begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	@(#)if_sl.c	5.2 (Berkeley) %G% */
end_comment

begin_comment
comment|/*  * Serial Line interface  *  * Rick Adams  * Center for Seismic Studies  * 1300 N 17th Street, Suite 1450  * Arlington, Virginia 22209  * (703)276-7900  * rick@seismo.ARPA  * seismo!rick  *  * Some things done here could obviously be done in a better way,  * but they were done this way to minimize the number of files  * that had to be changed to accomodate this device.  *  * Pounded on heavily by Chris Torek (chris@mimsy.umd.edu, umcp-cs!chris).  * N.B.: this belongs in netinet, not vaxif, the way it stands now.  * Should have a link-layer type designation, but wouldn't be  * backwards-compatible.  *  * Converted to 4.3BSD Beta by Chris Torek.  */
end_comment

begin_comment
comment|/* $Header: if_sl.c,v 1.12 85/12/20 21:54:55 chris Exp $ */
end_comment

begin_comment
comment|/* from if_sl.c,v 1.11 84/10/04 12:54:47 rick Exp */
end_comment

begin_include
include|#
directive|include
file|"sl.h"
end_include

begin_if
if|#
directive|if
name|NSL
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip_var.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_endif
endif|#
directive|endif
endif|vax
end_endif

begin_comment
comment|/*  * N.B.: SLMTU is now a hard limit on input packet size.  Some limit  * is required, lest we use up all mbufs in the case of deleterious data  * dribbling down the line.  */
end_comment

begin_define
define|#
directive|define
name|SLMTU
value|1006
end_define

begin_struct
struct|struct
name|sl_softc
block|{
name|struct
name|ifnet
name|sc_if
decl_stmt|;
comment|/* network-visible interface */
name|short
name|sc_flags
decl_stmt|;
comment|/* see below */
name|short
name|sc_ilen
decl_stmt|;
comment|/* length of input-packet-so-far */
name|struct
name|tty
modifier|*
name|sc_ttyp
decl_stmt|;
comment|/* pointer to tty structure */
name|char
modifier|*
name|sc_mp
decl_stmt|;
comment|/* pointer to next available buf char */
name|char
name|sc_buf
index|[
name|SLMTU
index|]
decl_stmt|;
comment|/* input buffer */
block|}
name|sl_softc
index|[
name|NSL
index|]
struct|;
end_struct

begin_comment
comment|/* flags */
end_comment

begin_define
define|#
directive|define
name|SC_ESCAPED
value|0x0001
end_define

begin_comment
comment|/* saw a FRAME_ESCAPE */
end_comment

begin_define
define|#
directive|define
name|SC_OACTIVE
value|0x0002
end_define

begin_comment
comment|/* output tty is active */
end_comment

begin_define
define|#
directive|define
name|FRAME_END
value|0300
end_define

begin_comment
comment|/* Frame End */
end_comment

begin_define
define|#
directive|define
name|FRAME_ESCAPE
value|0333
end_define

begin_comment
comment|/* Frame Esc */
end_comment

begin_define
define|#
directive|define
name|TRANS_FRAME_END
value|0334
end_define

begin_comment
comment|/* transposed frame end */
end_comment

begin_define
define|#
directive|define
name|TRANS_FRAME_ESCAPE
value|0335
end_define

begin_comment
comment|/* transposed frame esc */
end_comment

begin_define
define|#
directive|define
name|t_sc
value|T_LINEP
end_define

begin_decl_stmt
name|int
name|sloutput
argument_list|()
decl_stmt|,
name|slioctl
argument_list|()
decl_stmt|,
name|ttrstrt
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Called from boot code to establish sl interfaces.  */
end_comment

begin_macro
name|slattach
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sc
operator|=
name|sl_softc
init|;
name|i
operator|<
name|NSL
condition|;
name|sc
operator|++
control|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_name
operator|=
literal|"sl"
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|=
name|i
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|SLMTU
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|=
name|IFF_POINTOPOINT
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ioctl
operator|=
name|slioctl
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_output
operator|=
name|sloutput
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Line specific open routine.  * Attach the given tty to the first available sl unit.  */
end_comment

begin_macro
name|slopen
argument_list|(
argument|dev
argument_list|,
argument|tp
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|nsl
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_sc
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
for|for
control|(
name|nsl
operator|=
literal|0
operator|,
name|sc
operator|=
name|sl_softc
init|;
name|nsl
operator|<
name|NSL
condition|;
name|nsl
operator|++
operator|,
name|sc
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
operator|(
name|caddr_t
operator|)
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_ttyp
operator|=
name|tp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Line specific close routine.  * Detach the tty from the sl unit.  * Mimics part of ttyclose().  */
end_comment

begin_macro
name|slclose
argument_list|(
argument|tp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ttywflush
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* paranoid; splnet probably ok */
name|sc
operator|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|if_down
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ttyp
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
name|NULL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Line specific (tty) ioctl routine.  * Provide a way to get the sl unit number.  */
end_comment

begin_macro
name|sltioctl
argument_list|(
argument|tp
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cmd
operator|==
name|TIOCGETD
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
operator|)
operator|->
name|sc_if
operator|.
name|if_unit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Queue a packet.  Start transmission if not active.  */
end_comment

begin_expr_stmt
name|sloutput
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * `Cannot happen' (see slioctl).  Someday we will extend 	 * the line protocol to support other address families. 	 */
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|printf
argument_list|(
literal|"sl%d: af%d not supported\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
name|sc
operator|=
operator|&
name|sl_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* sort of */
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|slstart
argument_list|(
name|sc
operator|->
name|sc_ttyp
argument_list|)
expr_stmt|;
block|}
else|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Start output on interface.  Get another datagram  * to send from the interface queue and map it to  * the interface before starting output.  */
end_comment

begin_expr_stmt
name|slstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|mcp
decl_stmt|;
name|int
name|flush
decl_stmt|;
comment|/* 	 * If there is more in the output queue, just send it now. 	 * We are being called in lieu of ttstart and must do what 	 * it would. 	 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
literal|0
condition|)
block|{
name|ttstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * This happens briefly when the line shuts down. 	 */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Get a packet and map it to the interface. 	 */
name|c
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_OACTIVE
expr_stmt|;
name|splx
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|flush
operator|=
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_OACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_OACTIVE
expr_stmt|;
name|splx
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * The extra FRAME_END will start up a new packet, and thus 	 * will flush any accumulated garbage.  We do this whenever 	 * the line may have been idle for some time. 	 */
if|if
condition|(
name|flush
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|mcp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|mcp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|FRAME_ESCAPE
operator|||
name|c
operator|==
name|FRAME_END
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
name|FRAME_ESCAPE
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
goto|goto
name|full
goto|;
name|c
operator|=
name|c
operator|==
name|FRAME_ESCAPE
condition|?
name|TRANS_FRAME_ESCAPE
else|:
name|TRANS_FRAME_END
expr_stmt|;
if|if
condition|(
name|putc
argument_list|(
name|c
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
goto|goto
name|full
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|putc
argument_list|(
name|c
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
goto|goto
name|full
goto|;
block|}
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
name|full
label|:
comment|/* 		 * If you get many oerrors (more than one or two a day) 		 * you probably do not have enough clists and you should  		 * increase "nclist" in param.c. 		 */
operator|(
name|void
operator|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
comment|/* make room */
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
comment|/* end the packet */
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
comment|/* 	 * Start transmission.  Note that slstart, not ttstart, will be 	 * called when the transmission completes, be that after a single 	 * piece of what we have mapped, or be it after the entire thing 	 * has been sent.  That is why we need to check the output queue 	 * count at the top. 	 */
name|ttstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Copy data buffer to mbuf chain; add ifnet pointer ifp.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|sl_btom
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|,
name|ifp
parameter_list|)
specifier|register
name|caddr_t
name|addr
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mp
operator|=
name|m
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ifp
condition|)
block|{
name|m
operator|->
name|m_off
operator|+=
sizeof|sizeof
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|MLEN
operator|-
sizeof|sizeof
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>=
name|NBPG
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|p
decl_stmt|;
name|MCLGET
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|count
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|CLBYTES
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
operator|(
name|int
operator|)
name|p
operator|-
operator|(
name|int
operator|)
name|m
expr_stmt|;
block|}
else|else
name|count
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|MLEN
argument_list|)
expr_stmt|;
block|}
else|else
name|count
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|MLEN
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|addr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
block|{
name|m
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ifnet
operator|*
operator|*
argument_list|)
operator|=
name|ifp
expr_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
name|addr
operator|+=
name|count
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tty interface receiver interrupt.  */
end_comment

begin_expr_stmt
name|slinput
argument_list|(
name|c
argument_list|,
name|tp
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|c
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_ESCAPED
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_ESCAPED
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TRANS_FRAME_ESCAPE
case|:
name|c
operator|=
name|FRAME_ESCAPE
expr_stmt|;
break|break;
case|case
name|TRANS_FRAME_END
case|:
name|c
operator|=
name|FRAME_END
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|FRAME_END
case|:
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|0
condition|)
comment|/* ignore */
return|return;
name|m
operator|=
name|sl_btom
argument_list|(
name|sc
operator|->
name|sc_buf
argument_list|,
name|sc
operator|->
name|sc_ilen
argument_list|,
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ipintrq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ipintrq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_ENQUEUE
argument_list|(
operator|&
name|ipintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
case|case
name|FRAME_ESCAPE
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|SC_ESCAPED
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_ilen
operator|>=
name|SLMTU
condition|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
return|return;
block|}
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|slioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
else|else
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
case|case
name|SIOCSIFDSTADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

