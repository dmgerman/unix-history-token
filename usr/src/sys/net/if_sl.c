begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1987 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)if_sl.c	7.14 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Serial Line interface  *  * Rick Adams  * Center for Seismic Studies  * 1300 N 17th Street, Suite 1450  * Arlington, Virginia 22209  * (703)276-7900  * rick@seismo.ARPA  * seismo!rick  *  * Pounded on heavily by Chris Torek (chris@mimsy.umd.edu, umcp-cs!chris).  * N.B.: this belongs in netinet, not net, the way it stands now.  * Should have a link-layer type designation, but wouldn't be  * backwards-compatible.  *  * Converted to 4.3BSD Beta by Chris Torek.  * Other changes made at Berkeley, based in part on code by Kirk Smith.  */
end_comment

begin_comment
comment|/* $Header: if_sl.c,v 1.12 85/12/20 21:54:55 chris Exp $ */
end_comment

begin_comment
comment|/* from if_sl.c,v 1.11 84/10/04 12:54:47 rick Exp */
end_comment

begin_include
include|#
directive|include
file|"sl.h"
end_include

begin_if
if|#
directive|if
name|NSL
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"dk.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"if.h"
end_include

begin_include
include|#
directive|include
file|"netisr.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_if
if|#
directive|if
name|INET
end_if

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"machine/mtpr.h"
end_include

begin_comment
comment|/*  * N.B.: SLMTU is now a hard limit on input packet size.  * SLMTU must be<= MCLBYTES - sizeof(struct ifnet *).  */
end_comment

begin_define
define|#
directive|define
name|SLMTU
value|1006
end_define

begin_define
define|#
directive|define
name|SLIP_HIWAT
value|1000
end_define

begin_comment
comment|/* don't start a new packet if HIWAT on queue */
end_comment

begin_define
define|#
directive|define
name|CLISTRESERVE
value|1000
end_define

begin_comment
comment|/* Can't let clists get too low */
end_comment

begin_struct
struct|struct
name|sl_softc
block|{
name|struct
name|ifnet
name|sc_if
decl_stmt|;
comment|/* network-visible interface */
name|short
name|sc_flags
decl_stmt|;
comment|/* see below */
name|short
name|sc_ilen
decl_stmt|;
comment|/* length of input-packet-so-far */
name|struct
name|tty
modifier|*
name|sc_ttyp
decl_stmt|;
comment|/* pointer to tty structure */
name|char
modifier|*
name|sc_mp
decl_stmt|;
comment|/* pointer to next available buf char */
name|char
modifier|*
name|sc_buf
decl_stmt|;
comment|/* input buffer */
block|}
name|sl_softc
index|[
name|NSL
index|]
struct|;
end_struct

begin_comment
comment|/* flags */
end_comment

begin_define
define|#
directive|define
name|SC_ESCAPED
value|0x0001
end_define

begin_comment
comment|/* saw a FRAME_ESCAPE */
end_comment

begin_define
define|#
directive|define
name|FRAME_END
value|0300
end_define

begin_comment
comment|/* Frame End */
end_comment

begin_define
define|#
directive|define
name|FRAME_ESCAPE
value|0333
end_define

begin_comment
comment|/* Frame Esc */
end_comment

begin_define
define|#
directive|define
name|TRANS_FRAME_END
value|0334
end_define

begin_comment
comment|/* transposed frame end */
end_comment

begin_define
define|#
directive|define
name|TRANS_FRAME_ESCAPE
value|0335
end_define

begin_comment
comment|/* transposed frame esc */
end_comment

begin_define
define|#
directive|define
name|t_sc
value|T_LINEP
end_define

begin_decl_stmt
name|int
name|sloutput
argument_list|()
decl_stmt|,
name|slioctl
argument_list|()
decl_stmt|,
name|ttrstrt
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Called from boot code to establish sl interfaces.  */
end_comment

begin_macro
name|slattach
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sc
operator|=
name|sl_softc
init|;
name|i
operator|<
name|NSL
condition|;
name|sc
operator|++
control|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_name
operator|=
literal|"sl"
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|=
name|i
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|SLMTU
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|=
name|IFF_POINTOPOINT
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ioctl
operator|=
name|slioctl
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_output
operator|=
name|sloutput
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Line specific open routine.  * Attach the given tty to the first available sl unit.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|slopen
argument_list|(
argument|dev
argument_list|,
argument|tp
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|nsl
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|u
operator|.
name|u_cred
argument_list|,
operator|&
name|u
operator|.
name|u_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
name|SLIPDISC
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
for|for
control|(
name|nsl
operator|=
literal|0
operator|,
name|sc
operator|=
name|sl_softc
init|;
name|nsl
operator|<
name|NSL
condition|;
name|nsl
operator|++
operator|,
name|sc
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|slinit
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|tp
operator|->
name|t_sc
operator|=
operator|(
name|caddr_t
operator|)
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_ttyp
operator|=
name|tp
expr_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Line specific close routine.  * Detach the tty from the sl unit.  * Mimics part of ttyclose().  */
end_comment

begin_macro
name|slclose
argument_list|(
argument|tp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ttywflush
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* paranoid; splnet probably ok */
name|sc
operator|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|if_down
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ttyp
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
name|NULL
expr_stmt|;
name|MCLFREE
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|sc
operator|->
name|sc_buf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_buf
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Line specific (tty) ioctl routine.  * Provide a way to get the sl unit number.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|sltioctl
argument_list|(
argument|tp
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cmd
operator|==
name|TIOCGETD
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
operator|)
operator|->
name|sc_if
operator|.
name|if_unit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|TIOCMGET
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TIOCM_CAR
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Queue a packet.  Start transmission if not active.  */
end_comment

begin_expr_stmt
name|sloutput
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * `Cannot happen' (see slioctl).  Someday we will extend 	 * the line protocol to support other address families. 	 */
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|printf
argument_list|(
literal|"sl%d: af%d not supported\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
name|sc
operator|=
operator|&
name|sl_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* sort of */
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ttyp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|slstart
argument_list|(
name|sc
operator|->
name|sc_ttyp
argument_list|)
expr_stmt|;
block|}
else|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Start output on interface.  Get another datagram  * to send from the interface queue and map it to  * the interface before starting output.  */
end_comment

begin_expr_stmt
name|slstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|nd
decl_stmt|,
name|np
decl_stmt|,
name|n
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
specifier|extern
name|int
name|cfreecount
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * If there is more in the output queue, just send it now. 		 * We are being called in lieu of ttstart and must do what 		 * it would. 		 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
literal|0
condition|)
name|ttstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
name|SLIP_HIWAT
condition|)
return|return;
comment|/* 		 * This happens briefly when the line shuts down. 		 */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/* 		 * If system is getting low on clists 		 * and we have something running already, stop here. 		 */
if|if
condition|(
name|cfreecount
operator|<
name|CLISTRESERVE
operator|+
name|SLMTU
operator|&&
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
condition|)
return|return;
comment|/* 		 * Get a packet and send it to the interface. 		 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
comment|/* 		 * The extra FRAME_END will start up a new packet, and thus 		 * will flush any accumulated garbage.  We do this whenever 		 * the line may have been idle for some time. 		 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 				 * Find out how many bytes in the string we can 				 * handle without doing something special. 				 */
name|nd
operator|=
name|locc
argument_list|(
name|FRAME_ESCAPE
argument_list|,
name|len
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|np
operator|=
name|locc
argument_list|(
name|FRAME_END
argument_list|,
name|len
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
name|len
operator|-
name|MAX
argument_list|(
name|nd
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* 					 * Put n characters at once 					 * into the tty output queue. 					 */
if|if
condition|(
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|n
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
break|break;
name|len
operator|-=
name|n
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
comment|/* 				 * If there are characters left in the mbuf, 				 * the first one must be special.. 				 * Put it out in a different form. 				 */
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
name|FRAME_ESCAPE
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
break|break;
if|if
condition|(
name|putc
argument_list|(
operator|*
name|cp
operator|==
name|FRAME_ESCAPE
condition|?
name|TRANS_FRAME_ESCAPE
else|:
name|TRANS_FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
block|}
name|MFREE
argument_list|(
name|m
argument_list|,
name|m2
argument_list|)
expr_stmt|;
name|m
operator|=
name|m2
expr_stmt|;
block|}
if|if
condition|(
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
comment|/* 			 * Not enough room.  Remove a char to make room 			 * and end the packet normally. 			 * If you get many collisions (more than one or two 			 * a day) you probably do not have enough clists 			 * and you should increase "nclist" in param.c. 			 */
operator|(
name|void
operator|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|slinit
argument_list|(
name|sc
argument_list|)
specifier|register
expr|struct
name|sl_softc
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|caddr_t
name|p
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_buf
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|MCLALLOC
argument_list|(
name|p
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|sc
operator|->
name|sc_buf
operator|=
name|p
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"sl%d: can't allocate buffer\n"
argument_list|,
name|sc
operator|-
name|sl_softc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Copy data buffer to mbuf chain; add ifnet pointer ifp.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|sl_btom
parameter_list|(
name|sc
parameter_list|,
name|len
parameter_list|,
name|ifp
parameter_list|)
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|unsigned
name|count
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
name|cp
operator|=
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
block|}
else|else
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
comment|/* 		 * If we have at least MINCLSIZE bytes, 		 * allocate a new page.  Swap the current 		 * buffer page with the new one. 		 */
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|sc
operator|->
name|sc_buf
operator|=
name|cp
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
goto|goto
name|nocopy
goto|;
block|}
block|}
name|count
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|nocopy
label|:
name|m
operator|->
name|m_len
operator|=
name|count
expr_stmt|;
name|cp
operator|+=
name|count
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tty interface receiver interrupt.  */
end_comment

begin_expr_stmt
name|slinput
argument_list|(
name|c
argument_list|,
name|tp
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|s
decl_stmt|;
name|tk_nin
operator|++
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|c
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_ESCAPED
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_ESCAPED
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TRANS_FRAME_ESCAPE
case|:
name|c
operator|=
name|FRAME_ESCAPE
expr_stmt|;
break|break;
case|case
name|TRANS_FRAME_END
case|:
name|c
operator|=
name|FRAME_END
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|FRAME_END
case|:
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|0
condition|)
comment|/* ignore */
return|return;
name|m
operator|=
name|sl_btom
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ilen
argument_list|,
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ipintrq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ipintrq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_ENQUEUE
argument_list|(
operator|&
name|ipintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
case|case
name|FRAME_ESCAPE
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|SC_ESCAPED
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_ilen
operator|>
name|SLMTU
condition|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
return|return;
block|}
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|slioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
else|else
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
case|case
name|SIOCSIFDSTADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

