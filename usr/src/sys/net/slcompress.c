begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	@(#)slcompress.c	7.3 (Berkeley) %G%  *  *			THIS CODE IS NOT FOR DISTRIBUTION!  *	KEEP YOUR GRUBBY HANDS OFF UNLESS AUTHORIZED BY VAN JACOBSON TO COPY!  *			ASK SAM, MIKE, OR BILL ABOUT IT.  *  * Routines to compress and uncompess tcp packets (for transmission  * over low speed serial lines.  *  * Copyright (c) 1988, 1989 by Van Jacobson, Lawrence Berkeley Laboratory  * All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|"sl.h"
end_include

begin_if
if|#
directive|if
name|NSL
operator|>
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: slcompress.c,v 1.10 89/06/05 08:28:52 van Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SL_STATS
end_ifndef

begin_define
define|#
directive|define
name|INCR
parameter_list|(
name|counter
parameter_list|)
value|++comp->counter;
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INCR
parameter_list|(
name|counter
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BCMP
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|n
parameter_list|)
value|bcmp((char *)(p1), (char *)(p2), (int)(n))
end_define

begin_define
define|#
directive|define
name|BCOPY
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|n
parameter_list|)
value|bcopy((char *)(p1), (char *)(p2), (int)(n))
end_define

begin_function
name|void
name|sl_compress_init
parameter_list|(
name|comp
parameter_list|)
name|struct
name|slcompress
modifier|*
name|comp
decl_stmt|;
block|{
specifier|register
name|u_int
name|i
decl_stmt|;
specifier|register
name|struct
name|cstate
modifier|*
name|tstate
init|=
name|comp
operator|->
name|tstate
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|comp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MAX_STATES
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|tstate
index|[
name|i
index|]
operator|.
name|cs_id
operator|=
name|i
expr_stmt|;
name|tstate
index|[
name|i
index|]
operator|.
name|cs_next
operator|=
operator|&
name|tstate
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|tstate
index|[
literal|0
index|]
operator|.
name|cs_next
operator|=
operator|&
name|tstate
index|[
name|MAX_STATES
operator|-
literal|1
index|]
expr_stmt|;
name|tstate
index|[
literal|0
index|]
operator|.
name|cs_id
operator|=
literal|0
expr_stmt|;
name|comp
operator|->
name|last_cs
operator|=
operator|&
name|tstate
index|[
literal|0
index|]
expr_stmt|;
name|comp
operator|->
name|last_recv
operator|=
literal|255
expr_stmt|;
name|comp
operator|->
name|last_xmit
operator|=
literal|255
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ENCODE encodes a number that is known to be non-zero.  ENCODEZ  * checks for zero (since zero has to be encoded in the long, 3 byte  * form).  */
end_comment

begin_define
define|#
directive|define
name|ENCODE
parameter_list|(
name|n
parameter_list|)
value|{ \ 	if ((u_short)(n)>= 256) { \ 		*cp++ = 0; \ 		cp[1] = (n); \ 		cp[0] = (n)>> 8; \ 		cp += 2; \ 	} else { \ 		*cp++ = (n); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|ENCODEZ
parameter_list|(
name|n
parameter_list|)
value|{ \ 	if ((u_short)(n)>= 256 || (u_short)(n) == 0) { \ 		*cp++ = 0; \ 		cp[1] = (n); \ 		cp[0] = (n)>> 8; \ 		cp += 2; \ 	} else { \ 		*cp++ = (n); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DECODEL
parameter_list|(
name|f
parameter_list|)
value|{ \ 	if (*cp == 0) {\ 		(f) = htonl(ntohl(f) + ((cp[1]<< 8) | cp[2])); \ 		cp += 3; \ 	} else { \ 		(f) = htonl(ntohl(f) + (u_long)*cp++); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DECODES
parameter_list|(
name|f
parameter_list|)
value|{ \ 	if (*cp == 0) {\ 		(f) = htons(ntohs(f) + ((cp[1]<< 8) | cp[2])); \ 		cp += 3; \ 	} else { \ 		(f) = htons(ntohs(f) + (u_long)*cp++); \ 	} \ }
end_define

begin_function
name|u_char
name|sl_compress_tcp
parameter_list|(
name|m
parameter_list|,
name|ip
parameter_list|,
name|comp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|slcompress
modifier|*
name|comp
decl_stmt|;
block|{
specifier|register
name|struct
name|cstate
modifier|*
name|cs
init|=
name|comp
operator|->
name|last_cs
operator|->
name|cs_next
decl_stmt|;
specifier|register
name|u_int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|oth
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
specifier|register
name|u_int
name|deltaS
decl_stmt|,
name|deltaA
decl_stmt|;
specifier|register
name|u_int
name|changes
init|=
literal|0
decl_stmt|;
name|u_char
name|new_seq
index|[
literal|16
index|]
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
init|=
name|new_seq
decl_stmt|;
comment|/* 	 * Bail if this is an ip fragment or if we don't have 	 * a complete ip& tcp header in the first mbuf.  Otherwise, 	 * check flags to see if this is a packet we might compress  	 * and, if so, try to locate the connection state. 	 * special case the most recently used connection since 	 * it's most likely to be used again& we don't have to 	 * do any reordering if it's used. 	 */
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_off
operator|&
literal|0x3fff
operator|)
operator|||
name|m
operator|->
name|m_len
operator|<
literal|40
condition|)
return|return
operator|(
name|TYPE_IP
operator|)
return|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|int
operator|*
operator|)
name|ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator||
name|TH_RST
operator||
name|TH_ACK
operator|)
operator|)
operator|!=
name|TH_ACK
condition|)
return|return
operator|(
name|TYPE_IP
operator|)
return|;
name|INCR
argument_list|(
argument|sls_packets
argument_list|)
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_src
operator|.
name|s_addr
operator|||
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|!=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_dst
operator|.
name|s_addr
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|th
operator|!=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|cs
operator|->
name|cs_ip
operator|.
name|ip_hl
index|]
condition|)
block|{
comment|/* 		 * Wasn't the first -- search for it. 		 * 		 * States are kept in a circularly linked list with 		 * first_cs pointing to the head of the list.  The 		 * list is kept in lru order by moving a state to the 		 * head of the list whenever it is referenced.  Since 		 * the list is short and, empirically, the connection 		 * we want is almost always near the front, we locate 		 * states via linear search.  If we don't find a state 		 * for the datagram, the oldest state is used. 		 */
specifier|register
name|struct
name|cstate
modifier|*
name|lcs
decl_stmt|;
do|do
block|{
name|lcs
operator|=
name|cs
expr_stmt|;
name|cs
operator|=
name|cs
operator|->
name|cs_next
expr_stmt|;
name|INCR
argument_list|(
argument|sls_searches
argument_list|)
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|th
operator|==
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|cs
operator|->
name|cs_ip
operator|.
name|ip_hl
index|]
operator|&&
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|cs
operator|->
name|cs_ip
operator|.
name|ip_src
operator|.
name|s_addr
operator|&&
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|cs
operator|->
name|cs_ip
operator|.
name|ip_dst
operator|.
name|s_addr
condition|)
goto|goto
name|found
goto|;
block|}
do|while
condition|(
name|cs
operator|!=
name|comp
operator|->
name|last_cs
condition|)
do|;
name|INCR
argument_list|(
argument|sls_misses
argument_list|)
comment|/* 		 * Didn't find it -- re-use oldest cstate. 		 * Send an uncompressed packet that tells 		 * the other side what connection number 		 * we're using for this conversation.  Note 		 * that since the state list is circular, the 		 * oldest state points to the newest and we only 		 * need to set last_cs to update the lru linkage. 		 */
name|comp
operator|->
name|last_cs
operator|=
name|lcs
expr_stmt|;
name|hlen
operator|+=
name|th
operator|->
name|th_off
expr_stmt|;
name|hlen
operator|<<=
literal|2
expr_stmt|;
goto|goto
name|uncompressed
goto|;
name|found
label|:
comment|/* 		 * Found it -- move to the front on the connection list. 		 */
if|if
condition|(
name|comp
operator|->
name|last_cs
operator|==
name|cs
condition|)
name|comp
operator|->
name|last_cs
operator|=
name|lcs
expr_stmt|;
else|else
block|{
name|lcs
operator|->
name|cs_next
operator|=
name|cs
operator|->
name|cs_next
expr_stmt|;
name|cs
operator|->
name|cs_next
operator|=
name|comp
operator|->
name|last_cs
operator|->
name|cs_next
expr_stmt|;
name|comp
operator|->
name|last_cs
operator|->
name|cs_next
operator|=
name|cs
expr_stmt|;
block|}
block|}
comment|/* 	 * Make sure that only what we expect to change changed. 	 */
name|oth
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
name|deltaS
operator|=
name|hlen
expr_stmt|;
name|hlen
operator|+=
name|th
operator|->
name|th_off
expr_stmt|;
name|hlen
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|u_short
operator|*
operator|)
name|ip
operator|)
index|[
literal|0
index|]
operator|!=
operator|(
operator|(
name|u_short
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
literal|0
index|]
operator|||
operator|(
operator|(
name|u_short
operator|*
operator|)
name|ip
operator|)
index|[
literal|4
index|]
operator|!=
operator|(
operator|(
name|u_short
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
literal|4
index|]
operator|||
name|th
operator|->
name|th_off
operator|!=
name|oth
operator|->
name|th_off
operator|||
operator|(
name|deltaS
operator|>
literal|5
operator|&&
name|BCMP
argument_list|(
name|ip
operator|+
literal|1
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
operator|+
literal|1
argument_list|,
operator|(
name|deltaS
operator|-
literal|5
operator|)
operator|<<
literal|2
argument_list|)
operator|)
operator|||
operator|(
name|th
operator|->
name|th_off
operator|>
literal|5
operator|&&
name|BCMP
argument_list|(
name|th
operator|+
literal|1
argument_list|,
name|oth
operator|+
literal|1
argument_list|,
operator|(
name|th
operator|->
name|th_off
operator|-
literal|5
operator|)
operator|<<
literal|2
argument_list|)
operator|)
condition|)
goto|goto
name|uncompressed
goto|;
comment|/* 	 * Figure out which of the changing fields changed.  The 	 * receiver expects changes in the order: urgent, window, 	 * ack, seq (the order minimizes the number of temporaries 	 * needed in this section of code). 	 */
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_URG
condition|)
block|{
name|deltaS
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_urp
argument_list|)
expr_stmt|;
name|ENCODEZ
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_U
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|th
operator|->
name|th_urp
operator|!=
name|oth
operator|->
name|th_urp
condition|)
comment|/* argh! URG not set but urp changed -- a sensible 		 * implementation should never do this but RFC793 		 * doesn't prohibit the change so we have to deal 		 * with it.  */
goto|goto
name|uncompressed
goto|;
if|if
condition|(
name|deltaS
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ntohs
argument_list|(
name|th
operator|->
name|th_win
argument_list|)
operator|-
name|ntohs
argument_list|(
name|oth
operator|->
name|th_win
argument_list|)
argument_list|)
condition|)
block|{
name|ENCODE
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_W
expr_stmt|;
block|}
if|if
condition|(
name|deltaA
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|-
name|ntohl
argument_list|(
name|oth
operator|->
name|th_ack
argument_list|)
condition|)
block|{
if|if
condition|(
name|deltaA
operator|>
literal|0xffff
condition|)
goto|goto
name|uncompressed
goto|;
name|ENCODE
argument_list|(
name|deltaA
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_A
expr_stmt|;
block|}
if|if
condition|(
name|deltaS
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|-
name|ntohl
argument_list|(
name|oth
operator|->
name|th_seq
argument_list|)
condition|)
block|{
if|if
condition|(
name|deltaS
operator|>
literal|0xffff
condition|)
goto|goto
name|uncompressed
goto|;
name|ENCODE
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_S
expr_stmt|;
block|}
switch|switch
condition|(
name|changes
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|!=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
operator|&&
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|!=
name|hlen
condition|)
break|break;
comment|/* 		 * Nothing changed and this packet looks like a duplicate 		 * of the last or contains no data -- this is probably a 		 * retransmitted ack or window probe.  Send it 		 * uncompressed in case the other side missed the 		 * compressed version. 		 * 		 * (fall through) 		 */
case|case
name|SPECIAL_I
case|:
case|case
name|SPECIAL_D
case|:
comment|/* 		 * actual changes match one of our special case encodings -- 		 * send packet uncompressed. 		 */
goto|goto
name|uncompressed
goto|;
case|case
name|NEW_S
operator||
name|NEW_A
case|:
if|if
condition|(
name|deltaS
operator|==
name|deltaA
operator|&&
name|deltaS
operator|==
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|hlen
condition|)
block|{
comment|/* special case for echoed terminal traffic */
name|changes
operator|=
name|SPECIAL_I
expr_stmt|;
name|cp
operator|=
name|new_seq
expr_stmt|;
block|}
break|break;
case|case
name|NEW_S
case|:
if|if
condition|(
name|deltaS
operator|==
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|hlen
condition|)
block|{
comment|/* special case for data xfer */
name|changes
operator|=
name|SPECIAL_D
expr_stmt|;
name|cp
operator|=
name|new_seq
expr_stmt|;
block|}
break|break;
block|}
name|deltaS
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
operator|-
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaS
operator|!=
literal|1
condition|)
block|{
name|ENCODEZ
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_I
expr_stmt|;
block|}
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_PUSH
condition|)
name|changes
operator||=
name|TCP_PUSH_BIT
expr_stmt|;
comment|/* 	 * Grab the cksum before we overwrite it below.  Then update our 	 * state with this packet's header. 	 */
name|deltaA
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_sum
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|ip
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
comment|/* 	 * We want to use the original packet as our compressed packet. 	 * (cp - new_seq) is the number of bytes we need for compressed 	 * sequence numbers.  In addition we need one byte for the change 	 * mask, one for the connection id and two for the tcp checksum. 	 * So, (cp - new_seq) + 4 bytes of header are needed.  hlen is how 	 * many bytes of the original packet to toss so subtract the two to 	 * get the new packet size. 	 */
name|deltaS
operator|=
name|cp
operator|-
name|new_seq
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|last_xmit
operator|!=
name|cs
operator|->
name|cs_id
condition|)
block|{
name|comp
operator|->
name|last_xmit
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
name|hlen
operator|-=
name|deltaS
operator|+
literal|4
expr_stmt|;
name|cp
operator|+=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|hlen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|changes
operator||
name|NEW_C
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
block|}
else|else
block|{
name|hlen
operator|-=
name|deltaS
operator|+
literal|3
expr_stmt|;
name|cp
operator|+=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|hlen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|changes
expr_stmt|;
block|}
operator|*
name|cp
operator|++
operator|=
name|deltaA
operator|>>
literal|8
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|deltaA
expr_stmt|;
name|BCOPY
argument_list|(
name|new_seq
argument_list|,
name|cp
argument_list|,
name|deltaS
argument_list|)
expr_stmt|;
name|INCR
argument_list|(
argument|sls_compressed
argument_list|)
return|return
operator|(
name|TYPE_COMPRESSED_TCP
operator|)
return|;
comment|/* 	 * Update connection state cs& send uncompressed packet ('uncompressed' 	 * means a regular ip/tcp packet but with the 'conversation id' we hope 	 * to use on future compressed packets in the protocol field). 	 */
name|uncompressed
label|:
name|BCOPY
argument_list|(
name|ip
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
name|comp
operator|->
name|last_xmit
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
return|return
operator|(
name|TYPE_UNCOMPRESSED_TCP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sl_uncompress_tcp
parameter_list|(
name|bufp
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|,
name|comp
parameter_list|)
name|u_char
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_int
name|type
decl_stmt|;
name|struct
name|slcompress
modifier|*
name|comp
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|u_int
name|hlen
decl_stmt|,
name|changes
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
specifier|register
name|struct
name|cstate
modifier|*
name|cs
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_UNCOMPRESSED_TCP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|*
name|bufp
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|>=
name|MAX_STATES
condition|)
block|{
name|INCR
argument_list|(
argument|sls_errorin
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cs
operator|=
operator|&
name|comp
operator|->
name|rstate
index|[
name|comp
operator|->
name|last_recv
operator|=
name|ip
operator|->
name|ip_p
index|]
expr_stmt|;
name|comp
operator|->
name|flags
operator|&=
operator|~
name|SLF_TOSS
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
expr_stmt|;
name|hlen
operator|+=
operator|(
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|int
operator|*
operator|)
name|ip
operator|)
index|[
name|hlen
index|]
operator|)
operator|->
name|th_off
expr_stmt|;
name|hlen
operator|<<=
literal|2
expr_stmt|;
name|BCOPY
argument_list|(
name|ip
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_ip
operator|.
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|cs_hlen
operator|=
name|hlen
expr_stmt|;
name|INCR
argument_list|(
argument|sls_uncompressedin
argument_list|)
return|return
operator|(
name|len
operator|)
return|;
case|case
name|TYPE_ERROR
case|:
name|comp
operator|->
name|flags
operator||=
name|SLF_TOSS
expr_stmt|;
default|default:
name|INCR
argument_list|(
argument|sls_errorin
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TYPE_COMPRESSED_TCP
case|:
break|break;
block|}
comment|/* We've got a compressed packet. */
name|INCR
argument_list|(
argument|sls_compressedin
argument_list|)
name|cp
operator|=
operator|*
name|bufp
expr_stmt|;
name|changes
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|NEW_C
condition|)
block|{
comment|/* Make sure the state index is in range, then grab the state. 		 * If we have a good state index, clear the 'discard' flag. */
if|if
condition|(
operator|*
name|cp
operator|>=
name|MAX_STATES
condition|)
block|{
name|INCR
argument_list|(
argument|sls_errorin
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|comp
operator|->
name|flags
operator|&=
operator|~
name|SLF_TOSS
expr_stmt|;
name|comp
operator|->
name|last_recv
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* this packet has an implicit state index.  If we've 		 * had a line error since the last time we got an 		 * explicit state index, we have to toss the packet. */
if|if
condition|(
name|comp
operator|->
name|flags
operator|&
name|SLF_TOSS
condition|)
block|{
name|INCR
argument_list|(
argument|sls_tossed
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|cs
operator|=
operator|&
name|comp
operator|->
name|rstate
index|[
name|comp
operator|->
name|last_recv
index|]
expr_stmt|;
name|hlen
operator|=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|htons
argument_list|(
operator|(
operator|*
name|cp
operator|<<
literal|8
operator|)
operator||
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|TCP_PUSH_BIT
condition|)
name|th
operator|->
name|th_flags
operator||=
name|TH_PUSH
expr_stmt|;
else|else
name|th
operator|->
name|th_flags
operator|&=
operator|~
name|TH_PUSH
expr_stmt|;
switch|switch
condition|(
name|changes
operator|&
name|SPECIALS_MASK
condition|)
block|{
case|case
name|SPECIAL_I
case|:
block|{
specifier|register
name|u_int
name|i
init|=
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|cs
operator|->
name|cs_hlen
decl_stmt|;
name|th
operator|->
name|th_ack
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPECIAL_D
case|:
name|th
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|cs
operator|->
name|cs_hlen
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|changes
operator|&
name|NEW_U
condition|)
block|{
name|th
operator|->
name|th_flags
operator||=
name|TH_URG
expr_stmt|;
name|DECODES
argument_list|(
argument|th->th_urp
argument_list|)
block|}
else|else
name|th
operator|->
name|th_flags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|NEW_W
condition|)
name|DECODES
argument_list|(
argument|th->th_win
argument_list|)
if|if
condition|(
name|changes
operator|&
name|NEW_A
condition|)
name|DECODEL
argument_list|(
argument|th->th_ack
argument_list|)
if|if
condition|(
name|changes
operator|&
name|NEW_S
condition|)
name|DECODEL
argument_list|(
argument|th->th_seq
argument_list|)
break|break;
block|}
if|if
condition|(
name|changes
operator|&
name|NEW_I
condition|)
block|{
name|DECODES
argument_list|(
argument|cs->cs_ip.ip_id
argument_list|)
block|}
else|else
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * At this point, cp points to the first byte of data in the 	 * packet.  If we're not aligned on a 4-byte boundary, copy the 	 * data down so the ip& tcp headers will be aligned.  Then back up 	 * cp by the tcp/ip header length to make room for the reconstructed 	 * header (we assume the packet we were handed has enough space to 	 * prepend 128 bytes of header).  Adjust the lenth to account for 	 * the new header& fill in the IP total length. 	 */
name|len
operator|-=
operator|(
name|cp
operator|-
operator|*
name|bufp
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
comment|/* we must have dropped some characters (crc should detect 		 * this but the old slip framing won't) */
name|INCR
argument_list|(
argument|sls_errorin
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|&&
operator|(
operator|(
name|int
operator|)
name|cp
operator|&
operator|~
literal|3
operator|)
operator|!=
operator|(
name|int
operator|)
name|cp
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|cp
operator|&
operator|~
literal|3
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|cp
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
block|}
name|cp
operator|-=
name|cs
operator|->
name|cs_hlen
expr_stmt|;
name|len
operator|+=
name|cs
operator|->
name|cs_hlen
expr_stmt|;
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|cp
argument_list|,
name|cs
operator|->
name|cs_hlen
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|=
name|cp
expr_stmt|;
comment|/* recompute the ip header checksum */
block|{
specifier|register
name|u_short
modifier|*
name|bp
init|=
operator|(
name|u_short
operator|*
operator|)
name|cp
decl_stmt|;
for|for
control|(
name|changes
operator|=
literal|0
init|;
name|hlen
operator|>
literal|0
condition|;
name|hlen
operator|-=
literal|2
control|)
name|changes
operator|+=
operator|*
name|bp
operator|++
expr_stmt|;
name|changes
operator|=
operator|(
name|changes
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|changes
operator|>>
literal|16
operator|)
expr_stmt|;
name|changes
operator|=
operator|(
name|changes
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|changes
operator|>>
literal|16
operator|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|cp
operator|)
operator|->
name|ip_sum
operator|=
operator|~
name|changes
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

