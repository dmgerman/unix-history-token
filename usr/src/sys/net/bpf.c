begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * This code is derived from the Stanford/CMU enet packet filter,  * (net/enet.c) distributed in 4.3BSD Unix.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: bpf.c,v 1.23 91/01/30 18:22:13 mccanne Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
operator|(
name|NBPFILTER
operator|>
literal|0
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
define|#
directive|define
name|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/map.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_define
define|#
directive|define
name|PRINET
value|26
end_define

begin_comment
comment|/* interruptible */
end_comment

begin_comment
comment|/*  *  'bpf_iftab' is the driver state table per logical unit number  *  'bpf_dtab' holds the descriptors, indexed by minor device #  *  'bpf_units' is the number of attached units  *  * We really don't need NBPFILTER bpf_if entries, but this eliminates  * the need to account for all possible drivers here.  * This problem will go away when these structures are allocated dynamically.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bpf_if
name|bpf_iftab
index|[
name|NBPFILTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bpf_d
name|bpf_dtab
index|[
name|NBPFILTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|bpf_units
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|bpf_timeout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bpf_ifname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|catchpacket
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bpf_setif
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bpf_initd
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * The default filter accepts the maximum number of bytes from each packet.  */
end_comment

begin_decl_stmt
name|struct
name|bpf_insn
name|bpf_default_filter
index|[]
init|=
block|{
name|BPF_STMT
argument_list|(
name|RetOp
argument_list|,
name|MCLBYTES
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This routine was inspired by/stolen from ../sys/uipc_socket.c  * Move data from 'm' to user's read buffer.    * We assume 'm' is not chained.  * Returns error code (or 0 if success).  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|bpf_moveout
parameter_list|(
name|m
parameter_list|,
name|uio
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
name|len
condition|)
name|len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
return|return
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_movein
parameter_list|(
name|uio
parameter_list|,
name|linktype
parameter_list|,
name|mp
parameter_list|,
name|sockp
parameter_list|)
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|linktype
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|sockaddr
modifier|*
name|sockp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hlen
decl_stmt|;
comment|/* 	 * Build a sockaddr based on the data link layer type. 	 * We do this at this level because the ethernet header 	 * is copied directly into the data field of the sockaddr. 	 * In the case of SLIP, there is no header and the packet 	 * is forwarded as is. 	 * Also, we are careful to leave room at the front of the mbuf 	 * for the link level header. 	 */
switch|switch
condition|(
name|linktype
condition|)
block|{
case|case
name|DLT_SLIP
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DLT_EN10MB
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
comment|/* XXX Would MAXLINKHDR be better? */
name|hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
break|break;
case|case
name|DLT_FDDI
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
comment|/* XXX 4(FORMAC)+6(dst)+6(src)+3(LLC)+5(SNAP) */
name|hlen
operator|=
literal|24
expr_stmt|;
break|break;
default|default:
return|return
name|EIO
return|;
block|}
name|len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|len
operator|>
name|MCLBYTES
condition|)
return|return
name|EIO
return|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
name|ENOBUFS
return|;
if|if
condition|(
name|len
operator|>
name|MLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|MCLBYTES
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
comment|/* 	 * Make room for link header. 	 */
if|if
condition|(
name|hlen
condition|)
block|{
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_off
operator|+=
name|hlen
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|sockp
operator|->
name|sa_data
argument_list|,
name|hlen
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
operator|-
name|hlen
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
return|return
literal|0
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Attach 'd' to the bpf interface 'bp', i.e. make 'd' listen on 'bp'.  * Must be called at splimp.  */
end_comment

begin_function
specifier|static
name|void
name|bpf_attachd
parameter_list|(
name|d
parameter_list|,
name|bp
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
block|{
comment|/* Point 'd' at 'bp'. */
name|d
operator|->
name|bd_bif
operator|=
name|bp
expr_stmt|;
comment|/* Add 'd' to 'bp's list of listeners. */
name|d
operator|->
name|bd_next
operator|=
name|bp
operator|->
name|bif_dlist
expr_stmt|;
name|bp
operator|->
name|bif_dlist
operator|=
name|d
expr_stmt|;
comment|/* 	 * Let the driver know we're here (if it doesn't already). 	 */
operator|*
name|bp
operator|->
name|bif_driverp
operator|=
name|bp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bpf_detachd
parameter_list|(
name|d
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
name|struct
name|bpf_d
modifier|*
modifier|*
name|p
decl_stmt|;
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|d
operator|->
name|bd_bif
expr_stmt|;
comment|/* 	 * Check if this descriptor had requested promiscuous mode. 	 * If so, turn it off. 	 */
if|if
condition|(
name|d
operator|->
name|bd_promisc
condition|)
block|{
name|d
operator|->
name|bd_promisc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifpromisc
argument_list|(
name|bp
operator|->
name|bif_ifp
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* 			 * Something is really wrong if we were able to put 			 * the driver into promiscuous mode, but can't 			 * take it out. 			 */
name|panic
argument_list|(
literal|"bpf_detachd: exit promisc unsucessful"
argument_list|)
expr_stmt|;
block|}
comment|/* Remove 'd' from the interface's descriptor list. */
name|p
operator|=
operator|&
name|bp
operator|->
name|bif_dlist
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|d
condition|)
block|{
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|bd_next
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"bpf_detachd: descriptor not in list"
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|bd_next
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bif_dlist
operator|==
literal|0
condition|)
comment|/* 		 * Let the driver know that there are no more listeners. 		 */
operator|*
name|d
operator|->
name|bd_bif
operator|->
name|bif_driverp
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_bif
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark a descriptor free by making it point to itself.   * This is probably cheaper than marking with a constant since  * the address should be in a register anyway.  */
end_comment

begin_define
define|#
directive|define
name|D_ISFREE
parameter_list|(
name|d
parameter_list|)
value|((d) == (d)->bd_next)
end_define

begin_define
define|#
directive|define
name|D_MARKFREE
parameter_list|(
name|d
parameter_list|)
value|((d)->bd_next = (d))
end_define

begin_define
define|#
directive|define
name|D_MARKUSED
parameter_list|(
name|d
parameter_list|)
value|((d)->bd_next = 0)
end_define

begin_comment
comment|/*  *  bpfopen - open ethernet device  *  *  Errors:	ENXIO	- illegal minor device number  *		EBUSY	- too many files open  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|bpfopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
name|NBPFILTER
condition|)
return|return
name|ENXIO
return|;
comment|/* 	 * Each minor can be opened by only one process.  If the requested 	 * minor is in use, return EBUSY. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|d
operator|=
operator|&
name|bpf_dtab
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|D_ISFREE
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
else|else
comment|/* Mark "free" and do most initialization. */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_filter
operator|=
name|bpf_default_filter
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|bpf_initd
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D_MARKFREE
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Close the descriptor by detaching it from its interface,  * deallocating its buffers, and marking it free.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|bpfclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|&
name|bpf_dtab
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
condition|)
name|bpf_detachd
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Let the buffers go. */
name|m_freem
argument_list|(
name|d
operator|->
name|bd_hbuf
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|d
operator|->
name|bd_sbuf
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|d
operator|->
name|bd_fbuf
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|d
operator|->
name|bd_filterm
argument_list|)
expr_stmt|;
name|D_MARKFREE
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|RS_IDLE
value|0
end_define

begin_define
define|#
directive|define
name|RS_WAIT
value|1
end_define

begin_define
define|#
directive|define
name|RS_TIMEDOUT
value|2
end_define

begin_comment
comment|/*  *  bpfread - read next chunk of packets from buffers  */
end_comment

begin_function
name|int
name|bpfread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|&
name|bpf_dtab
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Restrict application to use a buffer the same size as  	 * as kernel buffers. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|!=
name|MCLBYTES
condition|)
return|return
name|EIO
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * If the hold buffer is empty, then set a timer and sleep 	 * until either the timeout has occurred or enough packets have 	 * arrived to fill the store buffer. 	 */
while|while
condition|(
name|d
operator|->
name|bd_hbuf
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_immediate
operator|&&
name|d
operator|->
name|bd_sbuf
operator|->
name|m_len
condition|)
block|{
comment|/* 			 * A packet(s) either arrived since the previous 			 * read or arrived while we were asleep. 			 * Rotate the buffers and return what's here. 			 */
name|d
operator|->
name|bd_hbuf
operator|=
name|d
operator|->
name|bd_sbuf
expr_stmt|;
name|d
operator|->
name|bd_sbuf
operator|=
name|d
operator|->
name|bd_fbuf
expr_stmt|;
name|d
operator|->
name|bd_sbuf
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_fbuf
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|d
operator|->
name|bd_rtout
condition|)
block|{
comment|/* 			 * If there was a previous timeout pending for this  			 * file, cancel it before setting another.  This is 			 * necessary since a cancel after the sleep might  			 * never happen if the read is interrupted by a signal. 			 */
if|if
condition|(
name|d
operator|->
name|bd_state
operator|==
name|RS_WAIT
condition|)
name|untimeout
argument_list|(
name|bpf_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|bpf_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|d
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|bd_rtout
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_state
operator|=
name|RS_WAIT
expr_stmt|;
block|}
else|else
name|d
operator|->
name|bd_state
operator|=
name|RS_IDLE
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|,
name|PRINET
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_state
operator|==
name|RS_WAIT
condition|)
block|{
name|untimeout
argument_list|(
name|bpf_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_state
operator|=
name|RS_IDLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|bd_state
operator|==
name|RS_TIMEDOUT
condition|)
block|{
comment|/* 			 * On a timeout, return what's in the buffer, 			 * which may be nothing.  We do this by moving 			 * the store buffer into the hold slot. 			 */
if|if
condition|(
name|d
operator|->
name|bd_hbuf
condition|)
comment|/* 				 * We filled up the buffer in between  				 * getting the timeout and arriving 				 * here, so we don't need to rotate. 				 */
break|break;
if|if
condition|(
name|d
operator|->
name|bd_sbuf
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|d
operator|->
name|bd_hbuf
operator|=
name|d
operator|->
name|bd_sbuf
expr_stmt|;
name|d
operator|->
name|bd_sbuf
operator|=
name|d
operator|->
name|bd_fbuf
expr_stmt|;
name|d
operator|->
name|bd_sbuf
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_fbuf
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * At this point, we know we have something in the hold slot. 	 */
name|m
operator|=
name|d
operator|->
name|bd_hbuf
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*   	 * Move data from hold buffer into user space. 	 * We know the entire buffer is transferred since 	 * we checked above that the read buffer is MCLBYTES. 	 */
name|error
operator|=
name|bpf_moveout
argument_list|(
name|m
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_fbuf
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"bpfread: free mbuf slot occupied"
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_fbuf
operator|=
name|m
expr_stmt|;
name|d
operator|->
name|bd_hbuf
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * If there are processes select sleeping on this descriptor,  * wake them up.    */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bpf_wakeup
parameter_list|(
name|d
parameter_list|)
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
if|if
condition|(
name|d
operator|->
name|bd_SelProc
condition|)
block|{
name|selwakeup
argument_list|(
name|d
operator|->
name|bd_SelProc
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|bd_SelColl
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_SelColl
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_SelProc
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  bpf_timeout - process ethernet read timeout  */
end_comment

begin_function
specifier|static
name|int
name|bpf_timeout
parameter_list|(
name|d
parameter_list|)
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
specifier|register
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|d
operator|->
name|bd_state
operator|=
name|RS_TIMEDOUT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
name|bpf_wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bpfwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|&
name|bpf_dtab
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
specifier|static
name|struct
name|sockaddr
name|dst
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
name|ifp
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
name|ifp
operator|->
name|if_mtu
condition|)
return|return
name|EMSGSIZE
return|;
name|error
operator|=
name|bpf_movein
argument_list|(
name|uio
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|bd_bif
operator|->
name|bif_devp
operator|.
name|bdev_type
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * The driver frees the mbuf.  	 */
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Reset a descriptor by flushing its packet before  * and clearing the receive and drop counts.  Should  * be called at splimp.  */
end_comment

begin_function
specifier|static
name|void
name|reset_d
parameter_list|(
name|d
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
if|if
condition|(
name|d
operator|->
name|bd_hbuf
condition|)
block|{
comment|/* Free the hold buffer. */
name|d
operator|->
name|bd_fbuf
operator|=
name|d
operator|->
name|bd_hbuf
expr_stmt|;
name|d
operator|->
name|bd_hbuf
operator|=
literal|0
expr_stmt|;
block|}
name|d
operator|->
name|bd_sbuf
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_rcount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_dcount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  bpfioctl - packet filter control  *  *  FIONREAD		Check for read packet available.  *  SIOCGIFADDR		Get interface address - convenient hook to driver.  *  BIOCGFLEN		Get max filter len.  *  BIOCGBLEN		Get buffer len [for read()].  *  BIOCSETF		Set ethernet read filter.  *  BIOCFLUSH		Flush read packet buffer.  *  BIOCPROMISC		Put interface into promiscuous mode.  *  BIOCDEVP		Get device parameters.  *  BIOCGETIF		Get interface name.  *  BIOCSETIF		Set interface.  *  BIOCSRTIMEOUT	Set read timeout.  *  BIOCGRTIMEOUT	Get read timeout.  *  BIOCGSTATS		Get packet stats.  *  BIOCIMMEDIATE	Set immediate mode.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|bpfioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|addr
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|&
name|bpf_dtab
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
comment|/* 	 * Check for read packet available. 	 */
case|case
name|FIONREAD
case|:
block|{
name|int
name|n
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|n
operator|=
name|d
operator|->
name|bd_sbuf
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_hbuf
condition|)
name|n
operator|+=
name|d
operator|->
name|bd_hbuf
operator|->
name|m_len
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|n
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGIFADDR
case|:
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|ifp
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	 * Get max filter len. 	 */
case|case
name|BIOCGFLEN
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|MCLBYTES
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|bpf_insn
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Get buffer len [for read()]. 	 */
case|case
name|BIOCGBLEN
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|MCLBYTES
expr_stmt|;
break|break;
comment|/* 	 * Set ethernet read filter. 	 */
case|case
name|BIOCSETF
case|:
name|error
operator|=
name|bpf_setf
argument_list|(
name|d
argument_list|,
operator|(
expr|struct
name|bpf_program
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Flush read packet buffer. 	 */
case|case
name|BIOCFLUSH
case|:
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Put interface into promiscuous mode. 	 */
case|case
name|BIOCPROMISC
case|:
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No interface attached yet. 			 */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_promisc
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|bd_promisc
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|ifpromisc
argument_list|(
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Get device parameters. 	 */
case|case
name|BIOCDEVP
case|:
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
operator|*
operator|(
expr|struct
name|bpf_devp
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_devp
expr_stmt|;
break|break;
comment|/* 	 * Set interface name. 	 */
case|case
name|BIOCGETIF
case|:
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|bpf_ifname
argument_list|(
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set interface. 	 */
case|case
name|BIOCSETIF
case|:
name|error
operator|=
name|bpf_setif
argument_list|(
name|d
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set read timeout. 	 */
case|case
name|BIOCSRTIMEOUT
case|:
block|{
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|addr
decl_stmt|;
name|u_long
name|msec
decl_stmt|;
comment|/* Compute number of milliseconds. */
name|msec
operator|=
name|tv
operator|->
name|tv_sec
operator|*
literal|1000
operator|+
name|tv
operator|->
name|tv_usec
operator|/
literal|1000
expr_stmt|;
comment|/* Scale milliseconds to ticks.  Assume hard 			   clock has millisecond or greater resolution 			   (i.e. tick>= 1000).  For 10ms hardclock, 			   tick/1000 = 10, so rtout<-msec/10. */
name|d
operator|->
name|bd_rtout
operator|=
name|msec
operator|/
operator|(
name|tick
operator|/
literal|1000
operator|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Get read timeout. 	 */
case|case
name|BIOCGRTIMEOUT
case|:
block|{
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|addr
decl_stmt|;
name|u_long
name|msec
init|=
name|d
operator|->
name|bd_rtout
decl_stmt|;
name|msec
operator|*=
name|tick
operator|/
literal|1000
expr_stmt|;
name|tv
operator|->
name|tv_sec
operator|=
name|msec
operator|/
literal|1000
expr_stmt|;
name|tv
operator|->
name|tv_usec
operator|=
name|msec
operator|%
literal|1000
expr_stmt|;
break|break;
block|}
comment|/* 	 * Get packet stats. 	 */
case|case
name|BIOCGSTATS
case|:
block|{
name|struct
name|bpf_stat
modifier|*
name|bs
init|=
operator|(
expr|struct
name|bpf_stat
operator|*
operator|)
name|addr
decl_stmt|;
name|bs
operator|->
name|bs_recv
operator|=
name|d
operator|->
name|bd_rcount
expr_stmt|;
name|bs
operator|->
name|bs_drop
operator|=
name|d
operator|->
name|bd_dcount
expr_stmt|;
break|break;
block|}
comment|/* 	 * Set immediate mode. 	 */
case|case
name|BIOCIMMEDIATE
case|:
name|d
operator|->
name|bd_immediate
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*   * Set d's packet filter program to 'fp'.  If 'd' already has a filter,  * free it and replace it.  Returns an appropriate ioctl error code.  */
end_comment

begin_function
name|int
name|bpf_setf
parameter_list|(
name|d
parameter_list|,
name|fp
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|struct
name|bpf_program
modifier|*
name|fp
decl_stmt|;
block|{
name|struct
name|bpf_insn
modifier|*
name|fcode
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|flen
decl_stmt|,
name|size
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|bf_insns
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|bf_len
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|d
operator|->
name|bd_filterm
condition|)
name|m_freem
argument_list|(
name|d
operator|->
name|bd_filterm
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_filterm
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_filter
operator|=
name|bpf_default_filter
expr_stmt|;
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|flen
operator|=
name|fp
operator|->
name|bf_len
expr_stmt|;
name|size
operator|=
name|flen
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fp
operator|->
name|bf_insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|MCLBYTES
condition|)
return|return
name|EINVAL
return|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
name|ENOBUFS
return|;
if|if
condition|(
name|size
operator|>
name|MLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|MCLBYTES
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
block|}
name|fcode
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|bpf_insn
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|fp
operator|->
name|bf_insns
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|fcode
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|bpf_validate
argument_list|(
name|fcode
argument_list|,
operator|(
name|int
operator|)
name|flen
argument_list|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_filterm
condition|)
name|m_freem
argument_list|(
name|d
operator|->
name|bd_filterm
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_filterm
operator|=
name|m
expr_stmt|;
name|d
operator|->
name|bd_filter
operator|=
name|fcode
expr_stmt|;
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/*  * Detach 'd' from its current interface (if attached at all) and attach to   * the interface named 'name'.  Return ioctl error code or 0.  */
end_comment

begin_function
specifier|static
name|int
name|bpf_setif
parameter_list|(
name|d
parameter_list|,
name|ifr
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|;
comment|/* 	 * Separate string into name part and unit number.  Put a null 	 * byte at the end of the name part, and compute the number.  	 * If the a unit number is unspecified, the default is 0, 	 * as initialized above. 	 */
name|unit
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|ifr
operator|->
name|ifr_name
expr_stmt|;
name|cp
index|[
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|>=
literal|'0'
operator|&&
operator|*
name|cp
operator|<=
literal|'9'
condition|)
block|{
name|unit
operator|=
operator|*
name|cp
operator|-
literal|'0'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|unit
operator|=
literal|10
operator|*
name|unit
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Look through attached interfaces for the named one. 	 */
name|bp
operator|=
name|bpf_iftab
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBPFILTER
condition|;
operator|++
name|bp
operator|,
operator|++
name|i
control|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|bp
operator|->
name|bif_ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
operator|||
name|unit
operator|!=
name|ifp
operator|->
name|if_unit
operator|||
name|strcmp
argument_list|(
name|ifp
operator|->
name|if_name
argument_list|,
name|ifr
operator|->
name|ifr_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* 		 * We found the requested interface.  If we're 		 * already attached to it, just flush the buffer. 		 * If it's not up, return an error. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
return|return
name|ENETDOWN
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|d
operator|->
name|bd_bif
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_bif
condition|)
comment|/*  				 * Detach if attached to  something else. 				 */
name|bpf_detachd
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|bpf_attachd
argument_list|(
name|d
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Not found. */
return|return
name|ENXIO
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the name of the 'ifp' interface and return it in 'ifr->ifr_name'.  * We augment the ifp's base name with its unit number.  */
end_comment

begin_function
specifier|static
name|void
name|bpf_ifname
parameter_list|(
name|ifp
parameter_list|,
name|ifr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|ifp
operator|->
name|if_name
decl_stmt|;
name|char
modifier|*
name|d
init|=
name|ifr
operator|->
name|ifr_name
decl_stmt|;
while|while
condition|(
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
comment|/* Assume that unit number is less than 10. */
operator|*
name|d
operator|++
operator|=
name|ifp
operator|->
name|if_unit
operator|+
literal|'0'
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Support for select() system call  * Inspired by the code in tty.c for the same purpose.  *  * bpfselect - returns true iff the specific operation  *	will not block indefinitely.  Otherwise, return  *	false but make a note that a selwakeup() must be done.  */
end_comment

begin_function
name|int
name|bpfselect
parameter_list|(
name|dev
parameter_list|,
name|rw
parameter_list|)
specifier|register
name|dev_t
name|dev
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
if|if
condition|(
name|rw
operator|!=
name|FREAD
condition|)
return|return
literal|0
return|;
comment|/* 	 * An imitation of the FIONREAD ioctl code. 	 */
name|d
operator|=
operator|&
name|bpf_dtab
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_sbuf
operator|->
name|m_len
operator|||
name|d
operator|->
name|bd_hbuf
operator|&&
name|d
operator|->
name|bd_hbuf
operator|->
name|m_len
condition|)
block|{
comment|/* 		 * There is data waiting. 		 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * No data ready.  If there's already a select() waiting on this 	 * minor device then this is a collision.  This shouldn't happen  	 * because minors really should not be shared, but if a process 	 * forks while one of these is open, it is possible that both 	 * processes could select on the same descriptor. 	 */
if|if
condition|(
name|d
operator|->
name|bd_SelProc
operator|&&
name|d
operator|->
name|bd_SelProc
operator|->
name|p_wchan
operator|==
operator|(
name|caddr_t
operator|)
operator|&
name|selwait
condition|)
name|d
operator|->
name|bd_SelColl
operator|=
literal|1
expr_stmt|;
else|else
name|d
operator|->
name|bd_SelProc
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * bpf_tap - incoming linkage from device drivers  */
end_comment

begin_function
name|void
name|bpf_tap
parameter_list|(
name|arg
parameter_list|,
name|pbuf
parameter_list|,
name|plen
parameter_list|)
name|caddr_t
name|arg
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|pbuf
decl_stmt|;
specifier|register
name|u_int
name|plen
decl_stmt|;
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
specifier|register
name|u_int
name|slen
decl_stmt|;
extern|extern bcopy(
block|)
function|;
end_function

begin_comment
comment|/* 	 * Note that the ipl does not have to be raised at this point. 	 * The only problem that could arise here is that if two different 	 * interfaces shared any data.  This is not the case. 	 */
end_comment

begin_expr_stmt
name|bp
operator|=
operator|(
expr|struct
name|bpf_if
operator|*
operator|)
name|arg
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|d
operator|=
name|bp
operator|->
name|bif_dlist
init|;
name|d
operator|!=
literal|0
condition|;
name|d
operator|=
name|d
operator|->
name|bd_next
control|)
block|{
operator|++
name|d
operator|->
name|bd_rcount
expr_stmt|;
name|slen
operator|=
name|bpf_filter
argument_list|(
name|d
operator|->
name|bd_filter
argument_list|,
name|pbuf
argument_list|,
name|plen
argument_list|,
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|!=
literal|0
condition|)
name|catchpacket
argument_list|(
name|d
argument_list|,
name|pbuf
argument_list|,
name|plen
argument_list|,
name|slen
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|bcopy
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
unit|}
comment|/*  * Copy data from an mbuf chain into a buffer.  This code is derived  * from m_copydata in sys/uipc_mbuf.c.  */
end_comment

begin_function
unit|static
name|void
name|bpf_m_copydata
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|len
parameter_list|)
name|u_char
modifier|*
name|src
decl_stmt|;
name|u_char
modifier|*
name|dst
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|src
decl_stmt|;
specifier|register
name|unsigned
name|count
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"bpf_m_copydata"
argument_list|)
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|dst
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
name|dst
operator|+=
name|count
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Length of ethernet and TCP/IP header header with no IP options.  */
end_comment

begin_define
define|#
directive|define
name|BPF_MIN_SNAPLEN
value|50
end_define

begin_comment
comment|/*  * bpf_mtap - incoming linkage from device drivers, when packet  *   is in an mbuf chain  */
end_comment

begin_function
name|void
name|bpf_mtap
parameter_list|(
name|arg
parameter_list|,
name|m0
parameter_list|)
name|caddr_t
name|arg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
block|{
specifier|static
name|u_char
name|buf
index|[
name|BPF_MIN_SNAPLEN
index|]
decl_stmt|;
name|struct
name|bpf_if
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bpf_if
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_int
name|slen
decl_stmt|,
name|plen
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_len
operator|>=
name|BPF_MIN_SNAPLEN
condition|)
block|{
name|slen
operator|=
name|m0
operator|->
name|m_len
expr_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nbytes
operator|=
name|BPF_MIN_SNAPLEN
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
while|while
condition|(
name|m
operator|&&
name|nbytes
operator|>
literal|0
condition|)
block|{
name|slen
operator|=
name|MIN
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|slen
expr_stmt|;
name|nbytes
operator|-=
name|slen
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|>
literal|0
condition|)
comment|/* Packet too small? */
return|return;
name|slen
operator|=
name|BPF_MIN_SNAPLEN
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
block|}
name|plen
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|plen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
for|for
control|(
name|d
operator|=
name|bp
operator|->
name|bif_dlist
init|;
name|d
operator|!=
literal|0
condition|;
name|d
operator|=
name|d
operator|->
name|bd_next
control|)
block|{
operator|++
name|d
operator|->
name|bd_rcount
expr_stmt|;
name|slen
operator|=
name|bpf_filter
argument_list|(
name|d
operator|->
name|bd_filter
argument_list|,
name|cp
argument_list|,
name|plen
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|!=
literal|0
condition|)
name|catchpacket
argument_list|(
name|d
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|m0
argument_list|,
name|plen
argument_list|,
name|slen
argument_list|,
name|bpf_m_copydata
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Move the packet data from interface memory ('pbuf') into the  * store buffer.  Return 1 if it's time to wakeup a listener (buffer full),  * otherwise 0.  'copy' is the routine called to do the actual data   * transfer.  'bcopy' is passed in to copy contiguous chunks, while  * 'bpf_m_copydata' is passed in to copy mbuf chains.  In the latter  * case, 'pbuf' is really an mbuf.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|catchpacket
argument_list|(
name|d
argument_list|,
name|pbuf
argument_list|,
name|plen
argument_list|,
name|snaplen
argument_list|,
name|cpfn
argument_list|)
decl|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|pbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|plen
decl_stmt|,
name|snaplen
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|cpfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|bpf_hdr
modifier|*
name|hp
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|curlen
decl_stmt|;
name|int
name|hdrlen
init|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_hdrlen
decl_stmt|;
comment|/* 	 * Figure out how many bytes to move.  If the packet is 	 * greater or equal to the snapshot length, transfer that 	 * much.  Otherwise, transfer the whole packet (unless 	 * we hit the cluster limit). 	 */
if|if
condition|(
name|snaplen
operator|<=
name|plen
condition|)
name|totlen
operator|=
name|snaplen
operator|+
name|hdrlen
expr_stmt|;
else|else
block|{
name|totlen
operator|=
name|plen
operator|+
name|hdrlen
expr_stmt|;
if|if
condition|(
name|totlen
operator|>
name|MCLBYTES
condition|)
name|totlen
operator|=
name|MCLBYTES
expr_stmt|;
block|}
name|m
operator|=
name|d
operator|->
name|bd_sbuf
expr_stmt|;
comment|/* 	 * Round up the end of the previous packet to the next longword. 	 */
name|curlen
operator|=
name|BPF_WORDALIGN
argument_list|(
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|curlen
operator|+
name|totlen
operator|>
name|MCLBYTES
condition|)
block|{
comment|/* 		 * This packet will overflow the storage buffer. 		 * Move the current cluster buffer to the hold slot, 		 * and grab the free one. 		 */
if|if
condition|(
name|d
operator|->
name|bd_fbuf
operator|==
literal|0
condition|)
block|{
comment|/*  			 * We haven't completed the previous read yet? 			 * Drop the packet. 			 */
operator|++
name|d
operator|->
name|bd_dcount
expr_stmt|;
return|return;
block|}
comment|/* 		 * Rotate the buffers.  Move the 'store' buffer 		 * into the 'hold' slot, and the 'free' buffer 		 * into the 'store' slot.  Zero out the length of 		 * the new 'store' buffer. 		 */
name|d
operator|->
name|bd_hbuf
operator|=
name|d
operator|->
name|bd_sbuf
expr_stmt|;
name|m
operator|=
name|d
operator|->
name|bd_sbuf
operator|=
name|d
operator|->
name|bd_fbuf
expr_stmt|;
name|d
operator|->
name|bd_fbuf
operator|=
literal|0
expr_stmt|;
name|curlen
operator|=
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Wake up anyone sleeping on this descriptor.  		 */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
name|bpf_wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|bd_immediate
condition|)
block|{
comment|/* 		 * Immediate mode is set.  A packet arrived so any 		 * reads should be woken up. 		 */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
name|bpf_wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Append the bpf header. 	 */
name|hp
operator|=
operator|(
expr|struct
name|bpf_hdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|curlen
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
name|uniqtime
argument_list|(
operator|&
name|hp
operator|->
name|bh_tstamp
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|hp300
name|microtime
argument_list|(
operator|&
name|hp
operator|->
name|bh_tstamp
argument_list|)
expr_stmt|;
else|#
directive|else
name|hp
operator|->
name|bh_tstamp
operator|=
name|time
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|hp
operator|->
name|bh_datalen
operator|=
name|plen
expr_stmt|;
name|hp
operator|->
name|bh_hdrlen
operator|=
name|hdrlen
expr_stmt|;
comment|/* 	 * Copy the packet data into the 'store' buffer and 	 * update the cluster length. 	 */
call|(
modifier|*
name|cpfn
call|)
argument_list|(
name|pbuf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|hp
operator|+
name|hdrlen
argument_list|,
name|hp
operator|->
name|bh_caplen
operator|=
name|totlen
operator|-
name|hdrlen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|curlen
operator|+
name|totlen
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Allocate an mbuf cluster and clear its length field.  * If resources unavaiable, return 0.  * We can wait in MGET since we assume that we are called  * at a low priority.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|bpf_mcluster
parameter_list|()
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|MCLGET
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
name|MCLBYTES
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
return|return
name|m
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * Initialize all nonzero fields of a descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|bpf_initd
parameter_list|(
name|d
parameter_list|)
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* Get the buffer space. */
name|m
operator|=
name|bpf_mcluster
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
name|ENOBUFS
return|;
name|d
operator|->
name|bd_fbuf
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|bpf_mcluster
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|d
operator|->
name|bd_fbuf
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|d
operator|->
name|bd_sbuf
operator|=
name|m
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Register 'ifp' with bpf.  'devp' is the link-level device descriptor  * and 'driverp' is a pointer to the 'struct bpf_if *' in the driver's softc.  */
end_comment

begin_function
name|void
name|bpfattach
parameter_list|(
name|driverp
parameter_list|,
name|ifp
parameter_list|,
name|devp
parameter_list|)
name|caddr_t
modifier|*
name|driverp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|bpf_devp
modifier|*
name|devp
decl_stmt|;
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bpf_units
operator|>=
name|NBPFILTER
condition|)
block|{
name|printf
argument_list|(
literal|"bpf: too many interfaces: %s%d not attached\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|=
operator|&
name|bpf_iftab
index|[
name|bpf_units
operator|++
index|]
expr_stmt|;
name|bp
operator|->
name|bif_dlist
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bif_driverp
operator|=
operator|(
expr|struct
name|bpf_if
operator|*
operator|*
operator|)
name|driverp
expr_stmt|;
name|bp
operator|->
name|bif_ifp
operator|=
name|ifp
expr_stmt|;
name|bp
operator|->
name|bif_devp
operator|=
operator|*
name|devp
expr_stmt|;
comment|/* 	 * Compute the length of the bpf header.  This is not necessarily 	 * equal to SIZEOF_BPF_HDR because we want to insert spacing such  	 * that the network layer header begins on a longword boundary (for  	 * performance reasons and to alleviate alignment restrictions). 	 */
name|i
operator|=
name|devp
operator|->
name|bdev_hdrlen
expr_stmt|;
name|bp
operator|->
name|bif_hdrlen
operator|=
name|BPF_WORDALIGN
argument_list|(
name|i
operator|+
name|SIZEOF_BPF_HDR
argument_list|)
operator|-
name|i
expr_stmt|;
comment|/* 	 * Mark all the descriptors free if this hasn't been done. 	 */
if|if
condition|(
operator|!
name|D_ISFREE
argument_list|(
operator|&
name|bpf_dtab
index|[
literal|0
index|]
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBPFILTER
condition|;
operator|++
name|i
control|)
name|D_MARKFREE
argument_list|(
operator|&
name|bpf_dtab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bpf: %s%d attached\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|(NBPFILTER> 0)
end_endif

end_unit

