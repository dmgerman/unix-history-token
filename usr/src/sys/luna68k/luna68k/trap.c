begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1992 OMRON Corporation.  * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: trap.c 1.35 91/12/26$  * OMRON: $Id: trap.c,v 1.2 92/06/14 06:23:41 moti Exp $  *  * from: hp300/hp300/trap.c     7.23 (Berkeley) 7/9/92  *  *	@(#)trap.c	7.2 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"acct.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"signalvar.h"
end_include

begin_include
include|#
directive|include
file|"resourcevar.h"
end_include

begin_include
include|#
directive|include
file|"syscall.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|"ktrace.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../include/psl.h"
end_include

begin_include
include|#
directive|include
file|"../include/trap.h"
end_include

begin_include
include|#
directive|include
file|"../include/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../include/reg.h"
end_include

begin_include
include|#
directive|include
file|"../include/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_include
include|#
directive|include
file|"vm/pmap.h"
end_include

begin_decl_stmt
name|struct
name|sysent
name|sysent
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsysent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|trap_type
index|[]
init|=
block|{
literal|"Bus error"
block|,
literal|"Address error"
block|,
literal|"Illegal instruction"
block|,
literal|"Zero divide"
block|,
literal|"CHK instruction"
block|,
literal|"TRAPV instruction"
block|,
literal|"Privilege violation"
block|,
literal|"Trace trap"
block|,
literal|"MMU fault"
block|,
literal|"SSIR trap"
block|,
literal|"Format error"
block|,
literal|"68881 exception"
block|,
literal|"Coprocessor violation"
block|,
literal|"Async system trap"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRAP_TYPES
value|(sizeof trap_type / sizeof trap_type[0])
end_define

begin_comment
comment|/*  * Size of various exception stack frames (minus the standard 8 bytes)  */
end_comment

begin_decl_stmt
name|short
name|exframesize
index|[]
init|=
block|{
name|FMT0SIZE
block|,
comment|/* type 0 - normal (68020/030/040) */
name|FMT1SIZE
block|,
comment|/* type 1 - throwaway (68020/030/040) */
name|FMT2SIZE
block|,
comment|/* type 2 - normal 6-word (68020/030/040) */
name|FMT3SIZE
block|,
comment|/* type 3 - FP post-instruction (68040) */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* type 4-6 - undefined */
name|FMT7SIZE
block|,
comment|/* type 7 - access error (68040) */
literal|58
block|,
comment|/* type 8 - bus fault (68010) */
name|FMT9SIZE
block|,
comment|/* type 9 - coprocessor mid-instruction (68020/030) */
name|FMTASIZE
block|,
comment|/* type A - short bus fault (68020/030) */
name|FMTBSIZE
block|,
comment|/* type B - long bus fault (68020/030) */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
comment|/* type C-F - undefined */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KDFAULT
parameter_list|(
name|c
parameter_list|)
value|(((c)& (SSW_DF|SSW_FCMASK)) == (SSW_DF|FC_SUPERD))
end_define

begin_define
define|#
directive|define
name|WRFAULT
parameter_list|(
name|c
parameter_list|)
value|(((c)& (SSW_DF|SSW_RW)) == SSW_DF)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|mmudebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mmupid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MDB_FOLLOW
value|1
end_define

begin_define
define|#
directive|define
name|MDB_WBFOLLOW
value|2
end_define

begin_define
define|#
directive|define
name|MDB_WBFAILED
value|4
end_define

begin_define
define|#
directive|define
name|MDB_ISPID
parameter_list|(
name|p
parameter_list|)
value|(p) == mmupid
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * trap and syscall both need the following work done before returning  * to user mode.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|userret
parameter_list|(
name|p
parameter_list|,
name|fp
parameter_list|,
name|oticks
parameter_list|,
name|faultaddr
parameter_list|,
name|fromtrap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|frame
modifier|*
name|fp
decl_stmt|;
name|u_quad_t
name|oticks
decl_stmt|;
name|u_int
name|faultaddr
decl_stmt|;
name|int
name|fromtrap
decl_stmt|;
block|{
name|int
name|sig
decl_stmt|,
name|s
decl_stmt|;
comment|/* take pending signals */
while|while
condition|(
operator|(
name|sig
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|psig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_pri
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
if|if
condition|(
name|want_resched
condition|)
block|{
comment|/* 		 * Since we are curproc, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we setrq ourselves but before we 		 * swtch()'ed, we might not be on the queue indicated by 		 * our priority. 		 */
name|s
operator|=
name|splstatclock
argument_list|()
expr_stmt|;
name|setrq
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|swtch
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sig
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|psig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If profiling, charge system time to the trapped pc. 	 */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SPROFIL
condition|)
name|addupc_intr
argument_list|(
name|p
argument_list|,
name|fp
operator|->
name|f_pc
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|->
name|p_sticks
operator|-
name|oticks
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HP380
comment|/* 	 * Deal with user mode writebacks (from trap, or from sigreturn). 	 * If any writeback fails, go back and attempt signal delivery. 	 * unless we have already been here and attempted the writeback 	 * (e.g. bad address with user ignoring SIGSEGV).  In that case 	 * we just return to the user without sucessfully completing 	 * the writebacks.  Maybe we should just drop the sucker? 	 */
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
operator|&&
name|fp
operator|->
name|f_format
operator|==
name|FMT7
condition|)
block|{
if|if
condition|(
name|beenhere
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|mmudebug
operator|&
name|MDB_WBFAILED
condition|)
name|printf
argument_list|(
name|fromtrap
condition|?
literal|"pid %d(%s): writeback aborted, pc=%x, fa=%x\n"
else|:
literal|"pid %d(%s): writeback aborted in sigreturn, pc=%x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|fp
operator|->
name|f_pc
argument_list|,
name|faultaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|sig
operator|=
name|writeback
argument_list|(
name|fp
argument_list|,
name|fromtrap
argument_list|)
condition|)
block|{
name|beenhere
operator|=
literal|1
expr_stmt|;
name|oticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
name|trapsignal
argument_list|(
name|p
argument_list|,
name|sig
argument_list|,
name|faultaddr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
endif|#
directive|endif
name|curpri
operator|=
name|p
operator|->
name|p_pri
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trap is called from locore to handle most types of processor traps,  * including events such as simulated software interrupts/AST's.  * System calls are broken out for efficiency.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|trap
argument_list|(
argument|type
argument_list|,
argument|code
argument_list|,
argument|v
argument_list|,
argument|frame
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame
name|frame
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|ucode
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|u_quad_t
name|sticks
decl_stmt|;
name|unsigned
name|ncode
decl_stmt|;
specifier|extern
name|char
name|fswintr
index|[]
decl_stmt|;
name|cnt
operator|.
name|v_trap
operator|++
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
name|ucode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|USERMODE
argument_list|(
name|frame
operator|.
name|f_sr
argument_list|)
condition|)
block|{
name|type
operator||=
name|T_USER
expr_stmt|;
name|sticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|=
name|frame
operator|.
name|f_regs
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|dopanic
label|:
name|printf
argument_list|(
literal|"trap type %d, code = %x, v = %x\n"
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|regdump
argument_list|(
name|frame
operator|.
name|f_regs
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|type
operator|&=
operator|~
name|T_USER
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|type
operator|<
name|TRAP_TYPES
condition|)
name|panic
argument_list|(
name|trap_type
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
case|case
name|T_BUSERR
case|:
comment|/* kernel bus error */
if|if
condition|(
operator|!
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
condition|)
goto|goto
name|dopanic
goto|;
comment|/* 		 * If we have arranged to catch this fault in any of the 		 * copy to/from user space routines, set PC to return to 		 * indicated location and set flag informing buserror code 		 * that it may need to clean up stack frame. 		 */
name|copyfault
label|:
name|frame
operator|.
name|f_stackadj
operator|=
name|exframesize
index|[
name|frame
operator|.
name|f_format
index|]
expr_stmt|;
name|frame
operator|.
name|f_format
operator|=
name|frame
operator|.
name|f_vector
operator|=
literal|0
expr_stmt|;
name|frame
operator|.
name|f_pc
operator|=
operator|(
name|int
operator|)
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
expr_stmt|;
return|return;
case|case
name|T_BUSERR
operator||
name|T_USER
case|:
comment|/* bus error */
case|case
name|T_ADDRERR
operator||
name|T_USER
case|:
comment|/* address error */
name|ucode
operator|=
name|v
expr_stmt|;
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FPCOPROC
case|case
name|T_COPERR
case|:
comment|/* kernel coprocessor violation */
endif|#
directive|endif
case|case
name|T_FMTERR
operator||
name|T_USER
case|:
comment|/* do all RTE errors come in as T_USER? */
case|case
name|T_FMTERR
case|:
comment|/* ...just in case... */
comment|/* 	 * The user has most likely trashed the RTE or FP state info 	 * in the stack frame of a signal handler. 	 */
name|type
operator||=
name|T_USER
expr_stmt|;
name|printf
argument_list|(
literal|"pid %d: kernel %s exception\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|type
operator|==
name|T_COPERR
condition|?
literal|"coprocessor"
else|:
literal|"format"
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigact
index|[
name|SIGILL
index|]
operator|=
name|SIG_DFL
expr_stmt|;
name|i
operator|=
name|sigmask
argument_list|(
name|SIGILL
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigignore
operator|&=
operator|~
name|i
expr_stmt|;
name|p
operator|->
name|p_sigcatch
operator|&=
operator|~
name|i
expr_stmt|;
name|p
operator|->
name|p_sigmask
operator|&=
operator|~
name|i
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was ILL_RESAD_FAULT */
break|break;
ifdef|#
directive|ifdef
name|FPCOPROC
case|case
name|T_COPERR
operator||
name|T_USER
case|:
comment|/* user coprocessor violation */
comment|/* What is a proper response here? */
name|ucode
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_FPERR
operator||
name|T_USER
case|:
comment|/* 68881 exceptions */
comment|/* 	 * We pass along the 68881 status register which locore stashed 	 * in code for us.  Note that there is a possibility that the 	 * bit pattern of this register will conflict with one of the 	 * FPE_* codes defined in signal.h.  Fortunately for us, the 	 * only such codes we use are all in the range 1-7 and the low 	 * 3 bits of the status register are defined as 0 so there is 	 * no clash. 	 */
name|ucode
operator|=
name|code
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_ILLINST
operator||
name|T_USER
case|:
comment|/* illegal instruction fault */
case|case
name|T_PRIVINST
operator||
name|T_USER
case|:
comment|/* privileged instruction fault */
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was ILL_PRIVIN_FAULT */
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_ZERODIV
operator||
name|T_USER
case|:
comment|/* Divide by zero */
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was FPE_INTDIV_TRAP */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_CHKINST
operator||
name|T_USER
case|:
comment|/* CHK instruction trap */
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was FPE_SUBRNG_TRAP */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_TRAPVINST
operator||
name|T_USER
case|:
comment|/* TRAPV instruction trap */
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was FPE_INTOVF_TRAP */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
comment|/* 	 * XXX: Trace traps are a nightmare. 	 * 	 *	HP-UX uses trap #1 for breakpoints, 	 *	HPBSD uses trap #2, 	 *	SUN 3.x uses trap #15, 	 *	KGDB uses trap #15 (for kernel breakpoints; handled elsewhere). 	 * 	 * HPBSD and HP-UX traps both get mapped by locore.s into T_TRACE. 	 * SUN 3.x traps get passed through as T_TRAP15 and are not really 	 * supported yet. 	 */
case|case
name|T_TRACE
case|:
comment|/* kernel trace trap */
case|case
name|T_TRAP15
case|:
comment|/* SUN trace trap */
name|frame
operator|.
name|f_sr
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|T_TRACE
operator||
name|T_USER
case|:
comment|/* user trace trap */
case|case
name|T_TRAP15
operator||
name|T_USER
case|:
comment|/* SUN user trace trap */
name|frame
operator|.
name|f_sr
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|T_ASTFLT
case|:
comment|/* system async trap, cannot happen */
goto|goto
name|dopanic
goto|;
case|case
name|T_ASTFLT
operator||
name|T_USER
case|:
comment|/* user async trap */
name|astpending
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We check for software interrupts first.  This is because 		 * they are at a higher level than ASTs, and on a VAX would 		 * interrupt the AST.  We assume that if we are processing 		 * an AST that we must be at IPL0 so we don't bother to 		 * check.  Note that we ensure that we are at least at SIR 		 * IPL while processing the SIR. 		 */
name|spl1
argument_list|()
expr_stmt|;
comment|/* fall into... */
case|case
name|T_SSIR
case|:
comment|/* software interrupt */
case|case
name|T_SSIR
operator||
name|T_USER
case|:
if|if
condition|(
name|ssir
operator|&
name|SIR_NET
condition|)
block|{
name|siroff
argument_list|(
name|SIR_NET
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|netintr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ssir
operator|&
name|SIR_CLOCK
condition|)
block|{
name|siroff
argument_list|(
name|SIR_CLOCK
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|softclock
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * If this was not an AST trap, we are all done. 		 */
if|if
condition|(
name|type
operator|!=
operator|(
name|T_ASTFLT
operator||
name|T_USER
operator|)
condition|)
block|{
name|cnt
operator|.
name|v_trap
operator|--
expr_stmt|;
return|return;
block|}
name|spl0
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SOWEUPC
condition|)
block|{
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|SOWEUPC
expr_stmt|;
name|ADDUPROF
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
case|case
name|T_MMUFLT
case|:
comment|/* kernel mode page fault */
comment|/* 		 * If we were doing profiling ticks or other user mode 		 * stuff from interrupt code, Just Say No. 		 */
if|if
condition|(
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
operator|==
name|fswintr
condition|)
goto|goto
name|copyfault
goto|;
comment|/* fall into ... */
case|case
name|T_MMUFLT
operator||
name|T_USER
case|:
comment|/* page fault */
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
specifier|register
name|vm_map_t
name|map
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
specifier|extern
name|vm_map_t
name|kernel_map
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|mmudebug
operator|&
name|MDB_WBFOLLOW
operator|)
operator|||
name|MDB_ISPID
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
condition|)
name|printf
argument_list|(
literal|"trap: T_MMUFLT pid=%d, code=%x, v=%x, pc=%x, sr=%x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|code
argument_list|,
name|v
argument_list|,
name|frame
operator|.
name|f_pc
argument_list|,
name|frame
operator|.
name|f_sr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * It is only a kernel address space fault iff: 		 * 	1. (type& T_USER) == 0  and 		 * 	2. pcb_onfault not set or 		 *	3. pcb_onfault set but supervisor space data fault 		 * The last can occur during an exec() copyin where the 		 * argument space is lazy-allocated. 		 */
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
operator|&&
operator|(
operator|!
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
operator|||
name|KDFAULT
argument_list|(
name|code
argument_list|)
operator|)
condition|)
name|map
operator|=
name|kernel_map
expr_stmt|;
else|else
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
if|if
condition|(
name|WRFAULT
argument_list|(
name|code
argument_list|)
condition|)
name|ftype
operator|=
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
expr_stmt|;
else|else
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|v
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|map
operator|==
name|kernel_map
operator|&&
name|va
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"trap: bad kernel access at %x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
endif|#
directive|endif
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rv
operator|&&
name|MDB_ISPID
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
condition|)
name|printf
argument_list|(
literal|"vm_fault(%x, %x, %x, 0) -> %x\n"
argument_list|,
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|rv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If this was a stack access we keep track of the maximum 		 * accessed stack size.  Also, if vm_fault gets a protection 		 * failure it is due to accessing the stack region outside 		 * the current limit and we need to reflect that as an access 		 * error. 		 */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|va
operator|>=
name|vm
operator|->
name|vm_maxsaddr
operator|&&
name|map
operator|!=
name|kernel_map
condition|)
block|{
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|unsigned
name|nss
decl_stmt|;
name|nss
operator|=
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|USRSTACK
operator|-
operator|(
name|unsigned
operator|)
name|va
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nss
operator|>
name|vm
operator|->
name|vm_ssize
condition|)
name|vm
operator|->
name|vm_ssize
operator|=
name|nss
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
condition|)
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
condition|)
block|{
return|return;
block|}
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
condition|)
goto|goto
name|copyfault
goto|;
name|printf
argument_list|(
literal|"vm_fault(%x, %x, %x, 0) -> %x\n"
argument_list|,
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  type %x, code [mmu,,ssw]: %x\n"
argument_list|,
name|type
argument_list|,
name|code
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
name|ucode
operator|=
name|v
expr_stmt|;
name|i
operator|=
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
expr_stmt|;
break|break;
block|}
block|}
name|trapsignal
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|T_USER
operator|)
operator|==
literal|0
condition|)
return|return;
name|out
label|:
name|userret
argument_list|(
name|p
argument_list|,
operator|&
name|frame
argument_list|,
name|sticks
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Proces a system call.  */
end_comment

begin_macro
name|syscall
argument_list|(
argument|code
argument_list|,
argument|frame
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame
name|frame
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|caddr_t
name|params
decl_stmt|;
specifier|register
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|opc
decl_stmt|,
name|numsys
decl_stmt|,
name|s
decl_stmt|;
name|u_int
name|argsize
decl_stmt|;
struct|struct
name|args
block|{
name|int
name|i
index|[
literal|8
index|]
decl_stmt|;
block|}
name|args
struct|;
name|int
name|rval
index|[
literal|2
index|]
decl_stmt|;
name|u_quad_t
name|sticks
decl_stmt|;
name|cnt
operator|.
name|v_syscall
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|frame
operator|.
name|f_sr
argument_list|)
condition|)
name|panic
argument_list|(
literal|"syscall"
argument_list|)
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
name|sticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|=
name|frame
operator|.
name|f_regs
expr_stmt|;
name|opc
operator|=
name|frame
operator|.
name|f_pc
operator|-
literal|2
expr_stmt|;
name|callp
operator|=
name|sysent
operator|,
name|numsys
operator|=
name|nsysent
expr_stmt|;
name|params
operator|=
operator|(
name|caddr_t
operator|)
name|frame
operator|.
name|f_regs
index|[
name|SP
index|]
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYS_indir
case|:
comment|/* 		 * Code is first argument, followed by actual args. 		 */
name|code
operator|=
name|fuword
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS___indir
case|:
comment|/* 		 * Like indir, but code is a quad, so as to maintain 		 * quad alignment for the rest of the arguments. 		 */
name|code
operator|=
name|fuword
argument_list|(
name|params
operator|+
name|_QUAD_LOWWORD
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|quad_t
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* nothing to do by default */
break|break;
block|}
if|if
condition|(
name|code
operator|<
name|numsys
condition|)
name|callp
operator|+=
name|code
expr_stmt|;
else|else
name|callp
operator|+=
name|SYS_indir
expr_stmt|;
comment|/* => nosys */
name|argsize
operator|=
name|callp
operator|->
name|sy_narg
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|argsize
operator|&&
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|params
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|,
name|argsize
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rval
index|[
literal|1
index|]
operator|=
name|frame
operator|.
name|f_regs
index|[
name|D1
index|]
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|args
argument_list|,
name|rval
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * Reinitialize proc pointer `p' as it may be different 		 * if this is a child returning from fork syscall. 		 */
name|p
operator|=
name|curproc
expr_stmt|;
name|frame
operator|.
name|f_regs
index|[
name|D0
index|]
operator|=
name|rval
index|[
literal|0
index|]
expr_stmt|;
name|frame
operator|.
name|f_regs
index|[
name|D1
index|]
operator|=
name|rval
index|[
literal|1
index|]
expr_stmt|;
name|frame
operator|.
name|f_sr
operator|&=
operator|~
name|PSL_C
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
name|frame
operator|.
name|f_pc
operator|=
name|opc
expr_stmt|;
break|break;
case|case
name|EJUSTRETURN
case|:
break|break;
comment|/* nothing to do */
default|default:
name|bad
label|:
name|frame
operator|.
name|f_regs
index|[
name|D0
index|]
operator|=
name|error
expr_stmt|;
name|frame
operator|.
name|f_sr
operator||=
name|PSL_C
expr_stmt|;
break|break;
block|}
name|userret
argument_list|(
name|p
argument_list|,
operator|&
name|frame
argument_list|,
name|sticks
argument_list|,
operator|(
name|u_int
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|error
argument_list|,
name|rval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

end_unit

