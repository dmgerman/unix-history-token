begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  * All rights reserved.  *  * This code is derived from software donated to Berkeley by  * Jan-Simon Pendry.  *  * %sccs.include.redist.c%  *  *	@(#)lofs_vnops.c	8.3 (Berkeley) %G%  *  * $Id: lofs_vnops.c,v 1.11 1992/05/30 10:05:43 jsp Exp jsp $  */
end_comment

begin_comment
comment|/*  * Loopback Filesystem  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/lofs/lofs.h>
end_include

begin_comment
comment|/*  * Basic strategy: as usual, do as little work as possible.  * Nothing is ever locked in the lofs'ed filesystem, all  * locks are held in the underlying filesystems.  */
end_comment

begin_comment
comment|/*  * Save a vnode and replace with  * the lofs'ed one  */
end_comment

begin_define
define|#
directive|define
name|PUSHREF
parameter_list|(
name|v
parameter_list|,
name|nd
parameter_list|)
define|\
value|{ \ 	struct { struct vnode *vnp; } v; \ 	v.vnp = (nd); \ 	(nd) = LOFSVP(v.vnp)
end_define

begin_comment
comment|/*  * Undo the PUSHREF  */
end_comment

begin_define
define|#
directive|define
name|POP
parameter_list|(
name|v
parameter_list|,
name|nd
parameter_list|)
define|\ 	\
value|(nd) = v.vnp; \ }
end_define

begin_comment
comment|/*  * vp is the current namei directory  * ndp is the name to locate in that directory...  */
end_comment

begin_function
name|int
name|lofs_lookup
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lookup_args
comment|/* { 		struct vnode * a_dvp; 		struct vnode ** a_vpp; 		struct componentname * a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|targetdvp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|flag
init|=
name|ap
operator|->
name|a_cnp
operator|->
name|cn_nameiop
comment|/*& OPMASK*/
decl_stmt|;
comment|/* 	 * (ap->a_dvp) was locked when passed in, and it will be replaced 	 * with the target vnode, BUT that will already have been 	 * locked when (ap->a_dvp) was locked [see lofs_lock].  all that 	 * must be done here is to keep track of reference counts. 	 */
name|targetdvp
operator|=
name|LOFSVP
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
comment|/*VREF(targetdvp);*/
comment|/* 	 * Call lookup on the looped vnode 	 */
name|error
operator|=
name|VOP_LOOKUP
argument_list|(
name|targetdvp
argument_list|,
operator|&
name|newvp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
comment|/*vrele(targetdvp);*/
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|newvp
expr_stmt|;
comment|/* 	 * If we just found a directory then make 	 * a loopback node for it and return the loopback 	 * instead of the real vnode.  Otherwise simply 	 * return the aliased directory and vnode. 	 */
if|if
condition|(
name|newvp
operator|&&
name|newvp
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
name|flag
operator|==
name|LOOKUP
condition|)
block|{
comment|/* 		 * At this point, newvp is the vnode to be looped. 		 * Activate a loopback and return the looped vnode. 		 */
return|return
operator|(
name|make_lofs
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this = ni_dvp  * ni_dvp references the locked directory.  * ni_vp is NULL.  */
end_comment

begin_function
name|int
name|lofs_mknod
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mknod_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|PUSHREF
argument_list|(
name|xdvp
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_MKNOD
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|xdvp
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this = ni_dvp;  * ni_dvp references the locked directory  * ni_vp is NULL.  */
end_comment

begin_function
name|int
name|lofs_create
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|PUSHREF
argument_list|(
name|xdvp
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|xdvp
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_open
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_open_args
comment|/* { 		struct vnode *a_vp; 		int  a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_OPEN
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_CLOSE
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnode *a_vp; 		int  a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_ACCESS
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * Get the stats from the underlying filesystem 	 */
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * and replace the fsid field with the loopback number 	 * to preserve the namespace. 	 */
name|ap
operator|->
name|a_vap
operator|->
name|va_fsid
operator|=
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_setattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_SETATTR
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_READ
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_write
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_write_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_WRITE
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_ioctl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_ioctl_args
comment|/* { 		struct vnode *a_vp; 		int  a_command; 		caddr_t  a_data; 		int  a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_IOCTL
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_command
argument_list|,
name|ap
operator|->
name|a_data
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_select
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_select_args
comment|/* { 		struct vnode *a_vp; 		int  a_which; 		int  a_fflags; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_SELECT
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_which
argument_list|,
name|ap
operator|->
name|a_fflags
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_mmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mmap_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflags; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_MMAP
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_fflags
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_fsync
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fsync_args
comment|/* { 		struct vnode *a_vp; 		struct ucred *a_cred; 		int  a_waitfor; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|targetvp
init|=
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetvp
condition|)
return|return
operator|(
name|VOP_FSYNC
argument_list|(
name|targetvp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_waitfor
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_seek
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_seek_args
comment|/* { 		struct vnode *a_vp; 		off_t  a_oldoff; 		off_t  a_newoff; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_SEEK
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_oldoff
argument_list|,
name|ap
operator|->
name|a_newoff
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_remove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_remove_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|PUSHREF
argument_list|(
name|xdvp
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|PUSHREF
argument_list|(
name|xvp
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_REMOVE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|xvp
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|xdvp
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vp is this.  * ni_dvp is the locked parent of the target.  * ni_vp is NULL.  */
end_comment

begin_function
name|int
name|lofs_link
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_link_args
comment|/* { 		struct vnode *a_vp; 		struct vnode *a_tdvp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|PUSHREF
argument_list|(
name|xdvp
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_LINK
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|xdvp
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_rename
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|fvp
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|struct
name|vnode
modifier|*
name|fsvp
decl_stmt|,
modifier|*
name|tsvp
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|;
comment|/* 	 * Switch source directory to point to lofsed vnode 	 */
name|PUSHREF
argument_list|(
name|fdvp
argument_list|,
name|ap
operator|->
name|a_fdvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|)
expr_stmt|;
comment|/* 	 * And source object if it is lofsed... 	 */
name|fvp
operator|=
name|ap
operator|->
name|a_fvp
expr_stmt|;
if|if
condition|(
name|fvp
operator|&&
name|fvp
operator|->
name|v_op
operator|==
name|lofs_vnodeop_p
condition|)
block|{
name|ap
operator|->
name|a_fvp
operator|=
name|LOFSVP
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fvp
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * And source startdir object if it is lofsed... 	 */
name|fsvp
operator|=
name|fndp
operator|->
name|ni_startdir
expr_stmt|;
if|if
condition|(
name|fsvp
operator|&&
name|fsvp
operator|->
name|v_op
operator|==
name|lofs_vnodeop_p
condition|)
block|{
name|fndp
operator|->
name|ni_startdir
operator|=
name|LOFSVP
argument_list|(
name|fsvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|fndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fsvp
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  	 * Switch target directory to point to lofsed vnode 	 */
name|tdvp
operator|=
name|ap
operator|->
name|a_tdvp
expr_stmt|;
if|if
condition|(
name|tdvp
operator|&&
name|tdvp
operator|->
name|v_op
operator|==
name|lofs_vnodeop_p
condition|)
block|{
name|ap
operator|->
name|a_tdvp
operator|=
name|LOFSVP
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tdvp
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * And target object if it is lofsed... 	 */
name|tvp
operator|=
name|ap
operator|->
name|a_tvp
expr_stmt|;
if|if
condition|(
name|tvp
operator|&&
name|tvp
operator|->
name|v_op
operator|==
name|lofs_vnodeop_p
condition|)
block|{
name|ap
operator|->
name|a_tvp
operator|=
name|LOFSVP
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|ap
operator|->
name|a_tvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tvp
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * And target startdir object if it is lofsed... 	 */
name|tsvp
operator|=
name|tndp
operator|->
name|ni_startdir
expr_stmt|;
if|if
condition|(
name|tsvp
operator|&&
name|tsvp
operator|->
name|v_op
operator|==
name|lofs_vnodeop_p
condition|)
block|{
name|tndp
operator|->
name|ni_startdir
operator|=
name|LOFSVP
argument_list|(
name|fsvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|tndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tsvp
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|VOP_RENAME
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|,
name|ap
operator|->
name|a_fvp
argument_list|,
name|ap
operator|->
name|a_fcnp
argument_list|,
name|ap
operator|->
name|a_tdvp
argument_list|,
name|ap
operator|->
name|a_tvp
argument_list|,
name|ap
operator|->
name|a_tcnp
argument_list|)
expr_stmt|;
comment|/* 	 * Put everything back... 	 */
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|tsvp
condition|)
block|{
if|if
condition|(
name|tndp
operator|->
name|ni_startdir
condition|)
name|vrele
argument_list|(
name|tndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|tndp
operator|->
name|ni_startdir
operator|=
name|tsvp
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tvp
condition|)
block|{
name|ap
operator|->
name|a_tvp
operator|=
name|tvp
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_tvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tdvp
condition|)
block|{
name|ap
operator|->
name|a_tdvp
operator|=
name|tdvp
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|fsvp
condition|)
block|{
if|if
condition|(
name|fndp
operator|->
name|ni_startdir
condition|)
name|vrele
argument_list|(
name|fndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|fndp
operator|->
name|ni_startdir
operator|=
name|fsvp
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fvp
condition|)
block|{
name|ap
operator|->
name|a_fvp
operator|=
name|fvp
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
block|}
name|POP
argument_list|(
name|fdvp
argument_list|,
name|ap
operator|->
name|a_fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ni_dvp is the locked (alias) parent.  * ni_vp is NULL.  */
end_comment

begin_function
name|int
name|lofs_mkdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mkdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|xdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
decl_stmt|;
name|xdvp
operator|=
name|dvp
expr_stmt|;
name|dvp
operator|=
name|LOFSVP
argument_list|(
name|xdvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|dvp
argument_list|,
operator|&
name|newvp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULLVP
expr_stmt|;
name|vrele
argument_list|(
name|xdvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Make a new lofs node 	 */
comment|/*VREF(dvp);*/
name|error
operator|=
name|make_lofs
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
operator|&
name|newvp
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|newvp
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ni_dvp is the locked parent.  * ni_vp is the entry to be removed.  */
end_comment

begin_function
name|int
name|lofs_rmdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rmdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|PUSHREF
argument_list|(
name|xdvp
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|PUSHREF
argument_list|(
name|xvp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_RMDIR
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|xvp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|xdvp
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ni_dvp is the locked parent.  * ni_vp is NULL.  */
end_comment

begin_function
name|int
name|lofs_symlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_symlink_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 		char *a_target; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|PUSHREF
argument_list|(
name|xdvp
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_SYMLINK
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_target
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|xdvp
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_READDIR
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_readlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readlink_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_READLINK
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Anyone's guess...  */
end_comment

begin_function
name|int
name|lofs_abortop
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_abortop_args
comment|/* { 		struct vnode *a_dvp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|PUSHREF
argument_list|(
name|xdvp
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_ABORTOP
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|xdvp
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_inactive
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|targetvp
init|=
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
block|{
specifier|extern
name|int
name|prtactive
decl_stmt|;
if|if
condition|(
name|prtactive
operator|&&
name|ap
operator|->
name|a_vp
operator|->
name|v_usecount
operator|!=
literal|0
condition|)
name|vprint
argument_list|(
literal|"lofs_inactive: pushing active"
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|targetvp
condition|)
block|{
name|vrele
argument_list|(
name|targetvp
argument_list|)
expr_stmt|;
name|LOFSP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|a_lofsvp
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|lofs_reclaim
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_reclaim_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|targetvp
decl_stmt|;
name|remque
argument_list|(
name|LOFSP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
name|targetvp
operator|=
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetvp
condition|)
block|{
name|printf
argument_list|(
literal|"lofs: delayed vrele of %x\n"
argument_list|,
name|targetvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|targetvp
argument_list|)
expr_stmt|;
comment|/* XXX should never happen */
block|}
name|FREE
argument_list|(
name|ap
operator|->
name|a_vp
operator|->
name|v_data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_vp
operator|->
name|v_data
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_lock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lock_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|targetvp
decl_stmt|;
while|while
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|VXLOCK
condition|)
block|{
name|vp
operator|->
name|v_flag
operator||=
name|VXWANT
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_tag
operator|==
name|VT_NON
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|targetvp
operator|=
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetvp
operator|&&
operator|(
name|error
operator|=
name|VOP_LOCK
argument_list|(
name|targetvp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_unlock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_unlock_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|targetvp
init|=
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetvp
condition|)
return|return
operator|(
name|VOP_UNLOCK
argument_list|(
name|targetvp
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_bmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bmap_args
comment|/* { 		struct vnode *a_vp; 		daddr_t  a_bn; 		struct vnode **a_vpp; 		daddr_t *a_bnp; 		int *a_runp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_BMAP
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_bn
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_bnp
argument_list|,
name|ap
operator|->
name|a_runp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_strategy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_strategy_args
comment|/* { 		struct buf *a_bp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|PUSHREF
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_STRATEGY
argument_list|(
name|ap
operator|->
name|a_bp
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_print
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_print_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|targetvp
init|=
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"tag VT_LOFS ref "
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetvp
condition|)
return|return
operator|(
name|VOP_PRINT
argument_list|(
name|targetvp
argument_list|)
operator|)
return|;
name|printf
argument_list|(
literal|"NULLVP\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_islocked
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_islocked_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|targetvp
init|=
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetvp
condition|)
return|return
operator|(
name|VOP_ISLOCKED
argument_list|(
name|targetvp
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_PATHCONF
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|ap
operator|->
name|a_retval
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lofs_advlock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_advlock_args
comment|/* { 		struct vnode *a_vp; 		caddr_t  a_id; 		int  a_op; 		struct flock *a_fl; 		int  a_flags; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|VOP_ADVLOCK
argument_list|(
name|LOFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_id
argument_list|,
name|ap
operator|->
name|a_op
argument_list|,
name|ap
operator|->
name|a_fl
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * LOFS directory offset lookup.  * Currently unsupported.  */
end_comment

begin_function
name|int
name|lofs_blkatoff
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_blkatoff_args
comment|/* { 		struct vnode *a_vp; 		off_t a_offset; 		char **a_res; 		struct buf **a_bpp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * LOFS flat namespace allocation.  * Currently unsupported.  */
end_comment

begin_function
name|int
name|lofs_valloc
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_valloc_args
comment|/* { 		struct vnode *a_pvp; 		int a_mode; 		struct ucred *a_cred; 		struct vnode **a_vpp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * LOFS flat namespace free.  * Currently unsupported.  */
end_comment

begin_comment
comment|/*void*/
end_comment

begin_function
name|int
name|lofs_vfree
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_vfree_args
comment|/* { 		struct vnode *a_pvp; 		ino_t a_ino; 		int a_mode; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * LOFS file truncation.  */
end_comment

begin_function
name|int
name|lofs_truncate
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_truncate_args
comment|/* { 		struct vnode *a_vp; 		off_t a_length; 		int a_flags; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
comment|/* Use lofs_setattr */
name|printf
argument_list|(
literal|"lofs_truncate: need to implement!!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * LOFS update.  */
end_comment

begin_function
name|int
name|lofs_update
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_update_args
comment|/* { 		struct vnode *a_vp; 		struct timeval *a_ta; 		struct timeval *a_tm; 		int a_waitfor; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
comment|/* Use lofs_setattr */
name|printf
argument_list|(
literal|"lofs_update: need to implement!!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * LOFS bwrite  */
end_comment

begin_function
name|int
name|lofs_bwrite
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bwrite_args
comment|/* { 		struct buf *a_bp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Global vfs data structures for ufs  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
modifier|*
name|lofs_vnodeop_p
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|vnodeopv_entry_desc
name|lofs_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
name|vn_default_error
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
name|lofs_lookup
block|}
block|,
comment|/* lookup */
block|{
operator|&
name|vop_create_desc
block|,
name|lofs_create
block|}
block|,
comment|/* create */
block|{
operator|&
name|vop_mknod_desc
block|,
name|lofs_mknod
block|}
block|,
comment|/* mknod */
block|{
operator|&
name|vop_open_desc
block|,
name|lofs_open
block|}
block|,
comment|/* open */
block|{
operator|&
name|vop_close_desc
block|,
name|lofs_close
block|}
block|,
comment|/* close */
block|{
operator|&
name|vop_access_desc
block|,
name|lofs_access
block|}
block|,
comment|/* access */
block|{
operator|&
name|vop_getattr_desc
block|,
name|lofs_getattr
block|}
block|,
comment|/* getattr */
block|{
operator|&
name|vop_setattr_desc
block|,
name|lofs_setattr
block|}
block|,
comment|/* setattr */
block|{
operator|&
name|vop_read_desc
block|,
name|lofs_read
block|}
block|,
comment|/* read */
block|{
operator|&
name|vop_write_desc
block|,
name|lofs_write
block|}
block|,
comment|/* write */
block|{
operator|&
name|vop_ioctl_desc
block|,
name|lofs_ioctl
block|}
block|,
comment|/* ioctl */
block|{
operator|&
name|vop_select_desc
block|,
name|lofs_select
block|}
block|,
comment|/* select */
block|{
operator|&
name|vop_mmap_desc
block|,
name|lofs_mmap
block|}
block|,
comment|/* mmap */
block|{
operator|&
name|vop_fsync_desc
block|,
name|lofs_fsync
block|}
block|,
comment|/* fsync */
block|{
operator|&
name|vop_seek_desc
block|,
name|lofs_seek
block|}
block|,
comment|/* seek */
block|{
operator|&
name|vop_remove_desc
block|,
name|lofs_remove
block|}
block|,
comment|/* remove */
block|{
operator|&
name|vop_link_desc
block|,
name|lofs_link
block|}
block|,
comment|/* link */
block|{
operator|&
name|vop_rename_desc
block|,
name|lofs_rename
block|}
block|,
comment|/* rename */
block|{
operator|&
name|vop_mkdir_desc
block|,
name|lofs_mkdir
block|}
block|,
comment|/* mkdir */
block|{
operator|&
name|vop_rmdir_desc
block|,
name|lofs_rmdir
block|}
block|,
comment|/* rmdir */
block|{
operator|&
name|vop_symlink_desc
block|,
name|lofs_symlink
block|}
block|,
comment|/* symlink */
block|{
operator|&
name|vop_readdir_desc
block|,
name|lofs_readdir
block|}
block|,
comment|/* readdir */
block|{
operator|&
name|vop_readlink_desc
block|,
name|lofs_readlink
block|}
block|,
comment|/* readlink */
block|{
operator|&
name|vop_abortop_desc
block|,
name|lofs_abortop
block|}
block|,
comment|/* abortop */
block|{
operator|&
name|vop_inactive_desc
block|,
name|lofs_inactive
block|}
block|,
comment|/* inactive */
block|{
operator|&
name|vop_reclaim_desc
block|,
name|lofs_reclaim
block|}
block|,
comment|/* reclaim */
block|{
operator|&
name|vop_lock_desc
block|,
name|lofs_lock
block|}
block|,
comment|/* lock */
block|{
operator|&
name|vop_unlock_desc
block|,
name|lofs_unlock
block|}
block|,
comment|/* unlock */
block|{
operator|&
name|vop_bmap_desc
block|,
name|lofs_bmap
block|}
block|,
comment|/* bmap */
block|{
operator|&
name|vop_strategy_desc
block|,
name|lofs_strategy
block|}
block|,
comment|/* strategy */
block|{
operator|&
name|vop_print_desc
block|,
name|lofs_print
block|}
block|,
comment|/* print */
block|{
operator|&
name|vop_islocked_desc
block|,
name|lofs_islocked
block|}
block|,
comment|/* islocked */
block|{
operator|&
name|vop_pathconf_desc
block|,
name|lofs_pathconf
block|}
block|,
comment|/* pathconf */
block|{
operator|&
name|vop_advlock_desc
block|,
name|lofs_advlock
block|}
block|,
comment|/* advlock */
block|{
operator|&
name|vop_blkatoff_desc
block|,
name|lofs_blkatoff
block|}
block|,
comment|/* blkatoff */
block|{
operator|&
name|vop_valloc_desc
block|,
name|lofs_valloc
block|}
block|,
comment|/* valloc */
block|{
operator|&
name|vop_vfree_desc
block|,
name|lofs_vfree
block|}
block|,
comment|/* vfree */
block|{
operator|&
name|vop_truncate_desc
block|,
name|lofs_truncate
block|}
block|,
comment|/* truncate */
block|{
operator|&
name|vop_update_desc
block|,
name|lofs_update
block|}
block|,
comment|/* update */
block|{
operator|&
name|vop_bwrite_desc
block|,
name|lofs_bwrite
block|}
block|,
comment|/* bwrite */
block|{
operator|(
expr|struct
name|vnodeop_desc
operator|*
operator|)
name|NULL
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnodeopv_desc
name|lofs_vnodeop_opv_desc
init|=
block|{
operator|&
name|lofs_vnodeop_p
block|,
name|lofs_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

end_unit

