begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsident
index|[]
init|=
literal|"$Header: tcp_procs.c,v 1.32 85/07/31 09:34:27 walsh Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/fsm.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/tcp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/seq.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/macros.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HMPTRAPS
end_ifdef

begin_include
include|#
directive|include
file|"../bbnnet/hmp_traps.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * TCP finite state machine procedures.  *  * Called from finite state machine action routines, these do most of the work  * of the protocol.  They in turn call primitive routines (in tcp_prim) to  * perform lower level functions.  */
end_comment

begin_comment
comment|/*  * This works cooperatively with t_close for freeing up data on receive/send  * buffers.  */
end_comment

begin_macro
name|tcp_pcbdisconnect
argument_list|(
argument|inp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|tp
operator|=
operator|(
expr|struct
name|tcpcb
operator|*
operator|)
name|inp
operator|->
name|inp_ppcb
condition|)
block|{
name|inp
operator|->
name|inp_ppcb
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
comment|/* 	 * free all data on receive queues 	 */
block|{
specifier|register
name|struct
name|th
modifier|*
name|t
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|t
operator|=
name|tp
operator|->
name|t_rcv_next
expr_stmt|;
while|while
condition|(
name|t
operator|!=
operator|(
expr|struct
name|th
operator|*
operator|)
name|tp
condition|)
block|{
name|next
operator|=
name|t
operator|->
name|t_next
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|next
expr_stmt|;
block|}
block|}
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|m
operator|=
name|tp
operator|->
name|t_rcv_unack
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|m
operator|->
name|m_act
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|oob_data
condition|)
name|m_freem
argument_list|(
name|tp
operator|->
name|oob_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_template
condition|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|tp
operator|->
name|t_template
argument_list|)
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|dtom
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Delete TCB and free all resources used by the connection.  Called after  * the close protocol is complete.  */
end_comment

begin_expr_stmt
name|t_close
argument_list|(
name|tp
argument_list|,
name|state
argument_list|)
specifier|register
expr|struct
name|tcpcb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|short
name|state
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
comment|/*      * in_pcbdetach() calls soisdisconnected(), which wakes up the      * process if it's sleeping.  Need only pass user error code if      * appropriate (like ENETRESET) and hope he'll close the file      * descriptor.  Don't need to clear timers since they're in the      * tcpcb to be deleted.      */
name|inp
operator|=
name|tp
operator|->
name|t_in_pcb
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|usr_abort
condition|)
name|inp
operator|->
name|inp_socket
operator|->
name|so_error
operator|=
name|state
expr_stmt|;
name|in_pcbdetach
argument_list|(
name|inp
argument_list|,
name|tcp_pcbdisconnect
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|short
name|max_ack_skipped
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We are in a position where, perhaps, we should send a TCP segment (packet).  * The important decisions are:  *	1)  How big a segment should we send?  This is important since most  *		overhead occurs at the packet level (interrupts, queueing,  *		header field checks...) and not at the byte level.  *	2)  Is it worth it to send this packet?  Are we sending enough data  *		or would we be better off waiting for some more to queue up?  *  * The above requirements are the point of view when called in response to  * a user's write request.  We are also called on packet arrival in order  * to send an ack (with piggy-backed data), and to respond to window openings  * by sending any pent up data.  *  * Send a TCP segment.  Send data from left window edge of send buffer up to  * window size or end (whichever is less).  Set retransmission timers.  *  * The Ford/Nagle algorithms might be thought of (if outstanding data, only  * send if packet would be large), but they are primarily for telnet and   * that doesn't go with ideas in comments down by push.  Has idea of tcp  * changed since RFC?  */
end_comment

begin_expr_stmt
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|ctl
argument_list|)
specifier|register
expr|struct
name|tcpcb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ctl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|sequence
name|last
decl_stmt|,
name|wind
decl_stmt|;
specifier|register
name|int
name|snd_flags
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sosnd
decl_stmt|;
name|int
name|forced
decl_stmt|,
name|error
decl_stmt|;
name|int
name|sendalot
decl_stmt|;
name|sosnd
operator|=
operator|&
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_socket
operator|->
name|so_snd
expr_stmt|;
name|sendalot
operator|=
name|FALSE
expr_stmt|;
name|snd_flags
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|snd_lst
operator|=
name|tp
operator|->
name|snd_nxt
expr_stmt|;
name|forced
operator|=
name|FALSE
expr_stmt|;
comment|/*       * Send SYN if this is first data (ISS)      */
if|if
condition|(
name|SEQ_EQ
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|tp
operator|->
name|iss
argument_list|)
condition|)
block|{
name|snd_flags
operator||=
name|T_SYN
expr_stmt|;
name|tp
operator|->
name|snd_lst
operator|++
expr_stmt|;
block|}
comment|/*      * Get seq # of last datum in send buffer       */
name|last
operator|=
name|tp
operator|->
name|snd_una
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|syn_acked
condition|)
name|last
operator|++
expr_stmt|;
comment|/* don't forget SYN */
name|last
operator|+=
name|sosnd
operator|->
name|sb_cc
expr_stmt|;
comment|/*      * If no data to send in buffer, just do FIN check, otherwise see      * how much we should send in segment.      */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|last
argument_list|)
condition|)
block|{
comment|/* 	 * should send FIN?  don't unless haven't already sent one  	 */
if|if
condition|(
name|tp
operator|->
name|snd_fin
operator|&&
operator|(
name|SEQ_EQ
argument_list|(
name|tp
operator|->
name|seq_fin
argument_list|,
name|tp
operator|->
name|iss
argument_list|)
operator|||
name|SEQ_LEQ
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|tp
operator|->
name|seq_fin
argument_list|)
operator|)
condition|)
block|{
name|snd_flags
operator||=
name|T_FIN
expr_stmt|;
name|tp
operator|->
name|seq_fin
operator|=
name|tp
operator|->
name|snd_lst
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|syn_acked
condition|)
block|{
comment|/* 	 * We can't send more than we have (SYN + data represented 	 * by last).  Nor can we send more than the other end is 	 * prepared to receive (represented by the window in snd_wnd 	 * and wind). 	 * 	 * Only send a segment if there is something in the buffer, 	 * and a non-zero window has been received. 	 */
name|wind
operator|=
name|tp
operator|->
name|snd_una
operator|+
name|tp
operator|->
name|snd_wnd
expr_stmt|;
name|tp
operator|->
name|snd_lst
operator|=
name|SEQ_MIN
argument_list|(
name|last
argument_list|,
name|wind
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the segment is not larger than the remote end 	 * can handle.  Though they may advertise a 4K window, perhaps 	 * they can only fill it 512 bytes at a time due to some 	 * buffering or device driver constraint. 	 * 	 * If we're both on the local net, the maxseg is probably the 	 * mtu of the local network, and this will avoid some IP 	 * fragmentation. 	 * 	 * ">=" so that set sendalot. 	 */
if|if
condition|(
operator|(
name|len
operator|=
name|tp
operator|->
name|snd_lst
operator|-
name|tp
operator|->
name|snd_nxt
operator|)
operator|>=
name|tp
operator|->
name|t_maxseg
condition|)
block|{
name|tp
operator|->
name|snd_lst
operator|-=
name|len
operator|-
name|tp
operator|->
name|t_maxseg
expr_stmt|;
name|sendalot
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * If we're not on the same net or on similar nets immediately 	 * connected by a gateway, the negotiated maxseg may cause 	 * fragmentation.  Fragmentation per se is not bad, but 	 * tinygrams can cause problems and are inefficient.  So, 	 * send something that if it fragments, will produce reasonably 	 * sized fragments.  Avoid excessive fragmentation to reduce 	 * probability datagram fails to reassemble. 	 */
if|if
condition|(
name|tp
operator|->
name|t_maxfrag
condition|)
block|{
name|len
operator|=
name|tp
operator|->
name|t_maxfrag
operator|*
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|snd_lst
operator|-
name|tp
operator|->
name|snd_nxt
operator|)
operator|>
name|len
condition|)
block|{
name|tp
operator|->
name|snd_lst
operator|=
name|tp
operator|->
name|snd_nxt
operator|+
name|len
expr_stmt|;
name|sendalot
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|snd_end
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
operator|&&
name|SEQ_LEQ
argument_list|(
name|tp
operator|->
name|snd_end
argument_list|,
name|tp
operator|->
name|snd_lst
argument_list|)
condition|)
comment|/* 	     * There is data to send, and it should be PUSHed. 	     * PUSHed segments avoid the SWS algorithm since it 	     * might delay transmission.  PUSHed data MUST go 	     * out ASAP.  Note:  To avoid performance degradation, 	     * bulk data transfers should not have PUSH on. 	     */
name|snd_flags
operator||=
name|T_PUSH
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|snd_wnd
operator|>
literal|0
condition|)
block|{
comment|/* 	     * Avoid the silly window syndrome (sending small 	     * packets).  Making sure the usable window is at 	     * least some % of the offered window ensures we're 	     * sending a relatively (for this connection) good 	     * sized segment. 	     * 	     * If sbspace(sosnd) == 0, then the user 	     * is blocked for send resources, and we won't be 	     * able to send a larger packet later, so send it now. 	     * (Hmm, still true?  How about the wakeup after we 	     * trim the acked data?) 	     * 	     *      SWS and persistence interaction 	     * If there is outstanding data, snd_nxt - snd_una 	     * will be> 0, we'll have retransmit timers running 	     * forcing eventual window updates.  If there is 	     * no outstanding data, then we'll send some and 	     * start up the retransmit timers.  So, any time 	     * we run through this segment of code instead of 	     * the next one, we've got some good timers running. 	     */
if|if
condition|(
operator|!
name|tp
operator|->
name|rexmt
operator|&&
operator|!
name|tp
operator|->
name|ack_due
operator|&&
operator|!
name|tp
operator|->
name|snd_fin
operator|&&
operator|!
name|sendalot
operator|&&
name|sbspace
argument_list|(
name|sosnd
argument_list|)
operator|>
literal|0
operator|&&
operator|(
operator|(
literal|100
operator|*
operator|(
name|tp
operator|->
name|snd_nxt
operator|-
name|tp
operator|->
name|snd_una
operator|)
operator|)
operator|/
name|tp
operator|->
name|snd_wnd
operator|)
operator|>
name|tp
operator|->
name|sws_qff
condition|)
name|tp
operator|->
name|snd_lst
operator|=
name|tp
operator|->
name|snd_nxt
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * We have stuff to send, but can't since the other 	     * end can't handle it right now.  We start up the 	     * persistence timer in case their window opening 	     * ack is lost.  When the timer goes off, we send 	     * a byte to force a window update.  Wait for timer 	     * in order to give him a chance to deal with the 	     * remotely buffered data and send us an update. 	     * (We'll get here on acks that stop rxmit timers 	     * but that contain zero window since remote user 	     * has not picked up data yet.) 	     * 	     * If we're called due to a write() or packet arrival, 	     * this is how we enter the persistence state.  If 	     * we're called because the persist timer went off, 	     * the timer is restarted to keep persisting. 	     */
if|if
condition|(
name|tp
operator|->
name|t_timers
index|[
name|TPERSIST
index|]
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_timers
index|[
name|TPERSIST
index|]
operator|=
name|MIN
argument_list|(
name|TCP_tvMAXPERSIST
argument_list|,
name|MAX
argument_list|(
name|TCP_tvMINPERSIST
argument_list|,
name|tp
operator|->
name|t_srtt
operator|*
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|force_one
condition|)
block|{
comment|/* persist timer went off */
name|tp
operator|->
name|snd_lst
operator|=
name|tp
operator|->
name|snd_nxt
operator|+
literal|1
expr_stmt|;
name|forced
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* must send FIN and no more data left to send after this */
if|if
condition|(
name|tp
operator|->
name|snd_fin
operator|&&
operator|!
name|forced
operator|&&
name|SEQ_EQ
argument_list|(
name|tp
operator|->
name|snd_lst
argument_list|,
name|last
argument_list|)
operator|&&
operator|(
name|SEQ_EQ
argument_list|(
name|tp
operator|->
name|seq_fin
argument_list|,
name|tp
operator|->
name|iss
argument_list|)
operator|||
name|SEQ_LEQ
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|tp
operator|->
name|seq_fin
argument_list|)
operator|)
condition|)
block|{
name|snd_flags
operator||=
name|T_FIN
expr_stmt|;
name|tp
operator|->
name|seq_fin
operator|=
name|tp
operator|->
name|snd_lst
operator|++
expr_stmt|;
block|}
block|}
comment|/*      * Now, we have determined how large a segment to send if our only      * purpose is to get data to the other side.  If there is something      * to send, do it and update timers for rexmt.      */
name|len
operator|=
name|tp
operator|->
name|snd_lst
operator|-
name|tp
operator|->
name|snd_nxt
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* then SEQ_LT(tp->snd_nxt, tp->snd_lst) */
name|error
operator|=
name|send_pkt
argument_list|(
name|tp
argument_list|,
name|snd_flags
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * SEQ_LEQ(snd_nxt, t_xmt_val): if this is a retransmission 	 * of the round-trip-time measuring byte, then remeasure the 	 * round trip time.  (Keep rtt from drifting upward on lossy 	 * networks.) 	 * 	 * SEQ_GT(snd_una, t_xmt_val):  Measure the rtt if the last 	 * timed byte has been acked. 	 */
if|if
condition|(
name|tp
operator|->
name|syn_acked
operator|&&
operator|(
name|SEQ_LEQ
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|tp
operator|->
name|t_xmt_val
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|snd_una
argument_list|,
name|tp
operator|->
name|t_xmt_val
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_srtt
operator|!=
literal|0
condition|)
name|tp
operator|->
name|t_timers
index|[
name|TXMT
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_xmt_val
operator|=
name|tp
operator|->
name|snd_nxt
expr_stmt|;
block|}
comment|/* 	 * If the window was full, and we're just forcing a byte 	 * out to try to get a new window, then don't use 	 * retransmission timeouts.  The other side can take as 	 * long as it wants to process the data it's currently got. 	 */
if|if
condition|(
operator|!
name|forced
condition|)
block|{
comment|/* 	     * Set timers for retransmission.  If we already have 	     * some outstanding data, then don't reset timer.  Think 	     * of case where send one byte every 1/4 second and only 	     * first byte is lost.  Would need to wait until filled 	     * window before retransmission timer started to decrease 	     * and go off. 	     */
if|if
condition|(
name|tp
operator|->
name|t_timers
index|[
name|TREXMT
index|]
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_timers
index|[
name|TREXMT
index|]
operator|=
name|tp
operator|->
name|t_rxmitime
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_timers
index|[
name|TREXMTTL
index|]
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_timers
index|[
name|TREXMTTL
index|]
operator|=
name|tp
operator|->
name|t_rttltimeo
expr_stmt|;
comment|/* 	     * and remember that next segment out begins 	     * further into the stream if this one got out. 	     */
if|if
condition|(
operator|!
name|error
condition|)
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_lst
expr_stmt|;
block|}
if|#
directive|if
name|T_DELACK
operator|>
literal|0
name|t_cancel
argument_list|(
name|tp
argument_list|,
name|TDELACK
argument_list|)
expr_stmt|;
name|tp
operator|->
name|force_ack
operator|=
name|FALSE
expr_stmt|;
name|tp
operator|->
name|ack_skipped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|tp
operator|->
name|ack_due
operator|=
name|FALSE
expr_stmt|;
name|tp
operator|->
name|snd_hi
operator|=
name|SEQ_MAX
argument_list|(
name|tp
operator|->
name|snd_lst
argument_list|,
name|tp
operator|->
name|snd_hi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/*      * If ctl, make sure to send something so ACK gets through.  Attempt      * to reduce ACK traffic by delaying ACKs with no data slightly.      * Naive ack traffic can account for about 10% of what the receiving      * tcp is doing.      *      * Bidirectional connection (telnet) => ack piggy backs application's      * response.      *      * Unidirectional connection (ftp) => advertise large enough window      * so that either #skipped (tp->ack_skipped) or our estimate of what he      * thinks window is cause ack.  The estimate assumes most packets get      * through.  This also assumes that the sender buffers enough to take      * advantage of the estimated usable window, so we'll assume a minimum      * send buffer provided by his operating system.  (Remember, his OS has      * to buffer it until we ack it.)      *      * So, test assumes his send buffer> MINTCPBUF bytes large      * and his silly window algorithm cuts in at< 50% of window.      *      * Use of the fasttimeout facility is a possibility.      */
if|if
condition|(
name|ctl
operator|==
name|TCP_CTL
condition|)
block|{
if|#
directive|if
name|T_DELACK
operator|>
literal|0
if|if
condition|(
name|tp
operator|->
name|force_ack
operator|||
operator|(
name|tp
operator|->
name|ack_skipped
operator|>=
name|max_ack_skipped
operator|)
operator|||
operator|(
operator|(
name|tp
operator|->
name|rcv_nxt
operator|-
name|tp
operator|->
name|lastack
operator|)
operator|>
name|MIN
argument_list|(
name|MINTCPBUF
argument_list|,
name|tp
operator|->
name|rcv_wnd
operator|>>
literal|1
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|send_pkt
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t_cancel
argument_list|(
name|tp
argument_list|,
name|TDELACK
argument_list|)
expr_stmt|;
name|tp
operator|->
name|force_ack
operator|=
name|FALSE
expr_stmt|;
name|tp
operator|->
name|ack_skipped
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|ack_due
operator|=
name|FALSE
expr_stmt|;
name|tcpstat
operator|.
name|t_ackonly
operator|++
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|ack_skipped
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_timers
index|[
name|TDELACK
index|]
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_timers
index|[
name|TDELACK
index|]
operator|=
name|T_DELACK
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|send_pkt
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ack_due
operator|=
name|FALSE
expr_stmt|;
name|tcpstat
operator|.
name|t_ackonly
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Process incoming ACKs.  Remove data from send queue up to acknowledgement.  * Also handles round-trip timer for retransmissions and acknowledgement of  * SYN, and clears the urgent flag if required.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BBNPING
end_ifdef

begin_define
define|#
directive|define
name|BBNPING_RESET
parameter_list|(
name|inp
parameter_list|,
name|len
parameter_list|)
define|\
value|if (len> 0){ \
comment|/* \ 		 * We've sent him NEW data, perhaps by a gateway, that he \ 		 * has successfully received.  If that's the case, then \ 		 * we know the route works and we don't have to ping that \ 		 * gateway. \ 		 * \ 		 * see check_ping() \ 		 */
value|\ 		register struct rtentry *rt; \  \ 		if (rt = inp->inp_route.ro_rt) \ 			if (rt->rt_flags& RTF_GATEWAY) \ 				rt->irt_pings = (-1); \ 	}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BBNPING_RESET
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_comment
comment|/* */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MBUF_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|LENCHECK
define|\
value|if ((len> sosnd->sb_cc) || (len< 0)){			\ 		printf("len %d sb_cc %d flags 0x%x state %d\n",	\ 		   len, sosnd->sb_cc, n->t_flags, tp->t_state);	\ 		if (len< 0)					\ 			len = 0;				\ 		else						\ 			len = sosnd->sb_cc;			\ 	}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LENCHECK
end_define

begin_comment
comment|/* */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|smooth
parameter_list|(
name|tp
parameter_list|)
value|(((75*(tp)->t_timers[TXMT]) + (125*(tp)->t_srtt)) / 200)
end_define

begin_define
define|#
directive|define
name|RCV_ACK
parameter_list|(
name|tp
parameter_list|,
name|n
parameter_list|)
define|\
value|{ \ 	register struct inpcb *inp; \ 	register struct sockbuf *sosnd; \ 	register len; \  \ 	inp	= tp->t_in_pcb; \ 	sosnd	=&inp->inp_socket->so_snd; \ 	len	= n->t_ackno - tp->snd_una;  \  \ 	tp->snd_una = n->t_ackno; \ 	if (SEQ_GT(tp->snd_una, tp->snd_nxt))  \ 		tp->snd_nxt = tp->snd_una; \  \
comment|/* \ 	 * if urgent data has been acked, reset urgent flag \ 	 */
value|\  \ 	if (tp->snd_urg&& SEQ_GEQ(tp->snd_una, tp->snd_urp)) \ 		tp->snd_urg = FALSE; \  \ 	if (tp->syn_acked) { \
comment|/* if timed message has been acknowledged, use the time to set \ 		   the retransmission time value, exponential decay, 60/40 \ 		   weighted average */
value|\  \ 		if (SEQ_GEQ(tp->snd_una, tp->t_xmt_val)) {			\ 			if (tp->t_srtt == 0)					\ 				tp->t_srtt = tp->t_timers[TXMT];		\ 			else							\ 				tp->t_srtt = smooth(tp);			\ 			tp->t_rxmitime = MIN(TCP_tvRXMAX,			\ 					   MAX(TCP_tvRXMIN, (3*tp->t_srtt)/2)); \ 		} \ 	} else { \
comment|/* handle ack of opening syn (tell user) */
value|\  \ 		if (SEQ_GT(tp->snd_una, tp->iss)) { \ 			tp->syn_acked = TRUE; \ 			len--;
comment|/* ignore SYN */
value|\ 			t_cancel(tp, TINIT);
comment|/* cancel init timer */
value|\ 		} \ 	} \  \
comment|/* remove acknowledged data from send buff */
value|\ 	if (ack_fin(tp, n)) \ 		len --; \ 	LENCHECK \ 	sbdrop (sosnd, len); \ 	BBNPING_RESET(inp, len) \ 	sbwakeup (sosnd);
comment|/* wakeup iff> x% of buffering avail? */
value|\  \
comment|/* handle ack of closing fin */
value|\  \ 	if (SEQ_NEQ(tp->seq_fin, tp->iss)&& SEQ_GT(tp->snd_una, tp->seq_fin)) \ 		tp->snd_fin = FALSE; \ 	t_cancel(tp, TREXMT);
comment|/* cancel retransmit timer */
value|\ 	t_cancel(tp, TREXMTTL);
comment|/* cancel retransmit too long timer */
value|\ 	tp->cancelled = TRUE; \ }
end_define

begin_comment
comment|/*  * Process incoming segments   */
end_comment

begin_expr_stmt
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
name|n
argument_list|,
name|ctl
argument_list|)
specifier|register
expr|struct
name|tcpcb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|th
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ctl
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sentsomedata
decl_stmt|;
name|tp
operator|->
name|dropped_txt
operator|=
name|FALSE
expr_stmt|;
name|tp
operator|->
name|ack_due
operator|=
name|FALSE
expr_stmt|;
name|tp
operator|->
name|new_window
operator|=
name|FALSE
expr_stmt|;
comment|/*      * Process SYN      */
if|if
condition|(
operator|!
name|tp
operator|->
name|syn_rcvd
operator|&&
name|n
operator|->
name|t_flags
operator|&
name|T_SYN
condition|)
block|{
name|tp
operator|->
name|snd_wl
operator|=
name|tp
operator|->
name|rcv_urp
operator|=
name|tp
operator|->
name|irs
operator|=
name|n
operator|->
name|t_seq
expr_stmt|;
name|tp
operator|->
name|rcv_urpend
operator|=
name|tp
operator|->
name|rcv_urp
operator|-
literal|1
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|=
name|n
operator|->
name|t_seq
operator|+
literal|1
expr_stmt|;
name|tp
operator|->
name|syn_rcvd
operator|=
name|TRUE
expr_stmt|;
name|tp
operator|->
name|ack_due
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|syn_rcvd
condition|)
block|{
comment|/* 	 * Process ACK if data not already acked previously. (Take  	 * ACKed data off send queue, and reset rexmt timers). 	 */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_ACK
operator|&&
name|SEQ_GT
argument_list|(
name|n
operator|->
name|t_ackno
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
condition|)
name|RCV_ACK
argument_list|(
argument|tp
argument_list|,
argument|n
argument_list|)
comment|/* 	 * Check for new window.  rcv_ack did not change syn_rcvd. 	 */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|n
operator|->
name|t_seq
argument_list|,
name|tp
operator|->
name|snd_wl
argument_list|)
condition|)
block|{
name|tp
operator|->
name|snd_wl
operator|=
name|n
operator|->
name|t_seq
expr_stmt|;
name|tp
operator|->
name|snd_wnd
operator|=
name|n
operator|->
name|t_win
expr_stmt|;
name|tp
operator|->
name|new_window
operator|=
name|TRUE
expr_stmt|;
name|t_cancel
argument_list|(
name|tp
argument_list|,
name|TPERSIST
argument_list|)
expr_stmt|;
comment|/* cancel persist timer */
block|}
block|}
comment|/*      * For data packets only (vs. ctl), process data and URG.      */
if|if
condition|(
name|ctl
operator|==
name|TCP_DATA
condition|)
block|{
comment|/* 	 * Remember how much urgent data for present_data 	 */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_URG
condition|)
block|{
comment|/* 	     * if last<= urpend, then is a retransmission 	     * bytes [n->t_seq ... last] are urgent 	     */
specifier|register
name|sequence
name|last
decl_stmt|;
name|last
operator|=
name|n
operator|->
name|t_seq
operator|+
name|n
operator|->
name|t_urp
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|last
argument_list|,
name|tp
operator|->
name|rcv_urpend
argument_list|)
condition|)
block|{
comment|/* 		 * Can only remember one contiguous region. 		 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|n
operator|->
name|t_seq
argument_list|,
name|tp
operator|->
name|rcv_urpend
operator|+
literal|1
argument_list|)
condition|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|tp
operator|->
name|rcv_urp
operator|=
name|n
operator|->
name|t_seq
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|oob_data
condition|)
block|{
name|m_freem
argument_list|(
name|tp
operator|->
name|oob_data
argument_list|)
expr_stmt|;
name|tp
operator|->
name|oob_data
operator|=
name|NULL
expr_stmt|;
block|}
name|so
operator|=
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_socket
expr_stmt|;
name|so
operator|->
name|so_oobmark
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|+
operator|(
name|tp
operator|->
name|rcv_urp
operator|-
name|tp
operator|->
name|rcv_nxt
operator|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_oobmark
operator|==
literal|0
condition|)
name|so
operator|->
name|so_state
operator||=
name|SS_RCVATMARK
expr_stmt|;
block|}
name|tp
operator|->
name|rcv_urpend
operator|=
name|last
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|->
name|t_len
operator|!=
literal|0
condition|)
name|rcv_text
argument_list|(
name|tp
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* accept and sequence data */
comment|/*  	 * Delay extraction of out-of-band data until 	 * present_data() so don't have to worry about 	 * duplication... 	 */
ifdef|#
directive|ifdef
name|bsd41
comment|/* 	 * Process PUSH, mark end of data chain. 	 * 	 * Not done in 4.2.  TCP is a byte stream, without record 	 * boundries, so don't have to mark for sbappend(), which 	 * preserves marks, and soreceive(), which terminates reads 	 * at marks.  Data IS pushed nevertheless since soreceive 	 * gives the user all that is available and returns. 	 */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_PUSH
operator|&&
operator|!
name|tp
operator|->
name|dropped_txt
operator|&&
name|tp
operator|->
name|t_rcv_prev
operator|!=
operator|(
expr|struct
name|th
operator|*
operator|)
name|tp
condition|)
block|{
comment|/* Find last mbuf on received data chain and mark */
name|m
operator|=
name|dtom
argument_list|(
name|tp
operator|->
name|t_rcv_prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|)
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_act
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/*      * Process FIN, check for duplicates and make sure all data is in.      */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_FIN
operator|&&
operator|!
name|tp
operator|->
name|dropped_txt
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|fin_rcvd
condition|)
name|tp
operator|->
name|ack_due
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* 	     * Check if we really have FIN  	     * (rcv buf filled in, no drops)  	     */
specifier|register
name|sequence
name|last
decl_stmt|;
name|last
operator|=
name|firstempty
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_rcv_prev
operator|==
operator|(
expr|struct
name|th
operator|*
operator|)
name|tp
operator|&&
name|SEQ_EQ
argument_list|(
name|last
argument_list|,
name|t_end
argument_list|(
name|n
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|||
name|SEQ_EQ
argument_list|(
name|last
argument_list|,
name|t_end
argument_list|(
name|tp
operator|->
name|t_rcv_prev
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
block|{
name|tp
operator|->
name|fin_rcvd
operator|=
name|TRUE
expr_stmt|;
name|uwake
argument_list|(
name|tp
operator|->
name|t_in_pcb
argument_list|)
expr_stmt|;
block|}
comment|/*  	     * If FIN, then set to ACK: incr rcv_nxt, since FIN  	     * occupies sequence space  	     */
if|if
condition|(
name|tp
operator|->
name|fin_rcvd
operator|&&
name|SEQ_GEQ
argument_list|(
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|last
argument_list|)
condition|)
block|{
name|tp
operator|->
name|rcv_nxt
operator|=
name|last
operator|+
literal|1
expr_stmt|;
name|tp
operator|->
name|ack_due
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/*      * If ACK required or rcv window has changed, try to send something.      */
name|sentsomedata
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ack_due
condition|)
name|sentsomedata
operator|=
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|new_window
condition|)
name|sentsomedata
operator|=
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
comment|/*            * tp->cancelled => retransmit, rttl timers are now zero      *      * If didn't send any data, might not have retransmit, rttl timers      * running.  If we still have unACKed data and we turned off      * the timers above, then ensure timers are running.      */
if|if
condition|(
operator|!
name|sentsomedata
operator|&&
name|is_unacked
argument_list|(
name|tp
argument_list|)
operator|&&
name|tp
operator|->
name|cancelled
condition|)
block|{
name|tp
operator|->
name|t_timers
index|[
name|TREXMT
index|]
operator|=
name|tp
operator|->
name|t_rxmitime
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TREXMTTL
index|]
operator|=
name|tp
operator|->
name|t_rttltimeo
expr_stmt|;
name|tp
operator|->
name|cancelled
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_block

begin_undef
undef|#
directive|undef
name|BBNPING_RESET
end_undef

begin_undef
undef|#
directive|undef
name|LENCHECK
end_undef

begin_comment
comment|/*  * Process incoming data.  Put the segments on sequencing queue in order,  * taking care of overlaps and duplicates.  Data is removed from sequence  * queue by present_data when sequence is complete (no holes at top).  * Drop data that falls outside buffer quota if tight for space.  Otherwise,  * process and recycle data held in tcp_input.  */
end_comment

begin_expr_stmt
name|rcv_text
argument_list|(
name|tp
argument_list|,
name|t
argument_list|)
specifier|register
expr|struct
name|tcpcb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|th
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|sockbuf
modifier|*
name|sorcv
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|th
modifier|*
name|q
decl_stmt|;
name|struct
name|th
modifier|*
name|p
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|th
modifier|*
name|savq
decl_stmt|;
name|int
name|j
decl_stmt|,
name|oldkeep
decl_stmt|;
name|sequence
name|last
decl_stmt|;
comment|/* throw away any data we have already received */
if|if
condition|(
operator|(
name|i
operator|=
name|tp
operator|->
name|rcv_nxt
operator|-
name|t
operator|->
name|t_seq
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|t
operator|->
name|t_len
condition|)
block|{
name|t
operator|->
name|t_seq
operator|+=
name|i
expr_stmt|;
name|t
operator|->
name|t_len
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|dtom
argument_list|(
name|t
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_olddata
operator|++
expr_stmt|;
name|tp
operator|->
name|ack_due
operator|=
name|TRUE
expr_stmt|;
comment|/* send ack just in case */
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_TCP_DUP, (caddr_t)0,0); */
endif|#
directive|endif
return|return;
block|}
block|}
name|last
operator|=
name|t_end
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* last seq # in incoming seg */
comment|/* # buffers available to con */
name|sorcv
operator|=
operator|&
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_socket
operator|->
name|so_rcv
expr_stmt|;
name|i
operator|=
name|sbspace
argument_list|(
name|sorcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* enough resources to process segment? used to walk mbuf chain to      * count up data bytes. let's be smart and use t_len */
name|j
operator|=
name|t
operator|->
name|t_len
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|i
condition|)
block|{
comment|/* if segment preceeds top of sequencing queue, try to take 	   buffers from bottom of queue */
name|q
operator|=
name|tp
operator|->
name|t_rcv_next
expr_stmt|;
if|if
condition|(
name|q
operator|!=
operator|(
expr|struct
name|th
operator|*
operator|)
name|tp
operator|&&
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|q
operator|->
name|t_seq
argument_list|)
operator|&&
name|SEQ_LT
argument_list|(
name|t
operator|->
name|t_seq
argument_list|,
name|q
operator|->
name|t_seq
argument_list|)
condition|)
for|for
control|(
name|p
operator|=
name|tp
operator|->
name|t_rcv_prev
init|;
name|i
operator|<
name|j
operator|&&
name|p
operator|!=
operator|(
expr|struct
name|th
operator|*
operator|)
name|tp
condition|;
control|)
block|{
name|savq
operator|=
name|p
operator|->
name|t_prev
expr_stmt|;
name|TCP_DEQ
argument_list|(
name|p
argument_list|,
name|tp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_TCP_UDROP, (caddr_t)0,0); */
endif|#
directive|endif
for|for
control|(
name|m
operator|=
name|dtom
argument_list|(
name|p
argument_list|)
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
control|)
name|i
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|p
operator|=
name|savq
expr_stmt|;
block|}
comment|/* if still not enough room, drop text from end of new segment */
if|if
condition|(
name|j
operator|>
name|i
condition|)
block|{
for|for
control|(
name|m
operator|=
name|dtom
argument_list|(
name|t
argument_list|)
init|;
name|i
operator|>
literal|0
operator|&&
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|i
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|t
operator|->
name|t_len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|last
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|tp
operator|->
name|dropped_txt
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_TCP_RDROP, (caddr_t)0,0); */
endif|#
directive|endif
if|if
condition|(
name|SEQ_LT
argument_list|(
name|last
argument_list|,
name|t
operator|->
name|t_seq
argument_list|)
condition|)
return|return;
block|}
block|}
comment|/* merge incoming data into the sequence queue */
name|q
operator|=
name|tp
operator|->
name|t_rcv_next
expr_stmt|;
comment|/* -> top of sequencing queue */
comment|/* skip frags which new doesn't overlap at end */
while|while
condition|(
operator|(
name|q
operator|!=
operator|(
expr|struct
name|th
operator|*
operator|)
name|tp
operator|)
operator|&&
name|SEQ_GT
argument_list|(
name|t
operator|->
name|t_seq
argument_list|,
name|t_end
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
name|q
operator|=
name|q
operator|->
name|t_next
expr_stmt|;
if|if
condition|(
name|q
operator|==
operator|(
expr|struct
name|th
operator|*
operator|)
name|tp
condition|)
block|{
comment|/* frag at end of chain */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|last
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|)
condition|)
block|{
name|tcp_net_keep
operator|=
name|TRUE
expr_stmt|;
name|TCP_ENQ
argument_list|(
name|t
argument_list|,
name|tp
operator|->
name|t_rcv_prev
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* we've received an out-of-order packet: trap! */
comment|/* hmp_trap(T_TCP_ORDER, (caddr_t)0,0); */
endif|#
directive|endif
comment|/* frag doesn't overlap any on chain */
if|if
condition|(
name|SEQ_LT
argument_list|(
name|last
argument_list|,
name|q
operator|->
name|t_seq
argument_list|)
condition|)
block|{
name|tcp_net_keep
operator|=
name|TRUE
expr_stmt|;
name|TCP_ENQ
argument_list|(
name|t
argument_list|,
name|q
operator|->
name|t_prev
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* new overlaps beginning of next frag only */
block|}
elseif|else
if|if
condition|(
name|SEQ_LT
argument_list|(
name|last
argument_list|,
name|t_end
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|last
operator|-
name|q
operator|->
name|t_seq
operator|+
literal|1
operator|)
operator|<
name|t
operator|->
name|t_len
condition|)
block|{
name|t
operator|->
name|t_len
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|dtom
argument_list|(
name|t
argument_list|)
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
name|tcp_net_keep
operator|=
name|TRUE
expr_stmt|;
name|TCP_ENQ
argument_list|(
name|t
argument_list|,
name|q
operator|->
name|t_prev
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* new overlaps end of previous frag */
block|}
else|else
block|{
name|savq
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|t
operator|->
name|t_seq
argument_list|,
name|q
operator|->
name|t_seq
argument_list|)
condition|)
block|{
comment|/* complete cover */
name|savq
operator|=
name|q
operator|->
name|t_prev
expr_stmt|;
name|TCP_DEQ
argument_list|(
name|q
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* overlap */
if|if
condition|(
operator|(
name|i
operator|=
name|t_end
argument_list|(
name|q
argument_list|)
operator|-
name|t
operator|->
name|t_seq
operator|+
literal|1
operator|)
operator|<
name|t
operator|->
name|t_len
condition|)
block|{
name|t
operator|->
name|t_seq
operator|+=
name|i
expr_stmt|;
name|t
operator|->
name|t_len
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|dtom
argument_list|(
name|t
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|->
name|t_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* new overlaps at beginning of successor frags */
name|q
operator|=
name|savq
operator|->
name|t_next
expr_stmt|;
while|while
condition|(
operator|(
name|q
operator|!=
operator|(
expr|struct
name|th
operator|*
operator|)
name|tp
operator|)
operator|&&
operator|(
name|t
operator|->
name|t_len
operator|!=
literal|0
operator|)
operator|&&
name|SEQ_LEQ
argument_list|(
name|q
operator|->
name|t_seq
argument_list|,
name|last
argument_list|)
condition|)
comment|/* complete cover */
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|t_end
argument_list|(
name|q
argument_list|)
argument_list|,
name|last
argument_list|)
condition|)
block|{
name|p
operator|=
name|q
operator|->
name|t_next
expr_stmt|;
name|TCP_DEQ
argument_list|(
name|q
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
comment|/* overlap */
if|if
condition|(
operator|(
name|i
operator|=
name|last
operator|-
name|q
operator|->
name|t_seq
operator|+
literal|1
operator|)
operator|<
name|t
operator|->
name|t_len
condition|)
block|{
name|t
operator|->
name|t_len
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|dtom
argument_list|(
name|t
argument_list|)
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|->
name|t_len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* enqueue whatever is left of new before successors */
if|if
condition|(
name|t
operator|->
name|t_len
operator|!=
literal|0
condition|)
block|{
name|tcp_net_keep
operator|=
name|TRUE
expr_stmt|;
name|TCP_ENQ
argument_list|(
name|t
argument_list|,
name|savq
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* set to ack completed data (no gaps) */
name|FIRSTEMPTY
argument_list|(
name|tp
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ack_due
operator|=
name|TRUE
expr_stmt|;
comment|/* if any room remaining in rcv buf, take any unprocessed        messages and schedule for later processing */
if|if
condition|(
operator|(
name|m
operator|=
name|tp
operator|->
name|t_rcv_unack
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|=
name|sbspace
argument_list|(
name|sorcv
argument_list|)
operator|)
operator|>
literal|0
condition|)
do|do
block|{
comment|/* schedule work request */
name|t
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|th
operator|*
argument_list|)
expr_stmt|;
name|j
operator|=
operator|(
name|t
operator|->
name|t_off
operator|<<
name|TCP_OFFSHIFT
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|+=
name|j
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|j
expr_stmt|;
name|tp
operator|->
name|t_rcv_unack
operator|=
name|m
operator|->
name|m_act
expr_stmt|;
name|m
operator|->
name|m_act
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|oldkeep
operator|=
name|tcp_net_keep
expr_stmt|;
name|tcpstat
operator|.
name|t_unack
operator|++
expr_stmt|;
name|w_alloc
argument_list|(
name|INRECV
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|tcp_net_keep
operator|=
name|oldkeep
expr_stmt|;
comment|/* remaining buffer space */
for|for
control|(
name|n
operator|=
name|m
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|i
operator|-=
name|n
operator|->
name|m_len
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|m
operator|=
name|tp
operator|->
name|t_rcv_unack
operator|)
operator|!=
name|NULL
operator|&&
name|i
operator|>
literal|0
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  * Send a reset segment  */
end_comment

begin_expr_stmt
name|send_rst
argument_list|(
name|tp
argument_list|,
name|n
argument_list|)
specifier|register
expr|struct
name|tcpcb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|th
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|in_addr
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|int
name|temp_rst
decl_stmt|;
comment|/* don't send a reset in response to a reset */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_RST
operator|||
operator|(
name|inp
operator|=
name|tp
operator|->
name|t_in_pcb
operator|)
operator|==
name|NULL
condition|)
return|return;
name|tp
operator|->
name|snd_rst
operator|=
name|TRUE
expr_stmt|;
name|temp_rst
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_ACK
condition|)
name|tp
operator|->
name|snd_nxt
operator|=
name|n
operator|->
name|t_ackno
expr_stmt|;
comment|/* if reset required from "wildcard" listener, take addresses and        port from incoming packet */
if|if
condition|(
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
literal|0
operator|||
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|==
literal|0
operator|||
name|inp
operator|->
name|inp_fport
operator|==
literal|0
condition|)
block|{
name|src
operator|=
name|inp
operator|->
name|inp_laddr
expr_stmt|;
name|dst
operator|=
name|inp
operator|->
name|inp_faddr
expr_stmt|;
name|port
operator|=
name|inp
operator|->
name|inp_fport
expr_stmt|;
name|inp
operator|->
name|inp_laddr
operator|=
name|n
operator|->
name|t_d
expr_stmt|;
name|inp
operator|->
name|inp_faddr
operator|=
name|n
operator|->
name|t_s
expr_stmt|;
name|inp
operator|->
name|inp_fport
operator|=
name|n
operator|->
name|t_src
expr_stmt|;
name|tp
operator|->
name|t_template
operator|=
name|tcp_template
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|temp_rst
operator|=
name|TRUE
expr_stmt|;
block|}
name|tp
operator|->
name|syn_rcvd
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_template
condition|)
operator|(
name|void
operator|)
name|send_pkt
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"send_rst: no template\n"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ack_due
operator|=
name|FALSE
expr_stmt|;
name|tp
operator|->
name|snd_rst
operator|=
name|FALSE
expr_stmt|;
if|#
directive|if
name|T_DELACK
operator|>
literal|0
name|tp
operator|->
name|force_ack
operator|=
name|FALSE
expr_stmt|;
name|t_cancel
argument_list|(
name|tp
argument_list|,
name|TDELACK
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ack_skipped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* restore "wildcard" addresses */
if|if
condition|(
name|temp_rst
condition|)
block|{
name|inp
operator|->
name|inp_laddr
operator|=
name|src
expr_stmt|;
name|inp
operator|->
name|inp_faddr
operator|=
name|dst
expr_stmt|;
name|inp
operator|->
name|inp_fport
operator|=
name|port
expr_stmt|;
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|iss
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|!=
name|NULL
condition|)
block|{
name|rtfree
argument_list|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_template
condition|)
block|{
name|m_free
argument_list|(
name|dtom
argument_list|(
name|tp
operator|->
name|t_template
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_template
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|struct
name|mbuf
modifier|*
name|extract_oob
parameter_list|(
name|tp
parameter_list|,
name|mp
parameter_list|,
name|sorcv
parameter_list|)
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sorcv
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
name|here
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|,
name|len
decl_stmt|,
name|tmp
decl_stmt|;
name|m
operator|=
name|mp
expr_stmt|;
name|so
operator|=
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_socket
expr_stmt|;
comment|/*      * skip over bytes that preceed out of band data.      */
if|if
condition|(
operator|(
name|off
operator|=
name|so
operator|->
name|so_oobmark
operator|-
name|sorcv
operator|->
name|sb_cc
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|KERN_RECOV
argument_list|,
literal|"extract_oob:  neg off\n"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_urpend
operator|=
name|tp
operator|->
name|rcv_urp
operator|=
name|tp
operator|->
name|irs
expr_stmt|;
return|return
operator|(
name|mp
operator|)
return|;
block|}
while|while
condition|(
name|m
operator|&&
operator|(
name|off
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
name|off
condition|)
block|{
name|off
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|!
name|m
condition|)
return|return
operator|(
name|mp
operator|)
return|;
comment|/*      * copy out of band data.  removing it from input stream.      */
name|len
operator|=
name|tp
operator|->
name|rcv_urpend
operator|-
name|tp
operator|->
name|rcv_urp
operator|+
literal|1
expr_stmt|;
comment|/* # urgent bytes */
name|top
operator|=
name|here
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|m
operator|&&
operator|(
name|len
operator|>
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|newm
decl_stmt|;
name|int
name|dropped
decl_stmt|;
name|tmp
operator|=
name|MIN
argument_list|(
name|m
operator|->
name|m_len
operator|-
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* tmp == # urgent bytes in this mbuf */
name|len
operator|-=
name|tmp
expr_stmt|;
name|tp
operator|->
name|rcv_urp
operator|+=
name|tmp
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
expr_stmt|;
comment|/* points at first urgent byte */
name|dropped
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|tmp
operator|>
literal|0
condition|)
block|{
name|unsigned
name|nbytes
decl_stmt|;
comment|/* in case this mbuf uses pages */
name|nbytes
operator|=
name|MIN
argument_list|(
name|tmp
argument_list|,
name|MLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dropped
condition|)
block|{
if|if
condition|(
name|newm
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|p
argument_list|,
name|mtod
argument_list|(
name|newm
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|newm
operator|->
name|m_len
operator|=
name|nbytes
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
name|top
operator|=
name|here
operator|=
name|newm
expr_stmt|;
else|else
block|{
name|here
operator|->
name|m_next
operator|=
name|newm
expr_stmt|;
name|here
operator|=
name|here
operator|->
name|m_next
expr_stmt|;
block|}
block|}
else|else
comment|/* potential unreliability */
name|dropped
operator|=
name|TRUE
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|p
operator|+
name|nbytes
argument_list|,
name|p
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|m
operator|->
name|m_len
operator|-
name|off
operator|-
name|nbytes
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|nbytes
expr_stmt|;
name|tmp
operator|-=
name|nbytes
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
literal|0
condition|)
block|{
comment|/* 	     * So soreceive never sees a zero length mbuf 	     * with m_act set.  (PUSHED URGENT data packet) 	     */
if|if
condition|(
name|m
operator|==
name|mp
condition|)
name|mp
operator|=
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|top
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|oob_data
condition|)
name|m_cat
argument_list|(
name|tp
operator|->
name|oob_data
argument_list|,
name|top
argument_list|)
expr_stmt|;
else|else
name|tp
operator|->
name|oob_data
operator|=
name|top
expr_stmt|;
name|sohasoutofband
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Accept data for the user to receive.  Moves data from sequenced tcp  * segments from the sequencing queue to the user's receive queue (in the  * ucb).  Observes locking on receive queue.  */
end_comment

begin_expr_stmt
name|present_data
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tcpcb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|PRESENT_DATA
argument_list|(
argument|tp
argument_list|)
block|}
end_block

end_unit

