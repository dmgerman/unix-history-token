begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/icmp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/nopcb.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
modifier|*
name|inetifp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We are generating an ICMP error message in response to this packet sent  * to us.  Too bad the device driver doesn't pair a pointer to its ifnet with  * the incoming packet.  That would save us a search, and we could use that  * for our source address in the ICMP error message.  *  * Pick a source address for that ICMP error message we send.  We can't  * always use ip_dst of the original for the ip_src of the ICMP error  * message since the packet may have been broadcast.  *  * We try to establish a proper interface to respond by in case we're  * multi-homed.  Try to respond by interface received on rather than  * interface that represents most direct route back.  */
end_comment

begin_function
name|struct
name|in_addr
name|icmp_addr
parameter_list|(
name|ip
parameter_list|)
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
ifdef|#
directive|ifdef
name|bsd42
comment|/* don't want broadcasts to match */
if|if
condition|(
operator|!
operator|(
name|ia
operator|=
name|in_iawithaddr
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
block|{
comment|/* hmm, try for the net... */
if|if
condition|(
operator|(
name|ia
operator|=
name|in_iawithnet
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|l
decl_stmt|;
comment|/* 	     * The message will be sent by ip_send() who will 	     * route the message and discover that a local address 	     * should be set on the basis of the route used. 	     */
name|l
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
block|}
endif|#
directive|endif
name|ia
operator|=
name|in_iafromif
argument_list|(
name|inetifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|IA_INADDR
argument_list|(
name|ia
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * notes to above mostly apply  *  * icmp_addr() sort of assumes the packet was addressed to us.  But when we  * act as a getway, S sends to A1, and we use A2 to get to D.  We want to  * reply with the A1 address, not the A2 address.  */
end_comment

begin_function
name|struct
name|in_addr
name|redir_addr
parameter_list|(
name|ip
parameter_list|)
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
block|{
specifier|register
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
ifdef|#
directive|ifdef
name|bsd42
comment|/* note we use ip_src, not ip_dst here */
if|if
condition|(
operator|(
name|ia
operator|=
name|in_iawithnet
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|l
decl_stmt|;
name|l
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
endif|#
directive|endif
name|ia
operator|=
name|in_iafromif
argument_list|(
name|inetifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|IA_INADDR
argument_list|(
name|ia
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * There are a few icmp output routines since the header has some variable  * types in it ...  */
end_comment

begin_macro
name|send_redirect
argument_list|(
argument|redirip
argument_list|,
argument|use
argument_list|,
argument|code
argument_list|,
argument|icmplen
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ip
modifier|*
name|redirip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|use
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|icmplen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|ICMPSIZE
operator|+
name|icmplen
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
block|{
specifier|register
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|ic
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|icmp
operator|*
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_type
operator|=
name|ICMP_REDIR
expr_stmt|;
name|ic
operator|->
name|ic_code
operator|=
name|code
expr_stmt|;
name|ic
operator|->
name|ic_sum
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_gaddr
operator|=
name|use
expr_stmt|;
if|if
condition|(
name|icmplen
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|redirip
argument_list|,
name|ic
operator|->
name|ic_data
argument_list|,
name|icmplen
argument_list|)
expr_stmt|;
comment|/* used to use an inline cksum here  */
name|ic
operator|->
name|ic_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_ICMP
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|redirip
operator|->
name|ip_src
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|=
name|redir_addr
argument_list|(
name|redirip
argument_list|)
expr_stmt|;
block|}
name|NOPCB_IPSEND
argument_list|(
name|m
argument_list|,
operator|(
name|int
operator|)
name|icmplen
argument_list|,
name|FALSE
argument_list|,
name|error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|error
operator|=
name|error
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_comment
comment|/*  * Send an ICMP error message.  Note that data must not exceed single mbuf.  */
end_comment

begin_macro
name|ic_errmsg
argument_list|(
argument|src
argument_list|,
argument|dst
argument_list|,
argument|type
argument_list|,
argument|code
argument_list|,
argument|off
argument_list|,
argument|dlen
argument_list|,
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|in_addr
name|src
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|dst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|dlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|dp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assumed to be contiguous */
end_comment

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|unsigned
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
comment|/*ENOBUFS*/
return|;
comment|/*      * Build ICMP header      */
name|len
operator|=
name|ICMPSIZE
operator|+
name|dlen
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_off
operator|<
operator|(
name|MMINOFF
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ic_errmsg len %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* ICMP header */
block|{
specifier|register
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|ic
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|icmp
operator|*
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_type
operator|=
name|type
expr_stmt|;
name|ic
operator|->
name|ic_code
operator|=
name|code
expr_stmt|;
name|ic
operator|->
name|ic_off
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|dlen
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|dp
argument_list|,
name|ic
operator|->
name|ic_data
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_sum
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* IP header */
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|m
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_ICMP
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|=
name|src
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|dst
expr_stmt|;
block|}
name|NOPCB_IPSEND
argument_list|(
name|m
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|FALSE
argument_list|,
name|error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|error
operator|=
name|error
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BBNPING
end_ifdef

begin_macro
name|ping
argument_list|(
argument|gwaddr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|in_addr
name|gwaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
name|ICMPSIZE
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|ICMPSIZE
expr_stmt|;
block|{
specifier|register
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|ic
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|icmp
operator|*
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_type
operator|=
name|ICMP_ECHO
expr_stmt|;
name|ic
operator|->
name|ic_code
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_id
operator|=
name|MY_ECHO_ID
expr_stmt|;
name|ic
operator|->
name|ic_sum
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|ICMPSIZE
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_ICMP
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|gwaddr
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|=
name|icmp_addr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|int
name|error
decl_stmt|;
name|NOPCB_IPSEND
argument_list|(
name|m
argument_list|,
name|ICMPSIZE
argument_list|,
name|FALSE
argument_list|,
name|error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|error
operator|=
name|error
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

