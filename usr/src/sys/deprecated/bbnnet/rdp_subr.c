begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Log:	rdp_subr.c,v $  * Revision 2.7  84/11/21  12:06:30  walsh  * *** empty log message ***  *   * Revision 2.6  84/11/08  16:12:53  walsh  * Added code to gather statistics on RDP traffic.  This makes the RDPCB  * too big unles you make mbufs 512 bytes large.  RDP_CS should be turned off  * unless you do.  *   * Revision 2.5  84/11/06  13:54:21  walsh  * *** empty log message ***  *   * Revision 2.4  84/11/05  16:25:18  walsh  * tied rdp to icmp source quenches.  See icmp_quench and rdp_quench.  *   * Revision 2.3  84/11/05  15:55:13  walsh  * update_nulltimer() macro began to look inappropriate with recent  * changes, so its been stripped out and put in-line.  *   * Revision 2.2  84/11/02  18:25:47  walsh  * Protocol specifiers want NULL message to have own sequence number in  * case of slow (t>NULL msg timeout) packets.  I don't see this as a problem,  * and even if happened (dubious) would only delay discovery, but I  * didn't win this one.  Initially not designed for this, but fixes are  * in almost neatly.  *   * Revision 2.1  84/11/02  10:15:35  walsh  * Fixed to include RCS comments in checked out source.  *   *  * description:  * Some subroutines for manipulating the datagram q's for RDP.  *   * revision 1.11          * date: 84/07/20 10:30:42;  author: walsh;  state: Exp;  lines added/del: 21/1  * Tied RDP acknowledgements to ping reduction, just like TCP.  *   * revision 1.10          * date: 84/07/19 10:22:33;  author: walsh;  state: Exp;  lines added/del: 1/17  * Organized macros and classified their definitions in rdp_macros.h.  *   * revision 1.9          * date: 84/07/17 22:35:26;  author: walsh;  state: Exp;  lines added/del: 3/0  * Ensure cannot bind port number greater than RDP_pMAX.  *   * revision 1.8          * date: 84/07/12 10:12:48;  author: walsh;  state: Exp;  lines added/del: 14/18  * some small optimizations.  *   * revision 1.7          * date: 84/07/12 09:39:06;  author: walsh;  state: Exp;  lines added/del: 2/4  * small optimizations.  ( a = (a+1)%b quicker than a++; a %= b)  *   * revision 1.6          * date: 84/07/10 14:58:24;  author: walsh;  state: Exp;  lines added/del: 10/3  * Now no unecessary wakeups of the user process are done.  *   * revision 1.5          * date: 84/07/10 10:38:24;  author: walsh;  state: Exp;  lines added/del: 13/13  * added register declarations.  *   * revision 1.4          * date: 84/07/06 14:28:53;  author: wjacobso;  state: Exp;  lines added/del: 6/6  * *** empty log message ***  *   * revision 1.3          * date: 84/07/06 14:17:02;  author: wjacobso;  state: Exp;  lines added/del: 8/8  * added register var definitions  *   * revision 1.2          * date: 84/07/06 09:51:12;  author: root;  state: Exp;  lines added/del: 2/1  * This version seems to run bug-free.  *   * revision 1.1          * date: 84/06/26 14:18:30;  author: walsh;  state: Exp;    * Initial revision  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RDP
end_ifdef

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/icmp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/rdp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/seq.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/rdp_macros.h"
end_include

begin_comment
comment|/*  * Called on ACK of a message we sent.  */
end_comment

begin_expr_stmt
name|he_acked
argument_list|(
name|rdpcb
argument_list|,
name|msgnum
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|rdpsequence
name|msgnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|index
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|MBUF
modifier|*
name|m
decl_stmt|;
name|index
operator|=
name|msgnum
operator|-
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_baseseq
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_maxqlen
condition|)
return|return;
comment|/*      * an ACK is cumulative and may be for more than one message      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|index
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|j
operator|=
operator|(
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_front
operator|+
name|i
operator|)
operator|%
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_maxqlen
expr_stmt|;
name|m
operator|=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_msgs
index|[
name|j
index|]
expr_stmt|;
comment|/* 	 * ignore redundant ACKs.  May have been EACKed (RDP_DELIVERED). 	 */
if|if
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|RDP_NULLMSG
condition|)
block|{
comment|/* and restart connection loss detection */
name|rdpcb
operator|->
name|r_nullsent
operator|=
literal|0
expr_stmt|;
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tNULL
index|]
operator|=
name|rdpcb
operator|->
name|r_tvnull
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|!=
name|RDP_DELIVERED
condition|)
block|{
ifdef|#
directive|ifdef
name|RDP_CS
comment|/* count when acked, not queued */
name|rdpcb
operator|->
name|r_sent
operator|.
name|r_nbytes
operator|+=
operator|(
name|int
operator|)
name|m
operator|->
name|m_act
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_msgs
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|clear_rxtimer
argument_list|(
name|rdpcb
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/*      * Ensure front is always NULL or an undelivered (unacked) message.      */
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_front
operator|+=
operator|(
name|index
operator|+
literal|1
operator|)
expr_stmt|;
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_front
operator|%=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_maxqlen
expr_stmt|;
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_baseseq
operator|+=
operator|(
name|index
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* bumps r_snduna */
comment|/*      * and, did this ack allow us to measure current round trip time?      */
if|if
condition|(
name|rdpcb
operator|->
name|r_rttiming
condition|)
block|{
if|if
condition|(
name|SEQ_GT
argument_list|(
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_baseseq
argument_list|,
name|rdpcb
operator|->
name|r_rttimed
argument_list|)
condition|)
block|{
name|update_rttestimate
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|update_rxmitime
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_rttiming
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|BBNPING
comment|/*      * We've sent him NEW data, perhaps by a gateway, that he      * has successfully received.  If that's the case, then      * we know the route works and we don't have to ping that      * gateway.      *      * see check_ping()      */
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
if|if
condition|(
name|rt
operator|=
name|rdpcb
operator|->
name|r_inpcb
operator|->
name|inp_route
operator|.
name|ro_rt
condition|)
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
name|rt
operator|->
name|irt_pings
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * and let sender send more pkts now that we have space.      */
name|sendbufhasspace
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Called on EACK of a message we sent.  */
end_comment

begin_expr_stmt
name|he_eacked
argument_list|(
name|rdpcb
argument_list|,
name|msgnum
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|rdpsequence
name|msgnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|index
decl_stmt|;
specifier|register
name|MBUF
modifier|*
name|m
decl_stmt|;
name|index
operator|=
name|msgnum
operator|-
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_baseseq
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_maxqlen
condition|)
return|return;
name|index
operator|=
operator|(
name|index
operator|+
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_front
operator|)
operator|%
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_maxqlen
expr_stmt|;
name|m
operator|=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_msgs
index|[
name|index
index|]
expr_stmt|;
comment|/*      * ignore redundant EACKs      */
if|if
condition|(
name|m
operator|&&
operator|(
name|m
operator|!=
name|RDP_DELIVERED
operator|)
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|RDP_NULLMSG
condition|)
block|{
comment|/* and restart connection loss detection */
name|rdpcb
operator|->
name|r_nullsent
operator|=
literal|0
expr_stmt|;
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tNULL
index|]
operator|=
name|rdpcb
operator|->
name|r_tvnull
expr_stmt|;
name|log
argument_list|(
name|KERN_RECOV
argument_list|,
literal|"Incorrect ACK strategy on rdpcb 0x%x\n"
argument_list|,
name|rdpcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|RDP_CS
name|rdpcb
operator|->
name|r_sent
operator|.
name|r_nbytes
operator|+=
operator|(
name|int
operator|)
name|m
operator|->
name|m_act
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_msgs
index|[
name|index
index|]
operator|=
name|RDP_DELIVERED
expr_stmt|;
name|clear_rxtimer
argument_list|(
name|rdpcb
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* 	 * did this eack allow us to measure current round trip time? 	 */
if|if
condition|(
name|rdpcb
operator|->
name|r_rttiming
condition|)
block|{
if|if
condition|(
name|msgnum
operator|==
name|rdpcb
operator|->
name|r_rttimed
condition|)
block|{
name|update_rttestimate
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|update_rxmitime
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_rttiming
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Grab a message for passing to the user.  msgq is our rcvq.  * Called on net reception if user recv q is empty.  * Called on PRU_RECV after user picks up current packet on socket.  * Only one packet is attached to the socket at a time.  */
end_comment

begin_function
name|MBUF
modifier|*
name|rdp_qremove
parameter_list|(
name|msgq
parameter_list|,
name|async
parameter_list|)
specifier|register
name|RDP_MSGQ
modifier|*
name|msgq
decl_stmt|;
block|{
name|MBUF
modifier|*
name|m
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|index
operator|=
name|msgq
operator|->
name|rq_front
expr_stmt|;
name|pass
operator|=
name|msgq
operator|->
name|rq_maxqlen
expr_stmt|;
do|do
block|{
name|m
operator|=
name|msgq
operator|->
name|rq_msgs
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|m
operator|!=
name|RDP_DELIVERED
condition|)
block|{
name|msgq
operator|->
name|rq_msgs
index|[
name|index
index|]
operator|=
name|RDP_DELIVERED
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
name|index
operator|=
operator|(
name|index
operator|+
literal|1
operator|)
operator|%
name|msgq
operator|->
name|rq_maxqlen
expr_stmt|;
block|}
do|while
condition|(
name|async
operator|&&
operator|(
operator|--
name|pass
operator|>
literal|0
operator|)
condition|)
do|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rdp_qremove() grabbed a message to pass to the user.  When he picks it up,  * PRU_RCVD occurs.  At that point, we bump front and we send an ACK.  */
end_comment

begin_expr_stmt
name|rdp_received
argument_list|(
name|msgq
argument_list|)
specifier|register
name|RDP_MSGQ
operator|*
name|msgq
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|MBUF
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
do|do
block|{
name|index
operator|=
name|msgq
operator|->
name|rq_front
expr_stmt|;
name|m
operator|=
name|msgq
operator|->
name|rq_msgs
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|RDP_DELIVERED
condition|)
block|{
name|msgq
operator|->
name|rq_front
operator|=
operator|(
name|msgq
operator|->
name|rq_front
operator|+
literal|1
operator|)
operator|%
name|msgq
operator|->
name|rq_maxqlen
expr_stmt|;
name|msgq
operator|->
name|rq_baseseq
operator|++
expr_stmt|;
name|msgq
operator|->
name|rq_msgs
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
do|while
condition|(
name|m
operator|==
name|RDP_DELIVERED
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  * Put a message on our send or rcv q.  *  *	0	internal error somewhere  *	1	new message  *	-1	duplicate message  */
end_comment

begin_expr_stmt
name|rdp_qinsert
argument_list|(
name|msgq
argument_list|,
name|m
argument_list|,
name|msgnum
argument_list|)
specifier|register
name|RDP_MSGQ
operator|*
name|msgq
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|MBUF
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rdpsequence
name|msgnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|index
decl_stmt|;
name|int
name|isdup
decl_stmt|;
name|index
operator|=
name|msgnum
operator|-
name|msgq
operator|->
name|rq_baseseq
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|msgq
operator|->
name|rq_maxqlen
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|index
operator|=
operator|(
name|index
operator|+
name|msgq
operator|->
name|rq_front
operator|)
operator|%
name|msgq
operator|->
name|rq_maxqlen
expr_stmt|;
if|if
condition|(
name|msgq
operator|->
name|rq_msgs
index|[
name|index
index|]
operator|==
name|RDP_DELIVERED
condition|)
block|{
comment|/* rcvd duplicate of a message the user already has on socket */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|isdup
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|msgq
operator|->
name|rq_msgs
index|[
name|index
index|]
condition|)
block|{
name|m_freem
argument_list|(
name|msgq
operator|->
name|rq_msgs
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|isdup
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|isdup
operator|=
literal|1
expr_stmt|;
name|msgq
operator|->
name|rq_msgs
index|[
name|index
index|]
operator|=
name|m
expr_stmt|;
block|}
return|return
operator|(
name|isdup
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

