begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsident
index|[]
init|=
literal|"$Header: ip_output.c,v 1.28 85/07/31 09:32:09 walsh Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/domain.h"
end_include

begin_include
include|#
directive|include
file|"../h/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../h/syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/icmp.h"
end_include

begin_comment
comment|/*  * If you're going to a specific host or via a gateway, the routing  * entry gateway field holds the best way to get there.  Otherwise,  * the routing entry tells you how to get onto that net -- it has  * the net address portion of our local host:  *  * On bbn-labs-b:  *  *		rt_dst		rt_gateway	flags  * il0  => 	0x00000b80	0x2010b80	UP  * imp0 =>	0x00000008	0x2000708	UP  * loop =>	0x0000007f	0x100007f	UP  *  * So you can see that the rt_gateway is our local address, and the  * rt_dst may be the net number of the media.  If it's a route  * to a net, the other guy is on this net and you want to route the  * packet to him anyway.  *  * gateway	0               0x1000b80       UP, RTF_GATEWAY  */
end_comment

begin_define
define|#
directive|define
name|IF_SEND
parameter_list|(
name|ifp
parameter_list|,
name|mp
parameter_list|,
name|rt
parameter_list|,
name|retval
parameter_list|)
define|\
value|{\     static struct sockaddr_in tmproute = {AF_INET};                           \ \     if (! ((ifp)->if_flags& IFF_UP)){					      \
comment|/* goes with PRC_IFDOWN in in.c */
value|\ 	m_freem(mp);							      \ 	retval = ENETUNREACH;						      \     } else if ((rt)->rt_flags& (RTF_GATEWAY|RTF_HOST))                       \ 	retval = (*(ifp)->if_output)(ifp, mp,&(rt)->rt_gateway);             \     else {                                                                    \ 	tmproute.sin_addr.s_addr = (mtod(mp, struct ip *))->ip_dst.s_addr;    \ 	retval = (*(ifp)->if_output)(ifp, mp, (struct sockaddr *)&tmproute); \ }}
end_define

begin_expr_stmt
name|if_send
argument_list|(
name|ifp
argument_list|,
name|mp
argument_list|,
name|rt
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retval
decl_stmt|;
name|IF_SEND
argument_list|(
name|ifp
argument_list|,
name|mp
argument_list|,
name|rt
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Find a route to this destination.  Given the source and destination   * addresses, it returns a local net address  * to send to (either the address of the destination itself or a gateway).  * Taken mostly from rtalloc;  expanded to route according to  * both ends of the connection.  */
end_comment

begin_function
name|struct
name|rtentry
modifier|*
name|ip_route
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|struct
name|in_addr
modifier|*
name|src
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|dst
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|unsigned
name|hash
decl_stmt|;
name|net_t
name|snet
decl_stmt|,
name|dnet
decl_stmt|;
name|int
name|doinghost
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rtmin
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|table
decl_stmt|;
specifier|static
name|struct
name|in_addr
name|wildcard
decl_stmt|;
comment|/* get network parts of src and dest addresses */
name|snet
operator|=
name|iptonet
argument_list|(
operator|*
name|src
argument_list|)
expr_stmt|;
name|dnet
operator|=
name|iptonet
argument_list|(
operator|*
name|dst
argument_list|)
expr_stmt|;
name|rtmin
operator|=
name|NULL
expr_stmt|;
name|hash
operator|=
name|HOSTHASH
argument_list|(
name|dst
operator|->
name|s_addr
argument_list|)
expr_stmt|;
name|table
operator|=
name|rthost
expr_stmt|;
name|doinghost
operator|=
name|TRUE
expr_stmt|;
name|again
label|:
for|for
control|(
name|m
operator|=
name|table
index|[
name|hash
operator|%
name|RTHASHSIZ
index|]
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|rt
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|rtentry
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_hash
operator|!=
name|hash
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
continue|continue;
if|if
condition|(
name|rt
operator|->
name|rt_dst
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
comment|/* packets go out an interface with our local IP address */
if|if
condition|(
name|iptonet
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|rt
operator|->
name|rt_gateway
operator|)
operator|)
operator|->
name|sin_addr
argument_list|)
operator|!=
name|snet
condition|)
continue|continue;
comment|/* does this route get us there? */
if|if
condition|(
name|doinghost
condition|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|rt
operator|->
name|rt_dst
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
name|dst
operator|->
name|s_addr
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* 	     * iptonet == 0 => smart gateway (route to anywhere) 	     * iptonet != 0 => gateway to another net (route to net) 	     */
if|if
condition|(
name|iptonet
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|rt
operator|->
name|rt_dst
operator|)
operator|)
operator|->
name|sin_addr
argument_list|)
operator|!=
name|dnet
condition|)
continue|continue;
block|}
comment|/* and try to share load across gateways */
if|if
condition|(
name|rtmin
operator|==
name|NULL
condition|)
name|rtmin
operator|=
name|rt
expr_stmt|;
elseif|else
if|if
condition|(
name|rt
operator|->
name|rt_use
operator|<
name|rtmin
operator|->
name|rt_use
condition|)
name|rtmin
operator|=
name|rt
expr_stmt|;
block|}
if|if
condition|(
name|rtmin
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|doinghost
condition|)
block|{
name|doinghost
operator|=
name|FALSE
expr_stmt|;
name|hash
operator|=
name|NETHASH
argument_list|(
operator|*
name|dst
argument_list|)
operator|,
name|table
operator|=
name|rtnet
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * Check for wildcard gateway, by convention network 0. 	 */
if|if
condition|(
name|dst
operator|!=
operator|&
name|wildcard
condition|)
block|{
name|hash
operator|=
literal|0
expr_stmt|;
name|dst
operator|=
operator|&
name|wildcard
expr_stmt|;
name|dnet
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|rtstat
operator|.
name|rts_unreach
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rtmin
operator|->
name|rt_refcnt
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|==
operator|&
name|wildcard
condition|)
name|rtstat
operator|.
name|rts_wildcard
operator|++
expr_stmt|;
return|return
operator|(
name|rtmin
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ip_send is called from the higher protocol layer (TCP/RDP/UDP) and is passed  * an mbuf chain containing a packet to send to the local network.  The first  * mbuf contains the protocol header and an IP header which is partially  * filled in.  After determining a route (outgoing interface + first hop) for  * the packet, it is fragmented (if necessary) and sent to the local net   * through the local net send routine.  *  * For non-raw output, caller should have stuffed:  *	ip protocol type, type of service, source addr, destin addr  *  * ip_tos is left to caller so that people using raw sockets can do whatever  * they please.  (They don't have an inpcb in which to store such info.)  *  * The asis argument is TRUE for raw output and the gateway (packet forwarding)  * code.  It indicates that the IP header is fully constructed.  *  * Errors at the IP layer and below occur synchronously, and can be reported  * back via subroutine return values.  Higher level protocols should remember  * that if they do things asynchronous to a system call (ie., packet  * retransmission) that they should post error back to user via advise_user()  * so that user gets error next time he rendezvous with the kernel.  */
end_comment

begin_macro
name|ip_send
argument_list|(
argument|inp
argument_list|,
argument|mp
argument_list|,
argument|len
argument_list|,
argument|asis
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|asis
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
specifier|register
name|int
name|hlen
decl_stmt|;
name|int
name|free_route
init|=
name|FALSE
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* -> ip header */
comment|/*      * Find route for datagram if one has not been assigned.      */
if|if
condition|(
operator|(
name|rt
operator|=
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rt
operator|=
name|ip_route
argument_list|(
operator|&
name|p
operator|->
name|ip_src
argument_list|,
operator|&
name|p
operator|->
name|ip_dst
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|asis
operator|||
operator|(
name|p
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
condition|)
block|{
comment|/* 		 * asis: forwarding a packet not sourced by us 		 *      eg., by raw interface and user level repeater process 		 * INADDR_ANY: sending icmp packet for which 		 *      we're trying to avoid routing twice. 		 */
name|struct
name|route
name|tmproute
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tmproute
argument_list|,
sizeof|sizeof
argument_list|(
name|tmproute
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|tmproute
operator|.
name|ro_dst
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|p
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|rtalloc
argument_list|(
operator|&
name|tmproute
argument_list|)
expr_stmt|;
name|rt
operator|=
name|tmproute
operator|.
name|ro_rt
expr_stmt|;
if|if
condition|(
name|rt
operator|&&
operator|(
name|p
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
condition|)
name|p
operator|->
name|ip_src
operator|=
name|IA_INADDR
argument_list|(
name|in_iafromif
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETUNREACH
operator|)
return|;
block|}
block|}
name|free_route
operator|=
name|TRUE
expr_stmt|;
block|}
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
comment|/*      * Copy ip source route to header.  Know asis must be FALSE, if do.      */
if|if
condition|(
name|inp
operator|->
name|inp_optlen
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_off
operator|-
name|inp
operator|->
name|inp_optlen
operator|>=
name|MMINOFF
condition|)
block|{
name|struct
name|in_addr
modifier|*
name|ipa
decl_stmt|;
name|mp
operator|->
name|m_off
operator|-=
name|inp
operator|->
name|inp_optlen
expr_stmt|;
name|mp
operator|->
name|m_len
operator|+=
name|inp
operator|->
name|inp_optlen
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|q
operator|-
name|inp
operator|->
name|inp_optlen
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|q
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|inp
operator|->
name|inp_options
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|p
operator|+
literal|1
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|inp
operator|->
name|inp_optlen
argument_list|)
expr_stmt|;
comment|/* 	     * And replate eventual destination with first hop. 	     * Eventual destination is in source route just 	     * copied in. 	     */
name|ipa
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
operator|&
name|inp
operator|->
name|inp_options
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|p
operator|->
name|ip_dst
operator|=
name|ipa
index|[
name|inp
operator|->
name|inp_optlen
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
index|]
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ip_send: optlen %d inpcb 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|inp
operator|->
name|inp_optlen
argument_list|,
name|inp
argument_list|)
expr_stmt|;
block|}
comment|/*      * fill in ip header fields      */
if|if
condition|(
name|asis
condition|)
block|{
comment|/* 	 * RAW OUTPUT.  Must get len, hlen, off from packet header. 	 * Byte swap is ugly (since we must swap back below), but 	 * necessary in case we must fragment. 	 */
name|hlen
operator|=
name|p
operator|->
name|ip_hl
operator|<<
name|IP_HLSHIFT
expr_stmt|;
name|len
operator|=
name|ntohs
argument_list|(
name|p
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|p
operator|->
name|ip_off
operator|=
name|ntohs
argument_list|(
name|p
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|static
name|u_short
name|next_ip_id
decl_stmt|;
comment|/* some day RDP may want to force for rxmit */
name|hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|inp
operator|->
name|inp_optlen
expr_stmt|;
name|len
operator|+=
name|hlen
expr_stmt|;
name|p
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|p
operator|->
name|ip_hl
operator|=
name|hlen
operator|>>
name|IP_HLSHIFT
expr_stmt|;
name|p
operator|->
name|ip_off
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|ip_ttl
operator|=
name|MAXTTL
expr_stmt|;
comment|/* ### should come from route */
name|p
operator|->
name|ip_id
operator|=
name|htons
argument_list|(
name|next_ip_id
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/*      * let ip_frag do the send if needed, otherwise do it directly.      */
comment|/* for testing IP reassembly code */
ifdef|#
directive|ifdef
name|FORCE_FRAG
define|#
directive|define
name|MTU
parameter_list|(
name|ifp
parameter_list|)
value|(((ifp)->if_mtu>> FORCE_FRAG)& (~3))
else|#
directive|else
define|#
directive|define
name|MTU
parameter_list|(
name|ifp
parameter_list|)
value|(ifp)->if_mtu
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
name|MTU
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|p
operator|->
name|ip_len
operator|=
name|len
expr_stmt|;
name|retval
operator|=
name|ip_frag
argument_list|(
name|p
argument_list|,
name|ifp
argument_list|,
name|rt
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * complete header, byte swap, and send to local net  	 */
name|p
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|p
operator|->
name|ip_off
argument_list|)
expr_stmt|;
comment|/* 	 * No reason not to have kernel checksum, even for raw packets. 	 */
name|p
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
name|dtom
argument_list|(
name|p
argument_list|)
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|IF_SEND
argument_list|(
name|ifp
argument_list|,
name|mp
argument_list|,
name|rt
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
name|rt
operator|->
name|rt_use
operator|++
expr_stmt|;
comment|/* Yet another IP packet sent away */
if|if
condition|(
name|free_route
condition|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
if|if
condition|(
operator|(
name|so
operator|=
name|inp
operator|->
name|inp_socket
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
condition|)
comment|/* 	     * Found a new route after old one pinged out. 	     */
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|=
name|rt
expr_stmt|;
else|else
name|rtfree
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Ip_frag is called with a packet with a completed ip header   * (except for checksum).  It fragments the packet, inserts the  * IP checksum, and calls the appropriate local net output routine  * to send it to the net.  *  * Previously, when there was only one kind of mbuf, it tried to  * reduce space requirements by recycling the chain to be fragmented.  * Preserving this approach is overly complicated, and should mbufs  * change again, cause problems.  Therefore, have switched to copying  * the chain to be fragmented.  */
end_comment

begin_expr_stmt
name|ip_frag
argument_list|(
name|p
argument_list|,
name|ifp
argument_list|,
name|rt
argument_list|,
name|hlen
argument_list|)
specifier|register
expr|struct
name|ip
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|hlen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* original chunk */
specifier|register
name|struct
name|mbuf
modifier|*
name|mhdr
decl_stmt|;
comment|/* fragment */
specifier|register
name|struct
name|ip
modifier|*
name|fip
decl_stmt|;
comment|/* the fragment IP header */
name|int
name|off
decl_stmt|;
comment|/* offset into entire IP datagram */
name|int
name|here
decl_stmt|;
comment|/* offset into this chunk of it */
specifier|register
name|int
name|len
decl_stmt|;
comment|/* length of data in this chunk */
name|int
name|flags
decl_stmt|;
comment|/* of this chunk to fragment */
name|int
name|max
decl_stmt|;
comment|/* max data length in a fragment */
name|int
name|fdlen
decl_stmt|;
comment|/* actual fragment data length */
name|int
name|error
decl_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ip_off
operator|&
name|ip_df
condition|)
block|{
comment|/* can't fragment */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
name|max
operator|=
name|MTU
argument_list|(
name|ifp
argument_list|)
operator|-
name|hlen
expr_stmt|;
comment|/* max data length in frag */
name|len
operator|=
name|p
operator|->
name|ip_len
operator|-
name|hlen
expr_stmt|;
comment|/* data length */
comment|/*       * this only needs to be this complicated if we are handed      * an already-fragmented packet      */
name|flags
operator|=
name|p
operator|->
name|ip_off
operator|&
operator|(
name|ip_mf
operator||
name|ip_df
operator|)
expr_stmt|;
comment|/* save old flags */
name|p
operator|->
name|ip_off
operator|&=
operator|~
name|flags
expr_stmt|;
comment|/* take them out of ip_off */
name|off
operator|=
name|p
operator|->
name|ip_off
operator|<<
name|IP_OFFSHIFT
expr_stmt|;
comment|/* fragment offset */
name|here
operator|=
name|hlen
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 	 * Allocate mbuf for fragment IP header 	 */
name|mhdr
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhdr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
comment|/* 	 * get copy of data for fragment 	 */
if|if
condition|(
name|len
operator|<
name|max
condition|)
name|fdlen
operator|=
name|len
expr_stmt|;
else|else
name|fdlen
operator|=
name|max
operator|&
operator|(
operator|~
literal|7
operator|)
expr_stmt|;
comment|/* 7 == 2^IP_OFFSHIFT -1 */
name|mhdr
operator|->
name|m_next
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
name|here
argument_list|,
name|fdlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhdr
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|mhdr
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
comment|/* 	 * build the header for this fragment and ship it off. 	 */
name|mhdr
operator|->
name|m_len
operator|=
name|hlen
expr_stmt|;
name|mhdr
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
name|hlen
expr_stmt|;
name|fip
operator|=
name|mtod
argument_list|(
name|mhdr
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
operator|(
name|caddr_t
operator|)
name|fip
argument_list|,
operator|(
name|unsigned
operator|)
name|hlen
argument_list|)
expr_stmt|;
name|fip
operator|->
name|ip_off
operator|=
name|off
operator|>>
name|IP_OFFSHIFT
expr_stmt|;
if|if
condition|(
name|fdlen
operator|>=
name|len
condition|)
comment|/* it's the last fragment */
name|fip
operator|->
name|ip_off
operator||=
name|flags
expr_stmt|;
else|else
name|fip
operator|->
name|ip_off
operator||=
name|ip_mf
expr_stmt|;
name|fip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|fip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
name|fip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|fdlen
operator|+
name|hlen
argument_list|)
expr_stmt|;
name|fip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|fip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
name|mhdr
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|if_send
argument_list|(
name|ifp
argument_list|,
name|mhdr
argument_list|,
name|rt
argument_list|)
condition|)
break|break;
comment|/* 	 * and get ready for next pass through the loop 	 */
name|len
operator|-=
name|fdlen
expr_stmt|;
name|off
operator|+=
name|fdlen
expr_stmt|;
name|here
operator|+=
name|fdlen
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Current connection should use a new path.  */
end_comment

begin_function
name|struct
name|rtentry
modifier|*
name|ip_reroute
parameter_list|(
name|inp
parameter_list|)
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
block|{
specifier|register
name|struct
name|route
modifier|*
name|ro
init|=
operator|&
name|inp
operator|->
name|inp_route
decl_stmt|;
name|rtfree
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ro
operator|->
name|ro_rt
operator|=
name|ip_route
argument_list|(
operator|&
name|inp
operator|->
name|inp_laddr
argument_list|,
operator|&
name|inp
operator|->
name|inp_faddr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A gateway has gone down.  Change route used by all connections currently  * using it.  */
end_comment

begin_macro
name|ip_gdown
argument_list|(
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|u_long
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|protosw
modifier|*
name|psw
decl_stmt|;
for|for
control|(
name|psw
operator|=
name|inetdomain
operator|.
name|dom_protosw
init|;
name|psw
operator|<
name|inetdomain
operator|.
name|dom_protoswNPROTOSW
condition|;
name|psw
operator|++
control|)
if|if
condition|(
name|psw
operator|->
name|pr_type
operator|!=
name|SOCK_RAW
condition|)
if|if
condition|(
name|psw
operator|->
name|pr_ctlinput
condition|)
operator|(
operator|*
operator|(
name|psw
operator|->
name|pr_ctlinput
operator|)
operator|)
operator|(
name|PRC_GWDOWN
operator|,
name|addr
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Called from protocol ctlinput routine.  This way, IP/ICMP don't need to know  * about protocol's head of inpcbs... for all the protocols.  */
end_comment

begin_expr_stmt
name|in_gdown
argument_list|(
name|head
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|inpcb
operator|*
name|head
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_long
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|inp
operator|=
name|head
operator|->
name|inp_next
init|;
name|inp
operator|!=
name|head
condition|;
name|inp
operator|=
name|inp
operator|->
name|inp_next
control|)
block|{
if|if
condition|(
name|rt
operator|=
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rt
operator|->
name|rt_gateway
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|addr
condition|)
block|{
comment|/* 			 * Don't remove route permanently, since want to catch 			 * the gateway when it reboots: 			 *      -- rtrequest (SIOCDELRT, rt) -- 			 * 			 * make sure rtfree() not remove route mbuf 			 * incrementing reference count here, and decrementing 			 * when timeout on reinstatement goes off.  Cannot call 			 * rtfree with zero reference count when have not done 			 * SIOCDELRT. 			 */
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
condition|)
block|{
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_UP
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator||=
name|RTF_REINSTATE
expr_stmt|;
name|rt
operator|->
name|irt_gdown
operator|=
name|RT_REINSTATE
expr_stmt|;
name|rt
operator|->
name|rt_refcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ip_reroute
argument_list|(
name|inp
argument_list|)
condition|)
name|advise_user
argument_list|(
name|inp
operator|->
name|inp_socket
argument_list|,
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

end_unit

