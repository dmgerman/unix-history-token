begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsident
index|[]
init|=
literal|"$Header: icmp.c,v 1.17 85/06/18 14:53:43 walsh Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/icmp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/nopcb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HMPTRAPS
end_ifdef

begin_include
include|#
directive|include
file|"../bbnnet/hmp_traps.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/time.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsicmphdr
index|[]
init|=
name|RCSICMPHDR
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|nosum
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NICTYPE
value|17
end_define

begin_comment
comment|/* ICMP message formats */
end_comment

begin_define
define|#
directive|define
name|ICBAD
value|0
end_define

begin_comment
comment|/* unimplemented */
end_comment

begin_define
define|#
directive|define
name|ICERR
value|1
end_define

begin_comment
comment|/* error format (use header) */
end_comment

begin_define
define|#
directive|define
name|ICDAT
value|2
end_define

begin_comment
comment|/* data format (use id) */
end_comment

begin_define
define|#
directive|define
name|ICINT
value|3
end_define

begin_comment
comment|/* data format (handle internally) */
end_comment

begin_decl_stmt
name|char
name|icaction
index|[
name|NICTYPE
index|]
init|=
block|{
name|ICDAT
block|,
name|ICBAD
block|,
name|ICBAD
block|,
name|ICERR
block|,
name|ICERR
block|,
name|ICERR
block|,
name|ICBAD
block|,
name|ICBAD
block|,
name|ICINT
block|,
name|ICBAD
block|,
name|ICBAD
block|,
name|ICERR
block|,
name|ICERR
block|,
name|ICINT
block|,
name|ICDAT
block|,
name|ICINT
block|,
name|ICDAT
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ICLEN1
value|(sizeof(struct ip) + ICMPSIZE + sizeof(struct ip) + ICMP_ERRLEN)
end_define

begin_define
define|#
directive|define
name|ICLEN2
value|(sizeof(struct ip) + ICMPSIZE + 3 * sizeof(long))
end_define

begin_decl_stmt
name|int
name|icpullup
index|[
name|NICTYPE
index|]
init|=
block|{
literal|0
block|,
comment|/* echo reply */
literal|0
block|,
literal|0
block|,
name|ICLEN1
block|,
comment|/* unreachable */
name|ICLEN1
block|,
comment|/* source quench */
name|ICLEN1
block|,
comment|/* redirect */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* echo request */
literal|0
block|,
literal|0
block|,
name|ICLEN1
block|,
comment|/* time exceeded */
name|ICLEN1
block|,
comment|/* parameter problem */
name|ICLEN2
block|,
comment|/* timestamp */
name|ICLEN2
block|,
comment|/* timestamp reply */
literal|0
block|,
comment|/* information request */
literal|0
comment|/* information reply */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|icunrch
index|[
name|ICMP_UNRCH_NUM
index|]
init|=
block|{
name|PRC_UNREACH_NET
block|,
name|PRC_UNREACH_HOST
block|,
name|PRC_UNREACH_PROTOCOL
block|,
name|PRC_UNREACH_PORT
block|,
name|PRC_MSGSIZE
block|,
name|PRC_UNREACH_HOST
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|icmp_stat
name|icmpstat
decl_stmt|;
end_decl_stmt

begin_function
name|u_long
name|iptime
parameter_list|()
block|{
name|int
name|s
init|=
name|spl7
argument_list|()
decl_stmt|;
comment|/* berkeley had spl6() */
name|u_long
name|t
decl_stmt|;
name|t
operator|=
operator|(
name|time
operator|.
name|tv_sec
operator|%
operator|(
literal|24
operator|*
literal|60
operator|*
literal|60
operator|)
operator|)
operator|*
literal|1000
operator|+
name|time
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|htonl
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|know_gateway2
argument_list|(
argument|gaddr
argument_list|,
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|u_long
name|gaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|rt
operator|=
name|mtod
argument_list|(
name|list
argument_list|,
expr|struct
name|rtentry
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_dst
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rt
operator|->
name|rt_gateway
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|gaddr
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|list
operator|=
name|list
operator|->
name|m_next
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_macro
name|know_gateway
argument_list|(
argument|gaddr
argument_list|)
end_macro

begin_decl_stmt
name|u_long
name|gaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RTHASHSIZ
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|know_gateway2
argument_list|(
name|gaddr
argument_list|,
name|rthost
index|[
name|i
index|]
argument_list|)
operator|||
name|know_gateway2
argument_list|(
name|gaddr
argument_list|,
name|rtnet
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BBNPING
end_ifdef

begin_comment
comment|/*  * Note that pinging is done on a per-route basis.  *  * 1.  If a gateway is used by more than one route, then for routes  *	with no active (measured by new data xfer) tcp connections,  *	the gateway will be pinged.  *	It is possible that every PINGTIME/2 seconds a gateway would  *	be sent multiple icmp ECHO REQUESTS, but that is unlikely (uncommon)  *	and we can worry about that if it actually proves to be a problem.  *  * 2.  Since the ping count is incremented on a per-route basis, but  *	ECHO REPLIES are dealt with on a per-address basis, a gateway is  *	not prematurely pinged out if it is used by more than one active  *	routing entry.  */
end_comment

begin_expr_stmt
specifier|static
name|check_ping
argument_list|(
name|list
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|rt
operator|=
name|mtod
argument_list|(
name|list
argument_list|,
expr|struct
name|rtentry
operator|*
argument_list|)
expr_stmt|;
name|next
operator|=
name|list
operator|->
name|m_next
expr_stmt|;
comment|/* in case remove it from list */
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_dst
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rt
operator|->
name|rt_gateway
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_refcnt
operator|>
literal|0
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|irt_pings
operator|>=
name|MAXPING
condition|)
block|{
comment|/* 		     * Too many unanswered pings.  re-route 		     * connections using this gateway.  Usually, 		     * this happens because the gateway is flooded 		     * with traffic. 		     */
union|union
block|{
name|u_long
name|ul
decl_stmt|;
name|u_char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|a
union|;
name|a
operator|.
name|ul
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"gw %d.%d.%d.%d pinged out\n"
argument_list|,
name|a
operator|.
name|c
index|[
literal|0
index|]
argument_list|,
name|a
operator|.
name|c
index|[
literal|1
index|]
argument_list|,
name|a
operator|.
name|c
index|[
literal|2
index|]
argument_list|,
name|a
operator|.
name|c
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|rt
operator|->
name|irt_pings
operator|=
literal|0
expr_stmt|;
name|ip_gdown
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * Ping him again. 		     * See rcv_ack() for comparison with zero here. 		     */
name|rt
operator|->
name|irt_pings
operator|++
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|irt_pings
operator|>
literal|0
condition|)
block|{
comment|/* 			 * count ping even if doesn't get to 			 * interface (ENOBUFS) or other error 			 * (EHOSTDOWN if no gateway at that 			 * address on an IMP network). 			 */
name|ping
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
name|icmpstat
operator|.
name|ic_pings
operator|++
expr_stmt|;
block|}
else|else
name|icmpstat
operator|.
name|ic_svpings
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_REINSTATE
condition|)
block|{
comment|/* 		     * The gateway pinged out or died at some point. 		     * Let's see if it's back up or if our 		     * re-routing of current connections in ip_gdown 		     * has let it breathe again.  Wait a while 		     * before try to use it again. 		     */
name|rt
operator|->
name|irt_gdown
operator|--
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|irt_gdown
operator|<=
literal|0
condition|)
block|{
name|rt
operator|->
name|irt_gdown
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Wait until we know it's alive 			 * for certain.  Ping it. 			 */
name|ping
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|reset_ping
argument_list|(
name|list
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|u_long
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|rt
operator|=
name|mtod
argument_list|(
name|list
argument_list|,
expr|struct
name|rtentry
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_dst
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rt
operator|->
name|rt_gateway
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|addr
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_REINSTATE
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|irt_gdown
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Was not a slow echo reply.  If was dead, 			 * use it again.  If was flooded, new connections 			 * can now use it (old shifted away). 			 */
name|rt
operator|->
name|rt_flags
operator||=
name|RTF_UP
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_REINSTATE
expr_stmt|;
name|rt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
comment|/* see ip_gdown() */
block|}
block|}
else|else
name|rt
operator|->
name|irt_pings
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|list
operator|=
name|list
operator|->
name|m_next
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Would be nice if we could use HOSTHASH/NETHASH/0, but the hashing is done  * on the destination, not the intermediary gateway.  */
end_comment

begin_expr_stmt
name|got_ping
argument_list|(
name|addr
argument_list|)
specifier|register
name|u_long
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RTHASHSIZ
condition|;
name|i
operator|++
control|)
block|{
name|reset_ping
argument_list|(
name|rthost
index|[
name|i
index|]
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|reset_ping
argument_list|(
name|rtnet
index|[
name|i
index|]
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Process ICMP messages.  Called directly from ip_input processor.  */
end_comment

begin_expr_stmt
name|icmp
argument_list|(
name|mp
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|mp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|icmp
modifier|*
name|icp
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|int
name|ilen
decl_stmt|;
name|int
name|prccode
decl_stmt|;
name|icmpstat
operator|.
name|ic_total
operator|++
expr_stmt|;
comment|/*      * see ip_input()      */
if|if
condition|(
operator|(
name|mp
operator|->
name|m_off
operator|>
name|MMAXOFF
operator|)
operator|||
operator|(
name|mp
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|ICMPSIZE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|mp
operator|=
name|m_pullup
argument_list|(
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|ICMPSIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|icmpstat
operator|.
name|ic_tooshort
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|icp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
comment|/*      * watch for fools sending out broadcast ICMP packets      * Don't check against inetifp, since is up to ip_input whether to receive      * on some interface rather than send to self for input on dst interface.      */
name|ia
operator|=
name|in_iawithaddr
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
name|NULL
condition|)
block|{
comment|/* drop it */
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* filter out message types */
if|if
condition|(
name|icp
operator|->
name|ic_type
operator|>=
name|NICTYPE
operator|||
name|icaction
index|[
name|icp
operator|->
name|ic_type
index|]
operator|==
name|ICBAD
condition|)
block|{
name|icmpstat
operator|.
name|ic_drops
operator|++
expr_stmt|;
goto|goto
name|badret
goto|;
block|}
if|if
condition|(
name|mp
operator|->
name|m_len
operator|<
name|icpullup
index|[
name|icp
operator|->
name|ic_type
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|mp
operator|=
name|m_pullup
argument_list|(
name|mp
argument_list|,
name|icpullup
index|[
name|icp
operator|->
name|ic_type
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|icmpstat
operator|.
name|ic_tooshort
operator|++
expr_stmt|;
return|return;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|icp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|mp
operator|->
name|m_off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|ilen
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
block|{
specifier|register
name|u_short
name|his_sum
decl_stmt|,
name|our_sum
decl_stmt|;
name|his_sum
operator|=
operator|(
name|u_short
operator|)
name|icp
operator|->
name|ic_sum
expr_stmt|;
name|icp
operator|->
name|ic_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|his_sum
operator|!=
operator|(
name|our_sum
operator|=
operator|(
name|u_short
operator|)
name|in_cksum
argument_list|(
name|mp
argument_list|,
name|ilen
argument_list|)
operator|)
condition|)
block|{
name|icmpstat
operator|.
name|ic_badsum
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|nosum
condition|)
block|{
comment|/* note that the icmp header doesn't overlap IP */
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_ICMP_CKSUM, (caddr_t),0); */
endif|#
directive|endif
name|inet_cksum_err
argument_list|(
literal|"icmp"
argument_list|,
name|ip
argument_list|,
operator|(
name|u_long
operator|)
name|his_sum
argument_list|,
operator|(
name|u_long
operator|)
name|our_sum
argument_list|)
expr_stmt|;
name|netlog
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/*      * Now do any processing.  Some messages are handled here,      * others are passed up ctlinput path for further processing.      */
switch|switch
condition|(
name|icp
operator|->
name|ic_type
condition|)
block|{
case|case
name|ICMP_UNRCH
case|:
comment|/* destination unreachable */
if|if
condition|(
name|icp
operator|->
name|ic_code
operator|<
name|ICMP_UNRCH_NUM
condition|)
block|{
specifier|register
name|int
function_decl|(
modifier|*
name|ctlfunc
function_decl|)
parameter_list|()
function_decl|;
name|prccode
operator|=
name|icunrch
index|[
name|icp
operator|->
name|ic_code
index|]
expr_stmt|;
name|passup
label|:
name|ctlfunc
operator|=
name|ipsw
index|[
name|icp
operator|->
name|ic_iphdr
operator|.
name|ip_p
index|]
operator|.
name|ipsw_user
operator|->
name|pr_ctlinput
expr_stmt|;
call|(
modifier|*
name|ctlfunc
call|)
argument_list|(
name|prccode
argument_list|,
operator|(
name|caddr_t
operator|)
name|icp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ICMP_SRCQ
case|:
comment|/* source quench */
comment|/* 	 * At the IP level, we could try to reroute the connection and see if we 	 * come up with a less loaded gateway.  Problem with this is that we know 	 * total number of packets sent over a route, not the recent traffic load. 	 */
name|icmpstat
operator|.
name|ic_quenches
operator|++
expr_stmt|;
name|prccode
operator|=
name|PRC_QUENCH
expr_stmt|;
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_ICMP_SRCQ, (caddr_t)0, 0); */
endif|#
directive|endif
goto|goto
name|passup
goto|;
case|case
name|ICMP_REDIR
case|:
comment|/* redirect */
name|icmpstat
operator|.
name|ic_redirects
operator|++
expr_stmt|;
comment|/* 	 * Sorry, we only trust the connected set of gateways 	 * that includes gateways installed by the system 	 * manager. 	 */
if|if
condition|(
name|know_gateway
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|table
decl_stmt|;
if|if
condition|(
name|icp
operator|->
name|ic_code
operator|==
name|ICMP_REDIR_NET
condition|)
block|{
name|prccode
operator|=
name|PRC_REDIRECT_NET
expr_stmt|;
name|table
operator|=
name|rtnet
expr_stmt|;
block|}
else|else
block|{
name|prccode
operator|=
name|PRC_REDIRECT_HOST
expr_stmt|;
name|table
operator|=
name|rthost
expr_stmt|;
block|}
if|if
condition|(
name|icmp_redirect_route
argument_list|(
name|icp
argument_list|,
name|table
argument_list|)
condition|)
goto|goto
name|passup
goto|;
block|}
else|else
block|{
comment|/* 	     * Who are you?  Why are you talking to us? 	     * And how do we know the ip source isn't a lie? 	     * (Eg., Catches Symbolics redirection of subnet broadcast.) 	     */
union|union
block|{
name|u_long
name|ul
decl_stmt|;
name|u_char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|a
union|;
name|a
operator|.
name|ul
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Ignoring redirect from %d.%d.%d.%d\n"
argument_list|,
name|a
operator|.
name|c
index|[
literal|0
index|]
argument_list|,
name|a
operator|.
name|c
index|[
literal|1
index|]
argument_list|,
name|a
operator|.
name|c
index|[
literal|2
index|]
argument_list|,
name|a
operator|.
name|c
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_ICMP_REDIR, (caddr_t)0,0); */
endif|#
directive|endif
break|break;
case|case
name|ICMP_ECHO
case|:
comment|/* echo */
name|icp
operator|->
name|ic_type
operator|=
name|ICMP_ECHOR
expr_stmt|;
name|icmpstat
operator|.
name|ic_echoes
operator|++
expr_stmt|;
goto|goto
name|loopback
goto|;
case|case
name|ICMP_ECHOR
case|:
comment|/* echo reply */
comment|/* check for gateway ping packets, look for 	 * corresponding gateway entry and set echo count 	 * to zero. 	 */
ifdef|#
directive|ifdef
name|BBNPING
if|if
condition|(
name|icp
operator|->
name|ic_id
operator|==
name|MY_ECHO_ID
condition|)
name|got_ping
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ICMP_TIMEX
case|:
comment|/* time exceeded */
comment|/* 	 * IP time to live field should be associated with the route so 	 * that it can be dynamically adjusted for time exceeded in transit. 	 * If did, would only need to "pass time exceeded in reassembly" 	 * up to protocol (TCP) so that it can better try to avoid IP 	 * fragmentation. 	 */
name|icmpstat
operator|.
name|ic_timex
operator|++
expr_stmt|;
name|prccode
operator|=
operator|(
name|icp
operator|->
name|ic_code
operator|==
name|ICMP_TIMEX_XMT
operator|)
condition|?
name|PRC_TIMXCEED_INTRANS
else|:
name|PRC_TIMXCEED_REASS
expr_stmt|;
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_ICMP_TIMEX, (caddr_t)0,0); */
endif|#
directive|endif
goto|goto
name|passup
goto|;
case|case
name|ICMP_TIMES
case|:
comment|/* timestamp */
if|if
condition|(
name|icp
operator|->
name|ic_code
operator|==
literal|0
condition|)
block|{
name|icp
operator|->
name|ic_type
operator|=
name|ICMP_TIMESR
expr_stmt|;
comment|/* 	     * Can now do timestamps in UT 	     * 	       icp->ic_trcv = (long)time.tv_sec | 0x80; 	       icp->ic_txmt = (long)time.tv_sec | 0x80; 	     */
name|icp
operator|->
name|ic_txmt
operator|=
name|icp
operator|->
name|ic_trcv
operator|=
name|iptime
argument_list|()
expr_stmt|;
goto|goto
name|loopback
goto|;
block|}
break|break;
case|case
name|ICMP_INFO
case|:
comment|/* info request */
comment|/* 	 * He knows his host number, but not his network #, 	 * fill in src& dst as he would have, had he known. 	 */
block|{
specifier|register
name|struct
name|in_ifaddr
modifier|*
name|inaddress
decl_stmt|;
specifier|extern
name|struct
name|ifnet
modifier|*
name|inetifp
decl_stmt|;
name|icp
operator|->
name|ic_type
operator|=
name|ICMP_INFOR
expr_stmt|;
name|inaddress
operator|=
name|in_iafromif
argument_list|(
name|inetifp
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator||=
name|inaddress
operator|->
name|ia_subnet
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|redir_addr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loopback
goto|;
case|case
name|ICMP_PARM
case|:
comment|/* parameter problem */
name|icmpstat
operator|.
name|ic_parm
operator|++
expr_stmt|;
name|prccode
operator|=
name|PRC_PARAMPROB
expr_stmt|;
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_ICMP_PARM, (caddr_t)0,0); */
endif|#
directive|endif
goto|goto
name|passup
goto|;
block|}
name|badret
label|:
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
name|loopback
label|:
block|{
name|struct
name|in_addr
name|temp
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
name|temp
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|temp
expr_stmt|;
comment|/* ip->ip_p = IPPROTO_ICMP; still is from input */
comment|/* ip->ip_tos = 0; use same tos for reply */
name|icp
operator|->
name|ic_sum
operator|=
name|in_cksum
argument_list|(
name|mp
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|NOPCB_IPSEND
argument_list|(
name|mp
argument_list|,
operator|(
name|int
operator|)
name|ip
operator|->
name|ip_len
argument_list|,
name|FALSE
argument_list|,
name|error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|error
operator|=
name|error
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_comment
comment|/*  * Ping gateways in use to see if they are still alive.  */
end_comment

begin_macro
name|ic_timeo
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|BBNPING
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
specifier|static
name|int
name|ictimer
decl_stmt|;
if|if
condition|(
operator|--
name|ictimer
operator|>
literal|0
condition|)
return|return;
name|ictimer
operator|=
name|PINGTIME
expr_stmt|;
name|level
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RTHASHSIZ
condition|;
name|i
operator|++
control|)
block|{
name|check_ping
argument_list|(
name|rthost
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|check_ping
argument_list|(
name|rtnet
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|level
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
specifier|static
name|struct
name|rtentry
modifier|*
name|rtfind
parameter_list|(
name|dst
parameter_list|,
name|via
parameter_list|,
name|table
parameter_list|)
name|struct
name|in_addr
name|dst
decl_stmt|;
name|struct
name|in_addr
name|via
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|table
index|[]
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
if|if
condition|(
name|table
operator|==
name|rthost
condition|)
name|m
operator|=
name|rthost
index|[
name|HOSTHASH
argument_list|(
name|dst
operator|.
name|s_addr
argument_list|)
operator|%
name|RTHASHSIZ
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dst
operator|.
name|s_addr
condition|)
block|{
name|m
operator|=
name|rtnet
index|[
name|NETHASH
argument_list|(
name|dst
argument_list|)
operator|%
name|RTHASHSIZ
index|]
expr_stmt|;
name|dst
operator|.
name|s_addr
operator|=
name|iptonet
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
else|else
name|m
operator|=
name|rtnet
index|[
literal|0
index|]
expr_stmt|;
block|}
while|while
condition|(
name|m
condition|)
block|{
name|struct
name|in_addr
name|d
decl_stmt|,
name|g
decl_stmt|;
name|rt
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|rtentry
operator|*
argument_list|)
expr_stmt|;
name|d
operator|=
name|satoipa
argument_list|(
operator|&
name|rt
operator|->
name|rt_dst
argument_list|)
expr_stmt|;
name|g
operator|=
name|satoipa
argument_list|(
operator|&
name|rt
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|.
name|s_addr
operator|==
name|dst
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|g
operator|.
name|s_addr
operator|==
name|via
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_dst
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
condition|)
block|{
comment|/* then, hash values must be same. */
return|return
operator|(
name|rt
operator|)
return|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|icmp_redirect_route
argument_list|(
argument|ic
argument_list|,
argument|table
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|table
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|red_dst
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|red_gtw
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ic
operator|->
name|ic_data
expr_stmt|;
comment|/*      * 1.  Make new routing entry so that new connections will use better      * route.  But only make entry if have not already done so.      */
if|if
condition|(
operator|!
name|rtfind
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|ic
operator|->
name|ic_gaddr
argument_list|,
name|table
argument_list|)
condition|)
block|{
name|char
modifier|*
name|err
decl_stmt|;
comment|/* check reasonableness of redirect */
if|if
condition|(
name|in_iawithnet
argument_list|(
name|ic
operator|->
name|ic_gaddr
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * Sorry, can't get there from here. 	     */
union|union
block|{
name|u_long
name|ul
decl_stmt|;
name|u_char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|g
union|,
name|f
union|,
name|t
union|,
name|v
union|;
name|err
operator|=
literal|"No interface for first hop"
expr_stmt|;
name|perr
label|:
name|g
operator|.
name|ul
operator|=
operator|(
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ic
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
operator|)
operator|->
name|ip_src
operator|.
name|s_addr
operator|)
expr_stmt|;
name|f
operator|.
name|ul
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|t
operator|.
name|ul
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|v
operator|.
name|ul
operator|=
name|ic
operator|->
name|ic_gaddr
operator|.
name|s_addr
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Ignoring ICMP redirect from gw %d.%d.%d.%d? to go from %d.%d.%d.%d to %d.%d.%d.%d via %d.%d.%d.%d : %s\n"
argument_list|,
name|g
operator|.
name|c
index|[
literal|0
index|]
argument_list|,
name|g
operator|.
name|c
index|[
literal|1
index|]
argument_list|,
name|g
operator|.
name|c
index|[
literal|2
index|]
argument_list|,
name|g
operator|.
name|c
index|[
literal|3
index|]
argument_list|,
name|f
operator|.
name|c
index|[
literal|0
index|]
argument_list|,
name|f
operator|.
name|c
index|[
literal|1
index|]
argument_list|,
name|f
operator|.
name|c
index|[
literal|2
index|]
argument_list|,
name|f
operator|.
name|c
index|[
literal|3
index|]
argument_list|,
name|t
operator|.
name|c
index|[
literal|0
index|]
argument_list|,
name|t
operator|.
name|c
index|[
literal|1
index|]
argument_list|,
name|t
operator|.
name|c
index|[
literal|2
index|]
argument_list|,
name|t
operator|.
name|c
index|[
literal|3
index|]
argument_list|,
name|v
operator|.
name|c
index|[
literal|0
index|]
argument_list|,
name|v
operator|.
name|c
index|[
literal|1
index|]
argument_list|,
name|v
operator|.
name|c
index|[
literal|2
index|]
argument_list|,
name|v
operator|.
name|c
index|[
literal|3
index|]
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|in_iawithaddr
argument_list|(
name|ic
operator|->
name|ic_gaddr
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* 	     * redirect to self is stupid, as is redirect to 	     * broadcast address (which if_iawithaddr will match 	     * for interfaces with IFF_BROADCAST set.) 	     */
name|err
operator|=
literal|"redirected to self"
expr_stmt|;
goto|goto
name|perr
goto|;
block|}
if|if
condition|(
name|iptonet
argument_list|(
name|ic
operator|->
name|ic_gaddr
argument_list|)
operator|!=
name|iptonet
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
condition|)
block|{
comment|/* 	     * Why is this gateway redirecting us?  It is not 	     * giving us a first hop gateway that is on the 	     * local net that we advertise. 	     */
name|err
operator|=
literal|"new first hop net<> src net"
expr_stmt|;
goto|goto
name|perr
goto|;
block|}
ifdef|#
directive|ifdef
name|done_in_icmp_c
if|if
condition|(
operator|!
name|know_gateway
argument_list|(
argument|icmp source
argument_list|)
condition|)
comment|/* 	     * Sorry, we only trust the connected set of gateways 	     * that includes gateways installed by the system 	     * manager.  Who are you?  Why are you talking to us? 	     */
return|return;
endif|#
directive|endif
comment|/* o.k., I'll believe it */
name|flags
operator|=
name|RTF_UP
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|rthost
condition|)
block|{
name|flags
operator||=
name|RTF_HOST
expr_stmt|;
name|red_dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
block|{
name|flags
operator||=
name|RTF_GATEWAY
expr_stmt|;
name|red_dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|iptonet
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
expr_stmt|;
block|}
name|red_gtw
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ic
operator|->
name|ic_gaddr
operator|.
name|s_addr
expr_stmt|;
name|rtinit
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|red_dst
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|red_gtw
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_macro
name|icmp_redirect_inp
argument_list|(
argument|inp
argument_list|,
argument|ic
argument_list|,
argument|table
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
comment|/*      * 2.  Redirect current connection.      */
ifdef|#
directive|ifdef
name|neverdef
comment|/* 	 * This would try to balance load across gateways, but 	 * that's something best done by the gateway before it 	 * sends a redirect.  Also, consider 3 gateways of which 	 * two are bad, and possibility of bouncing between the 	 * two bad ones until their use counts got high enough. 	 * 	 * Currently, gateways only take into account # hops, not 	 * load. 	 */
if|if
condition|(
name|rt
operator|=
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
condition|)
block|{
name|short
name|oflags
decl_stmt|;
comment|/* try to force a different path */
name|oflags
operator|=
name|rt
operator|->
name|rt_flags
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_UP
expr_stmt|;
comment|/* but don't lose current route */
name|rt
operator|->
name|rt_refcnt
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|ip_reroute
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|=
name|oflags
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rt
operator|=
name|rtfind
argument_list|(
name|ic
operator|->
name|ic_iphdr
operator|.
name|ip_dst
argument_list|,
name|ic
operator|->
name|ic_gaddr
argument_list|,
name|table
argument_list|)
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
condition|)
block|{
comment|/* 		 * packets go out an interface with our local 		 * IP address.  Know true from checks after 		 * first call to rtfind above. 		 * 		 * Interface has to be at least as up as 		 * for previous route, so don't bother to 		 * check. 		 */
if|if
condition|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
condition|)
name|rtfree
argument_list|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|=
name|rt
expr_stmt|;
name|rt
operator|->
name|rt_refcnt
operator|++
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ICMP Redirect to down route\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ICMP Redirect route not installed?\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

