begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)kdb_print.c	7.17 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"machine/mtpr.h"
end_include

begin_undef
undef|#
directive|undef
name|ISP
end_undef

begin_include
include|#
directive|include
file|"../kdb/defs.h"
end_include

begin_undef
undef|#
directive|undef
name|CTRL
end_undef

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|kdbBADRAD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|kdblastframe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|kdbcallpc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|kdbBADMOD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|kdblp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|kdbmaxpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kdbradix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|kdblastc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* breakpoints */
end_comment

begin_decl_stmt
name|BKPTR
name|kdbbkpthead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|REGLIST
name|kdbreglist
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* general printing routines ($) */
end_comment

begin_macro
name|kdbprinttrace
argument_list|(
argument|modif
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|narg
operator|,
name|i
expr_stmt|;
specifier|register
name|BKPTR
name|bkptr
decl_stmt|;
specifier|register
name|ADDR
name|word
decl_stmt|;
specifier|register
name|char
modifier|*
name|comptr
decl_stmt|;
specifier|register
name|ADDR
name|argp
decl_stmt|,
name|frame
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|int
name|ntramp
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|extern
name|struct
name|proc
modifier|*
name|allproc
decl_stmt|;
if|if
condition|(
name|kdbcntflg
operator|==
literal|0
condition|)
name|kdbcntval
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|modif
condition|)
block|{
case|case
literal|'d'
case|:
if|if
condition|(
name|kdbadrflg
condition|)
block|{
if|if
condition|(
name|kdbadrval
operator|<
literal|2
operator|||
name|kdbadrval
operator|>
literal|16
condition|)
name|kdberror
argument_list|(
name|kdbBADRAD
argument_list|)
expr_stmt|;
name|kdbradix
operator|=
name|kdbadrval
expr_stmt|;
block|}
name|kdbprintf
argument_list|(
literal|"radix=%d base ten"
argument_list|,
name|kdbradix
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|kdbprintf
argument_list|(
literal|"maxpos=%d"
argument_list|,
name|kdbmaxpos
operator|=
operator|(
name|kdbadrflg
condition|?
name|kdbadrval
else|:
name|MAXPOS
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|kdbprintf
argument_list|(
literal|"maxoff=%d"
argument_list|,
name|kdbmaxoff
operator|=
operator|(
name|kdbadrflg
condition|?
name|kdbadrval
else|:
name|MAXOFF
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|kdbprintf
argument_list|(
literal|"variables\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|35
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|kdbvar
index|[
name|i
index|]
condition|)
block|{
name|kdbprintc
argument_list|(
operator|(
name|i
operator|<=
literal|9
condition|?
literal|'0'
else|:
literal|'a'
operator|-
literal|10
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|kdbprintf
argument_list|(
literal|" = %R\n"
argument_list|,
name|kdbvar
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
case|case
literal|'?'
case|:
if|if
condition|(
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|kdbvar
index|[
name|kdbvarchk
argument_list|(
literal|'p'
argument_list|)
index|]
condition|)
name|kdbprintf
argument_list|(
literal|"pid = %d\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
else|else
name|kdbprintf
argument_list|(
literal|"in idle loop\n"
argument_list|)
expr_stmt|;
name|kdbprinttrap
argument_list|(
name|kdbvar
index|[
name|kdbvarchk
argument_list|(
literal|'t'
argument_list|)
index|]
argument_list|,
name|kdbvar
index|[
name|kdbvarchk
argument_list|(
literal|'c'
argument_list|)
index|]
argument_list|)
expr_stmt|;
comment|/* fall thru... */
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|kdbprintregs
argument_list|(
name|modif
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
if|if
condition|(
name|kdbadrflg
condition|)
block|{
name|frame
operator|=
name|kdbadrval
expr_stmt|;
name|kdbcallpc
operator|=
name|getprevpc
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|frame
operator|=
name|kdbpcb
operator|.
name|pcb_fp
expr_stmt|;
name|kdbcallpc
operator|=
name|kdbpcb
operator|.
name|pcb_pc
expr_stmt|;
block|}
name|kdblastframe
operator|=
name|NOFRAME
expr_stmt|;
name|ntramp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|kdbcntval
operator|--
operator|&&
name|frame
operator|!=
name|NOFRAME
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|kdbchkerr
argument_list|()
expr_stmt|;
comment|/* check for pc in pcb (signal trampoline code) */
if|if
condition|(
name|issignalpc
argument_list|(
name|kdbcallpc
argument_list|)
condition|)
block|{
name|name
operator|=
literal|"sigtramp"
expr_stmt|;
name|ntramp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ntramp
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|kdbfindsym
argument_list|(
operator|(
name|long
operator|)
name|kdbcallpc
argument_list|,
name|ISYM
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdbcursym
condition|)
name|name
operator|=
name|kdbcursym
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
else|else
name|name
operator|=
literal|"?"
expr_stmt|;
block|}
name|kdbprintf
argument_list|(
literal|"%s("
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|narg
operator|=
name|getnargs
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|narg
operator|>
literal|10
condition|)
name|narg
operator|=
literal|10
expr_stmt|;
name|argp
operator|=
name|frame
expr_stmt|;
if|if
condition|(
name|ntramp
operator|!=
literal|1
condition|)
while|while
condition|(
name|narg
condition|)
block|{
name|kdbprintf
argument_list|(
literal|"%R"
argument_list|,
name|kdbget
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|argp
operator|=
name|nextarg
argument_list|(
name|argp
argument_list|)
argument_list|)
argument_list|,
name|DSP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|narg
operator|!=
literal|0
condition|)
name|kdbprintc
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|kdbprintf
argument_list|(
literal|") at "
argument_list|)
expr_stmt|;
name|kdbpsymoff
argument_list|(
operator|(
name|long
operator|)
name|kdbcallpc
argument_list|,
name|ISYM
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modif
operator|==
literal|'C'
condition|)
block|{
while|while
condition|(
name|kdblocalsym
argument_list|(
operator|(
name|long
operator|)
name|frame
argument_list|)
condition|)
block|{
name|word
operator|=
name|kdbget
argument_list|(
operator|(
name|off_t
operator|)
name|kdblocalval
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|kdbprintf
argument_list|(
literal|"%8t%s:%10t"
argument_list|,
name|kdbcursym
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdberrflg
condition|)
block|{
name|kdbprintf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
name|kdberrflg
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|kdbprintf
argument_list|(
literal|"%R\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ntramp
operator|!=
literal|1
condition|)
block|{
name|kdbcallpc
operator|=
name|getprevpc
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|kdblastframe
operator|=
name|frame
expr_stmt|;
name|frame
operator|=
name|getprevframe
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
name|kdbcallpc
operator|=
name|getsignalpc
argument_list|(
name|kdblastframe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kdbadrflg
operator|&&
operator|!
name|INSTACK
argument_list|(
name|frame
argument_list|)
condition|)
break|break;
block|}
break|break;
comment|/*print externals*/
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
for|for
control|(
name|sp
operator|=
name|kdbsymtab
init|;
name|sp
operator|<
name|kdbesymtab
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|n_type
operator|==
operator|(
name|N_DATA
operator||
name|N_EXT
operator|)
operator|||
name|sp
operator|->
name|n_type
operator|==
operator|(
name|N_BSS
operator||
name|N_EXT
operator|)
condition|)
name|kdbprintf
argument_list|(
literal|"%s:%12t%R\n"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|kdbget
argument_list|(
operator|(
name|off_t
operator|)
name|sp
operator|->
name|n_value
argument_list|,
name|DSP
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/*print breakpoints*/
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|kdbprintf
argument_list|(
literal|"breakpoints\ncount%8tbkpt%24tcommand\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bkptr
operator|=
name|kdbbkpthead
init|;
name|bkptr
condition|;
name|bkptr
operator|=
name|bkptr
operator|->
name|nxtbkpt
control|)
if|if
condition|(
name|bkptr
operator|->
name|flag
condition|)
block|{
name|kdbprintf
argument_list|(
literal|"%-8.8d"
argument_list|,
name|bkptr
operator|->
name|count
argument_list|)
expr_stmt|;
name|kdbpsymoff
argument_list|(
operator|(
name|long
operator|)
name|bkptr
operator|->
name|loc
argument_list|,
name|ISYM
argument_list|,
literal|"%24t"
argument_list|)
expr_stmt|;
name|comptr
operator|=
name|bkptr
operator|->
name|comm
expr_stmt|;
while|while
condition|(
operator|*
name|comptr
condition|)
name|kdbprintc
argument_list|(
operator|*
name|comptr
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'k'
case|:
name|panic
argument_list|(
literal|"kdb requested panic"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'l'
case|:
block|{
name|struct
name|pte
name|savemmap
decl_stmt|;
specifier|extern
name|char
name|vmmap
index|[]
decl_stmt|;
name|savemmap
operator|=
name|mmap
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|allproc
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|p_nxt
control|)
block|{
name|kdbprintf
argument_list|(
literal|"%X pid %5d%c%5d %c "
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|==
operator|(
expr|struct
name|proc
operator|*
operator|)
name|kdbvar
index|[
name|kdbvarchk
argument_list|(
literal|'p'
argument_list|)
index|]
condition|?
literal|'*'
else|:
literal|' '
argument_list|,
name|p
operator|->
name|p_ppid
argument_list|,
name|p
operator|->
name|p_stat
operator|==
name|SSLEEP
condition|?
literal|'S'
else|:
name|p
operator|->
name|p_stat
operator|==
name|SRUN
condition|?
literal|'R'
else|:
name|p
operator|->
name|p_stat
operator|==
name|SIDL
condition|?
literal|'I'
else|:
name|p
operator|->
name|p_stat
operator|==
name|SSTOP
condition|?
literal|'T'
else|:
literal|'?'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_wchan
condition|)
name|kdbpsymoff
argument_list|(
operator|(
name|long
operator|)
name|p
operator|->
name|p_wchan
argument_list|,
name|ISYM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
operator|&&
name|p
operator|->
name|p_addr
condition|)
block|{
name|int
name|i
decl_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|mmap
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|p
operator|->
name|p_addr
expr_stmt|;
name|mtpr
argument_list|(
name|TBIS
argument_list|,
name|vmmap
argument_list|)
expr_stmt|;
define|#
directive|define
name|U
value|((struct user *)vmmap)
ifdef|#
directive|ifdef
name|not_until_uarea_completely_mapped
if|if
condition|(
name|U
operator|->
name|u_ttyp
condition|)
name|kdbprintf
argument_list|(
literal|" ctty %x "
argument_list|,
name|U
operator|->
name|u_ttyp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kdbprintf
argument_list|(
literal|" %.8s "
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|U
block|}
name|kdbprintc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
block|}
name|mmap
index|[
literal|0
index|]
operator|=
name|savemmap
expr_stmt|;
name|mtpr
argument_list|(
name|TBIS
argument_list|,
name|vmmap
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'t'
case|:
comment|/* XXX - debug */
if|if
condition|(
name|kdbadrflg
condition|)
block|{
name|kdbprintf
argument_list|(
literal|"dev       state  rawq   canq  outq  lwat hwat\n"
argument_list|)
expr_stmt|;
define|#
directive|define
name|T
value|((struct tty *)kdbadrval)
name|kdbprintf
argument_list|(
literal|"%x  %x %d %d %d %d %d\n"
argument_list|,
name|T
operator|->
name|t_dev
argument_list|,
name|T
operator|->
name|t_state
argument_list|,
name|T
operator|->
name|t_rawq
operator|.
name|c_cc
argument_list|,
name|T
operator|->
name|t_canq
operator|.
name|c_cc
argument_list|,
name|T
operator|->
name|t_outq
operator|.
name|c_cc
argument_list|,
name|T
operator|->
name|t_lowat
argument_list|,
name|T
operator|->
name|t_hiwat
argument_list|)
expr_stmt|;
name|kdbprintf
argument_list|(
literal|"&rawq&canq&outq&outq.c_cf&rawq.c_cf\n"
argument_list|)
expr_stmt|;
name|kdbprintf
argument_list|(
literal|" %x %x  %x %x %x \n"
argument_list|,
operator|&
name|T
operator|->
name|t_rawq
argument_list|,
operator|&
name|T
operator|->
name|t_canq
argument_list|,
operator|&
name|T
operator|->
name|t_outq
argument_list|,
operator|&
name|T
operator|->
name|t_outq
operator|.
name|c_cf
argument_list|,
operator|&
name|T
operator|->
name|t_rawq
operator|.
name|c_cf
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|T
block|}
case|case
literal|'v'
case|:
block|{
specifier|register
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|kdbprintf
argument_list|(
literal|"Locked vnodes\n"
argument_list|)
expr_stmt|;
name|mp
operator|=
name|rootfs
expr_stmt|;
do|do
block|{
for|for
control|(
name|vp
operator|=
name|mp
operator|->
name|m_mounth
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|v_mountf
control|)
if|if
condition|(
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
condition|)
name|vprint
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|mp
operator|!=
name|rootfs
condition|)
do|;
break|break;
block|}
default|default:
name|kdberror
argument_list|(
name|kdbBADMOD
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|kdbprintregs
argument_list|(
argument|c
argument_list|)
block|{
specifier|register
name|REGPTR
name|p
block|;
name|ADDR
name|v
block|;
for|for
control|(
name|p
operator|=
name|kdbreglist
init|;
name|p
operator|->
name|rname
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'R'
operator|&&
name|ishiddenreg
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
name|v
operator|=
operator|*
name|p
operator|->
name|rkern
expr_stmt|;
name|kdbprintf
argument_list|(
literal|"%s%6t%R %16t"
argument_list|,
name|p
operator|->
name|rname
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|kdbvalpr
argument_list|(
operator|(
name|long
operator|)
name|v
argument_list|,
name|p
operator|->
name|rkern
operator|==
operator|&
name|kdbpcb
operator|.
name|pcb_pc
condition|?
name|ISYM
else|:
name|DSYM
argument_list|)
expr_stmt|;
name|kdbprintc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
block|}
name|kdbprintpc
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  kdbgetreg
operator|(
name|regnam
operator|)
block|{
specifier|register
name|REGPTR
name|p
block|;
specifier|register
name|char
operator|*
name|regptr
block|;
name|char
operator|*
name|olp
block|;
name|olp
operator|=
name|kdblp
block|;
for|for
control|(
name|p
operator|=
name|kdbreglist
init|;
name|p
operator|->
name|rname
condition|;
name|p
operator|++
control|)
block|{
name|regptr
operator|=
name|p
operator|->
name|rname
expr_stmt|;
if|if
condition|(
name|regnam
operator|==
operator|*
name|regptr
operator|++
condition|)
block|{
while|while
condition|(
operator|*
name|regptr
condition|)
if|if
condition|(
name|kdbreadchar
argument_list|()
operator|!=
operator|*
name|regptr
operator|++
condition|)
block|{
operator|--
name|regptr
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|regptr
condition|)
name|kdblp
operator|=
name|olp
expr_stmt|;
else|else
return|return
operator|(
operator|(
name|int
operator|)
name|p
operator|->
name|rkern
operator|)
return|;
end_if

begin_expr_stmt
unit|} 	}
name|kdblp
operator|=
name|olp
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
operator|-
literal|1
operator|)
return|;
end_return

begin_expr_stmt
unit|}  kdbprintpc
operator|(
operator|)
block|{
name|kdbpsymoff
argument_list|(
operator|(
name|long
operator|)
name|kdbpcb
operator|.
name|pcb_pc
argument_list|,
name|ISYM
argument_list|,
literal|":%16t"
argument_list|)
block|;
name|kdbprintins
argument_list|(
name|ISP
argument_list|,
operator|(
name|long
operator|)
name|kdbchkget
argument_list|(
operator|(
name|off_t
operator|)
name|kdbpcb
operator|.
name|pcb_pc
argument_list|,
name|ISP
argument_list|)
argument_list|)
block|;
name|kdbprintc
argument_list|(
name|EOR
argument_list|)
block|; }
end_expr_stmt

end_unit

