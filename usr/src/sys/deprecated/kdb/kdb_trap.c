begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	kdb_trap.c	7.4	86/11/23	*/
end_comment

begin_comment
comment|/*  * Trap handler - command loop entry point.  */
end_comment

begin_include
include|#
directive|include
file|"../kdb/defs.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|NOEOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|executing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lastc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|userpc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastcom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|maxoff
init|=
name|MAXOFF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|maxpos
init|=
name|MAXPOS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Kdb trap handler; entered on all fatal  * and/or debugger related traps or faults.  */
end_comment

begin_macro
name|kdb
argument_list|(
argument|type
argument_list|,
argument|code
argument_list|,
argument|curproc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|,
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|curproc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|var
index|[
name|varchk
argument_list|(
literal|'t'
argument_list|)
index|]
operator|=
name|type
expr_stmt|;
name|var
index|[
name|varchk
argument_list|(
literal|'c'
argument_list|)
index|]
operator|=
name|code
expr_stmt|;
name|var
index|[
name|varchk
argument_list|(
literal|'p'
argument_list|)
index|]
operator|=
operator|(
name|int
operator|)
name|curproc
expr_stmt|;
name|printtrap
argument_list|(
name|type
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|userpc
operator|=
name|dot
operator|=
name|pcb
operator|.
name|pcb_pc
expr_stmt|;
switch|switch
condition|(
name|setexit
argument_list|()
condition|)
block|{
case|case
name|SINGLE
case|:
name|setsstep
argument_list|()
expr_stmt|;
comment|/* hardware single step */
comment|/* fall thru... */
case|case
name|CONTIN
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|0
case|:
if|if
condition|(
name|nextpcs
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"breakpoint%16t"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"stopped at%16t"
argument_list|)
expr_stmt|;
name|printpc
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|executing
condition|)
name|delbp
argument_list|()
expr_stmt|;
name|executing
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|flushbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|errflg
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|errflg
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mkfault
condition|)
block|{
name|mkfault
operator|=
literal|0
expr_stmt|;
name|printc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|DBNAME
argument_list|)
expr_stmt|;
block|}
name|kdbwrite
argument_list|(
literal|"kdb> "
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|lp
operator|=
literal|0
expr_stmt|;
name|rdc
argument_list|()
expr_stmt|;
name|lp
operator|--
expr_stmt|;
name|command
argument_list|(
literal|0
argument_list|,
name|lastcom
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|&&
name|lastc
operator|!=
literal|'\n'
condition|)
name|error
argument_list|(
name|NOEOR
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * If there has been an error or a fault, take the error.  */
end_comment

begin_macro
name|chkerr
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|errflg
operator|||
name|mkfault
condition|)
name|error
argument_list|(
name|errflg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * An error occurred; save the message for  * later printing, and reset to main command loop.  */
end_comment

begin_macro
name|error
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|errflg
operator|=
name|n
expr_stmt|;
name|reset
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

