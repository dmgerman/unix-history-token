begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and Ralph Campbell.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: hpux_compat.c 1.41 91/04/06$  *  *	@(#)ultrix_compat.c	7.4 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Various ULTRIX compatibility routines  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ULTRIXCOMPAT
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|unimpresponse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YP domainname */
end_comment

begin_decl_stmt
name|char
name|domainname
index|[
name|MAXHOSTNAMELEN
index|]
init|=
literal|"unknown"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|domainnamelen
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_macro
name|notimp
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
specifier|register
name|int
modifier|*
name|argp
init|=
name|uap
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ultrixsyscallnames
index|[]
decl_stmt|;
name|printf
argument_list|(
literal|"ULTRIX %s("
argument_list|,
name|ultrixsyscallnames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
condition|)
while|while
condition|(
name|nargs
operator|--
condition|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
operator|*
name|argp
operator|++
argument_list|,
name|nargs
condition|?
literal|','
else|:
literal|')'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|unimpresponse
condition|)
block|{
case|case
literal|0
case|:
name|error
operator|=
name|nosys
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|uprintf
argument_list|(
literal|"ULTRIX system call %d not implemented\n"
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_regs
index|[
name|V0
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|nosys
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|wait3_args
block|{
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|options
decl_stmt|;
name|int
name|rusage
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ultrixwait3
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|wait3_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
struct|struct
block|{
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|options
decl_stmt|;
name|struct
name|rusage
modifier|*
name|rusage
decl_stmt|;
name|int
name|compat
decl_stmt|;
block|}
name|bsd_uap
struct|;
comment|/* rusage pointer must be zero */
if|if
condition|(
name|uap
operator|->
name|rusage
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bsd_uap
operator|.
name|pid
operator|=
name|WAIT_ANY
expr_stmt|;
name|bsd_uap
operator|.
name|status
operator|=
name|uap
operator|->
name|status
expr_stmt|;
name|bsd_uap
operator|.
name|options
operator|=
literal|0
expr_stmt|;
name|bsd_uap
operator|.
name|rusage
operator|=
literal|0
expr_stmt|;
name|bsd_uap
operator|.
name|compat
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|wait1
argument_list|(
name|p
argument_list|,
operator|&
name|bsd_uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|domainname_args
block|{
name|char
modifier|*
name|domainname
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ultrixgetdomainname
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|domainname_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|uap
operator|->
name|len
operator|>
name|domainnamelen
operator|+
literal|1
condition|)
name|uap
operator|->
name|len
operator|=
name|domainnamelen
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
name|domainname
argument_list|,
name|uap
operator|->
name|domainname
argument_list|,
name|uap
operator|->
name|len
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|ultrixsetdomainname
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|domainname_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|len
operator|>
sizeof|sizeof
argument_list|(
name|domainname
argument_list|)
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|domainnamelen
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|domainname
argument_list|,
name|domainname
argument_list|,
name|uap
operator|->
name|len
argument_list|)
expr_stmt|;
name|domainname
index|[
name|domainnamelen
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|getpgrp_args
block|{
name|int
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * This is the equivalent of BSD getpgrp but with more restrictions.  * Note we do not check the real uid or "saved" uid.  */
end_comment

begin_macro
name|ultrixgetpgrp
argument_list|(
argument|cp
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|getpgrp_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
name|uap
operator|->
name|pid
operator|=
name|cp
operator|->
name|p_pid
expr_stmt|;
name|p
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|cp
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
name|cp
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|&&
operator|!
name|inferior
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
operator|*
name|retval
operator|=
name|p
operator|->
name|p_pgid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|setpgrp_args
block|{
name|int
name|pid
decl_stmt|;
name|int
name|pgrp
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_comment
comment|/*  * This is the equivalent of BSD setpgrp but with more restrictions.  * Note we do not check the real uid or "saved" uid or pgrp.  */
end_comment

begin_macro
name|ultrixsetpgrp
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|setpgrp_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* empirically determined */
if|if
condition|(
name|uap
operator|->
name|pgrp
operator|<
literal|0
operator|||
name|uap
operator|->
name|pgrp
operator|>=
literal|30000
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|setpgid
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|sigvec_args
block|{
name|int
name|signo
decl_stmt|;
name|struct
name|sigvec
modifier|*
name|nsv
decl_stmt|;
name|struct
name|sigvec
modifier|*
name|osv
decl_stmt|;
name|caddr_t
name|sigcode
decl_stmt|;
comment|/* handler return address */
block|}
struct|;
end_struct

begin_macro
name|ultrixsigvec
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|sigvec_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|osigvec
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|ultrixsigcleanup
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"ultrixsigcleanup %s %d\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_block

begin_macro
name|ultrixsigreturn
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"ultrixsigreturn %s %d\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Switch process from ULTRIX emulation to BSD.  */
end_comment

begin_macro
name|ultrixtobsd
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&=
operator|~
name|MDP_ULTRIX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|ultrixgetsysinfo
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * Just return a 0.  This says that the requested information is 	 * not available which is certainly true for the most part. 	 */
name|retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

