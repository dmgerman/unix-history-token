begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and Ralph Campbell.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: trap.c 1.32 91/04/06$  *  *	@(#)trap.c	7.2 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"signalvar.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|"ktrace.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../include/trap.h"
end_include

begin_include
include|#
directive|include
file|"../include/psl.h"
end_include

begin_include
include|#
directive|include
file|"../include/reg.h"
end_include

begin_include
include|#
directive|include
file|"../include/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../include/pte.h"
end_include

begin_include
include|#
directive|include
file|"../include/mips_opcode.h"
end_include

begin_include
include|#
directive|include
file|"clockreg.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_kern.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_page.h"
end_include

begin_comment
comment|/*  * This is a kludge to allow X windows to work.  */
end_comment

begin_define
define|#
directive|define
name|X_KLUGE
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|X_KLUGE
end_ifdef

begin_define
define|#
directive|define
name|USER_MAP_ADDR
value|0x4000
end_define

begin_define
define|#
directive|define
name|NPTES
value|300
end_define

begin_decl_stmt
specifier|static
name|pt_entry_t
name|UserMapPtes
index|[
name|NPTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|nUserMapPtes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pid_t
name|UserMapPid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|proc
modifier|*
name|machFPCurProcPtr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to last proc to use FP */
end_comment

begin_function_decl
specifier|extern
name|void
name|MachKernGenException
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachUserGenException
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachKernIntr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachUserIntr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachTLBModException
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachTLBMissException
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MemErrorInterrupt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|MachEmulateBranch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|machExceptionTable
index|[]
function_decl|)
parameter_list|()
init|=
block|{
comment|/*  * The kernel exception handlers.  */
name|MachKernIntr
operator|,
comment|/* external interrupt */
function_decl|MachKernGenException
operator|,
comment|/* TLB modification */
function_decl|MachTLBMissException
operator|,
comment|/* TLB miss (load or instr. fetch) */
function_decl|MachTLBMissException
operator|,
comment|/* TLB miss (store) */
function_decl|MachKernGenException
operator|,
comment|/* address error (load or I-fetch) */
function_decl|MachKernGenException
operator|,
comment|/* address error (store) */
function_decl|MachKernGenException
operator|,
comment|/* bus error (I-fetch) */
function_decl|MachKernGenException
operator|,
comment|/* bus error (load or store) */
function_decl|MachKernGenException
operator|,
comment|/* system call */
function_decl|MachKernGenException
operator|,
comment|/* breakpoint */
function_decl|MachKernGenException
operator|,
comment|/* reserved instruction */
function_decl|MachKernGenException
operator|,
comment|/* coprocessor unusable */
function_decl|MachKernGenException
operator|,
comment|/* arithmetic overflow */
function_decl|MachKernGenException
operator|,
comment|/* reserved */
function_decl|MachKernGenException
operator|,
comment|/* reserved */
function_decl|MachKernGenException
operator|,
comment|/* reserved */
comment|/*  * The user exception handlers.  */
function_decl|MachUserIntr
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
end_function_decl

begin_decl_stmt
unit|};
name|char
modifier|*
name|trap_type
index|[]
init|=
block|{
literal|"external interrupt"
block|,
literal|"TLB modification"
block|,
literal|"TLB miss (load or instr. fetch)"
block|,
literal|"TLB miss (store)"
block|,
literal|"address error (load or I-fetch)"
block|,
literal|"address error (store)"
block|,
literal|"bus error (I-fetch)"
block|,
literal|"bus error (load or store)"
block|,
literal|"system call"
block|,
literal|"breakpoint"
block|,
literal|"reserved instruction"
block|,
literal|"coprocessor unusable"
block|,
literal|"arithmetic overflow"
block|,
literal|"reserved 13"
block|,
literal|"reserved 14"
block|,
literal|"reserved 15"
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|TRAPSIZE
value|10
end_define

begin_struct
struct|struct
name|trapdebug
block|{
comment|/* trap history buffer for debugging */
name|u_int
name|status
decl_stmt|;
name|u_int
name|cause
decl_stmt|;
name|u_int
name|vadr
decl_stmt|;
name|u_int
name|pc
decl_stmt|;
name|u_int
name|ra
decl_stmt|;
name|u_int
name|code
decl_stmt|;
block|}
name|trapdebug
index|[
name|TRAPSIZE
index|]
struct|,
modifier|*
name|trp
init|=
name|trapdebug
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Handle an exception.  * Called from MachKernGenException() or MachUserGenException()  * when a processor trap occurs.  * In the case of a kernel trap, we return the pc where to resume if  * ((struct pcb *)UADDR)->pcb_onfault is set, otherwise, return old pc.  */
end_comment

begin_function
name|unsigned
name|trap
parameter_list|(
name|statusReg
parameter_list|,
name|causeReg
parameter_list|,
name|vadr
parameter_list|,
name|pc
parameter_list|,
name|args
parameter_list|)
name|unsigned
name|statusReg
decl_stmt|;
comment|/* status register at time of the exception */
name|unsigned
name|causeReg
decl_stmt|;
comment|/* cause register at time of exception */
name|unsigned
name|vadr
decl_stmt|;
comment|/* address (if any) the fault occured on */
name|unsigned
name|pc
decl_stmt|;
comment|/* program counter where to continue */
block|{
specifier|register
name|int
name|type
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|ucode
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|struct
name|timeval
name|syst
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
specifier|extern
name|unsigned
name|onfault_table
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|trp
operator|->
name|status
operator|=
name|statusReg
expr_stmt|;
name|trp
operator|->
name|cause
operator|=
name|causeReg
expr_stmt|;
name|trp
operator|->
name|vadr
operator|=
name|vadr
expr_stmt|;
name|trp
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
name|trp
operator|->
name|ra
operator|=
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|?
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|19
index|]
else|:
name|p
operator|->
name|p_regs
index|[
name|RA
index|]
expr_stmt|;
name|trp
operator|->
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|trp
operator|==
operator|&
name|trapdebug
index|[
name|TRAPSIZE
index|]
condition|)
name|trp
operator|=
name|trapdebug
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_trap
operator|++
expr_stmt|;
name|type
operator|=
operator|(
name|causeReg
operator|&
name|MACH_CR_EXC_CODE
operator|)
operator|>>
name|MACH_CR_EXC_CODE_SHIFT
expr_stmt|;
if|if
condition|(
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
block|{
name|type
operator||=
name|T_USER
expr_stmt|;
name|syst
operator|=
name|p
operator|->
name|p_stime
expr_stmt|;
block|}
comment|/* 	 * Enable hardware interrupts if they were on before. 	 * We only respond to software interrupts when returning to user mode. 	 */
if|if
condition|(
name|statusReg
operator|&
name|MACH_SR_INT_ENA_PREV
condition|)
name|splx
argument_list|(
operator|(
name|statusReg
operator|&
name|MACH_HARD_INT_MASK
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_TLB_MOD
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|vadr
operator|<
literal|0
condition|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
specifier|register
name|unsigned
name|entry
decl_stmt|;
ifndef|#
directive|ifndef
name|ATTR
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
endif|#
directive|endif
name|pte
operator|=
name|kvtopte
argument_list|(
name|vadr
argument_list|)
expr_stmt|;
name|entry
operator|=
name|pte
operator|->
name|pt_entry
expr_stmt|;
if|if
condition|(
name|entry
operator|&
name|PG_RO
condition|)
block|{
comment|/* write to read only page in the kernel */
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
goto|goto
name|kernel_fault
goto|;
block|}
name|entry
operator||=
name|PG_M
expr_stmt|;
name|pte
operator|->
name|pt_entry
operator|=
name|entry
expr_stmt|;
name|vadr
operator|&=
name|PG_FRAME
expr_stmt|;
name|printf
argument_list|(
literal|"trap: TLBupdate hi %x lo %x i %x\n"
argument_list|,
name|vadr
argument_list|,
name|entry
argument_list|,
name|MachTLBUpdate
argument_list|(
name|vadr
argument_list|,
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|entry
operator|-
name|KERNBASE
argument_list|)
index|]
operator||=
name|PMAP_ATTR_MOD
expr_stmt|;
else|#
directive|else
name|pa
operator|=
name|entry
operator|&
name|PG_FRAME
expr_stmt|;
if|if
condition|(
operator|!
name|IS_VM_PHYSADDR
argument_list|(
name|pa
argument_list|)
condition|)
name|panic
argument_list|(
literal|"trap: kmod"
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|->
name|clean
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pc
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
case|case
name|T_TLB_MOD
operator|+
name|T_USER
case|:
block|{
name|pmap_hash_t
name|hp
decl_stmt|;
ifndef|#
directive|ifndef
name|ATTR
name|vm_offset_t
name|pa
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
specifier|extern
name|pmap_hash_t
name|zero_pmap_hash
decl_stmt|;
specifier|extern
name|pmap_t
name|cur_pmap
decl_stmt|;
if|if
condition|(
name|cur_pmap
operator|->
name|pm_hash
operator|==
name|zero_pmap_hash
condition|)
name|panic
argument_list|(
literal|"tlbmod"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|=
operator|&
operator|(
operator|(
name|pmap_hash_t
operator|)
name|PMAP_HASH_UADDR
operator|)
index|[
name|PMAP_HASH
argument_list|(
name|vadr
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|low
operator|&
name|PG_RO
condition|)
block|{
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
goto|goto
name|dofault
goto|;
block|}
name|hp
operator|->
name|low
operator||=
name|PG_M
expr_stmt|;
name|printf
argument_list|(
literal|"trap: TLBupdate hi %x lo %x i %x\n"
argument_list|,
name|hp
operator|->
name|high
argument_list|,
name|hp
operator|->
name|low
argument_list|,
name|MachTLBUpdate
argument_list|(
name|hp
operator|->
name|high
argument_list|,
name|hp
operator|->
name|low
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|hp
operator|->
name|low
operator|-
name|KERNBASE
argument_list|)
index|]
operator||=
name|PMAP_ATTR_MOD
expr_stmt|;
else|#
directive|else
name|pa
operator|=
name|hp
operator|->
name|low
operator|&
name|PG_FRAME
expr_stmt|;
if|if
condition|(
operator|!
name|IS_VM_PHYSADDR
argument_list|(
name|pa
argument_list|)
condition|)
name|panic
argument_list|(
literal|"trap: umod"
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|->
name|clean
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
return|return
operator|(
name|pc
operator|)
return|;
goto|goto
name|out
goto|;
block|}
case|case
name|T_TLB_LD_MISS
case|:
case|case
name|T_TLB_ST_MISS
case|:
name|ftype
operator|=
operator|(
name|type
operator|==
name|T_TLB_ST_MISS
operator|)
condition|?
name|VM_PROT_WRITE
else|:
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|vadr
operator|<
literal|0
condition|)
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|kernel_fault
label|:
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vadr
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_fault
argument_list|(
name|kernel_map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
return|return
operator|(
name|pc
operator|)
return|;
if|if
condition|(
name|i
operator|=
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
condition|)
block|{
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
goto|goto
name|err
goto|;
block|}
goto|goto
name|dofault
goto|;
case|case
name|T_TLB_LD_MISS
operator|+
name|T_USER
case|:
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
goto|goto
name|dofault
goto|;
case|case
name|T_TLB_ST_MISS
operator|+
name|T_USER
case|:
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
name|dofault
label|:
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
specifier|register
name|vm_map_t
name|map
init|=
operator|&
name|vm
operator|->
name|vm_map
decl_stmt|;
name|int
name|rv
decl_stmt|;
ifdef|#
directive|ifdef
name|X_KLUGE
if|if
condition|(
name|p
operator|->
name|p_pid
operator|==
name|UserMapPid
operator|&&
operator|(
name|va
operator|=
name|pmax_btop
argument_list|(
name|vadr
operator|-
name|USER_MAP_ADDR
argument_list|)
operator|)
operator|<
name|nUserMapPtes
condition|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
operator|&
name|UserMapPtes
index|[
name|va
index|]
expr_stmt|;
name|MachTLBWriteRandom
argument_list|(
operator|(
name|vadr
operator|&
name|PG_FRAME
operator|)
operator||
operator|(
name|vm
operator|->
name|vm_pmap
operator|.
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
argument_list|,
name|pte
operator|->
name|pt_entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
endif|#
directive|endif
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vadr
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"vm_fault(%x, %x, %x, 0) -> %x ADR %x PC %x RA %x\n"
argument_list|,
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|rv
argument_list|,
name|vadr
argument_list|,
name|pc
argument_list|,
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|?
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|19
index|]
else|:
name|p
operator|->
name|p_regs
index|[
name|RA
index|]
argument_list|)
expr_stmt|;
comment|/* XXX */
name|printf
argument_list|(
literal|"\tpid %d %s PC %x RA %x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_regs
index|[
name|PC
index|]
argument_list|,
name|p
operator|->
name|p_regs
index|[
name|RA
index|]
argument_list|)
expr_stmt|;
comment|/* XXX */
name|trapDump
argument_list|(
literal|"vm_fault"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If this was a stack access we keep track of the maximum 		 * accessed stack size.  Also, if vm_fault gets a protection 		 * failure it is due to accessing the stack region outside 		 * the current limit and we need to reflect that as an access 		 * error. 		 */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|va
operator|>=
name|vm
operator|->
name|vm_maxsaddr
condition|)
block|{
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|unsigned
name|nss
decl_stmt|;
name|nss
operator|=
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|USRSTACK
operator|-
operator|(
name|unsigned
operator|)
name|va
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nss
operator|>
name|vm
operator|->
name|vm_ssize
condition|)
name|vm
operator|->
name|vm_ssize
operator|=
name|nss
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
condition|)
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
return|return
operator|(
name|pc
operator|)
return|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|=
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
condition|)
block|{
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
goto|goto
name|err
goto|;
block|}
name|ucode
operator|=
name|vadr
expr_stmt|;
name|i
operator|=
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
expr_stmt|;
break|break;
block|}
case|case
name|T_ADDR_ERR_LD
operator|+
name|T_USER
case|:
comment|/* misaligned or kseg access */
if|if
condition|(
name|vadr
operator|==
name|KERNBASE
condition|)
block|{
struct|struct
name|args
block|{
name|int
name|i
index|[
literal|1
index|]
decl_stmt|;
block|}
name|args
struct|;
name|int
name|rval
index|[
literal|2
index|]
decl_stmt|;
comment|/* 			 * Assume a signal handler is trying to return 			 * (see sendsig() and sigreturn()). We have to 			 * pop the sigframe struct to get the address of 			 * the sigcontext. 			 */
name|args
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_regs
index|[
name|SP
index|]
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigreturn
argument_list|(
name|curproc
argument_list|,
operator|&
name|args
argument_list|,
name|rval
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* FALLTHROUGH */
case|case
name|T_ADDR_ERR_ST
operator|+
name|T_USER
case|:
comment|/* misaligned or kseg access */
case|case
name|T_BUS_ERR_IFETCH
operator|+
name|T_USER
case|:
comment|/* BERR asserted to cpu */
case|case
name|T_BUS_ERR_LD_ST
operator|+
name|T_USER
case|:
comment|/* BERR asserted to cpu */
name|i
operator|=
name|SIGSEGV
expr_stmt|;
break|break;
case|case
name|T_SYSCALL
operator|+
name|T_USER
case|:
block|{
specifier|register
name|int
modifier|*
name|locr0
init|=
name|p
operator|->
name|p_regs
decl_stmt|;
specifier|register
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|int
name|code
decl_stmt|,
name|numsys
decl_stmt|;
struct|struct
name|args
block|{
name|int
name|i
index|[
literal|8
index|]
decl_stmt|;
block|}
name|args
struct|;
name|int
name|rval
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sysent
modifier|*
name|systab
decl_stmt|;
specifier|extern
name|int
name|nsysent
decl_stmt|;
ifdef|#
directive|ifdef
name|ULTRIXCOMPAT
specifier|extern
name|struct
name|sysent
name|ultrixsysent
index|[]
decl_stmt|;
specifier|extern
name|int
name|ultrixnsysent
decl_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_syscall
operator|++
expr_stmt|;
comment|/* compute next PC after syscall instruction */
if|if
condition|(
operator|(
name|int
operator|)
name|causeReg
operator|<
literal|0
condition|)
name|locr0
index|[
name|PC
index|]
operator|=
name|MachEmulateBranch
argument_list|(
name|locr0
argument_list|,
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|locr0
index|[
name|PC
index|]
operator|+=
literal|4
expr_stmt|;
name|systab
operator|=
name|sysent
expr_stmt|;
name|numsys
operator|=
name|nsysent
expr_stmt|;
ifdef|#
directive|ifdef
name|ULTRIXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_ULTRIX
condition|)
block|{
name|systab
operator|=
name|ultrixsysent
expr_stmt|;
name|numsys
operator|=
name|ultrixnsysent
expr_stmt|;
block|}
endif|#
directive|endif
name|code
operator|=
name|locr0
index|[
name|V0
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
block|{
comment|/* indir */
name|code
operator|=
name|locr0
index|[
name|A0
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|numsys
condition|)
name|callp
operator|=
operator|&
name|systab
index|[
literal|0
index|]
expr_stmt|;
comment|/* indir (illegal) */
else|else
name|callp
operator|=
operator|&
name|systab
index|[
name|code
index|]
expr_stmt|;
name|i
operator|=
name|callp
operator|->
name|sy_narg
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|locr0
index|[
name|A1
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|locr0
index|[
name|A2
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|2
index|]
operator|=
name|locr0
index|[
name|A3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|3
condition|)
block|{
name|i
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|locr0
index|[
name|SP
index|]
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
operator|.
name|i
index|[
literal|3
index|]
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|i
operator|-
literal|3
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|locr0
index|[
name|V0
index|]
operator|=
name|i
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|code
operator|>=
name|numsys
condition|)
name|callp
operator|=
operator|&
name|systab
index|[
literal|0
index|]
expr_stmt|;
comment|/* indir (illegal) */
else|else
name|callp
operator|=
operator|&
name|systab
index|[
name|code
index|]
expr_stmt|;
name|i
operator|=
name|callp
operator|->
name|sy_narg
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|locr0
index|[
name|A0
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|locr0
index|[
name|A1
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|2
index|]
operator|=
name|locr0
index|[
name|A2
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|3
index|]
operator|=
name|locr0
index|[
name|A3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|4
condition|)
block|{
name|i
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|locr0
index|[
name|SP
index|]
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
operator|.
name|i
index|[
literal|4
index|]
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|i
operator|-
literal|4
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|locr0
index|[
name|V0
index|]
operator|=
name|i
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rval
index|[
literal|1
index|]
operator|=
name|locr0
index|[
name|V1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|trp
operator|==
name|trapdebug
condition|)
name|trapdebug
index|[
name|TRAPSIZE
operator|-
literal|1
index|]
operator|.
name|code
operator|=
name|code
expr_stmt|;
else|else
name|trp
index|[
operator|-
literal|1
index|]
operator|.
name|code
operator|=
name|code
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|args
argument_list|,
name|rval
argument_list|)
expr_stmt|;
comment|/* 		 * Reinitialize proc pointer `p' as it may be different 		 * if this is a child returning from fork syscall. 		 */
name|p
operator|=
name|curproc
expr_stmt|;
name|locr0
operator|=
name|p
operator|->
name|p_regs
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|trp
operator|->
name|status
operator|=
name|statusReg
expr_stmt|;
name|trp
operator|->
name|cause
operator|=
name|causeReg
expr_stmt|;
name|trp
operator|->
name|vadr
operator|=
name|locr0
index|[
name|SP
index|]
expr_stmt|;
name|trp
operator|->
name|pc
operator|=
name|locr0
index|[
name|PC
index|]
expr_stmt|;
name|trp
operator|->
name|ra
operator|=
name|locr0
index|[
name|RA
index|]
expr_stmt|;
name|trp
operator|->
name|code
operator|=
operator|-
name|code
expr_stmt|;
if|if
condition|(
operator|++
name|trp
operator|==
operator|&
name|trapdebug
index|[
name|TRAPSIZE
index|]
condition|)
name|trp
operator|=
name|trapdebug
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
name|ERESTART
condition|)
name|locr0
index|[
name|PC
index|]
operator|=
name|pc
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|!=
name|EJUSTRETURN
condition|)
block|{
if|if
condition|(
name|i
condition|)
block|{
name|locr0
index|[
name|V0
index|]
operator|=
name|i
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|locr0
index|[
name|V0
index|]
operator|=
name|rval
index|[
literal|0
index|]
expr_stmt|;
name|locr0
index|[
name|V1
index|]
operator|=
name|rval
index|[
literal|1
index|]
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* else if (i == EJUSTRETURN) */
comment|/* nothing to do */
name|done
label|:
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|i
argument_list|,
name|rval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|out
goto|;
block|}
case|case
name|T_BREAK
operator|+
name|T_USER
case|:
block|{
specifier|register
name|unsigned
name|va
decl_stmt|,
name|instr
decl_stmt|;
comment|/* compute address of break instruction */
name|va
operator|=
name|pc
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|causeReg
operator|<
literal|0
condition|)
name|va
operator|+=
literal|4
expr_stmt|;
comment|/* read break instruction */
name|instr
operator|=
name|fuiword
argument_list|(
name|va
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KADB
if|if
condition|(
name|instr
operator|==
name|MACH_BREAK_BRKPT
operator|||
name|instr
operator|==
name|MACH_BREAK_SSTEP
condition|)
goto|goto
name|err
goto|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|!=
name|va
operator|||
name|instr
operator|!=
name|MACH_BREAK_SSTEP
condition|)
block|{
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
block|}
comment|/* restore original instruction and clear BP  */
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|vm_offset_t
name|sa
decl_stmt|,
name|ea
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sa
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|)
expr_stmt|;
name|ea
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
case|case
name|T_RES_INST
operator|+
name|T_USER
case|:
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_COP_UNUSABLE
operator|+
name|T_USER
case|:
if|if
condition|(
operator|(
name|causeReg
operator|&
name|MACH_CR_COP_ERR
operator|)
operator|!=
literal|0x10000000
condition|)
block|{
name|i
operator|=
name|SIGILL
expr_stmt|;
comment|/* only FPU instructions allowed */
break|break;
block|}
name|MachSwitchFPState
argument_list|(
name|machFPCurProcPtr
argument_list|,
name|p
operator|->
name|p_regs
argument_list|)
expr_stmt|;
name|machFPCurProcPtr
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|p_regs
index|[
name|PS
index|]
operator||=
name|MACH_SR_COP_1_BIT
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator||=
name|MDP_FPUSED
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|T_OVFLOW
operator|+
name|T_USER
case|:
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_ADDR_ERR_LD
case|:
comment|/* misaligned access */
case|case
name|T_ADDR_ERR_ST
case|:
comment|/* misaligned access */
case|case
name|T_BUS_ERR_LD_ST
case|:
comment|/* BERR asserted to cpu */
if|if
condition|(
name|i
operator|=
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
condition|)
block|{
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
name|err
label|:
ifdef|#
directive|ifdef
name|KADB
block|{
specifier|extern
name|struct
name|pcb
name|kdbpcb
decl_stmt|;
if|if
condition|(
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
name|kdbpcb
operator|=
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
expr_stmt|;
else|else
block|{
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|ZERO
index|]
operator|=
literal|0
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|AST
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|2
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|V0
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|3
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|V1
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|4
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A0
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|5
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A1
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|6
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A2
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|7
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A3
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|8
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T0
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|9
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T1
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|10
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T2
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|11
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T3
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|12
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T4
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|13
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T5
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|14
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T6
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|15
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T7
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|16
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T8
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|17
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T9
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|18
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|RA
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|19
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|MULLO
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|21
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|MULHI
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|22
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|PC
index|]
operator|=
name|pc
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|SR
index|]
operator|=
name|statusReg
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F0
index|]
argument_list|,
literal|33
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kdb
argument_list|(
name|causeReg
argument_list|,
name|vadr
argument_list|,
name|p
argument_list|,
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|PC
index|]
operator|)
return|;
block|}
endif|#
directive|endif
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"trap: pid %d %s sig %d adr %x pc %x ra %x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|i
argument_list|,
name|vadr
argument_list|,
name|pc
argument_list|,
name|p
operator|->
name|p_regs
index|[
name|RA
index|]
argument_list|)
expr_stmt|;
comment|/* XXX */
name|trapsignal
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * Note: we should only get here if returning to user mode. 	 */
name|astpending
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_pri
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
if|if
condition|(
name|want_resched
condition|)
block|{
name|int
name|s
decl_stmt|;
comment|/* 		 * Since we are curproc, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we setrq ourselves but before we 		 * swtch()'ed, we might not be on the queue indicated by 		 * our priority. 		 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setrq
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|swtch
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_stats
operator|->
name|p_prof
operator|.
name|pr_scale
condition|)
block|{
name|int
name|ticks
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|&
name|p
operator|->
name|p_stime
decl_stmt|;
name|ticks
operator|=
operator|(
operator|(
name|tv
operator|->
name|tv_sec
operator|-
name|syst
operator|.
name|tv_sec
operator|)
operator|*
literal|1000
operator|+
operator|(
name|tv
operator|->
name|tv_usec
operator|-
name|syst
operator|.
name|tv_usec
operator|)
operator|/
literal|1000
operator|)
operator|/
operator|(
name|tick
operator|/
literal|1000
operator|)
expr_stmt|;
if|if
condition|(
name|ticks
condition|)
name|addupc
argument_list|(
name|pc
argument_list|,
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_prof
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
block|}
name|curpri
operator|=
name|p
operator|->
name|p_pri
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DS5000
end_ifdef

begin_decl_stmt
name|struct
name|intr_tab
name|intr_tab
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|temp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX ULTRIX compiler bug with -O */
end_comment

begin_comment
comment|/*  * Handle an interrupt.  * Called from MachKernIntr() or MachUserIntr()  * Note: curproc might be NULL.  */
end_comment

begin_macro
name|interrupt
argument_list|(
argument|statusReg
argument_list|,
argument|causeReg
argument_list|,
argument|pc
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|statusReg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status register at time of the exception */
end_comment

begin_decl_stmt
name|unsigned
name|causeReg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cause register at time of exception */
end_comment

begin_decl_stmt
name|unsigned
name|pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program counter where to continue */
end_comment

begin_block
block|{
specifier|register
name|unsigned
name|mask
decl_stmt|;
name|clockframe
name|cf
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|trp
operator|->
name|status
operator|=
name|statusReg
expr_stmt|;
name|trp
operator|->
name|cause
operator|=
name|causeReg
expr_stmt|;
name|trp
operator|->
name|vadr
operator|=
literal|0
expr_stmt|;
name|trp
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
name|trp
operator|->
name|ra
operator|=
literal|0
expr_stmt|;
name|trp
operator|->
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|trp
operator|==
operator|&
name|trapdebug
index|[
name|TRAPSIZE
index|]
condition|)
name|trp
operator|=
name|trapdebug
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_intr
operator|++
expr_stmt|;
name|mask
operator|=
name|causeReg
operator|&
name|statusReg
expr_stmt|;
comment|/* pending interrupts& enable mask */
ifdef|#
directive|ifdef
name|DS3100
comment|/* handle clock interrupts ASAP */
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_3
condition|)
block|{
specifier|register
specifier|volatile
name|struct
name|chiptime
modifier|*
name|c
init|=
operator|(
specifier|volatile
expr|struct
name|chiptime
operator|*
operator|)
name|MACH_CLOCK_ADDR
decl_stmt|;
name|temp
operator|=
name|c
operator|->
name|regc
expr_stmt|;
comment|/* clear interrupt bits */
name|cf
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|cf
operator|.
name|ps
operator|=
name|statusReg
expr_stmt|;
name|hardclock
argument_list|(
name|cf
argument_list|)
expr_stmt|;
name|causeReg
operator|&=
operator|~
name|MACH_INT_MASK_3
expr_stmt|;
comment|/* reenable clock interrupts */
block|}
comment|/* 	 * Enable hardware interrupts which were enabled but not pending. 	 * We only respond to software interrupts when returning to spl0. 	 */
name|splx
argument_list|(
operator|(
name|statusReg
operator|&
operator|~
name|causeReg
operator|&
name|MACH_HARD_INT_MASK
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_0
condition|)
name|siiintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_1
condition|)
name|leintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_2
condition|)
name|dcintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_4
condition|)
name|MemErrorInterrupt
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DS3100 */
ifdef|#
directive|ifdef
name|DS5000
comment|/* handle clock interrupts ASAP */
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_1
condition|)
block|{
specifier|register
specifier|volatile
name|struct
name|chiptime
modifier|*
name|c
init|=
operator|(
specifier|volatile
expr|struct
name|chiptime
operator|*
operator|)
name|MACH_CLOCK_ADDR
decl_stmt|;
specifier|register
name|unsigned
name|csr
decl_stmt|;
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
name|csr
operator|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|MACH_SYS_CSR_ADDR
expr_stmt|;
if|if
condition|(
operator|(
name|csr
operator|&
name|MACH_CSR_PSWARN
operator|)
operator|&&
operator|!
name|warned
condition|)
block|{
name|warned
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"WARNING: power supply is overheating!\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warned
operator|&&
operator|!
operator|(
name|csr
operator|&
name|MACH_CSR_PSWARN
operator|)
condition|)
block|{
name|warned
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"WARNING: power supply is OK again\n"
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|c
operator|->
name|regc
expr_stmt|;
comment|/* clear interrupt bits */
name|cf
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|cf
operator|.
name|ps
operator|=
name|statusReg
expr_stmt|;
name|hardclock
argument_list|(
name|cf
argument_list|)
expr_stmt|;
name|causeReg
operator|&=
operator|~
name|MACH_INT_MASK_1
expr_stmt|;
comment|/* reenable clock interrupts */
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_0
condition|)
block|{
specifier|register
name|unsigned
name|csr
decl_stmt|;
specifier|register
name|unsigned
name|i
decl_stmt|,
name|m
decl_stmt|;
name|csr
operator|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|MACH_SYS_CSR_ADDR
expr_stmt|;
name|m
operator|=
name|csr
operator|&
operator|(
name|csr
operator|>>
name|MACH_CSR_IOINTEN_SHIFT
operator|)
operator|&
name|MACH_CSR_IOINT_MASK
expr_stmt|;
if|#
directive|if
literal|0
block|*(unsigned *)MACH_SYS_CSR_ADDR = 			(csr& ~(MACH_CSR_MBZ | 0xFF)) | 			(m<< MACH_CSR_IOINTEN_SHIFT);
endif|#
directive|endif
comment|/* 		 * Enable hardware interrupts which were enabled but not 		 * pending. We only respond to software interrupts when 		 * returning to spl0. 		 */
name|splx
argument_list|(
operator|(
name|statusReg
operator|&
operator|~
name|causeReg
operator|&
name|MACH_HARD_INT_MASK
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|m
condition|;
name|i
operator|++
operator|,
name|m
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|m
operator|&
literal|1
operator|)
condition|)
continue|continue;
if|if
condition|(
name|intr_tab
index|[
name|i
index|]
operator|.
name|func
condition|)
operator|(
operator|*
name|intr_tab
index|[
name|i
index|]
operator|.
name|func
operator|)
operator|(
name|intr_tab
index|[
name|i
index|]
operator|.
name|unit
operator|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"spurious interrupt %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|*(unsigned *)MACH_SYS_CSR_ADDR = 			csr& ~(MACH_CSR_MBZ | 0xFF);
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * Enable hardware interrupts which were enabled but not 		 * pending. We only respond to software interrupts when 		 * returning to spl0. 		 */
name|splx
argument_list|(
operator|(
name|statusReg
operator|&
operator|~
name|causeReg
operator|&
name|MACH_HARD_INT_MASK
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_3
condition|)
name|MemErrorInterrupt
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DS5000 */
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_5
condition|)
block|{
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|trapDump
argument_list|(
literal|"fpintr"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"FPU interrupt: PC %x CR %x SR %x\n"
argument_list|,
name|pc
argument_list|,
name|causeReg
argument_list|,
name|statusReg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|MachFPInterrupt
argument_list|(
name|statusReg
argument_list|,
name|causeReg
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_SOFT_INT_MASK_0
condition|)
block|{
name|clockframe
name|cf
decl_stmt|;
name|clearsoftclock
argument_list|()
expr_stmt|;
name|cf
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|cf
operator|.
name|ps
operator|=
name|statusReg
expr_stmt|;
name|softclock
argument_list|(
name|cf
argument_list|)
expr_stmt|;
block|}
comment|/* process network interrupt if we trapped or will very soon */
if|if
condition|(
operator|(
name|mask
operator|&
name|MACH_SOFT_INT_MASK_1
operator|)
operator|||
name|netisr
operator|&&
operator|(
name|statusReg
operator|&
name|MACH_SOFT_INT_MASK_1
operator|)
condition|)
block|{
name|clearsoftnet
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|netisr
operator|&
operator|(
literal|1
operator|<<
name|NETISR_ARP
operator|)
condition|)
block|{
name|netisr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|NETISR_ARP
operator|)
expr_stmt|;
name|arpintr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|netisr
operator|&
operator|(
literal|1
operator|<<
name|NETISR_IP
operator|)
condition|)
block|{
name|netisr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|NETISR_IP
operator|)
expr_stmt|;
name|ipintr
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
if|if
condition|(
name|netisr
operator|&
operator|(
literal|1
operator|<<
name|NETISR_NS
operator|)
condition|)
block|{
name|netisr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|NETISR_NS
operator|)
expr_stmt|;
name|nsintr
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISO
if|if
condition|(
name|netisr
operator|&
operator|(
literal|1
operator|<<
name|NETISR_ISO
operator|)
condition|)
block|{
name|netisr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|NETISR_ISO
operator|)
expr_stmt|;
name|clnlintr
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_block

begin_comment
comment|/*  * This is called from MachUserIntr() if astpending is set.  * This is very similar to the tail of trap().  */
end_comment

begin_macro
name|softintr
argument_list|(
argument|statusReg
argument_list|,
argument|pc
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|statusReg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status register at time of the exception */
end_comment

begin_decl_stmt
name|unsigned
name|pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program counter where to continue */
end_comment

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|astpending
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_pri
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
if|if
condition|(
name|want_resched
condition|)
block|{
name|int
name|s
decl_stmt|;
comment|/* 		 * Since we are curproc, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we setrq ourselves but before we 		 * swtch()'ed, we might not be on the queue indicated by 		 * our priority. 		 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setrq
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|swtch
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|curpri
operator|=
name|p
operator|->
name|p_pri
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|trapDump
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"trapDump(%s)\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRAPSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trp
operator|==
name|trapdebug
condition|)
name|trp
operator|=
operator|&
name|trapdebug
index|[
name|TRAPSIZE
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|trp
operator|--
expr_stmt|;
if|if
condition|(
name|trp
operator|->
name|cause
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"%s: ADR %x PC %x CR %x SR %x\n"
argument_list|,
name|trap_type
index|[
operator|(
name|trp
operator|->
name|cause
operator|&
name|MACH_CR_EXC_CODE
operator|)
operator|>>
name|MACH_CR_EXC_CODE_SHIFT
index|]
argument_list|,
name|trp
operator|->
name|vadr
argument_list|,
name|trp
operator|->
name|pc
argument_list|,
name|trp
operator|->
name|cause
argument_list|,
name|trp
operator|->
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   RA %x code %d\n"
argument_list|,
name|trp
operator|->
name|ra
argument_list|,
name|trp
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|trapdebug
argument_list|,
sizeof|sizeof
argument_list|(
name|trapdebug
argument_list|)
argument_list|)
expr_stmt|;
name|trp
operator|=
name|trapdebug
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|X_KLUGE
end_ifdef

begin_comment
comment|/*  * This is a kludge to allow X windows to work.  */
end_comment

begin_function
name|caddr_t
name|vmUserMap
parameter_list|(
name|size
parameter_list|,
name|pa
parameter_list|)
name|int
name|size
decl_stmt|;
name|unsigned
name|pa
decl_stmt|;
block|{
specifier|register
name|caddr_t
name|v
decl_stmt|;
name|unsigned
name|off
decl_stmt|,
name|entry
decl_stmt|;
if|if
condition|(
name|nUserMapPtes
operator|==
literal|0
condition|)
name|UserMapPid
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
elseif|else
if|if
condition|(
name|UserMapPid
operator|!=
name|curproc
operator|->
name|p_pid
condition|)
return|return
operator|(
operator|(
name|caddr_t
operator|)
literal|0
operator|)
return|;
name|off
operator|=
name|pa
operator|&
name|PGOFSET
expr_stmt|;
name|size
operator|=
name|btoc
argument_list|(
name|off
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|nUserMapPtes
operator|+
name|size
operator|>
name|NPTES
condition|)
return|return
operator|(
operator|(
name|caddr_t
operator|)
literal|0
operator|)
return|;
name|v
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|USER_MAP_ADDR
operator|+
name|pmax_ptob
argument_list|(
name|nUserMapPtes
argument_list|)
operator|+
name|off
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|pa
operator|&
literal|0x9ffff000
operator|)
operator||
name|PG_V
operator||
name|PG_M
expr_stmt|;
if|if
condition|(
name|pa
operator|>=
name|MACH_UNCACHED_MEMORY_ADDR
condition|)
name|entry
operator||=
name|PG_N
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|UserMapPtes
index|[
name|nUserMapPtes
index|]
operator|.
name|pt_entry
operator|=
name|entry
expr_stmt|;
name|entry
operator|+=
name|NBPG
expr_stmt|;
name|nUserMapPtes
operator|++
expr_stmt|;
name|size
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_macro
name|vmUserUnmap
argument_list|()
end_macro

begin_block
block|{
name|int
name|id
decl_stmt|;
name|nUserMapPtes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|UserMapPid
operator|==
name|curproc
operator|->
name|p_pid
condition|)
block|{
name|id
operator|=
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|.
name|pm_tlbpid
expr_stmt|;
if|if
condition|(
name|id
operator|>=
literal|0
condition|)
name|MachTLBFlushPID
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|UserMapPid
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MemErrorInterrupt --  *  *	Handler an interrupt for the control register.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|MemErrorInterrupt
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DS3100
specifier|volatile
name|u_short
modifier|*
name|sysCSRPtr
init|=
operator|(
name|u_short
operator|*
operator|)
name|MACH_SYS_CSR_ADDR
decl_stmt|;
name|u_short
name|csr
decl_stmt|;
name|csr
operator|=
operator|*
name|sysCSRPtr
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|MACH_CSR_MEM_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"Memory error at 0x%x\n"
argument_list|,
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|MACH_WRITE_ERROR_ADDR
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Mem error interrupt"
argument_list|)
expr_stmt|;
block|}
operator|*
name|sysCSRPtr
operator|=
operator|(
name|csr
operator|&
operator|~
name|MACH_CSR_MBZ
operator|)
operator||
literal|0xff
expr_stmt|;
endif|#
directive|endif
comment|/* DS3100 */
ifdef|#
directive|ifdef
name|DS5000
name|printf
argument_list|(
literal|"erradr %x\n"
argument_list|,
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|MACH_ERROR_ADDR
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|MACH_ERROR_ADDR
operator|=
literal|0
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DS5000 */
block|}
end_function

begin_comment
comment|/*  * Return the resulting PC as if the branch was executed.  */
end_comment

begin_function
name|unsigned
name|MachEmulateBranch
parameter_list|(
name|regsPtr
parameter_list|,
name|instPC
parameter_list|,
name|fpcCSR
parameter_list|,
name|allowNonBranch
parameter_list|)
name|unsigned
modifier|*
name|regsPtr
decl_stmt|;
name|unsigned
name|instPC
decl_stmt|;
name|unsigned
name|fpcCSR
decl_stmt|;
name|int
name|allowNonBranch
decl_stmt|;
block|{
name|InstFmt
name|inst
decl_stmt|;
name|unsigned
name|retAddr
decl_stmt|;
name|int
name|condition
decl_stmt|;
specifier|extern
name|unsigned
name|GetBranchDest
parameter_list|()
function_decl|;
if|#
directive|if
literal|0
block|printf("regsPtr=%x PC=%x Inst=%x fpcCsr=%x\n", regsPtr, instPC, 		*instPC, fpcCSR);
endif|#
directive|endif
name|inst
operator|=
operator|*
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|JType
operator|.
name|op
condition|)
block|{
case|case
name|OP_SPECIAL
case|:
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|RType
operator|.
name|func
condition|)
block|{
case|case
name|OP_JR
case|:
case|case
name|OP_JALR
case|:
name|retAddr
operator|=
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|allowNonBranch
condition|)
name|panic
argument_list|(
literal|"MachEmulateBranch: Non-branch"
argument_list|)
expr_stmt|;
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OP_BCOND
case|:
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|IType
operator|.
name|rt
condition|)
block|{
case|case
name|OP_BLTZ
case|:
case|case
name|OP_BLTZAL
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|<
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BGEZAL
case|:
case|case
name|OP_BGEZ
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|>=
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"MachEmulateBranch: Bad branch cond"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_J
case|:
case|case
name|OP_JAL
case|:
name|retAddr
operator|=
operator|(
name|inst
operator|.
name|JType
operator|.
name|target
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|unsigned
operator|)
name|instPC
operator|&
literal|0xF0000000
operator|)
expr_stmt|;
break|break;
case|case
name|OP_BEQ
case|:
if|if
condition|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
operator|==
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BNE
case|:
if|if
condition|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
operator|!=
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BLEZ
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|<=
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BGTZ
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|>
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_COP1
case|:
switch|switch
condition|(
name|inst
operator|.
name|RType
operator|.
name|rs
condition|)
block|{
case|case
name|OP_BCx
case|:
case|case
name|OP_BCy
case|:
if|if
condition|(
operator|(
name|inst
operator|.
name|RType
operator|.
name|rt
operator|&
name|COPz_BC_TF_MASK
operator|)
operator|==
name|COPz_BC_TRUE
condition|)
name|condition
operator|=
name|fpcCSR
operator|&
name|MACH_FPC_COND_BIT
expr_stmt|;
else|else
name|condition
operator|=
operator|!
operator|(
name|fpcCSR
operator|&
name|MACH_FPC_COND_BIT
operator|)
expr_stmt|;
if|if
condition|(
name|condition
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|allowNonBranch
condition|)
name|panic
argument_list|(
literal|"MachEmulateBranch: Bad coproc branch instruction"
argument_list|)
expr_stmt|;
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|allowNonBranch
condition|)
name|panic
argument_list|(
literal|"MachEmulateBranch: Non-branch instruction"
argument_list|)
expr_stmt|;
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("Target addr=%x\n", retAddr);
endif|#
directive|endif
return|return
operator|(
name|retAddr
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|GetBranchDest
parameter_list|(
name|InstPtr
parameter_list|)
name|InstFmt
modifier|*
name|InstPtr
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|unsigned
operator|)
name|InstPtr
operator|+
literal|4
operator|+
operator|(
operator|(
name|short
operator|)
name|InstPtr
operator|->
name|IType
operator|.
name|imm
operator|<<
literal|2
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called by procxmt() to single step one instruction.  * We do this by storing a break instruction after the current instruction,  * resuming execution, and then restoring the old instruction.  */
end_comment

begin_expr_stmt
name|cpu_singlestep
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|va
decl_stmt|;
specifier|register
name|int
modifier|*
name|locr0
init|=
name|p
operator|->
name|p_regs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* compute next address after current location */
name|va
operator|=
name|MachEmulateBranch
argument_list|(
name|locr0
argument_list|,
name|locr0
index|[
name|PC
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|||
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|==
name|va
operator|||
operator|!
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
literal|4
argument_list|,
name|B_READ
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"SS %s (%d): breakpoint already set at %x (va %x)\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|=
name|va
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
operator|=
name|fuiword
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|MACH_BREAK_SSTEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|vm_offset_t
name|sa
decl_stmt|,
name|ea
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sa
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|)
expr_stmt|;
name|ea
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|MACH_BREAK_SSTEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|printf
argument_list|(
literal|"SS %s (%d): breakpoint set at %x: %x (pc %x)\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
argument_list|,
name|locr0
index|[
name|PC
index|]
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

