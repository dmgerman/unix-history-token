begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and Ralph Campbell.  *  * %sccs.include.redist.c%  *  *	@(#)pmap.c	7.13 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  *	Manages physical address maps.  *  *	In addition to hardware address maps, this  *	module is called upon to provide software-use-only  *	maps which may or may not be stored in the same  *	form as hardware maps.  These pseudo-maps are  *	used to store intermediate results from copy  *	operations to and from address spaces.  *  *	Since the information managed by this module is  *	also stored by the logical address mapping module,  *	this module may throw away valid virtual-to-physical  *	mappings at almost any time.  However, invalidations  *	of virtual-to-physical mappings must be done as  *	requested.  *  *	In order to cope with hardware architectures which  *	make virtual-to-physical map invalidates expensive,  *	this module may delay invalidate or reduced protection  *	operations until such time as they are actually  *	necessary.  This module is given full information as  *	to which processors are currently using which maps,  *	and to when physical maps must be made correct.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<machine/machConst.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_comment
comment|/*  * For each vm_page_t, there is a list of all currently valid virtual  * mappings of that page.  An entry is a pv_entry_t, the list is pv_table.  * XXX really should do this as a part of the higher level code.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pv_entry
block|{
name|struct
name|pv_entry
modifier|*
name|pv_next
decl_stmt|;
comment|/* next pv_entry */
name|struct
name|pmap
modifier|*
name|pv_pmap
decl_stmt|;
comment|/* pmap where mapping lies */
name|vm_offset_t
name|pv_va
decl_stmt|;
comment|/* virtual address for mapping */
block|}
typedef|*
name|pv_entry_t
typedef|;
end_typedef

begin_decl_stmt
name|pv_entry_t
name|pv_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of entries, one per page */
end_comment

begin_function_decl
specifier|extern
name|void
name|pmap_remove_pv
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|pa_index
parameter_list|(
name|pa
parameter_list|)
value|atop((pa) - first_phys_addr)
end_define

begin_define
define|#
directive|define
name|pa_to_pvh
parameter_list|(
name|pa
parameter_list|)
value|(&pv_table[pa_index(pa)])
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_struct
struct|struct
block|{
name|int
name|kernel
decl_stmt|;
comment|/* entering kernel mapping */
name|int
name|user
decl_stmt|;
comment|/* entering user mapping */
name|int
name|ptpneeded
decl_stmt|;
comment|/* needed to allocate a PT page */
name|int
name|pwchange
decl_stmt|;
comment|/* no mapping change, just wiring or protection */
name|int
name|wchange
decl_stmt|;
comment|/* no mapping change, just wiring */
name|int
name|mchange
decl_stmt|;
comment|/* was mapped but mapping to different page */
name|int
name|managed
decl_stmt|;
comment|/* a managed page */
name|int
name|firstpv
decl_stmt|;
comment|/* first mapping for this PA */
name|int
name|secondpv
decl_stmt|;
comment|/* second mapping for this PA */
name|int
name|ci
decl_stmt|;
comment|/* cache inhibited */
name|int
name|unmanaged
decl_stmt|;
comment|/* not a managed page */
name|int
name|flushes
decl_stmt|;
comment|/* cache flushes */
name|int
name|cachehit
decl_stmt|;
comment|/* new entry forced valid entry out */
block|}
name|enter_stats
struct|;
end_struct

begin_struct
struct|struct
block|{
name|int
name|calls
decl_stmt|;
name|int
name|removes
decl_stmt|;
name|int
name|flushes
decl_stmt|;
name|int
name|pidflushes
decl_stmt|;
comment|/* HW pid stolen */
name|int
name|pvfirst
decl_stmt|;
name|int
name|pvsearch
decl_stmt|;
block|}
name|remove_stats
struct|;
end_struct

begin_decl_stmt
name|int
name|pmapdebug
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PDB_FOLLOW
value|0x0001
end_define

begin_define
define|#
directive|define
name|PDB_INIT
value|0x0002
end_define

begin_define
define|#
directive|define
name|PDB_ENTER
value|0x0004
end_define

begin_define
define|#
directive|define
name|PDB_REMOVE
value|0x0008
end_define

begin_define
define|#
directive|define
name|PDB_CREATE
value|0x0010
end_define

begin_define
define|#
directive|define
name|PDB_PTPAGE
value|0x0020
end_define

begin_define
define|#
directive|define
name|PDB_CACHE
value|0x0040
end_define

begin_define
define|#
directive|define
name|PDB_BITS
value|0x0080
end_define

begin_define
define|#
directive|define
name|PDB_COLLECT
value|0x0100
end_define

begin_define
define|#
directive|define
name|PDB_PROTECT
value|0x0200
end_define

begin_define
define|#
directive|define
name|PDB_TLBPID
value|0x0400
end_define

begin_define
define|#
directive|define
name|PDB_PARANOIA
value|0x2000
end_define

begin_define
define|#
directive|define
name|PDB_WIRING
value|0x4000
end_define

begin_define
define|#
directive|define
name|PDB_PVDUMP
value|0x8000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_decl_stmt
name|u_int
name|whichpids
index|[
literal|2
index|]
init|=
block|{
comment|/* bit mask of hardware PID's in use */
literal|3
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pmap_t
name|cur_pmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current pmap mapped in hardware */
end_comment

begin_decl_stmt
name|vm_offset_t
name|avail_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of first available physical page */
end_comment

begin_decl_stmt
name|vm_offset_t
name|avail_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of last available physical page */
end_comment

begin_decl_stmt
name|vm_size_t
name|mem_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* memory size in bytes */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss)*/
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
name|int
name|pmaxpagesperpage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PAGE_SIZE / NBPG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ATTR
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|pmap_attributes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference and modify bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|pmap_hash_t
name|zero_pmap_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* empty TLB hash table for init */
end_comment

begin_comment
comment|/*  *	Bootstrap the system enough to run with virtual memory.  */
end_comment

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|firstaddr
parameter_list|)
name|vm_offset_t
name|firstaddr
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|start
init|=
name|firstaddr
decl_stmt|;
specifier|extern
name|int
name|maxmem
decl_stmt|,
name|physmem
decl_stmt|;
comment|/* 	 * Allocate a TLB hash table for the kernel. 	 * This could be a KSEG0 address and thus save TLB entries but 	 * its faster and simpler in assembly language to have a 	 * fixed address that can be accessed with a 16 bit signed offset. 	 * Note: the kernel pm_hash field is null, user pm_hash fields are 	 * either the table or zero_pmap_hash. 	 */
name|kernel_pmap_store
operator|.
name|pm_hash
operator|=
operator|(
name|pmap_hash_t
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_HASH_KPAGES
condition|;
name|i
operator|++
control|)
block|{
name|MachTLBWriteIndexed
argument_list|(
name|i
operator|+
name|UPAGES
operator|+
name|PMAP_HASH_UPAGES
argument_list|,
name|PMAP_HASH_KADDR
operator|+
operator|(
name|i
operator|<<
name|PGSHIFT
operator|)
argument_list|,
name|firstaddr
operator||
name|PG_V
operator||
name|PG_M
operator||
name|PG_G
argument_list|)
expr_stmt|;
name|firstaddr
operator|+=
name|NBPG
expr_stmt|;
block|}
comment|/* 	 * Allocate an empty TLB hash table for initial pmap's. 	 */
name|zero_pmap_hash
operator|=
operator|(
name|pmap_hash_t
operator|)
name|MACH_PHYS_TO_CACHED
argument_list|(
name|firstaddr
argument_list|)
expr_stmt|;
comment|/* init proc[0]'s pmap hash table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_HASH_UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|kernel_pmap_store
operator|.
name|pm_hash_ptes
index|[
name|i
index|]
operator|=
name|firstaddr
operator||
name|PG_V
operator||
name|PG_RO
expr_stmt|;
name|MachTLBWriteIndexed
argument_list|(
name|i
operator|+
name|UPAGES
argument_list|,
operator|(
name|PMAP_HASH_UADDR
operator|+
operator|(
name|i
operator|<<
name|PGSHIFT
operator|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
argument_list|,
name|kernel_pmap_store
operator|.
name|pm_hash_ptes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|firstaddr
operator|+=
name|NBPG
expr_stmt|;
block|}
comment|/* 	 * Allocate memory for pv_table. 	 * This will allocate more entries than we really need. 	 * We should do this in pmap_init when we know the actual 	 * phys_start and phys_end but its better to use phys addresses 	 * rather than kernel virtual addresses mapped through the TLB. 	 */
name|i
operator|=
operator|(
name|maxmem
operator|-
name|pmax_btop
argument_list|(
name|firstaddr
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
expr_stmt|;
name|i
operator|=
name|pmax_round_page
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|pv_table
operator|=
operator|(
name|pv_entry_t
operator|)
name|MACH_PHYS_TO_CACHED
argument_list|(
name|firstaddr
argument_list|)
expr_stmt|;
name|firstaddr
operator|+=
name|i
expr_stmt|;
comment|/* 	 * Clear allocated memory. 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|MACH_PHYS_TO_CACHED
argument_list|(
name|start
argument_list|)
argument_list|,
name|firstaddr
operator|-
name|start
argument_list|)
expr_stmt|;
name|avail_start
operator|=
name|firstaddr
expr_stmt|;
name|avail_end
operator|=
name|pmax_ptob
argument_list|(
name|maxmem
argument_list|)
expr_stmt|;
name|mem_size
operator|=
name|avail_end
operator|-
name|avail_start
expr_stmt|;
name|virtual_avail
operator|=
name|VM_MIN_KERNEL_ADDRESS
expr_stmt|;
name|virtual_end
operator|=
name|VM_MIN_KERNEL_ADDRESS
operator|+
name|PMAP_HASH_KPAGES
operator|*
name|NPTEPG
operator|*
name|NBPG
expr_stmt|;
comment|/* XXX need to decide how to set cnt.v_page_size */
name|pmaxpagesperpage
operator|=
literal|1
expr_stmt|;
name|cur_pmap
operator|=
operator|&
name|kernel_pmap_store
expr_stmt|;
name|simple_lock_init
argument_list|(
operator|&
name|kernel_pmap_store
operator|.
name|pm_lock
argument_list|)
expr_stmt|;
name|kernel_pmap_store
operator|.
name|pm_count
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Bootstrap memory allocator. This function allows for early dynamic  * memory allocation until the virtual memory system has been bootstrapped.  * After that point, either kmem_alloc or malloc should be used. This  * function works by stealing pages from the (to be) managed page pool,  * stealing virtual address space, then mapping the pages and zeroing them.  *  * It should be used from pmap_bootstrap till vm_page_startup, afterwards  * it cannot be used, and will generate a panic if tried. Note that this  * memory will never be freed, and in essence it is wired down.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_bootstrap_alloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|vm_offset_t
name|val
decl_stmt|;
specifier|extern
name|boolean_t
name|vm_page_startup_initialized
decl_stmt|;
if|if
condition|(
name|vm_page_startup_initialized
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap_alloc: called after startup initialized"
argument_list|)
expr_stmt|;
name|val
operator|=
name|MACH_PHYS_TO_CACHED
argument_list|(
name|avail_start
argument_list|)
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|avail_start
operator|+=
name|size
expr_stmt|;
name|blkclr
argument_list|(
operator|(
name|caddr_t
operator|)
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Initialize the pmap module.  *	Called by vm_init, to initialize any structures that the pmap  *	system needs to map virtual memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|phys_start
parameter_list|,
name|phys_end
parameter_list|)
name|vm_offset_t
name|phys_start
decl_stmt|,
name|phys_end
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_init(%x, %x)\n"
argument_list|,
name|phys_start
argument_list|,
name|phys_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	This routine should only be called by vm_page_startup()  *	with KSEG0 addresses.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|virt
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|prot
parameter_list|)
name|vm_offset_t
name|virt
decl_stmt|;
name|vm_offset_t
name|start
decl_stmt|;
name|vm_offset_t
name|end
decl_stmt|;
name|int
name|prot
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_map(%x, %x, %x, %x)\n"
argument_list|,
name|virt
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|prot
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|round_page
argument_list|(
name|end
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Create and return a physical map.  *  *	If the size specified for the map  *	is zero, the map is an actual physical  *	map, and may be referenced by the  *	hardware.  *  *	If the size specified is non-zero,  *	the map will be used in software only, and  *	is bounded by that size.  */
end_comment

begin_function
name|pmap_t
name|pmap_create
parameter_list|(
name|size
parameter_list|)
name|vm_size_t
name|size
decl_stmt|;
block|{
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_CREATE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_create(%x)\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Software use map does not need a pmap 	 */
if|if
condition|(
name|size
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|printf
argument_list|(
literal|"pmap_create(%x) XXX\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* XXX: is it ok to wait here? */
name|pmap
operator|=
operator|(
name|pmap_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|pmap
argument_list|,
name|M_VMPMAP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notifwewait
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_create: cannot allocate a pmap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|pmap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_pinit
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|pmap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|struct
name|vmspace
name|vmspace0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_CREATE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_pinit(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|simple_lock_init
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_count
operator|=
literal|1
expr_stmt|;
name|pmap
operator|->
name|pm_flags
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_hash
operator|=
name|zero_pmap_hash
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_HASH_UPAGES
condition|;
name|i
operator|++
control|)
name|pmap
operator|->
name|pm_hash_ptes
index|[
name|i
index|]
operator|=
operator|(
name|MACH_CACHED_TO_PHYS
argument_list|(
name|zero_pmap_hash
argument_list|)
operator|+
operator|(
name|i
operator|<<
name|PGSHIFT
operator|)
operator|)
operator||
name|PG_V
operator||
name|PG_RO
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
operator|&
name|vmspace0
operator|.
name|vm_pmap
condition|)
name|pmap
operator|->
name|pm_tlbpid
operator|=
literal|1
expr_stmt|;
comment|/* preallocated in mach_init() */
else|else
name|pmap
operator|->
name|pm_tlbpid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* none allocated yet */
block|}
end_function

begin_comment
comment|/*  *	Retire the given physical map from service.  *	Should only be called if the map contains  *	no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_destroy
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_destroy(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|printf
argument_list|(
literal|"pmap_destroy(%x) XXX\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
comment|/* XXX */
name|simple_lock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
name|count
operator|=
operator|--
name|pmap
operator|->
name|pm_count
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|pmap_release
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pmap
argument_list|,
name|M_VMPMAP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
block|{
specifier|register
name|int
name|id
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
specifier|register
name|int
name|i
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_release(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|->
name|pm_hash
operator|&&
name|pmap
operator|->
name|pm_hash
operator|!=
name|zero_pmap_hash
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_hash
argument_list|,
name|PMAP_HASH_SIZE
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_hash
operator|=
name|zero_pmap_hash
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|id
operator|=
name|pmap
operator|->
name|pm_tlbpid
operator|)
operator|<
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|whichpids
index|[
name|id
operator|>>
literal|5
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|id
operator|&
literal|0x1F
operator|)
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"pmap_release: id free"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MachTLBFlushPID
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|whichpids
index|[
name|id
operator|>>
literal|5
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|id
operator|&
literal|0x1F
operator|)
operator|)
expr_stmt|;
name|pmap
operator|->
name|pm_flags
operator|&=
operator|~
name|PM_MODIFIED
expr_stmt|;
name|pmap
operator|->
name|pm_tlbpid
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|cur_pmap
condition|)
name|cur_pmap
operator|=
operator|(
name|pmap_t
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* invalidate user PTE cache */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_HASH_UPAGES
condition|;
name|i
operator|++
control|)
name|MachTLBWriteIndexed
argument_list|(
name|i
operator|+
name|UPAGES
argument_list|,
name|MACH_RESERVED_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Add a reference to the specified pmap.  */
end_comment

begin_function
name|void
name|pmap_reference
parameter_list|(
name|pmap
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_reference(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|simple_lock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_count
operator|++
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|pmap_hash_t
name|hp
decl_stmt|;
name|unsigned
name|entry
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_REMOVE
operator||
name|PDB_PROTECT
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_remove(%x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
name|remove_stats
operator|.
name|calls
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
comment|/* anything in the cache? */
if|if
condition|(
name|pmap
operator|->
name|pm_tlbpid
operator|<
literal|0
operator|||
name|pmap
operator|->
name|pm_hash
operator|==
name|zero_pmap_hash
condition|)
return|return;
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_hash
condition|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
comment|/* remove entries from kernel pmap */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sva
operator|<
name|VM_MIN_KERNEL_ADDRESS
operator|||
name|eva
operator|>
name|VM_MIN_KERNEL_ADDRESS
operator|+
name|PMAP_HASH_KPAGES
operator|*
name|NPTEPG
operator|*
name|NBPG
condition|)
name|panic
argument_list|(
literal|"pmap_remove"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pte
operator|=
name|kvtopte
argument_list|(
name|sva
argument_list|)
expr_stmt|;
for|for
control|(
name|va
operator|=
name|sva
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|NBPG
operator|,
name|pte
operator|++
control|)
block|{
name|entry
operator|=
name|pte
operator|->
name|pt_entry
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|&
name|PG_V
operator|)
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|&
name|PG_WIRED
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pmap_remove_pv
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|entry
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|entry
operator|-
name|KERNBASE
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|pte
operator|->
name|pt_entry
operator|=
name|PG_NV
expr_stmt|;
comment|/* 			 * Flush the TLB for the given address. 			 */
name|MachTLBFlushAddr
argument_list|(
name|va
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|flushes
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
name|va
operator|=
name|sva
operator||
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
expr_stmt|;
name|eva
operator||=
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
expr_stmt|;
comment|/* 	 * If we are not in the current address space, just flush the 	 * software cache and not the hardware. 	 */
if|if
condition|(
name|pmap
operator|!=
name|cur_pmap
condition|)
block|{
for|for
control|(
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|NBPG
control|)
block|{
name|hp
operator|=
operator|&
name|pmap
operator|->
name|pm_hash
index|[
name|PMAP_HASH
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|high
operator|==
name|va
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|high
operator|==
name|va
condition|)
name|i
operator|=
literal|1
expr_stmt|;
else|else
continue|continue;
name|hp
operator|->
name|pmh_pte
index|[
name|i
index|]
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|entry
operator|=
name|hp
operator|->
name|pmh_pte
index|[
name|i
index|]
operator|.
name|low
expr_stmt|;
if|if
condition|(
name|entry
operator|&
name|PG_WIRED
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pmap_remove_pv
argument_list|(
name|pmap
argument_list|,
name|va
operator|&
name|PG_FRAME
argument_list|,
name|entry
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|entry
operator|-
name|KERNBASE
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|pmap
operator|->
name|pm_flags
operator||=
name|PM_MODIFIED
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|removes
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
for|for
control|(
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|NBPG
control|)
block|{
name|hp
operator|=
operator|&
name|pmap
operator|->
name|pm_hash
index|[
name|PMAP_HASH
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|high
operator|==
name|va
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|high
operator|==
name|va
condition|)
name|i
operator|=
literal|1
expr_stmt|;
else|else
continue|continue;
name|hp
operator|->
name|pmh_pte
index|[
name|i
index|]
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|entry
operator|=
name|hp
operator|->
name|pmh_pte
index|[
name|i
index|]
operator|.
name|low
expr_stmt|;
if|if
condition|(
name|entry
operator|&
name|PG_WIRED
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pmap_remove_pv
argument_list|(
name|pmap
argument_list|,
name|va
operator|&
name|PG_FRAME
argument_list|,
name|entry
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|entry
operator|-
name|KERNBASE
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 		* Flush the TLB for the given address. 		*/
name|MachTLBFlushAddr
argument_list|(
name|va
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|flushes
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  *	pmap_page_protect:  *  *	Lower the permission for all mappings to a given page.  */
end_comment

begin_function
name|void
name|pmap_page_protect
parameter_list|(
name|pa
parameter_list|,
name|prot
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_PROTECT
operator|)
operator|)
operator|||
name|prot
operator|==
name|VM_PROT_NONE
operator|&&
operator|(
name|pmapdebug
operator|&
name|PDB_REMOVE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_page_protect(%x, %x)\n"
argument_list|,
name|pa
argument_list|,
name|prot
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|IS_VM_PHYSADDR
argument_list|(
name|pa
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|VM_PROT_ALL
case|:
break|break;
comment|/* copy_on_write */
case|case
name|VM_PROT_READ
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
case|:
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 		 * Loop over all current mappings setting/clearing as appropos. 		 */
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|pv
condition|;
name|pv
operator|=
name|pv
operator|->
name|pv_next
control|)
block|{
specifier|extern
name|vm_offset_t
name|pager_sva
decl_stmt|,
name|pager_eva
decl_stmt|;
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
comment|/* 				 * XXX don't write protect pager mappings 				 */
if|if
condition|(
name|va
operator|>=
name|pager_sva
operator|&&
name|va
operator|<
name|pager_eva
condition|)
continue|continue;
name|pmap_protect
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|va
argument_list|,
name|va
operator|+
name|PAGE_SIZE
argument_list|,
name|prot
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/* remove_all */
default|default:
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|pv
operator|->
name|pv_pmap
operator|!=
name|NULL
condition|)
block|{
name|pmap_remove
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_va
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|,
name|prot
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|pmap_hash_t
name|hp
decl_stmt|;
name|u_int
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_PROTECT
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_protect(%x, %x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|prot
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
comment|/* anything in the software cache? */
if|if
condition|(
name|pmap
operator|->
name|pm_tlbpid
operator|<
literal|0
operator|||
name|pmap
operator|->
name|pm_hash
operator|==
name|zero_pmap_hash
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_hash
condition|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
comment|/* 		 * Change entries in kernel pmap. 		 * This will trap if the page is writeable (in order to set 		 * the dirty bit) even if the dirty bit is already set. The 		 * optimization isn't worth the effort since this code isn't 		 * executed much. The common case is to make a user page 		 * read-only. 		 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sva
operator|<
name|VM_MIN_KERNEL_ADDRESS
operator|||
name|eva
operator|>
name|VM_MIN_KERNEL_ADDRESS
operator|+
name|PMAP_HASH_KPAGES
operator|*
name|NPTEPG
operator|*
name|NBPG
condition|)
name|panic
argument_list|(
literal|"pmap_protect"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
name|PG_RW
else|:
name|PG_RO
expr_stmt|;
name|pte
operator|=
name|kvtopte
argument_list|(
name|sva
argument_list|)
expr_stmt|;
for|for
control|(
name|va
operator|=
name|sva
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|NBPG
operator|,
name|pte
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|pte
operator|->
name|pt_entry
operator|&
name|PG_V
operator|)
condition|)
continue|continue;
name|pte
operator|->
name|pt_entry
operator|=
operator|(
name|pte
operator|->
name|pt_entry
operator|&
operator|~
operator|(
name|PG_M
operator||
name|PG_RO
operator|)
operator|)
operator||
name|p
expr_stmt|;
comment|/* 			 * Update the TLB if the given address is in the cache. 			 */
name|MachTLBUpdate
argument_list|(
name|va
argument_list|,
name|pte
operator|->
name|pt_entry
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|p
operator|=
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
name|PG_RW
else|:
name|PG_RO
expr_stmt|;
name|va
operator|=
name|sva
operator||
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
expr_stmt|;
name|eva
operator||=
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
expr_stmt|;
comment|/* 	 * If we are not in the current address space, just flush the 	 * software cache and not the hardware. 	 */
if|if
condition|(
name|pmap
operator|!=
name|cur_pmap
condition|)
block|{
for|for
control|(
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|NBPG
control|)
block|{
name|hp
operator|=
operator|&
name|pmap
operator|->
name|pm_hash
index|[
name|PMAP_HASH
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|high
operator|==
name|va
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|high
operator|==
name|va
condition|)
name|i
operator|=
literal|1
expr_stmt|;
else|else
continue|continue;
name|hp
operator|->
name|pmh_pte
index|[
name|i
index|]
operator|.
name|low
operator|=
operator|(
name|hp
operator|->
name|pmh_pte
index|[
name|i
index|]
operator|.
name|low
operator|&
operator|~
operator|(
name|PG_M
operator||
name|PG_RO
operator|)
operator|)
operator||
name|p
expr_stmt|;
name|pmap
operator|->
name|pm_flags
operator||=
name|PM_MODIFIED
expr_stmt|;
block|}
return|return;
block|}
for|for
control|(
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|NBPG
control|)
block|{
name|hp
operator|=
operator|&
name|pmap
operator|->
name|pm_hash
index|[
name|PMAP_HASH
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|high
operator|==
name|va
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|high
operator|==
name|va
condition|)
name|i
operator|=
literal|1
expr_stmt|;
else|else
continue|continue;
name|hp
operator|->
name|pmh_pte
index|[
name|i
index|]
operator|.
name|low
operator|=
operator|(
name|hp
operator|->
name|pmh_pte
index|[
name|i
index|]
operator|.
name|low
operator|&
operator|~
operator|(
name|PG_M
operator||
name|PG_RO
operator|)
operator|)
operator||
name|p
expr_stmt|;
comment|/* 		* Update the TLB if the given address is in the cache. 		*/
name|MachTLBUpdate
argument_list|(
name|hp
operator|->
name|pmh_pte
index|[
name|i
index|]
operator|.
name|high
argument_list|,
name|hp
operator|->
name|pmh_pte
index|[
name|i
index|]
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|pa
parameter_list|,
name|prot
parameter_list|,
name|wired
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
block|{
specifier|register
name|pmap_hash_t
name|hp
decl_stmt|;
specifier|register
name|u_int
name|npte
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|newpos
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_ENTER
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_enter(%x, %x, %x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|prot
argument_list|,
name|wired
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|pmap
condition|)
name|panic
argument_list|(
literal|"pmap_enter: pmap"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_tlbpid
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_enter: tlbpid"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_hash
condition|)
block|{
name|enter_stats
operator|.
name|kernel
operator|++
expr_stmt|;
if|if
condition|(
name|va
operator|<
name|VM_MIN_KERNEL_ADDRESS
operator|||
name|va
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|+
name|PMAP_HASH_KPAGES
operator|*
name|NPTEPG
operator|*
name|NBPG
condition|)
name|panic
argument_list|(
literal|"pmap_enter: kva"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enter_stats
operator|.
name|user
operator|++
expr_stmt|;
if|if
condition|(
name|va
operator|&
literal|0x80000000
condition|)
name|panic
argument_list|(
literal|"pmap_enter: uva"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pa
operator|&
literal|0x80000000
condition|)
name|panic
argument_list|(
literal|"pmap_enter: pa"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
condition|)
name|panic
argument_list|(
literal|"pmap_enter: prot"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * See if we need to create a new TLB cache. 	 */
if|if
condition|(
name|pmap
operator|->
name|pm_hash
operator|==
name|zero_pmap_hash
condition|)
block|{
specifier|register
name|vm_offset_t
name|kva
decl_stmt|;
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|kva
operator|=
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|PMAP_HASH_SIZE
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_hash
operator|=
operator|(
name|pmap_hash_t
operator|)
name|kva
expr_stmt|;
comment|/* 		 * Convert the kernel virtual address to a physical one 		 * and cache it in the pmap. Note: if the phyical address 		 * can change (due to memory compaction in kmem_alloc?), 		 * we will have to update things. 		 */
name|pte
operator|=
name|kvtopte
argument_list|(
name|kva
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_HASH_UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|pmap
operator|->
name|pm_hash_ptes
index|[
name|i
index|]
operator|=
name|pte
operator|->
name|pt_entry
operator|&
operator|~
name|PG_G
expr_stmt|;
name|pte
operator|++
expr_stmt|;
block|}
comment|/* 		 * Map in new TLB cache if it is current. 		 */
if|if
condition|(
name|pmap
operator|==
name|cur_pmap
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_HASH_UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|MachTLBWriteIndexed
argument_list|(
name|i
operator|+
name|UPAGES
argument_list|,
operator|(
name|PMAP_HASH_UADDR
operator|+
operator|(
name|i
operator|<<
name|PGSHIFT
operator|)
operator|)
operator||
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
argument_list|,
name|pmap
operator|->
name|pm_hash_ptes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PAGE_SIZE
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|,
name|kva
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|kva
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_enter: *kva != 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|IS_VM_PHYSADDR
argument_list|(
name|pa
argument_list|)
condition|)
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
condition|)
name|npte
operator|=
name|PG_RO
expr_stmt|;
else|else
block|{
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
name|mem
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|va
operator|<
literal|0
condition|)
block|{
comment|/* 				 * Don't bother to trap on kernel writes, 				 * just record page as dirty. 				 */
name|npte
operator|=
name|PG_M
expr_stmt|;
name|mem
operator|->
name|flags
operator|&=
operator|~
name|PG_CLEAN
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|ATTR
if|if
condition|(
operator|(
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
operator|-
name|KERNBASE
argument_list|)
index|]
operator|&
name|PMAP_ATTR_MOD
operator|)
operator|||
operator|!
operator|(
name|mem
operator|->
name|flags
operator|&
name|PG_CLEAN
operator|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|mem
operator|->
name|flags
operator|&
name|PG_CLEAN
operator|)
condition|)
endif|#
directive|endif
name|npte
operator|=
name|PG_M
expr_stmt|;
else|else
name|npte
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|managed
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Enter the pmap and virtual address into the 		 * physical to virtual map table. 		 */
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|printf
argument_list|(
literal|"pmap_enter: pv %x: was %x/%x/%x\n"
argument_list|,
name|pv
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_next
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * No entries yet, use header as the first entry 			 */
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|firstpv
operator|++
expr_stmt|;
endif|#
directive|endif
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|pv
operator|->
name|pv_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * There is at least one other VA mapping this page. 			 * Place this entry after the header. 			 * 			 * Note: the entry may already be in the table if 			 * we are only changing the protection bits. 			 */
for|for
control|(
name|npv
operator|=
name|pv
init|;
name|npv
condition|;
name|npv
operator|=
name|npv
operator|->
name|pv_next
control|)
if|if
condition|(
name|pmap
operator|==
name|npv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|npv
operator|->
name|pv_va
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_hash
condition|)
block|{
name|unsigned
name|entry
decl_stmt|;
name|entry
operator|=
name|kvtopte
argument_list|(
name|va
argument_list|)
operator|->
name|pt_entry
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|&
name|PG_V
operator|)
operator|||
operator|(
name|entry
operator|&
name|PG_FRAME
operator|)
operator|!=
name|pa
condition|)
name|printf
argument_list|(
literal|"found kva %x pa %x in pv_table but != %x\n"
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hp
operator|=
operator|&
name|pmap
operator|->
name|pm_hash
index|[
name|PMAP_HASH
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|high
operator|==
operator|(
name|va
operator||
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
operator|)
operator|&&
operator|(
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|low
operator|&
name|PG_FRAME
operator|)
operator|==
name|pa
operator|)
operator|||
operator|(
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|high
operator|==
operator|(
name|va
operator||
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
operator|)
operator|&&
operator|(
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|low
operator|&
name|PG_FRAME
operator|)
operator|==
name|pa
operator|)
condition|)
goto|goto
name|fnd
goto|;
name|printf
argument_list|(
literal|"found va %x pa %x in pv_table but !=\n"
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|fnd
goto|;
block|}
comment|/* can this cause us to recurse forever? */
name|npv
operator|=
operator|(
name|pv_entry_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|npv
argument_list|,
name|M_VMPVENT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|npv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|npv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|npv
operator|->
name|pv_next
operator|=
name|pv
operator|->
name|pv_next
expr_stmt|;
name|pv
operator|->
name|pv_next
operator|=
name|npv
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|npv
operator|->
name|pv_next
condition|)
name|enter_stats
operator|.
name|secondpv
operator|++
expr_stmt|;
endif|#
directive|endif
name|fnd
label|:
empty_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Assumption: if it is not part of our managed memory 		 * then it must be device memory which may be volitile. 		 */
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|unmanaged
operator|++
expr_stmt|;
endif|#
directive|endif
name|npte
operator|=
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
operator|(
name|PG_M
operator||
name|PG_N
operator|)
else|:
operator|(
name|PG_RO
operator||
name|PG_N
operator|)
expr_stmt|;
block|}
comment|/* 	 * The only time we need to flush the cache is if we 	 * execute from a physical address and then change the data. 	 * This is the best place to do this. 	 * pmap_protect() and pmap_remove() are mostly used to switch 	 * between R/W and R/O pages. 	 * NOTE: we only support cache flush for read only text. 	 */
if|if
condition|(
name|prot
operator|==
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
condition|)
name|MachFlushICache
argument_list|(
name|MACH_PHYS_TO_CACHED
argument_list|(
name|pa
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_hash
condition|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
comment|/* enter entries into kernel pmap */
name|pte
operator|=
name|kvtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|npte
operator||=
name|pa
operator||
name|PG_V
operator||
name|PG_G
expr_stmt|;
if|if
condition|(
name|wired
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|+=
name|pmaxpagesperpage
expr_stmt|;
name|npte
operator||=
name|PG_WIRED
expr_stmt|;
block|}
name|i
operator|=
name|pmaxpagesperpage
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|pte
operator|->
name|pt_entry
operator|&
name|PG_V
operator|)
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
name|MachTLBWriteRandom
argument_list|(
name|va
argument_list|,
name|npte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|pte
operator|->
name|pt_entry
operator|&
name|PG_WIRED
condition|)
name|panic
argument_list|(
literal|"pmap_enter: kernel wired"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 				 * Update the same virtual address entry. 				 */
name|MachTLBUpdate
argument_list|(
name|va
argument_list|,
name|npte
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TLB update kva %x pte %x -> %x\n"
argument_list|,
name|va
argument_list|,
name|pte
operator|->
name|pt_entry
argument_list|,
name|npte
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
name|pte
operator|->
name|pt_entry
operator|=
name|npte
expr_stmt|;
name|va
operator|+=
name|NBPG
expr_stmt|;
name|npte
operator|+=
name|NBPG
expr_stmt|;
name|pte
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|!=
literal|0
condition|)
do|;
return|return;
block|}
comment|/* 	 * Now validate mapping with desired protection/wiring. 	 * Assume uniform modified and referenced status for all 	 * PMAX pages in a MACH page. 	 */
name|npte
operator||=
name|pa
operator||
name|PG_V
expr_stmt|;
if|if
condition|(
name|wired
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|+=
name|pmaxpagesperpage
expr_stmt|;
name|npte
operator||=
name|PG_WIRED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|printf
argument_list|(
literal|"pmap_enter: new pte value %x\n"
argument_list|,
name|npte
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va
operator||=
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
expr_stmt|;
name|i
operator|=
name|pmaxpagesperpage
expr_stmt|;
do|do
block|{
name|hp
operator|=
operator|&
name|pmap
operator|->
name|pm_hash
index|[
name|PMAP_HASH
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|high
operator|==
name|va
operator|&&
operator|(
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|low
operator|&
name|PG_FRAME
operator|)
operator|==
operator|(
name|npte
operator|&
name|PG_FRAME
operator|)
condition|)
name|j
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|high
operator|==
name|va
operator|&&
operator|(
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|low
operator|&
name|PG_FRAME
operator|)
operator|==
operator|(
name|npte
operator|&
name|PG_FRAME
operator|)
condition|)
name|j
operator|=
literal|1
expr_stmt|;
else|else
name|j
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|cachehit
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|low
operator|&
name|PG_WIRED
operator|)
condition|)
block|{
comment|/* 				 * Update the same entry. 				 */
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|low
operator|=
name|npte
expr_stmt|;
name|MachTLBUpdate
argument_list|(
name|va
argument_list|,
name|npte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Don't replace wired entries, just update 				 * the hardware TLB. 				 * Bug: routines to flush the TLB won't know 				 * that the entry is in the hardware. 				 */
name|printf
argument_list|(
literal|"pmap_enter: wired va %x %x\n"
argument_list|,
name|va
argument_list|,
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|low
argument_list|)
expr_stmt|;
comment|/* XXX */
name|panic
argument_list|(
literal|"pmap_enter: wired"
argument_list|)
expr_stmt|;
comment|/* XXX */
name|MachTLBWriteRandom
argument_list|(
name|va
argument_list|,
name|npte
argument_list|)
expr_stmt|;
block|}
goto|goto
name|next
goto|;
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|high
condition|)
name|j
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|high
condition|)
name|j
operator|=
literal|1
expr_stmt|;
else|else
name|j
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|high
operator|=
name|va
expr_stmt|;
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|low
operator|=
name|npte
expr_stmt|;
name|MachTLBWriteRandom
argument_list|(
name|va
argument_list|,
name|npte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|cachehit
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|low
operator|&
name|PG_WIRED
operator|)
condition|)
block|{
name|MachTLBFlushAddr
argument_list|(
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|high
argument_list|)
expr_stmt|;
name|pmap_remove_pv
argument_list|(
name|pmap
argument_list|,
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|high
operator|&
name|PG_FRAME
argument_list|,
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|low
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|=
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
expr_stmt|;
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|high
operator|=
name|va
expr_stmt|;
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|low
operator|=
name|npte
expr_stmt|;
name|MachTLBWriteRandom
argument_list|(
name|va
argument_list|,
name|npte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Don't replace wired entries, just update 				 * the hardware TLB. 				 * Bug: routines to flush the TLB won't know 				 * that the entry is in the hardware. 				 */
name|printf
argument_list|(
literal|"pmap_enter: wired va %x %x\n"
argument_list|,
name|va
argument_list|,
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|low
argument_list|)
expr_stmt|;
comment|/* XXX */
name|panic
argument_list|(
literal|"pmap_enter: wired"
argument_list|)
expr_stmt|;
comment|/* XXX */
name|MachTLBWriteRandom
argument_list|(
name|va
argument_list|,
name|npte
argument_list|)
expr_stmt|;
block|}
block|}
name|next
label|:
name|va
operator|+=
name|NBPG
expr_stmt|;
name|npte
operator|+=
name|NBPG
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|wired
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
block|{
specifier|register
name|pmap_hash_t
name|hp
decl_stmt|;
name|u_int
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_change_wiring(%x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|wired
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|p
operator|=
name|wired
condition|?
name|PG_WIRED
else|:
literal|0
expr_stmt|;
comment|/* 	 * Don't need to flush the TLB since PG_WIRED is only in software. 	 */
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_hash
condition|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
comment|/* change entries in kernel pmap */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|va
operator|<
name|VM_MIN_KERNEL_ADDRESS
operator|||
name|va
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|+
name|PMAP_HASH_KPAGES
operator|*
name|NPTEPG
operator|*
name|NBPG
condition|)
name|panic
argument_list|(
literal|"pmap_change_wiring"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pte
operator|=
name|kvtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|i
operator|=
name|pmaxpagesperpage
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pte
operator|->
name|pt_entry
operator|&
name|PG_WIRED
operator|)
operator|&&
name|p
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|+=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pte
operator|->
name|pt_entry
operator|&
name|PG_WIRED
operator|)
operator|&&
operator|!
name|p
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|-=
name|i
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|pte
operator|->
name|pt_entry
operator|&
name|PG_V
operator|)
condition|)
continue|continue;
name|pte
operator|->
name|pt_entry
operator|=
operator|(
name|pte
operator|->
name|pt_entry
operator|&
operator|~
name|PG_WIRED
operator|)
operator||
name|p
expr_stmt|;
name|pte
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|!=
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|pmap
operator|->
name|pm_tlbpid
operator|>=
literal|0
operator|&&
name|pmap
operator|->
name|pm_hash
operator|!=
name|zero_pmap_hash
condition|)
block|{
name|i
operator|=
name|pmaxpagesperpage
expr_stmt|;
name|va
operator|=
operator|(
name|va
operator|&
name|PG_FRAME
operator|)
operator||
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
expr_stmt|;
do|do
block|{
name|hp
operator|=
operator|&
name|pmap
operator|->
name|pm_hash
index|[
name|PMAP_HASH
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|high
operator|==
name|va
condition|)
name|j
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|high
operator|==
name|va
condition|)
name|j
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|va
operator|+=
name|NBPG
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|low
operator|&
name|PG_WIRED
operator|)
operator|&&
name|p
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|low
operator|&
name|PG_WIRED
operator|)
operator|&&
operator|!
name|p
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|low
operator|=
operator|(
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|low
operator|&
operator|~
name|PG_WIRED
operator|)
operator||
name|p
expr_stmt|;
name|va
operator|+=
name|NBPG
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|!=
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_extract
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
specifier|register
name|pmap_hash_t
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_extract(%x, %x) -> "
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pmap
operator|->
name|pm_hash
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|va
operator|<
name|VM_MIN_KERNEL_ADDRESS
operator|||
name|va
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|+
name|PMAP_HASH_KPAGES
operator|*
name|NPTEPG
operator|*
name|NBPG
condition|)
name|panic
argument_list|(
literal|"pmap_extract"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pa
operator|=
name|kvtopte
argument_list|(
name|va
argument_list|)
operator|->
name|pt_entry
operator|&
name|PG_FRAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pmap
operator|->
name|pm_tlbpid
operator|>=
literal|0
condition|)
block|{
name|hp
operator|=
operator|&
name|pmap
operator|->
name|pm_hash
index|[
name|PMAP_HASH
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|va
operator|=
operator|(
name|va
operator|&
name|PG_FRAME
operator|)
operator||
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|high
operator|==
name|va
condition|)
name|pa
operator|=
name|hp
operator|->
name|pmh_pte
index|[
literal|0
index|]
operator|.
name|low
operator|&
name|PG_FRAME
expr_stmt|;
elseif|else
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|high
operator|==
name|va
condition|)
name|pa
operator|=
name|hp
operator|->
name|pmh_pte
index|[
literal|1
index|]
operator|.
name|low
operator|&
name|PG_FRAME
expr_stmt|;
else|else
name|pa
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|pa
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"%x\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|dst_pmap
parameter_list|,
name|src_pmap
parameter_list|,
name|dst_addr
parameter_list|,
name|len
parameter_list|,
name|src_addr
parameter_list|)
name|pmap_t
name|dst_pmap
decl_stmt|;
name|pmap_t
name|src_pmap
decl_stmt|;
name|vm_offset_t
name|dst_addr
decl_stmt|;
name|vm_size_t
name|len
decl_stmt|;
name|vm_offset_t
name|src_addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_copy(%x, %x, %x, %x, %x)\n"
argument_list|,
name|dst_pmap
argument_list|,
name|src_pmap
argument_list|,
name|dst_addr
argument_list|,
name|len
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Require that all active physical maps contain no  *	incorrect entries NOW.  [This update includes  *	forcing updates of any address map caching.]  *  *	Generally used to insure that a thread about  *	to run will see a semantically correct world.  */
end_comment

begin_function
name|void
name|pmap_update
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_update()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_collect  *	Function:  *		Garbage collects the physical map system for  *		pages which are no longer used.  *		Success need not be guaranteed -- that is, there  *		may well be pages which are not referenced, but  *		others may be collected.  *	Usage:  *		Called by the pageout daemon when pages are scarce.  */
end_comment

begin_function
name|void
name|pmap_collect
parameter_list|(
name|pmap
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_collect(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified (machine independent)  *	page.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|phys
parameter_list|)
name|vm_offset_t
name|phys
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_zero_page(%x)\n"
argument_list|,
name|phys
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|MACH_PHYS_TO_CACHED
argument_list|(
name|phys
argument_list|)
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
do|do
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|end
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page.  */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|vm_offset_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|tmp0
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_copy_page(%x, %x)\n"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
operator|(
name|int
operator|*
operator|)
name|MACH_PHYS_TO_CACHED
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|int
operator|*
operator|)
name|MACH_PHYS_TO_CACHED
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|end
operator|=
name|s
operator|+
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
do|do
block|{
name|tmp0
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|tmp1
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|tmp2
operator|=
name|s
index|[
literal|2
index|]
expr_stmt|;
name|tmp3
operator|=
name|s
index|[
literal|3
index|]
expr_stmt|;
name|d
index|[
literal|0
index|]
operator|=
name|tmp0
expr_stmt|;
name|d
index|[
literal|1
index|]
operator|=
name|tmp1
expr_stmt|;
name|d
index|[
literal|2
index|]
operator|=
name|tmp2
expr_stmt|;
name|d
index|[
literal|3
index|]
operator|=
name|tmp3
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
name|d
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|!=
name|end
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_pageable  *	Function:  *		Make the specified pages (by pmap, offset)  *		pageable (or not) as requested.  *  *		A page which is not pageable may not take  *		a fault; therefore, its page table entry  *		must remain valid for the duration.  *  *		This routine is merely advisory; pmap_enter  *		will specify that these pages are to be wired  *		down (or not) as appropriate.  */
end_comment

begin_function
name|void
name|pmap_pageable
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|,
name|pageable
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
name|boolean_t
name|pageable
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_pageable(%x, %x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|pageable
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
name|pmap_hash_t
name|hp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_clear_modify(%x)\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
operator|-
name|KERNBASE
argument_list|)
index|]
operator|&=
operator|~
name|PMAP_ATTR_MOD
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	pmap_clear_reference:  *  *	Clear the reference bit on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_clear_reference(%x)\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
operator|-
name|KERNBASE
argument_list|)
index|]
operator|&=
operator|~
name|PMAP_ATTR_REF
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	pmap_is_referenced:  *  *	Return whether or not the specified physical page is referenced  *	by any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_referenced
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ATTR
return|return
operator|(
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
operator|-
name|KERNBASE
argument_list|)
index|]
operator|&
name|PMAP_ATTR_REF
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|FALSE
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	pmap_is_modified:  *  *	Return whether or not the specified physical page is modified  *	by any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ATTR
return|return
operator|(
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
operator|-
name|KERNBASE
argument_list|)
index|]
operator|&
name|PMAP_ATTR_MOD
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|FALSE
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_phys_address
parameter_list|(
name|ppn
parameter_list|)
name|int
name|ppn
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_phys_address(%x)\n"
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pmax_ptob
argument_list|(
name|ppn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Miscellaneous support routines  */
end_comment

begin_comment
comment|/*  * Allocate a hardware PID and return it.  * Also, change the hardwired TLB entry to point to the current TLB cache.  * This is called by swtch().  */
end_comment

begin_function
name|int
name|pmap_alloc_tlbpid
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
specifier|register
name|u_int
name|i
decl_stmt|;
specifier|register
name|int
name|id
decl_stmt|;
name|pmap
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|pmap
operator|->
name|pm_tlbpid
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|pmap
operator|->
name|pm_flags
operator|&
name|PM_MODIFIED
condition|)
block|{
name|pmap
operator|->
name|pm_flags
operator|&=
operator|~
name|PM_MODIFIED
expr_stmt|;
name|MachTLBFlushPID
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|whichpids
index|[
literal|0
index|]
operator|)
operator|!=
literal|0xFFFFFFFF
condition|)
name|id
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|whichpids
index|[
literal|1
index|]
operator|)
operator|!=
literal|0xFFFFFFFF
condition|)
name|id
operator|=
literal|32
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|proc
modifier|*
name|q
decl_stmt|;
specifier|register
name|pmap_t
name|q_pmap
decl_stmt|;
comment|/* 		 * Have to find a tlbpid to recycle. 		 * There is probably a better way to do this. 		 */
for|for
control|(
name|q
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|allproc
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|p_nxt
control|)
block|{
name|q_pmap
operator|=
operator|&
name|q
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|q_pmap
operator|->
name|pm_tlbpid
operator|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|q
operator|->
name|p_stat
operator|!=
name|SRUN
condition|)
goto|goto
name|fnd
goto|;
block|}
if|if
condition|(
name|id
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"TLBPidAlloc"
argument_list|)
expr_stmt|;
name|fnd
label|:
name|printf
argument_list|(
literal|"pmap_alloc_tlbpid: recycle pid %d (%s) tlbpid %d\n"
argument_list|,
name|q
operator|->
name|p_pid
argument_list|,
name|q
operator|->
name|p_comm
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* 		 * Even though the virtual to physical mapping hasn't changed, 		 * we need to clear the PID tag in the high entry of the cache. 		 */
if|if
condition|(
name|q_pmap
operator|->
name|pm_hash
operator|!=
name|zero_pmap_hash
condition|)
block|{
specifier|register
name|pmap_hash_t
name|hp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|hp
operator|=
name|q_pmap
operator|->
name|pm_hash
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_HASH_NUM_ENTRIES
condition|;
name|i
operator|++
operator|,
name|hp
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|high
condition|)
continue|continue;
if|if
condition|(
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|low
operator|&
name|PG_WIRED
condition|)
block|{
name|printf
argument_list|(
literal|"Clearing wired user entry! h %x l %x\n"
argument_list|,
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|high
argument_list|,
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|low
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"pmap_alloc_tlbpid: wired"
argument_list|)
expr_stmt|;
block|}
name|pmap_remove_pv
argument_list|(
name|q_pmap
argument_list|,
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|high
operator|&
name|PG_FRAME
argument_list|,
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|low
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|q_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
block|}
block|}
block|}
name|q_pmap
operator|->
name|pm_tlbpid
operator|=
operator|-
literal|1
expr_stmt|;
name|MachTLBFlushPID
argument_list|(
name|id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|pidflushes
operator|++
expr_stmt|;
endif|#
directive|endif
name|pmap
operator|->
name|pm_tlbpid
operator|=
name|id
expr_stmt|;
goto|goto
name|done
goto|;
block|}
while|while
condition|(
name|i
operator|&
literal|1
condition|)
block|{
name|i
operator|>>=
literal|1
expr_stmt|;
name|id
operator|++
expr_stmt|;
block|}
name|whichpids
index|[
name|id
operator|>>
literal|5
index|]
operator||=
literal|1
operator|<<
operator|(
name|id
operator|&
literal|0x1F
operator|)
expr_stmt|;
name|pmap
operator|->
name|pm_tlbpid
operator|=
name|id
expr_stmt|;
name|done
label|:
comment|/* 	 * Map in new TLB cache. 	 */
if|if
condition|(
name|pmap
operator|==
name|cur_pmap
condition|)
return|return
operator|(
name|id
operator|)
return|;
name|cur_pmap
operator|=
name|pmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_HASH_UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|MachTLBWriteIndexed
argument_list|(
name|i
operator|+
name|UPAGES
argument_list|,
operator|(
name|PMAP_HASH_UADDR
operator|+
operator|(
name|i
operator|<<
name|PGSHIFT
operator|)
operator|)
operator||
operator|(
name|id
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
argument_list|,
name|pmap
operator|->
name|pm_hash_ptes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a physical to virtual address translation.  */
end_comment

begin_function
name|void
name|pmap_remove_pv
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|pa
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|,
name|pa
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_remove_pv(%x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Remove page from the PV table (raise IPL since we 	 * may be called at interrupt time). 	 */
if|if
condition|(
operator|!
name|IS_VM_PHYSADDR
argument_list|(
name|pa
argument_list|)
condition|)
return|return;
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * If it is the first entry on the list, it is actually 	 * in the header and we must copy the following entry up 	 * to the header.  Otherwise we must search the list for 	 * the entry.  In either case we free the now unused entry. 	 */
if|if
condition|(
name|pmap
operator|==
name|pv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
block|{
name|npv
operator|=
name|pv
operator|->
name|pv_next
expr_stmt|;
if|if
condition|(
name|npv
condition|)
block|{
operator|*
name|pv
operator|=
operator|*
name|npv
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|npv
argument_list|,
name|M_VMPVENT
argument_list|)
expr_stmt|;
block|}
else|else
name|pv
operator|->
name|pv_pmap
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|pvfirst
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
for|for
control|(
name|npv
operator|=
name|pv
operator|->
name|pv_next
init|;
name|npv
condition|;
name|pv
operator|=
name|npv
operator|,
name|npv
operator|=
name|npv
operator|->
name|pv_next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|pvsearch
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|npv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|npv
operator|->
name|pv_va
condition|)
goto|goto
name|fnd
goto|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"pmap_remove_pv(%x, %x, %x) not found\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"pmap_remove_pv"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fnd
label|:
name|pv
operator|->
name|pv_next
operator|=
name|npv
operator|->
name|pv_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|npv
argument_list|,
name|M_VMPVENT
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|pmap_print
argument_list|(
argument|pmap
argument_list|)
end_macro

begin_decl_stmt
name|pmap_t
name|pmap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|pmap_hash_t
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"\tpmap_print(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_hash
operator|==
name|zero_pmap_hash
condition|)
block|{
name|printf
argument_list|(
literal|"pm_hash == zero\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pmap
operator|->
name|pm_hash
operator|==
operator|(
name|pmap_hash_t
operator|)
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pm_hash == kernel\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|hp
operator|=
name|pmap
operator|->
name|pm_hash
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_HASH_NUM_ENTRIES
condition|;
name|i
operator|++
operator|,
name|hp
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|high
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%d: hi %x low %x\n"
argument_list|,
name|i
argument_list|,
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|high
argument_list|,
name|hp
operator|->
name|pmh_pte
index|[
name|j
index|]
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

