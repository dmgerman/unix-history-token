begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ralph Campbell and Rick Macklem.  *  * %sccs.include.redist.c%  *  *	@(#)asc.c	8.3 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1991,1990,1989 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * HISTORY  * $Log:	scsi_53C94_hdw.c,v $  * Revision 2.5  91/02/05  17:45:07  mrt  * 	Added author notices  * 	[91/02/04  11:18:43  mrt]  *   * 	Changed to use new Mach copyright  * 	[91/02/02  12:17:20  mrt]  *   * Revision 2.4  91/01/08  15:48:24  rpd  * 	Added continuation argument to thread_block.  * 	[90/12/27            rpd]  *   * Revision 2.3  90/12/05  23:34:48  af  * 	Recovered from pmax merge.. and from the destruction of a disk.  * 	[90/12/03  23:40:40  af]  *   * Revision 2.1.1.1  90/11/01  03:39:09  af  * 	Created, from the DEC specs:  * 	"PMAZ-AA TURBOchannel SCSI Module Functional Specification"  * 	Workstation Systems Engineering, Palo Alto, CA. Aug 27, 1990.  * 	And from the NCR data sheets  * 	"NCR 53C94, 53C95, 53C96 Advances SCSI Controller"  * 	[90/09/03            af]  */
end_comment

begin_comment
comment|/*  *	File: scsi_53C94_hdw.h  * 	Author: Alessandro Forin, Carnegie Mellon University  *	Date:	9/90  *  *	Bottom layer of the SCSI driver: chip-dependent functions  *  *	This file contains the code that is specific to the NCR 53C94  *	SCSI chip (Host Bus Adapter in SCSI parlance): probing, start  *	operation, and interrupt routine.  */
end_comment

begin_comment
comment|/*  * This layer works based on small simple 'scripts' that are installed  * at the start of the command and drive the chip to completion.  * The idea comes from the specs of the NCR 53C700 'script' processor.  *  * There are various reasons for this, mainly  * - Performance: identify the common (successful) path, and follow it;  *   at interrupt time no code is needed to find the current status  * - Code size: it should be easy to compact common operations  * - Adaptability: the code skeleton should adapt to different chips without  *   terrible complications.  * - Error handling: and it is easy to modify the actions performed  *   by the scripts to cope with strange but well identified sequences  *  */
end_comment

begin_include
include|#
directive|include
file|<asc.h>
end_include

begin_if
if|#
directive|if
name|NASC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<machine/machConst.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/scsi.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/ascreg.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/asic.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/kmin.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/pmaxtype.h>
end_include

begin_define
define|#
directive|define
name|readback
parameter_list|(
name|a
parameter_list|)
value|{ register int foo; foo = (a); }
end_define

begin_decl_stmt
specifier|extern
name|int
name|pmax_boardtype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * In 4ns ticks.  */
end_comment

begin_decl_stmt
name|int
name|asc_to_scsi_period
index|[]
init|=
block|{
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|asc_reset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|asc_startcmd
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|asc_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|asc_debug_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|asc_debug_bn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|asc_debug_sz
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NLOG
value|32
end_define

begin_struct
struct|struct
name|asc_log
block|{
name|u_int
name|status
decl_stmt|;
name|u_char
name|state
decl_stmt|;
name|u_char
name|msg
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|resid
decl_stmt|;
block|}
name|asc_log
index|[
name|NLOG
index|]
struct|,
modifier|*
name|asc_logp
init|=
name|asc_log
struct|;
end_struct

begin_define
define|#
directive|define
name|PACK
parameter_list|(
name|unit
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
define|\
value|((unit<< 24) | (status<< 16) | (ss<< 8) | ir)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Scripts are entries in a state machine table.  * A script has four parts: a pre-condition, an action, a command to the chip,  * and an index into asc_scripts for the next state. The first triggers error  * handling if not satisfied and in our case it is formed by the  * values of the interrupt register and status register, this  * basically captures the phase of the bus and the TC and BS  * bits.  The action part is just a function pointer, and the  * command is what the 53C94 should be told to do at the end  * of the action processing.  This command is only issued and the  * script proceeds if the action routine returns TRUE.  * See asc_intr() for how and where this is all done.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|script
block|{
name|int
name|condition
decl_stmt|;
comment|/* expected state at interrupt time */
name|int
function_decl|(
modifier|*
name|action
function_decl|)
parameter_list|()
function_decl|;
comment|/* extra operations */
name|int
name|command
decl_stmt|;
comment|/* command to the chip */
name|struct
name|script
modifier|*
name|next
decl_stmt|;
comment|/* index into asc_scripts for next state */
block|}
name|script_t
typedef|;
end_typedef

begin_comment
comment|/* Matching on the condition value */
end_comment

begin_define
define|#
directive|define
name|SCRIPT_MATCH
parameter_list|(
name|ir
parameter_list|,
name|csr
parameter_list|)
value|((ir) | (((csr)& 0x67)<< 8))
end_define

begin_comment
comment|/* forward decls of script actions */
end_comment

begin_function_decl
specifier|static
name|int
name|script_nop
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* when nothing needed */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_end
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* all come to an end */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_get_status
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* get status from target */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_dma_in
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* start reading data from target */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_last_dma_in
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* cleanup after all data is read */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_resume_in
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* resume data in after a message */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_resume_dma_in
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* resume DMA after a disconnect */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_dma_out
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* send data to target via dma */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_last_dma_out
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* cleanup after all data is written */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_resume_out
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* resume data out after a message */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_resume_dma_out
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* resume DMA after a disconnect */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_sendsync
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* negotiate sync xfer */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_replysync
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* negotiate sync xfer */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_msg_in
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* process a message byte */
end_comment

begin_function_decl
specifier|static
name|int
name|asc_disconnect
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* process an expected disconnect */
end_comment

begin_comment
comment|/* Define the index into asc_scripts for various state transitions */
end_comment

begin_define
define|#
directive|define
name|SCRIPT_DATA_IN
value|0
end_define

begin_define
define|#
directive|define
name|SCRIPT_CONTINUE_IN
value|2
end_define

begin_define
define|#
directive|define
name|SCRIPT_DATA_OUT
value|3
end_define

begin_define
define|#
directive|define
name|SCRIPT_CONTINUE_OUT
value|5
end_define

begin_define
define|#
directive|define
name|SCRIPT_SIMPLE
value|6
end_define

begin_define
define|#
directive|define
name|SCRIPT_GET_STATUS
value|7
end_define

begin_define
define|#
directive|define
name|SCRIPT_MSG_IN
value|9
end_define

begin_define
define|#
directive|define
name|SCRIPT_REPLY_SYNC
value|11
end_define

begin_define
define|#
directive|define
name|SCRIPT_TRY_SYNC
value|12
end_define

begin_define
define|#
directive|define
name|SCRIPT_DISCONNECT
value|15
end_define

begin_define
define|#
directive|define
name|SCRIPT_RESEL
value|16
end_define

begin_define
define|#
directive|define
name|SCRIPT_RESUME_IN
value|17
end_define

begin_define
define|#
directive|define
name|SCRIPT_RESUME_DMA_IN
value|18
end_define

begin_define
define|#
directive|define
name|SCRIPT_RESUME_OUT
value|19
end_define

begin_define
define|#
directive|define
name|SCRIPT_RESUME_DMA_OUT
value|20
end_define

begin_define
define|#
directive|define
name|SCRIPT_RESUME_NO_DATA
value|21
end_define

begin_comment
comment|/*  * Scripts  */
end_comment

begin_decl_stmt
name|script_t
name|asc_scripts
index|[]
init|=
block|{
comment|/* start data in */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_FC
operator||
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_DATAI
argument_list|)
block|,
comment|/*  0 */
name|asc_dma_in
block|,
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_DATA_IN
operator|+
literal|1
index|]
block|}
block|,
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_STATUS
argument_list|)
block|,
comment|/*  1 */
name|asc_last_dma_in
block|,
name|ASC_CMD_I_COMPLETE
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_GET_STATUS
index|]
block|}
block|,
comment|/* continue data in after a chunk is finished */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_DATAI
argument_list|)
block|,
comment|/*  2 */
name|asc_dma_in
block|,
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_DATA_IN
operator|+
literal|1
index|]
block|}
block|,
comment|/* start data out */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_FC
operator||
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_DATAO
argument_list|)
block|,
comment|/*  3 */
name|asc_dma_out
block|,
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_DATA_OUT
operator|+
literal|1
index|]
block|}
block|,
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_STATUS
argument_list|)
block|,
comment|/*  4 */
name|asc_last_dma_out
block|,
name|ASC_CMD_I_COMPLETE
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_GET_STATUS
index|]
block|}
block|,
comment|/* continue data out after a chunk is finished */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_DATAO
argument_list|)
block|,
comment|/*  5 */
name|asc_dma_out
block|,
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_DATA_OUT
operator|+
literal|1
index|]
block|}
block|,
comment|/* simple command with no data transfer */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_FC
operator||
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_STATUS
argument_list|)
block|,
comment|/*  6 */
name|script_nop
block|,
name|ASC_CMD_I_COMPLETE
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_GET_STATUS
index|]
block|}
block|,
comment|/* get status and finish command */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_FC
argument_list|,
name|ASC_PHASE_MSG_IN
argument_list|)
block|,
comment|/*  7 */
name|asc_get_status
block|,
name|ASC_CMD_MSG_ACPT
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_GET_STATUS
operator|+
literal|1
index|]
block|}
block|,
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_DISC
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  8 */
name|asc_end
block|,
name|ASC_CMD_NOP
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_GET_STATUS
operator|+
literal|1
index|]
block|}
block|,
comment|/* message in */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_FC
argument_list|,
name|ASC_PHASE_MSG_IN
argument_list|)
block|,
comment|/*  9 */
name|asc_msg_in
block|,
name|ASC_CMD_MSG_ACPT
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_MSG_IN
operator|+
literal|1
index|]
block|}
block|,
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_MSG_IN
argument_list|)
block|,
comment|/* 10 */
name|script_nop
block|,
name|ASC_CMD_XFER_INFO
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_MSG_IN
index|]
block|}
block|,
comment|/* send synchonous negotiation reply */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_MSG_OUT
argument_list|)
block|,
comment|/* 11 */
name|asc_replysync
block|,
name|ASC_CMD_XFER_INFO
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_REPLY_SYNC
index|]
block|}
block|,
comment|/* try to negotiate synchonous transfer parameters */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_FC
operator||
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_MSG_OUT
argument_list|)
block|,
comment|/* 12 */
name|asc_sendsync
block|,
name|ASC_CMD_XFER_INFO
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_TRY_SYNC
operator|+
literal|1
index|]
block|}
block|,
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_MSG_IN
argument_list|)
block|,
comment|/* 13 */
name|script_nop
block|,
name|ASC_CMD_XFER_INFO
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_MSG_IN
index|]
block|}
block|,
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_COMMAND
argument_list|)
block|,
comment|/* 14 */
name|script_nop
block|,
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_RESUME_NO_DATA
index|]
block|}
block|,
comment|/* handle a disconnect */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_DISC
argument_list|,
name|ASC_PHASE_DATAO
argument_list|)
block|,
comment|/* 15 */
name|asc_disconnect
block|,
name|ASC_CMD_ENABLE_SEL
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_RESEL
index|]
block|}
block|,
comment|/* reselect sequence: this is just a placeholder so match fails */
block|{
name|SCRIPT_MATCH
argument_list|(
literal|0
argument_list|,
name|ASC_PHASE_MSG_IN
argument_list|)
block|,
comment|/* 16 */
name|script_nop
block|,
name|ASC_CMD_MSG_ACPT
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_RESEL
index|]
block|}
block|,
comment|/* resume data in after a message */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_DATAI
argument_list|)
block|,
comment|/* 17 */
name|asc_resume_in
block|,
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_DATA_IN
operator|+
literal|1
index|]
block|}
block|,
comment|/* resume partial DMA data in after a message */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_DATAI
argument_list|)
block|,
comment|/* 18 */
name|asc_resume_dma_in
block|,
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_DATA_IN
operator|+
literal|1
index|]
block|}
block|,
comment|/* resume data out after a message */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_DATAO
argument_list|)
block|,
comment|/* 19 */
name|asc_resume_out
block|,
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_DATA_OUT
operator|+
literal|1
index|]
block|}
block|,
comment|/* resume partial DMA data out after a message */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_DATAO
argument_list|)
block|,
comment|/* 20 */
name|asc_resume_dma_out
block|,
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_DATA_OUT
operator|+
literal|1
index|]
block|}
block|,
comment|/* resume after a message when there is no more data */
block|{
name|SCRIPT_MATCH
argument_list|(
name|ASC_INT_BS
argument_list|,
name|ASC_PHASE_STATUS
argument_list|)
block|,
comment|/* 21 */
name|script_nop
block|,
name|ASC_CMD_I_COMPLETE
block|,
operator|&
name|asc_scripts
index|[
name|SCRIPT_GET_STATUS
index|]
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * State kept for each active SCSI device.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|scsi_state
block|{
name|script_t
modifier|*
name|script
decl_stmt|;
comment|/* saved script while processing error */
name|int
name|statusByte
decl_stmt|;
comment|/* status byte returned during STATUS_PHASE */
name|int
name|error
decl_stmt|;
comment|/* errno to pass back to device driver */
name|u_char
modifier|*
name|dmaBufAddr
decl_stmt|;
comment|/* DMA buffer address */
name|u_int
name|dmaBufSize
decl_stmt|;
comment|/* DMA buffer size */
name|int
name|dmalen
decl_stmt|;
comment|/* amount to transfer in this chunk */
name|int
name|dmaresid
decl_stmt|;
comment|/* amount not transfered if chunk suspended */
name|int
name|buflen
decl_stmt|;
comment|/* total remaining amount of data to transfer */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* current pointer within scsicmd->buf */
name|int
name|flags
decl_stmt|;
comment|/* see below */
name|int
name|msglen
decl_stmt|;
comment|/* number of message bytes to read */
name|int
name|msgcnt
decl_stmt|;
comment|/* number of message bytes received */
name|u_char
name|sync_period
decl_stmt|;
comment|/* DMA synchronous period */
name|u_char
name|sync_offset
decl_stmt|;
comment|/* DMA synchronous xfer offset or 0 if async */
name|u_char
name|msg_out
decl_stmt|;
comment|/* next MSG_OUT byte to send */
name|u_char
name|msg_in
index|[
literal|16
index|]
decl_stmt|;
comment|/* buffer for multibyte messages */
block|}
name|State
typedef|;
end_typedef

begin_comment
comment|/* state flags */
end_comment

begin_define
define|#
directive|define
name|DISCONN
value|0x01
end_define

begin_comment
comment|/* true if currently disconnected from bus */
end_comment

begin_define
define|#
directive|define
name|DMA_IN_PROGRESS
value|0x02
end_define

begin_comment
comment|/* true if data DMA started */
end_comment

begin_define
define|#
directive|define
name|DMA_IN
value|0x04
end_define

begin_comment
comment|/* true if reading from SCSI device */
end_comment

begin_define
define|#
directive|define
name|DMA_OUT
value|0x10
end_define

begin_comment
comment|/* true if writing to SCSI device */
end_comment

begin_define
define|#
directive|define
name|DID_SYNC
value|0x20
end_define

begin_comment
comment|/* true if synchronous offset was negotiated */
end_comment

begin_define
define|#
directive|define
name|TRY_SYNC
value|0x40
end_define

begin_comment
comment|/* true if try neg. synchronous offset */
end_comment

begin_define
define|#
directive|define
name|PARITY_ERR
value|0x80
end_define

begin_comment
comment|/* true if parity error seen */
end_comment

begin_comment
comment|/*  * State kept for each active SCSI host interface (53C94).  */
end_comment

begin_struct
struct|struct
name|asc_softc
block|{
name|asc_regmap_t
modifier|*
name|regs
decl_stmt|;
comment|/* chip address */
specifier|volatile
name|int
modifier|*
name|dmar
decl_stmt|;
comment|/* DMA address register address */
name|u_char
modifier|*
name|buff
decl_stmt|;
comment|/* RAM buffer address (uncached) */
name|int
name|myid
decl_stmt|;
comment|/* SCSI ID of this interface */
name|int
name|myidmask
decl_stmt|;
comment|/* ~(1<< myid) */
name|int
name|state
decl_stmt|;
comment|/* current SCSI connection state */
name|int
name|target
decl_stmt|;
comment|/* target SCSI ID if busy */
name|script_t
modifier|*
name|script
decl_stmt|;
comment|/* next expected interrupt& action */
name|ScsiCmd
modifier|*
name|cmd
index|[
name|ASC_NCMD
index|]
decl_stmt|;
comment|/* active command indexed by SCSI ID */
name|State
name|st
index|[
name|ASC_NCMD
index|]
decl_stmt|;
comment|/* state info for each active command */
name|void
function_decl|(
modifier|*
name|dma_start
function_decl|)
parameter_list|()
function_decl|;
comment|/* Start dma routine */
name|void
function_decl|(
modifier|*
name|dma_end
function_decl|)
parameter_list|()
function_decl|;
comment|/* End dma routine */
name|u_char
modifier|*
name|dma_next
decl_stmt|;
name|int
name|dma_xfer
decl_stmt|;
comment|/* Dma len still to go */
name|int
name|min_period
decl_stmt|;
comment|/* Min transfer period clk/byte */
name|int
name|max_period
decl_stmt|;
comment|/* Max transfer period clk/byte */
name|int
name|ccf
decl_stmt|;
comment|/* CCF, whatever that really is? */
name|int
name|timeout_250
decl_stmt|;
comment|/* 250ms timeout */
name|int
name|tb_ticks
decl_stmt|;
comment|/* 4ns. ticks/tb channel ticks */
block|}
name|asc_softc
index|[
name|NASC
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|ASC_STATE_IDLE
value|0
end_define

begin_comment
comment|/* idle state */
end_comment

begin_define
define|#
directive|define
name|ASC_STATE_BUSY
value|1
end_define

begin_comment
comment|/* selecting or currently connected */
end_comment

begin_define
define|#
directive|define
name|ASC_STATE_TARGET
value|2
end_define

begin_comment
comment|/* currently selected as target */
end_comment

begin_define
define|#
directive|define
name|ASC_STATE_RESEL
value|3
end_define

begin_comment
comment|/* currently waiting for reselect */
end_comment

begin_typedef
typedef|typedef
name|struct
name|asc_softc
modifier|*
name|asc_softc_t
typedef|;
end_typedef

begin_comment
comment|/*  * Dma operations.  */
end_comment

begin_define
define|#
directive|define
name|ASCDMA_READ
value|1
end_define

begin_define
define|#
directive|define
name|ASCDMA_WRITE
value|2
end_define

begin_decl_stmt
specifier|static
name|void
name|tb_dma_start
argument_list|()
decl_stmt|,
name|tb_dma_end
argument_list|()
decl_stmt|,
name|asic_dma_start
argument_list|()
decl_stmt|,
name|asic_dma_end
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|asc_iomem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|asic_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Definition of the controller for the auto-configuration program.  */
end_comment

begin_function_decl
name|int
name|asc_probe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|asc_start
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|asc_intr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|driver
name|ascdriver
init|=
block|{
literal|"asc"
block|,
name|asc_probe
block|,
name|asc_start
block|,
literal|0
block|,
name|asc_intr
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Test to see if device is present.  * Return true if found and initialized ok.  */
end_comment

begin_expr_stmt
name|asc_probe
argument_list|(
name|cp
argument_list|)
specifier|register
expr|struct
name|pmax_ctlr
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|asc_regmap_t
modifier|*
name|regs
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|id
decl_stmt|,
name|s
decl_stmt|,
name|i
decl_stmt|;
name|int
name|bufsiz
decl_stmt|;
if|if
condition|(
operator|(
name|unit
operator|=
name|cp
operator|->
name|pmax_unit
operator|)
operator|>=
name|NASC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|badaddr
argument_list|(
name|cp
operator|->
name|pmax_addr
operator|+
name|ASC_OFFSET_53C94
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|asc
operator|=
operator|&
name|asc_softc
index|[
name|unit
index|]
expr_stmt|;
comment|/* 	 * Initialize hw descriptor, cache some pointers 	 */
name|asc
operator|->
name|regs
operator|=
operator|(
name|asc_regmap_t
operator|*
operator|)
operator|(
name|cp
operator|->
name|pmax_addr
operator|+
name|ASC_OFFSET_53C94
operator|)
expr_stmt|;
comment|/* 	 * Set up machine dependencies. 	 * 1) how to do dma 	 * 2) timing based on turbochannel frequency 	 */
switch|switch
condition|(
name|pmax_boardtype
condition|)
block|{
case|case
name|DS_3MIN
case|:
case|case
name|DS_MAXINE
case|:
case|case
name|DS_3MAXPLUS
case|:
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|asc
operator|->
name|buff
operator|=
operator|(
name|u_char
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|asc_iomem
argument_list|)
expr_stmt|;
name|bufsiz
operator|=
literal|8192
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|ASIC_REG_SCSI_DMAPTR
argument_list|(
name|asic_base
argument_list|)
operator|)
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|ASIC_REG_SCSI_DMANPTR
argument_list|(
name|asic_base
argument_list|)
operator|)
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|ASIC_REG_SCSI_SCR
argument_list|(
name|asic_base
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
name|asc
operator|->
name|dma_start
operator|=
name|asic_dma_start
expr_stmt|;
name|asc
operator|->
name|dma_end
operator|=
name|asic_dma_end
expr_stmt|;
break|break;
block|}
comment|/* 	     * Fall through for turbochannel option. 	     */
case|case
name|DS_3MAX
case|:
default|default:
name|asc
operator|->
name|dmar
operator|=
operator|(
specifier|volatile
name|int
operator|*
operator|)
operator|(
name|cp
operator|->
name|pmax_addr
operator|+
name|ASC_OFFSET_DMAR
operator|)
expr_stmt|;
name|asc
operator|->
name|buff
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|cp
operator|->
name|pmax_addr
operator|+
name|ASC_OFFSET_RAM
operator|)
expr_stmt|;
name|bufsiz
operator|=
name|PER_TGT_DMA_SIZE
expr_stmt|;
name|asc
operator|->
name|dma_start
operator|=
name|tb_dma_start
expr_stmt|;
name|asc
operator|->
name|dma_end
operator|=
name|tb_dma_end
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 * Now for timing. The 3max has a 25Mhz tb whereas the 3min and 	 * maxine are 12.5Mhz. 	 */
switch|switch
condition|(
name|pmax_boardtype
condition|)
block|{
case|case
name|DS_3MAX
case|:
case|case
name|DS_3MAXPLUS
case|:
name|asc
operator|->
name|min_period
operator|=
name|ASC_MIN_PERIOD25
expr_stmt|;
name|asc
operator|->
name|max_period
operator|=
name|ASC_MAX_PERIOD25
expr_stmt|;
name|asc
operator|->
name|ccf
operator|=
name|ASC_CCF
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|asc
operator|->
name|timeout_250
operator|=
name|ASC_TIMEOUT_250
argument_list|(
literal|25
argument_list|,
name|asc
operator|->
name|ccf
argument_list|)
expr_stmt|;
name|asc
operator|->
name|tb_ticks
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|DS_3MIN
case|:
case|case
name|DS_MAXINE
case|:
default|default:
name|asc
operator|->
name|min_period
operator|=
name|ASC_MIN_PERIOD12
expr_stmt|;
name|asc
operator|->
name|max_period
operator|=
name|ASC_MAX_PERIOD12
expr_stmt|;
name|asc
operator|->
name|ccf
operator|=
name|ASC_CCF
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|asc
operator|->
name|timeout_250
operator|=
name|ASC_TIMEOUT_250
argument_list|(
literal|13
argument_list|,
name|asc
operator|->
name|ccf
argument_list|)
expr_stmt|;
name|asc
operator|->
name|tb_ticks
operator|=
literal|20
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|asc
operator|->
name|state
operator|=
name|ASC_STATE_IDLE
expr_stmt|;
name|asc
operator|->
name|target
operator|=
operator|-
literal|1
expr_stmt|;
name|regs
operator|=
name|asc
operator|->
name|regs
expr_stmt|;
comment|/* 	 * Reset chip, fully.  Note that interrupts are already enabled. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* preserve our ID for now */
name|asc
operator|->
name|myid
operator|=
name|regs
operator|->
name|asc_cnfg1
operator|&
name|ASC_CNFG1_MY_BUS_ID
expr_stmt|;
name|asc
operator|->
name|myidmask
operator|=
operator|~
operator|(
literal|1
operator|<<
name|asc
operator|->
name|myid
operator|)
expr_stmt|;
name|asc_reset
argument_list|(
name|asc
argument_list|,
name|regs
argument_list|)
expr_stmt|;
comment|/* 	 * Our SCSI id on the bus. 	 * The user can set this via the prom on 3maxen/pmaxen. 	 * If this changes it is easy to fix: make a default that 	 * can be changed as boot arg. 	 */
ifdef|#
directive|ifdef
name|unneeded
name|regs
operator|->
name|asc_cnfg1
operator|=
operator|(
name|regs
operator|->
name|asc_cnfg1
operator|&
operator|~
name|ASC_CNFG1_MY_BUS_ID
operator|)
operator||
operator|(
name|scsi_initiator_id
index|[
name|unit
index|]
operator|&
literal|0x7
operator|)
expr_stmt|;
endif|#
directive|endif
name|id
operator|=
name|regs
operator|->
name|asc_cnfg1
operator|&
name|ASC_CNFG1_MY_BUS_ID
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Statically partition the DMA buffer between targets. 	 * This way we will eventually be able to attach/detach 	 * drives on-fly.  And 18k/target is plenty for normal use. 	 */
comment|/* 	 * Give each target its own DMA buffer region. 	 * We may want to try ping ponging buffers later. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASC_NCMD
condition|;
name|i
operator|++
control|)
block|{
name|asc
operator|->
name|st
index|[
name|i
index|]
operator|.
name|dmaBufAddr
operator|=
name|asc
operator|->
name|buff
operator|+
name|bufsiz
operator|*
name|i
expr_stmt|;
name|asc
operator|->
name|st
index|[
name|i
index|]
operator|.
name|dmaBufSize
operator|=
name|bufsiz
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"asc%d at nexus0 csr 0x%x priority %d SCSI id %d\n"
argument_list|,
name|unit
argument_list|,
name|cp
operator|->
name|pmax_addr
argument_list|,
name|cp
operator|->
name|pmax_pri
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Start activity on a SCSI device.  * We maintain information on each device separately since devices can  * connect/disconnect during an operation.  */
end_comment

begin_function
name|void
name|asc_start
parameter_list|(
name|scsicmd
parameter_list|)
specifier|register
name|ScsiCmd
modifier|*
name|scsicmd
decl_stmt|;
comment|/* command to start */
block|{
specifier|register
name|struct
name|scsi_device
modifier|*
name|sdp
init|=
name|scsicmd
operator|->
name|sd
decl_stmt|;
specifier|register
name|asc_softc_t
name|asc
init|=
operator|&
name|asc_softc
index|[
name|sdp
operator|->
name|sd_ctlr
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * Check if another command is already in progress. 	 * We may have to change this if we allow SCSI devices with 	 * separate LUNs. 	 */
if|if
condition|(
name|asc
operator|->
name|cmd
index|[
name|sdp
operator|->
name|sd_drive
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"asc%d: device %s busy at start\n"
argument_list|,
name|sdp
operator|->
name|sd_ctlr
argument_list|,
name|sdp
operator|->
name|sd_driver
operator|->
name|d_name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sdp
operator|->
name|sd_driver
operator|->
name|d_done
call|)
argument_list|(
name|scsicmd
operator|->
name|unit
argument_list|,
name|EBUSY
argument_list|,
name|scsicmd
operator|->
name|buflen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|asc
operator|->
name|cmd
index|[
name|sdp
operator|->
name|sd_drive
index|]
operator|=
name|scsicmd
expr_stmt|;
name|asc_startcmd
argument_list|(
name|asc
argument_list|,
name|sdp
operator|->
name|sd_drive
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|asc_reset
parameter_list|(
name|asc
parameter_list|,
name|regs
parameter_list|)
name|asc_softc_t
name|asc
decl_stmt|;
name|asc_regmap_t
modifier|*
name|regs
decl_stmt|;
block|{
comment|/* 	 * Reset chip and wait till done 	 */
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_RESET
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
comment|/* spec says this is needed after reset */
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_NOP
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
comment|/* 	 * Set up various chip parameters 	 */
name|regs
operator|->
name|asc_ccf
operator|=
name|asc
operator|->
name|ccf
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|regs
operator|->
name|asc_sel_timo
operator|=
name|asc
operator|->
name|timeout_250
expr_stmt|;
comment|/* restore our ID */
name|regs
operator|->
name|asc_cnfg1
operator|=
name|asc
operator|->
name|myid
operator||
name|ASC_CNFG1_P_CHECK
expr_stmt|;
comment|/* include ASC_CNFG2_SCSI2 if you want to allow SCSI II commands */
name|regs
operator|->
name|asc_cnfg2
operator|=
comment|/* ASC_CNFG2_RFB | ASC_CNFG2_SCSI2 | */
name|ASC_CNFG2_EPL
expr_stmt|;
name|regs
operator|->
name|asc_cnfg3
operator|=
literal|0
expr_stmt|;
comment|/* zero anything else */
name|ASC_TC_PUT
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regs
operator|->
name|asc_syn_p
operator|=
name|asc
operator|->
name|min_period
expr_stmt|;
name|regs
operator|->
name|asc_syn_o
operator|=
literal|0
expr_stmt|;
comment|/* async for now */
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a SCSI command on a target.  */
end_comment

begin_function
specifier|static
name|void
name|asc_startcmd
parameter_list|(
name|asc
parameter_list|,
name|target
parameter_list|)
name|asc_softc_t
name|asc
decl_stmt|;
name|int
name|target
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
decl_stmt|;
specifier|register
name|ScsiCmd
modifier|*
name|scsicmd
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 	 * See if another target is currently selected on this SCSI bus. 	 */
if|if
condition|(
name|asc
operator|->
name|target
operator|>=
literal|0
condition|)
return|return;
name|regs
operator|=
name|asc
operator|->
name|regs
expr_stmt|;
comment|/* 	 * If a reselection is in progress, it is Ok to ignore it since 	 * the ASC will automatically cancel the command and flush 	 * the FIFO if the ASC is reselected before the command starts. 	 * If we try to use ASC_CMD_DISABLE_SEL, we can hang the system if 	 * a reselect occurs before starting the command. 	 */
name|asc
operator|->
name|state
operator|=
name|ASC_STATE_BUSY
expr_stmt|;
name|asc
operator|->
name|target
operator|=
name|target
expr_stmt|;
comment|/* cache some pointers */
name|scsicmd
operator|=
name|asc
operator|->
name|cmd
index|[
name|target
index|]
expr_stmt|;
name|state
operator|=
operator|&
name|asc
operator|->
name|st
index|[
name|target
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"asc_startcmd: %s target %d cmd %x len %d\n"
argument_list|,
name|scsicmd
operator|->
name|sd
operator|->
name|sd_driver
operator|->
name|d_name
argument_list|,
name|target
argument_list|,
name|scsicmd
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|scsicmd
operator|->
name|buflen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Init the chip and target state. 	 */
name|state
operator|->
name|flags
operator|=
name|state
operator|->
name|flags
operator|&
name|DID_SYNC
expr_stmt|;
name|state
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|script
operator|=
operator|(
name|script_t
operator|*
operator|)
literal|0
expr_stmt|;
name|state
operator|->
name|msg_out
operator|=
name|SCSI_NO_OP
expr_stmt|;
comment|/* 	 * Copy command data to the DMA buffer. 	 */
name|len
operator|=
name|scsicmd
operator|->
name|cmdlen
expr_stmt|;
name|state
operator|->
name|dmalen
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|scsicmd
operator|->
name|cmd
argument_list|,
name|state
operator|->
name|dmaBufAddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* check for simple SCSI command with no data transfer */
if|if
condition|(
operator|(
name|state
operator|->
name|buflen
operator|=
name|scsicmd
operator|->
name|buflen
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* check for sync negotiation */
if|if
condition|(
operator|(
name|scsicmd
operator|->
name|flags
operator|&
name|SCSICMD_USE_SYNC
operator|)
operator|&&
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|DID_SYNC
operator|)
condition|)
block|{
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_TRY_SYNC
index|]
expr_stmt|;
name|state
operator|->
name|flags
operator||=
name|TRY_SYNC
expr_stmt|;
block|}
else|else
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_SIMPLE
index|]
expr_stmt|;
name|state
operator|->
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scsicmd
operator|->
name|flags
operator|&
name|SCSICMD_DATA_TO_DEVICE
condition|)
block|{
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_DATA_OUT
index|]
expr_stmt|;
name|state
operator|->
name|buf
operator|=
name|scsicmd
operator|->
name|buf
expr_stmt|;
name|state
operator|->
name|flags
operator||=
name|DMA_OUT
expr_stmt|;
block|}
else|else
block|{
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_DATA_IN
index|]
expr_stmt|;
name|state
operator|->
name|buf
operator|=
name|scsicmd
operator|->
name|buf
expr_stmt|;
name|state
operator|->
name|flags
operator||=
name|DMA_IN
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|asc_debug_cmd
operator|=
name|scsicmd
operator|->
name|cmd
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|scsicmd
operator|->
name|cmd
index|[
literal|0
index|]
operator|==
name|SCSI_READ_EXT
condition|)
block|{
name|asc_debug_bn
operator|=
operator|(
name|scsicmd
operator|->
name|cmd
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|scsicmd
operator|->
name|cmd
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|scsicmd
operator|->
name|cmd
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|scsicmd
operator|->
name|cmd
index|[
literal|5
index|]
expr_stmt|;
name|asc_debug_sz
operator|=
operator|(
name|scsicmd
operator|->
name|cmd
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
operator||
name|scsicmd
operator|->
name|cmd
index|[
literal|8
index|]
expr_stmt|;
block|}
name|asc_logp
operator|->
name|status
operator|=
name|PACK
argument_list|(
name|asc
operator|-
name|asc_softc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|asc_debug_cmd
argument_list|)
expr_stmt|;
name|asc_logp
operator|->
name|target
operator|=
name|asc
operator|->
name|target
expr_stmt|;
name|asc_logp
operator|->
name|state
operator|=
name|asc
operator|->
name|script
operator|-
name|asc_scripts
expr_stmt|;
name|asc_logp
operator|->
name|msg
operator|=
name|SCSI_DIS_REC_IDENTIFY
expr_stmt|;
name|asc_logp
operator|->
name|resid
operator|=
name|scsicmd
operator|->
name|buflen
expr_stmt|;
if|if
condition|(
operator|++
name|asc_logp
operator|>=
operator|&
name|asc_log
index|[
name|NLOG
index|]
condition|)
name|asc_logp
operator|=
name|asc_log
expr_stmt|;
endif|#
directive|endif
comment|/* preload the FIFO with the message to be sent */
name|regs
operator|->
name|asc_fifo
operator|=
name|SCSI_DIS_REC_IDENTIFY
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* initialize the DMA */
call|(
modifier|*
name|asc
operator|->
name|dma_start
call|)
argument_list|(
name|asc
argument_list|,
name|state
argument_list|,
name|state
operator|->
name|dmaBufAddr
argument_list|,
name|ASCDMA_WRITE
argument_list|)
expr_stmt|;
name|ASC_TC_PUT
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
name|regs
operator|->
name|asc_dbus_id
operator|=
name|target
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_dbus_id
argument_list|)
expr_stmt|;
name|regs
operator|->
name|asc_syn_p
operator|=
name|state
operator|->
name|sync_period
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_syn_p
argument_list|)
expr_stmt|;
name|regs
operator|->
name|asc_syn_o
operator|=
name|state
operator|->
name|sync_offset
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_syn_o
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|TRY_SYNC
condition|)
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_SEL_ATN_STOP
expr_stmt|;
else|else
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_SEL_ATN
operator||
name|ASC_CMD_DMA
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt routine  *	Take interrupts from the chip  *  * Implementation:  *	Move along the current command's script if  *	all is well, invoke error handler if not.  */
end_comment

begin_function
name|void
name|asc_intr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|asc_softc_t
name|asc
init|=
operator|&
name|asc_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
decl_stmt|;
specifier|register
name|script_t
modifier|*
name|scpt
decl_stmt|;
specifier|register
name|int
name|ss
decl_stmt|,
name|ir
decl_stmt|,
name|status
decl_stmt|;
comment|/* collect ephemeral information */
name|status
operator|=
name|regs
operator|->
name|asc_status
expr_stmt|;
name|again
label|:
name|ss
operator|=
name|regs
operator|->
name|asc_ss
expr_stmt|;
name|ir
operator|=
name|regs
operator|->
name|asc_intr
expr_stmt|;
comment|/* this resets the previous two */
name|scpt
operator|=
name|asc
operator|->
name|script
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|asc_logp
operator|->
name|status
operator|=
name|PACK
argument_list|(
name|unit
argument_list|,
name|status
argument_list|,
name|ss
argument_list|,
name|ir
argument_list|)
expr_stmt|;
name|asc_logp
operator|->
name|target
operator|=
operator|(
name|asc
operator|->
name|state
operator|==
name|ASC_STATE_BUSY
operator|)
condition|?
name|asc
operator|->
name|target
else|:
operator|-
literal|1
expr_stmt|;
name|asc_logp
operator|->
name|state
operator|=
name|scpt
operator|-
name|asc_scripts
expr_stmt|;
name|asc_logp
operator|->
name|msg
operator|=
operator|-
literal|1
expr_stmt|;
name|asc_logp
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|asc_logp
operator|>=
operator|&
name|asc_log
index|[
name|NLOG
index|]
condition|)
name|asc_logp
operator|=
name|asc_log
expr_stmt|;
if|if
condition|(
name|asc_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"asc_intr: status %x ss %x ir %x cond %d:%x\n"
argument_list|,
name|status
argument_list|,
name|ss
argument_list|,
name|ir
argument_list|,
name|scpt
operator|-
name|asc_scripts
argument_list|,
name|scpt
operator|->
name|condition
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check the expected state */
if|if
condition|(
name|SCRIPT_MATCH
argument_list|(
name|ir
argument_list|,
name|status
argument_list|)
operator|==
name|scpt
operator|->
name|condition
condition|)
block|{
comment|/* 		 * Perform the appropriate operation, then proceed. 		 */
if|if
condition|(
call|(
modifier|*
name|scpt
operator|->
name|action
call|)
argument_list|(
name|asc
argument_list|,
name|status
argument_list|,
name|ss
argument_list|,
name|ir
argument_list|)
condition|)
block|{
name|regs
operator|->
name|asc_cmd
operator|=
name|scpt
operator|->
name|command
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
name|asc
operator|->
name|script
operator|=
name|scpt
operator|->
name|next
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Check for parity error. 	 * Hardware will automatically set ATN 	 * to request the device for a MSG_OUT phase. 	 */
if|if
condition|(
name|status
operator|&
name|ASC_CSR_PE
condition|)
block|{
name|printf
argument_list|(
literal|"asc%d: SCSI device %d: incomming parity error seen\n"
argument_list|,
name|asc
operator|-
name|asc_softc
argument_list|,
name|asc
operator|->
name|target
argument_list|)
expr_stmt|;
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
operator|.
name|flags
operator||=
name|PARITY_ERR
expr_stmt|;
block|}
comment|/* 	 * Check for gross error. 	 * Probably a bug in a device driver. 	 */
if|if
condition|(
name|status
operator|&
name|ASC_CSR_GE
condition|)
block|{
name|printf
argument_list|(
literal|"asc%d: SCSI device %d: gross error\n"
argument_list|,
name|asc
operator|-
name|asc_softc
argument_list|,
name|asc
operator|->
name|target
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
comment|/* check for message in or out */
if|if
condition|(
operator|(
name|ir
operator|&
operator|~
name|ASC_INT_FC
operator|)
operator|==
name|ASC_INT_BS
condition|)
block|{
specifier|register
name|int
name|len
decl_stmt|,
name|fifo
decl_stmt|;
name|state
operator|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
expr_stmt|;
switch|switch
condition|(
name|ASC_PHASE
argument_list|(
name|status
argument_list|)
condition|)
block|{
case|case
name|ASC_PHASE_DATAI
case|:
case|case
name|ASC_PHASE_DATAO
case|:
name|ASC_TC_GET
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fifo
operator|=
name|regs
operator|->
name|asc_flags
operator|&
name|ASC_FLAGS_FIFO_CNT
expr_stmt|;
name|printf
argument_list|(
literal|"asc_intr: data overrun: buflen %d dmalen %d tc %d fifo %d\n"
argument_list|,
name|state
operator|->
name|buflen
argument_list|,
name|state
operator|->
name|dmalen
argument_list|,
name|len
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
case|case
name|ASC_PHASE_MSG_IN
case|:
break|break;
case|case
name|ASC_PHASE_MSG_OUT
case|:
comment|/* 			 * Check for parity error. 			 * Hardware will automatically set ATN 			 * to request the device for a MSG_OUT phase. 			 */
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|PARITY_ERR
condition|)
block|{
name|state
operator|->
name|flags
operator|&=
operator|~
name|PARITY_ERR
expr_stmt|;
name|state
operator|->
name|msg_out
operator|=
name|SCSI_MESSAGE_PARITY_ERROR
expr_stmt|;
comment|/* reset message in counter */
name|state
operator|->
name|msglen
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|state
operator|->
name|msg_out
operator|=
name|SCSI_NO_OP
expr_stmt|;
name|regs
operator|->
name|asc_fifo
operator|=
name|state
operator|->
name|msg_out
expr_stmt|;
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_XFER_INFO
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|ASC_PHASE_STATUS
case|:
comment|/* probably an error in the SCSI command */
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_GET_STATUS
index|]
expr_stmt|;
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_I_COMPLETE
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
goto|goto
name|abort
goto|;
block|}
if|if
condition|(
name|state
operator|->
name|script
condition|)
goto|goto
name|abort
goto|;
comment|/* check for DMA in progress */
name|ASC_TC_GET
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fifo
operator|=
name|regs
operator|->
name|asc_flags
operator|&
name|ASC_FLAGS_FIFO_CNT
expr_stmt|;
comment|/* flush any data in the FIFO */
if|if
condition|(
name|fifo
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|DMA_OUT
condition|)
name|len
operator|+=
name|fifo
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|DMA_IN
condition|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|;
name|printf
argument_list|(
literal|"asc_intr: IN: dmalen %d len %d fifo %d\n"
argument_list|,
name|state
operator|->
name|dmalen
argument_list|,
name|len
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
comment|/* XXX */
name|len
operator|+=
name|fifo
expr_stmt|;
name|cp
operator|=
name|state
operator|->
name|dmaBufAddr
operator|+
operator|(
name|state
operator|->
name|dmalen
operator|-
name|len
operator|)
expr_stmt|;
while|while
condition|(
name|fifo
operator|--
operator|>
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
name|regs
operator|->
name|asc_fifo
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"asc_intr: dmalen %d len %d fifo %d\n"
argument_list|,
name|state
operator|->
name|dmalen
argument_list|,
name|len
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
comment|/* XXX */
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_FLUSH
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|&&
operator|(
name|state
operator|->
name|flags
operator|&
name|DMA_IN_PROGRESS
operator|)
condition|)
block|{
comment|/* save number of bytes still to be sent or received */
name|state
operator|->
name|dmaresid
operator|=
name|len
expr_stmt|;
name|state
operator|->
name|flags
operator|&=
operator|~
name|DMA_IN_PROGRESS
expr_stmt|;
name|ASC_TC_PUT
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_logp
operator|==
name|asc_log
condition|)
name|asc_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
else|else
name|asc_logp
index|[
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
endif|#
directive|endif
comment|/* setup state to resume to */
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|DMA_IN
condition|)
block|{
comment|/* 				 * Since the ASC_CNFG3_SRB bit of the 				 * cnfg3 register bit is not set, 				 * we just transferred an extra byte. 				 * Since we can't resume on an odd byte 				 * boundary, we copy the valid data out 				 * and resume DMA at the start address. 				 */
if|if
condition|(
name|len
operator|&
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"asc_intr: msg in len %d (fifo %d)\n"
argument_list|,
name|len
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
comment|/* XXX */
name|len
operator|=
name|state
operator|->
name|dmalen
operator|-
name|len
expr_stmt|;
goto|goto
name|do_in
goto|;
block|}
name|state
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_RESUME_DMA_IN
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|DMA_OUT
condition|)
name|state
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_RESUME_DMA_OUT
index|]
expr_stmt|;
else|else
name|state
operator|->
name|script
operator|=
name|asc
operator|->
name|script
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|DMA_IN
condition|)
block|{
if|if
condition|(
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"asc_intr: 1: bn %d len %d (fifo %d)\n"
argument_list|,
name|asc_debug_bn
argument_list|,
name|len
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
comment|/* XXX */
goto|goto
name|abort
goto|;
block|}
comment|/* setup state to resume to */
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|DMA_IN_PROGRESS
condition|)
block|{
name|len
operator|=
name|state
operator|->
name|dmalen
expr_stmt|;
name|state
operator|->
name|flags
operator|&=
operator|~
name|DMA_IN_PROGRESS
expr_stmt|;
name|do_in
label|:
call|(
modifier|*
name|asc
operator|->
name|dma_end
call|)
argument_list|(
name|asc
argument_list|,
name|state
argument_list|,
name|ASCDMA_READ
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|state
operator|->
name|dmaBufAddr
argument_list|,
name|state
operator|->
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|state
operator|->
name|buf
operator|+=
name|len
expr_stmt|;
name|state
operator|->
name|buflen
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|buflen
condition|)
name|state
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_RESUME_IN
index|]
expr_stmt|;
else|else
name|state
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_RESUME_NO_DATA
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|DMA_OUT
condition|)
block|{
if|if
condition|(
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"asc_intr: 2: len %d (fifo %d)\n"
argument_list|,
name|len
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
comment|/* XXX */
goto|goto
name|abort
goto|;
block|}
comment|/* 			 * If this is the last chunk, the next expected 			 * state is to get status. 			 */
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|DMA_IN_PROGRESS
condition|)
block|{
name|state
operator|->
name|flags
operator|&=
operator|~
name|DMA_IN_PROGRESS
expr_stmt|;
call|(
modifier|*
name|asc
operator|->
name|dma_end
call|)
argument_list|(
name|asc
argument_list|,
name|state
argument_list|,
name|ASCDMA_WRITE
argument_list|)
expr_stmt|;
name|len
operator|=
name|state
operator|->
name|dmalen
expr_stmt|;
name|state
operator|->
name|buf
operator|+=
name|len
expr_stmt|;
name|state
operator|->
name|buflen
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|buflen
condition|)
name|state
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_RESUME_OUT
index|]
expr_stmt|;
else|else
name|state
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_RESUME_NO_DATA
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asc
operator|->
name|script
operator|==
operator|&
name|asc_scripts
index|[
name|SCRIPT_SIMPLE
index|]
condition|)
name|state
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_RESUME_NO_DATA
index|]
expr_stmt|;
else|else
name|state
operator|->
name|script
operator|=
name|asc
operator|->
name|script
expr_stmt|;
comment|/* setup to receive a message */
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_MSG_IN
index|]
expr_stmt|;
name|state
operator|->
name|msglen
operator|=
literal|0
expr_stmt|;
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_XFER_INFO
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* check for SCSI bus reset */
if|if
condition|(
name|ir
operator|&
name|ASC_INT_RESET
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"asc%d: SCSI bus reset!!\n"
argument_list|,
name|asc
operator|-
name|asc_softc
argument_list|)
expr_stmt|;
comment|/* need to flush any pending commands */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASC_NCMD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|asc
operator|->
name|cmd
index|[
name|i
index|]
condition|)
continue|continue;
name|asc
operator|->
name|st
index|[
name|i
index|]
operator|.
name|error
operator|=
name|EIO
expr_stmt|;
name|asc_end
argument_list|(
name|asc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* rearbitrate synchronous offset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASC_NCMD
condition|;
name|i
operator|++
control|)
block|{
name|asc
operator|->
name|st
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
literal|0
expr_stmt|;
name|asc
operator|->
name|st
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|asc
operator|->
name|target
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* check for command errors */
if|if
condition|(
name|ir
operator|&
name|ASC_INT_ILL
condition|)
goto|goto
name|abort
goto|;
comment|/* check for disconnect */
if|if
condition|(
name|ir
operator|&
name|ASC_INT_DISC
condition|)
block|{
name|state
operator|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
expr_stmt|;
switch|switch
condition|(
name|ASC_SS
argument_list|(
name|ss
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* device did not respond */
comment|/* check for one of the starting scripts */
switch|switch
condition|(
name|asc
operator|->
name|script
operator|-
name|asc_scripts
condition|)
block|{
case|case
name|SCRIPT_TRY_SYNC
case|:
case|case
name|SCRIPT_SIMPLE
case|:
case|case
name|SCRIPT_DATA_IN
case|:
case|case
name|SCRIPT_DATA_OUT
case|:
if|if
condition|(
name|regs
operator|->
name|asc_flags
operator|&
name|ASC_FLAGS_FIFO_CNT
condition|)
block|{
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_FLUSH
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
block|}
name|state
operator|->
name|error
operator|=
name|ENXIO
expr_stmt|;
name|asc_end
argument_list|(
name|asc
argument_list|,
name|status
argument_list|,
name|ss
argument_list|,
name|ir
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHROUGH */
default|default:
name|printf
argument_list|(
literal|"asc%d: SCSI device %d: unexpected disconnect\n"
argument_list|,
name|asc
operator|-
name|asc_softc
argument_list|,
name|asc
operator|->
name|target
argument_list|)
expr_stmt|;
comment|/* 			 * On rare occasions my RZ24 does a disconnect during 			 * data in phase and the following seems to keep it 			 * happy. 			 * XXX Should a scsi disk ever do this?? 			 */
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_RESEL
index|]
expr_stmt|;
name|asc
operator|->
name|state
operator|=
name|ASC_STATE_RESEL
expr_stmt|;
name|state
operator|->
name|flags
operator||=
name|DISCONN
expr_stmt|;
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_ENABLE_SEL
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* check for reselect */
if|if
condition|(
name|ir
operator|&
name|ASC_INT_RESEL
condition|)
block|{
name|unsigned
name|fifo
decl_stmt|,
name|id
decl_stmt|,
name|msg
decl_stmt|;
name|fifo
operator|=
name|regs
operator|->
name|asc_flags
operator|&
name|ASC_FLAGS_FIFO_CNT
expr_stmt|;
if|if
condition|(
name|fifo
operator|<
literal|2
condition|)
goto|goto
name|abort
goto|;
comment|/* read unencoded SCSI ID and convert to binary */
name|msg
operator|=
name|regs
operator|->
name|asc_fifo
operator|&
name|asc
operator|->
name|myidmask
expr_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
operator|(
name|msg
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|id
operator|++
control|)
name|msg
operator|>>=
literal|1
expr_stmt|;
comment|/* read identify message */
name|msg
operator|=
name|regs
operator|->
name|asc_fifo
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_logp
operator|==
name|asc_log
condition|)
name|asc_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
else|else
name|asc_logp
index|[
operator|-
literal|1
index|]
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
endif|#
directive|endif
name|asc
operator|->
name|state
operator|=
name|ASC_STATE_BUSY
expr_stmt|;
name|asc
operator|->
name|target
operator|=
name|id
expr_stmt|;
name|state
operator|=
operator|&
name|asc
operator|->
name|st
index|[
name|id
index|]
expr_stmt|;
name|asc
operator|->
name|script
operator|=
name|state
operator|->
name|script
expr_stmt|;
name|state
operator|->
name|script
operator|=
operator|(
name|script_t
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|DISCONN
operator|)
condition|)
goto|goto
name|abort
goto|;
name|state
operator|->
name|flags
operator|&=
operator|~
name|DISCONN
expr_stmt|;
name|regs
operator|->
name|asc_syn_p
operator|=
name|state
operator|->
name|sync_period
expr_stmt|;
name|regs
operator|->
name|asc_syn_o
operator|=
name|state
operator|->
name|sync_offset
expr_stmt|;
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_MSG_ACPT
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* check if we are being selected as a target */
if|if
condition|(
name|ir
operator|&
operator|(
name|ASC_INT_SEL
operator||
name|ASC_INT_SEL_ATN
operator|)
condition|)
goto|goto
name|abort
goto|;
comment|/* 	 * 'ir' must be just ASC_INT_FC. 	 * This is normal if canceling an ASC_ENABLE_SEL. 	 */
name|done
label|:
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* watch out for HW race conditions and setup& hold time violations */
name|ir
operator|=
name|regs
operator|->
name|asc_status
expr_stmt|;
while|while
condition|(
name|ir
operator|!=
operator|(
name|status
operator|=
name|regs
operator|->
name|asc_status
operator|)
condition|)
name|ir
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ASC_CSR_INT
condition|)
goto|goto
name|again
goto|;
return|return;
name|abort
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|asc_DumpLog
argument_list|(
literal|"asc_intr"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|panic("asc_intr");
else|#
directive|else
name|boot
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * All the many little things that the interrupt  * routine might switch to.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|script_nop
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_get_status
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|int
name|data
decl_stmt|;
comment|/* 	 * Get the last two bytes in the FIFO. 	 */
if|if
condition|(
operator|(
name|data
operator|=
name|regs
operator|->
name|asc_flags
operator|&
name|ASC_FLAGS_FIFO_CNT
operator|)
operator|!=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"asc_get_status: fifo cnt %d\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* XXX */
name|asc_DumpLog
argument_list|(
literal|"get_status"
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|data
operator|<
literal|2
condition|)
block|{
name|asc
operator|->
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_MSG_ACPT
expr_stmt|;
name|readback
argument_list|(
name|asc
operator|->
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
do|do
block|{
name|data
operator|=
name|regs
operator|->
name|asc_fifo
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|regs
operator|->
name|asc_flags
operator|&
name|ASC_FLAGS_FIFO_CNT
operator|)
operator|>
literal|2
condition|)
do|;
block|}
comment|/* save the status byte */
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
operator|.
name|statusByte
operator|=
name|data
operator|=
name|regs
operator|->
name|asc_fifo
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_logp
operator|==
name|asc_log
condition|)
name|asc_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|msg
operator|=
name|data
expr_stmt|;
else|else
name|asc_logp
index|[
operator|-
literal|1
index|]
operator|.
name|msg
operator|=
name|data
expr_stmt|;
endif|#
directive|endif
comment|/* get the (presumed) command_complete message */
if|if
condition|(
operator|(
name|data
operator|=
name|regs
operator|->
name|asc_fifo
operator|)
operator|==
name|SCSI_COMMAND_COMPLETE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"asc_get_status: status %x cmd %x\n"
argument_list|,
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
operator|.
name|statusByte
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|asc_DumpLog
argument_list|(
literal|"asc_get_status"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_end
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|ScsiCmd
modifier|*
name|scsicmd
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|target
decl_stmt|;
name|asc
operator|->
name|state
operator|=
name|ASC_STATE_IDLE
expr_stmt|;
name|target
operator|=
name|asc
operator|->
name|target
expr_stmt|;
name|asc
operator|->
name|target
operator|=
operator|-
literal|1
expr_stmt|;
name|scsicmd
operator|=
name|asc
operator|->
name|cmd
index|[
name|target
index|]
expr_stmt|;
name|asc
operator|->
name|cmd
index|[
name|target
index|]
operator|=
operator|(
name|ScsiCmd
operator|*
operator|)
literal|0
expr_stmt|;
name|state
operator|=
operator|&
name|asc
operator|->
name|st
index|[
name|target
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"asc_end: %s target %d cmd %x err %d resid %d\n"
argument_list|,
name|scsicmd
operator|->
name|sd
operator|->
name|sd_driver
operator|->
name|d_name
argument_list|,
name|target
argument_list|,
name|scsicmd
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|state
operator|->
name|error
argument_list|,
name|state
operator|->
name|buflen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|target
operator|<
literal|0
operator|||
operator|!
name|scsicmd
condition|)
name|panic
argument_list|(
literal|"asc_end"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* look for disconnected devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASC_NCMD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|asc
operator|->
name|cmd
index|[
name|i
index|]
operator|||
operator|!
operator|(
name|asc
operator|->
name|st
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|DISCONN
operator|)
condition|)
continue|continue;
name|asc
operator|->
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_ENABLE_SEL
expr_stmt|;
name|readback
argument_list|(
name|asc
operator|->
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
name|asc
operator|->
name|state
operator|=
name|ASC_STATE_RESEL
expr_stmt|;
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_RESEL
index|]
expr_stmt|;
break|break;
block|}
comment|/* 	 * Look for another device that is ready. 	 * May want to keep last one started and increment for fairness 	 * rather than always starting at zero. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASC_NCMD
condition|;
name|i
operator|++
control|)
block|{
comment|/* don't restart a disconnected command */
if|if
condition|(
operator|!
name|asc
operator|->
name|cmd
index|[
name|i
index|]
operator|||
operator|(
name|asc
operator|->
name|st
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|DISCONN
operator|)
condition|)
continue|continue;
name|asc_startcmd
argument_list|(
name|asc
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* signal device driver that the command is done */
call|(
modifier|*
name|scsicmd
operator|->
name|sd
operator|->
name|sd_driver
operator|->
name|d_done
call|)
argument_list|(
name|scsicmd
operator|->
name|unit
argument_list|,
name|state
operator|->
name|error
argument_list|,
name|state
operator|->
name|buflen
argument_list|,
name|state
operator|->
name|statusByte
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_dma_in
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
init|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
comment|/* check for previous chunk in buffer */
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|DMA_IN_PROGRESS
condition|)
block|{
comment|/* 		 * Only count bytes that have been copied to memory. 		 * There may be some bytes in the FIFO if synchonous transfers 		 * are in progress. 		 */
call|(
modifier|*
name|asc
operator|->
name|dma_end
call|)
argument_list|(
name|asc
argument_list|,
name|state
argument_list|,
name|ASCDMA_READ
argument_list|)
expr_stmt|;
name|ASC_TC_GET
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|state
operator|->
name|dmalen
operator|-
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|state
operator|->
name|dmaBufAddr
argument_list|,
name|state
operator|->
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|state
operator|->
name|buf
operator|+=
name|len
expr_stmt|;
name|state
operator|->
name|buflen
operator|-=
name|len
expr_stmt|;
block|}
comment|/* setup to start reading the next chunk */
name|len
operator|=
name|state
operator|->
name|buflen
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_logp
operator|==
name|asc_log
condition|)
name|asc_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
else|else
name|asc_logp
index|[
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
name|state
operator|->
name|dmaBufSize
condition|)
name|len
operator|=
name|state
operator|->
name|dmaBufSize
expr_stmt|;
name|state
operator|->
name|dmalen
operator|=
name|len
expr_stmt|;
call|(
modifier|*
name|asc
operator|->
name|dma_start
call|)
argument_list|(
name|asc
argument_list|,
name|state
argument_list|,
name|state
operator|->
name|dmaBufAddr
argument_list|,
name|ASCDMA_READ
argument_list|)
expr_stmt|;
name|ASC_TC_PUT
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"asc_dma_in: buflen %d, len %d\n"
argument_list|,
name|state
operator|->
name|buflen
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check for next chunk */
name|state
operator|->
name|flags
operator||=
name|DMA_IN_PROGRESS
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|state
operator|->
name|buflen
condition|)
block|{
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_CONTINUE_IN
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_last_dma_in
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
init|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|fifo
decl_stmt|;
comment|/* copy data from buffer to main memory */
call|(
modifier|*
name|asc
operator|->
name|dma_end
call|)
argument_list|(
name|asc
argument_list|,
name|state
argument_list|,
name|ASCDMA_READ
argument_list|)
expr_stmt|;
name|ASC_TC_GET
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fifo
operator|=
name|regs
operator|->
name|asc_flags
operator|&
name|ASC_FLAGS_FIFO_CNT
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"asc_last_dma_in: buflen %d dmalen %d tc %d fifo %d\n"
argument_list|,
name|state
operator|->
name|buflen
argument_list|,
name|state
operator|->
name|dmalen
argument_list|,
name|len
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fifo
condition|)
block|{
comment|/* device must be trying to send more than we expect */
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_FLUSH
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
block|}
name|state
operator|->
name|flags
operator|&=
operator|~
name|DMA_IN_PROGRESS
expr_stmt|;
name|len
operator|=
name|state
operator|->
name|dmalen
operator|-
name|len
expr_stmt|;
name|state
operator|->
name|buflen
operator|-=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|state
operator|->
name|dmaBufAddr
argument_list|,
name|state
operator|->
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_resume_in
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
init|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
comment|/* setup to start reading the next chunk */
name|len
operator|=
name|state
operator|->
name|buflen
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_logp
operator|==
name|asc_log
condition|)
name|asc_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
else|else
name|asc_logp
index|[
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
name|state
operator|->
name|dmaBufSize
condition|)
name|len
operator|=
name|state
operator|->
name|dmaBufSize
expr_stmt|;
name|state
operator|->
name|dmalen
operator|=
name|len
expr_stmt|;
call|(
modifier|*
name|asc
operator|->
name|dma_start
call|)
argument_list|(
name|asc
argument_list|,
name|state
argument_list|,
name|state
operator|->
name|dmaBufAddr
argument_list|,
name|ASCDMA_READ
argument_list|)
expr_stmt|;
name|ASC_TC_PUT
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"asc_resume_in: buflen %d, len %d\n"
argument_list|,
name|state
operator|->
name|buflen
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check for next chunk */
name|state
operator|->
name|flags
operator||=
name|DMA_IN_PROGRESS
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|state
operator|->
name|buflen
condition|)
block|{
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_CONTINUE_IN
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_resume_dma_in
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
init|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|off
decl_stmt|;
comment|/* setup to finish reading the current chunk */
name|len
operator|=
name|state
operator|->
name|dmaresid
expr_stmt|;
name|off
operator|=
name|state
operator|->
name|dmalen
operator|-
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|&&
name|state
operator|->
name|sync_offset
condition|)
block|{
name|printf
argument_list|(
literal|"asc_resume_dma_in: odd xfer dmalen %d len %d off %d\n"
argument_list|,
name|state
operator|->
name|dmalen
argument_list|,
name|len
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* XXX */
name|regs
operator|->
name|asc_res_fifo
operator|=
name|state
operator|->
name|dmaBufAddr
index|[
name|off
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_logp
operator|==
name|asc_log
condition|)
name|asc_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
else|else
name|asc_logp
index|[
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|asc
operator|->
name|dma_start
call|)
argument_list|(
name|asc
argument_list|,
name|state
argument_list|,
name|state
operator|->
name|dmaBufAddr
operator|+
name|off
argument_list|,
name|ASCDMA_READ
argument_list|)
expr_stmt|;
name|ASC_TC_PUT
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"asc_resume_dma_in: buflen %d dmalen %d len %d off %d\n"
argument_list|,
name|state
operator|->
name|dmalen
argument_list|,
name|state
operator|->
name|buflen
argument_list|,
name|len
argument_list|,
name|off
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check for next chunk */
name|state
operator|->
name|flags
operator||=
name|DMA_IN_PROGRESS
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dmalen
operator|!=
name|state
operator|->
name|buflen
condition|)
block|{
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_CONTINUE_IN
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_dma_out
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
init|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|fifo
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|DMA_IN_PROGRESS
condition|)
block|{
comment|/* check to be sure previous chunk was finished */
name|ASC_TC_GET
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fifo
operator|=
name|regs
operator|->
name|asc_flags
operator|&
name|ASC_FLAGS_FIFO_CNT
expr_stmt|;
if|if
condition|(
name|len
operator|||
name|fifo
condition|)
name|printf
argument_list|(
literal|"asc_dma_out: buflen %d dmalen %d tc %d fifo %d\n"
argument_list|,
name|state
operator|->
name|buflen
argument_list|,
name|state
operator|->
name|dmalen
argument_list|,
name|len
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
comment|/* XXX */
name|len
operator|+=
name|fifo
expr_stmt|;
name|len
operator|=
name|state
operator|->
name|dmalen
operator|-
name|len
expr_stmt|;
name|state
operator|->
name|buf
operator|+=
name|len
expr_stmt|;
name|state
operator|->
name|buflen
operator|-=
name|len
expr_stmt|;
block|}
comment|/* setup for this chunk */
name|len
operator|=
name|state
operator|->
name|buflen
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_logp
operator|==
name|asc_log
condition|)
name|asc_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
else|else
name|asc_logp
index|[
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
name|state
operator|->
name|dmaBufSize
condition|)
name|len
operator|=
name|state
operator|->
name|dmaBufSize
expr_stmt|;
name|state
operator|->
name|dmalen
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|state
operator|->
name|buf
argument_list|,
name|state
operator|->
name|dmaBufAddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
call|(
modifier|*
name|asc
operator|->
name|dma_start
call|)
argument_list|(
name|asc
argument_list|,
name|state
argument_list|,
name|state
operator|->
name|dmaBufAddr
argument_list|,
name|ASCDMA_WRITE
argument_list|)
expr_stmt|;
name|ASC_TC_PUT
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"asc_dma_out: buflen %d, len %d\n"
argument_list|,
name|state
operator|->
name|buflen
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check for next chunk */
name|state
operator|->
name|flags
operator||=
name|DMA_IN_PROGRESS
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|state
operator|->
name|buflen
condition|)
block|{
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_CONTINUE_OUT
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_last_dma_out
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
init|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|fifo
decl_stmt|;
name|ASC_TC_GET
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fifo
operator|=
name|regs
operator|->
name|asc_flags
operator|&
name|ASC_FLAGS_FIFO_CNT
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"asc_last_dma_out: buflen %d dmalen %d tc %d fifo %d\n"
argument_list|,
name|state
operator|->
name|buflen
argument_list|,
name|state
operator|->
name|dmalen
argument_list|,
name|len
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fifo
condition|)
block|{
name|len
operator|+=
name|fifo
expr_stmt|;
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_FLUSH
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"asc_last_dma_out: buflen %d dmalen %d tc %d fifo %d\n"
argument_list|,
name|state
operator|->
name|buflen
argument_list|,
name|state
operator|->
name|dmalen
argument_list|,
name|len
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
block|}
name|state
operator|->
name|flags
operator|&=
operator|~
name|DMA_IN_PROGRESS
expr_stmt|;
name|len
operator|=
name|state
operator|->
name|dmalen
operator|-
name|len
expr_stmt|;
name|state
operator|->
name|buflen
operator|-=
name|len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_resume_out
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
init|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
comment|/* setup for this chunk */
name|len
operator|=
name|state
operator|->
name|buflen
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_logp
operator|==
name|asc_log
condition|)
name|asc_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
else|else
name|asc_logp
index|[
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
name|state
operator|->
name|dmaBufSize
condition|)
name|len
operator|=
name|state
operator|->
name|dmaBufSize
expr_stmt|;
name|state
operator|->
name|dmalen
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|state
operator|->
name|buf
argument_list|,
name|state
operator|->
name|dmaBufAddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
call|(
modifier|*
name|asc
operator|->
name|dma_start
call|)
argument_list|(
name|asc
argument_list|,
name|state
argument_list|,
name|state
operator|->
name|dmaBufAddr
argument_list|,
name|ASCDMA_WRITE
argument_list|)
expr_stmt|;
name|ASC_TC_PUT
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"asc_resume_out: buflen %d, len %d\n"
argument_list|,
name|state
operator|->
name|buflen
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check for next chunk */
name|state
operator|->
name|flags
operator||=
name|DMA_IN_PROGRESS
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|state
operator|->
name|buflen
condition|)
block|{
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_CONTINUE_OUT
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_resume_dma_out
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
init|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|off
decl_stmt|;
comment|/* setup to finish writing this chunk */
name|len
operator|=
name|state
operator|->
name|dmaresid
expr_stmt|;
name|off
operator|=
name|state
operator|->
name|dmalen
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|&
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"asc_resume_dma_out: odd xfer dmalen %d len %d off %d\n"
argument_list|,
name|state
operator|->
name|dmalen
argument_list|,
name|len
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* XXX */
name|regs
operator|->
name|asc_fifo
operator|=
name|state
operator|->
name|dmaBufAddr
index|[
name|off
index|]
expr_stmt|;
name|off
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_logp
operator|==
name|asc_log
condition|)
name|asc_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
else|else
name|asc_logp
index|[
operator|-
literal|1
index|]
operator|.
name|resid
operator|=
name|len
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|asc
operator|->
name|dma_start
call|)
argument_list|(
name|asc
argument_list|,
name|state
argument_list|,
name|state
operator|->
name|dmaBufAddr
operator|+
name|off
argument_list|,
name|ASCDMA_WRITE
argument_list|)
expr_stmt|;
name|ASC_TC_PUT
argument_list|(
name|regs
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"asc_resume_dma_out: buflen %d dmalen %d len %d off %d\n"
argument_list|,
name|state
operator|->
name|dmalen
argument_list|,
name|state
operator|->
name|buflen
argument_list|,
name|len
argument_list|,
name|off
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check for next chunk */
name|state
operator|->
name|flags
operator||=
name|DMA_IN_PROGRESS
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dmalen
operator|!=
name|state
operator|->
name|buflen
condition|)
block|{
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_XFER_INFO
operator||
name|ASC_CMD_DMA
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_CONTINUE_OUT
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_sendsync
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
init|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
decl_stmt|;
comment|/* send the extended synchronous negotiation message */
name|regs
operator|->
name|asc_fifo
operator|=
name|SCSI_EXTENDED_MSG
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|regs
operator|->
name|asc_fifo
operator|=
literal|3
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|regs
operator|->
name|asc_fifo
operator|=
name|SCSI_SYNCHRONOUS_XFER
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|regs
operator|->
name|asc_fifo
operator|=
name|SCSI_MIN_PERIOD
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|regs
operator|->
name|asc_fifo
operator|=
name|ASC_MAX_OFFSET
expr_stmt|;
comment|/* state to resume after we see the sync reply message */
name|state
operator|->
name|script
operator|=
name|asc
operator|->
name|script
operator|+
literal|2
expr_stmt|;
name|state
operator|->
name|msglen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_replysync
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
init|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"asc_replysync: %x %x\n"
argument_list|,
name|asc_to_scsi_period
index|[
name|state
operator|->
name|sync_period
index|]
operator|*
name|asc
operator|->
name|tb_ticks
argument_list|,
name|state
operator|->
name|sync_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* send synchronous transfer in response to a request */
name|regs
operator|->
name|asc_fifo
operator|=
name|SCSI_EXTENDED_MSG
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|regs
operator|->
name|asc_fifo
operator|=
literal|3
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|regs
operator|->
name|asc_fifo
operator|=
name|SCSI_SYNCHRONOUS_XFER
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|regs
operator|->
name|asc_fifo
operator|=
name|asc_to_scsi_period
index|[
name|state
operator|->
name|sync_period
index|]
operator|*
name|asc
operator|->
name|tb_ticks
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|regs
operator|->
name|asc_fifo
operator|=
name|state
operator|->
name|sync_offset
expr_stmt|;
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_XFER_INFO
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
comment|/* return to the appropriate script */
if|if
condition|(
operator|!
name|state
operator|->
name|script
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|asc_DumpLog
argument_list|(
literal|"asc_replsync"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"asc_replysync"
argument_list|)
expr_stmt|;
block|}
name|asc
operator|->
name|script
operator|=
name|state
operator|->
name|script
expr_stmt|;
name|state
operator|->
name|script
operator|=
operator|(
name|script_t
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_msg_in
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|asc_regmap_t
modifier|*
name|regs
init|=
name|asc
operator|->
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
init|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
decl_stmt|;
specifier|register
name|int
name|msg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* read one message byte */
name|msg
operator|=
name|regs
operator|->
name|asc_fifo
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_logp
operator|==
name|asc_log
condition|)
name|asc_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
else|else
name|asc_logp
index|[
operator|-
literal|1
index|]
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
endif|#
directive|endif
comment|/* check for multi-byte message */
if|if
condition|(
name|state
operator|->
name|msglen
operator|!=
literal|0
condition|)
block|{
comment|/* first byte is the message length */
if|if
condition|(
name|state
operator|->
name|msglen
operator|<
literal|0
condition|)
block|{
name|state
operator|->
name|msglen
operator|=
name|msg
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|state
operator|->
name|msgcnt
operator|>=
name|state
operator|->
name|msglen
condition|)
goto|goto
name|abort
goto|;
name|state
operator|->
name|msg_in
index|[
name|state
operator|->
name|msgcnt
operator|++
index|]
operator|=
name|msg
expr_stmt|;
comment|/* did we just read the last byte of the message? */
if|if
condition|(
name|state
operator|->
name|msgcnt
operator|!=
name|state
operator|->
name|msglen
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* process an extended message */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"asc_msg_in: msg %x %x %x\n"
argument_list|,
name|state
operator|->
name|msg_in
index|[
literal|0
index|]
argument_list|,
name|state
operator|->
name|msg_in
index|[
literal|1
index|]
argument_list|,
name|state
operator|->
name|msg_in
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|state
operator|->
name|msg_in
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SCSI_SYNCHRONOUS_XFER
case|:
name|state
operator|->
name|flags
operator||=
name|DID_SYNC
expr_stmt|;
name|state
operator|->
name|sync_offset
operator|=
name|state
operator|->
name|msg_in
index|[
literal|2
index|]
expr_stmt|;
comment|/* convert SCSI period to ASC period */
name|i
operator|=
name|state
operator|->
name|msg_in
index|[
literal|1
index|]
operator|/
name|asc
operator|->
name|tb_ticks
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|asc
operator|->
name|min_period
condition|)
name|i
operator|=
name|asc
operator|->
name|min_period
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>=
name|asc
operator|->
name|max_period
condition|)
block|{
comment|/* can't do sync transfer, period too long */
name|printf
argument_list|(
literal|"asc%d: SCSI device %d: sync xfer period too long (%d)\n"
argument_list|,
name|asc
operator|-
name|asc_softc
argument_list|,
name|asc
operator|->
name|target
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|asc
operator|->
name|max_period
expr_stmt|;
name|state
operator|->
name|sync_offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|*
name|asc
operator|->
name|tb_ticks
operator|)
operator|!=
name|state
operator|->
name|msg_in
index|[
literal|1
index|]
condition|)
name|i
operator|++
expr_stmt|;
name|state
operator|->
name|sync_period
operator|=
name|i
operator|&
literal|0x1F
expr_stmt|;
comment|/* 			 * If this is a request, check minimums and 			 * send back an acknowledge. 			 */
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|TRY_SYNC
operator|)
condition|)
block|{
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_SET_ATN
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|sync_period
operator|<
name|asc
operator|->
name|min_period
condition|)
name|state
operator|->
name|sync_period
operator|=
name|asc
operator|->
name|min_period
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|sync_offset
operator|>
name|ASC_MAX_OFFSET
condition|)
name|state
operator|->
name|sync_offset
operator|=
name|ASC_MAX_OFFSET
expr_stmt|;
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_REPLY_SYNC
index|]
expr_stmt|;
name|regs
operator|->
name|asc_syn_p
operator|=
name|state
operator|->
name|sync_period
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_syn_p
argument_list|)
expr_stmt|;
name|regs
operator|->
name|asc_syn_o
operator|=
name|state
operator|->
name|sync_offset
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_syn_o
argument_list|)
expr_stmt|;
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_MSG_ACPT
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|regs
operator|->
name|asc_syn_p
operator|=
name|state
operator|->
name|sync_period
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_syn_p
argument_list|)
expr_stmt|;
name|regs
operator|->
name|asc_syn_o
operator|=
name|state
operator|->
name|sync_offset
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_syn_o
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
name|printf
argument_list|(
literal|"asc%d: SCSI device %d: rejecting extended message 0x%x\n"
argument_list|,
name|asc
operator|-
name|asc_softc
argument_list|,
name|asc
operator|->
name|target
argument_list|,
name|state
operator|->
name|msg_in
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
block|}
comment|/* process first byte of a message */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|asc_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"asc_msg_in: msg %x\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|msg
condition|)
block|{
if|#
directive|if
literal|0
block|case SCSI_MESSAGE_REJECT: 		printf(" did not like SYNCH xfer ");
comment|/* XXX */
block|state->flags |= DID_SYNC; 		regs->asc_cmd = ASC_CMD_MSG_ACPT; 		readback(regs->asc_cmd); 		status = asc_wait(regs, ASC_CSR_INT); 		ir = regs->asc_intr;
comment|/* some just break out here, some dont */
block|if (ASC_PHASE(status) == ASC_PHASE_MSG_OUT) { 			regs->asc_fifo = SCSI_ABORT; 			regs->asc_cmd = ASC_CMD_XFER_INFO; 			readback(regs->asc_cmd); 			status = asc_wait(regs, ASC_CSR_INT); 			ir = regs->asc_intr; 		} 		if (ir& ASC_INT_DISC) { 			asc_end(asc, status, 0, ir); 			return (0); 		} 		goto status;
endif|#
directive|endif
case|case
name|SCSI_EXTENDED_MSG
case|:
comment|/* read an extended message */
comment|/* setup to read message length next */
name|state
operator|->
name|msglen
operator|=
operator|-
literal|1
expr_stmt|;
name|state
operator|->
name|msgcnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|SCSI_NO_OP
case|:
break|break;
case|case
name|SCSI_SAVE_DATA_POINTER
case|:
comment|/* expect another message */
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|SCSI_RESTORE_POINTERS
case|:
comment|/* 		 * Need to do the following if resuming synchonous data in 		 * on an odd byte boundary. 		regs->asc_cnfg2 |= ASC_CNFG2_RFB; 		 */
break|break;
case|case
name|SCSI_DISCONNECT
case|:
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|DISCONN
condition|)
goto|goto
name|abort
goto|;
name|state
operator|->
name|flags
operator||=
name|DISCONN
expr_stmt|;
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_MSG_ACPT
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
name|asc
operator|->
name|script
operator|=
operator|&
name|asc_scripts
index|[
name|SCRIPT_DISCONNECT
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"asc%d: SCSI device %d: rejecting message 0x%x\n"
argument_list|,
name|asc
operator|-
name|asc_softc
argument_list|,
name|asc
operator|->
name|target
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|reject
label|:
comment|/* request a message out before acknowledging this message */
name|state
operator|->
name|msg_out
operator|=
name|SCSI_MESSAGE_REJECT
expr_stmt|;
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_SET_ATN
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* return to original script */
name|regs
operator|->
name|asc_cmd
operator|=
name|ASC_CMD_MSG_ACPT
expr_stmt|;
name|readback
argument_list|(
name|regs
operator|->
name|asc_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|script
condition|)
block|{
name|abort
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|asc_DumpLog
argument_list|(
literal|"asc_msg_in"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"asc_msg_in"
argument_list|)
expr_stmt|;
block|}
name|asc
operator|->
name|script
operator|=
name|state
operator|->
name|script
expr_stmt|;
name|state
operator|->
name|script
operator|=
operator|(
name|script_t
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|asc_disconnect
parameter_list|(
name|asc
parameter_list|,
name|status
parameter_list|,
name|ss
parameter_list|,
name|ir
parameter_list|)
specifier|register
name|asc_softc_t
name|asc
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|ss
decl_stmt|,
name|ir
decl_stmt|;
block|{
specifier|register
name|State
modifier|*
name|state
init|=
operator|&
name|asc
operator|->
name|st
index|[
name|asc
operator|->
name|target
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|DISCONN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"asc_disconnect: device %d: DISCONN not set!\n"
argument_list|,
name|asc
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|asc
operator|->
name|target
operator|=
operator|-
literal|1
expr_stmt|;
name|asc
operator|->
name|state
operator|=
name|ASC_STATE_RESEL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * DMA handling routines. For a turbochannel device, just set the dmar.  * For the I/O ASIC, handle the actual DMA interface.  */
end_comment

begin_function
specifier|static
name|void
name|tb_dma_start
parameter_list|(
name|asc
parameter_list|,
name|state
parameter_list|,
name|cp
parameter_list|,
name|flag
parameter_list|)
name|asc_softc_t
name|asc
decl_stmt|;
name|State
modifier|*
name|state
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
if|if
condition|(
name|flag
operator|==
name|ASCDMA_WRITE
condition|)
operator|*
name|asc
operator|->
name|dmar
operator|=
name|ASC_DMAR_WRITE
operator||
name|ASC_DMA_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
else|else
operator|*
name|asc
operator|->
name|dmar
operator|=
name|ASC_DMA_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tb_dma_end
parameter_list|(
name|asc
parameter_list|,
name|state
parameter_list|,
name|flag
parameter_list|)
name|asc_softc_t
name|asc
decl_stmt|;
name|State
modifier|*
name|state
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{  }
end_function

begin_function
specifier|static
name|void
name|asic_dma_start
parameter_list|(
name|asc
parameter_list|,
name|state
parameter_list|,
name|cp
parameter_list|,
name|flag
parameter_list|)
name|asc_softc_t
name|asc
decl_stmt|;
name|State
modifier|*
name|state
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|u_int
modifier|*
name|ssr
init|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|ASIC_REG_CSR
argument_list|(
name|asic_base
argument_list|)
decl_stmt|;
name|u_int
name|phys
decl_stmt|,
name|nphys
decl_stmt|;
comment|/* stop DMA engine first */
operator|*
name|ssr
operator|&=
operator|~
name|ASIC_CSR_DMAEN_SCSI
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|ASIC_REG_SCSI_SCR
argument_list|(
name|asic_base
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
name|phys
operator|=
name|MACH_CACHED_TO_PHYS
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|caddr_t
operator|)
name|pmax_trunc_page
argument_list|(
name|cp
operator|+
name|NBPG
argument_list|)
expr_stmt|;
name|nphys
operator|=
name|MACH_CACHED_TO_PHYS
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|asc
operator|->
name|dma_next
operator|=
name|cp
expr_stmt|;
name|asc
operator|->
name|dma_xfer
operator|=
name|state
operator|->
name|dmalen
operator|-
operator|(
name|nphys
operator|-
name|phys
operator|)
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|ASIC_REG_SCSI_DMAPTR
argument_list|(
name|asic_base
argument_list|)
operator|=
name|ASIC_DMA_ADDR
argument_list|(
name|phys
argument_list|)
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|ASIC_REG_SCSI_DMANPTR
argument_list|(
name|asic_base
argument_list|)
operator|=
name|ASIC_DMA_ADDR
argument_list|(
name|nphys
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|ASCDMA_READ
condition|)
operator|*
name|ssr
operator||=
name|ASIC_CSR_SCSI_DIR
operator||
name|ASIC_CSR_DMAEN_SCSI
expr_stmt|;
else|else
operator|*
name|ssr
operator|=
operator|(
operator|*
name|ssr
operator|&
operator|~
name|ASIC_CSR_SCSI_DIR
operator|)
operator||
name|ASIC_CSR_DMAEN_SCSI
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|asic_dma_end
parameter_list|(
name|asc
parameter_list|,
name|state
parameter_list|,
name|flag
parameter_list|)
name|asc_softc_t
name|asc
decl_stmt|;
name|State
modifier|*
name|state
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|u_int
modifier|*
name|ssr
init|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|ASIC_REG_CSR
argument_list|(
name|asic_base
argument_list|)
decl_stmt|;
specifier|register
specifier|volatile
name|u_int
modifier|*
name|dmap
init|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|ASIC_REG_SCSI_DMAPTR
argument_list|(
name|asic_base
argument_list|)
decl_stmt|;
specifier|register
name|u_short
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|w
decl_stmt|;
name|int
name|nb
decl_stmt|;
operator|*
name|ssr
operator|&=
operator|~
name|ASIC_CSR_DMAEN_SCSI
expr_stmt|;
name|to
operator|=
operator|(
name|u_short
operator|*
operator|)
name|MACH_PHYS_TO_CACHED
argument_list|(
operator|*
name|dmap
operator|>>
literal|3
argument_list|)
expr_stmt|;
operator|*
name|dmap
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|ASIC_REG_SCSI_DMANPTR
argument_list|(
name|asic_base
argument_list|)
operator|)
operator|=
operator|-
literal|1
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|ASCDMA_READ
condition|)
block|{
name|MachFlushDCache
argument_list|(
name|MACH_PHYS_TO_CACHED
argument_list|(
name|MACH_UNCACHED_TO_PHYS
argument_list|(
name|state
operator|->
name|dmaBufAddr
argument_list|)
argument_list|)
argument_list|,
name|state
operator|->
name|dmalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|ASIC_REG_SCSI_SCR
argument_list|(
name|asic_base
argument_list|)
operator|)
condition|)
block|{
comment|/* pick up last upto6 bytes, sigh. */
comment|/* Last byte really xferred is.. */
name|w
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|ASIC_REG_SCSI_SDR0
argument_list|(
name|asic_base
argument_list|)
expr_stmt|;
operator|*
name|to
operator|++
operator|=
name|w
expr_stmt|;
if|if
condition|(
operator|--
name|nb
operator|>
literal|0
condition|)
block|{
name|w
operator|>>=
literal|16
expr_stmt|;
operator|*
name|to
operator|++
operator|=
name|w
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|nb
operator|>
literal|0
condition|)
block|{
name|w
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|ASIC_REG_SCSI_SDR1
argument_list|(
name|asic_base
argument_list|)
expr_stmt|;
operator|*
name|to
operator|++
operator|=
name|w
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * Called by asic_intr() for scsi dma pointer update interrupts.  */
end_comment

begin_function
name|void
name|asc_dma_intr
parameter_list|()
block|{
name|asc_softc_t
name|asc
init|=
operator|&
name|asc_softc
index|[
literal|0
index|]
decl_stmt|;
name|u_int
name|next_phys
decl_stmt|;
name|asc
operator|->
name|dma_xfer
operator|-=
name|NBPG
expr_stmt|;
if|if
condition|(
name|asc
operator|->
name|dma_xfer
operator|<=
operator|-
name|NBPG
condition|)
block|{
specifier|volatile
name|u_int
modifier|*
name|ssr
init|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|ASIC_REG_CSR
argument_list|(
name|asic_base
argument_list|)
decl_stmt|;
operator|*
name|ssr
operator|&=
operator|~
name|ASIC_CSR_DMAEN_SCSI
expr_stmt|;
block|}
else|else
block|{
name|asc
operator|->
name|dma_next
operator|+=
name|NBPG
expr_stmt|;
name|next_phys
operator|=
name|MACH_CACHED_TO_PHYS
argument_list|(
name|asc
operator|->
name|dma_next
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|ASIC_REG_SCSI_DMANPTR
argument_list|(
name|asic_base
argument_list|)
operator|=
name|ASIC_DMA_ADDR
argument_list|(
name|next_phys
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|asc_DumpLog
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|asc_log
modifier|*
name|lp
decl_stmt|;
specifier|register
name|u_int
name|status
decl_stmt|;
name|printf
argument_list|(
literal|"asc: %s: cmd %x bn %d cnt %d\n"
argument_list|,
name|str
argument_list|,
name|asc_debug_cmd
argument_list|,
name|asc_debug_bn
argument_list|,
name|asc_debug_sz
argument_list|)
expr_stmt|;
name|lp
operator|=
name|asc_logp
expr_stmt|;
do|do
block|{
name|status
operator|=
name|lp
operator|->
name|status
expr_stmt|;
name|printf
argument_list|(
literal|"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\n"
argument_list|,
name|status
operator|>>
literal|24
argument_list|,
name|lp
operator|->
name|target
argument_list|,
operator|(
name|status
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|,
operator|(
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|,
name|status
operator|&
literal|0XFF
argument_list|,
name|lp
operator|->
name|state
argument_list|,
name|asc_scripts
index|[
name|lp
operator|->
name|state
index|]
operator|.
name|condition
argument_list|,
name|lp
operator|->
name|msg
argument_list|,
name|lp
operator|->
name|resid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|lp
operator|>=
operator|&
name|asc_log
index|[
name|NLOG
index|]
condition|)
name|lp
operator|=
name|asc_log
expr_stmt|;
block|}
do|while
condition|(
name|lp
operator|!=
name|asc_logp
condition|)
do|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NASC> 0 */
end_comment

end_unit

