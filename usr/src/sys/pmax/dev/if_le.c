begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ralph Campbell and Rick Macklem.  *  * %sccs.include.redist.c%  *  *	@(#)if_le.c	8.3 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<le.h>
end_include

begin_if
if|#
directive|if
name|NLE
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<bpfilter.h>
end_include

begin_comment
comment|/*  * AMD 7990 LANCE  *  * This driver will generate and accept trailer encapsulated packets even  * though it buys us nothing.  The motivation was to avoid incompatibilities  * with VAXen, SUNs, and others that handle and benefit from them.  * This reasoning is dubious.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CCITT
argument_list|)
operator|&&
name|defined
argument_list|(
name|LLC
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/x25.h>
end_include

begin_extern
extern|extern llc_ctlinput(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|cons_rtrequest
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/machConst.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/pmaxtype.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/kn01.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/kmin.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/asic.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/if_lereg.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|leprobe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|leintr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|driver
name|ledriver
init|=
block|{
literal|"le"
block|,
name|leprobe
block|,
literal|0
block|,
literal|0
block|,
name|leintr
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ledebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* console error messages */
end_comment

begin_comment
comment|/*  * Ethernet software status per interface.  *  * Each interface is referenced by a network interface structure,  * le_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  */
end_comment

begin_struct
struct|struct
name|le_softc
block|{
name|struct
name|arpcom
name|sc_ac
decl_stmt|;
comment|/* common Ethernet structures */
define|#
directive|define
name|sc_if
value|sc_ac.ac_if
comment|/* network-visible interface */
define|#
directive|define
name|sc_addr
value|sc_ac.ac_enaddr
comment|/* hardware Ethernet address */
specifier|volatile
name|struct
name|lereg1
modifier|*
name|sc_r1
decl_stmt|;
comment|/* LANCE registers */
specifier|volatile
name|void
modifier|*
name|sc_r2
decl_stmt|;
comment|/* dual-port RAM */
name|int
name|sc_ler2pad
decl_stmt|;
comment|/* Do ring descriptors require short pads? */
name|void
function_decl|(
modifier|*
name|sc_copytobuf
function_decl|)
parameter_list|()
function_decl|;
comment|/* Copy to buffer */
name|void
function_decl|(
modifier|*
name|sc_copyfrombuf
function_decl|)
parameter_list|()
function_decl|;
comment|/* Copy from buffer */
name|void
function_decl|(
modifier|*
name|sc_zerobuf
function_decl|)
parameter_list|()
function_decl|;
comment|/* and Zero bytes in buffer */
name|int
name|sc_rmd
decl_stmt|;
comment|/* predicted next rmd to process */
name|int
name|sc_tmd
decl_stmt|;
comment|/* last tmd processed */
name|int
name|sc_tmdnext
decl_stmt|;
comment|/* next tmd to transmit with */
comment|/* stats */
name|int
name|sc_runt
decl_stmt|;
name|int
name|sc_merr
decl_stmt|;
name|int
name|sc_babl
decl_stmt|;
name|int
name|sc_cerr
decl_stmt|;
name|int
name|sc_miss
decl_stmt|;
name|int
name|sc_rown
decl_stmt|;
name|int
name|sc_xint
decl_stmt|;
name|int
name|sc_uflo
decl_stmt|;
name|int
name|sc_rxlen
decl_stmt|;
name|int
name|sc_rxoff
decl_stmt|;
name|int
name|sc_txoff
decl_stmt|;
name|int
name|sc_busy
decl_stmt|;
name|short
name|sc_iflags
decl_stmt|;
block|}
name|le_softc
index|[
name|NLE
index|]
struct|;
end_struct

begin_comment
comment|/* access LANCE registers */
end_comment

begin_function_decl
specifier|static
name|void
name|lewritereg
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|LERDWR
parameter_list|(
name|cntl
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
value|{ (dst) = (src); DELAY(10); }
end_define

begin_define
define|#
directive|define
name|LEWREG
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|lewritereg(&(dst), (src))
end_define

begin_define
define|#
directive|define
name|CPU_TO_CHIP_ADDR
parameter_list|(
name|cpu
parameter_list|)
define|\
value|((unsigned)(&(((struct lereg2 *)0)->cpu)))
end_define

begin_define
define|#
directive|define
name|LE_OFFSET_RAM
value|0x0
end_define

begin_define
define|#
directive|define
name|LE_OFFSET_LANCE
value|0x100000
end_define

begin_define
define|#
directive|define
name|LE_OFFSET_ROM
value|0x1c0000
end_define

begin_decl_stmt
name|void
name|copytobuf_contig
argument_list|()
decl_stmt|,
name|copyfrombuf_contig
argument_list|()
decl_stmt|,
name|bzerobuf_contig
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|copytobuf_gap2
argument_list|()
decl_stmt|,
name|copyfrombuf_gap2
argument_list|()
decl_stmt|,
name|bzerobuf_gap2
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|copytobuf_gap16
argument_list|()
decl_stmt|,
name|copyfrombuf_gap16
argument_list|()
decl_stmt|,
name|bzerobuf_gap16
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pmax_boardtype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|le_iomem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|asic_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Test to see if device is present.  * Return true if found and initialized ok.  * If interface exists, make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_macro
name|leprobe
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pmax_ctlr
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|volatile
name|struct
name|lereg1
modifier|*
name|ler1
decl_stmt|;
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|dp
operator|->
name|pmax_unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|le
operator|->
name|sc_if
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|extern
name|int
name|leinit
argument_list|()
decl_stmt|,
name|lereset
argument_list|()
decl_stmt|,
name|leioctl
argument_list|()
decl_stmt|,
name|lestart
argument_list|()
decl_stmt|,
name|ether_output
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|pmax_boardtype
condition|)
block|{
case|case
name|DS_PMAX
case|:
name|le
operator|->
name|sc_r1
operator|=
name|ler1
operator|=
operator|(
specifier|volatile
expr|struct
name|lereg1
operator|*
operator|)
name|dp
operator|->
name|pmax_addr
expr_stmt|;
name|le
operator|->
name|sc_r2
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
literal|0x19000000
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN01_SYS_CLOCK
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|le
operator|->
name|sc_ler2pad
operator|=
literal|1
expr_stmt|;
name|le
operator|->
name|sc_copytobuf
operator|=
name|copytobuf_gap2
expr_stmt|;
name|le
operator|->
name|sc_copyfrombuf
operator|=
name|copyfrombuf_gap2
expr_stmt|;
name|le
operator|->
name|sc_zerobuf
operator|=
name|bzerobuf_gap2
expr_stmt|;
break|break;
case|case
name|DS_3MIN
case|:
case|case
name|DS_MAXINE
case|:
case|case
name|DS_3MAXPLUS
case|:
if|if
condition|(
name|dp
operator|->
name|pmax_unit
operator|==
literal|0
condition|)
block|{
specifier|volatile
name|u_int
modifier|*
name|ssr
decl_stmt|,
modifier|*
name|ldp
decl_stmt|;
name|le
operator|->
name|sc_r1
operator|=
name|ler1
operator|=
operator|(
specifier|volatile
expr|struct
name|lereg1
operator|*
operator|)
name|ASIC_SYS_LANCE
argument_list|(
name|asic_base
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ASIC_SYS_ETHER_ADDRESS
argument_list|(
name|asic_base
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_r2
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|le_iomem
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_ler2pad
operator|=
literal|1
expr_stmt|;
name|le
operator|->
name|sc_copytobuf
operator|=
name|copytobuf_gap16
expr_stmt|;
name|le
operator|->
name|sc_copyfrombuf
operator|=
name|copyfrombuf_gap16
expr_stmt|;
name|le
operator|->
name|sc_zerobuf
operator|=
name|bzerobuf_gap16
expr_stmt|;
comment|/* 			 * And enable Lance dma through the asic. 			 */
name|ssr
operator|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|ASIC_REG_CSR
argument_list|(
name|asic_base
argument_list|)
expr_stmt|;
name|ldp
operator|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|ASIC_REG_LANCE_DMAPTR
argument_list|(
name|asic_base
argument_list|)
expr_stmt|;
operator|*
name|ldp
operator|=
operator|(
name|le_iomem
operator|<<
literal|3
operator|)
expr_stmt|;
comment|/* phys addr<< 3 */
operator|*
name|ssr
operator||=
name|ASIC_CSR_DMAEN_LANCE
expr_stmt|;
break|break;
block|}
comment|/* 		 * Units other than 0 are turbochannel option boards and fall 		 * through to DS_3MAX. 		 */
case|case
name|DS_3MAX
case|:
name|le
operator|->
name|sc_r1
operator|=
name|ler1
operator|=
operator|(
specifier|volatile
expr|struct
name|lereg1
operator|*
operator|)
operator|(
name|dp
operator|->
name|pmax_addr
operator|+
name|LE_OFFSET_LANCE
operator|)
expr_stmt|;
name|le
operator|->
name|sc_r2
operator|=
operator|(
specifier|volatile
name|void
operator|*
operator|)
operator|(
name|dp
operator|->
name|pmax_addr
operator|+
name|LE_OFFSET_RAM
operator|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|dp
operator|->
name|pmax_addr
operator|+
name|LE_OFFSET_ROM
operator|+
literal|2
operator|)
expr_stmt|;
name|le
operator|->
name|sc_ler2pad
operator|=
literal|0
expr_stmt|;
name|le
operator|->
name|sc_copytobuf
operator|=
name|copytobuf_contig
expr_stmt|;
name|le
operator|->
name|sc_copyfrombuf
operator|=
name|copyfrombuf_contig
expr_stmt|;
name|le
operator|->
name|sc_zerobuf
operator|=
name|bzerobuf_contig
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown CPU board type %d\n"
argument_list|,
name|pmax_boardtype
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	 * Get the ethernet address out of rom 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|le
operator|->
name|sc_addr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|le
operator|->
name|sc_addr
index|[
name|i
index|]
operator|=
operator|*
name|cp
expr_stmt|;
name|cp
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* make sure the chip is stopped */
name|LEWREG
argument_list|(
name|LE_CSR0
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LEWREG
argument_list|(
name|LE_STOP
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|dp
operator|->
name|pmax_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"le"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|leinit
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|lereset
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|leioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|lestart
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTICAST
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|ifp
operator|->
name|if_bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"le%d at nexus0 csr 0x%x priority %d ethernet address %s\n"
argument_list|,
name|dp
operator|->
name|pmax_unit
argument_list|,
name|dp
operator|->
name|pmax_addr
argument_list|,
name|dp
operator|->
name|pmax_pri
argument_list|,
name|ether_sprintf
argument_list|(
name|le
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|MULTICAST
end_ifdef

begin_comment
comment|/*  * Setup the logical address filter  */
end_comment

begin_function
name|void
name|lesetladrf
parameter_list|(
name|le
parameter_list|)
specifier|register
name|struct
name|le_softc
modifier|*
name|le
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|lereg2
modifier|*
name|ler2
init|=
name|le
operator|->
name|sc_r2
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|le
operator|->
name|sc_if
decl_stmt|;
specifier|register
name|struct
name|ether_multi
modifier|*
name|enm
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|u_long
name|crc
decl_stmt|;
specifier|register
name|u_long
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|ether_multistep
name|step
decl_stmt|;
comment|/* 	 * Set up multicast address filter by passing all multicast 	 * addresses through a crc generator, and then using the high 	 * order 6 bits as an index into the 64 bit logical address 	 * filter. The high order two bits select the word, while the 	 * rest of the bits select the bit within the word. 	 */
name|LER2_ladrf0
argument_list|(
name|ler2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LER2_ladrf1
argument_list|(
name|ler2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_ALLMULTI
expr_stmt|;
name|ETHER_FIRST_MULTI
argument_list|(
name|step
argument_list|,
operator|&
name|le
operator|->
name|sc_ac
argument_list|,
name|enm
argument_list|)
expr_stmt|;
while|while
condition|(
name|enm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|enm
operator|->
name|enm_addrlo
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|enm
operator|->
name|enm_addrhi
argument_list|,
sizeof|sizeof
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We must listen to a range of multicast 			 * addresses. For now, just accept all 			 * multicasts, rather than trying to set only 			 * those filter bits needed to match the range. 			 * (At this time, the only use of address 			 * ranges is for IP multicast routing, for 			 * which the range is big enough to require all 			 * bits set.) 			 */
name|LER2_ladrf0
argument_list|(
name|ler2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|LER2_ladrf1
argument_list|(
name|ler2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|LER2_ladrf2
argument_list|(
name|ler2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|LER2_ladrf3
argument_list|(
name|ler2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
return|return;
block|}
name|cp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|enm
operator|->
name|enm_addrlo
expr_stmt|;
name|c
operator|=
operator|*
name|cp
expr_stmt|;
name|crc
operator|=
literal|0xffffffff
expr_stmt|;
name|len
operator|=
literal|6
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|cp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|&
literal|0x01
operator|)
operator|^
operator|(
name|crc
operator|&
literal|0x01
operator|)
condition|)
block|{
name|crc
operator|>>=
literal|1
expr_stmt|;
name|crc
operator|=
name|crc
operator|^
literal|0xedb88320
expr_stmt|;
block|}
else|else
name|crc
operator|>>=
literal|1
expr_stmt|;
name|c
operator|>>=
literal|1
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
comment|/* Just want the 6 most significant bits. */
name|crc
operator|=
name|crc
operator|>>
literal|26
expr_stmt|;
comment|/* Turn on the corresponding bit in the filter. */
switch|switch
condition|(
name|crc
operator|>>
literal|5
condition|)
block|{
case|case
literal|0
case|:
name|LER2_ladrf0
argument_list|(
name|ler2
argument_list|,
literal|1
operator|<<
operator|(
name|crc
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|LER2_ladrf1
argument_list|(
name|ler2
argument_list|,
literal|1
operator|<<
operator|(
name|crc
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|LER2_ladrf2
argument_list|(
name|ler2
argument_list|,
literal|1
operator|<<
operator|(
name|crc
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|LER2_ladrf3
argument_list|(
name|ler2
argument_list|,
literal|1
operator|<<
operator|(
name|crc
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
block|}
name|ETHER_NEXT_MULTI
argument_list|(
name|step
argument_list|,
name|enm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|ledrinit
argument_list|(
argument|le
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|le_softc
modifier|*
name|le
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
specifier|volatile
name|void
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LERBUF
condition|;
name|i
operator|++
control|)
block|{
name|rp
operator|=
name|LER2_RMDADDR
argument_list|(
name|le
operator|->
name|sc_r2
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|LER2_rmd0
argument_list|(
name|rp
argument_list|,
name|CPU_TO_CHIP_ADDR
argument_list|(
name|ler2_rbuf
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|LER2_rmd1
argument_list|(
name|rp
argument_list|,
name|LE_OWN
argument_list|)
expr_stmt|;
name|LER2_rmd2
argument_list|(
name|rp
argument_list|,
operator|-
name|LEMTU
argument_list|)
expr_stmt|;
name|LER2_rmd3
argument_list|(
name|rp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LETBUF
condition|;
name|i
operator|++
control|)
block|{
name|rp
operator|=
name|LER2_TMDADDR
argument_list|(
name|le
operator|->
name|sc_r2
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|LER2_tmd0
argument_list|(
name|rp
argument_list|,
name|CPU_TO_CHIP_ADDR
argument_list|(
name|ler2_tbuf
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|LER2_tmd1
argument_list|(
name|rp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LER2_tmd2
argument_list|(
name|rp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LER2_tmd3
argument_list|(
name|rp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|lereset
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lereg1
modifier|*
name|ler1
init|=
name|le
operator|->
name|sc_r1
decl_stmt|;
specifier|register
specifier|volatile
name|void
modifier|*
name|ler2
init|=
name|le
operator|->
name|sc_r2
decl_stmt|;
specifier|register
name|int
name|timo
init|=
literal|100000
decl_stmt|;
specifier|register
name|int
name|stat
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|stat
operator|=
name|unit
expr_stmt|;
endif|#
directive|endif
name|LEWREG
argument_list|(
name|LE_CSR0
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LEWREG
argument_list|(
name|LE_STOP
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
comment|/* 	 * Setup for transmit/receive 	 */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
comment|/* set the promiscuous bit */
name|LER2_mode
argument_list|(
name|ler2
argument_list|,
name|LE_MODE
operator||
literal|0x8000
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|LER2_mode
argument_list|(
name|ler2
argument_list|,
name|LE_MODE
argument_list|)
expr_stmt|;
name|LER2_padr0
argument_list|(
name|ler2
argument_list|,
operator|(
name|le
operator|->
name|sc_addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|le
operator|->
name|sc_addr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|LER2_padr1
argument_list|(
name|ler2
argument_list|,
operator|(
name|le
operator|->
name|sc_addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|le
operator|->
name|sc_addr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|LER2_padr2
argument_list|(
name|ler2
argument_list|,
operator|(
name|le
operator|->
name|sc_addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|le
operator|->
name|sc_addr
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* Setup the logical address filter */
ifdef|#
directive|ifdef
name|MULTICAST
name|lesetladrf
argument_list|(
name|le
argument_list|)
expr_stmt|;
else|#
directive|else
name|LER2_ladrf0
argument_list|(
name|ler2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LER2_ladrf1
argument_list|(
name|ler2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LER2_ladrf2
argument_list|(
name|ler2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LER2_ladrf3
argument_list|(
name|ler2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LER2_rlen
argument_list|(
name|ler2
argument_list|,
name|LE_RLEN
argument_list|)
expr_stmt|;
name|LER2_rdra
argument_list|(
name|ler2
argument_list|,
name|CPU_TO_CHIP_ADDR
argument_list|(
name|ler2_rmd
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|LER2_tlen
argument_list|(
name|ler2
argument_list|,
name|LE_TLEN
argument_list|)
expr_stmt|;
name|LER2_tdra
argument_list|(
name|ler2
argument_list|,
name|CPU_TO_CHIP_ADDR
argument_list|(
name|ler2_tmd
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ledrinit
argument_list|(
name|le
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_rmd
operator|=
literal|0
expr_stmt|;
name|le
operator|->
name|sc_tmd
operator|=
name|LETBUF
operator|-
literal|1
expr_stmt|;
name|le
operator|->
name|sc_tmdnext
operator|=
literal|0
expr_stmt|;
name|LEWREG
argument_list|(
name|LE_CSR1
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LEWREG
argument_list|(
name|CPU_TO_CHIP_ADDR
argument_list|(
name|ler2_mode
argument_list|)
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LEWREG
argument_list|(
name|LE_CSR2
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LEWREG
argument_list|(
literal|0
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LEWREG
argument_list|(
name|LE_CSR3
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LEWREG
argument_list|(
literal|0
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LEWREG
argument_list|(
name|LE_CSR0
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_INIT
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|--
name|timo
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"le%d: init timeout, stat = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
block|}
name|stat
operator|=
name|ler1
operator|->
name|ler1_rdp
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|stat
operator|&
name|LE_IDON
operator|)
operator|==
literal|0
condition|)
do|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_IDON
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_STRT
operator||
name|LE_INEA
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialization of interface  */
end_comment

begin_macro
name|leinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
operator|.
name|sc_if
decl_stmt|;
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* not yet, if address still unknown */
for|for
control|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
init|;
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
if|if
condition|(
name|ifa
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|&&
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
break|break;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lestart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|LENEXTTMP
define|\
value|if (++bix == LETBUF) \ 		bix = 0; \ 	tmd = LER2_TMDADDR(le->sc_r2, bix)
end_define

begin_comment
comment|/*  * Start output on interface.  Get another datagram to send  * off of the interface queue, and copy it to the interface  * before starting the output.  */
end_comment

begin_macro
name|lestart
argument_list|(
argument|ifp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|int
name|bix
init|=
name|le
operator|->
name|sc_tmdnext
decl_stmt|;
specifier|register
specifier|volatile
name|void
modifier|*
name|tmd
init|=
name|LER2_TMDADDR
argument_list|(
name|le
operator|->
name|sc_r2
argument_list|,
name|bix
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|bix
operator|!=
name|le
operator|->
name|sc_tmd
condition|)
block|{
if|if
condition|(
name|LER2V_tmd1
argument_list|(
name|tmd
argument_list|)
operator|&
name|LE_OWN
condition|)
name|panic
argument_list|(
literal|"lestart"
argument_list|)
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|le
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 		 * If bpf is listening on this interface, let it 		 * see the packet before we commit it to the wire. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|leput
argument_list|(
name|le
argument_list|,
name|LER2_TBUFADDR
argument_list|(
name|le
operator|->
name|sc_r2
argument_list|,
name|bix
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|LER2_tmd3
argument_list|(
name|tmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LER2_tmd2
argument_list|(
name|tmd
argument_list|,
operator|-
name|len
argument_list|)
expr_stmt|;
name|LER2_tmd1
argument_list|(
name|tmd
argument_list|,
name|LE_OWN
operator||
name|LE_STP
operator||
name|LE_ENP
argument_list|)
expr_stmt|;
name|LENEXTTMP
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_TDMD
operator||
name|LE_INEA
argument_list|,
name|le
operator|->
name|sc_r1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
block|}
name|le
operator|->
name|sc_tmdnext
operator|=
name|bix
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Process interrupts from the 7990 chip.  */
end_comment

begin_function
name|void
name|leintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lereg1
modifier|*
name|ler1
decl_stmt|;
specifier|register
name|int
name|stat
decl_stmt|;
name|le
operator|=
operator|&
name|le_softc
index|[
name|unit
index|]
expr_stmt|;
name|ler1
operator|=
name|le
operator|->
name|sc_r1
expr_stmt|;
name|stat
operator|=
name|ler1
operator|->
name|ler1_rdp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|LE_INTR
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"le%d: spurrious interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat
operator|&
name|LE_SERR
condition|)
block|{
name|leerror
argument_list|(
name|unit
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|LE_MERR
condition|)
block|{
name|le
operator|->
name|sc_merr
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat
operator|&
name|LE_BABL
condition|)
name|le
operator|->
name|sc_babl
operator|++
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|LE_CERR
condition|)
name|le
operator|->
name|sc_cerr
operator|++
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|LE_MISS
condition|)
name|le
operator|->
name|sc_miss
operator|++
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_BABL
operator||
name|LE_CERR
operator||
name|LE_MISS
operator||
name|LE_INEA
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|LE_RXON
operator|)
operator|==
literal|0
condition|)
block|{
name|le
operator|->
name|sc_rxoff
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|LE_TXON
operator|)
operator|==
literal|0
condition|)
block|{
name|le
operator|->
name|sc_txoff
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat
operator|&
name|LE_RINT
condition|)
block|{
comment|/* interrupt is cleared in lerint */
name|lerint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|LE_TINT
condition|)
block|{
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_TINT
operator||
name|LE_INEA
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|lexint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Ethernet interface transmitter interrupt.  * Start another output if more data to send.  */
end_comment

begin_expr_stmt
name|lexint
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|bix
init|=
name|le
operator|->
name|sc_tmd
decl_stmt|;
specifier|register
specifier|volatile
name|void
modifier|*
name|tmd
decl_stmt|;
if|if
condition|(
operator|(
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|le
operator|->
name|sc_xint
operator|++
expr_stmt|;
return|return;
block|}
name|LENEXTTMP
expr_stmt|;
while|while
condition|(
name|bix
operator|!=
name|le
operator|->
name|sc_tmdnext
operator|&&
operator|(
name|LER2V_tmd1
argument_list|(
name|tmd
argument_list|)
operator|&
name|LE_OWN
operator|)
operator|==
literal|0
condition|)
block|{
name|le
operator|->
name|sc_tmd
operator|=
name|bix
expr_stmt|;
if|if
condition|(
operator|(
name|LER2V_tmd1
argument_list|(
name|tmd
argument_list|)
operator|&
name|LE_ERR
operator|)
operator|||
operator|(
name|LER2V_tmd3
argument_list|(
name|tmd
argument_list|)
operator|&
name|LE_TBUFF
operator|)
condition|)
block|{
name|lexerror
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|LER2V_tmd3
argument_list|(
name|tmd
argument_list|)
operator|&
operator|(
name|LE_TBUFF
operator||
name|LE_UFLO
operator|)
condition|)
block|{
name|le
operator|->
name|sc_uflo
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|LER2V_tmd3
argument_list|(
name|tmd
argument_list|)
operator|&
name|LE_LCOL
condition|)
name|le
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|LER2V_tmd3
argument_list|(
name|tmd
argument_list|)
operator|&
name|LE_RTRY
condition|)
name|le
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LER2V_tmd1
argument_list|(
name|tmd
argument_list|)
operator|&
name|LE_ONE
condition|)
name|le
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|LER2V_tmd1
argument_list|(
name|tmd
argument_list|)
operator|&
name|LE_MORE
condition|)
comment|/* what is the real number? */
name|le
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
literal|2
expr_stmt|;
else|else
name|le
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|LENEXTTMP
expr_stmt|;
block|}
if|if
condition|(
name|bix
operator|==
name|le
operator|->
name|sc_tmdnext
condition|)
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
operator|(
name|void
operator|)
name|lestart
argument_list|(
operator|&
name|le
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|LENEXTRMP
define|\
value|if (++bix == LERBUF) \ 		bix = 0; \ 	rmd = LER2_RMDADDR(le->sc_r2, bix)
end_define

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  * If input error just drop packet.  * Decapsulate packet based on type and pass to type specific  * higher-level input routine.  */
end_comment

begin_macro
name|lerint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|bix
init|=
name|le
operator|->
name|sc_rmd
decl_stmt|;
specifier|register
specifier|volatile
name|void
modifier|*
name|rmd
init|=
name|LER2_RMDADDR
argument_list|(
name|le
operator|->
name|sc_r2
argument_list|,
name|bix
argument_list|)
decl_stmt|;
comment|/* 	 * Out of sync with hardware, should never happen? 	 */
if|if
condition|(
name|LER2V_rmd1
argument_list|(
name|rmd
argument_list|)
operator|&
name|LE_OWN
condition|)
block|{
name|le
operator|->
name|sc_rown
operator|++
expr_stmt|;
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_RINT
operator||
name|LE_INEA
argument_list|,
name|le
operator|->
name|sc_r1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Process all buffers with valid data 	 */
while|while
condition|(
operator|(
name|LER2V_rmd1
argument_list|(
name|rmd
argument_list|)
operator|&
name|LE_OWN
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
init|=
name|LER2V_rmd3
argument_list|(
name|rmd
argument_list|)
decl_stmt|;
comment|/* Clear interrupt to avoid race condition */
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_RINT
operator||
name|LE_INEA
argument_list|,
name|le
operator|->
name|sc_r1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|LER2V_rmd1
argument_list|(
name|rmd
argument_list|)
operator|&
name|LE_ERR
condition|)
block|{
name|le
operator|->
name|sc_rmd
operator|=
name|bix
expr_stmt|;
name|lererror
argument_list|(
name|unit
argument_list|,
literal|"bad packet"
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|LER2V_rmd1
argument_list|(
name|rmd
argument_list|)
operator|&
operator|(
name|LE_STP
operator||
name|LE_ENP
operator|)
operator|)
operator|!=
operator|(
name|LE_STP
operator||
name|LE_ENP
operator|)
condition|)
block|{
comment|/* 			 * Find the end of the packet so we can see how long 			 * it was.  We still throw it away. 			 */
do|do
block|{
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_RINT
operator||
name|LE_INEA
argument_list|,
name|le
operator|->
name|sc_r1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LER2_rmd3
argument_list|(
name|rmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LER2_rmd1
argument_list|(
name|rmd
argument_list|,
name|LE_OWN
argument_list|)
expr_stmt|;
name|LENEXTRMP
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|LER2V_rmd1
argument_list|(
name|rmd
argument_list|)
operator|&
operator|(
name|LE_OWN
operator||
name|LE_ERR
operator||
name|LE_STP
operator||
name|LE_ENP
operator|)
operator|)
condition|)
do|;
name|le
operator|->
name|sc_rmd
operator|=
name|bix
expr_stmt|;
name|lererror
argument_list|(
name|unit
argument_list|,
literal|"chained buffer"
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_rxlen
operator|++
expr_stmt|;
comment|/* 			 * If search terminated without successful completion 			 * we reset the hardware (conservative). 			 */
if|if
condition|(
operator|(
name|LER2V_rmd1
argument_list|(
name|rmd
argument_list|)
operator|&
operator|(
name|LE_OWN
operator||
name|LE_ERR
operator||
name|LE_STP
operator||
name|LE_ENP
operator|)
operator|)
operator|!=
name|LE_ENP
condition|)
block|{
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|leread
argument_list|(
name|unit
argument_list|,
name|LER2_RBUFADDR
argument_list|(
name|le
operator|->
name|sc_r2
argument_list|,
name|bix
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|LER2_rmd3
argument_list|(
name|rmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LER2_rmd1
argument_list|(
name|rmd
argument_list|,
name|LE_OWN
argument_list|)
expr_stmt|;
name|LENEXTRMP
expr_stmt|;
block|}
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* Paranoia */
name|le
operator|->
name|sc_rmd
operator|=
name|bix
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Look at the packet in network buffer memory so we can be smart about how  * we copy the data into mbufs.  * This needs work since we can't just read network buffer memory like  * regular memory.  */
end_comment

begin_macro
name|leread
argument_list|(
argument|unit
argument_list|,
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|void
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ether_header
name|et
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|,
name|resid
decl_stmt|,
name|flags
decl_stmt|;
name|u_short
name|sbuf
index|[
literal|2
index|]
decl_stmt|,
name|eth_type
decl_stmt|;
specifier|extern
name|struct
name|mbuf
modifier|*
name|leget
parameter_list|()
function_decl|;
name|le
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
call|(
modifier|*
name|le
operator|->
name|sc_copyfrombuf
call|)
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|et
argument_list|,
sizeof|sizeof
argument_list|(
name|et
argument_list|)
argument_list|)
expr_stmt|;
name|eth_type
operator|=
name|ntohs
argument_list|(
name|et
operator|.
name|ether_type
argument_list|)
expr_stmt|;
comment|/* adjust input length to account for header and CRC */
name|len
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|eth_type
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|eth_type
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|off
operator|=
operator|(
name|eth_type
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|*
literal|512
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|ETHERMTU
condition|)
return|return;
comment|/* sanity */
call|(
modifier|*
name|le
operator|->
name|sc_copyfrombuf
call|)
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|et
argument_list|)
operator|+
name|off
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|eth_type
operator|=
name|ntohs
argument_list|(
name|sbuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ntohs
argument_list|(
name|sbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|resid
operator|>
name|len
condition|)
return|return;
comment|/* sanity */
name|len
operator|=
name|off
operator|+
name|resid
expr_stmt|;
block|}
else|else
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|ledebug
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"le%d: ierror(runt packet): from %s: len=%d\n"
argument_list|,
name|unit
argument_list|,
name|ether_sprintf
argument_list|(
name|et
operator|.
name|ether_shost
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_runt
operator|++
expr_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|etherbroadcastaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|et
operator|.
name|ether_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|etherbroadcastaddr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|M_BCAST
expr_stmt|;
if|if
condition|(
name|et
operator|.
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
condition|)
name|flags
operator||=
name|M_MCAST
expr_stmt|;
comment|/* 	 * Pull packet off interface.  Off is nonzero if packet 	 * has trailing header; leget will then force this header 	 * information to be at the front, but we still have to drop 	 * the type and length which are at the front of any trailer data. 	 */
name|m
operator|=
name|leget
argument_list|(
name|le
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
operator|&
name|le
operator|->
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Check if there's a bpf filter listening on this interface. 	 * If so, hand off the raw packet to enet. 	 */
if|if
condition|(
name|le
operator|->
name|sc_if
operator|.
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|le
operator|->
name|sc_if
operator|.
name|if_bpf
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * Keep the packet if it's a broadcast or has our 		 * physical ethernet address (or if we support 		 * multicast and it's one). 		 */
if|if
condition|(
ifdef|#
directive|ifdef
name|MULTICAST
operator|(
name|flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
operator|&&
else|#
directive|else
operator|(
name|flags
operator|&
name|M_BCAST
operator|)
operator|==
literal|0
operator|&&
endif|#
directive|endif
name|bcmp
argument_list|(
name|et
operator|.
name|ether_dhost
argument_list|,
name|le
operator|->
name|sc_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|et
operator|.
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|m
operator|->
name|m_flags
operator||=
name|flags
expr_stmt|;
name|et
operator|.
name|ether_type
operator|=
name|eth_type
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|le
operator|->
name|sc_if
argument_list|,
operator|&
name|et
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Routine to copy from mbuf chain to transmit buffer in  * network buffer memory.  */
end_comment

begin_macro
name|leput
argument_list|(
argument|le
argument_list|,
argument|lebuf
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|le_softc
modifier|*
name|le
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
specifier|volatile
name|void
modifier|*
name|lebuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|tlen
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|boff
init|=
literal|0
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
call|(
modifier|*
name|le
operator|->
name|sc_copytobuf
call|)
argument_list|(
name|mtod
argument_list|(
name|mp
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|lebuf
argument_list|,
name|boff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tlen
operator|+=
name|len
expr_stmt|;
name|boff
operator|+=
name|len
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|<
name|LEMINSIZE
condition|)
block|{
call|(
modifier|*
name|le
operator|->
name|sc_zerobuf
call|)
argument_list|(
name|lebuf
argument_list|,
name|boff
argument_list|,
name|LEMINSIZE
operator|-
name|tlen
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|LEMINSIZE
expr_stmt|;
block|}
return|return
operator|(
name|tlen
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Routine to copy from network buffer memory into mbufs.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|leget
parameter_list|(
name|le
parameter_list|,
name|lebuf
parameter_list|,
name|totlen
parameter_list|,
name|off
parameter_list|,
name|ifp
parameter_list|)
name|struct
name|le_softc
modifier|*
name|le
decl_stmt|;
specifier|volatile
name|void
modifier|*
name|lebuf
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|off
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
init|=
literal|0
decl_stmt|,
modifier|*
modifier|*
name|mp
init|=
operator|&
name|top
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|resid
decl_stmt|,
name|boff
decl_stmt|;
comment|/* NOTE: sizeof(struct ether_header) should be even */
name|boff
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
condition|)
block|{
comment|/* NOTE: off should be even */
name|boff
operator|+=
name|off
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|totlen
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|resid
operator|=
name|totlen
operator|-
name|off
expr_stmt|;
block|}
else|else
name|resid
operator|=
name|totlen
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|resid
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|resid
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|resid
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
comment|/* 			 * Place initial small packet/header at end of mbuf. 			 */
if|if
condition|(
name|top
operator|==
literal|0
operator|&&
name|resid
operator|+
name|max_linkhdr
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|resid
expr_stmt|;
block|}
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
call|(
modifier|*
name|le
operator|->
name|sc_copyfrombuf
call|)
argument_list|(
name|lebuf
argument_list|,
name|boff
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|boff
operator|+=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
name|resid
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|resid
operator|==
literal|0
condition|)
block|{
name|boff
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|resid
operator|=
name|totlen
expr_stmt|;
block|}
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|leioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|volatile
name|struct
name|lereg1
modifier|*
name|ler1
init|=
name|le
operator|->
name|sc_r1
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|le
operator|->
name|sc_addr
operator|)
expr_stmt|;
else|else
block|{
comment|/*  				 * The manual says we can't change the address  				 * while the receiver is armed, 				 * so reset everything 				 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|LEWREG
argument_list|(
name|LE_STOP
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|le
operator|->
name|sc_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|le
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* does le_setaddr() */
break|break;
block|}
endif|#
directive|endif
default|default:
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
if|#
directive|if
name|defined
argument_list|(
name|CCITT
argument_list|)
operator|&&
name|defined
argument_list|(
name|LLC
argument_list|)
case|case
name|SIOCSIFCONF_X25
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|ifa
operator|->
name|ifa_rtrequest
operator|=
name|cons_rtrequest
expr_stmt|;
name|error
operator|=
name|x25_llcglue
argument_list|(
name|PRC_IFUP
argument_list|,
name|ifa
operator|->
name|ifa_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* CCITT&& LLC */
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|LEWREG
argument_list|(
name|LE_STOP
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* 		 * If the state of the promiscuous bit changes, the interface 		 * must be reset to effect the change. 		 */
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|le
operator|->
name|sc_iflags
operator|)
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|le
operator|->
name|sc_iflags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|lereset
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|lestart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|MULTICAST
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* Update our multicast list  */
name|error
operator|=
operator|(
name|cmd
operator|==
name|SIOCADDMULTI
operator|)
condition|?
name|ether_addmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|le
operator|->
name|sc_ac
argument_list|)
else|:
name|ether_delmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|le
operator|->
name|sc_ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
comment|/* 			 * Multicast list has changed; set the hardware 			 * filter accordingly. 			 */
name|lereset
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|leerror
argument_list|(
argument|unit
argument_list|,
argument|stat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stat
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|ledebug
condition|)
return|return;
comment|/* 	 * Not all transceivers implement heartbeat 	 * so we only log CERR once. 	 */
if|if
condition|(
operator|(
name|stat
operator|&
name|LE_CERR
operator|)
operator|&&
name|le_softc
index|[
name|unit
index|]
operator|.
name|sc_cerr
condition|)
return|return;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"le%d: error: stat=%b\n"
argument_list|,
name|unit
argument_list|,
name|stat
argument_list|,
literal|"\20\20ERR\17BABL\16CERR\15MISS\14MERR\13RINT\12TINT\11IDON\10INTR\07INEA\06RXON\05TXON\04TDMD\03STOP\02STRT\01INIT"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lererror
argument_list|(
argument|unit
argument_list|,
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
specifier|volatile
name|void
modifier|*
name|rmd
decl_stmt|;
name|u_char
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ledebug
condition|)
return|return;
name|rmd
operator|=
name|LER2_RMDADDR
argument_list|(
name|le
operator|->
name|sc_r2
argument_list|,
name|le
operator|->
name|sc_rmd
argument_list|)
expr_stmt|;
name|len
operator|=
name|LER2V_rmd3
argument_list|(
name|rmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|11
condition|)
call|(
modifier|*
name|le
operator|->
name|sc_copyfrombuf
call|)
argument_list|(
name|LER2_RBUFADDR
argument_list|(
name|le
operator|->
name|sc_r2
argument_list|,
name|le
operator|->
name|sc_rmd
argument_list|)
argument_list|,
literal|6
argument_list|,
name|eaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"le%d: ierror(%s): from %s: buf=%d, len=%d, rmd1=%b\n"
argument_list|,
name|unit
argument_list|,
name|msg
argument_list|,
name|len
operator|>
literal|11
condition|?
name|ether_sprintf
argument_list|(
name|eaddr
argument_list|)
else|:
literal|"unknown"
argument_list|,
name|le
operator|->
name|sc_rmd
argument_list|,
name|len
argument_list|,
name|LER2V_rmd1
argument_list|(
name|rmd
argument_list|)
argument_list|,
literal|"\20\20OWN\17ERR\16FRAM\15OFLO\14CRC\13RBUF\12STP\11ENP"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lexerror
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
specifier|volatile
name|void
modifier|*
name|tmd
decl_stmt|;
name|u_char
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ledebug
condition|)
return|return;
name|tmd
operator|=
name|LER2_TMDADDR
argument_list|(
name|le
operator|->
name|sc_r2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
operator|-
name|LER2V_tmd2
argument_list|(
name|tmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|5
condition|)
call|(
modifier|*
name|le
operator|->
name|sc_copyfrombuf
call|)
argument_list|(
name|LER2_TBUFADDR
argument_list|(
name|le
operator|->
name|sc_r2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|eaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"le%d: oerror: to %s: buf=%d, len=%d, tmd1=%b, tmd3=%b\n"
argument_list|,
name|unit
argument_list|,
name|len
operator|>
literal|5
condition|?
name|ether_sprintf
argument_list|(
name|eaddr
argument_list|)
else|:
literal|"unknown"
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|LER2V_tmd1
argument_list|(
name|tmd
argument_list|)
argument_list|,
literal|"\20\20OWN\17ERR\16RES\15MORE\14ONE\13DEF\12STP\11ENP"
argument_list|,
name|LER2V_tmd3
argument_list|(
name|tmd
argument_list|)
argument_list|,
literal|"\20\20BUFF\17UFLO\16RES\15LCOL\14LCAR\13RTRY"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Write a lance register port, reading it back to ensure success. This seems  * to be necessary during initialization, since the chip appears to be a bit  * pokey sometimes.  */
end_comment

begin_function
specifier|static
name|void
name|lewritereg
parameter_list|(
name|regptr
parameter_list|,
name|val
parameter_list|)
specifier|register
specifier|volatile
name|u_short
modifier|*
name|regptr
decl_stmt|;
specifier|register
name|u_short
name|val
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|regptr
operator|!=
name|val
condition|)
block|{
operator|*
name|regptr
operator|=
name|val
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"le: Reg did not settle (to x%x): x%x\n"
argument_list|,
name|val
argument_list|,
operator|*
name|regptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Routines for accessing the transmit and receive buffers. Unfortunately,  * CPU addressing of these buffers is done in one of 3 ways:  * - contiguous (for the 3max and turbochannel option card)  * - gap2, which means shorts (2 bytes) interspersed with short (2 byte)  *   spaces (for the pmax)  * - gap16, which means 16bytes interspersed with 16byte spaces  *   for buffers which must begin on a 32byte boundary (for 3min and maxine)  * The buffer offset is the logical byte offset, assuming contiguous storage.  */
end_comment

begin_function
name|void
name|copytobuf_contig
parameter_list|(
name|from
parameter_list|,
name|lebuf
parameter_list|,
name|boff
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
specifier|volatile
name|void
modifier|*
name|lebuf
decl_stmt|;
name|int
name|boff
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* 	 * Just call bcopy() to do the work. 	 */
name|bcopy
argument_list|(
name|from
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|lebuf
operator|)
operator|+
name|boff
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|copyfrombuf_contig
parameter_list|(
name|lebuf
parameter_list|,
name|boff
parameter_list|,
name|to
parameter_list|,
name|len
parameter_list|)
specifier|volatile
name|void
modifier|*
name|lebuf
decl_stmt|;
name|int
name|boff
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* 	 * Just call bcopy() to do the work. 	 */
name|bcopy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|lebuf
operator|)
operator|+
name|boff
argument_list|,
name|to
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bzerobuf_contig
parameter_list|(
name|lebuf
parameter_list|,
name|boff
parameter_list|,
name|len
parameter_list|)
specifier|volatile
name|void
modifier|*
name|lebuf
decl_stmt|;
name|int
name|boff
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* 	 * Just let bzero() do the work 	 */
name|bzero
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|lebuf
operator|)
operator|+
name|boff
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For the pmax the buffer consists of shorts (2 bytes) interspersed with  * short (2 byte) spaces and must be accessed with halfword load/stores.  * (don't worry about doing an extra byte)  */
end_comment

begin_function
name|void
name|copytobuf_gap2
parameter_list|(
name|from
parameter_list|,
name|lebuf
parameter_list|,
name|boff
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
specifier|volatile
name|void
modifier|*
name|lebuf
decl_stmt|;
name|int
name|boff
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|u_short
modifier|*
name|bptr
decl_stmt|;
specifier|register
name|int
name|xfer
decl_stmt|;
if|if
condition|(
name|boff
operator|&
literal|0x1
condition|)
block|{
comment|/* handle unaligned first byte */
name|bptr
operator|=
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|lebuf
operator|)
operator|+
operator|(
name|boff
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|bptr
operator|=
operator|(
operator|*
name|from
operator|++
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
name|bptr
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bptr
operator|+=
literal|2
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
else|else
name|bptr
operator|=
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|lebuf
operator|)
operator|+
name|boff
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|from
operator|&
literal|0x1
condition|)
block|{
while|while
condition|(
name|len
operator|>
literal|1
condition|)
block|{
operator|*
name|bptr
operator|=
operator|(
name|from
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|from
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bptr
operator|+=
literal|2
expr_stmt|;
name|from
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* optimize for aligned transfers */
name|xfer
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|unsigned
operator|)
name|len
operator|&
operator|~
literal|0x1
argument_list|)
expr_stmt|;
name|CopyToBuffer
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|from
argument_list|,
name|bptr
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|bptr
operator|+=
name|xfer
expr_stmt|;
name|from
operator|+=
name|xfer
expr_stmt|;
name|len
operator|-=
name|xfer
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
condition|)
operator|*
name|bptr
operator|=
operator|(
name|u_short
operator|)
operator|*
name|from
expr_stmt|;
block|}
end_function

begin_function
name|void
name|copyfrombuf_gap2
parameter_list|(
name|lebuf
parameter_list|,
name|boff
parameter_list|,
name|to
parameter_list|,
name|len
parameter_list|)
specifier|volatile
name|void
modifier|*
name|lebuf
decl_stmt|;
name|int
name|boff
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|u_short
modifier|*
name|bptr
decl_stmt|;
specifier|register
name|u_short
name|tmp
decl_stmt|;
specifier|register
name|int
name|xfer
decl_stmt|;
if|if
condition|(
name|boff
operator|&
literal|0x1
condition|)
block|{
comment|/* handle unaligned first byte */
name|bptr
operator|=
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|lebuf
operator|)
operator|+
operator|(
name|boff
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|to
operator|++
operator|=
operator|(
operator|*
name|bptr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|bptr
operator|+=
literal|2
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
else|else
name|bptr
operator|=
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|lebuf
operator|)
operator|+
name|boff
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|to
operator|&
literal|0x1
condition|)
block|{
while|while
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|tmp
operator|=
operator|*
name|bptr
expr_stmt|;
operator|*
name|to
operator|++
operator|=
name|tmp
operator|&
literal|0xff
expr_stmt|;
operator|*
name|to
operator|++
operator|=
operator|(
name|tmp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|bptr
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* optimize for aligned transfers */
name|xfer
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|unsigned
operator|)
name|len
operator|&
operator|~
literal|0x1
argument_list|)
expr_stmt|;
name|CopyFromBuffer
argument_list|(
name|bptr
argument_list|,
name|to
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|bptr
operator|+=
name|xfer
expr_stmt|;
name|to
operator|+=
name|xfer
expr_stmt|;
name|len
operator|-=
name|xfer
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
condition|)
operator|*
name|to
operator|=
operator|*
name|bptr
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bzerobuf_gap2
parameter_list|(
name|lebuf
parameter_list|,
name|boff
parameter_list|,
name|len
parameter_list|)
specifier|volatile
name|void
modifier|*
name|lebuf
decl_stmt|;
name|int
name|boff
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|u_short
modifier|*
name|bptr
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|boff
operator|&
literal|0x1
condition|)
block|{
name|bptr
operator|=
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|lebuf
operator|)
operator|+
operator|(
name|boff
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|bptr
operator|&=
literal|0xff
expr_stmt|;
name|bptr
operator|+=
literal|2
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
else|else
name|bptr
operator|=
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|lebuf
operator|)
operator|+
name|boff
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
name|bptr
operator|=
literal|0
expr_stmt|;
name|bptr
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * For the 3min and maxine, the buffers are in main memory filled in with  * 16byte blocks interspersed with 16byte spaces.  */
end_comment

begin_function
name|void
name|copytobuf_gap16
parameter_list|(
name|from
parameter_list|,
name|lebuf
parameter_list|,
name|boff
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
specifier|volatile
name|void
modifier|*
name|lebuf
decl_stmt|;
name|int
name|boff
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bptr
decl_stmt|;
specifier|register
name|int
name|xfer
decl_stmt|;
name|bptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|lebuf
operator|)
operator|+
operator|(
operator|(
name|boff
operator|<<
literal|1
operator|)
operator|&
operator|~
literal|0x1f
operator|)
expr_stmt|;
name|boff
operator|&=
literal|0xf
expr_stmt|;
name|xfer
operator|=
name|min
argument_list|(
name|len
argument_list|,
literal|16
operator|-
name|boff
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|from
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|bptr
operator|)
operator|+
name|boff
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|from
operator|+=
name|xfer
expr_stmt|;
name|bptr
operator|+=
literal|32
expr_stmt|;
name|boff
operator|=
literal|0
expr_stmt|;
name|len
operator|-=
name|xfer
expr_stmt|;
name|xfer
operator|=
name|min
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|copyfrombuf_gap16
parameter_list|(
name|lebuf
parameter_list|,
name|boff
parameter_list|,
name|to
parameter_list|,
name|len
parameter_list|)
specifier|volatile
name|void
modifier|*
name|lebuf
decl_stmt|;
name|int
name|boff
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bptr
decl_stmt|;
specifier|register
name|int
name|xfer
decl_stmt|;
name|bptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|lebuf
operator|)
operator|+
operator|(
operator|(
name|boff
operator|<<
literal|1
operator|)
operator|&
operator|~
literal|0x1f
operator|)
expr_stmt|;
name|boff
operator|&=
literal|0xf
expr_stmt|;
name|xfer
operator|=
name|min
argument_list|(
name|len
argument_list|,
literal|16
operator|-
name|boff
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|bptr
operator|)
operator|+
name|boff
argument_list|,
name|to
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|to
operator|+=
name|xfer
expr_stmt|;
name|bptr
operator|+=
literal|32
expr_stmt|;
name|boff
operator|=
literal|0
expr_stmt|;
name|len
operator|-=
name|xfer
expr_stmt|;
name|xfer
operator|=
name|min
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bzerobuf_gap16
parameter_list|(
name|lebuf
parameter_list|,
name|boff
parameter_list|,
name|len
parameter_list|)
specifier|volatile
name|void
modifier|*
name|lebuf
decl_stmt|;
name|int
name|boff
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bptr
decl_stmt|;
specifier|register
name|int
name|xfer
decl_stmt|;
name|bptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|lebuf
operator|)
operator|+
operator|(
operator|(
name|boff
operator|<<
literal|1
operator|)
operator|&
operator|~
literal|0x1f
operator|)
expr_stmt|;
name|boff
operator|&=
literal|0xf
expr_stmt|;
name|xfer
operator|=
name|min
argument_list|(
name|len
argument_list|,
literal|16
operator|-
name|boff
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|bptr
operator|)
operator|+
name|boff
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|bptr
operator|+=
literal|32
expr_stmt|;
name|boff
operator|=
literal|0
expr_stmt|;
name|len
operator|-=
name|xfer
expr_stmt|;
name|xfer
operator|=
name|min
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NLE */
end_comment

end_unit

