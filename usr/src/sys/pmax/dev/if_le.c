begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ralph Campbell.  *  * %sccs.include.redist.c%  *  *	@(#)if_le.c	7.1 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"le.h"
end_include

begin_if
if|#
directive|if
name|NLE
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_comment
comment|/*  * AMD 7990 LANCE  *  * This driver will generate and accept trailer encapsulated packets even  * though it buys us nothing.  The motivation was to avoid incompatibilities  * with VAXen, SUNs, and others that handle and benefit from them.  * This reasoning is dubious.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"net/if.h"
end_include

begin_include
include|#
directive|include
file|"net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"net/route.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|"netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip.h"
end_include

begin_include
include|#
directive|include
file|"netinet/if_ether.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|"netns/ns.h"
end_include

begin_include
include|#
directive|include
file|"netns/ns_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RMP
end_ifdef

begin_include
include|#
directive|include
file|"netrmp/rmp.h"
end_include

begin_include
include|#
directive|include
file|"netrmp/rmp_var.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"machine/machConst.h"
end_include

begin_include
include|#
directive|include
file|"device.h"
end_include

begin_include
include|#
directive|include
file|"if_lereg.h"
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"../net/bpf.h"
end_include

begin_include
include|#
directive|include
file|"../net/bpfdesc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|leprobe
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|driver
name|ledriver
init|=
block|{
literal|"le"
block|,
name|leprobe
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ledebug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* console error messages */
end_comment

begin_decl_stmt
name|int
name|leintr
argument_list|()
decl_stmt|,
name|leinit
argument_list|()
decl_stmt|,
name|leioctl
argument_list|()
decl_stmt|,
name|lestart
argument_list|()
decl_stmt|,
name|ether_output
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|mbuf
modifier|*
name|leget
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Ethernet software status per interface.  *  * Each interface is referenced by a network interface structure,  * le_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  */
end_comment

begin_struct
struct|struct
name|le_softc
block|{
name|struct
name|arpcom
name|sc_ac
decl_stmt|;
comment|/* common Ethernet structures */
define|#
directive|define
name|sc_if
value|sc_ac.ac_if
comment|/* network-visible interface */
define|#
directive|define
name|sc_addr
value|sc_ac.ac_enaddr
comment|/* hardware Ethernet address */
specifier|volatile
name|struct
name|lereg1
modifier|*
name|sc_r1
decl_stmt|;
comment|/* LANCE registers */
specifier|volatile
name|struct
name|lereg2
modifier|*
name|sc_r2
decl_stmt|;
comment|/* dual-port RAM */
name|int
name|sc_rmd
decl_stmt|;
comment|/* predicted next rmd to process */
name|int
name|sc_tmd
decl_stmt|;
comment|/* last tmd processed */
name|int
name|sc_tmdnext
decl_stmt|;
comment|/* next tmd to transmit with */
name|int
name|sc_runt
decl_stmt|;
name|int
name|sc_jab
decl_stmt|;
name|int
name|sc_merr
decl_stmt|;
name|int
name|sc_babl
decl_stmt|;
name|int
name|sc_cerr
decl_stmt|;
name|int
name|sc_miss
decl_stmt|;
name|int
name|sc_xint
decl_stmt|;
name|int
name|sc_xown
decl_stmt|;
name|int
name|sc_uflo
decl_stmt|;
name|int
name|sc_rxlen
decl_stmt|;
name|int
name|sc_rxoff
decl_stmt|;
name|int
name|sc_txoff
decl_stmt|;
name|int
name|sc_busy
decl_stmt|;
name|short
name|sc_iflags
decl_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|caddr_t
name|sc_bpf
decl_stmt|;
endif|#
directive|endif
block|}
name|le_softc
index|[
name|NLE
index|]
struct|;
end_struct

begin_comment
comment|/* access LANCE registers */
end_comment

begin_define
define|#
directive|define
name|LERDWR
parameter_list|(
name|cntl
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
value|{ (dst) = (src); DELAY(10); }
end_define

begin_define
define|#
directive|define
name|CPU_TO_CHIP_ADDR
parameter_list|(
name|cpu
parameter_list|)
define|\
value|(((unsigned)(&(((struct lereg2 *)0)->cpu)))>> 1)
end_define

begin_comment
comment|/*  * Test to see if device is present.  * Return true if found and initialized ok.  * If interface exists, make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_macro
name|leprobe
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pmax_ctlr
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|volatile
name|struct
name|lereg1
modifier|*
name|ler1
decl_stmt|;
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|dp
operator|->
name|pmax_unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|le
operator|->
name|sc_if
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|le
operator|->
name|sc_r1
operator|=
name|ler1
operator|=
operator|(
specifier|volatile
expr|struct
name|lereg1
operator|*
operator|)
name|dp
operator|->
name|pmax_addr
expr_stmt|;
name|le
operator|->
name|sc_r2
operator|=
operator|(
specifier|volatile
expr|struct
name|lereg2
operator|*
operator|)
name|MACH_NETWORK_BUFFER_ADDR
expr_stmt|;
comment|/* 	 * Read the ethernet address. 	 * See "DECstation 3100 Desktop Workstation Functional Specification". 	 */
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|MACH_CLOCK_ADDR
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|le
operator|->
name|sc_addr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|le
operator|->
name|sc_addr
index|[
name|i
index|]
operator|=
operator|*
name|cp
expr_stmt|;
name|cp
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* make sure the chip is stopped */
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_CSR0
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_STOP
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|dp
operator|->
name|pmax_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"le"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|leinit
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|leioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|lestart
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|le
operator|->
name|sc_bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"le%d at nexus0 csr 0x%x ethernet address %s\n"
argument_list|,
name|dp
operator|->
name|pmax_unit
argument_list|,
name|dp
operator|->
name|pmax_addr
argument_list|,
name|ether_sprintf
argument_list|(
name|le
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|ledrinit
argument_list|(
name|ler2
argument_list|)
specifier|register
specifier|volatile
expr|struct
name|lereg2
operator|*
name|ler2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LERBUF
condition|;
name|i
operator|++
control|)
block|{
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd0
operator|=
name|CPU_TO_CHIP_ADDR
argument_list|(
name|ler2_rbuf
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd1
operator|=
name|LE_OWN
expr_stmt|;
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd2
operator|=
operator|-
name|LEMTU
expr_stmt|;
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd3
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LETBUF
condition|;
name|i
operator|++
control|)
block|{
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd0
operator|=
name|CPU_TO_CHIP_ADDR
argument_list|(
name|ler2_tbuf
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd1
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd2
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd3
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|lereset
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lereg1
modifier|*
name|ler1
init|=
name|le
operator|->
name|sc_r1
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lereg2
modifier|*
name|ler2
init|=
name|le
operator|->
name|sc_r2
decl_stmt|;
specifier|register
name|int
name|timo
init|=
literal|100000
decl_stmt|;
specifier|register
name|int
name|stat
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|stat
operator|=
name|unit
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
comment|/* set the promiscuous bit */
name|le
operator|->
name|sc_r2
operator|->
name|ler2_mode
operator|=
name|LE_MODE
operator||
literal|0x8000
expr_stmt|;
else|else
name|le
operator|->
name|sc_r2
operator|->
name|ler2_mode
operator|=
name|LE_MODE
expr_stmt|;
endif|#
directive|endif
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_CSR0
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_STOP
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
comment|/* 	 * Setup for transmit/receive 	 */
name|ler2
operator|->
name|ler2_mode
operator|=
name|LE_MODE
expr_stmt|;
name|ler2
operator|->
name|ler2_padr0
operator|=
operator|(
name|le
operator|->
name|sc_addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|le
operator|->
name|sc_addr
index|[
literal|0
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_padr1
operator|=
operator|(
name|le
operator|->
name|sc_addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|le
operator|->
name|sc_addr
index|[
literal|2
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_padr2
operator|=
operator|(
name|le
operator|->
name|sc_addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|le
operator|->
name|sc_addr
index|[
literal|4
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|RMP
comment|/* 	 * Set up logical addr filter to accept multicast 9:0:9:0:0:4 	 * This should be an ioctl() to the driver.  (XXX) 	 */
name|ler2
operator|->
name|ler2_ladrf0
operator|=
literal|0x0010
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf1
operator|=
literal|0x0
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf2
operator|=
literal|0x0
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf3
operator|=
literal|0x0
expr_stmt|;
else|#
directive|else
name|ler2
operator|->
name|ler2_ladrf0
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf1
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf2
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf3
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ler2
operator|->
name|ler2_rlen
operator|=
name|LE_RLEN
expr_stmt|;
name|ler2
operator|->
name|ler2_rdra
operator|=
name|CPU_TO_CHIP_ADDR
argument_list|(
name|ler2_rmd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ler2
operator|->
name|ler2_tlen
operator|=
name|LE_TLEN
expr_stmt|;
name|ler2
operator|->
name|ler2_tdra
operator|=
name|CPU_TO_CHIP_ADDR
argument_list|(
name|ler2_tmd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ledrinit
argument_list|(
name|ler2
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_rmd
operator|=
literal|0
expr_stmt|;
name|le
operator|->
name|sc_tmd
operator|=
name|LETBUF
operator|-
literal|1
expr_stmt|;
name|le
operator|->
name|sc_tmdnext
operator|=
literal|0
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_CSR1
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|CPU_TO_CHIP_ADDR
argument_list|(
name|ler2_mode
argument_list|)
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_CSR2
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
literal|0
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_CSR3
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
literal|0
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_CSR0
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_INIT
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|--
name|timo
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"le%d: init timeout, stat = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
block|}
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|stat
operator|&
name|LE_IDON
operator|)
operator|==
literal|0
condition|)
do|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_IDON
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_STRT
operator||
name|LE_INEA
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialization of interface  */
end_comment

begin_macro
name|leinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|le
operator|->
name|sc_if
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* not yet, if address still unknown */
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lestart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|LENEXTTMP
define|\
value|if (++bix == LETBUF) bix = 0, tmd = le->sc_r2->ler2_tmd; else ++tmd
end_define

begin_comment
comment|/*  * Start output on interface.  Get another datagram to send  * off of the interface queue, and copy it to the interface  * before starting the output.  */
end_comment

begin_macro
name|lestart
argument_list|(
argument|ifp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|int
name|bix
init|=
name|le
operator|->
name|sc_tmdnext
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|letmd
modifier|*
name|tmd
init|=
operator|&
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tmd
index|[
name|bix
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|bix
operator|!=
name|le
operator|->
name|sc_tmd
condition|)
block|{
if|if
condition|(
name|tmd
operator|->
name|tmd1
operator|&
name|LE_OWN
condition|)
name|panic
argument_list|(
literal|"lestart"
argument_list|)
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|le
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
name|leput
argument_list|(
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tbuf
index|[
name|bix
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 		 * If bpf is listening on this interface, let it 		 * see the packet before we commit it to the wire. 		 */
if|if
condition|(
name|le
operator|->
name|sc_bpf
condition|)
name|bpf_tap
argument_list|(
name|le
operator|->
name|sc_bpf
argument_list|,
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tbuf
index|[
name|bix
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmd
operator|->
name|tmd3
operator|=
literal|0
expr_stmt|;
name|tmd
operator|->
name|tmd2
operator|=
operator|-
name|len
expr_stmt|;
name|tmd
operator|->
name|tmd1
operator|=
name|LE_OWN
operator||
name|LE_STP
operator||
name|LE_ENP
expr_stmt|;
name|LENEXTTMP
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_TDMD
operator||
name|LE_INEA
argument_list|,
name|le
operator|->
name|sc_r1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
name|le
operator|->
name|sc_tmdnext
operator|=
name|bix
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Process interrupts from the 7990 chip.  */
end_comment

begin_macro
name|leintr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lereg1
modifier|*
name|ler1
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|,
name|stat
decl_stmt|;
comment|/* only one unit right now; should be a loop. */
name|unit
operator|=
literal|0
expr_stmt|;
name|le
operator|=
operator|&
name|le_softc
index|[
name|unit
index|]
expr_stmt|;
name|ler1
operator|=
name|le
operator|->
name|sc_r1
expr_stmt|;
name|stat
operator|=
name|ler1
operator|->
name|ler1_rdp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|LE_INTR
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"le?: spurrious interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat
operator|&
name|LE_SERR
condition|)
block|{
name|leerror
argument_list|(
name|unit
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|LE_MERR
condition|)
block|{
name|le
operator|->
name|sc_merr
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat
operator|&
name|LE_BABL
condition|)
name|le
operator|->
name|sc_babl
operator|++
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|LE_CERR
condition|)
name|le
operator|->
name|sc_cerr
operator|++
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|LE_MISS
condition|)
name|le
operator|->
name|sc_miss
operator|++
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_BABL
operator||
name|LE_CERR
operator||
name|LE_MISS
operator||
name|LE_INEA
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|LE_RXON
operator|)
operator|==
literal|0
condition|)
block|{
name|le
operator|->
name|sc_rxoff
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|LE_TXON
operator|)
operator|==
literal|0
condition|)
block|{
name|le
operator|->
name|sc_txoff
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat
operator|&
name|LE_RINT
condition|)
block|{
comment|/* interrupt is cleared in lerint */
name|lerint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|LE_TINT
condition|)
block|{
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_TINT
operator||
name|LE_INEA
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|lexint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Ethernet interface transmitter interrupt.  * Start another output if more data to send.  */
end_comment

begin_expr_stmt
name|lexint
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|bix
init|=
name|le
operator|->
name|sc_tmd
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|letmd
modifier|*
name|tmd
init|=
operator|&
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tmd
index|[
name|bix
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|le
operator|->
name|sc_xint
operator|++
expr_stmt|;
return|return;
block|}
name|LENEXTTMP
expr_stmt|;
while|while
condition|(
name|bix
operator|!=
name|le
operator|->
name|sc_tmdnext
operator|&&
operator|(
name|tmd
operator|->
name|tmd1
operator|&
name|LE_OWN
operator|)
operator|==
literal|0
condition|)
block|{
name|le
operator|->
name|sc_tmd
operator|=
name|bix
expr_stmt|;
if|if
condition|(
operator|(
name|tmd
operator|->
name|tmd1
operator|&
name|LE_ERR
operator|)
operator|||
operator|(
name|tmd
operator|->
name|tmd3
operator|&
name|LE_TBUFF
operator|)
condition|)
block|{
name|lexerror
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|tmd
operator|->
name|tmd3
operator|&
operator|(
name|LE_TBUFF
operator||
name|LE_UFLO
operator|)
condition|)
block|{
name|le
operator|->
name|sc_uflo
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd3
operator|&
name|LE_LCOL
condition|)
name|le
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd3
operator|&
name|LE_RTRY
condition|)
name|le
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd1
operator|&
name|LE_ONE
condition|)
name|le
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd1
operator|&
name|LE_MORE
condition|)
comment|/* what is the real number? */
name|le
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
literal|2
expr_stmt|;
else|else
name|le
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|LENEXTTMP
expr_stmt|;
block|}
if|if
condition|(
name|bix
operator|==
name|le
operator|->
name|sc_tmdnext
condition|)
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
operator|(
name|void
operator|)
name|lestart
argument_list|(
operator|&
name|le
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|LENEXTRMP
define|\
value|if (++bix == LERBUF) bix = 0, rmd = le->sc_r2->ler2_rmd; else ++rmd
end_define

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  * If input error just drop packet.  * Decapsulate packet based on type and pass to type specific  * higher-level input routine.  */
end_comment

begin_macro
name|lerint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|bix
init|=
name|le
operator|->
name|sc_rmd
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lermd
modifier|*
name|rmd
init|=
operator|&
name|le
operator|->
name|sc_r2
operator|->
name|ler2_rmd
index|[
name|bix
index|]
decl_stmt|;
comment|/* 	 * Out of sync with hardware, should never happen? 	 */
if|if
condition|(
name|rmd
operator|->
name|rmd1
operator|&
name|LE_OWN
condition|)
block|{
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_RINT
operator||
name|LE_INEA
argument_list|,
name|le
operator|->
name|sc_r1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 	 * Process all buffers with valid data 	 */
while|while
condition|(
operator|(
name|rmd
operator|->
name|rmd1
operator|&
name|LE_OWN
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
init|=
name|rmd
operator|->
name|rmd3
decl_stmt|;
comment|/* Clear interrupt to avoid race condition */
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_RINT
operator||
name|LE_INEA
argument_list|,
name|le
operator|->
name|sc_r1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|rmd
operator|->
name|rmd1
operator|&
name|LE_ERR
condition|)
block|{
name|le
operator|->
name|sc_rmd
operator|=
name|bix
expr_stmt|;
name|lererror
argument_list|(
name|unit
argument_list|,
literal|"bad packet"
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rmd
operator|->
name|rmd1
operator|&
operator|(
name|LE_STP
operator||
name|LE_ENP
operator|)
operator|)
operator|!=
operator|(
name|LE_STP
operator||
name|LE_ENP
operator|)
condition|)
block|{
comment|/* 			 * Find the end of the packet so we can see how long 			 * it was.  We still throw it away. 			 */
do|do
block|{
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_RINT
operator||
name|LE_INEA
argument_list|,
name|le
operator|->
name|sc_r1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|rmd
operator|->
name|rmd3
operator|=
literal|0
expr_stmt|;
name|rmd
operator|->
name|rmd1
operator|=
name|LE_OWN
expr_stmt|;
name|LENEXTRMP
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|rmd
operator|->
name|rmd1
operator|&
operator|(
name|LE_OWN
operator||
name|LE_ERR
operator||
name|LE_STP
operator||
name|LE_ENP
operator|)
operator|)
condition|)
do|;
name|le
operator|->
name|sc_rmd
operator|=
name|bix
expr_stmt|;
name|lererror
argument_list|(
name|unit
argument_list|,
literal|"chained buffer"
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_rxlen
operator|++
expr_stmt|;
comment|/* 			 * If search terminated without successful completion 			 * we reset the hardware (conservative). 			 */
if|if
condition|(
operator|(
name|rmd
operator|->
name|rmd1
operator|&
operator|(
name|LE_OWN
operator||
name|LE_ERR
operator||
name|LE_STP
operator||
name|LE_ENP
operator|)
operator|)
operator|!=
name|LE_ENP
condition|)
block|{
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|leread
argument_list|(
name|unit
argument_list|,
name|le
operator|->
name|sc_r2
operator|->
name|ler2_rbuf
index|[
name|bix
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rmd
operator|->
name|rmd3
operator|=
literal|0
expr_stmt|;
name|rmd
operator|->
name|rmd1
operator|=
name|LE_OWN
expr_stmt|;
name|LENEXTRMP
expr_stmt|;
block|}
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* Paranoia */
name|le
operator|->
name|sc_rmd
operator|=
name|bix
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Look at the packet in network buffer memory so we can be smart about how  * we copy the data into mbufs.  * This needs work since we can't just read network buffer memory like  * regular memory.  */
end_comment

begin_macro
name|leread
argument_list|(
argument|unit
argument_list|,
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|u_short
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ether_header
name|et
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|,
name|resid
decl_stmt|;
name|u_short
name|sbuf
index|[
literal|2
index|]
decl_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|CopyFromBuffer
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|et
argument_list|,
sizeof|sizeof
argument_list|(
name|et
argument_list|)
argument_list|)
expr_stmt|;
name|et
operator|.
name|ether_type
operator|=
name|ntohs
argument_list|(
name|et
operator|.
name|ether_type
argument_list|)
expr_stmt|;
comment|/* adjust input length to account for header and CRC */
name|len
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|RMP
comment|/*  (XXX) 	 * 	 *  If Ethernet Type field is< MaxPacketSize, we probably have 	 *  a IEEE802 packet here.  Make sure that the size is at least 	 *  that of the HP LLC.  Also do sanity checks on length of LLC 	 *  (old Ethernet Type field) and packet length. 	 * 	 *  Provided the above checks succeed, change `len' to reflect 	 *  the length of the LLC (i.e. et.ether_type) and change the 	 *  type field to ETHERTYPE_IEEE so we can switch() on it later. 	 *  Yes, this is a hack and will eventually be done "right". 	 */
if|if
condition|(
name|et
operator|.
name|ether_type
operator|<=
name|IEEE802LEN_MAX
operator|&&
name|len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|hp_llc
argument_list|)
operator|&&
name|len
operator|>=
name|et
operator|.
name|ether_type
operator|&&
name|len
operator|>=
name|IEEE802LEN_MIN
condition|)
block|{
name|len
operator|=
name|et
operator|.
name|ether_type
expr_stmt|;
name|et
operator|.
name|ether_type
operator|=
name|ETHERTYPE_IEEE
expr_stmt|;
comment|/* hack! */
block|}
endif|#
directive|endif
if|if
condition|(
name|et
operator|.
name|ether_type
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|et
operator|.
name|ether_type
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|off
operator|=
operator|(
name|et
operator|.
name|ether_type
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|*
literal|512
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|ETHERMTU
condition|)
return|return;
comment|/* sanity */
name|CopyFromBuffer
argument_list|(
name|buf
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|et
argument_list|)
operator|+
name|off
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|et
operator|.
name|ether_type
operator|=
name|ntohs
argument_list|(
name|sbuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ntohs
argument_list|(
name|sbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|resid
operator|>
name|len
condition|)
return|return;
comment|/* sanity */
name|len
operator|=
name|off
operator|+
name|resid
expr_stmt|;
block|}
else|else
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|ledebug
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"le%d: ierror(runt packet): from %s: len=%d\n"
argument_list|,
name|unit
argument_list|,
name|ether_sprintf
argument_list|(
name|et
operator|.
name|ether_shost
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_runt
operator|++
expr_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Check if there's a bpf filter listening on this interface. 	 * If so, hand off the raw packet to bpf, which must deal with 	 * trailers in its own way. 	 */
if|if
condition|(
name|le
operator|->
name|sc_bpf
condition|)
block|{
name|bpf_tap
argument_list|(
name|le
operator|->
name|sc_bpf
argument_list|,
name|buf
argument_list|,
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Note that the interface cannot be in promiscuous mode if 		 * there are no bpf listeners.  And if we are in promiscuous 		 * mode, we have to check if this packet is really ours. 		 * 		 * XXX This test does not support multicasts. 		 */
if|if
condition|(
operator|(
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|bcmp
argument_list|(
name|et
operator|.
name|ether_dhost
argument_list|,
name|le
operator|->
name|sc_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|et
operator|.
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
name|et
operator|.
name|ether_dhost
argument_list|,
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|et
operator|.
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Pull packet off interface.  Off is nonzero if packet 	 * has trailing header; leget will then force this header 	 * information to be at the front, but we still have to drop 	 * the type and length which are at the front of any trailer data. 	 */
name|m
operator|=
name|leget
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
operator|&
name|le
operator|->
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|RMP
comment|/* 	 * (XXX) 	 * This needs to be integrated with the ISO stuff in ether_input() 	 */
if|if
condition|(
name|et
operator|.
name|ether_type
operator|==
name|ETHERTYPE_IEEE
condition|)
block|{
comment|/* 		 *  Snag the Logical Link Control header (IEEE 802.2). 		 */
name|struct
name|hp_llc
modifier|*
name|llc
init|=
operator|&
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|rmp_packet
operator|*
argument_list|)
operator|->
name|hp_llc
operator|)
decl_stmt|;
comment|/* 		 *  If the DSAP (and HP's extended DXSAP) indicate this 		 *  is an RMP packet, hand it to the raw input routine. 		 */
if|if
condition|(
name|llc
operator|->
name|dsap
operator|==
name|IEEE_DSAP_HP
operator|&&
name|llc
operator|->
name|dxsap
operator|==
name|HPEXT_DXSAP
condition|)
block|{
specifier|static
name|struct
name|sockproto
name|rmp_sp
init|=
block|{
name|AF_RMP
block|,
name|RMPPROTO_BOOT
block|}
decl_stmt|;
specifier|static
name|struct
name|sockaddr
name|rmp_src
init|=
block|{
name|AF_RMP
block|}
decl_stmt|;
specifier|static
name|struct
name|sockaddr
name|rmp_dst
init|=
block|{
name|AF_RMP
block|}
decl_stmt|;
name|bcopy
argument_list|(
name|et
operator|.
name|ether_shost
argument_list|,
name|rmp_src
operator|.
name|sa_data
argument_list|,
sizeof|sizeof
argument_list|(
name|et
operator|.
name|ether_shost
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|et
operator|.
name|ether_dhost
argument_list|,
name|rmp_dst
operator|.
name|sa_data
argument_list|,
sizeof|sizeof
argument_list|(
name|et
operator|.
name|ether_dhost
argument_list|)
argument_list|)
expr_stmt|;
name|raw_input
argument_list|(
name|m
argument_list|,
operator|&
name|rmp_sp
argument_list|,
operator|&
name|rmp_src
argument_list|,
operator|&
name|rmp_dst
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|ether_input
argument_list|(
operator|&
name|le
operator|->
name|sc_if
argument_list|,
operator|&
name|et
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Routine to copy from mbuf chain to transmit buffer in  * network buffer memory.  * NOTE: network memory can only be written one short at every other address.  */
end_comment

begin_expr_stmt
name|leput
argument_list|(
name|lebuf
argument_list|,
name|m
argument_list|)
specifier|volatile
specifier|register
name|u_short
operator|*
name|lebuf
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|tlen
init|=
literal|0
decl_stmt|,
name|xfer
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|tmp
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
comment|/* copy data for this mbuf */
name|cp
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|&
literal|1
condition|)
block|{
comment|/* handle odd length from previous mbuf */
operator|*
name|lebuf
operator|=
operator|(
name|cp
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|tmp
expr_stmt|;
name|lebuf
operator|+=
literal|2
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|tlen
operator|++
expr_stmt|;
block|}
name|tlen
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|cp
operator|&
literal|1
condition|)
block|{
while|while
condition|(
name|len
operator|>
literal|1
condition|)
block|{
operator|*
name|lebuf
operator|=
operator|(
name|cp
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|lebuf
operator|+=
literal|2
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* optimize for aligned transfers */
name|xfer
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|unsigned
operator|)
name|len
operator|&
operator|~
literal|0x1
argument_list|)
expr_stmt|;
name|CopyToBuffer
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|cp
argument_list|,
name|lebuf
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|lebuf
operator|+=
name|xfer
expr_stmt|;
name|cp
operator|+=
name|xfer
expr_stmt|;
name|len
operator|-=
name|xfer
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
condition|)
name|tmp
operator|=
operator|*
name|cp
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* handle odd length from previous mbuf */
if|if
condition|(
name|tlen
operator|&
literal|1
condition|)
operator|*
name|lebuf
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|tlen
operator|<
name|LEMINSIZE
condition|)
name|tlen
operator|=
name|LEMINSIZE
expr_stmt|;
return|return
operator|(
name|tlen
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Routine to copy from network buffer memory into mbufs.  * NOTE: network memory can only be read one short at every other address.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|leget
parameter_list|(
name|lebuf
parameter_list|,
name|totlen
parameter_list|,
name|off
parameter_list|,
name|ifp
parameter_list|)
specifier|volatile
name|u_short
modifier|*
name|lebuf
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|off
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
init|=
literal|0
decl_stmt|,
modifier|*
modifier|*
name|mp
init|=
operator|&
name|top
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|resid
decl_stmt|;
specifier|register
specifier|volatile
name|u_short
modifier|*
name|sp
decl_stmt|;
comment|/* NOTE: sizeof(struct ether_header) should be even */
name|lebuf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|sp
operator|=
name|lebuf
expr_stmt|;
if|if
condition|(
name|off
condition|)
block|{
comment|/* NOTE: off should be even */
name|sp
operator|+=
name|off
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|totlen
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|resid
operator|=
name|totlen
operator|-
name|off
expr_stmt|;
block|}
else|else
name|resid
operator|=
name|totlen
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|resid
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m
operator|->
name|m_len
operator|=
name|MIN
argument_list|(
name|resid
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|resid
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
comment|/* 			 * Place initial small packet/header at end of mbuf. 			 */
if|if
condition|(
name|top
operator|==
literal|0
operator|&&
name|resid
operator|+
name|max_linkhdr
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|resid
expr_stmt|;
block|}
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|sp
operator|&
literal|2
condition|)
block|{
comment|/* 			 * Previous len was odd. Copy the single byte specially. 			 * XXX Can this ever happen?? 			 */
name|panic
argument_list|(
literal|"le odd rcv"
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|=
operator|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|sp
operator|)
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|CopyFromBuffer
argument_list|(
name|sp
operator|+
literal|1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|CopyFromBuffer
argument_list|(
name|sp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
name|resid
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|resid
operator|==
literal|0
condition|)
block|{
name|sp
operator|=
name|lebuf
expr_stmt|;
name|resid
operator|=
name|totlen
expr_stmt|;
block|}
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|leioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|volatile
name|struct
name|lereg1
modifier|*
name|ler1
init|=
name|le
operator|->
name|sc_r1
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|le
operator|->
name|sc_addr
operator|)
expr_stmt|;
else|else
block|{
comment|/*  				 * The manual says we can't change the address  				 * while the receiver is armed, 				 * so reset everything 				 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|le
operator|->
name|sc_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|le
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* does le_setaddr() */
break|break;
block|}
endif|#
directive|endif
default|default:
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_STOP
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* 		 * If the state of the promiscuous bit changes, the interface 		 * must be reset to effect the change. 		 */
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|le
operator|->
name|sc_iflags
operator|)
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|le
operator|->
name|sc_iflags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|lereset
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|lestart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|leerror
argument_list|(
argument|unit
argument_list|,
argument|stat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stat
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|ledebug
condition|)
return|return;
comment|/* 	 * Not all transceivers implement heartbeat 	 * so we only log CERR once. 	 */
if|if
condition|(
operator|(
name|stat
operator|&
name|LE_CERR
operator|)
operator|&&
name|le_softc
index|[
name|unit
index|]
operator|.
name|sc_cerr
condition|)
return|return;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"le%d: error: stat=%b\n"
argument_list|,
name|unit
argument_list|,
name|stat
argument_list|,
literal|"\20\20ERR\17BABL\16CERR\15MISS\14MERR\13RINT\12TINT\11IDON\10INTR\07INEA\06RXON\05TXON\04TDMD\03STOP\02STRT\01INIT"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lererror
argument_list|(
argument|unit
argument_list|,
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lermd
modifier|*
name|rmd
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ledebug
condition|)
return|return;
name|rmd
operator|=
operator|&
name|le
operator|->
name|sc_r2
operator|->
name|ler2_rmd
index|[
name|le
operator|->
name|sc_rmd
index|]
expr_stmt|;
name|len
operator|=
name|rmd
operator|->
name|rmd3
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"le%d: ierror(%s): from %s: buf=%d, len=%d, rmd1=%b\n"
argument_list|,
name|unit
argument_list|,
name|msg
argument_list|,
name|len
operator|>
literal|11
condition|?
name|ether_sprintf
argument_list|(
operator|&
name|le
operator|->
name|sc_r2
operator|->
name|ler2_rbuf
index|[
name|le
operator|->
name|sc_rmd
index|]
index|[
literal|6
index|]
argument_list|)
else|:
literal|"unknown"
argument_list|,
name|le
operator|->
name|sc_rmd
argument_list|,
name|len
argument_list|,
name|rmd
operator|->
name|rmd1
argument_list|,
literal|"\20\20OWN\17ERR\16FRAM\15OFLO\14CRC\13RBUF\12STP\11ENP"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lexerror
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|letmd
modifier|*
name|tmd
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ledebug
condition|)
return|return;
name|tmd
operator|=
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tmd
expr_stmt|;
name|len
operator|=
operator|-
name|tmd
operator|->
name|tmd2
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"le%d: oerror: to %s: buf=%d, len=%d, tmd1=%b, tmd3=%b\n"
argument_list|,
name|unit
argument_list|,
name|len
operator|>
literal|5
condition|?
name|ether_sprintf
argument_list|(
operator|&
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tbuf
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
else|:
literal|"unknown"
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|tmd
operator|->
name|tmd1
argument_list|,
literal|"\20\20OWN\17ERR\16RES\15MORE\14ONE\13DEF\12STP\11ENP"
argument_list|,
name|tmd
operator|->
name|tmd3
argument_list|,
literal|"\20\20BUFF\17UFLO\16RES\15LCOL\14LCAR\13RTRY"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

