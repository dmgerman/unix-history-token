begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ralph Campbell and Rick Macklem.  *  * %sccs.include.redist.c%  *  *	@(#)dtop.c	7.1 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1991,1990,1989 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * 	Author: Alessandro Forin, Carnegie Mellon University  *  *	Hardware-level operations for the Desktop serial line  *	bus (i2c aka ACCESS).  */
end_comment

begin_include
include|#
directive|include
file|<dtop.h>
end_include

begin_if
if|#
directive|if
name|NDTOP
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/map.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/machConst.h>
end_include

begin_include
include|#
directive|include
file|<machine/dc7085cons.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/pmaxtype.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/maxine.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/asic.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/dtopreg.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/fbreg.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|pmax_boardtype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ttrstrt
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dtop_keyboard_autorepeat
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtop_null_device_handler
name|__P
argument_list|(
operator|(
name|dtop_device_t
operator|,
name|dtop_message_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtop_locator_handler
name|__P
argument_list|(
operator|(
name|dtop_device_t
operator|,
name|dtop_message_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtop_keyboard_handler
name|__P
argument_list|(
operator|(
name|dtop_device_t
operator|,
name|dtop_message_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtopparam
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|,
expr|struct
name|termios
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtopstop
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dtopstart
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dtopKBDPutc
name|__P
argument_list|(
operator|(
name|dev_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tty
name|dtop_tty
index|[
name|NDTOP
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|dtopDivertXInput
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* X windows keyboard input routine */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|dtopMouseEvent
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* X windows mouse motion event routine */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|dtopMouseButtons
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* X windows mouse buttons event routine */
end_comment

begin_define
define|#
directive|define
name|DTOP_MAX_POLL
value|0x7fff
end_define

begin_comment
comment|/* about half a sec */
end_comment

begin_typedef
typedef|typedef
specifier|volatile
name|unsigned
name|int
modifier|*
name|data_reg_t
typedef|;
end_typedef

begin_comment
comment|/* uC  */
end_comment

begin_define
define|#
directive|define
name|DTOP_GET_BYTE
parameter_list|(
name|data
parameter_list|)
value|(((*(data))>> 8)& 0xff)
end_define

begin_define
define|#
directive|define
name|DTOP_PUT_BYTE
parameter_list|(
name|data
parameter_list|,
name|c
parameter_list|)
value|{ *(data) = (c)<< 8; }
end_define

begin_typedef
typedef|typedef
specifier|volatile
name|unsigned
name|int
modifier|*
name|poll_reg_t
typedef|;
end_typedef

begin_comment
comment|/* SIR */
end_comment

begin_define
define|#
directive|define
name|DTOP_RX_AVAIL
parameter_list|(
name|poll
parameter_list|)
value|(*(poll)& 1)
end_define

begin_define
define|#
directive|define
name|DTOP_TX_AVAIL
parameter_list|(
name|poll
parameter_list|)
value|(*(poll)& 2)
end_define

begin_define
define|#
directive|define
name|GET_SHORT
parameter_list|(
name|b0
parameter_list|,
name|b1
parameter_list|)
value|(((b0)<<8)|(b1))
end_define

begin_comment
comment|/*  * Driver status  */
end_comment

begin_struct
struct|struct
name|dtop_softc
block|{
name|data_reg_t
name|data
decl_stmt|;
name|poll_reg_t
name|poll
decl_stmt|;
name|char
name|polling_mode
decl_stmt|;
name|char
name|probed_once
decl_stmt|;
name|short
name|bad_pkts
decl_stmt|;
struct|struct
name|dtop_ds
block|{
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
name|dtop_device
name|status
decl_stmt|;
block|}
name|device
index|[
operator|(
name|DTOP_ADDR_DEFAULT
operator|-
name|DTOP_ADDR_FIRST
operator|)
operator|>>
literal|1
index|]
struct|;
define|#
directive|define
name|DTOP_DEVICE_NO
parameter_list|(
name|address
parameter_list|)
value|(((address)-DTOP_ADDR_FIRST)>>1)
block|}
name|dtop_softc
index|[
name|NDTOP
index|]
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|dtop_softc
modifier|*
name|dtop_softc_t
typedef|;
end_typedef

begin_decl_stmt
name|struct
name|tty
name|dtop_tty
index|[
name|NDTOP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dtopenabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Definition of the driver for the auto-configuration program.  */
end_comment

begin_function_decl
name|int
name|dtopprobe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dtopintr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|driver
name|dtopdriver
init|=
block|{
literal|"dtop"
block|,
name|dtopprobe
block|,
literal|0
block|,
literal|0
block|,
name|dtopintr
block|, }
decl_stmt|;
end_decl_stmt

begin_macro
name|dtopprobe
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pmax_ctlr
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|cntr
decl_stmt|;
name|int
name|dtopunit
init|=
name|cp
operator|->
name|pmax_unit
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|;
name|dtop_softc_t
name|dtop
decl_stmt|;
if|if
condition|(
name|dtopunit
operator|>=
name|NDTOP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|badaddr
argument_list|(
name|cp
operator|->
name|pmax_addr
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dtop
operator|=
operator|&
name|dtop_softc
index|[
name|dtopunit
index|]
expr_stmt|;
name|dtop
operator|->
name|poll
operator|=
operator|(
name|poll_reg_t
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|XINE_REG_INTR
argument_list|)
expr_stmt|;
name|dtop
operator|->
name|data
operator|=
operator|(
name|data_reg_t
operator|)
name|cp
operator|->
name|pmax_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DTOP_MAX_DEVICES
condition|;
name|i
operator|++
control|)
name|dtop
operator|->
name|device
index|[
name|i
index|]
operator|.
name|handler
operator|=
name|dtop_null_device_handler
expr_stmt|;
comment|/* a lot more needed here, fornow: */
name|dtop
operator|->
name|device
index|[
name|DTOP_DEVICE_NO
argument_list|(
literal|0x6a
argument_list|)
index|]
operator|.
name|handler
operator|=
name|dtop_locator_handler
expr_stmt|;
name|dtop
operator|->
name|device
index|[
name|DTOP_DEVICE_NO
argument_list|(
literal|0x6c
argument_list|)
index|]
operator|.
name|handler
operator|=
name|dtop_keyboard_handler
expr_stmt|;
name|dtop
operator|->
name|device
index|[
name|DTOP_DEVICE_NO
argument_list|(
literal|0x6c
argument_list|)
index|]
operator|.
name|status
operator|.
name|keyboard
operator|.
name|poll_frequency
operator|=
operator|(
name|hz
operator|*
literal|5
operator|)
operator|/
literal|100
expr_stmt|;
comment|/* x0.01 secs */
name|dtop
operator|->
name|device
index|[
name|DTOP_DEVICE_NO
argument_list|(
literal|0x6c
argument_list|)
index|]
operator|.
name|status
operator|.
name|keyboard
operator|.
name|k_ar_state
operator|=
name|K_AR_IDLE
expr_stmt|;
comment|/* 	 * Sometimes a first interrupt gets lost, so just in case 	 * poke it now. 	 */
name|dtopintr
argument_list|(
name|dtopunit
argument_list|)
expr_stmt|;
name|dtopenabled
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|dtopopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDTOP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|=
operator|&
name|dtop_tty
index|[
name|unit
index|]
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|dtopstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|dtopparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dtopparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|)
operator|&&
name|curproc
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|ttysleep
argument_list|(
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
name|ttopen
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|dtopclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|dtop_tty
index|[
name|unit
index|]
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
return|return
operator|(
name|ttyclose
argument_list|(
name|tp
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|dtopread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|dtop_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|dtopwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|dtop_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|dtopioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tp
operator|=
operator|&
name|dtop_tty
index|[
name|unit
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
name|ttyoutput
argument_list|(
literal|0
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
name|ttyoutput
argument_list|(
literal|0
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|DML_DTR
operator||
name|DML_DSR
operator||
name|DML_CAR
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interrupt routine  */
end_comment

begin_function
name|void
name|dtopintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|dtop_message
name|msg
decl_stmt|;
name|int
name|devno
decl_stmt|;
name|dtop_softc_t
name|dtop
decl_stmt|;
name|dtop
operator|=
operator|&
name|dtop_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|dtop_get_packet
argument_list|(
name|dtop
argument_list|,
operator|&
name|msg
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|dtopenabled
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
literal|"dtop: overrun (or stray)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|devno
operator|=
name|DTOP_DEVICE_NO
argument_list|(
name|msg
operator|.
name|src_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|devno
operator|<
literal|0
operator|||
name|devno
operator|>
literal|15
condition|)
return|return;
call|(
name|void
call|)
argument_list|(
operator|*
name|dtop
operator|->
name|device
index|[
name|devno
index|]
operator|.
name|handler
argument_list|)
argument_list|(
operator|&
name|dtop
operator|->
name|device
index|[
name|devno
index|]
operator|.
name|status
argument_list|,
operator|&
name|msg
argument_list|,
name|DTOP_EVENT_RECEIVE_PACKET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dtopstart
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|int
name|cc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* handle console specially */
if|if
condition|(
name|tp
operator|==
name|dtop_tty
condition|)
block|{
while|while
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
literal|0
condition|)
block|{
name|cc
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|&
literal|0x7f
expr_stmt|;
name|cnputc
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * After we flush the output queue we may need to wake 		 * up the process that made the output. 		 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dtopKBDPutc
parameter_list|(
name|dev
parameter_list|,
name|c
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
comment|/* 	 * Not yet, someday we will know how to send commands to the 	 * LK501 over the Access bus. 	 */
block|}
end_function

begin_comment
comment|/*  * Take a packet off dtop interface  * A packet MUST be there, this is not checked for.  */
end_comment

begin_define
define|#
directive|define
name|DTOP_ESC_CHAR
value|0xf8
end_define

begin_macro
name|dtop_escape
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
comment|/* I donno much about this stuff.. */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0xe8
case|:
return|return
operator|(
literal|0xf8
operator|)
return|;
case|case
literal|0xe9
case|:
return|return
operator|(
literal|0xf9
operator|)
return|;
case|case
literal|0xea
case|:
return|return
operator|(
literal|0xfa
operator|)
return|;
case|case
literal|0xeb
case|:
return|return
operator|(
literal|0xfb
operator|)
return|;
default|default:
comment|/* printf("{esc %x}", c); */
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|dtop_get_packet
argument_list|(
argument|dtop
argument_list|,
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|dtop_softc_t
name|dtop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtop_message_t
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|poll_reg_t
name|poll
decl_stmt|;
specifier|register
name|data_reg_t
name|data
decl_stmt|;
specifier|register
name|int
name|max
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
name|poll
operator|=
name|dtop
operator|->
name|poll
expr_stmt|;
name|data
operator|=
name|dtop
operator|->
name|data
expr_stmt|;
comment|/* 	 * The interface does not handle us the first byte, 	 * which is our address and cannot ever be anything 	 * else but 0x50.  This is a good thing, it makes 	 * the average packet exactly one word long, too. 	 */
for|for
control|(
name|max
operator|=
literal|0
init|;
operator|(
name|max
operator|<
name|DTOP_MAX_POLL
operator|)
operator|&&
operator|!
name|DTOP_RX_AVAIL
argument_list|(
name|poll
argument_list|)
condition|;
name|max
operator|++
control|)
name|DELAY
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
name|DTOP_MAX_POLL
condition|)
goto|goto
name|bad
goto|;
name|pkt
operator|->
name|src_address
operator|=
name|DTOP_GET_BYTE
argument_list|(
name|data
argument_list|)
expr_stmt|;
for|for
control|(
name|max
operator|=
literal|0
init|;
operator|(
name|max
operator|<
name|DTOP_MAX_POLL
operator|)
operator|&&
operator|!
name|DTOP_RX_AVAIL
argument_list|(
name|poll
argument_list|)
condition|;
name|max
operator|++
control|)
name|DELAY
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
name|DTOP_MAX_POLL
condition|)
goto|goto
name|bad
goto|;
name|pkt
operator|->
name|code
operator|.
name|bits
operator|=
name|DTOP_GET_BYTE
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* 	 * Now get data and checksum 	 */
name|len
operator|=
name|pkt
operator|->
name|code
operator|.
name|val
operator|.
name|len
operator|+
literal|1
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|again
label|:
for|for
control|(
name|max
operator|=
literal|0
init|;
operator|(
name|max
operator|<
name|DTOP_MAX_POLL
operator|)
operator|&&
operator|!
name|DTOP_RX_AVAIL
argument_list|(
name|poll
argument_list|)
condition|;
name|max
operator|++
control|)
name|DELAY
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
name|DTOP_MAX_POLL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|c
operator|==
name|DTOP_ESC_CHAR
condition|)
block|{
name|c
operator|=
name|dtop_escape
argument_list|(
name|DTOP_GET_BYTE
argument_list|(
name|data
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|DTOP_GET_BYTE
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|DTOP_ESC_CHAR
condition|)
goto|goto
name|again
goto|;
block|}
name|pkt
operator|->
name|body
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
name|bad
label|:
name|dtop
operator|->
name|bad_pkts
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get a keyboard char for the console  */
end_comment

begin_macro
name|dtopKBDGetc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|dtop_softc_t
name|dtop
decl_stmt|;
name|dtop
operator|=
operator|&
name|dtop_softc
index|[
literal|0
index|]
expr_stmt|;
name|again
label|:
name|c
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Now check keyboard 	 */
if|if
condition|(
name|DTOP_RX_AVAIL
argument_list|(
name|dtop
operator|->
name|poll
argument_list|)
condition|)
block|{
name|dtop_message
name|msg
decl_stmt|;
name|struct
name|dtop_ds
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
name|dtop_get_packet
argument_list|(
name|dtop
argument_list|,
operator|&
name|msg
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|ds
operator|=
operator|&
name|dtop
operator|->
name|device
index|[
name|DTOP_DEVICE_NO
argument_list|(
name|msg
operator|.
name|src_address
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|handler
operator|==
name|dtop_keyboard_handler
condition|)
block|{
name|c
operator|=
name|dtop_keyboard_handler
argument_list|(
operator|&
name|ds
operator|->
name|status
argument_list|,
operator|&
name|msg
argument_list|,
name|DTOP_EVENT_RECEIVE_PACKET
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
return|return
name|c
return|;
name|c
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
name|c
return|;
block|}
end_block

begin_function
name|int
name|dtopparam
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
name|ttymodem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* called too early to invoke ttymodem, sigh */
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop output on a line.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|dtopstop
argument_list|(
name|tp
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Default handler function  */
end_comment

begin_function
name|int
name|dtop_null_device_handler
parameter_list|(
name|dev
parameter_list|,
name|msg
parameter_list|,
name|event
parameter_list|,
name|outc
parameter_list|)
name|dtop_device_t
name|dev
decl_stmt|;
name|dtop_message_t
name|msg
decl_stmt|;
name|int
name|event
decl_stmt|;
name|int
name|outc
decl_stmt|;
block|{
comment|/* See if the message was to the default address (powerup) */
comment|/* Uhmm, donno how to handle this. Drop it */
if|if
condition|(
name|event
operator|==
name|DTOP_EVENT_RECEIVE_PACKET
condition|)
name|dev
operator|->
name|unknown_report
operator|=
operator|*
name|msg
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Handler for locator devices (mice)  */
end_comment

begin_function
name|int
name|dtop_locator_handler
parameter_list|(
name|dev
parameter_list|,
name|msg
parameter_list|,
name|event
parameter_list|,
name|outc
parameter_list|)
name|dtop_device_t
name|dev
decl_stmt|;
name|dtop_message_t
name|msg
decl_stmt|;
name|int
name|event
decl_stmt|;
name|int
name|outc
decl_stmt|;
block|{
specifier|register
name|unsigned
name|short
name|buttons
decl_stmt|;
specifier|register
name|short
name|coord
decl_stmt|;
specifier|register
name|int
name|moved
init|=
literal|0
decl_stmt|;
specifier|static
name|MouseReport
name|currentRep
decl_stmt|;
specifier|register
name|MouseReport
modifier|*
name|mrp
init|=
operator|&
name|currentRep
decl_stmt|;
if|if
condition|(
name|dtopMouseButtons
condition|)
block|{
comment|/* 		 * Do the position first 		 */
name|coord
operator|=
name|GET_SHORT
argument_list|(
name|msg
operator|->
name|body
index|[
literal|2
index|]
argument_list|,
name|msg
operator|->
name|body
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|mrp
operator|->
name|dx
operator|=
name|coord
expr_stmt|;
if|if
condition|(
name|coord
operator|!=
literal|0
condition|)
name|moved
operator|=
literal|1
expr_stmt|;
name|coord
operator|=
name|GET_SHORT
argument_list|(
name|msg
operator|->
name|body
index|[
literal|4
index|]
argument_list|,
name|msg
operator|->
name|body
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|coord
operator|=
operator|-
name|coord
expr_stmt|;
name|mrp
operator|->
name|dy
operator|=
name|coord
expr_stmt|;
if|if
condition|(
name|coord
operator|!=
literal|0
condition|)
name|moved
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Time for the buttons now 		 */
name|buttons
operator|=
name|GET_SHORT
argument_list|(
name|msg
operator|->
name|body
index|[
literal|0
index|]
argument_list|,
name|msg
operator|->
name|body
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mrp
operator|->
name|state
operator|=
name|MOUSE_Y_SIGN
operator||
name|MOUSE_X_SIGN
operator||
operator|(
name|buttons
operator|&
literal|0x7
operator|)
expr_stmt|;
if|if
condition|(
name|moved
condition|)
call|(
modifier|*
name|dtopMouseEvent
call|)
argument_list|(
name|mrp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|dtopMouseButtons
call|)
argument_list|(
name|mrp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handler for keyboard devices  * Special case: outc set for recv packet means  * we are inside the kernel debugger  */
end_comment

begin_function
name|int
name|dtop_keyboard_handler
parameter_list|(
name|dev
parameter_list|,
name|msg
parameter_list|,
name|event
parameter_list|,
name|outc
parameter_list|)
name|dtop_device_t
name|dev
decl_stmt|;
name|dtop_message_t
name|msg
decl_stmt|;
name|int
name|event
decl_stmt|;
name|int
name|outc
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|ls
decl_stmt|,
modifier|*
name|le
decl_stmt|,
modifier|*
name|ns
decl_stmt|,
modifier|*
name|ne
decl_stmt|;
name|u_char
name|save
index|[
literal|11
index|]
decl_stmt|,
name|retc
decl_stmt|;
name|int
name|msg_len
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|dtop_tty
index|[
literal|0
index|]
decl_stmt|;
comment|/* 	 * Fiddle about emulating an lk201 keyboard. The lk501 	 * designers carefully ensured that keyboard handlers could be 	 * stateless, then we turn around and use lots of state to 	 * emulate the stateful lk201, since the X11R5 X servers 	 * only know about the lk201... (oh well) 	 */
if|if
condition|(
name|event
operator|!=
name|DTOP_EVENT_RECEIVE_PACKET
condition|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|DTOP_EVENT_POLL
case|:
block|{
specifier|register
name|unsigned
name|int
name|t
decl_stmt|,
name|t0
decl_stmt|;
comment|/* 			 * Note we will always have at least the 			 * end-of-list marker present (a zero) 			 * Here stop and trigger of autorepeat. 			 * Do not repeat shift keys, either. 			 */
block|{
specifier|register
name|unsigned
name|char
name|uc
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|rpt_char
label|:
name|uc
operator|=
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|uc
operator|==
name|DTOP_KBD_EMPTY
condition|)
block|{
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|=
name|K_AR_OFF
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|uc
operator|>=
name|KEY_R_SHIFT
operator|)
operator|&&
operator|(
name|uc
operator|<=
name|KEY_R_ALT
operator|)
condition|)
block|{
comment|/* sometimes swapped. Grrr. */
if|if
condition|(
operator|++
name|i
operator|<
name|dev
operator|->
name|keyboard
operator|.
name|last_codes_count
condition|)
goto|goto
name|rpt_char
goto|;
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|=
name|K_AR_OFF
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|=
name|uc
expr_stmt|;
block|}
comment|/* 			 * Got a char. See if enough time from stroke, 			 * or from last repeat. 			 */
name|t0
operator|=
operator|(
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|==
name|K_AR_TRIGGER
operator|)
condition|?
literal|30
else|:
literal|500
expr_stmt|;
name|t
operator|=
name|TO_MS
argument_list|(
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|-
name|dev
operator|->
name|keyboard
operator|.
name|last_msec
operator|)
operator|<
name|t0
condition|)
return|return
literal|0
return|;
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|=
name|K_AR_TRIGGER
expr_stmt|;
if|if
condition|(
name|dtopDivertXInput
condition|)
block|{
call|(
modifier|*
name|dtopDivertXInput
call|)
argument_list|(
name|KEY_REPEAT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|outc
operator|=
name|kbdMapChar
argument_list|(
name|KEY_REPEAT
argument_list|)
operator|)
operator|>=
literal|0
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|outc
operator|,
name|tp
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
default|default:
name|printf
argument_list|(
literal|"Unknown dtop keyb\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|msg_len
operator|=
name|msg
operator|->
name|code
operator|.
name|val
operator|.
name|len
expr_stmt|;
comment|/* Check for errors */
name|c
operator|=
name|msg
operator|->
name|body
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|<
name|DTOP_KBD_KEY_MIN
operator|)
operator|&&
operator|(
name|c
operator|!=
name|DTOP_KBD_EMPTY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Keyboard error: %x %x %x..\n"
argument_list|,
name|msg_len
argument_list|,
name|c
argument_list|,
name|msg
operator|->
name|body
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|DTOP_KBD_OUT_ERR
condition|)
return|return
operator|-
literal|1
return|;
comment|/* spec sez if scan list overflow still there is data */
name|msg
operator|->
name|body
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dev
operator|->
name|keyboard
operator|.
name|last_msec
operator|=
name|TO_MS
argument_list|(
name|time
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
condition|)
block|{
case|case
name|K_AR_IDLE
case|:
if|if
condition|(
name|outc
operator|!=
literal|0xff
condition|)
comment|/* from debugger, might be too early */
name|dtop_keyboard_autorepeat
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|K_AR_TRIGGER
case|:
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|=
name|K_AR_ACTIVE
expr_stmt|;
break|break;
case|case
name|K_AR_ACTIVE
case|:
break|break;
case|case
name|K_AR_OFF
case|:
name|printf
argument_list|(
literal|"dtop keyb off?\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|=
name|K_AR_IDLE
expr_stmt|;
block|}
comment|/* 	 * To make things readable, do a first pass cancelling out 	 * all keys that are still pressed, and a second one generating 	 * events.  While generating events, do the upstrokes first 	 * from oldest to youngest, then the downstrokes from oldest 	 * to youngest.  This copes with lost packets and provides 	 * a reasonable model even if scans are too slow. 	 */
comment|/* make a copy of new state first */
if|if
condition|(
name|msg_len
operator|==
literal|1
condition|)
name|save
index|[
literal|0
index|]
operator|=
name|msg
operator|->
name|body
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|msg_len
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|msg
operator|->
name|body
argument_list|,
name|save
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
comment|/* 	 * Cancel out any keys in both the last and current message as 	 * they are unchanged. 	 */
if|if
condition|(
name|msg_len
operator|>
literal|0
operator|&&
name|dev
operator|->
name|keyboard
operator|.
name|last_codes_count
operator|>
literal|0
condition|)
block|{
name|ls
operator|=
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
expr_stmt|;
name|le
operator|=
operator|&
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
index|[
name|dev
operator|->
name|keyboard
operator|.
name|last_codes_count
index|]
expr_stmt|;
name|ne
operator|=
operator|&
name|msg
operator|->
name|body
index|[
name|msg_len
index|]
expr_stmt|;
for|for
control|(
init|;
name|ls
operator|<
name|le
condition|;
name|ls
operator|++
control|)
block|{
for|for
control|(
name|ns
operator|=
name|msg
operator|->
name|body
init|;
name|ns
operator|<
name|ne
condition|;
name|ns
operator|++
control|)
if|if
condition|(
operator|*
name|ls
operator|==
operator|*
name|ns
condition|)
block|{
operator|*
name|ls
operator|=
operator|*
name|ns
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * Now generate all upstrokes 	 */
name|le
operator|=
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
expr_stmt|;
name|ls
operator|=
operator|&
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
index|[
name|dev
operator|->
name|keyboard
operator|.
name|last_codes_count
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
init|;
name|ls
operator|>=
name|le
condition|;
name|ls
operator|--
control|)
if|if
condition|(
name|c
operator|=
operator|*
name|ls
condition|)
block|{
comment|/* 		 * If there are no other down/up keys currently down, we 		 * should actually generate a KEY_UP, but that would require 		 * a lot more state. 		 */
operator|(
name|void
operator|)
name|kbdMapChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|outc
operator|==
literal|0
operator|&&
name|dtopDivertXInput
condition|)
call|(
modifier|*
name|dtopDivertXInput
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * And finally the downstrokes 	 */
name|ne
operator|=
operator|(
name|char
operator|*
operator|)
name|msg
operator|->
name|body
expr_stmt|;
name|ns
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
operator|->
name|body
index|[
name|msg_len
operator|-
literal|1
index|]
expr_stmt|;
name|retc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|ns
operator|>=
name|ne
condition|;
name|ns
operator|--
control|)
if|if
condition|(
operator|*
name|ns
condition|)
block|{
name|c
operator|=
name|kbdMapChar
argument_list|(
operator|*
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|outc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dtopDivertXInput
condition|)
block|{
call|(
modifier|*
name|dtopDivertXInput
call|)
argument_list|(
operator|*
name|ns
argument_list|)
expr_stmt|;
name|c
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* consumed by X */
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|,
name|tp
operator|)
expr_stmt|;
block|}
comment|/* return the related keycode anyways */
if|if
condition|(
operator|(
name|c
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|retc
operator|==
literal|0
operator|)
condition|)
name|retc
operator|=
name|c
expr_stmt|;
block|}
name|outc
operator|=
name|retc
expr_stmt|;
comment|/* install new scan state */
if|if
condition|(
name|msg_len
operator|==
literal|1
condition|)
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
index|[
literal|0
index|]
operator|=
name|save
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|msg_len
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|save
argument_list|,
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
name|dev
operator|->
name|keyboard
operator|.
name|last_codes_count
operator|=
name|msg_len
expr_stmt|;
return|return
operator|(
name|outc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Polled operations: we must do autorepeat by hand. Sigh.  */
end_comment

begin_function
name|void
name|dtop_keyboard_autorepeat
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|dtop_device_t
name|dev
init|=
operator|(
name|dtop_device_t
operator|)
name|arg
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|!=
name|K_AR_IDLE
condition|)
operator|(
name|void
operator|)
name|dtop_keyboard_handler
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|DTOP_EVENT_POLL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|==
name|K_AR_OFF
condition|)
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|=
name|K_AR_IDLE
expr_stmt|;
else|else
name|timeout
argument_list|(
name|dtop_keyboard_autorepeat
argument_list|,
name|dev
argument_list|,
name|dev
operator|->
name|keyboard
operator|.
name|poll_frequency
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

