begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ralph Campbell and Rick Macklem.  *  * %sccs.include.redist.c%  *  *	@(#)dtop.c	7.3 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1991,1990,1989 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * 	Author: Alessandro Forin, Carnegie Mellon University  *  *	Hardware-level operations for the Desktop serial line  *	bus (i2c aka ACCESS).  */
end_comment

begin_comment
comment|/************************************************************ Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ********************************************************/
end_comment

begin_include
include|#
directive|include
file|<dtop.h>
end_include

begin_if
if|#
directive|if
name|NDTOP
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/map.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/machConst.h>
end_include

begin_include
include|#
directive|include
file|<machine/dc7085cons.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/pmaxtype.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/maxine.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/asic.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/dtopreg.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/fbreg.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|pmax_boardtype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ttrstrt
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dtop_keyboard_repeat
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtop_null_device_handler
name|__P
argument_list|(
operator|(
name|dtop_device_t
operator|,
name|dtop_message_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtop_locator_handler
name|__P
argument_list|(
operator|(
name|dtop_device_t
operator|,
name|dtop_message_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtop_keyboard_handler
name|__P
argument_list|(
operator|(
name|dtop_device_t
operator|,
name|dtop_message_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtopparam
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|,
expr|struct
name|termios
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtopstop
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dtopstart
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dtopKBDPutc
name|__P
argument_list|(
operator|(
name|dev_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tty
name|dtop_tty
index|[
name|NDTOP
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|dtopDivertXInput
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* X windows keyboard input routine */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|dtopMouseEvent
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* X windows mouse motion event routine */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|dtopMouseButtons
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* X windows mouse buttons event routine */
end_comment

begin_define
define|#
directive|define
name|DTOP_MAX_POLL
value|0x7fff
end_define

begin_comment
comment|/* about half a sec */
end_comment

begin_typedef
typedef|typedef
specifier|volatile
name|unsigned
name|int
modifier|*
name|data_reg_t
typedef|;
end_typedef

begin_comment
comment|/* uC  */
end_comment

begin_define
define|#
directive|define
name|DTOP_GET_BYTE
parameter_list|(
name|data
parameter_list|)
value|(((*(data))>> 8)& 0xff)
end_define

begin_define
define|#
directive|define
name|DTOP_PUT_BYTE
parameter_list|(
name|data
parameter_list|,
name|c
parameter_list|)
value|{ *(data) = (c)<< 8; }
end_define

begin_typedef
typedef|typedef
specifier|volatile
name|unsigned
name|int
modifier|*
name|poll_reg_t
typedef|;
end_typedef

begin_comment
comment|/* SIR */
end_comment

begin_define
define|#
directive|define
name|DTOP_RX_AVAIL
parameter_list|(
name|poll
parameter_list|)
value|(*(poll)& 1)
end_define

begin_define
define|#
directive|define
name|DTOP_TX_AVAIL
parameter_list|(
name|poll
parameter_list|)
value|(*(poll)& 2)
end_define

begin_define
define|#
directive|define
name|GET_SHORT
parameter_list|(
name|b0
parameter_list|,
name|b1
parameter_list|)
value|(((b0)<<8)|(b1))
end_define

begin_comment
comment|/*  * Driver status  */
end_comment

begin_struct
struct|struct
name|dtop_softc
block|{
name|data_reg_t
name|data
decl_stmt|;
name|poll_reg_t
name|poll
decl_stmt|;
name|char
name|polling_mode
decl_stmt|;
name|char
name|probed_once
decl_stmt|;
name|short
name|bad_pkts
decl_stmt|;
struct|struct
name|dtop_ds
block|{
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
name|dtop_device
name|status
decl_stmt|;
block|}
name|device
index|[
operator|(
name|DTOP_ADDR_DEFAULT
operator|-
name|DTOP_ADDR_FIRST
operator|)
operator|>>
literal|1
index|]
struct|;
define|#
directive|define
name|DTOP_DEVICE_NO
parameter_list|(
name|address
parameter_list|)
value|(((address)-DTOP_ADDR_FIRST)>>1)
block|}
name|dtop_softc
index|[
name|NDTOP
index|]
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|dtop_softc
modifier|*
name|dtop_softc_t
typedef|;
end_typedef

begin_decl_stmt
name|struct
name|tty
name|dtop_tty
index|[
name|NDTOP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * lk201 keyboard divisions and up/down mode key bitmap.  */
end_comment

begin_define
define|#
directive|define
name|NUMDIVS
value|14
end_define

begin_decl_stmt
specifier|static
name|u_char
name|divbeg
index|[
name|NUMDIVS
index|]
init|=
block|{
literal|0xbf
block|,
literal|0x91
block|,
literal|0xbc
block|,
literal|0xbd
block|,
literal|0xb0
block|,
literal|0xad
block|,
literal|0xa6
block|,
literal|0xa9
block|,
literal|0x88
block|,
literal|0x56
block|,
literal|0x63
block|,
literal|0x6f
block|,
literal|0x7b
block|,
literal|0x7e
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|divend
index|[
name|NUMDIVS
index|]
init|=
block|{
literal|0xff
block|,
literal|0xa5
block|,
literal|0xbc
block|,
literal|0xbe
block|,
literal|0xb2
block|,
literal|0xaf
block|,
literal|0xa8
block|,
literal|0xac
block|,
literal|0x90
block|,
literal|0x62
block|,
literal|0x6e
block|,
literal|0x7a
block|,
literal|0x7d
block|,
literal|0x87
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initial defaults, groups 5 and 6 are up/down  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|keymodes
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x0003e000
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Definition of the driver for the auto-configuration program.  */
end_comment

begin_function_decl
name|int
name|dtopprobe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dtopintr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|driver
name|dtopdriver
init|=
block|{
literal|"dtop"
block|,
name|dtopprobe
block|,
literal|0
block|,
literal|0
block|,
name|dtopintr
block|, }
decl_stmt|;
end_decl_stmt

begin_macro
name|dtopprobe
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pmax_ctlr
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|cntr
decl_stmt|;
name|int
name|dtopunit
init|=
name|cp
operator|->
name|pmax_unit
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|;
name|dtop_softc_t
name|dtop
decl_stmt|;
if|if
condition|(
name|dtopunit
operator|>=
name|NDTOP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|badaddr
argument_list|(
name|cp
operator|->
name|pmax_addr
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dtop
operator|=
operator|&
name|dtop_softc
index|[
name|dtopunit
index|]
expr_stmt|;
name|dtop
operator|->
name|poll
operator|=
operator|(
name|poll_reg_t
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|XINE_REG_INTR
argument_list|)
expr_stmt|;
name|dtop
operator|->
name|data
operator|=
operator|(
name|data_reg_t
operator|)
name|cp
operator|->
name|pmax_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DTOP_MAX_DEVICES
condition|;
name|i
operator|++
control|)
name|dtop
operator|->
name|device
index|[
name|i
index|]
operator|.
name|handler
operator|=
name|dtop_null_device_handler
expr_stmt|;
comment|/* a lot more needed here, fornow: */
name|dtop
operator|->
name|device
index|[
name|DTOP_DEVICE_NO
argument_list|(
literal|0x6a
argument_list|)
index|]
operator|.
name|handler
operator|=
name|dtop_locator_handler
expr_stmt|;
name|dtop
operator|->
name|device
index|[
name|DTOP_DEVICE_NO
argument_list|(
literal|0x6c
argument_list|)
index|]
operator|.
name|handler
operator|=
name|dtop_keyboard_handler
expr_stmt|;
name|dtop
operator|->
name|device
index|[
name|DTOP_DEVICE_NO
argument_list|(
literal|0x6c
argument_list|)
index|]
operator|.
name|status
operator|.
name|keyboard
operator|.
name|k_ar_state
operator|=
name|K_AR_IDLE
expr_stmt|;
name|dtop
operator|->
name|probed_once
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"dtop%d at nexus0 csr 0x%x priority %d\n"
argument_list|,
name|cp
operator|->
name|pmax_unit
argument_list|,
name|cp
operator|->
name|pmax_addr
argument_list|,
name|cp
operator|->
name|pmax_pri
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|dtopopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDTOP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|=
operator|&
name|dtop_tty
index|[
name|unit
index|]
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|dtopstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|dtopparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dtopparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|)
operator|&&
name|curproc
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|ttysleep
argument_list|(
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
name|ttopen
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|dtopclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|dtop_tty
index|[
name|unit
index|]
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
return|return
operator|(
name|ttyclose
argument_list|(
name|tp
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|dtopread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|dtop_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|dtopwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|dtop_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|dtopioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tp
operator|=
operator|&
name|dtop_tty
index|[
name|unit
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
name|ttyoutput
argument_list|(
literal|0
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
name|ttyoutput
argument_list|(
literal|0
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|DML_DTR
operator||
name|DML_DSR
operator||
name|DML_CAR
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interrupt routine  */
end_comment

begin_function
name|void
name|dtopintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|dtop_message
name|msg
decl_stmt|;
name|int
name|devno
decl_stmt|;
name|dtop_softc_t
name|dtop
decl_stmt|;
name|dtop
operator|=
operator|&
name|dtop_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|dtop_get_packet
argument_list|(
name|dtop
argument_list|,
operator|&
name|msg
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"dtop: overrun (or stray)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	     * Ugh! The most common occurrence of a data overrun is upon a 	     * key press and the result is a software generated "stuck key". 	     * All I can think to do is fake an "all keys up" whenever a 	     * data overrun occurs. 	     */
name|msg
operator|.
name|src_address
operator|=
literal|0x6c
expr_stmt|;
name|msg
operator|.
name|code
operator|.
name|val
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|body
index|[
literal|0
index|]
operator|=
name|DTOP_KBD_EMPTY
expr_stmt|;
block|}
comment|/* 	 * If not probed yet, just throw the data away. 	 */
if|if
condition|(
operator|!
name|dtop
operator|->
name|probed_once
condition|)
return|return;
name|devno
operator|=
name|DTOP_DEVICE_NO
argument_list|(
name|msg
operator|.
name|src_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|devno
operator|<
literal|0
operator|||
name|devno
operator|>
literal|15
condition|)
return|return;
call|(
name|void
call|)
argument_list|(
operator|*
name|dtop
operator|->
name|device
index|[
name|devno
index|]
operator|.
name|handler
argument_list|)
argument_list|(
operator|&
name|dtop
operator|->
name|device
index|[
name|devno
index|]
operator|.
name|status
argument_list|,
operator|&
name|msg
argument_list|,
name|DTOP_EVENT_RECEIVE_PACKET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dtopstart
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|int
name|cc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* handle console specially */
if|if
condition|(
name|tp
operator|==
name|dtop_tty
condition|)
block|{
while|while
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
literal|0
condition|)
block|{
name|cc
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|&
literal|0x7f
expr_stmt|;
name|cnputc
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * After we flush the output queue we may need to wake 		 * up the process that made the output. 		 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dtopKBDPutc
parameter_list|(
name|dev
parameter_list|,
name|c
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|param
init|=
literal|0
decl_stmt|,
name|cmd
decl_stmt|,
name|mod
decl_stmt|,
name|typ
decl_stmt|;
specifier|static
name|u_char
name|parms
index|[
literal|2
index|]
decl_stmt|;
comment|/* 	 * Emulate the lk201 command codes. 	 */
if|if
condition|(
name|param
operator|==
literal|0
condition|)
block|{
name|typ
operator|=
operator|(
name|c
operator|&
literal|0x1
operator|)
expr_stmt|;
name|cmd
operator|=
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|mod
operator|=
operator|(
operator|(
name|c
operator|>>
literal|1
operator|)
operator|&
literal|0x3
operator|)
expr_stmt|;
block|}
else|else
name|parms
index|[
name|param
operator|-
literal|1
index|]
operator|=
operator|(
name|c
operator|&
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|typ
condition|)
block|{
comment|/* 			 * A peripheral command code. Someday this driver 			 * should know how to send commands to the lk501, 			 * but until then this is all essentially a no-op. 			 */
empty_stmt|;
block|}
else|else
block|{
comment|/* 			 * Set modes. These have to be emulated in software. 			 */
if|if
condition|(
name|cmd
operator|>
literal|0
operator|&&
name|cmd
operator|<
literal|15
condition|)
block|{
name|cmd
operator|--
expr_stmt|;
if|if
condition|(
name|mod
operator|&
literal|0x2
condition|)
for|for
control|(
name|i
operator|=
name|divbeg
index|[
name|cmd
index|]
init|;
name|i
operator|<=
name|divend
index|[
name|cmd
index|]
condition|;
name|i
operator|++
control|)
name|keymodes
index|[
name|i
operator|>>
literal|5
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|divbeg
index|[
name|cmd
index|]
init|;
name|i
operator|<=
name|divend
index|[
name|cmd
index|]
condition|;
name|i
operator|++
control|)
name|keymodes
index|[
name|i
operator|>>
literal|5
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
block|}
block|}
name|param
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|param
operator|>
literal|2
condition|)
name|param
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take a packet off dtop interface  * A packet MUST be there, this is not checked for.  */
end_comment

begin_define
define|#
directive|define
name|DTOP_ESC_CHAR
value|0xf8
end_define

begin_macro
name|dtop_escape
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
comment|/* I donno much about this stuff.. */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0xe8
case|:
return|return
operator|(
literal|0xf8
operator|)
return|;
case|case
literal|0xe9
case|:
return|return
operator|(
literal|0xf9
operator|)
return|;
case|case
literal|0xea
case|:
return|return
operator|(
literal|0xfa
operator|)
return|;
case|case
literal|0xeb
case|:
return|return
operator|(
literal|0xfb
operator|)
return|;
default|default:
comment|/* printf("{esc %x}", c); */
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|dtop_get_packet
argument_list|(
argument|dtop
argument_list|,
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|dtop_softc_t
name|dtop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtop_message_t
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|poll_reg_t
name|poll
decl_stmt|;
specifier|register
name|data_reg_t
name|data
decl_stmt|;
specifier|register
name|int
name|max
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
name|poll
operator|=
name|dtop
operator|->
name|poll
expr_stmt|;
name|data
operator|=
name|dtop
operator|->
name|data
expr_stmt|;
comment|/* 	 * The interface does not handle us the first byte, 	 * which is our address and cannot ever be anything 	 * else but 0x50.  This is a good thing, it makes 	 * the average packet exactly one word long, too. 	 */
for|for
control|(
name|max
operator|=
literal|0
init|;
operator|(
name|max
operator|<
name|DTOP_MAX_POLL
operator|)
operator|&&
operator|!
name|DTOP_RX_AVAIL
argument_list|(
name|poll
argument_list|)
condition|;
name|max
operator|++
control|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
name|DTOP_MAX_POLL
condition|)
goto|goto
name|bad
goto|;
name|pkt
operator|->
name|src_address
operator|=
name|DTOP_GET_BYTE
argument_list|(
name|data
argument_list|)
expr_stmt|;
for|for
control|(
name|max
operator|=
literal|0
init|;
operator|(
name|max
operator|<
name|DTOP_MAX_POLL
operator|)
operator|&&
operator|!
name|DTOP_RX_AVAIL
argument_list|(
name|poll
argument_list|)
condition|;
name|max
operator|++
control|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
name|DTOP_MAX_POLL
condition|)
goto|goto
name|bad
goto|;
name|pkt
operator|->
name|code
operator|.
name|bits
operator|=
name|DTOP_GET_BYTE
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* 	 * Now get data and checksum 	 */
name|len
operator|=
name|pkt
operator|->
name|code
operator|.
name|val
operator|.
name|len
operator|+
literal|1
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|again
label|:
for|for
control|(
name|max
operator|=
literal|0
init|;
operator|(
name|max
operator|<
name|DTOP_MAX_POLL
operator|)
operator|&&
operator|!
name|DTOP_RX_AVAIL
argument_list|(
name|poll
argument_list|)
condition|;
name|max
operator|++
control|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
name|DTOP_MAX_POLL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|c
operator|==
name|DTOP_ESC_CHAR
condition|)
block|{
name|c
operator|=
name|dtop_escape
argument_list|(
name|DTOP_GET_BYTE
argument_list|(
name|data
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|DTOP_GET_BYTE
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|DTOP_ESC_CHAR
condition|)
goto|goto
name|again
goto|;
block|}
name|pkt
operator|->
name|body
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
name|bad
label|:
name|dtop
operator|->
name|bad_pkts
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get a keyboard char for the console  */
end_comment

begin_macro
name|dtopKBDGetc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|dtop_softc_t
name|dtop
decl_stmt|;
name|dtop
operator|=
operator|&
name|dtop_softc
index|[
literal|0
index|]
expr_stmt|;
name|again
label|:
name|c
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Now check keyboard 	 */
if|if
condition|(
name|DTOP_RX_AVAIL
argument_list|(
name|dtop
operator|->
name|poll
argument_list|)
condition|)
block|{
name|dtop_message
name|msg
decl_stmt|;
name|struct
name|dtop_ds
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
name|dtop_get_packet
argument_list|(
name|dtop
argument_list|,
operator|&
name|msg
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|ds
operator|=
operator|&
name|dtop
operator|->
name|device
index|[
name|DTOP_DEVICE_NO
argument_list|(
name|msg
operator|.
name|src_address
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|handler
operator|==
name|dtop_keyboard_handler
condition|)
block|{
name|c
operator|=
name|dtop_keyboard_handler
argument_list|(
operator|&
name|ds
operator|->
name|status
argument_list|,
operator|&
name|msg
argument_list|,
name|DTOP_EVENT_RECEIVE_PACKET
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
return|return
name|c
return|;
name|c
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
name|c
return|;
block|}
end_block

begin_function
name|int
name|dtopparam
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
name|ttymodem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* called too early to invoke ttymodem, sigh */
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop output on a line.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|dtopstop
argument_list|(
name|tp
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Default handler function  */
end_comment

begin_function
name|int
name|dtop_null_device_handler
parameter_list|(
name|dev
parameter_list|,
name|msg
parameter_list|,
name|event
parameter_list|,
name|outc
parameter_list|)
name|dtop_device_t
name|dev
decl_stmt|;
name|dtop_message_t
name|msg
decl_stmt|;
name|int
name|event
decl_stmt|;
name|int
name|outc
decl_stmt|;
block|{
comment|/* See if the message was to the default address (powerup) */
comment|/* Uhmm, donno how to handle this. Drop it */
if|if
condition|(
name|event
operator|==
name|DTOP_EVENT_RECEIVE_PACKET
condition|)
name|dev
operator|->
name|unknown_report
operator|=
operator|*
name|msg
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Handler for locator devices (mice)  */
end_comment

begin_function
name|int
name|dtop_locator_handler
parameter_list|(
name|dev
parameter_list|,
name|msg
parameter_list|,
name|event
parameter_list|,
name|outc
parameter_list|)
name|dtop_device_t
name|dev
decl_stmt|;
name|dtop_message_t
name|msg
decl_stmt|;
name|int
name|event
decl_stmt|;
name|int
name|outc
decl_stmt|;
block|{
specifier|register
name|unsigned
name|short
name|buttons
decl_stmt|;
specifier|register
name|short
name|coord
decl_stmt|;
specifier|register
name|int
name|moved
init|=
literal|0
decl_stmt|;
specifier|static
name|MouseReport
name|currentRep
decl_stmt|;
specifier|register
name|MouseReport
modifier|*
name|mrp
init|=
operator|&
name|currentRep
decl_stmt|;
if|if
condition|(
name|dtopMouseButtons
condition|)
block|{
name|mrp
operator|->
name|state
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Do the position first 		 */
name|coord
operator|=
name|GET_SHORT
argument_list|(
name|msg
operator|->
name|body
index|[
literal|2
index|]
argument_list|,
name|msg
operator|->
name|body
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|coord
operator|<
literal|0
condition|)
block|{
name|coord
operator|=
operator|-
name|coord
expr_stmt|;
name|moved
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coord
operator|>
literal|0
condition|)
block|{
name|mrp
operator|->
name|state
operator||=
name|MOUSE_X_SIGN
expr_stmt|;
name|moved
operator|=
literal|1
expr_stmt|;
block|}
name|mrp
operator|->
name|dx
operator|=
operator|(
name|coord
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|coord
operator|=
name|GET_SHORT
argument_list|(
name|msg
operator|->
name|body
index|[
literal|4
index|]
argument_list|,
name|msg
operator|->
name|body
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|coord
operator|<
literal|0
condition|)
block|{
name|coord
operator|=
operator|-
name|coord
expr_stmt|;
name|moved
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coord
operator|>
literal|0
condition|)
block|{
name|mrp
operator|->
name|state
operator||=
name|MOUSE_Y_SIGN
expr_stmt|;
name|moved
operator|=
literal|1
expr_stmt|;
block|}
name|mrp
operator|->
name|dy
operator|=
operator|(
name|coord
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* 		 * Time for the buttons now 		 * Shuffle button bits around to serial mouse order. 		 */
name|buttons
operator|=
name|GET_SHORT
argument_list|(
name|msg
operator|->
name|body
index|[
literal|0
index|]
argument_list|,
name|msg
operator|->
name|body
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mrp
operator|->
name|state
operator||=
operator|(
operator|(
operator|(
name|buttons
operator|>>
literal|1
operator|)
operator|&
literal|0x3
operator|)
operator||
operator|(
operator|(
name|buttons
operator|<<
literal|2
operator|)
operator|&
literal|0x4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|moved
condition|)
call|(
modifier|*
name|dtopMouseEvent
call|)
argument_list|(
name|mrp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|dtopMouseButtons
call|)
argument_list|(
name|mrp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handler for keyboard devices  * Special case: outc set for recv packet means  * we are inside the kernel debugger  */
end_comment

begin_function
name|int
name|dtop_keyboard_handler
parameter_list|(
name|dev
parameter_list|,
name|msg
parameter_list|,
name|event
parameter_list|,
name|outc
parameter_list|)
name|dtop_device_t
name|dev
decl_stmt|;
name|dtop_message_t
name|msg
decl_stmt|;
name|int
name|event
decl_stmt|;
name|int
name|outc
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|ls
decl_stmt|,
modifier|*
name|le
decl_stmt|,
modifier|*
name|ns
decl_stmt|,
modifier|*
name|ne
decl_stmt|;
name|u_char
name|save
index|[
literal|11
index|]
decl_stmt|,
name|retc
decl_stmt|;
name|int
name|msg_len
decl_stmt|,
name|c
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|dtop_tty
index|[
literal|0
index|]
decl_stmt|;
comment|/* 	 * Fiddle about emulating an lk201 keyboard. The lk501 	 * designers carefully ensured that keyboard handlers could be 	 * stateless, then we turn around and use lots of state to 	 * emulate the stateful lk201, since the X11R5 X servers 	 * only know about the lk201... (oh well) 	 */
comment|/* 	 * Turn off any autorepeat timeout. 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|!=
name|K_AR_IDLE
condition|)
block|{
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|=
name|K_AR_IDLE
expr_stmt|;
name|untimeout
argument_list|(
name|dtop_keyboard_repeat
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|msg_len
operator|=
name|msg
operator|->
name|code
operator|.
name|val
operator|.
name|len
expr_stmt|;
comment|/* Check for errors */
name|c
operator|=
name|msg
operator|->
name|body
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|<
name|DTOP_KBD_KEY_MIN
operator|)
operator|&&
operator|(
name|c
operator|!=
name|DTOP_KBD_EMPTY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Keyboard error: %x %x %x..\n"
argument_list|,
name|msg_len
argument_list|,
name|c
argument_list|,
name|msg
operator|->
name|body
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|c
operator|!=
name|DTOP_KBD_OUT_ERR
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
comment|/* 		 * Fake an "all ups" to avoid the stuck key syndrome. 		 */
name|c
operator|=
name|msg
operator|->
name|body
index|[
literal|0
index|]
operator|=
name|DTOP_KBD_EMPTY
expr_stmt|;
name|msg_len
operator|=
literal|1
expr_stmt|;
block|}
name|dev
operator|->
name|keyboard
operator|.
name|last_msec
operator|=
name|TO_MS
argument_list|(
name|time
argument_list|)
expr_stmt|;
comment|/* 	 * To make things readable, do a first pass cancelling out 	 * all keys that are still pressed, and a second one generating 	 * events.  While generating events, do the upstrokes first 	 * from oldest to youngest, then the downstrokes from oldest 	 * to youngest.  This copes with lost packets and provides 	 * a reasonable model even if scans are too slow. 	 */
comment|/* make a copy of new state first */
if|if
condition|(
name|msg_len
operator|==
literal|1
condition|)
name|save
index|[
literal|0
index|]
operator|=
name|msg
operator|->
name|body
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|msg_len
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|msg
operator|->
name|body
argument_list|,
name|save
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
comment|/* 	 * Cancel out any keys in both the last and current message as 	 * they are unchanged. 	 */
if|if
condition|(
name|msg_len
operator|>
literal|0
operator|&&
name|dev
operator|->
name|keyboard
operator|.
name|last_codes_count
operator|>
literal|0
condition|)
block|{
name|ls
operator|=
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
expr_stmt|;
name|le
operator|=
operator|&
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
index|[
name|dev
operator|->
name|keyboard
operator|.
name|last_codes_count
index|]
expr_stmt|;
name|ne
operator|=
operator|&
name|msg
operator|->
name|body
index|[
name|msg_len
index|]
expr_stmt|;
for|for
control|(
init|;
name|ls
operator|<
name|le
condition|;
name|ls
operator|++
control|)
block|{
for|for
control|(
name|ns
operator|=
name|msg
operator|->
name|body
init|;
name|ns
operator|<
name|ne
condition|;
name|ns
operator|++
control|)
if|if
condition|(
operator|*
name|ls
operator|==
operator|*
name|ns
condition|)
block|{
operator|*
name|ls
operator|=
operator|*
name|ns
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * Now generate all upstrokes 	 */
name|le
operator|=
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
expr_stmt|;
name|ls
operator|=
operator|&
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
index|[
name|dev
operator|->
name|keyboard
operator|.
name|last_codes_count
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
init|;
name|ls
operator|>=
name|le
condition|;
name|ls
operator|--
control|)
if|if
condition|(
name|c
operator|=
operator|*
name|ls
condition|)
block|{
operator|(
name|void
operator|)
name|kbdMapChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|outc
operator|==
literal|0
operator|&&
name|dtopDivertXInput
operator|&&
operator|(
name|keymodes
index|[
operator|(
name|c
operator|>>
literal|5
operator|)
operator|&
literal|0x7
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|0x1f
operator|)
operator|)
operator|)
condition|)
call|(
modifier|*
name|dtopDivertXInput
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * And finally the downstrokes 	 */
name|ne
operator|=
operator|(
name|char
operator|*
operator|)
name|msg
operator|->
name|body
expr_stmt|;
name|ns
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
operator|->
name|body
index|[
name|msg_len
operator|-
literal|1
index|]
expr_stmt|;
name|retc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|ns
operator|>=
name|ne
condition|;
name|ns
operator|--
control|)
if|if
condition|(
operator|*
name|ns
condition|)
block|{
name|c
operator|=
name|kbdMapChar
argument_list|(
operator|*
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|outc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dtopDivertXInput
condition|)
block|{
call|(
modifier|*
name|dtopDivertXInput
call|)
argument_list|(
operator|*
name|ns
argument_list|)
expr_stmt|;
name|c
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* consumed by X */
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|,
name|tp
operator|)
expr_stmt|;
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|=
name|K_AR_ACTIVE
expr_stmt|;
block|}
comment|/* return the related keycode anyways */
if|if
condition|(
operator|(
name|c
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|retc
operator|==
literal|0
operator|)
condition|)
name|retc
operator|=
name|c
expr_stmt|;
block|}
name|outc
operator|=
name|retc
expr_stmt|;
comment|/* install new scan state */
if|if
condition|(
name|msg_len
operator|==
literal|1
condition|)
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
index|[
literal|0
index|]
operator|=
name|save
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|msg_len
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|save
argument_list|,
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
name|dev
operator|->
name|keyboard
operator|.
name|last_codes_count
operator|=
name|msg_len
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|==
name|K_AR_ACTIVE
condition|)
name|timeout
argument_list|(
name|dtop_keyboard_repeat
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dev
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|outc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do an autorepeat as required.  */
end_comment

begin_function
name|void
name|dtop_keyboard_repeat
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|dtop_device_t
name|dev
init|=
operator|(
name|dtop_device_t
operator|)
name|arg
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|dtop_tty
decl_stmt|;
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|,
name|gotone
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|keyboard
operator|.
name|last_codes_count
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|int
operator|)
name|dev
operator|->
name|keyboard
operator|.
name|last_codes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|DTOP_KBD_EMPTY
operator|&&
operator|(
name|keymodes
index|[
operator|(
name|c
operator|>>
literal|5
operator|)
operator|&
literal|0x7
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|0x1f
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|=
name|K_AR_TRIGGER
expr_stmt|;
if|if
condition|(
name|dtopDivertXInput
condition|)
block|{
call|(
modifier|*
name|dtopDivertXInput
call|)
argument_list|(
name|KEY_REPEAT
argument_list|)
expr_stmt|;
name|gotone
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|kbdMapChar
argument_list|(
name|KEY_REPEAT
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|,
name|tp
operator|)
expr_stmt|;
name|gotone
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|gotone
condition|)
name|timeout
argument_list|(
name|dtop_keyboard_repeat
argument_list|,
name|arg
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
else|else
name|dev
operator|->
name|keyboard
operator|.
name|k_ar_state
operator|=
name|K_AR_IDLE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

