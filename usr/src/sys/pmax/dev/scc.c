begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ralph Campbell and Rick Macklem.  *  * %sccs.include.redist.c%  *  *	@(#)scc.c	7.3 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1991,1990,1989 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|<scc.h>
end_include

begin_if
if|#
directive|if
name|NSCC
operator|>
literal|0
end_if

begin_comment
comment|/*  * Intel 82530 dual usart chip driver. Supports the serial port(s) on the  * Personal DECstation 5000/xx and DECstation 5000/1xx, plus the keyboard  * and mouse on the 5000/1xx. (Don't ask me where the A channel signals  * are on the 5000/xx.)  *  * See: Intel MicroCommunications Handbook, Section 2, pg. 155-173, 1992.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/map.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmioctl.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/pdma.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/sccreg.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/fbreg.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/cons.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/pmaxtype.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|pmax_boardtype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|consdev
name|cn_tab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ttrstrt
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|KBDReset
name|__P
argument_list|(
operator|(
name|dev_t
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|MouseInit
name|__P
argument_list|(
operator|(
name|dev_t
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Driver information for auto-configuration stuff.  */
end_comment

begin_decl_stmt
name|int
name|sccprobe
argument_list|()
decl_stmt|,
name|sccopen
argument_list|()
decl_stmt|,
name|sccparam
argument_list|()
decl_stmt|,
name|sccGetc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sccintr
argument_list|()
decl_stmt|,
name|sccstart
argument_list|()
decl_stmt|,
name|sccPutc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|driver
name|sccdriver
init|=
block|{
literal|"scc"
block|,
name|sccprobe
block|,
literal|0
block|,
literal|0
block|,
name|sccintr
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NSCCLINE
value|(NSCC*2)
end_define

begin_define
define|#
directive|define
name|SCCUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> 1)
end_define

begin_define
define|#
directive|define
name|SCCLINE
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x1)
end_define

begin_decl_stmt
name|struct
name|tty
name|scc_tty
index|[
name|NSCCLINE
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|sccDivertXInput
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* X windows keyboard input routine */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|sccMouseEvent
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* X windows mouse motion event routine */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|sccMouseButtons
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* X windows mouse buttons event routine */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|debugChar
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|scc_modem_intr
argument_list|()
decl_stmt|,
name|sccreset
argument_list|()
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|scc_softc
block|{
name|struct
name|pdma
name|scc_pdma
index|[
literal|2
index|]
decl_stmt|;
struct|struct
block|{
name|u_char
name|wr1
decl_stmt|;
name|u_char
name|wr3
decl_stmt|;
name|u_char
name|wr4
decl_stmt|;
name|u_char
name|wr5
decl_stmt|;
name|u_char
name|wr14
decl_stmt|;
block|}
name|scc_wreg
index|[
literal|2
index|]
struct|;
name|int
name|scc_softCAR
decl_stmt|;
block|}
name|scc_softc
index|[
name|NSCC
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|speedtab
name|sccspeedtab
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|50
block|,
literal|4606
block|,
literal|75
block|,
literal|3070
block|,
literal|110
block|,
literal|2093
block|,
literal|134
block|,
literal|1711
block|,
literal|150
block|,
literal|1534
block|,
literal|300
block|,
literal|766
block|,
literal|600
block|,
literal|382
block|,
literal|1200
block|,
literal|190
block|,
literal|1800
block|,
literal|126
block|,
literal|2400
block|,
literal|94
block|,
literal|4800
block|,
literal|46
block|,
literal|9600
block|,
literal|22
block|,
literal|19200
block|,
literal|10
block|,
literal|38400
block|,
literal|4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PORTSELECTOR
end_ifndef

begin_define
define|#
directive|define
name|ISPEED
value|TTYDEF_SPEED
end_define

begin_define
define|#
directive|define
name|LFLAG
value|TTYDEF_LFLAG
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISPEED
value|B4800
end_define

begin_define
define|#
directive|define
name|LFLAG
value|(TTYDEF_LFLAG& ~ECHO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Test to see if device is present.  * Return true if found and initialized ok.  */
end_comment

begin_expr_stmt
name|sccprobe
argument_list|(
name|cp
argument_list|)
specifier|register
expr|struct
name|pmax_ctlr
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|scc_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|pdma
modifier|*
name|pdp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|cntr
decl_stmt|;
name|struct
name|tty
name|ctty
decl_stmt|;
name|struct
name|termios
name|cterm
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|pmax_unit
operator|>=
name|NSCC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|badaddr
argument_list|(
name|cp
operator|->
name|pmax_addr
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * For a remote console, wait a while for previous output to 	 * complete. 	 */
if|if
condition|(
name|major
argument_list|(
name|cn_tab
operator|.
name|cn_dev
argument_list|)
operator|==
name|SCCDEV
operator|&&
name|cn_tab
operator|.
name|cn_screen
operator|==
literal|0
operator|&&
name|SCCUNIT
argument_list|(
name|cn_tab
operator|.
name|cn_dev
argument_list|)
operator|==
name|cp
operator|->
name|pmax_unit
condition|)
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|scc_softc
index|[
name|cp
operator|->
name|pmax_unit
index|]
expr_stmt|;
name|pdp
operator|=
operator|&
name|sc
operator|->
name|scc_pdma
index|[
literal|0
index|]
expr_stmt|;
comment|/* init pseudo DMA structures */
name|tp
operator|=
operator|&
name|scc_tty
index|[
name|cp
operator|->
name|pmax_unit
operator|*
literal|2
index|]
expr_stmt|;
for|for
control|(
name|cntr
operator|=
literal|0
init|;
name|cntr
operator|<
literal|2
condition|;
name|cntr
operator|++
control|)
block|{
name|pdp
operator|->
name|p_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|cp
operator|->
name|pmax_addr
expr_stmt|;
name|pdp
operator|->
name|p_arg
operator|=
operator|(
name|int
operator|)
name|tp
expr_stmt|;
name|pdp
operator|->
name|p_fcn
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
expr_stmt|;
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
name|pdp
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
call|(
name|dev_t
call|)
argument_list|(
operator|(
name|cp
operator|->
name|pmax_unit
operator|<<
literal|1
operator|)
operator||
name|cntr
argument_list|)
expr_stmt|;
name|pdp
operator|++
operator|,
name|tp
operator|++
expr_stmt|;
block|}
name|sc
operator|->
name|scc_softCAR
operator|=
name|cp
operator|->
name|pmax_flags
operator||
literal|0x2
expr_stmt|;
comment|/* reset chip */
name|sccreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Special handling for consoles. 	 */
if|if
condition|(
name|cn_tab
operator|.
name|cn_screen
condition|)
block|{
if|if
condition|(
name|cn_tab
operator|.
name|cn_kbdgetc
operator|==
name|sccGetc
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|pmax_unit
operator|==
literal|1
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|ctty
operator|.
name|t_dev
operator|=
name|makedev
argument_list|(
name|SCCDEV
argument_list|,
name|SCCKBD_PORT
argument_list|)
expr_stmt|;
name|cterm
operator|.
name|c_cflag
operator|=
name|CS8
expr_stmt|;
name|cterm
operator|.
name|c_ospeed
operator|=
name|cterm
operator|.
name|c_ispeed
operator|=
literal|4800
expr_stmt|;
operator|(
name|void
operator|)
name|sccparam
argument_list|(
operator|&
name|ctty
argument_list|,
operator|&
name|cterm
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 				 * For some reason doing this hangs the 3min 				 * during booting. Fortunately the keyboard 				 * works ok without it. 				 */
name|KBDReset
argument_list|(
name|ctty
operator|.
name|t_dev
argument_list|,
name|sccPutc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|pmax_unit
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|ctty
operator|.
name|t_dev
operator|=
name|makedev
argument_list|(
name|SCCDEV
argument_list|,
name|SCCMOUSE_PORT
argument_list|)
expr_stmt|;
name|cterm
operator|.
name|c_cflag
operator|=
name|CS8
operator||
name|PARENB
operator||
name|PARODD
expr_stmt|;
name|cterm
operator|.
name|c_ospeed
operator|=
name|cterm
operator|.
name|c_ispeed
operator|=
literal|4800
expr_stmt|;
operator|(
name|void
operator|)
name|sccparam
argument_list|(
operator|&
name|ctty
argument_list|,
operator|&
name|cterm
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|MouseInit
argument_list|(
name|ctty
operator|.
name|t_dev
argument_list|,
name|sccPutc
argument_list|,
name|sccGetc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|SCCUNIT
argument_list|(
name|cn_tab
operator|.
name|cn_dev
argument_list|)
operator|==
name|cp
operator|->
name|pmax_unit
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|ctty
operator|.
name|t_dev
operator|=
name|cn_tab
operator|.
name|cn_dev
expr_stmt|;
name|cterm
operator|.
name|c_cflag
operator|=
name|CS8
expr_stmt|;
name|cterm
operator|.
name|c_ospeed
operator|=
name|cterm
operator|.
name|c_ispeed
operator|=
literal|9600
expr_stmt|;
operator|(
name|void
operator|)
name|sccparam
argument_list|(
operator|&
name|ctty
argument_list|,
operator|&
name|cterm
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|cn_tab
operator|.
name|cn_disabled
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"scc%d at nexus0 csr 0x%x priority %d\n"
argument_list|,
name|cp
operator|->
name|pmax_unit
argument_list|,
name|cp
operator|->
name|pmax_addr
argument_list|,
name|cp
operator|->
name|pmax_pri
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Reset the chip.  */
end_comment

begin_function
specifier|static
name|void
name|sccreset
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|scc_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|scc_regmap_t
modifier|*
name|regs
decl_stmt|;
specifier|register
name|u_char
name|val
decl_stmt|;
name|regs
operator|=
operator|(
name|scc_regmap_t
operator|*
operator|)
name|sc
operator|->
name|scc_pdma
index|[
literal|0
index|]
operator|.
name|p_addr
expr_stmt|;
comment|/* 	 * Chip once-only initialization 	 * 	 * NOTE: The wiring we assume is the one on the 3min: 	 * 	 *	out	A-TxD	-->	TxD	keybd or mouse 	 *	in	A-RxD	-->	RxD	keybd or mouse 	 *	out	A-DTR~	-->	DTR	comm 	 *	out	A-RTS~	-->	RTS	comm 	 *	in	A-CTS~	-->	SI	comm 	 *	in	A-DCD~	-->	RI	comm 	 *	in	A-SYNCH~-->	DSR	comm 	 *	out	B-TxD	-->	TxD	comm 	 *	in	B-RxD	-->	RxD	comm 	 *	in	B-RxC	-->	TRxCB	comm 	 *	in	B-TxC	-->	RTxCB	comm 	 *	out	B-RTS~	-->	SS	comm 	 *	in	B-CTS~	-->	CTS	comm 	 *	in	B-DCD~	-->	CD	comm 	 */
name|SCC_INIT_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_A
argument_list|)
expr_stmt|;
name|SCC_INIT_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_B
argument_list|)
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_A
argument_list|,
name|SCC_WR9
argument_list|,
name|SCC_WR9_HW_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
comment|/*enough ? */
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_A
argument_list|,
name|SCC_WR9
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* program the interrupt vector */
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_A
argument_list|,
name|SCC_WR2
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_B
argument_list|,
name|SCC_WR2
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_A
argument_list|,
name|SCC_WR9
argument_list|,
name|SCC_WR9_VIS
argument_list|)
expr_stmt|;
comment|/* timing base defaults */
name|sc
operator|->
name|scc_wreg
index|[
name|SCC_CHANNEL_A
index|]
operator|.
name|wr4
operator|=
name|SCC_WR4_CLK_x16
expr_stmt|;
name|sc
operator|->
name|scc_wreg
index|[
name|SCC_CHANNEL_B
index|]
operator|.
name|wr4
operator|=
name|SCC_WR4_CLK_x16
expr_stmt|;
comment|/* enable DTR, RTS and SS */
name|sc
operator|->
name|scc_wreg
index|[
name|SCC_CHANNEL_B
index|]
operator|.
name|wr5
operator|=
name|SCC_WR5_RTS
expr_stmt|;
name|sc
operator|->
name|scc_wreg
index|[
name|SCC_CHANNEL_A
index|]
operator|.
name|wr5
operator|=
name|SCC_WR5_RTS
operator||
name|SCC_WR5_DTR
expr_stmt|;
comment|/* baud rates */
name|val
operator|=
name|SCC_WR14_BAUDR_ENABLE
operator||
name|SCC_WR14_BAUDR_SRC
expr_stmt|;
name|sc
operator|->
name|scc_wreg
index|[
name|SCC_CHANNEL_B
index|]
operator|.
name|wr14
operator|=
name|val
expr_stmt|;
name|sc
operator|->
name|scc_wreg
index|[
name|SCC_CHANNEL_A
index|]
operator|.
name|wr14
operator|=
name|val
expr_stmt|;
comment|/* interrupt conditions */
name|val
operator|=
name|SCC_WR1_RXI_ALL_CHAR
operator||
name|SCC_WR1_PARITY_IE
operator||
name|SCC_WR1_EXT_IE
expr_stmt|;
name|sc
operator|->
name|scc_wreg
index|[
name|SCC_CHANNEL_A
index|]
operator|.
name|wr1
operator|=
name|val
expr_stmt|;
name|sc
operator|->
name|scc_wreg
index|[
name|SCC_CHANNEL_B
index|]
operator|.
name|wr1
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_macro
name|sccopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|scc_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|,
name|line
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|unit
operator|=
name|SCCUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NSCC
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|line
operator|=
name|SCCLINE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|scc_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|scc_pdma
index|[
name|line
index|]
operator|.
name|p_addr
operator|==
operator|(
name|void
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|=
operator|&
name|scc_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|scc_pdma
index|[
name|line
index|]
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|sccstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|sccparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PORTSELECTOR
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|ISPEED
expr_stmt|;
ifdef|#
directive|ifdef
name|PORTSELECTOR
name|tp
operator|->
name|t_cflag
operator||=
name|HUPCL
expr_stmt|;
else|#
directive|else
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|sccparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|)
operator|&&
name|curproc
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
operator|(
name|void
operator|)
name|sccmctl
argument_list|(
name|dev
argument_list|,
name|DML_DTR
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|ttysleep
argument_list|(
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
name|ttopen
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|sccclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|scc_softc
modifier|*
name|sc
init|=
operator|&
name|scc_softc
index|[
name|SCCUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|bit
decl_stmt|,
name|line
decl_stmt|;
name|tp
operator|=
operator|&
name|scc_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|line
operator|=
name|SCCLINE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr5
operator|&
name|SCC_WR5_SEND_BREAK
condition|)
block|{
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr5
operator|&=
operator|~
name|SCC_WR5_SEND_BREAK
expr_stmt|;
name|ttyoutput
argument_list|(
literal|0
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_WOPEN
operator|)
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
operator|(
name|void
operator|)
name|sccmctl
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
return|return
operator|(
name|ttyclose
argument_list|(
name|tp
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|sccread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|scc_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|sccwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|scc_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|sccioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|scc_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|line
decl_stmt|;
name|tp
operator|=
operator|&
name|scc_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|line
operator|=
name|SCCLINE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|scc_softc
index|[
name|SCCUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr5
operator||=
name|SCC_WR5_SEND_BREAK
expr_stmt|;
name|ttyoutput
argument_list|(
literal|0
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr5
operator|&=
operator|~
name|SCC_WR5_SEND_BREAK
expr_stmt|;
name|ttyoutput
argument_list|(
literal|0
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCSDTR
case|:
operator|(
name|void
operator|)
name|sccmctl
argument_list|(
name|dev
argument_list|,
name|DML_DTR
operator||
name|DML_RTS
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
operator|(
name|void
operator|)
name|sccmctl
argument_list|(
name|dev
argument_list|,
name|DML_DTR
operator||
name|DML_RTS
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
operator|(
name|void
operator|)
name|sccmctl
argument_list|(
name|dev
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
operator|(
name|void
operator|)
name|sccmctl
argument_list|(
name|dev
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
operator|(
name|void
operator|)
name|sccmctl
argument_list|(
name|dev
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sccmctl
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|DMGET
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|sccparam
argument_list|(
name|tp
argument_list|,
name|t
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|scc_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|scc_regmap_t
modifier|*
name|regs
decl_stmt|;
specifier|register
name|int
name|line
decl_stmt|;
specifier|register
name|u_char
name|value
decl_stmt|,
name|wvalue
decl_stmt|;
specifier|register
name|int
name|cflag
init|=
name|t
operator|->
name|c_cflag
decl_stmt|;
name|int
name|ospeed
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|&&
name|t
operator|->
name|c_ispeed
operator|!=
name|t
operator|->
name|c_ospeed
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
operator|&
name|scc_softc
index|[
name|SCCUNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
index|]
expr_stmt|;
name|line
operator|=
name|SCCLINE
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|regs
operator|=
operator|(
name|scc_regmap_t
operator|*
operator|)
name|sc
operator|->
name|scc_pdma
index|[
name|line
index|]
operator|.
name|p_addr
expr_stmt|;
name|ospeed
operator|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
name|sccspeedtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|ospeed
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* and copy to tty */
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|cflag
expr_stmt|;
comment|/* 	 * Handle console specially. 	 */
if|if
condition|(
name|cn_tab
operator|.
name|cn_screen
condition|)
block|{
if|if
condition|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|==
name|SCCKBD_PORT
condition|)
block|{
name|cflag
operator|=
name|CS8
expr_stmt|;
name|ospeed
operator|=
name|ttspeedtab
argument_list|(
literal|4800
argument_list|,
name|sccspeedtab
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|==
name|SCCMOUSE_PORT
condition|)
block|{
name|cflag
operator|=
name|CS8
operator||
name|PARENB
operator||
name|PARODD
expr_stmt|;
name|ospeed
operator|=
name|ttspeedtab
argument_list|(
literal|4800
argument_list|,
name|sccspeedtab
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_dev
operator|==
name|cn_tab
operator|.
name|cn_dev
condition|)
block|{
name|cflag
operator|=
name|CS8
expr_stmt|;
name|ospeed
operator|=
name|ttspeedtab
argument_list|(
literal|9600
argument_list|,
name|sccspeedtab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ospeed
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sccmctl
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|,
literal|0
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
comment|/* hang up line */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* reset line */
if|if
condition|(
name|line
operator|==
name|SCC_CHANNEL_A
condition|)
name|value
operator|=
name|SCC_WR9_RESET_CHA_A
expr_stmt|;
else|else
name|value
operator|=
name|SCC_WR9_RESET_CHA_B
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR9
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
comment|/* stop bits, normally 1 */
name|value
operator|=
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr4
operator|&
literal|0xf0
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
name|value
operator||=
name|SCC_WR4_2_STOP
expr_stmt|;
else|else
name|value
operator||=
name|SCC_WR4_1_STOP
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|PARODD
operator|)
operator|==
literal|0
condition|)
name|value
operator||=
name|SCC_WR4_EVEN_PARITY
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
name|value
operator||=
name|SCC_WR4_PARITY_ENABLE
expr_stmt|;
comment|/* set it now, remember it must be first after reset */
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr4
operator|=
name|value
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR4
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* vector again */
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR2
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
comment|/* clear break, keep rts dtr */
name|wvalue
operator|=
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr5
operator|&
operator|(
name|SCC_WR5_DTR
operator||
name|SCC_WR5_RTS
operator|)
expr_stmt|;
switch|switch
condition|(
name|cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|value
operator|=
name|SCC_WR3_RX_5_BITS
expr_stmt|;
name|wvalue
operator||=
name|SCC_WR5_TX_5_BITS
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|value
operator|=
name|SCC_WR3_RX_6_BITS
expr_stmt|;
name|wvalue
operator||=
name|SCC_WR5_TX_6_BITS
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|value
operator|=
name|SCC_WR3_RX_7_BITS
expr_stmt|;
name|wvalue
operator||=
name|SCC_WR5_TX_7_BITS
expr_stmt|;
break|break;
case|case
name|CS8
case|:
default|default:
name|value
operator|=
name|SCC_WR3_RX_8_BITS
expr_stmt|;
name|wvalue
operator||=
name|SCC_WR5_TX_8_BITS
expr_stmt|;
block|}
empty_stmt|;
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr3
operator|=
name|value
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR3
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr5
operator|=
name|wvalue
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR5
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR9
argument_list|,
name|SCC_WR9_VIS
argument_list|)
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|SCC_WR11_RCLK_BAUDR
operator||
name|SCC_WR11_XTLK_BAUDR
operator||
name|SCC_WR11_TRc_OUT
operator||
name|SCC_WR11_TRcOUT_BAUDR
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR11
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|SCC_SET_TIMING_BASE
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|ospeed
argument_list|)
expr_stmt|;
name|value
operator|=
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr14
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR14
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|SCC_WR15_BREAK_IE
operator||
name|SCC_WR15_CTS_IE
operator||
name|SCC_WR15_DCD_IE
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR15
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* and now the enables */
name|value
operator|=
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr3
operator||
name|SCC_WR3_RX_ENABLE
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR3
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr5
operator||
name|SCC_WR5_TX_ENABLE
expr_stmt|;
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr5
operator|=
name|value
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR5
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* master inter enable */
name|value
operator|=
name|SCC_WR9_MASTER_IE
operator||
name|SCC_WR9_VIS
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR9
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR1
argument_list|,
name|sc
operator|->
name|scc_wreg
index|[
name|line
index|]
operator|.
name|wr1
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Check for interrupts from all devices.  */
end_comment

begin_function
name|void
name|sccintr
parameter_list|(
name|unit
parameter_list|)
specifier|register
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|scc_regmap_t
modifier|*
name|regs
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|pdma
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|scc_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|cc
decl_stmt|,
name|chan
decl_stmt|,
name|rr1
decl_stmt|,
name|rr2
decl_stmt|,
name|rr3
decl_stmt|;
name|int
name|overrun
init|=
literal|0
decl_stmt|;
name|sc
operator|=
operator|&
name|scc_softc
index|[
name|unit
index|]
expr_stmt|;
name|regs
operator|=
operator|(
name|scc_regmap_t
operator|*
operator|)
name|sc
operator|->
name|scc_pdma
index|[
literal|0
index|]
operator|.
name|p_addr
expr_stmt|;
name|unit
operator|<<=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|SCC_READ_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_B
argument_list|,
name|SCC_RR2
argument_list|,
name|rr2
argument_list|)
expr_stmt|;
name|rr2
operator|=
name|SCC_RR2_STATUS
argument_list|(
name|rr2
argument_list|)
expr_stmt|;
comment|/* are we done yet ? */
if|if
condition|(
name|rr2
operator|==
literal|6
condition|)
block|{
comment|/* strange, distinguished value */
name|SCC_READ_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_A
argument_list|,
name|SCC_RR3
argument_list|,
name|rr3
argument_list|)
expr_stmt|;
if|if
condition|(
name|rr3
operator|==
literal|0
condition|)
return|return;
block|}
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_A
argument_list|,
name|SCC_RR0
argument_list|,
name|SCC_RESET_HIGHEST_IUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rr2
operator|==
name|SCC_RR2_A_XMIT_DONE
operator|)
operator|||
operator|(
name|rr2
operator|==
name|SCC_RR2_B_XMIT_DONE
operator|)
condition|)
block|{
name|chan
operator|=
operator|(
name|rr2
operator|==
name|SCC_RR2_A_XMIT_DONE
operator|)
condition|?
name|SCC_CHANNEL_A
else|:
name|SCC_CHANNEL_B
expr_stmt|;
name|tp
operator|=
operator|&
name|scc_tty
index|[
name|unit
operator||
name|chan
index|]
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|pdma
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|p_mem
operator|<
name|dp
operator|->
name|p_end
condition|)
block|{
name|SCC_WRITE_DATA
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
operator|*
name|dp
operator|->
name|p_mem
operator|++
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_FLUSH
expr_stmt|;
else|else
block|{
name|ndflush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|dp
operator|->
name|p_mem
operator|-
name|tp
operator|->
name|t_outq
operator|.
name|c_cf
argument_list|)
expr_stmt|;
name|dp
operator|->
name|p_end
operator|=
name|dp
operator|->
name|p_mem
operator|=
name|tp
operator|->
name|t_outq
operator|.
name|c_cf
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_line
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
else|else
name|sccstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
operator|)
condition|)
block|{
name|SCC_READ_REG
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
name|SCC_RR15
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|&=
operator|~
name|SCC_WR15_TX_UNDERRUN_IE
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
name|SCC_WR15
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|=
name|sc
operator|->
name|scc_wreg
index|[
name|chan
index|]
operator|.
name|wr1
operator|&
operator|~
name|SCC_WR1_TX_IE
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
name|SCC_WR1
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|scc_wreg
index|[
name|chan
index|]
operator|.
name|wr1
operator|=
name|cc
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|rr2
operator|==
name|SCC_RR2_A_RECV_DONE
operator|||
name|rr2
operator|==
name|SCC_RR2_B_RECV_DONE
operator|||
name|rr2
operator|==
name|SCC_RR2_A_RECV_SPECIAL
operator|||
name|rr2
operator|==
name|SCC_RR2_B_RECV_SPECIAL
condition|)
block|{
if|if
condition|(
name|rr2
operator|==
name|SCC_RR2_A_RECV_DONE
operator|||
name|rr2
operator|==
name|SCC_RR2_A_RECV_SPECIAL
condition|)
name|chan
operator|=
name|SCC_CHANNEL_A
expr_stmt|;
else|else
name|chan
operator|=
name|SCC_CHANNEL_B
expr_stmt|;
name|tp
operator|=
operator|&
name|scc_tty
index|[
name|unit
operator||
name|chan
index|]
expr_stmt|;
name|SCC_READ_DATA
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rr2
operator|==
name|SCC_RR2_A_RECV_SPECIAL
operator|||
name|rr2
operator|==
name|SCC_RR2_B_RECV_SPECIAL
condition|)
block|{
name|SCC_READ_REG
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
name|SCC_RR1
argument_list|,
name|rr1
argument_list|)
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
name|SCC_RR0
argument_list|,
name|SCC_RESET_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rr1
operator|&
name|SCC_RR1_RX_OVERRUN
operator|)
operator|&&
name|overrun
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"scc%d,%d: silo overflow\n"
argument_list|,
name|unit
operator|>>
literal|1
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|overrun
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 		 * Keyboard needs special treatment. 		 */
if|if
condition|(
name|tp
operator|==
operator|&
name|scc_tty
index|[
name|SCCKBD_PORT
index|]
operator|&&
name|cn_tab
operator|.
name|cn_screen
condition|)
block|{
ifdef|#
directive|ifdef
name|KADB
if|if
condition|(
name|cc
operator|==
name|LK_DO
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
name|kdbpanic
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|debugChar
operator|=
name|cc
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sccDivertXInput
condition|)
block|{
call|(
modifier|*
name|sccDivertXInput
call|)
argument_list|(
name|cc
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|cc
operator|=
name|kbdMapChar
argument_list|(
name|cc
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
comment|/* 		 * Now for mousey 		 */
block|}
elseif|else
if|if
condition|(
name|tp
operator|==
operator|&
name|scc_tty
index|[
name|SCCMOUSE_PORT
index|]
operator|&&
name|sccMouseButtons
condition|)
block|{
specifier|register
name|MouseReport
modifier|*
name|mrp
decl_stmt|;
specifier|static
name|MouseReport
name|currentRep
decl_stmt|;
name|mrp
operator|=
operator|&
name|currentRep
expr_stmt|;
name|mrp
operator|->
name|byteCount
operator|++
expr_stmt|;
if|if
condition|(
name|cc
operator|&
name|MOUSE_START_FRAME
condition|)
block|{
comment|/* 				 * The first mouse report byte (button state). 				 */
name|mrp
operator|->
name|state
operator|=
name|cc
expr_stmt|;
if|if
condition|(
name|mrp
operator|->
name|byteCount
operator|>
literal|1
condition|)
name|mrp
operator|->
name|byteCount
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mrp
operator|->
name|byteCount
operator|==
literal|2
condition|)
block|{
comment|/* 				 * The second mouse report byte (delta x). 				 */
name|mrp
operator|->
name|dx
operator|=
name|cc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mrp
operator|->
name|byteCount
operator|==
literal|3
condition|)
block|{
comment|/* 				 * The final mouse report byte (delta y). 				 */
name|mrp
operator|->
name|dy
operator|=
name|cc
expr_stmt|;
name|mrp
operator|->
name|byteCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mrp
operator|->
name|dx
operator|!=
literal|0
operator|||
name|mrp
operator|->
name|dy
operator|!=
literal|0
condition|)
block|{
comment|/* 					 * If the mouse moved, 					 * post a motion event. 					 */
call|(
modifier|*
name|sccMouseEvent
call|)
argument_list|(
name|mrp
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|sccMouseButtons
call|)
argument_list|(
name|mrp
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PORTSELECTOR
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_WOPEN
operator|)
condition|)
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|rr2
operator|==
name|SCC_RR2_A_RECV_SPECIAL
operator|||
name|rr2
operator|==
name|SCC_RR2_B_RECV_SPECIAL
condition|)
block|{
if|if
condition|(
name|rr1
operator|&
name|SCC_RR1_PARITY_ERR
condition|)
name|cc
operator||=
name|TTY_PE
expr_stmt|;
if|if
condition|(
name|rr1
operator|&
name|SCC_RR1_FRAME_ERR
condition|)
name|cc
operator||=
name|TTY_FE
expr_stmt|;
block|}
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|cc
operator|,
name|tp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rr2
operator|==
name|SCC_RR2_A_EXT_STATUS
operator|)
operator|||
operator|(
name|rr2
operator|==
name|SCC_RR2_B_EXT_STATUS
operator|)
condition|)
block|{
name|chan
operator|=
operator|(
name|rr2
operator|==
name|SCC_RR2_A_EXT_STATUS
operator|)
condition|?
name|SCC_CHANNEL_A
else|:
name|SCC_CHANNEL_B
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
name|SCC_RR0
argument_list|,
name|SCC_RESET_EXT_IP
argument_list|)
expr_stmt|;
name|scc_modem_intr
argument_list|(
name|unit
operator||
name|chan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sccstart
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|pdma
modifier|*
name|dp
decl_stmt|;
specifier|register
name|scc_regmap_t
modifier|*
name|regs
decl_stmt|;
specifier|register
name|struct
name|scc_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|cc
decl_stmt|,
name|chan
decl_stmt|;
name|u_char
name|temp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|sendone
decl_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|pdma
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
name|regs
operator|=
operator|(
name|scc_regmap_t
operator|*
operator|)
name|dp
operator|->
name|p_addr
expr_stmt|;
name|sc
operator|=
operator|&
name|scc_softc
index|[
name|SCCUNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
index|]
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* handle console specially */
if|if
condition|(
name|tp
operator|==
operator|&
name|scc_tty
index|[
name|SCCKBD_PORT
index|]
operator|&&
name|cn_tab
operator|.
name|cn_screen
condition|)
block|{
while|while
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
literal|0
condition|)
block|{
name|cc
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|&
literal|0x7f
expr_stmt|;
name|cnputc
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * After we flush the output queue we may need to wake 		 * up the process that made the output. 		 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator|)
condition|)
name|cc
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|cc
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0200
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
name|cc
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ttrstrt
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tp
argument_list|,
operator|(
name|cc
operator|&
literal|0x7f
operator|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_TIMEOUT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|dp
operator|->
name|p_end
operator|=
name|dp
operator|->
name|p_mem
operator|=
name|tp
operator|->
name|t_outq
operator|.
name|c_cf
expr_stmt|;
name|dp
operator|->
name|p_end
operator|+=
name|cc
expr_stmt|;
comment|/* 	 * Enable transmission and send the first char, as required. 	 */
name|chan
operator|=
name|SCCLINE
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|SCC_READ_REG
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
name|SCC_RR0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|sendone
operator|=
operator|(
name|temp
operator|&
name|SCC_RR0_TX_EMPTY
operator|)
expr_stmt|;
name|SCC_READ_REG
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
name|SCC_RR15
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator||=
name|SCC_WR15_TX_UNDERRUN_IE
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
name|SCC_WR15
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|sc
operator|->
name|scc_wreg
index|[
name|chan
index|]
operator|.
name|wr1
operator||
name|SCC_WR1_TX_IE
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
name|SCC_WR1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|scc_wreg
index|[
name|chan
index|]
operator|.
name|wr1
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|sendone
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"sccstart: No chars"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCC_WRITE_DATA
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
operator|*
name|dp
operator|->
name|p_mem
operator|++
argument_list|)
expr_stmt|;
block|}
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop output on a line.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|sccstop
argument_list|(
name|tp
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|pdma
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|pdma
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|dp
operator|->
name|p_end
operator|=
name|dp
operator|->
name|p_mem
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sccmctl
argument_list|(
argument|dev
argument_list|,
argument|bits
argument_list|,
argument|how
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bits
decl_stmt|,
name|how
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|scc_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|scc_regmap_t
modifier|*
name|regs
decl_stmt|;
specifier|register
name|int
name|line
decl_stmt|,
name|mbits
decl_stmt|;
specifier|register
name|u_char
name|value
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|=
operator|&
name|scc_softc
index|[
name|SCCUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|line
operator|=
name|SCCLINE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|regs
operator|=
operator|(
name|scc_regmap_t
operator|*
operator|)
name|sc
operator|->
name|scc_pdma
index|[
name|line
index|]
operator|.
name|p_addr
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* 	 * only channel B has modem control, however the DTR and RTS 	 * pins on the comm port are wired to the DTR and RTS A channel 	 * signals. 	 */
name|mbits
operator|=
name|DML_DTR
operator||
name|DML_DSR
operator||
name|DML_CAR
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|SCC_CHANNEL_B
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|scc_wreg
index|[
name|SCC_CHANNEL_A
index|]
operator|.
name|wr5
operator|&
name|SCC_WR5_DTR
condition|)
name|mbits
operator|=
name|DML_DTR
operator||
name|DML_DSR
expr_stmt|;
else|else
name|mbits
operator|=
literal|0
expr_stmt|;
name|SCC_READ_REG_ZERO
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_B
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&
name|SCC_RR0_DCD
condition|)
name|mbits
operator||=
name|DML_CAR
expr_stmt|;
block|}
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|DMSET
case|:
name|mbits
operator|=
name|bits
expr_stmt|;
break|break;
case|case
name|DMBIS
case|:
name|mbits
operator||=
name|bits
expr_stmt|;
break|break;
case|case
name|DMBIC
case|:
name|mbits
operator|&=
operator|~
name|bits
expr_stmt|;
break|break;
case|case
name|DMGET
case|:
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|mbits
operator|)
return|;
block|}
if|if
condition|(
name|line
operator|==
name|SCC_CHANNEL_B
condition|)
block|{
if|if
condition|(
name|mbits
operator|&
name|DML_DTR
condition|)
name|sc
operator|->
name|scc_wreg
index|[
name|SCC_CHANNEL_A
index|]
operator|.
name|wr5
operator||=
name|SCC_WR5_DTR
expr_stmt|;
else|else
name|sc
operator|->
name|scc_wreg
index|[
name|SCC_CHANNEL_A
index|]
operator|.
name|wr5
operator|&=
operator|~
name|SCC_WR5_DTR
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_A
argument_list|,
name|SCC_WR5
argument_list|,
name|sc
operator|->
name|scc_wreg
index|[
name|SCC_CHANNEL_A
index|]
operator|.
name|wr5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mbits
operator|&
name|DML_DTR
operator|)
operator|&&
operator|(
name|sc
operator|->
name|scc_softCAR
operator|&
operator|(
literal|1
operator|<<
name|line
operator|)
operator|)
condition|)
name|scc_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|mbits
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Check for carrier transition.  */
end_comment

begin_function
specifier|static
name|void
name|scc_modem_intr
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
specifier|register
name|scc_regmap_t
modifier|*
name|regs
decl_stmt|;
specifier|register
name|struct
name|scc_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|car
decl_stmt|,
name|chan
decl_stmt|;
specifier|register
name|u_char
name|value
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|=
operator|&
name|scc_softc
index|[
name|SCCUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|scc_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|regs
operator|=
operator|(
name|scc_regmap_t
operator|*
operator|)
operator|(
operator|(
expr|struct
name|pdma
operator|*
operator|)
name|tp
operator|->
name|t_addr
operator|)
operator|->
name|p_addr
expr_stmt|;
name|chan
operator|=
name|SCCLINE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|SCC_CHANNEL_A
condition|)
return|return;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|scc_softCAR
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
condition|)
name|car
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|SCC_READ_REG_ZERO
argument_list|(
name|regs
argument_list|,
name|chan
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|car
operator|=
name|value
operator|&
name|SCC_RR0_DCD
expr_stmt|;
block|}
if|if
condition|(
name|car
condition|)
block|{
comment|/* carrier present */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a char off the appropriate line via. a busy wait loop.  */
end_comment

begin_function
name|int
name|sccGetc
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
specifier|register
name|scc_regmap_t
modifier|*
name|regs
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|line
decl_stmt|;
specifier|register
name|u_char
name|value
decl_stmt|;
name|int
name|s
decl_stmt|;
name|line
operator|=
name|SCCLINE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|regs
operator|=
operator|(
name|scc_regmap_t
operator|*
operator|)
name|scc_softc
index|[
name|SCCUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|scc_pdma
index|[
name|line
index|]
operator|.
name|p_addr
expr_stmt|;
if|if
condition|(
operator|!
name|regs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|SCC_READ_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_RR0
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&
name|SCC_RR0_RX_AVAIL
condition|)
block|{
name|SCC_READ_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_RR1
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|SCC_READ_DATA
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&
operator|(
name|SCC_RR1_PARITY_ERR
operator||
name|SCC_RR1_RX_OVERRUN
operator||
name|SCC_RR1_FRAME_ERR
operator|)
condition|)
block|{
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_WR0
argument_list|,
name|SCC_RESET_ERROR
argument_list|)
expr_stmt|;
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_A
argument_list|,
name|SCC_WR0
argument_list|,
name|SCC_RESET_HIGHEST_IUS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCC_WRITE_REG
argument_list|(
name|regs
argument_list|,
name|SCC_CHANNEL_A
argument_list|,
name|SCC_WR0
argument_list|,
name|SCC_RESET_HIGHEST_IUS
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|&
literal|0xff
operator|)
return|;
block|}
block|}
else|else
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send a char on a port, via a busy wait loop.  */
end_comment

begin_function
name|void
name|sccPutc
parameter_list|(
name|dev
parameter_list|,
name|c
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|scc_regmap_t
modifier|*
name|regs
decl_stmt|;
specifier|register
name|int
name|line
decl_stmt|;
specifier|register
name|u_char
name|value
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|line
operator|=
name|SCCLINE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|regs
operator|=
operator|(
name|scc_regmap_t
operator|*
operator|)
name|scc_softc
index|[
name|SCCUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|scc_pdma
index|[
name|line
index|]
operator|.
name|p_addr
expr_stmt|;
comment|/* 	 * Wait for transmitter to be not busy. 	 */
do|do
block|{
name|SCC_READ_REG
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|SCC_RR0
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&
name|SCC_RR0_TX_EMPTY
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* 	 * Send the char. 	 */
name|SCC_WRITE_DATA
argument_list|(
name|regs
argument_list|,
name|line
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSCC */
end_comment

end_unit

