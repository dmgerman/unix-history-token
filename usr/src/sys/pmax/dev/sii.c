begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ralph Campbell and Rick Macklem.  *  * %sccs.include.redist.c%  *  *	@(#)sii.c	8.3 (Berkeley) %G%  *  * from: $Header: /sprite/src/kernel/dev/ds3100.md/RCS/devSII.c,  *	v 9.2 89/09/14 13:37:41 jhh Exp $ SPRITE (DECWRL)";  */
end_comment

begin_include
include|#
directive|include
file|"sii.h"
end_include

begin_if
if|#
directive|if
name|NSII
operator|>
literal|0
end_if

begin_comment
comment|/*  * SCSI interface driver  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<machine/machConst.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/scsi.h>
end_include

begin_include
include|#
directive|include
file|<pmax/dev/siireg.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/kn01.h>
end_include

begin_function_decl
name|int
name|siiprobe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|siistart
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|driver
name|siidriver
init|=
block|{
literal|"sii"
block|,
name|siiprobe
block|,
name|siistart
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|scsi_state
block|{
name|int
name|statusByte
decl_stmt|;
comment|/* status byte returned during STATUS_PHASE */
name|int
name|dmaDataPhase
decl_stmt|;
comment|/* which data phase to expect */
name|int
name|dmaCurPhase
decl_stmt|;
comment|/* SCSI phase if DMA is in progress */
name|int
name|dmaPrevPhase
decl_stmt|;
comment|/* SCSI phase of DMA suspended by disconnect */
name|u_short
modifier|*
name|dmaAddr
index|[
literal|2
index|]
decl_stmt|;
comment|/* DMA buffer memory address */
name|int
name|dmaBufIndex
decl_stmt|;
comment|/* which of the above is currently in use */
name|int
name|dmalen
decl_stmt|;
comment|/* amount to transfer in this chunk */
name|int
name|cmdlen
decl_stmt|;
comment|/* total remaining amount of cmd to transfer */
name|u_char
modifier|*
name|cmd
decl_stmt|;
comment|/* current pointer within scsicmd->cmd */
name|int
name|buflen
decl_stmt|;
comment|/* total remaining amount of data to transfer */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* current pointer within scsicmd->buf */
name|u_short
name|flags
decl_stmt|;
comment|/* see below */
name|u_short
name|prevComm
decl_stmt|;
comment|/* command reg before disconnect */
name|u_short
name|dmaCtrl
decl_stmt|;
comment|/* DMA control register if disconnect */
name|u_short
name|dmaAddrL
decl_stmt|;
comment|/* DMA address register if disconnect */
name|u_short
name|dmaAddrH
decl_stmt|;
comment|/* DMA address register if disconnect */
name|u_short
name|dmaCnt
decl_stmt|;
comment|/* DMA count if disconnect */
name|u_short
name|dmaByte
decl_stmt|;
comment|/* DMA byte if disconnect on odd boundary */
name|u_short
name|dmaReqAck
decl_stmt|;
comment|/* DMA synchronous xfer offset or 0 if async */
block|}
name|State
typedef|;
end_typedef

begin_comment
comment|/* state flags */
end_comment

begin_define
define|#
directive|define
name|FIRST_DMA
value|0x01
end_define

begin_comment
comment|/* true if no data DMA started yet */
end_comment

begin_define
define|#
directive|define
name|PARITY_ERR
value|0x02
end_define

begin_comment
comment|/* true if parity error seen */
end_comment

begin_define
define|#
directive|define
name|SII_NCMD
value|7
end_define

begin_struct
struct|struct
name|siisoftc
block|{
name|SIIRegs
modifier|*
name|sc_regs
decl_stmt|;
comment|/* HW address of SII controller chip */
name|int
name|sc_flags
decl_stmt|;
name|int
name|sc_target
decl_stmt|;
comment|/* target SCSI ID if connected */
name|ScsiCmd
modifier|*
name|sc_cmd
index|[
name|SII_NCMD
index|]
decl_stmt|;
comment|/* active command indexed by ID */
name|State
name|sc_st
index|[
name|SII_NCMD
index|]
decl_stmt|;
comment|/* state info for each active command */
block|}
name|sii_softc
index|[
name|NSII
index|]
struct|;
end_struct

begin_comment
comment|/*   * MACROS for timing out spin loops.  *  * Wait until expression is true.  *  * Control register bits can change at any time so when the CPU  * reads a register, the bits might change and  * invalidate the setup and hold times for the CPU.  * This macro reads the register twice to be sure the value is stable.  *  *	args:	var 		- variable to save control register contents  *		reg		- control register to read  *		expr 		- expression to spin on  *		spincount 	- maximum number of times through the loop  *		cntr		- variable for number of tries  */
end_comment

begin_define
define|#
directive|define
name|SII_WAIT_UNTIL
parameter_list|(
name|var
parameter_list|,
name|reg
parameter_list|,
name|expr
parameter_list|,
name|spincount
parameter_list|,
name|cntr
parameter_list|)
value|{	\ 		register u_int tmp = reg;			\ 		for (cntr = 0; cntr< spincount; cntr++) {	\ 			while (tmp != (var = reg))		\ 				tmp = var;			\ 			if (expr)				\ 				break;				\ 			if (cntr>= 100)			\ 				DELAY(100);			\ 		}						\ 	}
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|sii_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sii_debug_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sii_debug_bn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sii_debug_sz
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NLOG
value|16
end_define

begin_struct
struct|struct
name|sii_log
block|{
name|u_short
name|cstat
decl_stmt|;
name|u_short
name|dstat
decl_stmt|;
name|u_short
name|comm
decl_stmt|;
name|u_short
name|msg
decl_stmt|;
name|int
name|rlen
decl_stmt|;
name|int
name|dlen
decl_stmt|;
name|int
name|target
decl_stmt|;
block|}
name|sii_log
index|[
name|NLOG
index|]
struct|,
modifier|*
name|sii_logp
init|=
name|sii_log
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|u_char
name|sii_buf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for extended messages */
end_comment

begin_define
define|#
directive|define
name|NORESET
value|0
end_define

begin_define
define|#
directive|define
name|RESET
value|1
end_define

begin_define
define|#
directive|define
name|NOWAIT
value|0
end_define

begin_define
define|#
directive|define
name|WAIT
value|1
end_define

begin_comment
comment|/* define a safe address in the SCSI buffer for doing status& message DMA */
end_comment

begin_define
define|#
directive|define
name|SII_BUF_ADDR
value|(MACH_PHYS_TO_UNCACHED(KN01_SYS_SII_B_START) \ 		+ SII_MAX_DMA_XFER_LENGTH * 14)
end_define

begin_function_decl
specifier|static
name|void
name|sii_Reset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sii_StartCmd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sii_CmdDone
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sii_DoIntr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sii_StateChg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sii_DoSync
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sii_StartDMA
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sii_GetByte
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Test to see if device is present.  * Return true if found and initialized ok.  */
end_comment

begin_expr_stmt
name|siiprobe
argument_list|(
name|cp
argument_list|)
specifier|register
expr|struct
name|pmax_ctlr
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|siisoftc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|pmax_unit
operator|>=
name|NSII
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|=
operator|&
name|sii_softc
index|[
name|cp
operator|->
name|pmax_unit
index|]
expr_stmt|;
name|sc
operator|->
name|sc_regs
operator|=
operator|(
name|SIIRegs
operator|*
operator|)
name|cp
operator|->
name|pmax_addr
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|cp
operator|->
name|pmax_flags
expr_stmt|;
name|sc
operator|->
name|sc_target
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no command active */
comment|/* 	 * Give each target its own DMA buffer region. 	 * Make it big enough for 2 max transfers so we can ping pong buffers 	 * while we copy the data. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SII_NCMD
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_st
index|[
name|i
index|]
operator|.
name|dmaAddr
index|[
literal|0
index|]
operator|=
operator|(
name|u_short
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN01_SYS_SII_B_START
argument_list|)
operator|+
literal|2
operator|*
name|SII_MAX_DMA_XFER_LENGTH
operator|*
name|i
expr_stmt|;
name|sc
operator|->
name|sc_st
index|[
name|i
index|]
operator|.
name|dmaAddr
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sc_st
index|[
name|i
index|]
operator|.
name|dmaAddr
index|[
literal|0
index|]
operator|+
name|SII_MAX_DMA_XFER_LENGTH
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"sii%d at nexus0 csr 0x%x\n"
argument_list|,
name|cp
operator|->
name|pmax_unit
argument_list|,
name|cp
operator|->
name|pmax_addr
argument_list|)
expr_stmt|;
name|sii_Reset
argument_list|(
name|sc
operator|->
name|sc_regs
argument_list|,
name|RESET
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Start activity on a SCSI device.  * We maintain information on each device separately since devices can  * connect/disconnect during an operation.  */
end_comment

begin_function
name|void
name|siistart
parameter_list|(
name|scsicmd
parameter_list|)
specifier|register
name|ScsiCmd
modifier|*
name|scsicmd
decl_stmt|;
comment|/* command to start */
block|{
specifier|register
name|struct
name|scsi_device
modifier|*
name|sdp
init|=
name|scsicmd
operator|->
name|sd
decl_stmt|;
specifier|register
name|struct
name|siisoftc
modifier|*
name|sc
init|=
operator|&
name|sii_softc
index|[
name|sdp
operator|->
name|sd_ctlr
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * Check if another command is already in progress. 	 * We may have to change this if we allow SCSI devices with 	 * separate LUNs. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_cmd
index|[
name|sdp
operator|->
name|sd_drive
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: device %s busy at start\n"
argument_list|,
name|sdp
operator|->
name|sd_ctlr
argument_list|,
name|sdp
operator|->
name|sd_driver
operator|->
name|d_name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sdp
operator|->
name|sd_driver
operator|->
name|d_done
call|)
argument_list|(
name|scsicmd
operator|->
name|unit
argument_list|,
name|EBUSY
argument_list|,
name|scsicmd
operator|->
name|buflen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_cmd
index|[
name|sdp
operator|->
name|sd_drive
index|]
operator|=
name|scsicmd
expr_stmt|;
name|sii_StartCmd
argument_list|(
name|sc
argument_list|,
name|sdp
operator|->
name|sd_drive
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if any SII chips have pending interrupts  * and process as appropriate.  */
end_comment

begin_function
name|void
name|siiintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|siisoftc
modifier|*
name|sc
init|=
operator|&
name|sii_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_int
name|dstat
decl_stmt|;
comment|/* 	 * Find which controller caused the interrupt. 	 */
name|dstat
operator|=
name|sc
operator|->
name|sc_regs
operator|->
name|dstat
expr_stmt|;
if|if
condition|(
name|dstat
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
condition|)
name|sii_DoIntr
argument_list|(
name|sc
argument_list|,
name|dstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the SII chip and do a SCSI reset if 'reset' is true.  * NOTE: if !cold&& reset, should probably probe for devices  * since a SCSI bus reset will set UNIT_ATTENTION.  */
end_comment

begin_function
specifier|static
name|void
name|sii_Reset
parameter_list|(
name|regs
parameter_list|,
name|reset
parameter_list|)
specifier|register
name|SIIRegs
modifier|*
name|regs
decl_stmt|;
name|int
name|reset
decl_stmt|;
comment|/* TRUE => reset SCSI bus */
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"sii: RESET\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Reset the SII chip. 	 */
name|regs
operator|->
name|comm
operator|=
name|SII_CHRESET
expr_stmt|;
comment|/* 	 * Set arbitrated bus mode. 	 */
name|regs
operator|->
name|csr
operator|=
name|SII_HPM
expr_stmt|;
comment|/* 	 * SII is always ID 7. 	 */
name|regs
operator|->
name|id
operator|=
name|SII_ID_IO
operator||
literal|7
expr_stmt|;
comment|/* 	 * Enable SII to drive the SCSI bus. 	 */
name|regs
operator|->
name|dictrl
operator|=
name|SII_PRE
expr_stmt|;
name|regs
operator|->
name|dmctrl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reset
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 		 * Assert SCSI bus reset for at least 25 Usec to clear the  		 * world. SII_DO_RST is self clearing. 		 * Delay 250 ms before doing any commands. 		 */
name|regs
operator|->
name|comm
operator|=
name|SII_DO_RST
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|DELAY
argument_list|(
literal|250000
argument_list|)
expr_stmt|;
comment|/* rearbitrate synchronous offset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SII_NCMD
condition|;
name|i
operator|++
control|)
name|sii_softc
index|[
literal|0
index|]
operator|.
name|sc_st
index|[
name|i
index|]
operator|.
name|dmaReqAck
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Clear any pending interrupts from the reset. 	 */
name|regs
operator|->
name|cstat
operator|=
name|regs
operator|->
name|cstat
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|regs
operator|->
name|dstat
expr_stmt|;
comment|/* 	 * Set up SII for arbitrated bus mode, SCSI parity checking, 	 * Reselect Enable, and Interrupt Enable. 	 */
name|regs
operator|->
name|csr
operator|=
name|SII_HPM
operator||
name|SII_RSE
operator||
name|SII_PCE
operator||
name|SII_IE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a SCSI command by sending the cmd data  * to a SCSI controller via the SII.  * Call the device done proceedure if it can't be started.  * NOTE: we should be called with interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|sii_StartCmd
parameter_list|(
name|sc
parameter_list|,
name|target
parameter_list|)
specifier|register
name|struct
name|siisoftc
modifier|*
name|sc
decl_stmt|;
comment|/* which SII to use */
specifier|register
name|int
name|target
decl_stmt|;
comment|/* which command to start */
block|{
specifier|register
name|SIIRegs
modifier|*
name|regs
decl_stmt|;
specifier|register
name|ScsiCmd
modifier|*
name|scsicmd
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
decl_stmt|;
specifier|register
name|u_int
name|status
decl_stmt|;
name|int
name|error
decl_stmt|,
name|retval
decl_stmt|;
comment|/* if another command is currently in progress, just wait */
if|if
condition|(
name|sc
operator|->
name|sc_target
operator|>=
literal|0
condition|)
return|return;
comment|/* initialize state information for this command */
name|scsicmd
operator|=
name|sc
operator|->
name|sc_cmd
index|[
name|target
index|]
expr_stmt|;
name|state
operator|=
operator|&
name|sc
operator|->
name|sc_st
index|[
name|target
index|]
expr_stmt|;
name|state
operator|->
name|flags
operator|=
name|FIRST_DMA
expr_stmt|;
name|state
operator|->
name|prevComm
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|dmalen
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|dmaCurPhase
operator|=
operator|-
literal|1
expr_stmt|;
name|state
operator|->
name|dmaPrevPhase
operator|=
operator|-
literal|1
expr_stmt|;
name|state
operator|->
name|dmaBufIndex
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|cmd
operator|=
name|scsicmd
operator|->
name|cmd
expr_stmt|;
name|state
operator|->
name|cmdlen
operator|=
name|scsicmd
operator|->
name|cmdlen
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|->
name|buflen
operator|=
name|scsicmd
operator|->
name|buflen
operator|)
operator|==
literal|0
condition|)
block|{
name|state
operator|->
name|dmaDataPhase
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* illegal phase. shouldn't happen */
name|state
operator|->
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|dmaDataPhase
operator|=
operator|(
name|scsicmd
operator|->
name|flags
operator|&
name|SCSICMD_DATA_TO_DEVICE
operator|)
condition|?
name|SII_DATA_OUT_PHASE
else|:
name|SII_DATA_IN_PHASE
expr_stmt|;
name|state
operator|->
name|buf
operator|=
name|scsicmd
operator|->
name|buf
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"sii_StartCmd: %s target %d cmd 0x%x addr %x size %d dma %d\n"
argument_list|,
name|scsicmd
operator|->
name|sd
operator|->
name|sd_driver
operator|->
name|d_name
argument_list|,
name|target
argument_list|,
name|scsicmd
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|scsicmd
operator|->
name|buf
argument_list|,
name|scsicmd
operator|->
name|buflen
argument_list|,
name|state
operator|->
name|dmaDataPhase
argument_list|)
expr_stmt|;
block|}
name|sii_debug_cmd
operator|=
name|scsicmd
operator|->
name|cmd
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|scsicmd
operator|->
name|cmd
index|[
literal|0
index|]
operator|==
name|SCSI_READ_EXT
operator|||
name|scsicmd
operator|->
name|cmd
index|[
literal|0
index|]
operator|==
name|SCSI_WRITE_EXT
condition|)
block|{
name|sii_debug_bn
operator|=
operator|(
name|scsicmd
operator|->
name|cmd
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|scsicmd
operator|->
name|cmd
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|scsicmd
operator|->
name|cmd
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|scsicmd
operator|->
name|cmd
index|[
literal|5
index|]
expr_stmt|;
name|sii_debug_sz
operator|=
operator|(
name|scsicmd
operator|->
name|cmd
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
operator||
name|scsicmd
operator|->
name|cmd
index|[
literal|8
index|]
expr_stmt|;
block|}
else|else
block|{
name|sii_debug_bn
operator|=
literal|0
expr_stmt|;
name|sii_debug_sz
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* try to select the target */
name|regs
operator|=
name|sc
operator|->
name|sc_regs
expr_stmt|;
comment|/* 	 * Another device may have selected us; in which case, 	 * this command will be restarted later. 	 */
if|if
condition|(
operator|(
name|status
operator|=
name|regs
operator|->
name|dstat
operator|)
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
condition|)
block|{
name|sii_DoIntr
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_target
operator|=
name|target
expr_stmt|;
if|#
directive|if
literal|0
comment|/* seem to have problems with synchronous transfers */
block|if (scsicmd->flags& SCSICMD_USE_SYNC) { 		printf("sii_StartCmd: doing extended msg\n");
comment|/* XXX */
comment|/* 		 * Setup to send both the identify message and the synchronous 		 * data transfer request. 		 */
block|sii_buf[0] = SCSI_DIS_REC_IDENTIFY; 		sii_buf[1] = SCSI_EXTENDED_MSG; 		sii_buf[2] = 3;
comment|/* message length */
block|sii_buf[3] = SCSI_SYNCHRONOUS_XFER; 		sii_buf[4] = 0; 		sii_buf[5] = 3;
comment|/* maximum SII chip supports */
block|state->dmaCurPhase = SII_MSG_OUT_PHASE, 		state->dmalen = 6; 		CopyToBuffer((u_short *)sii_buf, 			(volatile u_short *)SII_BUF_ADDR, 6); 		regs->slcsr = target; 		regs->dmctrl = state->dmaReqAck; 		regs->dmaddrl = (u_short)(SII_BUF_ADDR>> 1); 		regs->dmaddrh = (u_short)(SII_BUF_ADDR>> 17)& 03; 		regs->dmlotc = 6; 		regs->comm = SII_DMA | SII_INXFER | SII_SELECT | SII_ATN | 			SII_CON | SII_MSG_OUT_PHASE; 	} else
endif|#
directive|endif
block|{
comment|/* do a chained, select with ATN and programmed I/O command */
name|regs
operator|->
name|data
operator|=
name|SCSI_DIS_REC_IDENTIFY
expr_stmt|;
name|regs
operator|->
name|slcsr
operator|=
name|target
expr_stmt|;
name|regs
operator|->
name|dmctrl
operator|=
name|state
operator|->
name|dmaReqAck
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
name|SII_SELECT
operator||
name|SII_ATN
operator||
name|SII_CON
operator||
name|SII_MSG_OUT_PHASE
expr_stmt|;
block|}
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* 	 * Wait for something to happen 	 * (should happen soon or we would use interrupts). 	 */
name|SII_WAIT_UNTIL
argument_list|(
name|status
argument_list|,
name|regs
operator|->
name|cstat
argument_list|,
name|status
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
argument_list|,
name|SII_WAIT_COUNT
operator|/
literal|4
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* check to see if we are connected OK */
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|SII_RST
operator||
name|SII_SCH
operator||
name|SII_STATE_MSK
operator|)
operator|)
operator|==
operator|(
name|SII_SCH
operator||
name|SII_CON
operator|)
condition|)
block|{
name|regs
operator|->
name|cstat
operator|=
name|status
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|sii_logp
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|sii_logp
operator|->
name|cstat
operator|=
name|status
expr_stmt|;
name|sii_logp
operator|->
name|dstat
operator|=
literal|0
expr_stmt|;
name|sii_logp
operator|->
name|comm
operator|=
name|regs
operator|->
name|comm
expr_stmt|;
name|sii_logp
operator|->
name|msg
operator|=
operator|-
literal|1
expr_stmt|;
name|sii_logp
operator|->
name|rlen
operator|=
name|state
operator|->
name|buflen
expr_stmt|;
name|sii_logp
operator|->
name|dlen
operator|=
name|state
operator|->
name|dmalen
expr_stmt|;
if|if
condition|(
operator|++
name|sii_logp
operator|>=
operator|&
name|sii_log
index|[
name|NLOG
index|]
condition|)
name|sii_logp
operator|=
name|sii_log
expr_stmt|;
endif|#
directive|endif
comment|/* wait a short time for command phase */
name|SII_WAIT_UNTIL
argument_list|(
name|status
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|status
operator|&
name|SII_MIS
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|retval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"sii_StartCmd: ds %x cnt %d\n"
argument_list|,
name|status
argument_list|,
name|retval
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|SII_CI
operator||
name|SII_MIS
operator||
name|SII_PHASE_MSK
operator|)
operator|)
operator|!=
operator|(
name|SII_MIS
operator||
name|SII_CMD_PHASE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sii_StartCmd: timeout cs %x ds %x cnt %d\n"
argument_list|,
name|regs
operator|->
name|cstat
argument_list|,
name|status
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* process interrupt or continue until it happens */
if|if
condition|(
name|status
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
condition|)
name|sii_DoIntr
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
comment|/* clear Msg Out DMA done */
comment|/* send command data */
name|CopyToBuffer
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|state
operator|->
name|cmd
argument_list|,
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|state
operator|->
name|dmaAddr
index|[
literal|0
index|]
argument_list|,
name|state
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
name|sii_StartDMA
argument_list|(
name|regs
argument_list|,
name|state
operator|->
name|dmaCurPhase
operator|=
name|SII_CMD_PHASE
argument_list|,
name|state
operator|->
name|dmaAddr
index|[
literal|0
index|]
argument_list|,
name|state
operator|->
name|dmalen
operator|=
name|scsicmd
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
comment|/* wait a little while for DMA to finish */
name|SII_WAIT_UNTIL
argument_list|(
name|status
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|status
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|retval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"sii_StartCmd: ds %x, cnt %d\n"
argument_list|,
name|status
argument_list|,
name|retval
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
condition|)
name|sii_DoIntr
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"sii_StartCmd: DONE ds %x\n"
argument_list|,
name|regs
operator|->
name|dstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * Another device may have selected us; in which case, 	 * this command will be restarted later. 	 */
if|if
condition|(
name|status
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
condition|)
block|{
name|sii_DoIntr
argument_list|(
name|sc
argument_list|,
name|regs
operator|->
name|dstat
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Disconnect if selection command still in progress. 	 */
if|if
condition|(
name|status
operator|&
name|SII_SIP
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
comment|/* device didn't respond */
name|regs
operator|->
name|comm
operator|=
name|SII_DISCON
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|status
argument_list|,
name|regs
operator|->
name|cstat
argument_list|,
operator|!
operator|(
name|status
operator|&
operator|(
name|SII_CON
operator||
name|SII_SIP
operator|)
operator|)
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* couldn't get the bus */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"sii_StartCmd: Couldn't select target %d error %d\n"
argument_list|,
name|target
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_target
operator|=
operator|-
literal|1
expr_stmt|;
name|regs
operator|->
name|cstat
operator|=
literal|0xffff
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
literal|0xffff
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
literal|0
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|sii_CmdDone
argument_list|(
name|sc
argument_list|,
name|target
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process interrupt conditions.  */
end_comment

begin_function
specifier|static
name|void
name|sii_DoIntr
parameter_list|(
name|sc
parameter_list|,
name|dstat
parameter_list|)
specifier|register
name|struct
name|siisoftc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|u_int
name|dstat
decl_stmt|;
block|{
specifier|register
name|SIIRegs
modifier|*
name|regs
init|=
name|sc
operator|->
name|sc_regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
decl_stmt|;
specifier|register
name|u_int
name|cstat
decl_stmt|;
name|int
name|i
decl_stmt|,
name|msg
decl_stmt|;
name|u_int
name|comm
decl_stmt|;
name|again
label|:
name|comm
operator|=
name|regs
operator|->
name|comm
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"sii_DoIntr: cs %x, ds %x cm %x "
argument_list|,
name|regs
operator|->
name|cstat
argument_list|,
name|dstat
argument_list|,
name|comm
argument_list|)
expr_stmt|;
name|sii_logp
operator|->
name|target
operator|=
name|sc
operator|->
name|sc_target
expr_stmt|;
name|sii_logp
operator|->
name|cstat
operator|=
name|regs
operator|->
name|cstat
expr_stmt|;
name|sii_logp
operator|->
name|dstat
operator|=
name|dstat
expr_stmt|;
name|sii_logp
operator|->
name|comm
operator|=
name|comm
expr_stmt|;
name|sii_logp
operator|->
name|msg
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_target
operator|>=
literal|0
condition|)
block|{
name|sii_logp
operator|->
name|rlen
operator|=
name|sc
operator|->
name|sc_st
index|[
name|sc
operator|->
name|sc_target
index|]
operator|.
name|buflen
expr_stmt|;
name|sii_logp
operator|->
name|dlen
operator|=
name|sc
operator|->
name|sc_st
index|[
name|sc
operator|->
name|sc_target
index|]
operator|.
name|dmalen
expr_stmt|;
block|}
else|else
block|{
name|sii_logp
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|sii_logp
operator|->
name|dlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|sii_logp
operator|>=
operator|&
name|sii_log
index|[
name|NLOG
index|]
condition|)
name|sii_logp
operator|=
name|sii_log
expr_stmt|;
endif|#
directive|endif
name|regs
operator|->
name|dstat
operator|=
name|dstat
expr_stmt|;
comment|/* acknowledge everything */
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|dstat
operator|&
name|SII_CI
condition|)
block|{
comment|/* deglitch cstat register */
name|msg
operator|=
name|regs
operator|->
name|cstat
expr_stmt|;
while|while
condition|(
name|msg
operator|!=
operator|(
name|cstat
operator|=
name|regs
operator|->
name|cstat
operator|)
condition|)
name|msg
operator|=
name|cstat
expr_stmt|;
name|regs
operator|->
name|cstat
operator|=
name|cstat
expr_stmt|;
comment|/* acknowledge everything */
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_logp
operator|>
name|sii_log
condition|)
name|sii_logp
index|[
operator|-
literal|1
index|]
operator|.
name|cstat
operator|=
name|cstat
expr_stmt|;
else|else
name|sii_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|cstat
operator|=
name|cstat
expr_stmt|;
endif|#
directive|endif
comment|/* check for a BUS RESET */
if|if
condition|(
name|cstat
operator|&
name|SII_RST
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: SCSI bus reset!!\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|)
expr_stmt|;
comment|/* need to flush disconnected commands */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SII_NCMD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_cmd
index|[
name|i
index|]
condition|)
continue|continue;
name|sii_CmdDone
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
block|}
comment|/* rearbitrate synchronous offset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SII_NCMD
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_st
index|[
name|i
index|]
operator|.
name|dmaReqAck
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_target
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* 		 * Check for a BUS ERROR. 		 * According to DEC, this feature doesn't really work 		 * and to just clear the bit if it's set. 		 */
if|if
condition|(
name|cstat
operator|&
name|SII_BER
condition|)
block|{ 		}
endif|#
directive|endif
comment|/* check for state change */
if|if
condition|(
name|cstat
operator|&
name|SII_SCH
condition|)
block|{
name|sii_StateChg
argument_list|(
name|sc
argument_list|,
name|cstat
argument_list|)
expr_stmt|;
name|comm
operator|=
name|regs
operator|->
name|comm
expr_stmt|;
block|}
block|}
comment|/* check for DMA completion */
if|if
condition|(
name|dstat
operator|&
name|SII_DNE
condition|)
block|{
name|u_short
modifier|*
name|dma
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* 		 * There is a race condition with SII_SCH. There is a short 		 * window between the time a SII_SCH is seen after a disconnect  		 * and when the SII_SCH is cleared. A reselect can happen 		 * in this window and we will clear the SII_SCH without 		 * processing the reconnect. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_target
operator|<
literal|0
condition|)
block|{
name|cstat
operator|=
name|regs
operator|->
name|cstat
expr_stmt|;
name|printf
argument_list|(
literal|"sii%d: target %d DNE?? dev %d,%d cs %x\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|,
name|regs
operator|->
name|slcsr
argument_list|,
name|regs
operator|->
name|destat
argument_list|,
name|cstat
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|cstat
operator|&
name|SII_DST
condition|)
block|{
name|sc
operator|->
name|sc_target
operator|=
name|regs
operator|->
name|destat
expr_stmt|;
name|state
operator|->
name|prevComm
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"sc_target 1"
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
operator|&
name|sc
operator|->
name|sc_st
index|[
name|sc
operator|->
name|sc_target
index|]
expr_stmt|;
comment|/* check for a PARITY ERROR */
if|if
condition|(
name|dstat
operator|&
name|SII_IPE
condition|)
block|{
name|state
operator|->
name|flags
operator||=
name|PARITY_ERR
expr_stmt|;
name|printf
argument_list|(
literal|"sii%d: Parity error!!\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
comment|/* dmalen = amount left to transfer, i = amount transfered */
name|i
operator|=
name|state
operator|->
name|dmalen
expr_stmt|;
name|state
operator|->
name|dmalen
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|dmaCurPhase
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"DNE: amt %d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dstat
operator|&
name|SII_TCZ
operator|)
condition|)
name|printf
argument_list|(
literal|"no TCZ?? (%d) "
argument_list|,
name|regs
operator|->
name|dmlotc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|dstat
operator|&
name|SII_TCZ
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: device %d: no TCZ?? (%d)\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|,
name|regs
operator|->
name|dmlotc
argument_list|)
expr_stmt|;
name|sii_DumpLog
argument_list|()
expr_stmt|;
comment|/* XXX */
block|}
endif|#
directive|endif
switch|switch
condition|(
name|comm
operator|&
name|SII_PHASE_MSK
condition|)
block|{
case|case
name|SII_CMD_PHASE
case|:
name|state
operator|->
name|cmdlen
operator|-=
name|i
expr_stmt|;
break|break;
case|case
name|SII_DATA_IN_PHASE
case|:
comment|/* check for more data for the same phase */
name|dma
operator|=
name|state
operator|->
name|dmaAddr
index|[
name|state
operator|->
name|dmaBufIndex
index|]
expr_stmt|;
name|buf
operator|=
name|state
operator|->
name|buf
expr_stmt|;
name|state
operator|->
name|buf
operator|+=
name|i
expr_stmt|;
name|state
operator|->
name|buflen
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|buflen
operator|>
literal|0
operator|&&
operator|!
operator|(
name|dstat
operator|&
name|SII_MIS
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
comment|/* start reading next chunk */
name|len
operator|=
name|state
operator|->
name|buflen
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SII_MAX_DMA_XFER_LENGTH
condition|)
name|len
operator|=
name|SII_MAX_DMA_XFER_LENGTH
expr_stmt|;
name|state
operator|->
name|dmaBufIndex
operator|=
operator|!
name|state
operator|->
name|dmaBufIndex
expr_stmt|;
name|sii_StartDMA
argument_list|(
name|regs
argument_list|,
name|state
operator|->
name|dmaCurPhase
operator|=
name|SII_DATA_IN_PHASE
argument_list|,
name|state
operator|->
name|dmaAddr
index|[
name|state
operator|->
name|dmaBufIndex
index|]
argument_list|,
name|state
operator|->
name|dmalen
operator|=
name|len
argument_list|)
expr_stmt|;
name|dstat
operator|&=
operator|~
operator|(
name|SII_IBF
operator||
name|SII_TBE
operator|)
expr_stmt|;
block|}
comment|/* copy in the data */
name|CopyFromBuffer
argument_list|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|dma
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|SII_DATA_OUT_PHASE
case|:
name|state
operator|->
name|dmaBufIndex
operator|=
operator|!
name|state
operator|->
name|dmaBufIndex
expr_stmt|;
name|state
operator|->
name|buf
operator|+=
name|i
expr_stmt|;
name|state
operator|->
name|buflen
operator|-=
name|i
expr_stmt|;
comment|/* check for more data for the same phase */
if|if
condition|(
name|state
operator|->
name|buflen
operator|<=
literal|0
operator|||
operator|(
name|dstat
operator|&
name|SII_MIS
operator|)
condition|)
break|break;
comment|/* start next chunk */
name|i
operator|=
name|state
operator|->
name|buflen
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|SII_MAX_DMA_XFER_LENGTH
condition|)
block|{
name|sii_StartDMA
argument_list|(
name|regs
argument_list|,
name|state
operator|->
name|dmaCurPhase
operator|=
name|SII_DATA_OUT_PHASE
argument_list|,
name|state
operator|->
name|dmaAddr
index|[
name|state
operator|->
name|dmaBufIndex
index|]
argument_list|,
name|state
operator|->
name|dmalen
operator|=
name|SII_MAX_DMA_XFER_LENGTH
argument_list|)
expr_stmt|;
comment|/* prepare for next chunk */
name|i
operator|-=
name|SII_MAX_DMA_XFER_LENGTH
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|SII_MAX_DMA_XFER_LENGTH
condition|)
name|i
operator|=
name|SII_MAX_DMA_XFER_LENGTH
expr_stmt|;
name|CopyToBuffer
argument_list|(
operator|(
name|u_short
operator|*
operator|)
operator|(
name|state
operator|->
name|buf
operator|+
name|SII_MAX_DMA_XFER_LENGTH
operator|)
argument_list|,
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|state
operator|->
name|dmaAddr
index|[
operator|!
name|state
operator|->
name|dmaBufIndex
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sii_StartDMA
argument_list|(
name|regs
argument_list|,
name|state
operator|->
name|dmaCurPhase
operator|=
name|SII_DATA_OUT_PHASE
argument_list|,
name|state
operator|->
name|dmaAddr
index|[
name|state
operator|->
name|dmaBufIndex
index|]
argument_list|,
name|state
operator|->
name|dmalen
operator|=
name|i
argument_list|)
expr_stmt|;
block|}
name|dstat
operator|&=
operator|~
operator|(
name|SII_IBF
operator||
name|SII_TBE
operator|)
expr_stmt|;
block|}
block|}
comment|/* check for phase change or another MsgIn/Out */
if|if
condition|(
name|dstat
operator|&
operator|(
name|SII_MIS
operator||
name|SII_IBF
operator||
name|SII_TBE
operator|)
condition|)
block|{
comment|/* 		 * There is a race condition with SII_SCH. There is a short 		 * window between the time a SII_SCH is seen after a disconnect  		 * and when the SII_SCH is cleared. A reselect can happen 		 * in this window and we will clear the SII_SCH without 		 * processing the reconnect. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_target
operator|<
literal|0
condition|)
block|{
name|cstat
operator|=
name|regs
operator|->
name|cstat
expr_stmt|;
name|printf
argument_list|(
literal|"sii%d: target %d MIS?? dev %d,%d cs %x ds %x\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|,
name|regs
operator|->
name|slcsr
argument_list|,
name|regs
operator|->
name|destat
argument_list|,
name|cstat
argument_list|,
name|dstat
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|cstat
operator|&
name|SII_DST
condition|)
block|{
name|sc
operator|->
name|sc_target
operator|=
name|regs
operator|->
name|destat
expr_stmt|;
name|state
operator|->
name|prevComm
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sii_DumpLog
argument_list|()
expr_stmt|;
name|panic
argument_list|(
literal|"sc_target 2"
argument_list|)
expr_stmt|;
block|}
block|}
name|state
operator|=
operator|&
name|sc
operator|->
name|sc_st
index|[
name|sc
operator|->
name|sc_target
index|]
expr_stmt|;
switch|switch
condition|(
name|dstat
operator|&
name|SII_PHASE_MSK
condition|)
block|{
case|case
name|SII_CMD_PHASE
case|:
if|if
condition|(
name|state
operator|->
name|dmaPrevPhase
operator|>=
literal|0
condition|)
block|{
comment|/* restart DMA after disconnect/reconnect */
if|if
condition|(
name|state
operator|->
name|dmaPrevPhase
operator|!=
name|SII_CMD_PHASE
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: device %d: dma reselect phase doesn't match\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|state
operator|->
name|dmaCurPhase
operator|=
name|SII_CMD_PHASE
expr_stmt|;
name|state
operator|->
name|dmaPrevPhase
operator|=
operator|-
literal|1
expr_stmt|;
name|regs
operator|->
name|dmaddrl
operator|=
name|state
operator|->
name|dmaAddrL
expr_stmt|;
name|regs
operator|->
name|dmaddrh
operator|=
name|state
operator|->
name|dmaAddrH
expr_stmt|;
name|regs
operator|->
name|dmlotc
operator|=
name|state
operator|->
name|dmaCnt
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dmaCnt
operator|&
literal|1
condition|)
name|regs
operator|->
name|dmabyte
operator|=
name|state
operator|->
name|dmaByte
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|SII_DMA
operator||
name|SII_INXFER
operator||
operator|(
name|comm
operator|&
name|SII_STATE_MSK
operator|)
operator||
name|SII_CMD_PHASE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"Cmd dcnt %d dadr %x "
argument_list|,
name|state
operator|->
name|dmaCnt
argument_list|,
operator|(
name|state
operator|->
name|dmaAddrH
operator|<<
literal|16
operator|)
operator||
name|state
operator|->
name|dmaAddrL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* send command data */
name|i
operator|=
name|state
operator|->
name|cmdlen
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: device %d: cmd count exceeded\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|CopyToBuffer
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|state
operator|->
name|cmd
argument_list|,
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|state
operator|->
name|dmaAddr
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sii_StartDMA
argument_list|(
name|regs
argument_list|,
name|state
operator|->
name|dmaCurPhase
operator|=
name|SII_CMD_PHASE
argument_list|,
name|state
operator|->
name|dmaAddr
index|[
literal|0
index|]
argument_list|,
name|state
operator|->
name|dmalen
operator|=
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* wait a short time for XFER complete */
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstat
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"cnt %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sii_debug
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"sii_DoIntr: cmd wait ds %x cnt %d\n"
argument_list|,
name|dstat
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|again
goto|;
block|}
break|break;
case|case
name|SII_DATA_IN_PHASE
case|:
case|case
name|SII_DATA_OUT_PHASE
case|:
if|if
condition|(
name|state
operator|->
name|cmdlen
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: device %d: cmd %x: command data not all sent (%d) 1\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|,
name|sc
operator|->
name|sc_cmd
index|[
name|sc
operator|->
name|sc_target
index|]
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|state
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
name|state
operator|->
name|cmdlen
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|sii_DumpLog
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|state
operator|->
name|dmaPrevPhase
operator|>=
literal|0
condition|)
block|{
comment|/* restart DMA after disconnect/reconnect */
if|if
condition|(
name|state
operator|->
name|dmaPrevPhase
operator|!=
operator|(
name|dstat
operator|&
name|SII_PHASE_MSK
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: device %d: dma reselect phase doesn't match\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|state
operator|->
name|dmaCurPhase
operator|=
name|state
operator|->
name|dmaPrevPhase
expr_stmt|;
name|state
operator|->
name|dmaPrevPhase
operator|=
operator|-
literal|1
expr_stmt|;
name|regs
operator|->
name|dmaddrl
operator|=
name|state
operator|->
name|dmaAddrL
expr_stmt|;
name|regs
operator|->
name|dmaddrh
operator|=
name|state
operator|->
name|dmaAddrH
expr_stmt|;
name|regs
operator|->
name|dmlotc
operator|=
name|state
operator|->
name|dmaCnt
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dmaCnt
operator|&
literal|1
condition|)
name|regs
operator|->
name|dmabyte
operator|=
name|state
operator|->
name|dmaByte
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|SII_DMA
operator||
name|SII_INXFER
operator||
operator|(
name|comm
operator|&
name|SII_STATE_MSK
operator|)
operator||
name|state
operator|->
name|dmaCurPhase
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"Data %d dcnt %d dadr %x "
argument_list|,
name|state
operator|->
name|dmaDataPhase
argument_list|,
name|state
operator|->
name|dmaCnt
argument_list|,
operator|(
name|state
operator|->
name|dmaAddrH
operator|<<
literal|16
operator|)
operator||
name|state
operator|->
name|dmaAddrL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|state
operator|->
name|dmaDataPhase
operator|!=
operator|(
name|dstat
operator|&
name|SII_PHASE_MSK
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: device %d: cmd %x: dma phase doesn't match\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|,
name|sc
operator|->
name|sc_cmd
index|[
name|sc
operator|->
name|sc_target
index|]
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"Data %d "
argument_list|,
name|state
operator|->
name|dmaDataPhase
argument_list|)
expr_stmt|;
if|if
condition|(
name|sii_debug
operator|>
literal|5
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|i
operator|=
name|state
operator|->
name|buflen
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: device %d: data count exceeded\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
if|if
condition|(
name|i
operator|>
name|SII_MAX_DMA_XFER_LENGTH
condition|)
name|i
operator|=
name|SII_MAX_DMA_XFER_LENGTH
expr_stmt|;
if|if
condition|(
operator|(
name|dstat
operator|&
name|SII_PHASE_MSK
operator|)
operator|==
name|SII_DATA_IN_PHASE
condition|)
block|{
name|sii_StartDMA
argument_list|(
name|regs
argument_list|,
name|state
operator|->
name|dmaCurPhase
operator|=
name|SII_DATA_IN_PHASE
argument_list|,
name|state
operator|->
name|dmaAddr
index|[
name|state
operator|->
name|dmaBufIndex
index|]
argument_list|,
name|state
operator|->
name|dmalen
operator|=
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* start first chunk */
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|FIRST_DMA
condition|)
block|{
name|state
operator|->
name|flags
operator|&=
operator|~
name|FIRST_DMA
expr_stmt|;
name|CopyToBuffer
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|state
operator|->
name|buf
argument_list|,
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|state
operator|->
name|dmaAddr
index|[
name|state
operator|->
name|dmaBufIndex
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sii_StartDMA
argument_list|(
name|regs
argument_list|,
name|state
operator|->
name|dmaCurPhase
operator|=
name|SII_DATA_OUT_PHASE
argument_list|,
name|state
operator|->
name|dmaAddr
index|[
name|state
operator|->
name|dmaBufIndex
index|]
argument_list|,
name|state
operator|->
name|dmalen
operator|=
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|state
operator|->
name|buflen
operator|-
name|SII_MAX_DMA_XFER_LENGTH
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* prepare for next chunk */
if|if
condition|(
name|i
operator|>
name|SII_MAX_DMA_XFER_LENGTH
condition|)
name|i
operator|=
name|SII_MAX_DMA_XFER_LENGTH
expr_stmt|;
name|CopyToBuffer
argument_list|(
operator|(
name|u_short
operator|*
operator|)
operator|(
name|state
operator|->
name|buf
operator|+
name|SII_MAX_DMA_XFER_LENGTH
operator|)
argument_list|,
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|state
operator|->
name|dmaAddr
index|[
operator|!
name|state
operator|->
name|dmaBufIndex
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SII_STATUS_PHASE
case|:
if|if
condition|(
name|state
operator|->
name|cmdlen
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: device %d: cmd %x: command data not all sent (%d) 2\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|,
name|sc
operator|->
name|sc_cmd
index|[
name|sc
operator|->
name|sc_target
index|]
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|state
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
name|state
operator|->
name|cmdlen
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|sii_DumpLog
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* read amount transfered if DMA didn't finish */
if|if
condition|(
name|state
operator|->
name|dmalen
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|state
operator|->
name|dmalen
operator|-
name|regs
operator|->
name|dmlotc
expr_stmt|;
name|state
operator|->
name|dmalen
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|dmaCurPhase
operator|=
operator|-
literal|1
expr_stmt|;
name|regs
operator|->
name|dmlotc
operator|=
literal|0
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|comm
operator|&
operator|(
name|SII_STATE_MSK
operator||
name|SII_PHASE_MSK
operator|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"DMA amt %d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|comm
operator|&
name|SII_PHASE_MSK
condition|)
block|{
case|case
name|SII_DATA_IN_PHASE
case|:
comment|/* copy in the data */
name|CopyFromBuffer
argument_list|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|state
operator|->
name|dmaAddr
index|[
name|state
operator|->
name|dmaBufIndex
index|]
argument_list|,
name|state
operator|->
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
case|case
name|SII_CMD_PHASE
case|:
case|case
name|SII_DATA_OUT_PHASE
case|:
name|state
operator|->
name|buflen
operator|-=
name|i
expr_stmt|;
block|}
block|}
comment|/* read a one byte status message */
name|state
operator|->
name|statusByte
operator|=
name|msg
operator|=
name|sii_GetByte
argument_list|(
name|regs
argument_list|,
name|SII_STATUS_PHASE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|<
literal|0
condition|)
block|{
name|dstat
operator|=
name|regs
operator|->
name|dstat
expr_stmt|;
goto|goto
name|again
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"Status %x "
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sii_logp
operator|>
name|sii_log
condition|)
name|sii_logp
index|[
operator|-
literal|1
index|]
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
else|else
name|sii_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
endif|#
directive|endif
comment|/* do a quick wait for COMMAND_COMPLETE */
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstat
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"cnt2 %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|again
goto|;
block|}
break|break;
case|case
name|SII_MSG_IN_PHASE
case|:
comment|/* 			 * Save DMA state if DMA didn't finish. 			 * Be careful not to save state again after reconnect 			 * and see RESTORE_POINTER message. 			 * Note that the SII DMA address is not incremented 			 * as DMA proceeds. 			 */
if|if
condition|(
name|state
operator|->
name|dmaCurPhase
operator|>
literal|0
condition|)
block|{
comment|/* save dma registers */
name|state
operator|->
name|dmaPrevPhase
operator|=
name|state
operator|->
name|dmaCurPhase
expr_stmt|;
name|state
operator|->
name|dmaCurPhase
operator|=
operator|-
literal|1
expr_stmt|;
name|state
operator|->
name|dmaCnt
operator|=
name|i
operator|=
name|regs
operator|->
name|dmlotc
expr_stmt|;
if|if
condition|(
name|dstat
operator|&
name|SII_OBB
condition|)
name|state
operator|->
name|dmaByte
operator|=
name|regs
operator|->
name|dmabyte
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|SII_MAX_DMA_XFER_LENGTH
expr_stmt|;
name|i
operator|=
name|state
operator|->
name|dmalen
operator|-
name|i
expr_stmt|;
comment|/* note: no carry from dmaddrl to dmaddrh */
name|state
operator|->
name|dmaAddrL
operator|=
name|regs
operator|->
name|dmaddrl
operator|+
name|i
expr_stmt|;
name|state
operator|->
name|dmaAddrH
operator|=
name|regs
operator|->
name|dmaddrh
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|comm
operator|&
operator|(
name|SII_STATE_MSK
operator||
name|SII_PHASE_MSK
operator|)
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"SavP dcnt %d dadr %x "
argument_list|,
name|state
operator|->
name|dmaCnt
argument_list|,
operator|(
name|state
operator|->
name|dmaAddrH
operator|<<
literal|16
operator|)
operator||
name|state
operator|->
name|dmaAddrL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dstat
operator|&
name|SII_OBB
operator|)
operator|!=
literal|0
operator|)
operator|^
operator|(
name|state
operator|->
name|dmaCnt
operator|&
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"OBB??? "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sii_debug
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|dstat
operator|&
name|SII_OBB
operator|)
operator|!=
literal|0
operator|)
operator|^
operator|(
name|state
operator|->
name|dmaCnt
operator|&
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sii_DoIntr: OBB??? ds %x cnt %d\n"
argument_list|,
name|dstat
argument_list|,
name|state
operator|->
name|dmaCnt
argument_list|)
expr_stmt|;
name|sii_DumpLog
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* read a one byte message */
name|msg
operator|=
name|sii_GetByte
argument_list|(
name|regs
argument_list|,
name|SII_MSG_IN_PHASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|<
literal|0
condition|)
block|{
name|dstat
operator|=
name|regs
operator|->
name|dstat
expr_stmt|;
goto|goto
name|again
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"MsgIn %x "
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sii_logp
operator|>
name|sii_log
condition|)
name|sii_logp
index|[
operator|-
literal|1
index|]
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
else|else
name|sii_log
index|[
name|NLOG
operator|-
literal|1
index|]
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
endif|#
directive|endif
comment|/* process message */
switch|switch
condition|(
name|msg
condition|)
block|{
case|case
name|SCSI_COMMAND_COMPLETE
case|:
comment|/* acknowledge last byte */
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
name|SII_MSG_IN_PHASE
operator||
operator|(
name|comm
operator|&
name|SII_STATE_MSK
operator|)
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|msg
operator|=
name|sc
operator|->
name|sc_target
expr_stmt|;
name|sc
operator|->
name|sc_target
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 				 * Wait a short time for disconnect. 				 * Don't be fooled if SII_BER happens first. 				 * Note: a reselect may happen here. 				 */
name|SII_WAIT_UNTIL
argument_list|(
name|cstat
argument_list|,
name|regs
operator|->
name|cstat
argument_list|,
name|cstat
operator|&
operator|(
name|SII_RST
operator||
name|SII_SCH
operator|)
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cstat
operator|&
operator|(
name|SII_RST
operator||
name|SII_SCH
operator||
name|SII_STATE_MSK
operator|)
operator|)
operator|==
name|SII_SCH
condition|)
block|{
name|regs
operator|->
name|cstat
operator|=
name|SII_SCH
operator||
name|SII_BER
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
literal|0
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* 					 * Double check that we didn't miss a 					 * state change between seeing it and 					 * clearing the SII_SCH bit. 					 */
name|i
operator|=
name|regs
operator|->
name|cstat
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|&
name|SII_SCH
operator|)
operator|&&
operator|(
name|i
operator|&
name|SII_STATE_MSK
operator|)
operator|!=
operator|(
name|cstat
operator|&
name|SII_STATE_MSK
operator|)
condition|)
name|sii_StateChg
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"cs %x\n"
argument_list|,
name|cstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sii_CmdDone
argument_list|(
name|sc
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_EXTENDED_MSG
case|:
comment|/* acknowledge last byte */
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
name|SII_MSG_IN_PHASE
operator||
operator|(
name|comm
operator|&
name|SII_STATE_MSK
operator|)
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* read the message length */
name|msg
operator|=
name|sii_GetByte
argument_list|(
name|regs
argument_list|,
name|SII_MSG_IN_PHASE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|<
literal|0
condition|)
block|{
name|dstat
operator|=
name|regs
operator|->
name|dstat
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|sii_buf
index|[
literal|1
index|]
operator|=
name|msg
expr_stmt|;
comment|/* message length */
if|if
condition|(
name|msg
operator|==
literal|0
condition|)
name|msg
operator|=
literal|256
expr_stmt|;
comment|/* 				 * We read and acknowlege all the bytes 				 * except the last so we can assert ATN 				 * if needed before acknowledging the last. 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
condition|;
name|i
operator|++
control|)
block|{
name|dstat
operator|=
name|sii_GetByte
argument_list|(
name|regs
argument_list|,
name|SII_MSG_IN_PHASE
argument_list|,
name|i
operator|<
name|msg
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|dstat
operator|<
literal|0
condition|)
block|{
name|dstat
operator|=
name|regs
operator|->
name|dstat
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|sii_buf
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|dstat
expr_stmt|;
block|}
switch|switch
condition|(
name|sii_buf
index|[
literal|2
index|]
condition|)
block|{
case|case
name|SCSI_MODIFY_DATA_PTR
case|:
comment|/* acknowledge last byte */
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
name|SII_MSG_IN_PHASE
operator||
operator|(
name|comm
operator|&
name|SII_STATE_MSK
operator|)
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|i
operator|=
operator|(
name|sii_buf
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sii_buf
index|[
literal|4
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sii_buf
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|sii_buf
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dmaPrevPhase
operator|>=
literal|0
condition|)
block|{
name|state
operator|->
name|dmaAddrL
operator|+=
name|i
expr_stmt|;
name|state
operator|->
name|dmaCnt
operator|-=
name|i
expr_stmt|;
block|}
break|break;
case|case
name|SCSI_SYNCHRONOUS_XFER
case|:
comment|/* 					 * Acknowledge last byte and 					 * signal a request for MSG_OUT. 					 */
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
name|SII_ATN
operator||
name|SII_MSG_IN_PHASE
operator||
operator|(
name|comm
operator|&
name|SII_STATE_MSK
operator|)
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|sii_DoSync
argument_list|(
name|regs
argument_list|,
name|state
argument_list|)
expr_stmt|;
break|break;
default|default:
name|reject
label|:
comment|/* 					 * Acknowledge last byte and 					 * signal a request for MSG_OUT. 					 */
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
name|SII_ATN
operator||
name|SII_MSG_IN_PHASE
operator||
operator|(
name|comm
operator|&
name|SII_STATE_MSK
operator|)
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* wait for MSG_OUT phase */
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_TBE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* send a reject message */
name|regs
operator|->
name|data
operator|=
name|SCSI_MESSAGE_REJECT
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
operator|(
name|regs
operator|->
name|cstat
operator|&
name|SII_STATE_MSK
operator|)
operator||
name|SII_MSG_OUT_PHASE
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|SCSI_SAVE_DATA_POINTER
case|:
case|case
name|SCSI_RESTORE_POINTERS
case|:
comment|/* acknowledge last byte */
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
name|SII_MSG_IN_PHASE
operator||
operator|(
name|comm
operator|&
name|SII_STATE_MSK
operator|)
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* wait a short time for another msg */
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstat
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"cnt %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|again
goto|;
block|}
break|break;
case|case
name|SCSI_DISCONNECT
case|:
comment|/* acknowledge last byte */
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
name|SII_MSG_IN_PHASE
operator||
operator|(
name|comm
operator|&
name|SII_STATE_MSK
operator|)
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|state
operator|->
name|prevComm
operator|=
name|comm
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"disconn %d "
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 				 * Wait a short time for disconnect. 				 * Don't be fooled if SII_BER happens first. 				 * Note: a reselect may happen here. 				 */
name|SII_WAIT_UNTIL
argument_list|(
name|cstat
argument_list|,
name|regs
operator|->
name|cstat
argument_list|,
name|cstat
operator|&
operator|(
name|SII_RST
operator||
name|SII_SCH
operator|)
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cstat
operator|&
operator|(
name|SII_RST
operator||
name|SII_SCH
operator||
name|SII_STATE_MSK
operator|)
operator|)
operator|!=
name|SII_SCH
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"cnt %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dstat
operator|=
name|regs
operator|->
name|dstat
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|regs
operator|->
name|cstat
operator|=
name|SII_SCH
operator||
name|SII_BER
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
literal|0
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_target
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 				 * Double check that we didn't miss a state 				 * change between seeing it and clearing 				 * the SII_SCH bit. 				 */
name|i
operator|=
name|regs
operator|->
name|cstat
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|&
name|SII_SCH
operator|)
operator|&&
operator|(
name|i
operator|&
name|SII_STATE_MSK
operator|)
operator|!=
operator|(
name|cstat
operator|&
name|SII_STATE_MSK
operator|)
condition|)
name|sii_StateChg
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_MESSAGE_REJECT
case|:
comment|/* acknowledge last byte */
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
name|SII_MSG_IN_PHASE
operator||
operator|(
name|comm
operator|&
name|SII_STATE_MSK
operator|)
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"sii%d: device %d: message reject.\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
operator|(
name|msg
operator|&
name|SCSI_IDENTIFY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: device %d: couldn't handle message 0x%x... rejecting.\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|,
name|msg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|sii_DumpLog
argument_list|()
expr_stmt|;
endif|#
directive|endif
goto|goto
name|reject
goto|;
block|}
comment|/* acknowledge last byte */
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
name|SII_MSG_IN_PHASE
operator||
operator|(
name|comm
operator|&
name|SII_STATE_MSK
operator|)
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* may want to check LUN some day */
comment|/* wait a short time for another msg */
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstat
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"cnt %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|again
goto|;
block|}
block|}
break|break;
case|case
name|SII_MSG_OUT_PHASE
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"MsgOut\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"MsgOut %x\n"
argument_list|,
name|state
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* 			 * Check for parity error. 			 * Hardware will automatically set ATN 			 * to request the device for a MSG_OUT phase. 			 */
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|PARITY_ERR
condition|)
block|{
name|state
operator|->
name|flags
operator|&=
operator|~
name|PARITY_ERR
expr_stmt|;
name|regs
operator|->
name|data
operator|=
name|SCSI_MESSAGE_PARITY_ERROR
expr_stmt|;
block|}
else|else
name|regs
operator|->
name|data
operator|=
name|SCSI_NO_OP
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
operator|(
name|comm
operator|&
name|SII_STATE_MSK
operator|)
operator||
name|SII_MSG_OUT_PHASE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* wait a short time for XFER complete */
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"ds %x i %d\n"
argument_list|,
name|dstat
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* just clear the DNE bit and check errors later */
if|if
condition|(
name|dstat
operator|&
name|SII_DNE
condition|)
block|{
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"sii%d: Couldn't handle phase %d... ignoring.\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|dstat
operator|&
name|SII_PHASE_MSK
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Check to make sure we won't be interrupted again. 	 * Deglitch dstat register. 	 */
name|msg
operator|=
name|regs
operator|->
name|dstat
expr_stmt|;
while|while
condition|(
name|msg
operator|!=
operator|(
name|dstat
operator|=
name|regs
operator|->
name|dstat
operator|)
condition|)
name|msg
operator|=
name|dstat
expr_stmt|;
if|if
condition|(
name|dstat
operator|&
operator|(
name|SII_CI
operator||
name|SII_DI
operator|)
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|sc
operator|->
name|sc_target
operator|<
literal|0
condition|)
block|{
comment|/* look for another device that is ready */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SII_NCMD
condition|;
name|i
operator|++
control|)
block|{
comment|/* don't restart a disconnected command */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_cmd
index|[
name|i
index|]
operator|||
name|sc
operator|->
name|sc_st
index|[
name|i
index|]
operator|.
name|prevComm
condition|)
continue|continue;
name|sii_StartCmd
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return;
name|abort
label|:
comment|/* jump here to abort the current command */
name|printf
argument_list|(
literal|"sii%d: device %d: current command terminated\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|sii_DumpLog
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|cstat
operator|=
name|regs
operator|->
name|cstat
operator|)
operator|&
name|SII_CON
condition|)
block|{
comment|/* try to send an abort msg for awhile */
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|regs
operator|->
name|data
operator|=
name|SCSI_ABORT
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
name|SII_ATN
operator||
operator|(
name|cstat
operator|&
name|SII_STATE_MSK
operator|)
operator||
name|SII_MSG_OUT_PHASE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
operator|(
name|dstat
operator|&
operator|(
name|SII_DNE
operator||
name|SII_PHASE_MSK
operator|)
operator|)
operator|==
operator|(
name|SII_DNE
operator||
name|SII_MSG_OUT_PHASE
operator|)
argument_list|,
literal|2
operator|*
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Abort: cs %x ds %x i %d\n"
argument_list|,
name|cstat
argument_list|,
name|dstat
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dstat
operator|&
operator|(
name|SII_DNE
operator||
name|SII_PHASE_MSK
operator|)
operator|==
operator|(
name|SII_DNE
operator||
name|SII_MSG_OUT_PHASE
operator|)
condition|)
block|{
comment|/* disconnect if command in progress */
name|regs
operator|->
name|comm
operator|=
name|SII_DISCON
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
name|cstat
argument_list|,
name|regs
operator|->
name|cstat
argument_list|,
operator|!
operator|(
name|cstat
operator|&
name|SII_CON
operator|)
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Abort: cs %x\n"
argument_list|,
name|cstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|regs
operator|->
name|cstat
operator|=
literal|0xffff
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
literal|0xffff
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
literal|0
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|i
operator|=
name|sc
operator|->
name|sc_target
expr_stmt|;
name|sc
operator|->
name|sc_target
operator|=
operator|-
literal|1
expr_stmt|;
name|sii_CmdDone
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"sii_DoIntr: after CmdDone target %d\n"
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sii_StateChg
parameter_list|(
name|sc
parameter_list|,
name|cstat
parameter_list|)
specifier|register
name|struct
name|siisoftc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|u_int
name|cstat
decl_stmt|;
block|{
specifier|register
name|SIIRegs
modifier|*
name|regs
init|=
name|sc
operator|->
name|sc_regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"SCH: "
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cstat
operator|&
name|SII_STATE_MSK
condition|)
block|{
case|case
literal|0
case|:
comment|/* disconnect */
name|i
operator|=
name|sc
operator|->
name|sc_target
expr_stmt|;
name|sc
operator|->
name|sc_target
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"disconn %d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
operator|!
name|sc
operator|->
name|sc_st
index|[
name|i
index|]
operator|.
name|prevComm
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: device %d: spurrious disconnect (%d)\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|i
argument_list|,
name|regs
operator|->
name|slcsr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_st
index|[
name|i
index|]
operator|.
name|prevComm
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|SII_CON
case|:
comment|/* connected as initiator */
name|i
operator|=
name|regs
operator|->
name|slcsr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_target
operator|==
name|i
condition|)
break|break;
name|printf
argument_list|(
literal|"sii%d: device %d: connect to device %d??\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_target
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|SII_DST
case|:
comment|/* 		 * Wait for CON to become valid, 		 * chip is slow sometimes. 		 */
name|SII_WAIT_UNTIL
argument_list|(
name|cstat
argument_list|,
name|regs
operator|->
name|cstat
argument_list|,
name|cstat
operator|&
name|SII_CON
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cstat
operator|&
name|SII_CON
operator|)
condition|)
name|panic
argument_list|(
literal|"sii resel"
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SII_CON
operator||
name|SII_DST
case|:
comment|/* 		 * Its a reselection. Save the ID and wait for 		 * interrupts to tell us what to do next 		 * (should be MSG_IN of IDENTIFY). 		 * NOTE: sc_target may be>= 0 if we were in 		 * the process of trying to start a command 		 * and were reselected before the select 		 * command finished. 		 */
name|sc
operator|->
name|sc_target
operator|=
name|i
operator|=
name|regs
operator|->
name|destat
expr_stmt|;
name|state
operator|=
operator|&
name|sc
operator|->
name|sc_st
index|[
name|i
index|]
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|SII_CON
operator||
name|SII_DST
operator||
name|SII_MSG_IN_PHASE
expr_stmt|;
name|regs
operator|->
name|dmctrl
operator|=
name|state
operator|->
name|dmaReqAck
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|prevComm
condition|)
block|{
name|printf
argument_list|(
literal|"sii%d: device %d: spurrious reselection\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|state
operator|->
name|prevComm
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"resel %d "
argument_list|,
name|sc
operator|->
name|sc_target
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|notyet
case|case
name|SII_DST
operator||
name|SII_TGT
case|:
case|case
name|SII_CON
operator||
name|SII_DST
operator||
name|SII_TGT
case|:
comment|/* connected as target */
name|printf
argument_list|(
literal|"sii%d: Selected by device %d as target!!\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|regs
operator|->
name|destat
argument_list|)
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|SII_DISCON
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|SII_WAIT_UNTIL
argument_list|(
operator|!
operator|(
name|regs
operator|->
name|cstat
operator|&
name|SII_CON
operator|)
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|regs
operator|->
name|cstat
operator|=
literal|0xffff
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
literal|0xffff
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"sii%d: Unknown state change (cs %x)!!\n"
argument_list|,
name|sc
operator|-
name|sii_softc
argument_list|,
name|cstat
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|sii_DumpLog
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Read one byte of data.  * If 'ack' is true, acknowledge the byte.  */
end_comment

begin_function
specifier|static
name|int
name|sii_GetByte
parameter_list|(
name|regs
parameter_list|,
name|phase
parameter_list|,
name|ack
parameter_list|)
specifier|register
name|SIIRegs
modifier|*
name|regs
decl_stmt|;
name|int
name|phase
decl_stmt|,
name|ack
decl_stmt|;
block|{
specifier|register
name|u_int
name|dstat
decl_stmt|;
specifier|register
name|u_int
name|state
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|data
decl_stmt|;
name|dstat
operator|=
name|regs
operator|->
name|dstat
expr_stmt|;
name|state
operator|=
name|regs
operator|->
name|cstat
operator|&
name|SII_STATE_MSK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dstat
operator|&
name|SII_IBF
operator|)
operator|||
operator|(
name|dstat
operator|&
name|SII_MIS
operator|)
condition|)
block|{
name|regs
operator|->
name|comm
operator|=
name|state
operator||
name|phase
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* wait a short time for IBF */
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_IBF
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
operator|(
name|dstat
operator|&
name|SII_IBF
operator|)
condition|)
name|printf
argument_list|(
literal|"status no IBF\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|dstat
operator|&
name|SII_DNE
condition|)
block|{
comment|/* XXX */
name|printf
argument_list|(
literal|"sii_GetByte: DNE set 5\n"
argument_list|)
expr_stmt|;
name|sii_DumpLog
argument_list|()
expr_stmt|;
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
block|}
name|data
operator|=
name|regs
operator|->
name|data
expr_stmt|;
comment|/* check for parity error */
if|if
condition|(
name|dstat
operator|&
name|SII_IPE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"cnt0 %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"sii_GetByte: data %x ?? ds %x cm %x i %d\n"
argument_list|,
name|data
argument_list|,
name|dstat
argument_list|,
name|regs
operator|->
name|comm
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* XXX */
name|data
operator|=
operator|-
literal|1
expr_stmt|;
name|ack
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ack
condition|)
block|{
name|regs
operator|->
name|comm
operator|=
name|SII_INXFER
operator||
name|state
operator||
name|phase
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* wait a short time for XFER complete */
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* clear the DNE */
if|if
condition|(
name|dstat
operator|&
name|SII_DNE
condition|)
block|{
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Exchange messages to initiate synchronous data transfers.  */
end_comment

begin_function
specifier|static
name|void
name|sii_DoSync
parameter_list|(
name|regs
parameter_list|,
name|state
parameter_list|)
specifier|register
name|SIIRegs
modifier|*
name|regs
decl_stmt|;
specifier|register
name|State
modifier|*
name|state
decl_stmt|;
block|{
specifier|register
name|u_int
name|dstat
decl_stmt|,
name|comm
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
condition|)
name|printf
argument_list|(
literal|"sii_DoSync: len %d per %d req/ack %d\n"
argument_list|,
name|sii_buf
index|[
literal|1
index|]
argument_list|,
name|sii_buf
index|[
literal|3
index|]
argument_list|,
name|sii_buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SII chip can only handle a minimum transfer period of ??? */
if|if
condition|(
name|sii_buf
index|[
literal|3
index|]
operator|<
literal|64
condition|)
name|sii_buf
index|[
literal|3
index|]
operator|=
literal|64
expr_stmt|;
comment|/* SII chip can only handle a maximum REQ/ACK offset of 3 */
name|len
operator|=
name|sii_buf
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|3
condition|)
name|len
operator|=
literal|3
expr_stmt|;
name|sii_buf
index|[
literal|0
index|]
operator|=
name|SCSI_EXTENDED_MSG
expr_stmt|;
name|sii_buf
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
comment|/* message length */
name|sii_buf
index|[
literal|2
index|]
operator|=
name|SCSI_SYNCHRONOUS_XFER
expr_stmt|;
name|sii_buf
index|[
literal|4
index|]
operator|=
name|len
expr_stmt|;
if|#
directive|if
literal|1
name|comm
operator|=
name|SII_INXFER
operator||
name|SII_ATN
operator||
name|SII_MSG_OUT_PHASE
operator||
operator|(
name|regs
operator|->
name|cstat
operator|&
name|SII_STATE_MSK
operator|)
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|comm
operator|&
operator|~
name|SII_INXFER
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|5
condition|;
name|j
operator|++
control|)
block|{
comment|/* wait for target to request the next byte */
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_TBE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dstat
operator|&
name|SII_TBE
operator|)
operator|||
operator|(
name|dstat
operator|&
name|SII_PHASE_MSK
operator|)
operator|!=
name|SII_MSG_OUT_PHASE
condition|)
block|{
name|printf
argument_list|(
literal|"sii_DoSync: TBE? ds %x cm %x i %d\n"
argument_list|,
name|dstat
argument_list|,
name|comm
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return;
block|}
comment|/* the last message byte should have ATN off */
if|if
condition|(
name|j
operator|==
literal|4
condition|)
name|comm
operator|&=
operator|~
name|SII_ATN
expr_stmt|;
name|regs
operator|->
name|data
operator|=
name|sii_buf
index|[
name|j
index|]
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|comm
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* wait a short time for XFER complete */
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|dstat
operator|&
name|SII_DNE
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dstat
operator|&
name|SII_DNE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sii_DoSync: DNE? ds %x cm %x i %d\n"
argument_list|,
name|dstat
argument_list|,
name|comm
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return;
block|}
comment|/* clear the DNE, other errors handled later */
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
name|CopyToBuffer
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|sii_buf
argument_list|,
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|SII_BUF_ADDR
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sii_DoSync: %x %x %x ds %x\n"
argument_list|,
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|SII_BUF_ADDR
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|SII_BUF_ADDR
operator|)
index|[
literal|2
index|]
argument_list|,
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|SII_BUF_ADDR
operator|)
index|[
literal|4
index|]
argument_list|,
name|regs
operator|->
name|dstat
argument_list|)
expr_stmt|;
comment|/* XXX */
name|regs
operator|->
name|dmaddrl
operator|=
call|(
name|u_short
call|)
argument_list|(
name|SII_BUF_ADDR
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|regs
operator|->
name|dmaddrh
operator|=
call|(
name|u_short
call|)
argument_list|(
name|SII_BUF_ADDR
operator|>>
literal|17
argument_list|)
operator|&
literal|03
expr_stmt|;
name|regs
operator|->
name|dmlotc
operator|=
literal|5
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|SII_DMA
operator||
name|SII_INXFER
operator||
name|SII_ATN
operator||
operator|(
name|regs
operator|->
name|cstat
operator|&
name|SII_STATE_MSK
operator|)
operator||
name|SII_MSG_OUT_PHASE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
comment|/* wait a short time for XFER complete */
name|SII_WAIT_UNTIL
argument_list|(
name|dstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
operator|(
name|dstat
operator|&
operator|(
name|SII_DNE
operator||
name|SII_TCZ
operator|)
operator|)
operator|==
operator|(
name|SII_DNE
operator||
name|SII_TCZ
operator|)
argument_list|,
name|SII_WAIT_COUNT
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dstat
operator|&
operator|(
name|SII_DNE
operator||
name|SII_TCZ
operator|)
operator|)
operator|!=
operator|(
name|SII_DNE
operator||
name|SII_TCZ
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sii_DoSync: ds %x cm %x i %d lotc %d\n"
argument_list|,
name|dstat
argument_list|,
name|regs
operator|->
name|comm
argument_list|,
name|i
argument_list|,
name|regs
operator|->
name|dmlotc
argument_list|)
expr_stmt|;
comment|/* XXX */
name|sii_DumpLog
argument_list|()
expr_stmt|;
comment|/* XXX */
return|return;
block|}
comment|/* clear the DNE, other errors handled later */
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|SII_WAIT_UNTIL(dstat, regs->dstat, dstat& (SII_CI | SII_DI), 		SII_WAIT_COUNT, i); 	printf("sii_DoSync: ds %x cm %x i %d lotc %d\n", 		dstat, regs->comm, i, regs->dmlotc);
comment|/* XXX */
endif|#
directive|endif
name|state
operator|->
name|dmaReqAck
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Issue the sequence of commands to the controller to start DMA.  * NOTE: the data buffer should be word-aligned for DMA out.  */
end_comment

begin_function
specifier|static
name|void
name|sii_StartDMA
parameter_list|(
name|regs
parameter_list|,
name|phase
parameter_list|,
name|dmaAddr
parameter_list|,
name|size
parameter_list|)
specifier|register
name|SIIRegs
modifier|*
name|regs
decl_stmt|;
comment|/* which SII to use */
name|int
name|phase
decl_stmt|;
comment|/* phase to send/receive data */
name|u_short
modifier|*
name|dmaAddr
decl_stmt|;
comment|/* DMA buffer address */
name|int
name|size
decl_stmt|;
comment|/* # of bytes to transfer */
block|{
if|if
condition|(
name|regs
operator|->
name|dstat
operator|&
name|SII_DNE
condition|)
block|{
comment|/* XXX */
name|regs
operator|->
name|dstat
operator|=
name|SII_DNE
expr_stmt|;
name|printf
argument_list|(
literal|"sii_StartDMA: DNE set\n"
argument_list|)
expr_stmt|;
name|sii_DumpLog
argument_list|()
expr_stmt|;
block|}
name|regs
operator|->
name|dmaddrl
operator|=
operator|(
operator|(
name|u_long
operator|)
name|dmaAddr
operator|>>
literal|1
operator|)
expr_stmt|;
name|regs
operator|->
name|dmaddrh
operator|=
operator|(
operator|(
name|u_long
operator|)
name|dmaAddr
operator|>>
literal|17
operator|)
operator|&
literal|03
expr_stmt|;
name|regs
operator|->
name|dmlotc
operator|=
name|size
expr_stmt|;
name|regs
operator|->
name|comm
operator|=
name|SII_DMA
operator||
name|SII_INXFER
operator||
operator|(
name|regs
operator|->
name|cstat
operator|&
name|SII_STATE_MSK
operator|)
operator||
name|phase
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"sii_StartDMA: cs 0x%x, ds 0x%x, cm 0x%x, size %d\n"
argument_list|,
name|regs
operator|->
name|cstat
argument_list|,
name|regs
operator|->
name|dstat
argument_list|,
name|regs
operator|->
name|comm
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Call the device driver's 'done' routine to let it know the command is done.  * The 'done' routine may try to start another command.  * To be fair, we should start pending commands for other devices  * before allowing the same device to start another command.  */
end_comment

begin_function
specifier|static
name|void
name|sii_CmdDone
parameter_list|(
name|sc
parameter_list|,
name|target
parameter_list|,
name|error
parameter_list|)
specifier|register
name|struct
name|siisoftc
modifier|*
name|sc
decl_stmt|;
comment|/* which SII to use */
name|int
name|target
decl_stmt|;
comment|/* which device is done */
name|int
name|error
decl_stmt|;
comment|/* error code if any errors */
block|{
specifier|register
name|ScsiCmd
modifier|*
name|scsicmd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|scsicmd
operator|=
name|sc
operator|->
name|sc_cmd
index|[
name|target
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|target
operator|<
literal|0
operator|||
operator|!
name|scsicmd
condition|)
name|panic
argument_list|(
literal|"sii_CmdDone"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_cmd
index|[
name|target
index|]
operator|=
operator|(
name|ScsiCmd
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sii_debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"sii_CmdDone: %s target %d cmd %x err %d resid %d\n"
argument_list|,
name|scsicmd
operator|->
name|sd
operator|->
name|sd_driver
operator|->
name|d_name
argument_list|,
name|target
argument_list|,
name|scsicmd
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|error
argument_list|,
name|sc
operator|->
name|sc_st
index|[
name|target
index|]
operator|.
name|buflen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* look for another device that is ready */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SII_NCMD
condition|;
name|i
operator|++
control|)
block|{
comment|/* don't restart a disconnected command */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_cmd
index|[
name|i
index|]
operator|||
name|sc
operator|->
name|sc_st
index|[
name|i
index|]
operator|.
name|prevComm
condition|)
continue|continue;
name|sii_StartCmd
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
call|(
modifier|*
name|scsicmd
operator|->
name|sd
operator|->
name|sd_driver
operator|->
name|d_done
call|)
argument_list|(
name|scsicmd
operator|->
name|unit
argument_list|,
name|error
argument_list|,
name|sc
operator|->
name|sc_st
index|[
name|target
index|]
operator|.
name|buflen
argument_list|,
name|sc
operator|->
name|sc_st
index|[
name|target
index|]
operator|.
name|statusByte
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|sii_DumpLog
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|sii_log
modifier|*
name|lp
decl_stmt|;
name|printf
argument_list|(
literal|"sii: cmd %x bn %d cnt %d\n"
argument_list|,
name|sii_debug_cmd
argument_list|,
name|sii_debug_bn
argument_list|,
name|sii_debug_sz
argument_list|)
expr_stmt|;
name|lp
operator|=
name|sii_logp
expr_stmt|;
do|do
block|{
name|printf
argument_list|(
literal|"target %d cs %x ds %x cm %x msg %x rlen %x dlen %x\n"
argument_list|,
name|lp
operator|->
name|target
argument_list|,
name|lp
operator|->
name|cstat
argument_list|,
name|lp
operator|->
name|dstat
argument_list|,
name|lp
operator|->
name|comm
argument_list|,
name|lp
operator|->
name|msg
argument_list|,
name|lp
operator|->
name|rlen
argument_list|,
name|lp
operator|->
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|lp
operator|>=
operator|&
name|sii_log
index|[
name|NLOG
index|]
condition|)
name|lp
operator|=
name|sii_log
expr_stmt|;
block|}
do|while
condition|(
name|lp
operator|!=
name|sii_logp
condition|)
do|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

