begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)ps.c	7.1 (Berkeley) 6/5/86  */
end_comment

begin_comment
comment|/*  * Evans and Sutherland Picture System 2 driver -- Bill Reeves.  */
end_comment

begin_comment
comment|/*  *	Still to be done:  *		WAIT_HIT  */
end_comment

begin_include
include|#
directive|include
file|"ps.h"
end_include

begin_if
if|#
directive|if
name|NPS
operator|>
literal|0
end_if

begin_define
define|#
directive|define
name|EXTERNAL_SYNC
end_define

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"ubareg.h"
end_include

begin_include
include|#
directive|include
file|"ubavar.h"
end_include

begin_include
include|#
directive|include
file|"psreg.h"
end_include

begin_decl_stmt
name|int
name|psprobe
argument_list|()
decl_stmt|,
name|psattach
argument_list|()
decl_stmt|,
name|psextsync
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|psclockintr
argument_list|()
decl_stmt|,
name|pssystemintr
argument_list|()
decl_stmt|,
name|psdeviceintr
argument_list|()
decl_stmt|,
name|psdmaintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|psdinfo
index|[
name|NPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|psstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|psdriver
init|=
block|{
name|psprobe
block|,
literal|0
block|,
name|psattach
block|,
literal|0
block|,
name|psstd
block|,
literal|"ps"
block|,
name|psdinfo
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PSUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev))
end_define

begin_define
define|#
directive|define
name|MAXAUTOREFRESH
value|4
end_define

begin_define
define|#
directive|define
name|MAXAUTOMAP
value|4
end_define

begin_define
define|#
directive|define
name|MAXDBSIZE
value|(0177777/2)
end_define

begin_define
define|#
directive|define
name|PSPRI
value|(PZERO+1)
end_define

begin_define
define|#
directive|define
name|PSWAIT
parameter_list|(
name|psaddr
parameter_list|)
value|{ \ 	register short i = 20000, j; \ 	while (i-- != 0&& ((j = psaddr->ps_iostat)& DIOREADY) == 0) \ 		;\ }
end_define

begin_struct
struct|struct
name|psrefresh
block|{
enum|enum
block|{
name|SINGLE_STEP_RF
block|,
name|AUTO_RF
block|,
name|TIME_RF
block|}
name|state
enum|;
enum|enum
block|{
name|RUNNING_RF
block|,
name|SYNCING_RF
block|,
name|WAITING_MAP
block|,
name|STOPPED_RF
block|}
name|mode
enum|;
name|u_short
name|sraddrs
index|[
name|MAXAUTOREFRESH
index|]
decl_stmt|;
name|short
name|nsraddrs
decl_stmt|;
name|short
name|srcntr
decl_stmt|;
name|char
name|waiting
decl_stmt|;
name|char
name|stop
decl_stmt|;
name|int
name|icnt
decl_stmt|;
name|int
name|timecnt
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|psdbuffer
block|{
enum|enum
block|{
name|ON_DB
block|,
name|OFF_DB
block|}
name|state
enum|;
name|u_short
name|dbaddrs
index|[
literal|2
index|]
decl_stmt|;
name|u_short
name|dbsize
decl_stmt|;
name|short
name|rbuffer
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|psmap
block|{
enum|enum
block|{
name|SINGLE_STEP_MAP
block|,
name|AUTO_MAP
block|}
name|state
enum|;
enum|enum
block|{
name|RUNNING_MAP
block|,
name|WAITING_RF
block|,
name|WAITING_START
block|,
name|STOPPED_MAP
block|}
name|mode
enum|;
name|u_short
name|maddrs
index|[
name|MAXAUTOMAP
index|]
decl_stmt|;
name|short
name|nmaddrs
decl_stmt|;
name|short
name|mcntr
decl_stmt|;
name|short
name|outputstart
decl_stmt|;
name|char
name|waiting
decl_stmt|;
name|char
name|stop
decl_stmt|;
name|int
name|icnt
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * PS2 software state.  */
end_comment

begin_struct
struct|struct
name|ps
block|{
name|char
name|ps_open
decl_stmt|;
comment|/* device is open */
name|uid_t
name|ps_uid
decl_stmt|;
comment|/* uid of device owner */
name|struct
name|psrefresh
name|ps_refresh
decl_stmt|;
comment|/* refresh state */
name|struct
name|psdbuffer
name|ps_dbuffer
decl_stmt|;
comment|/* double buffering state */
name|struct
name|psmap
name|ps_map
decl_stmt|;
comment|/* segment map state */
name|int
name|ps_clockticks
decl_stmt|;
comment|/* clock ints between refresh */
name|int
name|ps_clockmiss
decl_stmt|;
comment|/* clock ints w/o refresh */
name|int
name|ps_clockcnt
decl_stmt|;
comment|/* count of clock interrupts */
name|int
name|ps_hitcnt
decl_stmt|;
comment|/* count of hit interrupts */
name|int
name|ps_strayintr
decl_stmt|;
comment|/* count of stray interrupts */
name|int
name|ps_icnt
decl_stmt|;
comment|/* count of system interrupts */
comment|/* BEGIN GROT */
name|int
name|ps_lastrequest
decl_stmt|;
name|int
name|ps_lastrequest2
decl_stmt|;
name|int
name|ps_lastfunnyrequest
decl_stmt|;
name|int
name|ps_funnycnt
decl_stmt|;
comment|/* END GROT */
block|}
name|ps
index|[
name|NPS
index|]
struct|;
end_struct

begin_macro
name|psprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
specifier|register
name|struct
name|psdevice
modifier|*
name|psaddr
init|=
operator|(
expr|struct
name|psdevice
operator|*
operator|)
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|psclockintr
argument_list|(
operator|(
name|dev_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|pssystemintr
argument_list|(
operator|(
name|dev_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|psdeviceintr
argument_list|(
operator|(
name|dev_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|psdmaintr
argument_list|(
operator|(
name|dev_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|psextsync
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|psaddr
operator|->
name|ps_iostat
operator|=
name|PSRESET
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|RTCIE
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
literal|01
expr_stmt|;
name|psaddr
operator|->
name|ps_iostat
operator|=
name|PSIE
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|RTCSR
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
name|SYNC
operator||
name|RUN
expr_stmt|;
name|DELAY
argument_list|(
literal|200000
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|RTCREQ
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
literal|01
expr_stmt|;
name|psaddr
operator|->
name|ps_iostat
operator|=
literal|0
expr_stmt|;
name|psaddr
operator|->
name|ps_iostat
operator|=
name|PSRESET
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|psdevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|psattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{  }
end_block

begin_macro
name|psopen
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ps
modifier|*
name|psp
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|PSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NPS
operator|||
operator|(
name|psp
operator|=
operator|&
name|ps
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|)
operator|->
name|ps_open
operator|||
operator|(
name|ui
operator|=
name|psdinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|psp
operator|->
name|ps_open
operator|=
literal|1
expr_stmt|;
name|psp
operator|->
name|ps_uid
operator|=
name|u
operator|.
name|u_uid
expr_stmt|;
name|psp
operator|->
name|ps_strayintr
operator|=
literal|0
expr_stmt|;
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|=
name|SINGLE_STEP_RF
expr_stmt|;
name|psp
operator|->
name|ps_refresh
operator|.
name|mode
operator|=
name|STOPPED_RF
expr_stmt|;
name|psp
operator|->
name|ps_refresh
operator|.
name|waiting
operator|=
literal|0
expr_stmt|;
name|psp
operator|->
name|ps_refresh
operator|.
name|stop
operator|=
literal|0
expr_stmt|;
name|psp
operator|->
name|ps_dbuffer
operator|.
name|state
operator|=
name|OFF_DB
expr_stmt|;
name|psp
operator|->
name|ps_map
operator|.
name|state
operator|=
name|SINGLE_STEP_MAP
expr_stmt|;
name|psp
operator|->
name|ps_map
operator|.
name|mode
operator|=
name|STOPPED_MAP
expr_stmt|;
name|psp
operator|->
name|ps_map
operator|.
name|waiting
operator|=
literal|0
expr_stmt|;
name|psp
operator|->
name|ps_map
operator|.
name|stop
operator|=
literal|0
expr_stmt|;
name|psp
operator|->
name|ps_clockticks
operator|=
literal|0
expr_stmt|;
name|psp
operator|->
name|ps_clockmiss
operator|=
literal|0
expr_stmt|;
name|psp
operator|->
name|ps_refresh
operator|.
name|icnt
operator|=
name|psp
operator|->
name|ps_map
operator|.
name|icnt
operator|=
name|psp
operator|->
name|ps_clockcnt
operator|=
literal|0
expr_stmt|;
name|psp
operator|->
name|ps_hitcnt
operator|=
literal|0
expr_stmt|;
name|psp
operator|->
name|ps_icnt
operator|=
literal|0
expr_stmt|;
name|maptouser
argument_list|(
name|ui
operator|->
name|ui_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|psclose
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|psdevice
modifier|*
name|psaddr
init|=
operator|(
expr|struct
name|psdevice
operator|*
operator|)
name|psdinfo
index|[
name|PSUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|ui_addr
decl_stmt|;
name|ps
index|[
name|PSUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|ps_open
operator|=
literal|0
expr_stmt|;
name|psaddr
operator|->
name|ps_iostat
operator|=
literal|0
expr_stmt|;
comment|/* clear IENABLE */
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|RFSR
expr_stmt|;
comment|/* set in auto refresh mode */
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
name|AUTOREF
expr_stmt|;
name|unmaptouser
argument_list|(
operator|(
name|caddr_t
operator|)
name|psaddr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|psread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|pswrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|psioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
specifier|register
name|caddr_t
name|data
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|psdinfo
index|[
name|PSUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|ps
modifier|*
name|psp
init|=
operator|&
name|ps
index|[
name|PSUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
modifier|*
name|waddr
init|=
operator|*
operator|(
name|int
operator|*
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|n
decl_stmt|,
name|arg
decl_stmt|,
name|i
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PSIOGETADDR
case|:
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|data
operator|=
name|ui
operator|->
name|ui_addr
expr_stmt|;
break|break;
case|case
name|PSIOAUTOREFRESH
case|:
name|n
operator|=
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
name|waddr
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|MAXAUTOREFRESH
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|arg
operator|=
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
name|waddr
operator|++
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|psp
operator|->
name|ps_refresh
operator|.
name|sraddrs
index|[
name|i
index|]
operator|=
name|arg
expr_stmt|;
block|}
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|=
name|AUTO_RF
expr_stmt|;
name|psp
operator|->
name|ps_refresh
operator|.
name|nsraddrs
operator|=
name|n
expr_stmt|;
name|psp
operator|->
name|ps_refresh
operator|.
name|srcntr
operator|=
literal|0
expr_stmt|;
name|psp
operator|->
name|ps_refresh
operator|.
name|mode
operator|=
name|WAITING_MAP
expr_stmt|;
break|break;
case|case
name|PSIOAUTOMAP
case|:
name|n
operator|=
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
name|waddr
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|MAXAUTOMAP
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|arg
operator|=
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
name|waddr
operator|++
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|psp
operator|->
name|ps_map
operator|.
name|maddrs
index|[
name|i
index|]
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
name|waddr
operator|++
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|psp
operator|->
name|ps_map
operator|.
name|outputstart
operator|=
name|arg
expr_stmt|;
name|psp
operator|->
name|ps_map
operator|.
name|state
operator|=
name|AUTO_MAP
expr_stmt|;
name|psp
operator|->
name|ps_map
operator|.
name|nmaddrs
operator|=
name|n
expr_stmt|;
name|psp
operator|->
name|ps_map
operator|.
name|mcntr
operator|=
literal|0
expr_stmt|;
name|psp
operator|->
name|ps_map
operator|.
name|mode
operator|=
name|WAITING_START
expr_stmt|;
break|break;
case|case
name|PSIOSINGLEREFRESH
case|:
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|=
name|SINGLE_STEP_RF
expr_stmt|;
break|break;
case|case
name|PSIOSINGLEMAP
case|:
name|psp
operator|->
name|ps_map
operator|.
name|state
operator|=
name|SINGLE_STEP_MAP
expr_stmt|;
break|break;
case|case
name|PSIODOUBLEBUFFER
case|:
if|if
condition|(
operator|(
name|arg
operator|=
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
name|waddr
operator|++
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|psp
operator|->
name|ps_dbuffer
operator|.
name|dbaddrs
index|[
literal|0
index|]
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
name|waddr
operator|++
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|arg
operator|<=
literal|0
operator|||
name|arg
operator|>
name|MAXDBSIZE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|psp
operator|->
name|ps_dbuffer
operator|.
name|dbsize
operator|=
name|arg
expr_stmt|;
name|psp
operator|->
name|ps_dbuffer
operator|.
name|dbaddrs
index|[
literal|1
index|]
operator|=
name|psp
operator|->
name|ps_dbuffer
operator|.
name|dbaddrs
index|[
literal|0
index|]
operator|+
name|arg
expr_stmt|;
name|psp
operator|->
name|ps_dbuffer
operator|.
name|state
operator|=
name|ON_DB
expr_stmt|;
name|psp
operator|->
name|ps_dbuffer
operator|.
name|rbuffer
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PSIOSINGLEBUFFER
case|:
name|psp
operator|->
name|ps_dbuffer
operator|.
name|state
operator|=
name|OFF_DB
expr_stmt|;
break|break;
case|case
name|PSIOTIMEREFRESH
case|:
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|!=
name|SINGLE_STEP_RF
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|arg
operator|=
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
name|waddr
operator|++
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|=
name|TIME_RF
expr_stmt|;
name|psp
operator|->
name|ps_refresh
operator|.
name|timecnt
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|PSIOWAITREFRESH
case|:
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|mode
operator|!=
name|RUNNING_RF
condition|)
comment|/* not running */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* dont wait */
comment|/* fall into ... */
case|case
name|PSIOSTOPREFRESH
case|:
if|if
condition|(
name|cmd
operator|==
name|PSIOSTOPREFRESH
condition|)
block|{
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|mode
operator|==
name|STOPPED_RF
operator|&&
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|!=
name|TIME_RF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|psp
operator|->
name|ps_refresh
operator|.
name|stop
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|spl5
argument_list|()
expr_stmt|;
name|psp
operator|->
name|ps_refresh
operator|.
name|waiting
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|waiting
condition|)
name|sleep
argument_list|(
operator|&
name|psp
operator|->
name|ps_refresh
operator|.
name|waiting
argument_list|,
name|PSPRI
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|PSIOSTOPREFRESH
condition|)
name|psp
operator|->
name|ps_refresh
operator|.
name|mode
operator|=
name|STOPPED_RF
expr_stmt|;
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|==
name|TIME_RF
condition|)
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|=
name|SINGLE_STEP_RF
expr_stmt|;
break|break;
case|case
name|PSIOWAITMAP
case|:
if|if
condition|(
name|psp
operator|->
name|ps_map
operator|.
name|mode
operator|!=
name|RUNNING_MAP
condition|)
comment|/* not running */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* dont wait */
comment|/* fall into ... */
case|case
name|PSIOSTOPMAP
case|:
if|if
condition|(
name|cmd
operator|==
name|PSIOSTOPMAP
condition|)
name|psp
operator|->
name|ps_map
operator|.
name|stop
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|spl5
argument_list|()
expr_stmt|;
name|psp
operator|->
name|ps_map
operator|.
name|waiting
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|psp
operator|->
name|ps_map
operator|.
name|waiting
condition|)
name|sleep
argument_list|(
operator|&
name|psp
operator|->
name|ps_map
operator|.
name|waiting
argument_list|,
name|PSPRI
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|SAVEPSADDR
parameter_list|(
name|psaddr
parameter_list|,
name|savepsaddr
parameter_list|)
value|{ \ 	register short i, xx1; \ 	xx1 = splclock(); \ 	i = psaddr->ps_addr; \ 	while ((psaddr->ps_iostat& DIOREADY) == 0) \ 		; \ 	savepsaddr = psaddr->ps_data; \ 	splx(xx1); \ }
end_define

begin_define
define|#
directive|define
name|RESTORPSADDR
parameter_list|(
name|psaddr
parameter_list|,
name|savepsaddr
parameter_list|)
value|{ \ 	register short xx2; \ 	xx2 = splclock(); \ 	while ((psaddr->ps_iostat& DIOREADY) == 0) \ 		;\ 	psaddr->ps_addr = savepsaddr; \ 	splx(xx2); \ }
end_define

begin_macro
name|psclockintr
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|psdevice
modifier|*
name|psaddr
init|=
operator|(
expr|struct
name|psdevice
operator|*
operator|)
name|psdinfo
index|[
name|PSUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|ps
modifier|*
name|psp
init|=
operator|&
name|ps
index|[
name|PSUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|savepsaddr
decl_stmt|;
if|if
condition|(
operator|!
name|psp
operator|->
name|ps_open
condition|)
return|return;
name|psp
operator|->
name|ps_clockcnt
operator|++
expr_stmt|;
name|SAVEPSADDR
argument_list|(
name|psaddr
argument_list|,
name|savepsaddr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|EXTERNAL_SYNC
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|==
name|AUTO_RF
condition|)
block|{
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|mode
operator|==
name|SYNCING_RF
operator|&&
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|!=
name|TIME_RF
condition|)
block|{
operator|(
name|void
operator|)
name|psrfnext
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|psp
operator|->
name|ps_clockticks
operator|++
expr_stmt|;
name|psp
operator|->
name|ps_clockmiss
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|RTCREQ
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
literal|01
expr_stmt|;
comment|/* clear the request bits */
name|RESTORPSADDR
argument_list|(
name|psaddr
argument_list|,
name|savepsaddr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|pssystemintr
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|psdevice
modifier|*
name|psaddr
init|=
operator|(
expr|struct
name|psdevice
operator|*
operator|)
name|psdinfo
index|[
name|PSUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|ps
modifier|*
name|psp
init|=
operator|&
name|ps
index|[
name|PSUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|short
name|request
decl_stmt|,
name|tmp
decl_stmt|;
specifier|register
name|int
name|savepsaddr
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|psp
operator|->
name|ps_open
condition|)
return|return;
name|psp
operator|->
name|ps_icnt
operator|++
expr_stmt|;
name|SAVEPSADDR
argument_list|(
name|psaddr
argument_list|,
name|savepsaddr
argument_list|)
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|SYSREQ
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|request
operator|=
name|psaddr
operator|->
name|ps_data
expr_stmt|;
name|request
operator|=
name|request
operator|&
literal|0377
expr_stmt|;
name|psp
operator|->
name|ps_lastrequest2
operator|=
name|psp
operator|->
name|ps_lastrequest
expr_stmt|;
name|psp
operator|->
name|ps_lastrequest
operator|=
name|request
expr_stmt|;
if|if
condition|(
name|request
operator|&
operator|~
operator|(
name|HALT_REQ
operator||
name|RFSTOP_REQ
operator||
name|HIT_REQ
operator|)
condition|)
block|{
name|psp
operator|->
name|ps_lastfunnyrequest
operator|=
name|request
expr_stmt|;
name|psp
operator|->
name|ps_funnycnt
operator|++
expr_stmt|;
block|}
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|SYSREQ
expr_stmt|;
name|tmp
operator|=
name|request
operator|&
operator|(
operator|~
operator|(
name|HALT_REQ
operator||
name|MOSTOP_REQ
operator|)
operator|)
expr_stmt|;
comment|/* acknowledge */
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|request
operator|&
operator|(
name|MOSTOP_REQ
operator||
name|HALT_REQ
operator|)
condition|)
block|{
comment|/* Map stopped */
name|psp
operator|->
name|ps_map
operator|.
name|icnt
operator|++
expr_stmt|;
name|psmapstop
argument_list|(
name|psaddr
argument_list|,
name|psp
argument_list|,
name|request
argument_list|)
expr_stmt|;
comment|/* kill it dead */
if|if
condition|(
name|psp
operator|->
name|ps_map
operator|.
name|waiting
condition|)
block|{
name|psp
operator|->
name|ps_map
operator|.
name|waiting
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|psp
operator|->
name|ps_map
operator|.
name|waiting
argument_list|)
expr_stmt|;
if|if
condition|(
name|psp
operator|->
name|ps_map
operator|.
name|stop
condition|)
block|{
name|psp
operator|->
name|ps_map
operator|.
name|stop
operator|=
literal|0
expr_stmt|;
goto|goto
name|tryrf
goto|;
block|}
block|}
if|if
condition|(
name|psp
operator|->
name|ps_map
operator|.
name|state
operator|==
name|AUTO_MAP
operator|&&
operator|!
name|psmapnext
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
condition|)
block|{
name|psp
operator|->
name|ps_map
operator|.
name|mcntr
operator|=
literal|0
expr_stmt|;
comment|/* prepare for next round */
name|pssetmapbounds
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|==
name|AUTO_RF
condition|)
block|{
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|mode
operator|==
name|WAITING_MAP
condition|)
block|{
if|if
condition|(
name|psp
operator|->
name|ps_dbuffer
operator|.
name|state
operator|==
name|ON_DB
condition|)
comment|/* fill other db */
name|psdbswitch
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
else|else
name|psp
operator|->
name|ps_map
operator|.
name|mode
operator|=
name|WAITING_RF
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTERNAL_SYNC
name|x
operator|=
name|splclock
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|psrfnext
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTERNAL_SYNC
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|psp
operator|->
name|ps_map
operator|.
name|mode
operator|=
name|WAITING_RF
expr_stmt|;
block|}
else|else
block|{
comment|/* no auto refresh */
if|if
condition|(
name|psp
operator|->
name|ps_dbuffer
operator|.
name|state
operator|==
name|ON_DB
condition|)
comment|/* fill other db */
name|psdbswitch
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|psmapnext
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|tryrf
label|:
if|if
condition|(
name|request
operator|&
name|RFSTOP_REQ
condition|)
block|{
comment|/* Refresh stopped */
name|psp
operator|->
name|ps_refresh
operator|.
name|icnt
operator|++
expr_stmt|;
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|==
name|TIME_RF
condition|)
if|if
condition|(
operator|--
name|psp
operator|->
name|ps_refresh
operator|.
name|timecnt
operator|>
literal|0
condition|)
goto|goto
name|tryhit
goto|;
name|psrfstop
argument_list|(
name|psaddr
argument_list|,
name|psp
argument_list|)
expr_stmt|;
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|waiting
condition|)
block|{
name|psp
operator|->
name|ps_refresh
operator|.
name|waiting
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|psp
operator|->
name|ps_refresh
operator|.
name|waiting
argument_list|)
expr_stmt|;
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|stop
condition|)
block|{
name|psp
operator|->
name|ps_refresh
operator|.
name|stop
operator|=
literal|0
expr_stmt|;
goto|goto
name|tryhit
goto|;
block|}
block|}
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|==
name|AUTO_RF
condition|)
if|if
condition|(
operator|!
name|psrfnext
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
condition|)
block|{
comment|/* at end of refresh cycle */
if|if
condition|(
name|psp
operator|->
name|ps_map
operator|.
name|state
operator|==
name|AUTO_MAP
operator|&&
name|psp
operator|->
name|ps_map
operator|.
name|mode
operator|==
name|WAITING_RF
condition|)
block|{
if|if
condition|(
name|psp
operator|->
name|ps_dbuffer
operator|.
name|state
operator|==
name|ON_DB
condition|)
name|psdbswitch
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|psmapnext
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
block|}
name|psp
operator|->
name|ps_refresh
operator|.
name|srcntr
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTERNAL_SYNC
name|x
operator|=
name|splclock
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|psp
operator|->
name|ps_refresh
operator|.
name|mode
operator|=
name|SYNCING_RF
expr_stmt|;
if|if
condition|(
name|psp
operator|->
name|ps_clockticks
condition|)
operator|(
name|void
operator|)
name|psrfnext
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
name|psp
operator|->
name|ps_clockticks
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTERNAL_SYNC
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|tryhit
label|:
if|if
condition|(
name|request
operator|&
name|HIT_REQ
condition|)
comment|/* Hit request */
name|psp
operator|->
name|ps_hitcnt
operator|++
expr_stmt|;
if|if
condition|(
name|request
operator|==
literal|0
condition|)
name|psp
operator|->
name|ps_strayintr
operator|++
expr_stmt|;
name|RESTORPSADDR
argument_list|(
name|psaddr
argument_list|,
name|savepsaddr
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|psrfnext
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
specifier|register
expr|struct
name|ps
operator|*
name|psp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|psdevice
modifier|*
name|psaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_short
name|start
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|srcntr
operator|<
name|psp
operator|->
name|ps_refresh
operator|.
name|nsraddrs
condition|)
block|{
name|psrfstart
argument_list|(
name|psp
operator|->
name|ps_refresh
operator|.
name|sraddrs
index|[
name|psp
operator|->
name|ps_refresh
operator|.
name|srcntr
operator|++
index|]
argument_list|,
literal|0
argument_list|,
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|srcntr
operator|==
name|psp
operator|->
name|ps_refresh
operator|.
name|nsraddrs
operator|&&
name|psp
operator|->
name|ps_dbuffer
operator|.
name|state
operator|==
name|ON_DB
condition|)
block|{
name|start
operator|=
name|psp
operator|->
name|ps_dbuffer
operator|.
name|dbaddrs
index|[
name|psp
operator|->
name|ps_dbuffer
operator|.
name|rbuffer
index|]
expr_stmt|;
name|last
operator|=
name|start
operator|+
name|psp
operator|->
name|ps_dbuffer
operator|.
name|dbsize
expr_stmt|;
name|psrfstart
argument_list|(
name|start
argument_list|,
name|last
argument_list|,
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
name|psp
operator|->
name|ps_refresh
operator|.
name|srcntr
operator|++
expr_stmt|;
comment|/* flag for after dbuffer */
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|psrfstart
argument_list|(
argument|dfaddr
argument_list|,
argument|last
argument_list|,
argument|psp
argument_list|,
argument|psaddr
argument_list|)
end_macro

begin_decl_stmt
name|u_short
name|dfaddr
decl_stmt|,
name|last
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ps
modifier|*
name|psp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|psdevice
modifier|*
name|psaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|dummy
decl_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|RFASA
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
name|dfaddr
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|!=
literal|0
condition|)
name|psaddr
operator|->
name|ps_data
operator|=
name|last
expr_stmt|;
else|else
name|dummy
operator|=
name|psaddr
operator|->
name|ps_data
expr_stmt|;
comment|/* just access to get to status reg */
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
name|RFSTART
expr_stmt|;
comment|/* may want | here */
name|psp
operator|->
name|ps_refresh
operator|.
name|mode
operator|=
name|RUNNING_RF
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|psrfstop
argument_list|(
name|psaddr
argument_list|,
name|psp
argument_list|)
specifier|register
expr|struct
name|psdevice
operator|*
name|psaddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|ps
modifier|*
name|psp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|RFSR
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|psdbswitch
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
specifier|register
expr|struct
name|ps
operator|*
name|psp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|psdevice
modifier|*
name|psaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|psp
operator|->
name|ps_dbuffer
operator|.
name|rbuffer
operator|=
operator|!
name|psp
operator|->
name|ps_dbuffer
operator|.
name|rbuffer
expr_stmt|;
name|pssetmapbounds
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|psmapnext
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|psmapnext
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
specifier|register
expr|struct
name|ps
operator|*
name|psp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|psdevice
modifier|*
name|psaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|psp
operator|->
name|ps_map
operator|.
name|mcntr
operator|<
name|psp
operator|->
name|ps_map
operator|.
name|nmaddrs
condition|)
block|{
name|psmapstart
argument_list|(
name|psp
operator|->
name|ps_map
operator|.
name|maddrs
index|[
name|psp
operator|->
name|ps_map
operator|.
name|mcntr
operator|++
index|]
argument_list|,
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|pssetmapbounds
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
specifier|register
expr|struct
name|ps
operator|*
name|psp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|psdevice
modifier|*
name|psaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_short
name|start
decl_stmt|,
name|last
decl_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|MAOL
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|psp
operator|->
name|ps_dbuffer
operator|.
name|state
operator|==
name|ON_DB
condition|)
block|{
name|start
operator|=
name|psp
operator|->
name|ps_dbuffer
operator|.
name|dbaddrs
index|[
operator|!
name|psp
operator|->
name|ps_dbuffer
operator|.
name|rbuffer
index|]
expr_stmt|;
name|last
operator|=
name|start
operator|+
name|psp
operator|->
name|ps_dbuffer
operator|.
name|dbsize
operator|-
literal|2
expr_stmt|;
comment|/* 2 for halt cmd */
name|psaddr
operator|->
name|ps_data
operator|=
name|last
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
name|start
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|psaddr
operator|->
name|ps_data
expr_stmt|;
comment|/* dummy: don't update limit */
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
name|psp
operator|->
name|ps_map
operator|.
name|outputstart
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|psmapstart
argument_list|(
argument|dfaddr
argument_list|,
argument|psp
argument_list|,
argument|psaddr
argument_list|)
end_macro

begin_decl_stmt
name|u_short
name|dfaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ps
modifier|*
name|psp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|psdevice
modifier|*
name|psaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|MAIA
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
name|dfaddr
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
name|MAO
operator||
name|MAI
expr_stmt|;
comment|/* may want more here */
name|psp
operator|->
name|ps_map
operator|.
name|mode
operator|=
name|RUNNING_MAP
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|pskillcnt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|psmapstop
argument_list|(
name|psaddr
argument_list|,
name|psp
argument_list|,
name|request
argument_list|)
specifier|register
expr|struct
name|psdevice
operator|*
name|psaddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|ps
modifier|*
name|psp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|request
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|request
operator|&=
name|HALT_REQ
operator||
name|MOSTOP_REQ
expr_stmt|;
comment|/* overkill?? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pskillcnt
condition|;
name|i
operator|++
control|)
block|{
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|MASR
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
name|IOUT
expr_stmt|;
comment|/* zero MAI& MAO */
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|MAIA
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
literal|0
expr_stmt|;
comment|/* 0 input addr reg */
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|MAOA
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
literal|0
expr_stmt|;
comment|/* 0 output addr reg */
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_addr
operator|=
name|SYSREQ
expr_stmt|;
name|PSWAIT
argument_list|(
name|psaddr
argument_list|)
expr_stmt|;
name|psaddr
operator|->
name|ps_data
operator|=
name|request
expr_stmt|;
block|}
name|psp
operator|->
name|ps_map
operator|.
name|mode
operator|=
name|STOPPED_MAP
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|psdeviceintr
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"ps device intr\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|psdmaintr
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"ps dma intr\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|psreset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{  }
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|psextsync
argument_list|(
argument|PC
argument_list|,
argument|PS
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|psdevice
modifier|*
name|psaddr
decl_stmt|;
specifier|register
name|struct
name|ps
modifier|*
name|psp
decl_stmt|;
specifier|register
name|int
name|savepsaddr
decl_stmt|;
ifdef|#
directive|ifdef
name|EXTERNAL_SYNC
for|for
control|(
name|psp
operator|=
name|ps
operator|,
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NPS
condition|;
name|psp
operator|++
operator|,
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|psp
operator|->
name|ps_open
condition|)
continue|continue;
if|if
condition|(
name|psp
operator|->
name|ps_refresh
operator|.
name|mode
operator|==
name|SYNCING_RF
operator|&&
name|psp
operator|->
name|ps_refresh
operator|.
name|state
operator|!=
name|TIME_RF
condition|)
block|{
name|psaddr
operator|=
operator|(
expr|struct
name|psdevice
operator|*
operator|)
name|psdinfo
index|[
name|n
index|]
operator|->
name|ui_addr
expr_stmt|;
name|SAVEPSADDR
argument_list|(
name|psaddr
argument_list|,
name|savepsaddr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|psrfnext
argument_list|(
name|psp
argument_list|,
name|psaddr
argument_list|)
expr_stmt|;
name|RESTORPSADDR
argument_list|(
name|psaddr
argument_list|,
name|savepsaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|psp
operator|->
name|ps_clockticks
operator|++
expr_stmt|;
name|psp
operator|->
name|ps_clockmiss
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

