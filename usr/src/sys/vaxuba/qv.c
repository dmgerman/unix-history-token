begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  * 		@(#)qv.c	1.7  Berkeley  6/14/88  *  *	derived from: @(#)qv.c	1.8 (ULTRIX) 8/21/85  */
end_comment

begin_comment
comment|/************************************************************************  *									*  *			Copyright (c) 1985 by				*  *		Digital Equipment Corporation, Maynard, MA		*  *			All rights reserved.				*  *									*  *   This software is furnished under a license and may be used and	*  *   copied  only  in accordance with the terms of such license and	*  *   with the  inclusion  of  the  above  copyright  notice.   This	*  *   software  or  any  other copies thereof may not be provided or	*  *   otherwise made available to any other person.  No title to and	*  *   ownership of the software is hereby transferred.			*  *									*  *   This software is  derived  from  software  received  from  the	*  *   University    of   California,   Berkeley,   and   from   Bell	*  *   Laboratories.  Use, duplication, or disclosure is  subject  to	*  *   restrictions  under  license  agreements  with  University  of	*  *   California and with AT&T.						*  *									*  *   The information in this software is subject to change  without	*  *   notice  and should not be construed as a commitment by Digital	*  *   Equipment Corporation.						*  *									*  *   Digital assumes no responsibility for the use  or  reliability	*  *   of its software on equipment which is not supplied by Digital.	*  *									*  ************************************************************************  *  * This driver provides glass tty functionality to the qvss. It is a strange  * device in that it supports three subchannels. The first being the asr,  * the second being a channel that intercepts the chars headed for the screen  * ( like a pseudo tty ) and the third being a source of mouse state changes.  * NOTE: the second is conditional on #ifdef CONS_HACK in this version  * of the driver, as it's a total crock.  *  * There may be one and only one qvss in the system.  This restriction is based  * on the inability to map more than one at a time.  This restriction will  * exist until the kernel has shared memory services. This driver therefore  * support a single unit. No attempt was made to have it service more.  *  * (this belongs in sccs - not here)  *  * 02 Aug 85 -- rjl  *	Changed the names of the special setup routines so that the system  *	can have a qvss or a qdss system console.  *  * 03 Jul 85 -- rjl  *	Added a check for virtual mode in qvputc so that the driver  *	doesn't crash while in a dump which is done in physical mode.  *  * 10 Apr 85 -- jg  *	Well, our theory about keyboard handling was wrong; most of the   *	keyboard is in autorepeat, down mode.  These changes are to make  *	the qvss work the same as the Vs100, which is not necessarily  *	completely correct, as some chord usage may fail.  But since we  *	can't easily change the Vs100, we might as well propagate the  *	problem to another device.  There are also changes for screen and  *	mouse accellaration.  *  * 27 Mar 85 -- rjl  *	MicroVAX-II systems have interval timers that interrupt at ipl4.  *	Everything else is higher and thus causes us to miss clock ticks. The  *	problem isn't severe except in the case of a device like this one that  *	generates lots of interrupts. We aren't willing to make this change to  *	all device drivers but it seems acceptable in this case.  *  *  3 Dec 84 -- jg  *	To continue the tradition of building a better mouse trap,  this  * 	driver has been extended to form Vs100 style event queues.  If the  *	mouse device is open, the keyboard events are intercepted and put  *	into the shared memory queue.  Unfortunately, we are ending up with  *	one of the longest Unix device drivers.  Sigh....  *  * 20 Nov 84 -- rjl  *      As a further complication this driver is required to function as the  *      virtual system console. This code runs before and during auto-  *      configuration and therefore is require to have a second path for setup.  *      It is futher constrained to have a character output routine that  *      is not dependant on the interrupt system.  *  */
end_comment

begin_include
include|#
directive|include
file|"qv.h"
end_include

begin_if
if|#
directive|if
name|NQV
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"qvioctl.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"bk.h"
end_include

begin_include
include|#
directive|include
file|"clist.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"../machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../machine/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"ubareg.h"
end_include

begin_include
include|#
directive|include
file|"ubavar.h"
end_include

begin_define
define|#
directive|define
name|CONS_HACK
end_define

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|qvinfo
index|[
name|NQV
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tty
name|qv_tty
index|[
name|NQV
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|nNQV
value|NQV
end_define

begin_decl_stmt
name|int
name|nqv
init|=
name|NQV
operator|*
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Definition of the driver for the auto-configuration program.  */
end_comment

begin_decl_stmt
name|int
name|qvprobe
argument_list|()
decl_stmt|,
name|qvattach
argument_list|()
decl_stmt|,
name|qvkint
argument_list|()
decl_stmt|,
name|qvvint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|qvstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|qvdriver
init|=
block|{
name|qvprobe
block|,
literal|0
block|,
name|qvattach
block|,
literal|0
block|,
name|qvstd
block|,
literal|"qv"
block|,
name|qvinfo
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|qvmem
index|[]
index|[
literal|512
operator|*
name|NBPG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|pte
name|QVmap
index|[]
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local variables for the driver. Initialized for 15' screen  * so that it can be used during the boot process.  */
end_comment

begin_define
define|#
directive|define
name|QVWAITPRI
value|(PZERO+1)
end_define

begin_define
define|#
directive|define
name|QVSSMAJOR
value|40
end_define

begin_define
define|#
directive|define
name|QVKEYBOARD
value|0
end_define

begin_comment
comment|/* minor 0, keyboard/glass tty */
end_comment

begin_define
define|#
directive|define
name|QVPCONS
value|1
end_define

begin_comment
comment|/* minor 1, console interceptor XXX */
end_comment

begin_define
define|#
directive|define
name|QVMOUSECHAN
value|2
end_define

begin_comment
comment|/* minor 2, mouse */
end_comment

begin_define
define|#
directive|define
name|QVSPARE
value|3
end_define

begin_comment
comment|/* unused */
end_comment

begin_define
define|#
directive|define
name|QVCHAN
parameter_list|(
name|unit
parameter_list|)
value|((unit)& 03)
end_define

begin_comment
comment|/*  * v_putc is the switch that is used to redirect the console cnputc to the  * virtual console vputc.  consops is used to redirect the console  * device to the qvss console.  */
end_comment

begin_function_decl
specifier|extern
function_decl|(
modifier|*
name|v_putc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|cdevsw
modifier|*
name|consops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * qv_def_scrn is used to select the appropriate tables. 0=15 inch 1=19 inch,  * 2 = uVAXII.  */
end_comment

begin_decl_stmt
name|int
name|qv_def_scrn
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|QVMAXEVQ
value|64
end_define

begin_comment
comment|/* must be power of 2 */
end_comment

begin_define
define|#
directive|define
name|EVROUND
parameter_list|(
name|x
parameter_list|)
value|((x)& (QVMAXEVQ - 1))
end_define

begin_comment
comment|/*  * Screen parameters 15& 19 inch monitors. These determine the max size in  * pixel and character units for the display and cursor positions.  * Notice that the mouse defaults to original square algorithm, but X  * will change to its defaults once implemented.  */
end_comment

begin_decl_stmt
name|struct
name|qv_info
modifier|*
name|qv_scn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|qv_info
name|qv_scn_defaults
index|[]
init|=
block|{
block|{
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|30
block|,
literal|80
block|,
literal|768
block|,
literal|480
block|,
literal|768
operator|-
literal|16
block|,
literal|480
operator|-
literal|16
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|QVMAXEVQ
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|55
block|,
literal|120
block|,
literal|960
block|,
literal|864
block|,
literal|960
operator|-
literal|16
block|,
literal|864
operator|-
literal|16
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|QVMAXEVQ
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|56
block|,
literal|120
block|,
literal|1024
block|,
literal|864
block|,
literal|1024
operator|-
literal|16
block|,
literal|864
operator|-
literal|16
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|QVMAXEVQ
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|2
block|,
literal|4
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Screen controller initialization parameters. The definations and use  * of these parameters can be found in the Motorola 68045 crtc specs. In  * essence they set the display parameters for the chip. The first set is  * for the 15" screen and the second is for the 19" seperate sync. There  * is also a third set for a 19" composite sync monitor which we have not  * tested and which is not supported.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|qv_crt_parms
index|[]
index|[
literal|16
index|]
init|=
block|{
block|{
literal|31
block|,
literal|25
block|,
literal|27
block|,
literal|0142
block|,
literal|31
block|,
literal|13
block|,
literal|30
block|,
literal|31
block|,
literal|4
block|,
literal|15
block|,
literal|040
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* VR100*/
block|{
literal|39
block|,
literal|30
block|,
literal|32
block|,
literal|0262
block|,
literal|55
block|,
literal|5
block|,
literal|54
block|,
literal|54
block|,
literal|4
block|,
literal|15
block|,
literal|040
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* VR260*/
block|{
literal|39
block|,
literal|32
block|,
literal|33
block|,
literal|0264
block|,
literal|56
block|,
literal|5
block|,
literal|54
block|,
literal|54
block|,
literal|4
block|,
literal|15
block|,
literal|040
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Screen parameters  */
end_comment

begin_decl_stmt
name|struct
name|qv_info
modifier|*
name|qv_scn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxqvmem
init|=
literal|254
operator|*
literal|1024
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|qv_info
argument_list|)
operator|-
name|QVMAXEVQ
operator|*
sizeof|sizeof
argument_list|(
name|vsEvent
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keyboard state  */
end_comment

begin_struct
struct|struct
name|qv_keyboard
block|{
name|int
name|shift
decl_stmt|;
comment|/* state variables	*/
name|int
name|cntrl
decl_stmt|;
name|int
name|lock
decl_stmt|;
name|char
name|last
decl_stmt|;
comment|/* last character	*/
block|}
name|qv_keyboard
struct|;
end_struct

begin_decl_stmt
name|short
name|divdefaults
index|[
literal|15
index|]
init|=
block|{
name|LK_DOWN
block|,
comment|/* 0 doesn't exist */
name|LK_AUTODOWN
block|,
name|LK_AUTODOWN
block|,
name|LK_AUTODOWN
block|,
name|LK_DOWN
block|,
name|LK_UPDOWN
block|,
name|LK_UPDOWN
block|,
name|LK_AUTODOWN
block|,
name|LK_AUTODOWN
block|,
name|LK_AUTODOWN
block|,
name|LK_AUTODOWN
block|,
name|LK_AUTODOWN
block|,
name|LK_AUTODOWN
block|,
name|LK_DOWN
block|,
name|LK_AUTODOWN
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|kbdinitstring
index|[]
init|=
block|{
comment|/* reset any random keyboard stuff */
name|LK_AR_ENABLE
block|,
comment|/* we want autorepeat by default */
name|LK_CL_ENABLE
block|,
comment|/* keyclick */
literal|0x84
block|,
comment|/* keyclick volume */
name|LK_KBD_ENABLE
block|,
comment|/* the keyboard itself */
name|LK_BELL_ENABLE
block|,
comment|/* keyboard bell */
literal|0x84
block|,
comment|/* bell volume */
name|LK_LED_DISABLE
block|,
comment|/* keyboard leds */
name|LED_ALL
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KBD_INIT_LENGTH
value|sizeof(kbdinitstring)/sizeof(short)
end_define

begin_define
define|#
directive|define
name|TOY
value|((time.tv_sec * 100) + (time.tv_usec / 10000))
end_define

begin_decl_stmt
name|int
name|qv_ipl_lo
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IPL low flag			*/
end_comment

begin_decl_stmt
name|int
name|mouseon
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mouse channel is enabled when 1*/
end_comment

begin_decl_stmt
name|struct
name|proc
modifier|*
name|qvrsel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* process waiting for select */
end_comment

begin_decl_stmt
name|int
name|qvstart
argument_list|()
decl_stmt|,
name|qvputc
argument_list|()
decl_stmt|,
name|ttrstrt
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keyboard translation and font tables  */
end_comment

begin_decl_stmt
specifier|extern
name|u_short
name|q_key
index|[]
decl_stmt|,
name|q_shift_key
index|[]
decl_stmt|,
name|q_cursor
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|q_special
index|[]
decl_stmt|,
name|q_font
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * See if the qvss will interrupt.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|qvprobe
argument_list|(
argument|reg
argument_list|,
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* these are ``value-result'' */
specifier|register
name|struct
name|qvdevice
modifier|*
name|qvaddr
init|=
operator|(
expr|struct
name|qvdevice
operator|*
operator|)
name|reg
decl_stmt|;
specifier|static
name|int
name|tvec
decl_stmt|,
name|ovec
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|qvkint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|qvvint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate the next two vectors 	 */
name|tvec
operator|=
literal|0360
expr_stmt|;
name|ovec
operator|=
name|cvec
expr_stmt|;
comment|/* 	 * Turn on the keyboard and vertical interrupt vectors. 	 */
name|qvaddr
operator|->
name|qv_intcsr
operator|=
literal|0
expr_stmt|;
comment|/* init the interrupt controler */
name|qvaddr
operator|->
name|qv_intcsr
operator|=
literal|0x40
expr_stmt|;
comment|/* reset irr			*/
name|qvaddr
operator|->
name|qv_intcsr
operator|=
literal|0x80
expr_stmt|;
comment|/* specify individual vectors	*/
name|qvaddr
operator|->
name|qv_intcsr
operator|=
literal|0xc0
expr_stmt|;
comment|/* preset autoclear data	*/
name|qvaddr
operator|->
name|qv_intdata
operator|=
literal|0xff
expr_stmt|;
comment|/* all setup as autoclear	*/
name|qvaddr
operator|->
name|qv_intcsr
operator|=
literal|0xe0
expr_stmt|;
comment|/* preset vector address 1	*/
name|qvaddr
operator|->
name|qv_intdata
operator|=
name|tvec
expr_stmt|;
comment|/* give it the keyboard vector	*/
name|qvaddr
operator|->
name|qv_intcsr
operator|=
literal|0x28
expr_stmt|;
comment|/* enable tx/rx interrupt	*/
name|qvaddr
operator|->
name|qv_intcsr
operator|=
literal|0xe1
expr_stmt|;
comment|/* preset vector address 2	*/
name|qvaddr
operator|->
name|qv_intdata
operator|=
name|tvec
operator|+
literal|4
expr_stmt|;
comment|/* give it the vertical sysnc	*/
name|qvaddr
operator|->
name|qv_intcsr
operator|=
literal|0x29
expr_stmt|;
comment|/* enable 			*/
name|qvaddr
operator|->
name|qv_intcsr
operator|=
literal|0xa1
expr_stmt|;
comment|/* arm the interrupt ctrl	*/
name|qvaddr
operator|->
name|qv_uartcmd
operator|=
literal|0x15
expr_stmt|;
comment|/* set mode pntr/enable rx/tx	*/
name|qvaddr
operator|->
name|qv_uartmode
operator|=
literal|0x17
expr_stmt|;
comment|/* noparity, 8-bit		*/
name|qvaddr
operator|->
name|qv_uartmode
operator|=
literal|0x07
expr_stmt|;
comment|/* 1 stop bit			*/
name|qvaddr
operator|->
name|qv_uartstatus
operator|=
literal|0x99
expr_stmt|;
comment|/* 4800 baud xmit/recv 		*/
name|qvaddr
operator|->
name|qv_uartintstatus
operator|=
literal|2
expr_stmt|;
comment|/* enable recv interrupts	*/
name|qvaddr
operator|->
name|qv_csr
operator||=
name|QV_INT_ENABLE
operator||
name|QV_CUR_MODE
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|qvaddr
operator|->
name|qv_csr
operator|&=
operator|~
name|QV_INT_ENABLE
expr_stmt|;
comment|/* 	 * If the qvss did interrupt it was the second vector not 	 * the first so we have to return the first so that they 	 * will be setup properly 	 */
if|if
condition|(
name|ovec
operator|==
name|cvec
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
name|cvec
operator|-=
literal|4
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|qvdevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Routine called to attach a qv.  */
end_comment

begin_macro
name|qvattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*          * If not the console then we have to setup the screen          */
if|if
condition|(
name|v_putc
operator|!=
name|qvputc
operator|||
name|ui
operator|->
name|ui_unit
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|qv_setup
argument_list|(
operator|(
expr|struct
name|qvdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|qv_scn
operator|->
name|qvaddr
operator|=
operator|(
expr|struct
name|qvdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|qvopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|,
name|qv
decl_stmt|;
specifier|register
name|struct
name|qvdevice
modifier|*
name|qvaddr
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|qv_info
modifier|*
name|qp
init|=
name|qv_scn
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|qv
operator|=
name|unit
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|nqv
operator|||
operator|(
name|ui
operator|=
name|qvinfo
index|[
name|qv
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|QVCHAN
argument_list|(
name|unit
argument_list|)
operator|==
name|QVSPARE
ifndef|#
directive|ifndef
name|CONS_HACK
operator|||
name|QVCHAN
argument_list|(
name|unit
argument_list|)
operator|==
name|QVPCONS
endif|#
directive|endif
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|tp
operator|=
operator|&
name|qv_tty
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|u
operator|.
name|u_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|qvaddr
operator|=
operator|(
expr|struct
name|qvdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|qv_scn
operator|->
name|qvaddr
operator|=
name|qvaddr
expr_stmt|;
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
name|qvaddr
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|qvstart
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TS_ISOPEN
operator||
name|TS_CARR_ON
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|B9600
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|B9600
expr_stmt|;
if|if
condition|(
name|QVCHAN
argument_list|(
name|unit
argument_list|)
operator|==
name|QVKEYBOARD
condition|)
block|{
comment|/* make sure keyboard is always back to default */
name|qvkbdreset
argument_list|()
expr_stmt|;
name|qvaddr
operator|->
name|qv_csr
operator||=
name|QV_INT_ENABLE
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|=
name|XTABS
operator||
name|EVENP
operator||
name|ECHO
operator||
name|CRMOD
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|t_flags
operator|=
name|RAW
expr_stmt|;
block|}
comment|/* 	 * Process line discipline specific open if its not the 	 * mouse channel. For the mouse we init the ring ptr's. 	 */
if|if
condition|(
name|QVCHAN
argument_list|(
name|unit
argument_list|)
operator|!=
name|QVMOUSECHAN
condition|)
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
return|;
else|else
block|{
name|mouseon
operator|=
literal|1
expr_stmt|;
comment|/* set up event queue for later */
name|qp
operator|->
name|ibuff
operator|=
operator|(
name|vsEvent
operator|*
operator|)
name|qp
operator|-
name|QVMAXEVQ
expr_stmt|;
name|qp
operator|->
name|iqsize
operator|=
name|QVMAXEVQ
expr_stmt|;
name|qp
operator|->
name|ihead
operator|=
name|qp
operator|->
name|itail
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * Close a QVSS line.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|qvclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|unit
expr_stmt|;
specifier|register
name|struct
name|qvdevice
modifier|*
name|qvaddr
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|qv_tty
index|[
name|unit
index|]
expr_stmt|;
comment|/* 	 * If this is the keyboard unit (0) shutdown the 	 * interface. 	 */
name|qvaddr
operator|=
operator|(
expr|struct
name|qvdevice
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
if|if
condition|(
name|QVCHAN
argument_list|(
name|unit
argument_list|)
operator|==
name|QVKEYBOARD
condition|)
name|qvaddr
operator|->
name|qv_csr
operator|&=
operator|~
name|QV_INT_ENABLE
expr_stmt|;
comment|/* 	 * If unit is not the mouse channel call the line disc. 	 * otherwise clear the state flag, and put the keyboard into down/up. 	 */
if|if
condition|(
name|QVCHAN
argument_list|(
name|unit
argument_list|)
operator|!=
name|QVMOUSECHAN
condition|)
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mouseon
operator|=
literal|0
expr_stmt|;
name|qv_init
argument_list|(
name|qvaddr
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|qvread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|QVCHAN
argument_list|(
name|unit
argument_list|)
operator|!=
name|QVMOUSECHAN
condition|)
block|{
name|tp
operator|=
operator|&
name|qv_tty
index|[
name|unit
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_block

begin_macro
name|qvwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* 	 * If this is the mouse we simply fake the i/o, otherwise 	 * we let the line disp. handle it. 	 */
if|if
condition|(
name|QVCHAN
argument_list|(
name|unit
argument_list|)
operator|==
name|QVMOUSECHAN
condition|)
block|{
name|uio
operator|->
name|uio_offset
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tp
operator|=
operator|&
name|qv_tty
index|[
name|unit
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Mouse activity select routine  */
end_comment

begin_macro
name|qvselect
argument_list|(
argument|dev
argument_list|,
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|s
init|=
name|spl5
argument_list|()
decl_stmt|;
specifier|register
name|struct
name|qv_info
modifier|*
name|qp
init|=
name|qv_scn
decl_stmt|;
if|if
condition|(
name|QVCHAN
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|==
name|QVMOUSECHAN
condition|)
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
name|FREAD
case|:
comment|/* if events okay */
if|if
condition|(
name|qp
operator|->
name|ihead
operator|!=
name|qp
operator|->
name|itail
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|qvrsel
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
comment|/* can never write */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ttselect
argument_list|(
name|dev
argument_list|,
name|rw
argument_list|)
operator|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_block

begin_comment
comment|/*  * QVSS keyboard interrupt.  */
end_comment

begin_macro
name|qvkint
argument_list|(
argument|qv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|qv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|int
name|key
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|ui
operator|=
name|qvinfo
index|[
name|qv
index|]
expr_stmt|;
if|if
condition|(
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return;
name|tp
operator|=
operator|&
name|qv_tty
index|[
name|qv
operator|<<
literal|2
index|]
expr_stmt|;
comment|/* 	 * Get a character from the keyboard. 	 */
name|key
operator|=
operator|(
operator|(
expr|struct
name|qvdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
operator|)
operator|->
name|qv_uartdata
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|mouseon
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Check for various keyboard errors 		 */
if|if
condition|(
name|key
operator|==
name|LK_POWER_ERROR
operator|||
name|key
operator|==
name|LK_KDOWN_ERROR
operator|||
name|key
operator|==
name|LK_INPUT_ERROR
operator|||
name|key
operator|==
name|LK_OUTPUT_ERROR
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"qv%d: Keyboard error, code = %x\n"
argument_list|,
name|qv
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|key
operator|<
name|LK_LOWEST
condition|)
return|return;
comment|/* 		 * See if its a state change key 		 */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|LOCK
case|:
name|qv_keyboard
operator|.
name|lock
operator|^=
literal|0xffff
expr_stmt|;
comment|/* toggle */
if|if
condition|(
name|qv_keyboard
operator|.
name|lock
condition|)
name|qv_key_out
argument_list|(
name|LK_LED_ENABLE
argument_list|)
expr_stmt|;
else|else
name|qv_key_out
argument_list|(
name|LK_LED_DISABLE
argument_list|)
expr_stmt|;
name|qv_key_out
argument_list|(
name|LED_3
argument_list|)
expr_stmt|;
return|return;
case|case
name|SHIFT
case|:
name|qv_keyboard
operator|.
name|shift
operator|^=
literal|0xffff
expr_stmt|;
return|return;
case|case
name|CNTRL
case|:
name|qv_keyboard
operator|.
name|cntrl
operator|^=
literal|0xffff
expr_stmt|;
return|return;
case|case
name|ALLUP
case|:
name|qv_keyboard
operator|.
name|cntrl
operator|=
name|qv_keyboard
operator|.
name|shift
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|REPEAT
case|:
name|c
operator|=
name|qv_keyboard
operator|.
name|last
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Test for control characters. If set, see if the character 		 * is elligible to become a control character. 		 */
if|if
condition|(
name|qv_keyboard
operator|.
name|cntrl
condition|)
block|{
name|c
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|'~'
condition|)
name|c
operator|&=
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qv_keyboard
operator|.
name|lock
operator|||
name|qv_keyboard
operator|.
name|shift
condition|)
name|c
operator|=
name|q_shift_key
index|[
name|key
index|]
expr_stmt|;
else|else
name|c
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
break|break;
block|}
name|qv_keyboard
operator|.
name|last
operator|=
name|c
expr_stmt|;
comment|/* 		 * Check for special function keys 		 */
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
name|string
operator|=
name|q_special
index|[
name|c
operator|&
literal|0x7f
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|string
operator|++
operator|,
name|tp
operator|)
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|,
name|tp
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Mouse channel is open put it into the event queue 		 * instead. 		 */
specifier|register
name|struct
name|qv_info
modifier|*
name|qp
init|=
name|qv_scn
decl_stmt|;
specifier|register
name|vsEvent
modifier|*
name|vep
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|EVROUND
argument_list|(
name|qp
operator|->
name|itail
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|qp
operator|->
name|ihead
condition|)
return|return;
name|vep
operator|=
operator|&
name|qp
operator|->
name|ibuff
index|[
name|qp
operator|->
name|itail
index|]
expr_stmt|;
name|vep
operator|->
name|vse_direction
operator|=
name|VSE_KBTRAW
expr_stmt|;
name|vep
operator|->
name|vse_type
operator|=
name|VSE_BUTTON
expr_stmt|;
name|vep
operator|->
name|vse_device
operator|=
name|VSE_DKB
expr_stmt|;
name|vep
operator|->
name|vse_x
operator|=
name|qp
operator|->
name|mouse
operator|.
name|x
expr_stmt|;
name|vep
operator|->
name|vse_y
operator|=
name|qp
operator|->
name|mouse
operator|.
name|y
expr_stmt|;
name|vep
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
name|vep
operator|->
name|vse_key
operator|=
name|key
expr_stmt|;
name|qp
operator|->
name|itail
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|qvrsel
condition|)
block|{
name|selwakeup
argument_list|(
name|qvrsel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qvrsel
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Ioctl for QVSS.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|qvioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|qv_info
modifier|*
name|qp
init|=
name|qv_scn
decl_stmt|;
specifier|register
name|struct
name|qv_kpcmd
modifier|*
name|qk
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Check for and process qvss specific ioctl's 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|QIOCGINFO
case|:
comment|/* return screen info */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|qp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qv_info
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QIOCSMSTATE
case|:
comment|/* set mouse state */
name|qp
operator|->
name|mouse
operator|=
operator|*
operator|(
operator|(
name|vsCursor
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|qv_pos_cur
argument_list|(
name|qp
operator|->
name|mouse
operator|.
name|x
argument_list|,
name|qp
operator|->
name|mouse
operator|.
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
name|QIOCINIT
case|:
comment|/* init screen	*/
name|qv_init
argument_list|(
name|qp
operator|->
name|qvaddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|QIOCKPCMD
case|:
name|qk
operator|=
operator|(
expr|struct
name|qv_kpcmd
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|qk
operator|->
name|nbytes
operator|==
literal|0
condition|)
name|qk
operator|->
name|cmd
operator||=
literal|0200
expr_stmt|;
if|if
condition|(
name|mouseon
operator|==
literal|0
condition|)
name|qk
operator|->
name|cmd
operator||=
literal|1
expr_stmt|;
comment|/* no mode changes */
name|qv_key_out
argument_list|(
name|qk
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|qk
operator|->
name|par
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|qk
operator|->
name|nbytes
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* terminate parameters */
if|if
condition|(
name|qk
operator|->
name|nbytes
operator|<=
literal|0
condition|)
operator|*
name|cp
operator||=
literal|0200
expr_stmt|;
name|qv_key_out
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QIOCADDR
case|:
comment|/* get struct addr */
operator|*
operator|(
expr|struct
name|qv_info
operator|*
operator|*
operator|)
name|data
operator|=
name|qp
expr_stmt|;
break|break;
default|default:
comment|/* not ours ??  */
name|tp
operator|=
operator|&
name|qv_tty
index|[
name|unit
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Initialize the screen and the scanmap  */
end_comment

begin_macro
name|qv_init
argument_list|(
argument|qvaddr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|qvdevice
modifier|*
name|qvaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|scanline
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|short
name|scan
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|struct
name|qv_info
modifier|*
name|qp
init|=
name|qv_scn
decl_stmt|;
comment|/* 	 * Clear the bit map 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ptr
operator|=
name|qp
operator|->
name|bitmap
init|;
name|i
operator|<
literal|240
condition|;
name|i
operator|+=
literal|2
operator|,
name|ptr
operator|+=
literal|2048
control|)
name|bzero
argument_list|(
name|ptr
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
comment|/* 	 * Reinitialize the scanmap 	 */
name|scan
operator|=
name|qvaddr
operator|->
name|qv_csr
operator|&
name|QV_MEM_BANK
expr_stmt|;
name|scanline
operator|=
name|qp
operator|->
name|scanmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|max_y
condition|;
name|i
operator|++
control|)
operator|*
name|scanline
operator|++
operator|=
name|scan
operator|++
expr_stmt|;
comment|/* 	 * Home the cursor 	 */
name|qp
operator|->
name|row
operator|=
name|qp
operator|->
name|col
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Reset the cursor to the default type. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|qp
operator|->
name|cursorbits
index|[
name|i
index|]
operator|=
name|q_cursor
index|[
name|i
index|]
expr_stmt|;
name|qvaddr
operator|->
name|qv_csr
operator||=
name|QV_CUR_MODE
expr_stmt|;
comment|/* 	 * Reset keyboard to default state. 	 */
name|qvkbdreset
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|qvreset
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_macro
name|qvkbdreset
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|qv_key_out
argument_list|(
name|LK_DEFAULTS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
name|qv_key_out
argument_list|(
name|divdefaults
index|[
name|i
index|]
operator||
operator|(
name|i
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KBD_INIT_LENGTH
condition|;
name|i
operator|++
control|)
name|qv_key_out
argument_list|(
name|kbdinitstring
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|x
parameter_list|)
value|(((x)> 0) ? (x) : (-(x)))
end_define

begin_comment
comment|/*  * QVSS vertical sync interrupt  */
end_comment

begin_macro
name|qvvint
argument_list|(
argument|qv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|qv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|selwait
decl_stmt|;
specifier|register
name|struct
name|qvdevice
modifier|*
name|qvaddr
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|qv_info
modifier|*
name|qp
init|=
name|qv_scn
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp0
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
comment|/* 	 * Mouse state info 	 */
specifier|static
name|ushort
name|omouse
init|=
literal|0
decl_stmt|,
name|nmouse
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|omx
init|=
literal|0
decl_stmt|,
name|omy
init|=
literal|0
decl_stmt|,
name|mx
init|=
literal|0
decl_stmt|,
name|my
init|=
literal|0
decl_stmt|,
name|om_switch
init|=
literal|0
decl_stmt|,
name|m_switch
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
comment|/* 	 * Test and set the qv_ipl_lo flag. If the result is not zero then 	 * someone else must have already gotten here. 	 */
if|if
condition|(
operator|--
name|qv_ipl_lo
condition|)
return|return;
operator|(
name|void
operator|)
name|spl4
argument_list|()
expr_stmt|;
name|ui
operator|=
name|qvinfo
index|[
name|qv
index|]
expr_stmt|;
name|unit
operator|=
name|qv
operator|<<
literal|2
expr_stmt|;
name|qvaddr
operator|=
operator|(
expr|struct
name|qvdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|tp0
operator|=
operator|&
name|qv_tty
index|[
name|QVCHAN
argument_list|(
name|unit
argument_list|)
operator|+
name|QVMOUSECHAN
index|]
expr_stmt|;
comment|/* 	 * See if the mouse has moved. 	 */
if|if
condition|(
name|omouse
operator|!=
operator|(
name|nmouse
operator|=
name|qvaddr
operator|->
name|qv_mouse
operator|)
condition|)
block|{
name|omouse
operator|=
name|nmouse
expr_stmt|;
name|mx
operator|=
name|nmouse
operator|&
literal|0xff
expr_stmt|;
name|my
operator|=
name|nmouse
operator|>>
literal|8
expr_stmt|;
name|dy
operator|=
name|my
operator|-
name|omy
expr_stmt|;
name|omy
operator|=
name|my
expr_stmt|;
name|dx
operator|=
name|mx
operator|-
name|omx
expr_stmt|;
name|omx
operator|=
name|mx
expr_stmt|;
if|if
condition|(
name|dy
operator|<
literal|50
operator|&&
name|dy
operator|>
operator|-
literal|50
operator|&&
name|dx
operator|<
literal|50
operator|&&
name|dx
operator|>
operator|-
literal|50
condition|)
block|{
specifier|register
name|vsEvent
modifier|*
name|vep
decl_stmt|;
if|if
condition|(
name|qp
operator|->
name|mscale
operator|<
literal|0
condition|)
block|{
comment|/* Ray Lanza's original */
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
name|dy
operator|=
operator|-
operator|(
name|dy
operator|*
name|dy
operator|)
expr_stmt|;
else|else
name|dy
operator|*=
name|dy
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
name|dx
operator|=
operator|-
operator|(
name|dx
operator|*
name|dx
operator|)
expr_stmt|;
else|else
name|dx
operator|*=
name|dx
expr_stmt|;
block|}
else|else
block|{
comment|/* Vs100 style, see WGA spec */
name|int
name|thresh
init|=
name|qp
operator|->
name|mthreshold
decl_stmt|;
name|int
name|scale
init|=
name|qp
operator|->
name|mscale
decl_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|dx
argument_list|)
operator|>
name|thresh
condition|)
block|{
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
name|dx
operator|=
operator|(
name|dx
operator|+
name|thresh
operator|)
operator|*
name|scale
operator|-
name|thresh
expr_stmt|;
else|else
name|dx
operator|=
operator|(
name|dx
operator|-
name|thresh
operator|)
operator|*
name|scale
operator|+
name|thresh
expr_stmt|;
block|}
if|if
condition|(
name|abs
argument_list|(
name|dy
argument_list|)
operator|>
name|thresh
condition|)
block|{
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
name|dy
operator|=
operator|(
name|dy
operator|+
name|thresh
operator|)
operator|*
name|scale
operator|-
name|thresh
expr_stmt|;
else|else
name|dy
operator|=
operator|(
name|dy
operator|-
name|thresh
operator|)
operator|*
name|scale
operator|+
name|thresh
expr_stmt|;
block|}
block|}
name|qp
operator|->
name|mouse
operator|.
name|x
operator|+=
name|dx
expr_stmt|;
name|qp
operator|->
name|mouse
operator|.
name|y
operator|-=
name|dy
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|mouse
operator|.
name|x
operator|<
literal|0
condition|)
name|qp
operator|->
name|mouse
operator|.
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|mouse
operator|.
name|y
operator|<
literal|0
condition|)
name|qp
operator|->
name|mouse
operator|.
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|mouse
operator|.
name|x
operator|>
name|qp
operator|->
name|max_cur_x
condition|)
name|qp
operator|->
name|mouse
operator|.
name|x
operator|=
name|qp
operator|->
name|max_cur_x
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|mouse
operator|.
name|y
operator|>
name|qp
operator|->
name|max_cur_y
condition|)
name|qp
operator|->
name|mouse
operator|.
name|y
operator|=
name|qp
operator|->
name|max_cur_y
expr_stmt|;
if|if
condition|(
name|tp0
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
name|qv_pos_cur
argument_list|(
name|qp
operator|->
name|mouse
operator|.
name|x
argument_list|,
name|qp
operator|->
name|mouse
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|mouse
operator|.
name|y
operator|<
name|qp
operator|->
name|mbox
operator|.
name|bottom
operator|&&
name|qp
operator|->
name|mouse
operator|.
name|y
operator|>=
name|qp
operator|->
name|mbox
operator|.
name|top
operator|&&
name|qp
operator|->
name|mouse
operator|.
name|x
operator|<
name|qp
operator|->
name|mbox
operator|.
name|right
operator|&&
name|qp
operator|->
name|mouse
operator|.
name|x
operator|>=
name|qp
operator|->
name|mbox
operator|.
name|left
condition|)
goto|goto
name|switches
goto|;
name|qp
operator|->
name|mbox
operator|.
name|bottom
operator|=
literal|0
expr_stmt|;
comment|/* trash box */
if|if
condition|(
name|EVROUND
argument_list|(
name|qp
operator|->
name|itail
operator|+
literal|1
argument_list|)
operator|==
name|qp
operator|->
name|ihead
condition|)
goto|goto
name|switches
goto|;
name|i
operator|=
name|EVROUND
argument_list|(
name|qp
operator|->
name|itail
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|itail
operator|!=
name|qp
operator|->
name|ihead
operator|)
operator|&&
operator|(
name|i
operator|!=
name|qp
operator|->
name|ihead
operator|)
condition|)
block|{
name|vep
operator|=
operator|&
name|qp
operator|->
name|ibuff
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vep
operator|->
name|vse_type
operator|==
name|VSE_MMOTION
condition|)
block|{
name|vep
operator|->
name|vse_x
operator|=
name|qp
operator|->
name|mouse
operator|.
name|x
expr_stmt|;
name|vep
operator|->
name|vse_y
operator|=
name|qp
operator|->
name|mouse
operator|.
name|y
expr_stmt|;
goto|goto
name|switches
goto|;
block|}
block|}
comment|/* put event into queue and do select */
name|vep
operator|=
operator|&
name|qp
operator|->
name|ibuff
index|[
name|qp
operator|->
name|itail
index|]
expr_stmt|;
name|vep
operator|->
name|vse_type
operator|=
name|VSE_MMOTION
expr_stmt|;
name|vep
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
name|vep
operator|->
name|vse_x
operator|=
name|qp
operator|->
name|mouse
operator|.
name|x
expr_stmt|;
name|vep
operator|->
name|vse_y
operator|=
name|qp
operator|->
name|mouse
operator|.
name|y
expr_stmt|;
name|qp
operator|->
name|itail
operator|=
name|EVROUND
argument_list|(
name|qp
operator|->
name|itail
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * See if mouse switches have changed. 	 */
name|switches
label|:
if|if
condition|(
name|om_switch
operator|!=
operator|(
name|m_switch
operator|=
operator|(
name|qvaddr
operator|->
name|qv_csr
operator|&
name|QV_MOUSE_ANY
operator|)
operator|>>
literal|8
operator|)
condition|)
block|{
name|qp
operator|->
name|mswitches
operator|=
operator|~
name|m_switch
operator|&
literal|0x7
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
comment|/* check each switch */
specifier|register
name|vsEvent
modifier|*
name|vep
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|om_switch
operator|>>
name|j
operator|)
operator|&
literal|1
operator|)
operator|==
operator|(
operator|(
name|m_switch
operator|>>
name|j
operator|)
operator|&
literal|1
operator|)
condition|)
continue|continue;
comment|/* check for room in the queue */
if|if
condition|(
operator|(
name|i
operator|=
name|EVROUND
argument_list|(
name|qp
operator|->
name|itail
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|qp
operator|->
name|ihead
condition|)
return|return;
comment|/* put event into queue and do select */
name|vep
operator|=
operator|&
name|qp
operator|->
name|ibuff
index|[
name|qp
operator|->
name|itail
index|]
expr_stmt|;
name|vep
operator|->
name|vse_type
operator|=
name|VSE_BUTTON
expr_stmt|;
name|vep
operator|->
name|vse_key
operator|=
literal|2
operator|-
name|j
expr_stmt|;
name|vep
operator|->
name|vse_direction
operator|=
name|VSE_KBTDOWN
expr_stmt|;
if|if
condition|(
operator|(
name|m_switch
operator|>>
name|j
operator|)
operator|&
literal|1
condition|)
name|vep
operator|->
name|vse_direction
operator|=
name|VSE_KBTUP
expr_stmt|;
name|vep
operator|->
name|vse_device
operator|=
name|VSE_MOUSE
expr_stmt|;
name|vep
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
name|vep
operator|->
name|vse_x
operator|=
name|qp
operator|->
name|mouse
operator|.
name|x
expr_stmt|;
name|vep
operator|->
name|vse_y
operator|=
name|qp
operator|->
name|mouse
operator|.
name|y
expr_stmt|;
block|}
name|qp
operator|->
name|itail
operator|=
name|i
expr_stmt|;
name|om_switch
operator|=
name|m_switch
expr_stmt|;
name|qp
operator|->
name|mswitches
operator|=
name|m_switch
expr_stmt|;
block|}
comment|/* if we have proc waiting, and event has happened, wake him up */
if|if
condition|(
name|qvrsel
operator|&&
operator|(
name|qp
operator|->
name|ihead
operator|!=
name|qp
operator|->
name|itail
operator|)
condition|)
block|{
name|selwakeup
argument_list|(
name|qvrsel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qvrsel
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Okay we can take another hit now 	 */
name|qv_ipl_lo
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start  transmission  */
end_comment

begin_expr_stmt
name|qvstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONS_HACK
name|tp0
operator|=
operator|&
name|qv_tty
index|[
operator|(
name|unit
operator|&
literal|0xfc
operator|)
operator|+
name|QVPCONS
index|]
expr_stmt|;
endif|#
directive|endif
name|unit
operator|=
name|QVCHAN
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
comment|/* 	 * If it's currently active, or delaying, no need to do anything. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Display chars until the queue is empty, if the second subchannel 	 * is open direct them there. Drop characters from subchannels other 	 * than 0 on the floor. 	 */
while|while
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|QVKEYBOARD
condition|)
ifdef|#
directive|ifdef
name|CONS_HACK
if|if
condition|(
name|tp0
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
operator|(
operator|*
name|linesw
index|[
name|tp0
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|,
name|tp0
operator|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|qvputchar
argument_list|(
name|c
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Position the cursor to the next character location. 	 */
name|qv_pos_cur
argument_list|(
name|qv_scn
operator|->
name|col
operator|*
literal|8
argument_list|,
name|qv_scn
operator|->
name|row
operator|*
literal|15
argument_list|)
expr_stmt|;
comment|/* 	 * If there are sleepers, and output has drained below low 	 * water mark, wake up the sleepers. 	 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|TTLOWAT
argument_list|(
name|tp
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Stop output on a line, e.g. for ^S/^Q or output flush.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|qvstop
argument_list|(
name|tp
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|;
comment|/* 	 * Block input/output interrupts while messing with state. 	 */
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|qvputc
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|qvputchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|qvputchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Routine to display a character on the screen.  The model used is a   * glass tty.  It is assummed that the user will only use this emulation  * during system boot and that the screen will be eventually controlled  * by a window manager.  *  */
end_comment

begin_expr_stmt
name|qvputchar
argument_list|(
name|c
argument_list|)
specifier|register
name|char
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|b_row
decl_stmt|,
modifier|*
name|f_row
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|short
modifier|*
name|scanline
decl_stmt|;
specifier|register
name|int
name|ote
init|=
literal|128
decl_stmt|;
specifier|register
name|struct
name|qv_info
modifier|*
name|qp
init|=
name|qv_scn
decl_stmt|;
comment|/* 	 * This routine may be called in physical mode by the dump code 	 * so we check and punt if that's the case. 	 */
if|if
condition|(
operator|(
name|mfpr
argument_list|(
name|MAPEN
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return;
name|c
operator|&=
literal|0x7f
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
comment|/* tab		*/
for|for
control|(
name|i
operator|=
literal|8
operator|-
operator|(
name|qp
operator|->
name|col
operator|&
literal|0x7
operator|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|qvputchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
comment|/* return	*/
name|qp
operator|->
name|col
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\010'
case|:
comment|/* backspace	*/
if|if
condition|(
operator|--
name|qp
operator|->
name|col
operator|<
literal|0
condition|)
name|qp
operator|->
name|col
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
comment|/* linefeed	*/
if|if
condition|(
name|qp
operator|->
name|row
operator|+
literal|1
operator|>=
name|qp
operator|->
name|max_row
condition|)
name|qvscroll
argument_list|()
expr_stmt|;
else|else
name|qp
operator|->
name|row
operator|++
expr_stmt|;
comment|/* 		* Position the cursor to the next character location. 		*/
name|qv_pos_cur
argument_list|(
name|qp
operator|->
name|col
operator|*
literal|8
argument_list|,
name|qp
operator|->
name|row
operator|*
literal|15
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\007'
case|:
comment|/* bell		*/
comment|/*                  * We don't do anything to the keyboard until after                  * autoconfigure.                  */
if|if
condition|(
name|qp
operator|->
name|qvaddr
condition|)
name|qv_key_out
argument_list|(
name|LK_RING_BELL
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|'~'
condition|)
block|{
name|scanline
operator|=
name|qp
operator|->
name|scanmap
expr_stmt|;
name|b_row
operator|=
name|qp
operator|->
name|bitmap
operator|+
operator|(
name|scanline
index|[
name|qp
operator|->
name|row
operator|*
literal|15
index|]
operator|&
literal|0x3ff
operator|)
operator|*
literal|128
operator|+
name|qp
operator|->
name|col
expr_stmt|;
name|i
operator|=
name|c
operator|-
literal|' '
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|95
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|*=
literal|15
expr_stmt|;
name|f_row
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|q_font
operator|+
name|i
operator|)
expr_stmt|;
comment|/*			for( i=0 ; i<15 ; i++ , b_row += 128, f_row++ ) 				*b_row = *f_row;*/
comment|/* inline expansion for speed */
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
operator|*
name|b_row
operator|=
operator|*
name|f_row
operator|++
expr_stmt|;
name|b_row
operator|+=
name|ote
expr_stmt|;
if|if
condition|(
operator|++
name|qp
operator|->
name|col
operator|>=
name|qp
operator|->
name|max_col
condition|)
block|{
name|qp
operator|->
name|col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|row
operator|+
literal|1
operator|>=
name|qp
operator|->
name|max_row
condition|)
name|qvscroll
argument_list|()
expr_stmt|;
else|else
name|qp
operator|->
name|row
operator|++
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * Position the cursor to a particular spot.  */
end_comment

begin_expr_stmt
name|qv_pos_cur
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
specifier|register
name|int
name|x
operator|,
name|y
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|qvdevice
modifier|*
name|qvaddr
decl_stmt|;
specifier|register
name|struct
name|qv_info
modifier|*
name|qp
init|=
name|qv_scn
decl_stmt|;
specifier|register
name|index
expr_stmt|;
if|if
condition|(
name|qvaddr
operator|=
name|qp
operator|->
name|qvaddr
condition|)
block|{
if|if
condition|(
name|y
operator|<
literal|0
operator|||
name|y
operator|>
name|qp
operator|->
name|max_cur_y
condition|)
name|y
operator|=
name|qp
operator|->
name|max_cur_y
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>
name|qp
operator|->
name|max_cur_x
condition|)
name|x
operator|=
name|qp
operator|->
name|max_cur_x
expr_stmt|;
name|qp
operator|->
name|cursor
operator|.
name|x
operator|=
name|x
expr_stmt|;
comment|/* keep track of real cursor*/
name|qp
operator|->
name|cursor
operator|.
name|y
operator|=
name|y
expr_stmt|;
comment|/* position, indep. of mouse*/
name|qvaddr
operator|->
name|qv_crtaddr
operator|=
literal|10
expr_stmt|;
comment|/* select cursor start reg */
name|qvaddr
operator|->
name|qv_crtdata
operator|=
name|y
operator|&
literal|0xf
expr_stmt|;
name|qvaddr
operator|->
name|qv_crtaddr
operator|=
literal|11
expr_stmt|;
comment|/* select cursor end reg */
name|qvaddr
operator|->
name|qv_crtdata
operator|=
name|y
operator|&
literal|0xf
expr_stmt|;
name|qvaddr
operator|->
name|qv_crtaddr
operator|=
literal|14
expr_stmt|;
comment|/* select cursor y pos. */
name|qvaddr
operator|->
name|qv_crtdata
operator|=
name|y
operator|>>
literal|4
expr_stmt|;
name|qvaddr
operator|->
name|qv_xcur
operator|=
name|x
expr_stmt|;
comment|/* pos x axis	*/
comment|/* 		 * If the mouse is being used then we change the mode of 		 * cursor display based on the pixels under the cursor 		 */
if|if
condition|(
name|mouseon
condition|)
block|{
name|index
operator|=
name|y
operator|*
literal|128
operator|+
name|x
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|bitmap
index|[
name|index
index|]
operator|&&
name|qp
operator|->
name|bitmap
index|[
name|index
operator|+
literal|128
index|]
condition|)
name|qvaddr
operator|->
name|qv_csr
operator|&=
operator|~
name|QV_CUR_MODE
expr_stmt|;
else|else
name|qvaddr
operator|->
name|qv_csr
operator||=
name|QV_CUR_MODE
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Scroll the bitmap by moving the scanline map words. This could  * be done by moving the bitmap but it's much too slow for a full screen.  * The only drawback is that the scanline map must be reset when the user   * wants to do graphics.  */
end_comment

begin_macro
name|qvscroll
argument_list|()
end_macro

begin_block
block|{
name|short
name|tmpscanlines
index|[
literal|15
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|b_row
decl_stmt|;
specifier|register
name|short
modifier|*
name|scanline
decl_stmt|;
specifier|register
name|struct
name|qv_info
modifier|*
name|qp
init|=
name|qv_scn
decl_stmt|;
comment|/* 	 * If the mouse is on we don't scroll so that the bit map 	 * remains sane. 	 */
if|if
condition|(
name|mouseon
condition|)
block|{
name|qp
operator|->
name|row
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * Save the first 15 scanlines so that we can put them at 	 * the bottom when done. 	 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|qp
operator|->
name|scanmap
argument_list|,
operator|(
name|caddr_t
operator|)
name|tmpscanlines
argument_list|,
sizeof|sizeof
name|tmpscanlines
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the wrapping line so that it won't flash on the bottom 	 * of the screen. 	 */
name|scanline
operator|=
name|qp
operator|->
name|scanmap
expr_stmt|;
name|b_row
operator|=
name|qp
operator|->
name|bitmap
operator|+
operator|(
operator|*
name|scanline
operator|&
literal|0x3ff
operator|)
operator|*
literal|128
expr_stmt|;
name|bzero
argument_list|(
name|b_row
argument_list|,
literal|1920
argument_list|)
expr_stmt|;
comment|/* 	 * Now move the scanlines down  	 */
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|qp
operator|->
name|scanmap
operator|+
literal|15
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|qp
operator|->
name|scanmap
argument_list|,
operator|(
name|qp
operator|->
name|row
operator|*
literal|15
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now put the other lines back 	 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tmpscanlines
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|qp
operator|->
name|scanmap
operator|+
operator|(
name|qp
operator|->
name|row
operator|*
literal|15
operator|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpscanlines
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Output to the keyboard. This routine status polls the transmitter on the  * keyboard to output a code. The timer is to avoid hanging on a bad device.  */
end_comment

begin_macro
name|qv_key_out
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|u_short
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|timer
init|=
literal|30000
decl_stmt|;
specifier|register
name|struct
name|qv_info
modifier|*
name|qp
init|=
name|qv_scn
decl_stmt|;
if|if
condition|(
name|qp
operator|->
name|qvaddr
condition|)
block|{
while|while
condition|(
operator|(
name|qp
operator|->
name|qvaddr
operator|->
name|qv_uartstatus
operator|&
literal|0x4
operator|)
operator|==
literal|0
operator|&&
name|timer
operator|--
condition|)
empty_stmt|;
name|qp
operator|->
name|qvaddr
operator|->
name|qv_uartdata
operator|=
name|c
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Virtual console initialization. This routine sets up the qvss so that it can  * be used as the system console. It is invoked before autoconfig and has to do  * everything necessary to allow the device to serve as the system console.   * In this case it must map the q-bus and device areas and initialize the qvss   * screen.  */
end_comment

begin_macro
name|qvcons_init
argument_list|()
end_macro

begin_block
block|{
name|struct
name|percpu
modifier|*
name|pcpu
decl_stmt|;
comment|/* pointer to percpu structure  */
specifier|register
name|struct
name|qbus
modifier|*
name|qb
decl_stmt|;
name|struct
name|qvdevice
modifier|*
name|qvaddr
decl_stmt|;
comment|/* device pointer               */
name|short
modifier|*
name|devptr
decl_stmt|;
comment|/* virtual device space         */
extern|extern cnputc(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* standard serial console putc */
end_comment

begin_define
define|#
directive|define
name|QVSSCSR
value|017200
end_define

begin_comment
comment|/* 	 * If secondary console already configured, 	 * don't override the previous one. 	 */
end_comment

begin_if
if|if
condition|(
name|v_putc
operator|!=
name|cnputc
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|/*          * find the percpu entry that matches this machine.          */
end_comment

begin_for
for|for
control|(
name|pcpu
operator|=
name|percpu
init|;
name|pcpu
operator|&&
name|pcpu
operator|->
name|pc_cputype
operator|!=
name|cpu
condition|;
name|pcpu
operator|++
control|)
empty_stmt|;
end_for

begin_if
if|if
condition|(
name|pcpu
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|/*          * Found an entry for this cpu. Because this device is Microvax specific          * we assume that there is a single q-bus and don't have to worry about          * multiple adapters.          *          * Map the device registers.          */
end_comment

begin_expr_stmt
name|qb
operator|=
operator|(
expr|struct
name|qbus
operator|*
operator|)
name|pcpu
operator|->
name|pc_io
operator|->
name|io_details
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ioaccess
argument_list|(
name|qb
operator|->
name|qb_iopage
argument_list|,
name|UMEMmap
index|[
literal|0
index|]
operator|+
name|qb
operator|->
name|qb_memsize
argument_list|,
name|UBAIOPAGES
operator|*
name|NBPG
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*          * See if the qvss is there.          */
end_comment

begin_expr_stmt
name|devptr
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|umem
index|[
literal|0
index|]
operator|+
operator|(
name|qb
operator|->
name|qb_memsize
operator|*
name|NBPG
operator|)
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qvaddr
operator|=
operator|(
expr|struct
name|qvdevice
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|devptr
operator|+
name|ubdevreg
argument_list|(
name|QVSSCSR
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|qvaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|/*          * Okay the device is there lets set it up          */
end_comment

begin_if
if|if
condition|(
operator|!
name|qv_setup
argument_list|(
name|qvaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
end_if

begin_expr_stmt
name|v_putc
operator|=
name|qvputc
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|consops
operator|=
operator|&
name|cdevsw
index|[
name|QVSSMAJOR
index|]
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|1
return|;
end_return

begin_comment
unit|}
comment|/*  * Do the board specific setup  */
end_comment

begin_expr_stmt
unit|qv_setup
operator|(
name|qvaddr
operator|,
name|unit
operator|,
name|probed
operator|)
expr|struct
name|qvdevice
operator|*
name|qvaddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|probed
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|caddr_t
name|qvssmem
decl_stmt|;
comment|/* pointer to the display mem   */
specifier|register
name|i
expr_stmt|;
comment|/* simple index                 */
specifier|register
name|struct
name|qv_info
modifier|*
name|qp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pte
decl_stmt|;
name|struct
name|percpu
modifier|*
name|pcpu
decl_stmt|;
comment|/* pointer to percpu structure  */
specifier|register
name|struct
name|qbus
modifier|*
name|qb
decl_stmt|;
comment|/*          * find the percpu entry that matches this machine.          */
for|for
control|(
name|pcpu
operator|=
name|percpu
init|;
name|pcpu
operator|&&
name|pcpu
operator|->
name|pc_cputype
operator|!=
name|cpu
condition|;
name|pcpu
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|pcpu
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*          * Found an entry for this cpu. Because this device is Microvax specific          * we assume that there is a single q-bus and don't have to worry about          * multiple adapters.          *          * Map the device memory.          */
name|qb
operator|=
operator|(
expr|struct
name|qbus
operator|*
operator|)
name|pcpu
operator|->
name|pc_io
operator|->
name|io_details
expr_stmt|;
name|i
operator|=
call|(
name|u_int
call|)
argument_list|(
name|qvaddr
operator|->
name|qv_csr
operator|&
name|QV_MEM_BANK
argument_list|)
operator|<<
literal|7
expr_stmt|;
name|ioaccess
argument_list|(
name|qb
operator|->
name|qb_maddr
operator|+
name|i
argument_list|,
name|QVmap
index|[
name|unit
index|]
argument_list|,
literal|512
operator|*
name|NBPG
argument_list|)
expr_stmt|;
name|qvssmem
operator|=
name|qvmem
index|[
name|unit
index|]
expr_stmt|;
name|pte
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
name|unit
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
operator|,
name|pte
operator|++
control|)
operator|*
name|pte
operator|=
operator|(
operator|*
name|pte
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|qv_scn
operator|=
operator|(
expr|struct
name|qv_info
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|qvssmem
operator|+
literal|251
operator|*
literal|1024
operator|)
expr_stmt|;
name|qp
operator|=
name|qv_scn
expr_stmt|;
if|if
condition|(
operator|(
name|qvaddr
operator|->
name|qv_csr
operator|&
name|QV_19INCH
operator|)
operator|&&
name|qv_def_scrn
operator|==
literal|0
condition|)
name|qv_def_scrn
operator|=
literal|1
expr_stmt|;
operator|*
name|qv_scn
operator|=
name|qv_scn_defaults
index|[
name|qv_def_scrn
index|]
expr_stmt|;
if|if
condition|(
name|probed
condition|)
name|qp
operator|->
name|qvaddr
operator|=
name|qvaddr
expr_stmt|;
name|qp
operator|->
name|bitmap
operator|=
name|qvssmem
expr_stmt|;
name|qp
operator|->
name|scanmap
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|qvssmem
operator|+
literal|254
operator|*
literal|1024
operator|)
expr_stmt|;
name|qp
operator|->
name|cursorbits
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|qvssmem
operator|+
literal|256
operator|*
literal|1024
operator|-
literal|32
operator|)
expr_stmt|;
comment|/* set up event queue for later */
name|qp
operator|->
name|ibuff
operator|=
operator|(
name|vsEvent
operator|*
operator|)
name|qp
operator|-
name|QVMAXEVQ
expr_stmt|;
name|qp
operator|->
name|iqsize
operator|=
name|QVMAXEVQ
expr_stmt|;
name|qp
operator|->
name|ihead
operator|=
name|qp
operator|->
name|itail
operator|=
literal|0
expr_stmt|;
comment|/*          * Setup the crt controller chip.          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|qvaddr
operator|->
name|qv_crtaddr
operator|=
name|i
expr_stmt|;
name|qvaddr
operator|->
name|qv_crtdata
operator|=
name|qv_crt_parms
index|[
name|qv_def_scrn
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/*          * Setup the display.          */
name|qv_init
argument_list|(
name|qvaddr
argument_list|)
expr_stmt|;
comment|/*          * Turn on the video          */
name|qvaddr
operator|->
name|qv_csr
operator||=
name|QV_VIDEO_ENA
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

