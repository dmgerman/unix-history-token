begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)spp_usrreq.c	6.6 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/tcp_fsm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/tcp_timer.h"
end_include

begin_include
include|#
directive|include
file|"ns.h"
end_include

begin_include
include|#
directive|include
file|"ns_pcb.h"
end_include

begin_include
include|#
directive|include
file|"idp.h"
end_include

begin_include
include|#
directive|include
file|"idp_var.h"
end_include

begin_include
include|#
directive|include
file|"ns_error.h"
end_include

begin_include
include|#
directive|include
file|"sp.h"
end_include

begin_include
include|#
directive|include
file|"spidp.h"
end_include

begin_include
include|#
directive|include
file|"spp_var.h"
end_include

begin_include
include|#
directive|include
file|"spp_debug.h"
end_include

begin_comment
comment|/*  * SP protocol implementation.  */
end_comment

begin_macro
name|spp_init
argument_list|()
end_macro

begin_block
block|{
name|spp_iss
operator|=
literal|1
expr_stmt|;
comment|/* WRONG !! should fish it out of TODR */
block|}
end_block

begin_decl_stmt
name|struct
name|spidp
name|spp_savesi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|traceallspps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sppconsdebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|spp_hardnosed
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|spp_input
argument_list|(
name|m
argument_list|,
name|nsp
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|struct
name|spidp
modifier|*
name|si
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|len
decl_stmt|;
name|short
name|ostate
decl_stmt|;
name|int
name|dropsocket
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nsp
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"No nspcb in spp_input\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cb
operator|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|spp_istat
operator|.
name|hdrops
operator|++
expr_stmt|;
return|return;
block|}
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
block|}
name|si
operator|->
name|si_seq
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_ack
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_alo
argument_list|)
expr_stmt|;
name|so
operator|=
name|nsp
operator|->
name|nsp_socket
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
block|{
name|ostate
operator|=
name|cb
operator|->
name|s_state
expr_stmt|;
name|spp_savesi
operator|=
operator|*
name|si
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
name|so
operator|=
name|sonewconn
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
literal|0
condition|)
block|{
name|spp_istat
operator|.
name|nonucn
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* 		 * This is ugly, but .... 		 * 		 * Mark socket as temporary until we're 		 * committed to keeping it.  The code at 		 * ``drop'' and ``dropwithreset'' check the 		 * flag dropsocket to see if the temporary 		 * socket created here should be discarded. 		 * We mark the socket as discardable until 		 * we're committed to it below in TCPS_LISTEN. 		 */
name|dropsocket
operator|++
expr_stmt|;
name|nsp
operator|=
operator|(
expr|struct
name|nspcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|nsp
operator|->
name|nsp_laddr
operator|=
name|si
operator|->
name|si_dna
expr_stmt|;
name|cb
operator|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
block|}
comment|/* 	 * Packet received on connection. 	 * reset idle time and keep-alive timer; 	 */
name|cb
operator|->
name|s_idle
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_KEEP
index|]
operator|=
name|TCPTV_KEEP
expr_stmt|;
switch|switch
condition|(
name|cb
operator|->
name|s_state
condition|)
block|{
case|case
name|TCPS_LISTEN
case|:
block|{
name|struct
name|mbuf
modifier|*
name|am
decl_stmt|;
specifier|register
name|struct
name|sockaddr_ns
modifier|*
name|sns
decl_stmt|;
name|struct
name|ns_addr
name|laddr
decl_stmt|;
comment|/* 		 * If somebody here was carying on a conversation 		 * and went away, and his pen pal thinks he can 		 * still talk, we get the misdirected packet. 		 */
if|if
condition|(
name|spp_hardnosed
operator|&&
operator|(
name|si
operator|->
name|si_did
operator|!=
literal|0
operator|||
name|si
operator|->
name|si_seq
operator|!=
literal|0
operator|)
condition|)
block|{
name|spp_istat
operator|.
name|gonawy
operator|++
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
name|am
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|==
name|NULL
condition|)
goto|goto
name|drop
goto|;
name|am
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ns
argument_list|)
expr_stmt|;
name|sns
operator|=
name|mtod
argument_list|(
name|am
argument_list|,
expr|struct
name|sockaddr_ns
operator|*
argument_list|)
expr_stmt|;
name|sns
operator|->
name|sns_family
operator|=
name|AF_NS
expr_stmt|;
name|sns
operator|->
name|sns_addr
operator|=
name|si
operator|->
name|si_sna
expr_stmt|;
name|laddr
operator|=
name|nsp
operator|->
name|nsp_laddr
expr_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
name|laddr
argument_list|)
condition|)
name|nsp
operator|->
name|nsp_laddr
operator|=
name|si
operator|->
name|si_dna
expr_stmt|;
if|if
condition|(
name|ns_pcbconnect
argument_list|(
name|nsp
argument_list|,
name|am
argument_list|)
condition|)
block|{
name|nsp
operator|->
name|nsp_laddr
operator|=
name|laddr
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
name|spp_istat
operator|.
name|noconn
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_SYN_RECEIVED
expr_stmt|;
name|spp_template
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_did
operator|=
name|si
operator|->
name|si_sid
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_AK
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_KEEP
index|]
operator|=
name|TCPTV_KEEP
expr_stmt|;
name|dropsocket
operator|=
literal|0
expr_stmt|;
comment|/* committed to socket */
block|}
break|break;
comment|/* 	 * This state means that we have gotten a response 	 * to our attempt to establish a connection. 	 * We fill in the data from the other side, 	 * telling us which port to respond to, instead of the well- 	 * known one we might have sent to in the first place. 	 * We also require that this is a response to our 	 * connection id. 	 */
case|case
name|TCPS_SYN_SENT
case|:
if|if
condition|(
name|si
operator|->
name|si_did
operator|!=
name|cb
operator|->
name|s_sid
condition|)
block|{
name|spp_istat
operator|.
name|notme
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|cb
operator|->
name|s_did
operator|=
name|si
operator|->
name|si_sid
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
name|cb
operator|->
name|s_dport
operator|=
name|nsp
operator|->
name|nsp_fport
operator|=
name|si
operator|->
name|si_sport
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_AK
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
break|break;
comment|/* 	 * This state means that we have heard a response 	 * to our acceptance of their connection 	 * It is probably logically unnecessary in this 	 * implementation. 	 */
case|case
name|TCPS_SYN_RECEIVED
case|:
if|if
condition|(
name|si
operator|->
name|si_did
operator|!=
name|cb
operator|->
name|s_sid
condition|)
block|{
name|spp_istat
operator|.
name|wrncon
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|nsp
operator|->
name|nsp_fport
operator|=
name|si
operator|->
name|si_sport
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_KEEP
index|]
operator|=
name|TCPTV_KEEP
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_INPUT
argument_list|,
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spp_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|idp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|idp
argument_list|)
expr_stmt|;
if|if
condition|(
name|spp_reass
argument_list|(
name|cb
argument_list|,
name|si
argument_list|)
condition|)
block|{
goto|goto
name|drop
goto|;
block|}
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
name|dropwithreset
label|:
if|if
condition|(
name|dropsocket
condition|)
operator|(
name|void
operator|)
name|soabort
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_seq
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_ack
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_alo
argument_list|)
expr_stmt|;
name|ns_error
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|,
name|NS_ERR_NOSOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_DROP
argument_list|,
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spp_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
name|drop
label|:
name|bad
label|:
if|if
condition|(
name|cb
operator|==
literal|0
operator|||
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_DROP
argument_list|,
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spp_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This is structurally similar to the tcp reassembly routine  * but its function is somewhat different:  It merely queues  * packets up, and suppresses duplicates.  */
end_comment

begin_expr_stmt
name|spp_reass
argument_list|(
name|cb
argument_list|,
name|si
argument_list|)
specifier|register
expr|struct
name|sppcb
operator|*
name|cb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|spidp
modifier|*
name|si
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|spidp_q
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
operator|(
name|so
operator|->
name|so_rcv
operator|)
decl_stmt|;
name|char
name|packetp
init|=
name|cb
operator|->
name|s_flags
operator|&
name|SF_HI
decl_stmt|;
name|char
name|wakeup
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|si
operator|==
name|SI
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|present
goto|;
comment|/* 	 * Update our news from them. 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SA
condition|)
name|cb
operator|->
name|s_flags
operator||=
name|SF_DELACK
expr_stmt|;
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
name|cb
operator|->
name|s_rack
argument_list|)
condition|)
block|{
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If transmit timer is running and timed sequence 		 * number was acked, update smoothed round trip time. 		 */
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|&&
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
name|cb
operator|->
name|s_rtseq
argument_list|)
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_srtt
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_srtt
operator|=
name|cb
operator|->
name|s_rtt
expr_stmt|;
else|else
name|cb
operator|->
name|s_srtt
operator|=
name|tcp_alpha
operator|*
name|cb
operator|->
name|s_srtt
operator|+
operator|(
literal|1
operator|-
name|tcp_alpha
operator|)
operator|*
name|cb
operator|->
name|s_rtt
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_alo
argument_list|,
name|cb
operator|->
name|s_ralo
argument_list|)
condition|)
block|{
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_PERSIST
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If this is a system packet, we don't need to 	 * queue it up, and won't update acknowledge # 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SP
condition|)
block|{
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If this packet number has a sequence number less 	 * than that of the first packet not yet seen coming 	 * from them, this must be a duplicate, so drop. 	 */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_ack
argument_list|)
condition|)
block|{
name|spp_istat
operator|.
name|bdreas
operator|++
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_ack
operator|-
literal|1
condition|)
name|spp_istat
operator|.
name|lstdup
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If this packet number is higher than that which 	 * we have allocated refuse it, unless urgent 	 */
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_alo
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SP_OB
operator|)
operator|)
condition|)
block|{
name|spp_istat
operator|.
name|notyet
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If this packet is urgent, inform process 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SP_OB
condition|)
block|{
name|cb
operator|->
name|s_iobc
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|si
operator|)
index|[
literal|1
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
index|]
expr_stmt|;
name|sohasoutofband
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Loop through all packets queued up to insert in 	 * appropriate sequence. 	 */
for|for
control|(
name|q
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
init|;
name|q
operator|!=
operator|&
name|cb
operator|->
name|s_q
condition|;
name|q
operator|=
name|q
operator|->
name|si_next
control|)
block|{
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/*duplicate */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
argument_list|)
condition|)
break|break;
block|}
name|insque
argument_list|(
name|si
argument_list|,
name|q
operator|->
name|si_prev
argument_list|)
expr_stmt|;
name|present
label|:
define|#
directive|define
name|SPINC
value|sizeof(struct sphdr)
comment|/* 	 * Loop through all packets queued up to update acknowledge 	 * number, and present all acknowledged data to user; 	 * If in packet interface mode, show packet headers. 	 */
for|for
control|(
name|q
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
init|;
name|q
operator|!=
operator|&
name|cb
operator|->
name|s_q
condition|;
name|q
operator|=
name|q
operator|->
name|si_next
control|)
block|{
if|if
condition|(
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_ack
condition|)
block|{
name|cb
operator|->
name|s_ack
operator|++
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_cc
operator|&
name|SP_OB
condition|)
block|{
if|if
condition|(
name|sb
operator|->
name|sb_cc
condition|)
name|so
operator|->
name|so_oobmark
operator|=
name|sb
operator|->
name|sb_cc
expr_stmt|;
else|else
name|so
operator|->
name|so_state
operator||=
name|SS_RCVATMARK
expr_stmt|;
block|}
name|q
operator|=
name|q
operator|->
name|si_prev
expr_stmt|;
name|remque
argument_list|(
name|q
operator|->
name|si_next
argument_list|)
expr_stmt|;
name|wakeup
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|packetp
condition|)
block|{
name|sbappendrecord
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|s_rhdr
operator|=
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|+=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|SPINC
expr_stmt|;
name|sbappend
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|wakeup
condition|)
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|spp_ctlinput
argument_list|(
argument|cmd
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ns_addr
modifier|*
name|na
decl_stmt|;
specifier|extern
name|u_char
name|nsctlerrmap
index|[]
decl_stmt|;
extern|extern spp_abort(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|ns_errp
modifier|*
name|errp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|cmd
operator|<
literal|0
operator|||
name|cmd
operator|>
name|PRC_NCMDS
condition|)
return|return;
end_if

begin_expr_stmt
name|type
operator|=
name|NS_ERR_UNREACH_HOST
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_ROUTEDEAD
case|:
case|case
name|PRC_QUENCH
case|:
break|break;
case|case
name|PRC_IFDOWN
case|:
name|na
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_ns
operator|*
operator|)
name|arg
operator|)
operator|->
name|sns_addr
expr_stmt|;
break|break;
case|case
name|PRC_HOSTDEAD
case|:
case|case
name|PRC_HOSTUNREACH
case|:
name|na
operator|=
operator|(
expr|struct
name|ns_addr
operator|*
operator|)
name|arg
expr_stmt|;
break|break;
default|default:
name|errp
operator|=
operator|(
expr|struct
name|ns_errp
operator|*
operator|)
name|arg
expr_stmt|;
name|na
operator|=
operator|&
name|errp
operator|->
name|ns_err_idp
operator|.
name|idp_dna
expr_stmt|;
name|type
operator|=
name|errp
operator|->
name|ns_err_num
expr_stmt|;
name|type
operator|=
name|ntohs
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|NS_ERR_UNREACH_HOST
case|:
name|ns_pcbnotify
argument_list|(
name|na
argument_list|,
operator|(
name|int
operator|)
name|nsctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|spp_abort
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_ERR_TOO_BIG
case|:
case|case
name|NS_ERR_NOSOCK
case|:
name|nsp
operator|=
name|ns_pcblookup
argument_list|(
name|na
argument_list|,
name|errp
operator|->
name|ns_err_idp
operator|.
name|idp_sna
operator|.
name|x_port
argument_list|,
name|NS_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsp
condition|)
block|{
if|if
condition|(
name|nsp
operator|->
name|nsp_pcb
condition|)
name|spp_drop
argument_list|(
name|nsp
operator|->
name|nsp_pcb
argument_list|,
operator|(
name|int
operator|)
name|nsctlerrmap
index|[
name|cmd
index|]
argument_list|)
expr_stmt|;
else|else
name|idp_drop
argument_list|(
name|nsp
argument_list|,
operator|(
name|int
operator|)
name|nsctlerrmap
index|[
name|cmd
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_switch

begin_expr_stmt
unit|}  int
name|spp_fixmtu
argument_list|(
name|nsp
argument_list|)
specifier|register
expr|struct
name|nspcb
operator|*
name|nsp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
init|=
operator|(
expr|struct
name|sppcb
operator|*
operator|)
operator|(
name|nsp
operator|->
name|nsp_pcb
operator|)
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|spidp
modifier|*
name|si
decl_stmt|;
name|struct
name|ns_errp
modifier|*
name|ep
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|badseq
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|firstbad
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
if|if
condition|(
name|cb
condition|)
block|{
comment|/*  		 * The notification that we have sent 		 * too much is bad news -- we will 		 * have to go through queued up so far 		 * splitting ones which are too big and 		 * reassigning sequence numbers and checksums. 		 * we should then retransmit all packets from 		 * one above the offending packet to the last one 		 * we had sent (or our allocation) 		 * then the offending one so that the any queued 		 * data at our destination will be discarded. 		 */
name|ep
operator|=
operator|(
expr|struct
name|ns_errp
operator|*
operator|)
name|nsp
operator|->
name|nsp_notify_param
expr_stmt|;
name|sb
operator|=
operator|&
name|nsp
operator|->
name|nsp_socket
operator|->
name|so_snd
expr_stmt|;
name|cb
operator|->
name|s_mtu
operator|=
name|ep
operator|->
name|ns_err_param
expr_stmt|;
name|badseq
operator|=
name|SI
argument_list|(
operator|&
name|ep
operator|->
name|ns_err_idp
argument_list|)
operator|->
name|si_seq
expr_stmt|;
for|for
control|(
name|m
operator|=
name|sb
operator|->
name|sb_mb
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_act
control|)
block|{
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|badseq
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|firstbad
operator|=
name|m
expr_stmt|;
comment|/*for (;;) {*/
comment|/* calculate length */
for|for
control|(
name|m0
operator|=
name|m
operator|,
name|len
operator|=
literal|0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|cb
operator|->
name|s_mtu
condition|)
block|{ 			}
comment|/* FINISH THIS 		} */
block|}
block|}
end_block

begin_decl_stmt
name|int
name|spp_output_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|spp_output
argument_list|(
name|cb
argument_list|,
name|m0
argument_list|)
specifier|register
expr|struct
name|sppcb
operator|*
name|cb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|spidp
modifier|*
name|si
init|=
operator|(
expr|struct
name|spidp
operator|*
operator|)
literal|0
decl_stmt|;
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
operator|(
name|so
operator|->
name|so_snd
operator|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|debit
decl_stmt|,
name|mtu
init|=
name|cb
operator|->
name|s_mtu
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_short
name|lookfor
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mprev
decl_stmt|;
specifier|extern
name|int
name|idpcksum
decl_stmt|;
if|if
condition|(
name|m0
condition|)
block|{
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|mprev
operator|=
name|m
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|mtu
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
else|else
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
name|mtu
condition|)
block|{
name|m
operator|=
name|m_copy
argument_list|(
name|m0
argument_list|,
name|off
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|m_adj
argument_list|(
name|m0
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|len
operator|-=
name|mtu
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|len
operator|&
literal|1
condition|)
block|{
name|m
operator|=
name|mprev
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|+
name|m
operator|->
name|m_off
operator|<
name|MMAXOFF
condition|)
block|{
name|m
operator|->
name|m_len
operator|++
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m1
init|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
decl_stmt|;
if|if
condition|(
name|m1
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m1
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
name|m1
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
literal|1
expr_stmt|;
name|mprev
operator|->
name|m_next
operator|=
name|m1
expr_stmt|;
block|}
block|}
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 		 * Fill in mbuf with extended SP header 		 * and addresses and length put into network format. 		 */
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
operator|*
name|si
operator|=
name|cb
operator|->
name|s_shdr
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
operator|)
operator|&&
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_HO
operator|)
condition|)
block|{
specifier|register
name|struct
name|sphdr
modifier|*
name|sh
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
decl_stmt|;
name|si
operator|->
name|si_dt
operator|=
name|sh
operator|->
name|sp_dt
expr_stmt|;
name|si
operator|->
name|si_cc
operator||=
name|sh
operator|->
name|sp_cc
operator|&
name|SP_EM
expr_stmt|;
name|m0
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_off
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
block|}
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_SOOB
condition|)
block|{
comment|/* 			 * Per jqj@cornell: 			 * make sure OB packets convey exactly 1 byte. 			 * If the packet is 1 byte or larger, we 			 * have already guaranted there to be at least 			 * one garbage byte for the checksum, and 			 * extra bytes shouldn't hurt! 			 *  			 */
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
condition|)
block|{
name|si
operator|->
name|si_cc
operator||=
name|SP_OB
expr_stmt|;
name|len
operator|=
operator|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
name|si
operator|->
name|si_len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* 		 * queue stuff up for output 		 */
name|sbappendrecord
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_seq
operator|++
expr_stmt|;
block|}
name|output
label|:
comment|/* 	 * update window 	 */
block|{
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_rcv
decl_stmt|;
name|int
name|credit
init|=
operator|(
operator|(
name|sb
operator|->
name|sb_mbmax
operator|-
name|sb
operator|->
name|sb_mbcnt
operator|)
operator|/
name|cb
operator|->
name|s_mtu
operator|)
decl_stmt|;
name|int
name|alo
init|=
name|cb
operator|->
name|s_ack
operator|+
name|credit
decl_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_alo
operator|<
name|alo
condition|)
name|cb
operator|->
name|s_alo
operator|=
name|alo
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_SOOB
condition|)
block|{
comment|/* 		 * must transmit this out of band packet 		 */
name|cb
operator|->
name|s_oobflags
operator|&=
operator|~
name|SF_SOOB
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Decide what to transmit: 		 * If we have a new packet, send that 		 * (So long as it is in our allocation) 		 * If it is time to retransmit a packet, 		 * send that. 		 * Otherwise, see if it time to bang on them 		 * to ask for our current allocation. 		 */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_snt
argument_list|,
name|cb
operator|->
name|s_ralo
argument_list|)
condition|)
name|lookfor
operator|=
name|cb
operator|->
name|s_snt
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cb
operator|->
name|s_force
operator|==
operator|(
literal|1
operator|+
name|TCPT_REXMT
operator|)
condition|)
block|{
name|lookfor
operator|=
name|cb
operator|->
name|s_rack
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_ralo
argument_list|,
name|cb
operator|->
name|s_seq
argument_list|)
condition|)
block|{
name|lookfor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_PERSIST
index|]
operator|==
literal|0
condition|)
block|{
name|spp_setpersist
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
block|}
name|m
operator|=
name|sb
operator|->
name|sb_mb
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_act
expr_stmt|;
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_rack
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_WAIT
operator|)
operator|||
name|so
operator|->
name|so_snd
operator|.
name|sb_sel
condition|)
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sbdroprecord
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|si
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|lookfor
argument_list|)
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|si
operator|&&
operator|(
name|si
operator|->
name|si_seq
operator|!=
name|lookfor
operator|)
condition|)
name|si
operator|=
literal|0
expr_stmt|;
block|}
name|cb
operator|->
name|s_want
operator|=
name|lookfor
expr_stmt|;
if|if
condition|(
name|si
condition|)
block|{
comment|/* 		 * must make a copy of this packet for 		 * idp_output to monkey with 		 */
name|m
operator|=
name|dtom
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m0
operator|=
name|m
expr_stmt|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|s_force
operator|||
name|cb
operator|->
name|s_flags
operator|&
name|SF_AK
condition|)
block|{
comment|/* 		 * Must send an acknowledgement or a probe 		 */
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 		 * Fill in mbuf with extended SP header 		 * and addresses and length put into network format. 		 */
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
operator|*
name|si
operator|=
name|cb
operator|->
name|s_shdr
expr_stmt|;
name|si
operator|->
name|si_seq
operator|=
name|cb
operator|->
name|s_snt
operator|+
literal|1
expr_stmt|;
name|si
operator|->
name|si_len
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_cc
operator||=
name|SP_SP
expr_stmt|;
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|SF_AK
expr_stmt|;
block|}
comment|/* 	 * Stuff checksum and output datagram. 	 */
if|if
condition|(
name|si
condition|)
block|{
comment|/* 		 * If we are almost out of allocation 		 * or one of the timers has gone off 		 * request an ack. 		 */
if|if
condition|(
name|SSEQ_GEQ
argument_list|(
name|cb
operator|->
name|s_seq
argument_list|,
name|cb
operator|->
name|s_ralo
argument_list|)
condition|)
name|si
operator|->
name|si_cc
operator||=
name|SP_SA
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_force
condition|)
block|{
name|si
operator|->
name|si_cc
operator||=
name|SP_SA
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a new packet (and not a system packet), 		 * and we are not currently timing anything, 		 * time this one and ask for an ack. 		 */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_snt
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SP
operator|)
operator|)
condition|)
block|{
name|cb
operator|->
name|s_snt
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|==
literal|0
condition|)
block|{
name|cb
operator|->
name|s_rtseq
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|1
expr_stmt|;
name|si
operator|->
name|si_cc
operator||=
name|SP_SA
expr_stmt|;
block|}
comment|/* 			 * If the retransmit timer has not been set 			 * and this is a real packet 			 * then start the retransmit timer 			 */
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|==
literal|0
condition|)
block|{
name|TCPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
argument_list|,
name|tcp_beta
operator|*
name|cb
operator|->
name|s_srtt
argument_list|,
name|TCPTV_MIN
argument_list|,
name|TCPTV_MAX
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|si
operator|->
name|si_seq
operator|=
name|htons
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|htons
argument_list|(
name|cb
operator|->
name|s_alo
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|htons
argument_list|(
name|cb
operator|->
name|s_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|idpcksum
condition|)
block|{
name|si
operator|->
name|si_sum
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_len
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
operator|(
name|len
operator|-
literal|1
operator|)
operator||
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|si
operator|->
name|si_sum
operator|=
name|ns_cksum
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|si
operator|->
name|si_sum
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_OUTPUT
argument_list|,
name|cb
operator|->
name|s_state
argument_list|,
name|cb
argument_list|,
name|si
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spp_output_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
condition|)
name|error
operator|=
name|ns_output
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|route
operator|*
operator|)
literal|0
argument_list|,
name|NS_ROUTETOIF
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ns_output
argument_list|(
name|m
argument_list|,
operator|&
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_route
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|traceallspps
operator|&&
name|sppconsdebug
condition|)
block|{
name|printf
argument_list|(
literal|"spp_out: %x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_OUTPUT
argument_list|,
name|cb
operator|->
name|s_state
argument_list|,
name|cb
argument_list|,
name|si
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|spp_ctloutput
argument_list|(
argument|req
argument_list|,
argument|so
argument_list|,
argument|level
argument_list|,
argument|name
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|sotonspcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|level
operator|!=
name|NSPROTO_SPP
condition|)
block|{
comment|/* This will have to be changed when we do more general 		   stacking of protocols */
return|return
operator|(
name|idp_ctloutput
argument_list|(
name|req
argument_list|,
name|so
argument_list|,
name|level
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|nsp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
else|else
name|cb
operator|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRCO_GETOPT
case|:
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
switch|switch
condition|(
name|name
condition|)
block|{
case|case
name|SO_HEADERS_ON_INPUT
case|:
name|mask
operator|=
name|SF_HI
expr_stmt|;
goto|goto
name|get_flags
goto|;
case|case
name|SO_HEADERS_ON_OUTPUT
case|:
name|mask
operator|=
name|SF_HO
expr_stmt|;
name|get_flags
label|:
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|short
operator|*
argument_list|)
operator|=
name|cb
operator|->
name|s_flags
operator|&
name|mask
expr_stmt|;
break|break;
case|case
name|SO_LAST_HEADER
case|:
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
operator|=
name|cb
operator|->
name|s_rhdr
expr_stmt|;
break|break;
case|case
name|SO_DEFAULT_HEADERS
case|:
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
operator|=
name|cb
operator|->
name|s_shdr
operator|.
name|si_s
expr_stmt|;
block|}
operator|*
name|value
operator|=
name|m
expr_stmt|;
break|break;
case|case
name|PRCO_SETOPT
case|:
switch|switch
condition|(
name|name
condition|)
block|{
name|int
name|mask
decl_stmt|,
modifier|*
name|ok
decl_stmt|;
case|case
name|SO_HEADERS_ON_INPUT
case|:
name|mask
operator|=
name|SF_HI
expr_stmt|;
goto|goto
name|set_head
goto|;
case|case
name|SO_HEADERS_ON_OUTPUT
case|:
name|mask
operator|=
name|SF_HO
expr_stmt|;
name|set_head
label|:
if|if
condition|(
name|value
operator|&&
operator|*
name|value
condition|)
block|{
name|ok
operator|=
name|mtod
argument_list|(
operator|*
name|value
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ok
condition|)
name|cb
operator|->
name|s_flags
operator||=
name|mask
expr_stmt|;
else|else
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SO_DEFAULT_HEADERS
case|:
block|{
specifier|register
name|struct
name|sphdr
modifier|*
name|sp
init|=
name|mtod
argument_list|(
operator|*
name|value
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
decl_stmt|;
name|cb
operator|->
name|s_dt
operator|=
name|sp
operator|->
name|sp_dt
expr_stmt|;
name|cb
operator|->
name|s_cc
operator|=
name|sp
operator|->
name|sp_cc
operator|&
name|SP_EM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|&&
operator|*
name|value
condition|)
name|m_freem
argument_list|(
operator|*
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|release
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|spp_usrreq
argument_list|(
argument|so
argument_list|,
argument|req
argument_list|,
argument|m
argument_list|,
argument|nam
argument_list|,
argument|rights
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nam
decl_stmt|,
modifier|*
name|rights
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|sotonspcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|ostate
decl_stmt|;
if|if
condition|(
name|req
operator|==
name|PRU_CONTROL
condition|)
return|return
operator|(
name|ns_control
argument_list|(
name|so
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
name|nam
argument_list|,
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|rights
argument_list|)
operator|)
return|;
if|if
condition|(
name|rights
operator|&&
name|rights
operator|->
name|m_len
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|nsp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|req
operator|!=
name|PRU_ATTACH
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
else|else
name|cb
operator|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
name|ostate
operator|=
name|cb
condition|?
name|cb
operator|->
name|s_state
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRU_ATTACH
case|:
if|if
condition|(
name|nsp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|ns_pcballoc
argument_list|(
name|so
argument_list|,
operator|&
name|nspcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
literal|2048
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|nsp
operator|=
name|sotonspcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mm
init|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_PCB
argument_list|)
decl_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|cb
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|sppcb
operator|*
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
name|cb
operator|->
name|s_snt
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|->
name|s_q
operator|.
name|si_next
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_prev
operator|=
operator|&
name|cb
operator|->
name|s_q
expr_stmt|;
name|cb
operator|->
name|s_nspcb
operator|=
name|nsp
expr_stmt|;
name|nsp
operator|->
name|nsp_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|cb
expr_stmt|;
block|}
break|break;
case|case
name|PRU_DETACH
case|:
if|if
condition|(
name|nsp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cb
operator|->
name|s_state
operator|>
name|TCPS_LISTEN
condition|)
name|cb
operator|=
name|spp_disconnect
argument_list|(
name|cb
argument_list|)
expr_stmt|;
else|else
name|cb
operator|=
name|spp_close
argument_list|(
name|cb
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_BIND
case|:
name|error
operator|=
name|ns_pcbbind
argument_list|(
name|nsp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_LISTEN
case|:
if|if
condition|(
name|nsp
operator|->
name|nsp_lport
operator|==
literal|0
condition|)
name|error
operator|=
name|ns_pcbbind
argument_list|(
name|nsp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
break|break;
comment|/* 	 * Initiate connection to peer. 	 * Enter SYN_SENT state, and mark socket as connecting. 	 * Start keep-alive timer, setup prototype header, 	 * Send initial system packet requesting connection. 	 */
case|case
name|PRU_CONNECT
case|:
if|if
condition|(
name|nsp
operator|->
name|nsp_lport
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ns_pcbbind
argument_list|(
name|nsp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|error
operator|=
name|ns_pcbconnect
argument_list|(
name|nsp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_SYN_SENT
expr_stmt|;
name|cb
operator|->
name|s_did
operator|=
literal|0
expr_stmt|;
name|spp_template
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_KEEP
index|]
operator|=
name|TCPTV_KEEP
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|TCPTV_KEEP
expr_stmt|;
comment|/* 		 * Other party is required to respond to 		 * the port I send from, but he is not 		 * required to answer from where I am sending to, 		 * so allow wildcarding. 		 * original port I am sending to is still saved in 		 * cb->s_dport. 		 */
name|nsp
operator|->
name|nsp_fport
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_CONNECT2
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
comment|/* 	 * We may decide later to implement connection closing 	 * handshaking at the spp level optionally. 	 * here is the hook to do it: 	 */
case|case
name|PRU_DISCONNECT
case|:
name|cb
operator|=
name|spp_disconnect
argument_list|(
name|cb
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Accept a connection.  Essentially all the work is 	 * done at higher levels; just return the address 	 * of the peer, storing through addr. 	 */
case|case
name|PRU_ACCEPT
case|:
block|{
name|struct
name|sockaddr_ns
modifier|*
name|sns
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_ns
operator|*
argument_list|)
decl_stmt|;
name|nam
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ns
argument_list|)
expr_stmt|;
name|sns
operator|->
name|sns_family
operator|=
name|AF_NS
expr_stmt|;
name|sns
operator|->
name|sns_addr
operator|=
name|nsp
operator|->
name|nsp_faddr
expr_stmt|;
break|break;
block|}
case|case
name|PRU_SHUTDOWN
case|:
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|spp_usrclosed
argument_list|(
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
condition|)
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * After a receive, possibly send acknowledgment 	 * updating allocation. 	 */
case|case
name|PRU_RCVD
case|:
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_SEND
case|:
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|PRU_ABORT
case|:
name|spp_drop
argument_list|(
name|cb
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_SENSE
case|:
case|case
name|PRU_CONTROL
case|:
name|m
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
case|case
name|PRU_RCVOOB
case|:
if|if
condition|(
operator|!
operator|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_IOOB
operator|)
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
name|m
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|=
name|cb
operator|->
name|s_iobc
expr_stmt|;
name|cb
operator|->
name|s_oobflags
operator|&=
operator|~
name|SF_IOOB
expr_stmt|;
break|break;
case|case
name|PRU_SENDOOB
case|:
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|<
operator|-
literal|512
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|cb
operator|->
name|s_oobflags
operator||=
name|SF_SOOB
expr_stmt|;
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|cb
operator|->
name|s_oobflags
operator|&=
operator|~
name|SF_SOOB
expr_stmt|;
break|break;
case|case
name|PRU_SOCKADDR
case|:
name|ns_setsockaddr
argument_list|(
name|nsp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_PEERADDR
case|:
name|ns_setpeeraddr
argument_list|(
name|nsp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_SLOWTIMO
case|:
name|cb
operator|=
name|spp_timers
argument_list|(
name|cb
argument_list|,
operator|(
name|int
operator|)
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_FASTTIMO
case|:
case|case
name|PRU_PROTORCV
case|:
case|case
name|PRU_PROTOSEND
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"sp_usrreq"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
operator|)
condition|)
name|spp_trace
argument_list|(
name|SA_USER
argument_list|,
name|ostate
argument_list|,
name|cb
argument_list|,
operator|(
expr|struct
name|sphdr
operator|*
operator|)
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|release
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|spp_usrreq_sp
argument_list|(
argument|so
argument_list|,
argument|req
argument_list|,
argument|m
argument_list|,
argument|nam
argument_list|,
argument|rights
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nam
decl_stmt|,
modifier|*
name|rights
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
name|spp_usrreq
argument_list|(
name|so
argument_list|,
name|req
argument_list|,
name|m
argument_list|,
name|nam
argument_list|,
name|rights
argument_list|)
decl_stmt|;
if|if
condition|(
name|req
operator|==
name|PRU_ATTACH
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|sotonspcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
operator|(
operator|(
expr|struct
name|sppcb
operator|*
operator|)
name|nsp
operator|->
name|nsp_pcb
operator|)
operator|->
name|s_flags
operator||=
operator|(
name|SF_HI
operator||
name|SF_HO
operator||
name|SF_PI
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Create template to be used to send spp packets on a connection.  * Called after host entry created, fills  * in a skeletal spp header (choosing connection id),  * minimizing the amount of work necessary when the connection is used.  */
end_comment

begin_macro
name|spp_template
argument_list|(
argument|cb
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|cb
operator|->
name|s_nspcb
decl_stmt|;
specifier|register
name|struct
name|spidp
modifier|*
name|n
init|=
operator|&
operator|(
name|cb
operator|->
name|s_shdr
operator|)
decl_stmt|;
name|cb
operator|->
name|s_mtu
operator|=
literal|1024
expr_stmt|;
name|n
operator|->
name|si_pt
operator|=
name|NSPROTO_SPP
expr_stmt|;
name|n
operator|->
name|si_sna
operator|=
name|nsp
operator|->
name|nsp_laddr
expr_stmt|;
name|n
operator|->
name|si_dna
operator|=
name|nsp
operator|->
name|nsp_faddr
expr_stmt|;
name|n
operator|->
name|si_sid
operator|=
name|htons
argument_list|(
name|spp_iss
argument_list|)
expr_stmt|;
name|spp_iss
operator|+=
name|SPP_ISSINCR
operator|/
literal|2
expr_stmt|;
name|n
operator|->
name|si_alo
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Close a SPIP control block:  *	discard spp control block itself  *	discard ns protocol control block  *	wake up any sleepers  */
end_comment

begin_function
name|struct
name|sppcb
modifier|*
name|spp_close
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
block|{
specifier|register
name|struct
name|spidp_q
modifier|*
name|s
decl_stmt|;
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|cb
operator|->
name|s_nspcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|nsp
operator|->
name|nsp_socket
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|s
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
expr_stmt|;
while|while
condition|(
name|s
operator|!=
operator|&
operator|(
name|cb
operator|->
name|s_q
operator|)
condition|)
block|{
name|s
operator|=
name|s
operator|->
name|si_next
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|s
operator|->
name|si_prev
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|s
operator|->
name|si_prev
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|cb
argument_list|)
argument_list|)
expr_stmt|;
name|nsp
operator|->
name|nsp_pcb
operator|=
literal|0
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ns_pcbdetach
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|sppcb
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Someday we may do level 3 handshaking  *	to close a connection or send a xerox style error.  *	For now, just close.  */
end_comment

begin_function
name|struct
name|sppcb
modifier|*
name|spp_usrclosed
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
block|{
return|return
operator|(
name|spp_close
argument_list|(
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sppcb
modifier|*
name|spp_disconnect
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
block|{
return|return
operator|(
name|spp_close
argument_list|(
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drop connection, reporting  * the specified error.  */
end_comment

begin_function
name|struct
name|sppcb
modifier|*
name|spp_drop
parameter_list|(
name|cb
parameter_list|,
name|errno
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|errno
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
decl_stmt|;
comment|/* 	 * someday, in the xerox world 	 * we will generate error protocol packets 	 * announcing that the socket has gone away. 	 */
comment|/*if (TCPS_HAVERCVDSYN(tp->t_state)) { 		tp->t_state = TCPS_CLOSED; 		(void) tcp_output(tp); 	}*/
name|so
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
return|return
operator|(
name|spp_close
argument_list|(
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|spp_abort
argument_list|(
argument|nsp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|spp_close
argument_list|(
operator|(
expr|struct
name|sppcb
operator|*
operator|)
name|nsp
operator|->
name|nsp_pcb
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|spp_setpersist
argument_list|(
name|cb
argument_list|)
specifier|register
expr|struct
name|sppcb
operator|*
name|cb
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*if (cb->s_timer[TCPT_REXMT]) 		panic("spp_output REXMT");*/
comment|/* 	 * Start/restart persistance timer. 	 */
name|TCPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_PERSIST
index|]
argument_list|,
operator|(
call|(
name|int
call|)
argument_list|(
name|tcp_beta
operator|*
name|cb
operator|->
name|s_srtt
argument_list|)
operator|)
operator|<<
name|cb
operator|->
name|s_rxtshift
argument_list|,
name|TCPTV_PERSMIN
argument_list|,
name|TCPTV_MAX
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rxtshift
operator|>=
name|TCP_MAXRXTSHIFT
condition|)
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Fast timeout routine for processing delayed acks  */
end_comment

begin_decl_stmt
name|int
name|spp_ftcnt
decl_stmt|;
end_decl_stmt

begin_macro
name|spp_fasttimo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|nsp
operator|=
name|nspcb
operator|.
name|nsp_next
expr_stmt|;
name|spp_ftcnt
operator|++
expr_stmt|;
if|if
condition|(
name|nsp
condition|)
for|for
control|(
init|;
name|nsp
operator|!=
operator|&
name|nspcb
condition|;
name|nsp
operator|=
name|nsp
operator|->
name|nsp_next
control|)
if|if
condition|(
operator|(
name|cb
operator|=
operator|(
expr|struct
name|sppcb
operator|*
operator|)
name|nsp
operator|->
name|nsp_pcb
operator|)
operator|&&
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_DELACK
operator|)
condition|)
block|{
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|SF_DELACK
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_AK
expr_stmt|;
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * spp protocol timeout routine called every 500 ms.  * Updates the timers in all active pcb's and  * causes finite state machine actions if timers expire.  */
end_comment

begin_macro
name|spp_slowtimo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nspcb
modifier|*
name|ip
decl_stmt|,
modifier|*
name|ipnxt
decl_stmt|;
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Search through tcb's and update active timers. 	 */
name|ip
operator|=
name|nspcb
operator|.
name|nsp_next
expr_stmt|;
if|if
condition|(
name|ip
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|ip
operator|!=
operator|&
name|nspcb
condition|)
block|{
name|cb
operator|=
name|nstosppcb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ipnxt
operator|=
name|ip
operator|->
name|nsp_next
expr_stmt|;
if|if
condition|(
name|cb
operator|==
literal|0
condition|)
goto|goto
name|tpgone
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TCPT_NTIMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|i
index|]
operator|&&
operator|--
name|cb
operator|->
name|s_timer
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|spp_usrreq
argument_list|(
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
argument_list|,
name|PRU_SLOWTIMO
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipnxt
operator|->
name|nsp_prev
operator|!=
name|ip
condition|)
goto|goto
name|tpgone
goto|;
block|}
block|}
name|cb
operator|->
name|s_idle
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rtt
condition|)
name|cb
operator|->
name|s_rtt
operator|++
expr_stmt|;
name|tpgone
label|:
name|ip
operator|=
name|ipnxt
expr_stmt|;
block|}
name|spp_iss
operator|+=
name|SPP_ISSINCR
operator|/
name|PR_SLOWHZ
expr_stmt|;
comment|/* increment iss */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|float
name|spp_backoff
index|[
name|TCP_MAXRXTSHIFT
index|]
init|=
block|{
literal|1.0
block|,
literal|1.2
block|,
literal|1.4
block|,
literal|1.7
block|,
literal|2.0
block|,
literal|3.0
block|,
literal|5.0
block|,
literal|8.0
block|,
literal|16.0
block|,
literal|32.0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tcpexprexmtbackoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TCP timer processing.  */
end_comment

begin_function
name|struct
name|sppcb
modifier|*
name|spp_timers
parameter_list|(
name|cb
parameter_list|,
name|timer
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|timer
decl_stmt|;
block|{
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|timer
expr_stmt|;
switch|switch
condition|(
name|timer
condition|)
block|{
comment|/* 	 * 2 MSL timeout in shutdown went off.  Delete connection 	 * control block. 	 */
case|case
name|TCPT_2MSL
case|:
name|cb
operator|=
name|spp_close
argument_list|(
name|cb
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Retransmission timer went off.  Message has not 	 * been acked within retransmit interval.  Back off 	 * to a longer retransmit interval and retransmit all 	 * unacknowledged messages in the window. 	 */
case|case
name|TCPT_REXMT
case|:
name|cb
operator|->
name|s_rxtshift
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rxtshift
operator|>
name|TCP_MAXRXTSHIFT
condition|)
block|{
name|cb
operator|=
name|spp_drop
argument_list|(
name|cb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|TCPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
argument_list|,
operator|(
name|int
operator|)
name|cb
operator|->
name|s_srtt
argument_list|,
name|TCPTV_MIN
argument_list|,
name|TCPTV_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcpexprexmtbackoff
condition|)
block|{
name|TCPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
argument_list|,
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|<<
name|cb
operator|->
name|s_rxtshift
argument_list|,
name|TCPTV_MIN
argument_list|,
name|TCPTV_MAX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TCPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
argument_list|,
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|*
name|spp_backoff
index|[
name|cb
operator|->
name|s_rxtshift
operator|-
literal|1
index|]
argument_list|,
name|TCPTV_MIN
argument_list|,
name|TCPTV_MAX
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Persistance timer into zero window. 	 * Force a probe to be sent. 	 */
case|case
name|TCPT_PERSIST
case|:
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|spp_setpersist
argument_list|(
name|cb
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Keep-alive timer went off; send something 	 * or drop connection if idle for too long. 	 */
case|case
name|TCPT_KEEP
case|:
if|if
condition|(
name|cb
operator|->
name|s_state
operator|<
name|TCPS_ESTABLISHED
condition|)
goto|goto
name|dropit
goto|;
if|if
condition|(
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
operator|->
name|so_options
operator|&
name|SO_KEEPALIVE
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_idle
operator|>=
name|TCPTV_MAXIDLE
condition|)
goto|goto
name|dropit
goto|;
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|cb
operator|->
name|s_idle
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_KEEP
index|]
operator|=
name|TCPTV_KEEP
expr_stmt|;
break|break;
name|dropit
label|:
name|cb
operator|=
name|spp_drop
argument_list|(
name|cb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|cb
operator|)
return|;
block|}
end_function

end_unit

