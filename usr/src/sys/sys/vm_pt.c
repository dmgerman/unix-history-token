begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	vm_pt.c	6.1	83/07/29	*/
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/proc.h"
end_include

begin_include
include|#
directive|include
file|"../h/map.h"
end_include

begin_include
include|#
directive|include
file|"../h/cmap.h"
end_include

begin_include
include|#
directive|include
file|"../h/vm.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/text.h"
end_include

begin_include
include|#
directive|include
file|"../h/mount.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get page tables for process p.  Allocator  * for memory is argument; process must be locked  * from swapping if vmemall is used; if memall is  * used, call will return w/o waiting for memory.  * In any case an error return results if no user  * page table space is available.  */
end_comment

begin_expr_stmt
name|vgetpt
argument_list|(
name|p
argument_list|,
name|pmemall
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|pmemall
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|long
name|a
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_szpt
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"vgetpt"
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space in the kernel map for this process. 	 * Then allocate page table pages, and initialize the 	 * process' p0br and addr pointer to be the kernel 	 * virtual addresses of the base of the page tables and 	 * the pte for the process pcb (at the base of the u.). 	 */
name|a
operator|=
name|rmalloc
argument_list|(
name|kernelmap
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_szpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
call|(
modifier|*
name|pmemall
call|)
argument_list|(
operator|&
name|Usrptmap
index|[
name|a
index|]
argument_list|,
name|p
operator|->
name|p_szpt
argument_list|,
name|p
argument_list|,
name|CSYS
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rmfree
argument_list|(
name|kernelmap
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_szpt
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|->
name|p_p0br
operator|=
name|kmxtob
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_addr
operator|=
name|uaddr
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Now validate the system page table entries for the 	 * user page table pages, flushing old translations 	 * for these kernel virtual addresses.  Clear the new 	 * page table pages for clean post-mortems. 	 */
name|vmaccess
argument_list|(
operator|&
name|Usrptmap
index|[
name|a
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_p0br
argument_list|,
name|p
operator|->
name|p_szpt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|p_szpt
condition|;
name|i
operator|++
control|)
name|clearseg
argument_list|(
name|Usrptmap
index|[
name|a
operator|+
name|i
index|]
operator|.
name|pg_pfnum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Initialize text portion of page table.  */
end_comment

begin_macro
name|vinitpt
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|pte
name|proto
decl_stmt|;
name|xp
operator|=
name|p
operator|->
name|p_textp
expr_stmt|;
if|if
condition|(
name|xp
operator|==
literal|0
condition|)
return|return;
name|pte
operator|=
name|tptopte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If there is another instance of same text in core 	 * then just copy page tables from other process. 	 */
if|if
condition|(
name|q
operator|=
name|xp
operator|->
name|x_caddr
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tptopte
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|pte
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
operator|*
name|xp
operator|->
name|x_size
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Initialize text page tables, zfod if we are loading 	 * the text now; unless the process is demand loaded, 	 * this will suffice as the text will henceforth either be 	 * read from a file or demand paged in. 	 */
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|proto
operator|=
name|PG_URKR
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|x_flag
operator|&
name|XLOAD
condition|)
block|{
name|proto
operator|.
name|pg_fod
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
operator|&
name|proto
operator|)
operator|->
name|pg_fileno
operator|=
name|PG_FZERO
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xp
operator|->
name|x_size
condition|;
name|i
operator|++
control|)
operator|*
name|pte
operator|++
operator|=
name|proto
expr_stmt|;
if|if
condition|(
operator|(
name|xp
operator|->
name|x_flag
operator|&
name|XPAGI
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Text is demand loaded.  If process is not loaded (i.e. being 	 * swapped in) then retrieve page tables from swap area.  Otherwise 	 * this is the first time and we must initialize the page tables 	 * from the blocks in the file system. 	 */
if|if
condition|(
name|xp
operator|->
name|x_flag
operator|&
name|XLOAD
condition|)
name|vinifod
argument_list|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
name|tptopte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PG_FTEXT
argument_list|,
name|xp
operator|->
name|x_iptr
argument_list|,
operator|(
name|daddr_t
operator|)
literal|1
argument_list|,
name|xp
operator|->
name|x_size
argument_list|)
expr_stmt|;
else|else
name|swap
argument_list|(
name|p
argument_list|,
name|xp
operator|->
name|x_ptdaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|tptopte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xp
operator|->
name|x_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|,
name|B_READ
argument_list|,
name|B_PAGET
argument_list|,
name|swapdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * In the case where we are overlaying ourself with new page 	 * table entries, old user-space translations should be flushed. 	 */
if|if
condition|(
name|p
operator|==
name|u
operator|.
name|u_procp
condition|)
name|newptes
argument_list|(
name|tptopte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tptov
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xp
operator|->
name|x_size
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|p_flag
operator||=
name|SPTECHG
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Update the page tables of all processes linked  * to a particular text segment, by distributing  * dpte to the the text page at virtual frame v.  *  * Note that invalidation in the translation buffer for  * the current process is the responsibility of the caller.  */
end_comment

begin_macro
name|distpte
argument_list|(
argument|xp
argument_list|,
argument|tp
argument_list|,
argument|dpte
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|size_t
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|pte
modifier|*
name|dpte
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|p
operator|=
name|xp
operator|->
name|x_caddr
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|p_xlink
control|)
block|{
name|pte
operator|=
name|tptopte
argument_list|(
name|p
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|SPTECHG
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|dpte
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLSIZE
condition|;
name|i
operator|++
control|)
name|pte
index|[
name|i
index|]
operator|=
name|dpte
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Release page tables of process p.  */
end_comment

begin_expr_stmt
name|vrelpt
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|a
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_szpt
operator|==
literal|0
condition|)
return|return;
name|a
operator|=
name|btokmx
argument_list|(
name|p
operator|->
name|p_p0br
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vmemfree
argument_list|(
operator|&
name|Usrptmap
index|[
name|a
index|]
argument_list|,
name|p
operator|->
name|p_szpt
argument_list|)
expr_stmt|;
name|rmfree
argument_list|(
name|kernelmap
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_szpt
argument_list|,
operator|(
name|long
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|Xu
parameter_list|(
name|a
parameter_list|)
value|t = up->u_pcb.a; up->u_pcb.a = uq ->u_pcb.a; uq->u_pcb.a = t;
end_define

begin_define
define|#
directive|define
name|Xup
parameter_list|(
name|a
parameter_list|)
value|tp = up->u_pcb.a; up->u_pcb.a = uq ->u_pcb.a; uq->u_pcb.a = tp;
end_define

begin_define
define|#
directive|define
name|Xp
parameter_list|(
name|a
parameter_list|)
value|t = p->a; p->a = q->a; q->a = t;
end_define

begin_define
define|#
directive|define
name|Xpp
parameter_list|(
name|a
parameter_list|)
value|tp = p->a; p->a = q->a; q->a = tp;
end_define

begin_comment
comment|/*  * Pass the page tables of process p to process q.  * Used during vfork().  P and q are not symmetric;  * p is the giver and q the receiver; after calling vpasspt  * p will be ``cleaned out''.  Thus before vfork() we call vpasspt  * with the child as q and give it our resources; after vfork() we  * call vpasspt with the child as p to steal our resources back.  * We are cognizant of whether we are p or q because we have to  * be careful to keep our u. area and restore the other u. area from  * umap after we temporarily put our u. area in both p and q's page tables.  */
end_comment

begin_expr_stmt
name|vpasspt
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|up
argument_list|,
name|uq
argument_list|,
name|umap
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|user
modifier|*
name|up
decl_stmt|,
modifier|*
name|uq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pte
modifier|*
name|umap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|t
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|pte
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
comment|/* conservative, and slightly paranoid */
name|Xu
argument_list|(
name|pcb_szpt
argument_list|)
expr_stmt|;
name|Xu
argument_list|(
name|pcb_p0lr
argument_list|)
expr_stmt|;
name|Xu
argument_list|(
name|pcb_p1lr
argument_list|)
expr_stmt|;
name|Xup
argument_list|(
name|pcb_p0br
argument_list|)
expr_stmt|;
name|Xup
argument_list|(
name|pcb_p1br
argument_list|)
expr_stmt|;
comment|/* 	 * The u. area is contained in the process' p1 region. 	 * Thus we map the current u. area into the process virtual space 	 * of both sets of page tables we will deal with so that it 	 * will stay with us as we rearrange memory management. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|up
operator|==
operator|&
name|u
condition|)
name|q
operator|->
name|p_addr
index|[
name|i
index|]
operator|=
name|p
operator|->
name|p_addr
index|[
name|i
index|]
expr_stmt|;
else|else
name|p
operator|->
name|p_addr
index|[
name|i
index|]
operator|=
name|q
operator|->
name|p_addr
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now have u. double mapped, and have flushed 	 * any stale translations to new u. area. 	 * Switch the page tables. 	 */
name|Xpp
argument_list|(
name|p_p0br
argument_list|)
expr_stmt|;
name|Xp
argument_list|(
name|p_szpt
argument_list|)
expr_stmt|;
name|Xpp
argument_list|(
name|p_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
name|mtpr
argument_list|(
name|P0BR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0br
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|P1BR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1br
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|P0LR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0lr
operator|&
operator|~
name|AST_CLR
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|P1LR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1lr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now running on the ``other'' set of page tables. 	 * Flush translation to insure that we get correct u. 	 * Resurrect the u. for the other process in the other 	 * (our old) set of page tables.  Thus the other u. has moved 	 * from its old (our current) set of page tables to our old 	 * (its current) set of page tables, while we have kept our 	 * u. by mapping it into the other page table and then keeping 	 * the other page table. 	 */
ifdef|#
directive|ifdef
name|vax
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pf
decl_stmt|;
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
name|up
operator|==
operator|&
name|u
condition|)
block|{
name|pf
operator|=
name|umap
index|[
name|i
index|]
operator|.
name|pg_pfnum
expr_stmt|;
name|pte
operator|=
operator|&
name|q
operator|->
name|p_addr
index|[
name|i
index|]
expr_stmt|;
name|pte
operator|->
name|pg_pfnum
operator|=
name|pf
expr_stmt|;
block|}
else|else
block|{
name|pf
operator|=
name|umap
index|[
name|i
index|]
operator|.
name|pg_pfnum
expr_stmt|;
name|pte
operator|=
operator|&
name|p
operator|->
name|p_addr
index|[
name|i
index|]
expr_stmt|;
name|pte
operator|->
name|pg_pfnum
operator|=
name|pf
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|vax
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Compute number of pages to be allocated to the u. area  * and data and stack area page tables, which are stored on the  * disk immediately after the u. area.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|vusize
argument_list|(
name|p
argument_list|,
name|utl
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|user
modifier|*
name|utl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|tsz
init|=
name|p
operator|->
name|p_tsize
operator|/
name|NPTEPG
decl_stmt|;
comment|/* 	 * We do not need page table space on the disk for page 	 * table pages wholly containing text.  This is well 	 * understood in the code in vmswap.c. 	 */
return|return
operator|(
name|clrnd
argument_list|(
name|UPAGES
operator|+
name|clrnd
argument_list|(
name|ctopt
argument_list|(
name|p
operator|->
name|p_tsize
operator|+
name|p
operator|->
name|p_dsize
operator|+
name|p
operator|->
name|p_ssize
operator|+
name|UPAGES
argument_list|)
argument_list|)
operator|-
name|tsz
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get u area for process p.  If a old u area is given,  * then copy the new area from the old, else  * swap in as specified in the proc structure.  *  * Since argument map/newu is potentially shared  * when an old u. is provided we have to be careful not  * to block after beginning to use them in this case.  * (This is not true when called from swapin() with no old u.)  */
end_comment

begin_expr_stmt
name|vgetu
argument_list|(
name|p
argument_list|,
name|palloc
argument_list|,
name|map
argument_list|,
name|newu
argument_list|,
name|oldu
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|palloc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|register
name|struct
name|pte
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|user
modifier|*
name|newu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|user
modifier|*
name|oldu
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|palloc
call|)
argument_list|(
name|p
operator|->
name|p_addr
argument_list|,
name|clrnd
argument_list|(
name|UPAGES
argument_list|)
argument_list|,
name|p
argument_list|,
name|CSYS
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * New u. pages are to be accessible in map/newu as well 	 * as in process p's virtual memory. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|map
index|[
name|i
index|]
operator|=
name|p
operator|->
name|p_addr
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|p
operator|->
name|p_addr
operator|+
name|i
operator|)
operator||=
name|PG_URKW
operator||
name|PG_V
expr_stmt|;
block|}
name|setredzone
argument_list|(
name|p
operator|->
name|p_addr
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|vmaccess
argument_list|(
name|map
argument_list|,
operator|(
name|caddr_t
operator|)
name|newu
argument_list|,
name|UPAGES
argument_list|)
expr_stmt|;
comment|/* 	 * New u.'s come from forking or inswap. 	 */
if|if
condition|(
name|oldu
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|oldu
argument_list|,
operator|(
name|caddr_t
operator|)
name|newu
argument_list|,
name|UPAGES
operator|*
name|NBPG
argument_list|)
expr_stmt|;
name|newu
operator|->
name|u_procp
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|swap
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_swaddr
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ctob
argument_list|(
name|UPAGES
argument_list|)
argument_list|,
name|B_READ
argument_list|,
name|B_UAREA
argument_list|,
name|swapdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|vax
name|newu
operator|->
name|u_pcb
operator|.
name|pcb_ssp
operator|!=
operator|-
literal|1
operator|||
name|newu
operator|->
name|u_pcb
operator|.
name|pcb_esp
operator|!=
operator|-
literal|1
operator|||
endif|#
directive|endif
name|newu
operator|->
name|u_tsize
operator|!=
name|p
operator|->
name|p_tsize
operator|||
name|newu
operator|->
name|u_dsize
operator|!=
name|p
operator|->
name|p_dsize
operator|||
name|newu
operator|->
name|u_ssize
operator|!=
name|p
operator|->
name|p_ssize
operator|||
name|newu
operator|->
name|u_procp
operator|!=
name|p
condition|)
name|panic
argument_list|(
literal|"vgetu"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize the pcb copies of the p0 and p1 region bases and 	 * software page table size from the information in the proc structure. 	 */
name|newu
operator|->
name|u_pcb
operator|.
name|pcb_p0br
operator|=
name|p
operator|->
name|p_p0br
expr_stmt|;
name|newu
operator|->
name|u_pcb
operator|.
name|pcb_p1br
operator|=
name|initp1br
argument_list|(
name|p
operator|->
name|p_p0br
operator|+
name|p
operator|->
name|p_szpt
operator|*
name|NPTEPG
argument_list|)
expr_stmt|;
name|newu
operator|->
name|u_pcb
operator|.
name|pcb_szpt
operator|=
name|p
operator|->
name|p_szpt
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Release swap space for a u. area.  */
end_comment

begin_macro
name|vrelswu
argument_list|(
argument|p
argument_list|,
argument|utl
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|user
modifier|*
name|utl
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rmfree
argument_list|(
name|swapmap
argument_list|,
operator|(
name|long
operator|)
name|ctod
argument_list|(
name|vusize
argument_list|(
name|p
argument_list|,
name|utl
argument_list|)
argument_list|)
argument_list|,
name|p
operator|->
name|p_swaddr
argument_list|)
expr_stmt|;
comment|/* p->p_swaddr = 0; */
comment|/* leave for post-mortems */
block|}
end_block

begin_comment
comment|/*  * Get swap space for a u. area.  */
end_comment

begin_macro
name|vgetswu
argument_list|(
argument|p
argument_list|,
argument|utl
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|user
modifier|*
name|utl
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p
operator|->
name|p_swaddr
operator|=
name|rmalloc
argument_list|(
name|swapmap
argument_list|,
operator|(
name|long
operator|)
name|ctod
argument_list|(
name|vusize
argument_list|(
name|p
argument_list|,
name|utl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|p_swaddr
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Release u. area, swapping it out if desired.  *  * Note: we run on the old u. after it is released into swtch(),  * and are safe because nothing can happen at interrupt time.  */
end_comment

begin_expr_stmt
name|vrelu
argument_list|(
name|p
argument_list|,
name|swapu
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|pte
name|uu
index|[
name|UPAGES
index|]
decl_stmt|;
if|if
condition|(
name|swapu
condition|)
name|swap
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_swaddr
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ctob
argument_list|(
name|UPAGES
argument_list|)
argument_list|,
name|B_WRITE
argument_list|,
name|B_UAREA
argument_list|,
name|swapdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
name|uu
index|[
name|i
index|]
operator|=
name|p
operator|->
name|p_addr
index|[
name|i
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|vmemfree
argument_list|(
name|uu
argument_list|,
name|clrnd
argument_list|(
name|UPAGES
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|unneeded
end_ifdef

begin_decl_stmt
name|int
name|ptforceswap
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Expand a page table, assigning new kernel virtual  * space and copying the page table entries over both  * in the system map and as necessary in the user page table space.  */
end_comment

begin_expr_stmt
name|ptexpand
argument_list|(
name|change
argument_list|,
name|ods
argument_list|,
name|oss
argument_list|)
specifier|register
name|int
name|change
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|ods
decl_stmt|,
name|oss
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|spages
decl_stmt|,
name|ss
init|=
name|P1PAGES
operator|-
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1lr
decl_stmt|;
specifier|register
name|int
name|kold
init|=
name|btokmx
argument_list|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0br
argument_list|)
decl_stmt|;
name|int
name|knew
decl_stmt|,
name|tdpages
decl_stmt|;
name|int
name|szpt
init|=
name|u
operator|.
name|u_pcb
operator|.
name|pcb_szpt
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|change
operator|<=
literal|0
operator|||
name|change
operator|%
name|CLSIZE
condition|)
name|panic
argument_list|(
literal|"ptexpand"
argument_list|)
expr_stmt|;
comment|/* 	 * Change is the number of new page table pages needed. 	 * Kold is the old index in the kernelmap of the page tables. 	 * Allocate a new kernel map segment of size szpt+change for 	 * the page tables, and the new page table pages in the 	 * middle of this new region. 	 */
name|top
label|:
ifdef|#
directive|ifdef
name|unneeded
if|if
condition|(
name|ptforceswap
condition|)
goto|goto
name|bad
goto|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|knew
operator|=
name|rmalloc
argument_list|(
name|kernelmap
argument_list|,
call|(
name|long
call|)
argument_list|(
name|szpt
operator|+
name|change
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|spages
operator|=
name|ss
operator|/
name|NPTEPG
expr_stmt|;
name|tdpages
operator|=
name|szpt
operator|-
name|spages
expr_stmt|;
if|if
condition|(
name|memall
argument_list|(
operator|&
name|Usrptmap
index|[
name|knew
operator|+
name|tdpages
index|]
argument_list|,
name|change
argument_list|,
name|u
operator|.
name|u_procp
argument_list|,
name|CSYS
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rmfree
argument_list|(
name|kernelmap
argument_list|,
call|(
name|long
call|)
argument_list|(
name|szpt
operator|+
name|change
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|knew
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Spages pages of u.+stack page tables go over unchanged. 	 * Tdpages of text+data page table may contain a few stack 	 * pages which need to go in one of the newly allocated pages; 	 * this is a rough cut. 	 */
name|kmcopy
argument_list|(
name|knew
argument_list|,
name|kold
argument_list|,
name|tdpages
argument_list|)
expr_stmt|;
name|kmcopy
argument_list|(
name|knew
operator|+
name|tdpages
operator|+
name|change
argument_list|,
name|kold
operator|+
name|tdpages
argument_list|,
name|spages
argument_list|)
expr_stmt|;
comment|/* 	 * Validate and clear the newly allocated page table pages in the 	 * center of the new region of the kernelmap. 	 */
name|i
operator|=
name|knew
operator|+
name|tdpages
expr_stmt|;
name|p1
operator|=
operator|&
name|Usrptmap
index|[
name|i
index|]
expr_stmt|;
name|p2
operator|=
name|p1
operator|+
name|change
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|p2
condition|)
block|{
comment|/* tptov BELOW WORKS ONLY FOR VAX */
name|mapin
argument_list|(
name|p1
argument_list|,
name|tptov
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|i
argument_list|)
argument_list|,
name|p1
operator|->
name|pg_pfnum
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|PG_V
operator||
name|PG_KW
argument_list|)
argument_list|)
expr_stmt|;
name|clearseg
argument_list|(
name|p1
operator|->
name|pg_pfnum
argument_list|)
expr_stmt|;
name|p1
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|vax
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Move the stack and u. pte's which are before the newly 	 * allocated pages into the last of the newly allocated pages. 	 * They are taken from the end of the current p1 region, 	 * and moved to the end of the new p1 region. 	 */
name|p1
operator|=
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1br
operator|+
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1lr
expr_stmt|;
name|p2
operator|=
name|initp1br
argument_list|(
name|kmxtob
argument_list|(
name|knew
operator|+
name|szpt
operator|+
name|change
argument_list|)
argument_list|)
operator|+
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1lr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|kmxtob
argument_list|(
name|kold
operator|+
name|szpt
argument_list|)
operator|-
name|p1
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
comment|/* 	 * Now switch to the new page tables. 	 */
ifdef|#
directive|ifdef
name|vax
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* paranoid */
endif|#
directive|endif
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
comment|/* conservative */
name|u
operator|.
name|u_procp
operator|->
name|p_p0br
operator|=
name|kmxtob
argument_list|(
name|knew
argument_list|)
expr_stmt|;
name|setp0br
argument_list|(
name|u
operator|.
name|u_procp
operator|->
name|p_p0br
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1br
operator|=
name|initp1br
argument_list|(
name|kmxtob
argument_list|(
name|knew
operator|+
name|szpt
operator|+
name|change
argument_list|)
argument_list|)
expr_stmt|;
name|setp1br
argument_list|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1br
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_pcb
operator|.
name|pcb_szpt
operator|+=
name|change
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_szpt
operator|+=
name|change
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_addr
operator|=
name|uaddr
argument_list|(
name|u
operator|.
name|u_procp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, free old kernelmap. 	 */
if|if
condition|(
name|szpt
condition|)
name|rmfree
argument_list|(
name|kernelmap
argument_list|,
operator|(
name|long
operator|)
name|szpt
argument_list|,
operator|(
name|long
operator|)
name|kold
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
comment|/* 	 * Swap out the process so that the unavailable  	 * resource will be allocated upon swapin. 	 * 	 * When resume is executed for the process,  	 * here is where it will resume. 	 */
name|resume
argument_list|(
name|pcbb
argument_list|(
name|u
operator|.
name|u_procp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
operator|&
name|u
operator|.
name|u_ssave
argument_list|)
condition|)
return|return;
if|if
condition|(
name|swapout
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|ods
argument_list|,
name|oss
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No space to swap... it is inconvenient to try 		 * to exit, so just wait a bit and hope something 		 * turns up.  Could deadlock here. 		 * 		 * SOMEDAY REFLECT ERROR BACK THROUGH expand TO CALLERS 		 * (grow, sbreak) SO CAN'T DEADLOCK HERE. 		 */
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* 	 * Set SSWAP bit, so that when process is swapped back in 	 * swapin will set u.u_pcb.pcb_sswap to u_sswap and force a 	 * return from the setjmp() above. 	 */
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator||=
name|SSWAP
expr_stmt|;
name|swtch
argument_list|()
expr_stmt|;
comment|/* no return */
block|}
end_block

begin_expr_stmt
name|kmcopy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|count
argument_list|)
specifier|register
name|int
name|to
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|tp
init|=
operator|&
name|Usrptmap
index|[
name|to
index|]
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|fp
init|=
operator|&
name|Usrptmap
index|[
name|from
index|]
decl_stmt|;
while|while
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|mapin
argument_list|(
name|tp
argument_list|,
name|tptov
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|to
argument_list|)
argument_list|,
name|fp
operator|->
name|pg_pfnum
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|fp
operator|)
operator|&
operator|(
name|PG_V
operator||
name|PG_PROT
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
name|fp
operator|++
expr_stmt|;
name|to
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
end_block

end_unit

