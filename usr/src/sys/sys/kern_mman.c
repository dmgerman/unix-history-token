begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)kern_mman.c	7.4 (Berkeley) 7/10/87  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"inode.h"
end_include

begin_include
include|#
directive|include
file|"seg.h"
end_include

begin_include
include|#
directive|include
file|"acct.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"text.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"vadvise.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"trace.h"
end_include

begin_include
include|#
directive|include
file|"mman.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"../machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../machine/reg.h"
end_include

begin_include
include|#
directive|include
file|"../machine/psl.h"
end_include

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../machine/mtpr.h"
end_include

begin_macro
name|sbrk
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_macro
name|sstk
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_macro
name|getpagesize
argument_list|()
end_macro

begin_block
block|{
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
name|NBPG
operator|*
name|CLSIZE
expr_stmt|;
block|}
end_block

begin_macro
name|smmap
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|MMAP
struct|struct
name|a
block|{
name|caddr_t
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|prot
decl_stmt|;
name|int
name|share
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|int
name|off
decl_stmt|,
name|fv
decl_stmt|,
name|lv
decl_stmt|,
name|pm
decl_stmt|,
argument_list|(
operator|*
name|mapfun
argument_list|)
argument_list|()
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
specifier|extern
name|struct
name|file
modifier|*
name|getinode
parameter_list|()
function_decl|;
name|fp
operator|=
name|getinode
argument_list|(
name|uap
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return;
name|ip
operator|=
operator|(
expr|struct
name|inode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_mode
operator|&
name|IFMT
operator|)
operator|!=
name|IFCHR
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|dev
operator|=
name|ip
operator|->
name|i_rdev
expr_stmt|;
name|mapfun
operator|=
name|cdevsw
index|[
name|major
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|d_mmap
expr_stmt|;
if|if
condition|(
name|mapfun
operator|==
name|NULL
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|uap
operator|->
name|addr
operator|&
name|CLOFSET
operator|)
operator|||
operator|(
name|uap
operator|->
name|len
operator|&
name|CLOFSET
operator|)
operator|||
operator|(
name|uap
operator|->
name|pos
operator|&
name|CLOFSET
operator|)
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|uap
operator|->
name|prot
operator|&
name|PROT_WRITE
operator|)
operator|&&
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|uap
operator|->
name|prot
operator|&
name|PROT_READ
operator|)
operator|&&
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|uap
operator|->
name|share
operator|!=
name|MAP_SHARED
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|u
operator|.
name|u_pofile
index|[
name|uap
operator|->
name|fd
index|]
operator|&
name|UF_MAPPED
condition|)
block|{
comment|/* XXX */
name|u
operator|.
name|u_error
operator|=
name|EBUSY
expr_stmt|;
comment|/* XXX */
return|return;
comment|/* XXX */
block|}
comment|/* XXX */
name|fv
operator|=
name|btop
argument_list|(
name|uap
operator|->
name|addr
argument_list|)
expr_stmt|;
name|lv
operator|=
name|btop
argument_list|(
name|uap
operator|->
name|addr
operator|+
name|uap
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lv
operator|<
name|fv
operator|||
operator|!
name|isadsv
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|fv
argument_list|)
operator|||
operator|!
name|isadsv
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|lv
argument_list|)
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|uap
operator|->
name|len
condition|;
name|off
operator|+=
name|NBPG
control|)
if|if
condition|(
call|(
modifier|*
name|mapfun
call|)
argument_list|(
name|dev
argument_list|,
name|uap
operator|->
name|pos
operator|+
name|off
argument_list|,
name|uap
operator|->
name|prot
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
comment|/* XXX */
return|return;
block|}
if|if
condition|(
name|uap
operator|->
name|prot
operator|&
name|PROT_WRITE
condition|)
name|pm
operator|=
name|PG_UW
expr_stmt|;
else|else
name|pm
operator|=
name|PG_URKR
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|uap
operator|->
name|len
condition|;
name|off
operator|+=
name|NBPG
control|)
block|{
name|pte
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|vtopte
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|fv
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_rssize
operator|-=
name|vmemfree
argument_list|(
name|pte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
name|pm
expr_stmt|;
name|pte
operator|->
name|pg_v
operator|=
literal|1
expr_stmt|;
name|pte
operator|->
name|pg_fod
operator|=
literal|1
expr_stmt|;
name|pte
operator|->
name|pg_pfnum
operator|=
call|(
modifier|*
name|mapfun
call|)
argument_list|(
name|dev
argument_list|,
name|uap
operator|->
name|pos
operator|+
name|off
argument_list|,
name|uap
operator|->
name|prot
argument_list|)
expr_stmt|;
name|fv
operator|++
expr_stmt|;
block|}
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator||=
name|SPTECHG
expr_stmt|;
name|u
operator|.
name|u_mmap
index|[
name|uap
operator|->
name|fd
index|]
operator|.
name|um_base
operator|=
name|fv
expr_stmt|;
name|u
operator|.
name|u_mmap
index|[
name|uap
operator|->
name|fd
index|]
operator|.
name|um_len
operator|=
name|btoc
argument_list|(
name|uap
operator|->
name|len
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_pofile
index|[
name|uap
operator|->
name|fd
index|]
operator||=
name|UF_MAPPED
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|msync
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_macro
name|munmap
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|MMAP
specifier|register
struct|struct
name|a
block|{
name|caddr_t
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|int
name|off
decl_stmt|,
name|fv
decl_stmt|,
name|lv
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|uap
operator|->
name|addr
operator|&
name|CLOFSET
operator|)
operator|||
operator|(
name|uap
operator|->
name|len
operator|&
name|CLOFSET
operator|)
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|fv
operator|=
name|btop
argument_list|(
name|uap
operator|->
name|addr
argument_list|)
expr_stmt|;
name|lv
operator|=
name|btop
argument_list|(
name|uap
operator|->
name|addr
operator|+
name|uap
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lv
operator|<
name|fv
operator|||
operator|!
name|isadsv
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|fv
argument_list|)
operator|||
operator|!
name|isadsv
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|lv
argument_list|)
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|uap
operator|->
name|len
condition|;
name|off
operator|+=
name|NBPG
control|)
block|{
name|pte
operator|=
name|vtopte
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|fv
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_rssize
operator|-=
name|vmemfree
argument_list|(
name|pte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
name|PG_UW
operator||
name|PG_FOD
expr_stmt|;
operator|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
name|pte
operator|)
operator|->
name|pg_fileno
operator|=
name|PG_FZERO
expr_stmt|;
name|fv
operator|++
expr_stmt|;
block|}
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator||=
name|SPTECHG
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|munmapfd
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|MMAP
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|mmap
modifier|*
name|mmp
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|.
name|u_pofile
index|[
name|fd
index|]
operator|&
name|UF_MAPPED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"munmapfd"
argument_list|)
expr_stmt|;
name|mmp
operator|=
operator|&
name|u
operator|.
name|u_mmap
index|[
name|fd
index|]
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|mmp
operator|->
name|um_base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mmp
operator|->
name|um_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pte
operator|->
name|pg_v
operator|&&
name|pte
operator|->
name|pg_fod
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
name|PG_UW
operator||
name|PG_FOD
expr_stmt|;
operator|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
name|pte
operator|)
operator|->
name|pg_fileno
operator|=
name|PG_FZERO
expr_stmt|;
block|}
name|pte
operator|++
expr_stmt|;
block|}
name|newptes
argument_list|(
name|vtopte
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|mmp
operator|->
name|um_base
argument_list|)
argument_list|,
name|mmp
operator|->
name|um_base
argument_list|,
name|mmp
operator|->
name|um_len
argument_list|)
expr_stmt|;
name|mmp
operator|->
name|um_base
operator|=
literal|0
expr_stmt|;
name|mmp
operator|->
name|um_len
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|u
operator|.
name|u_pofile
index|[
name|fd
index|]
operator|&=
operator|~
name|UF_MAPPED
expr_stmt|;
block|}
end_block

begin_macro
name|mprotect
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_macro
name|madvise
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_macro
name|mincore
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_comment
comment|/* BEGIN DEFUNCT */
end_comment

begin_macro
name|obreak
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|char
modifier|*
name|nsiz
decl_stmt|;
block|}
struct|;
specifier|register
name|size_t
name|n
decl_stmt|,
name|d
decl_stmt|,
name|ds
decl_stmt|;
comment|/* 	 * set n to new data size 	 */
name|n
operator|=
name|btoc
argument_list|(
operator|(
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
operator|)
operator|->
name|nsiz
argument_list|)
operator|-
name|ctos
argument_list|(
name|u
operator|.
name|u_tsize
argument_list|)
operator|*
name|stoc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
comment|/* 	 * since we can't pass a -ve argument for the difference to chksize, 	 * if d is negative, make ds equal to the final value and clear d. 	 * keep the real difference in n for later use in expand. 	 */
name|ds
operator|=
name|u
operator|.
name|u_dsize
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|d
operator|=
name|clrnd
argument_list|(
name|n
operator|-
name|u
operator|.
name|u_dsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ds
operator|+=
name|d
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ctob
argument_list|(
name|ds
operator|+
name|d
argument_list|)
operator|>
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_cur
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chksize
argument_list|(
operator|(
name|u_int
operator|)
name|u
operator|.
name|u_tsize
argument_list|,
operator|(
name|u_int
operator|)
name|ds
argument_list|,
operator|(
name|u_int
operator|)
name|d
argument_list|,
operator|(
name|u_int
operator|)
name|u
operator|.
name|u_ssize
argument_list|)
condition|)
return|return;
if|if
condition|(
name|swpexpand
argument_list|(
name|ds
operator|+
name|d
argument_list|,
name|u
operator|.
name|u_ssize
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|expand
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|both
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clear a data page's reference bits.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_define
define|#
directive|define
name|dpte_clrref
parameter_list|(
name|pte
parameter_list|,
name|c
parameter_list|)
value|{ \ 	uncache(pte); \ 	if (pte->pg_u) { \ 		c =&cmap[pgtocm(pte->pg_pfnum)]; \ 		if (c->c_lock) \ 			continue; \ 		pte->pg_u = 0; \ 		if (anycl(pte, pg_m)) \ 			pte->pg_m = 1; \ 		distcl(pte); \ 	} \ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dpte_clrref
parameter_list|(
name|pte
parameter_list|,
name|c
parameter_list|)
value|{ \ 	c =&cmap[pgtocm(pte->pg_pfnum)]; \ 	if (c->c_lock) \ 		continue; \ 	pte->pg_v = 0; \ 	if (anycl(pte, pg_m)) \ 		pte->pg_m = 1; \ 	distcl(pte); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Clear a text page's reference bits.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_define
define|#
directive|define
name|tpte_clrref
parameter_list|(
name|pte
parameter_list|,
name|c
parameter_list|,
name|rp
parameter_list|,
name|i
parameter_list|)
value|{ \ 	uncache(pte); \ 	if (pte->pg_u) { \ 		c =&cmap[pgtocm(pte->pg_pfnum)]; \ 		if (c->c_lock) \ 			continue; \ 		pte->pg_u = 0; \ 		if (anycl(pte, pg_m)) \ 			pte->pg_m = 1; \ 		distcl(pte); \ 		distpte(rp->p_textp, i, pte); \ 	} \ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|tpte_clrref
parameter_list|(
name|pte
parameter_list|,
name|c
parameter_list|,
name|rp
parameter_list|,
name|i
parameter_list|)
value|{ \ 	dpte_clrref(pte, c); \ 	distpte(rp->p_textp, i, pte); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|ovadvise
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|anom
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
specifier|register
name|struct
name|proc
modifier|*
name|rp
init|=
name|u
operator|.
name|u_procp
decl_stmt|;
name|int
name|oanom
init|=
name|rp
operator|->
name|p_flag
operator|&
name|SUANOM
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
specifier|register
name|unsigned
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|both
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|uap
operator|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
expr_stmt|;
name|trace
argument_list|(
name|TR_VADVISE
argument_list|,
name|uap
operator|->
name|anom
argument_list|,
name|u
operator|.
name|u_procp
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|rp
operator|->
name|p_flag
operator|&=
operator|~
operator|(
name|SSEQL
operator||
name|SUANOM
operator|)
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|anom
condition|)
block|{
case|case
name|VA_ANOM
case|:
name|rp
operator|->
name|p_flag
operator||=
name|SUANOM
expr_stmt|;
break|break;
case|case
name|VA_SEQL
case|:
name|rp
operator|->
name|p_flag
operator||=
name|SSEQL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|oanom
operator|&&
operator|(
name|rp
operator|->
name|p_flag
operator|&
name|SUANOM
operator|)
operator|==
literal|0
operator|)
operator|||
name|uap
operator|->
name|anom
operator|==
name|VA_FLUSH
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rp
operator|->
name|p_dsize
condition|;
name|i
operator|+=
name|CLSIZE
control|)
block|{
name|pte
operator|=
name|dptopte
argument_list|(
name|rp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
name|dpte_clrref
argument_list|(
name|pte
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uap
operator|->
name|anom
operator|==
name|VA_FLUSH
condition|)
block|{
comment|/* invalidate all pages */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rp
operator|->
name|p_ssize
condition|;
name|i
operator|+=
name|CLSIZE
control|)
block|{
name|pte
operator|=
name|sptopte
argument_list|(
name|rp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
name|dpte_clrref
argument_list|(
name|pte
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rp
operator|->
name|p_tsize
condition|;
name|i
operator|+=
name|CLSIZE
control|)
block|{
name|pte
operator|=
name|tptopte
argument_list|(
name|rp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
name|tpte_clrref
argument_list|(
name|pte
argument_list|,
name|c
argument_list|,
name|rp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* END DEFUNCT */
end_comment

begin_comment
comment|/*  * grow the stack to include the SP  * true return if successful.  */
end_comment

begin_macro
name|grow
argument_list|(
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|si
decl_stmt|;
if|if
condition|(
name|sp
operator|>=
name|USRSTACK
operator|-
name|ctob
argument_list|(
name|u
operator|.
name|u_ssize
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|si
operator|=
name|clrnd
argument_list|(
name|btoc
argument_list|(
operator|(
name|USRSTACK
operator|-
name|sp
operator|)
argument_list|)
operator|-
name|u
operator|.
name|u_ssize
operator|+
name|SINCR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctob
argument_list|(
name|si
argument_list|)
operator|>
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_STACK
index|]
operator|.
name|rlim_cur
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|chksize
argument_list|(
operator|(
name|u_int
operator|)
name|u
operator|.
name|u_tsize
argument_list|,
operator|(
name|u_int
operator|)
name|u
operator|.
name|u_dsize
argument_list|,
operator|(
name|u_int
operator|)
literal|0
argument_list|,
operator|(
name|u_int
operator|)
name|u
operator|.
name|u_ssize
operator|+
name|si
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|swpexpand
argument_list|(
name|u
operator|.
name|u_dsize
argument_list|,
name|u
operator|.
name|u_ssize
operator|+
name|si
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|expand
argument_list|(
name|si
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

