begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)ut.c	7.7 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"tj.h"
end_include

begin_if
if|#
directive|if
name|NUT
operator|>
literal|0
end_if

begin_comment
comment|/*  * System Industries Model 9700 Tape Drive  *   emulates a TU45 on the UNIBUS  *  * TODO:  *	check out attention processing  *	try reset code and dump code  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"mtio.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"ubareg.h"
end_include

begin_include
include|#
directive|include
file|"ubavar.h"
end_include

begin_include
include|#
directive|include
file|"utreg.h"
end_include

begin_decl_stmt
name|struct
name|buf
name|cutbuf
index|[
name|NUT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bufs for control operations */
end_comment

begin_decl_stmt
name|struct
name|buf
name|tjutab
index|[
name|NTJ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bufs for slave queue headers */
end_comment

begin_decl_stmt
name|struct
name|uba_ctlr
modifier|*
name|utminfo
index|[
name|NUT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|tjdinfo
index|[
name|NTJ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|utprobe
argument_list|()
decl_stmt|,
name|utslave
argument_list|()
decl_stmt|,
name|utattach
argument_list|()
decl_stmt|,
name|utdgo
argument_list|()
decl_stmt|,
name|utintr
argument_list|()
decl_stmt|,
name|uttimer
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|utstd
index|[]
init|=
block|{
literal|0772440
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|utdriver
init|=
block|{
name|utprobe
block|,
name|utslave
block|,
name|utattach
block|,
name|utdgo
block|,
name|utstd
block|,
literal|"tj"
block|,
name|tjdinfo
block|,
literal|"ut"
block|,
name|utminfo
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MASKREG
parameter_list|(
name|reg
parameter_list|)
value|((reg)&0xffff)
end_define

begin_comment
comment|/* bits in minor device */
end_comment

begin_define
define|#
directive|define
name|TJUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)&03)
end_define

begin_define
define|#
directive|define
name|T_NOREWIND
value|04
end_define

begin_define
define|#
directive|define
name|T_1600BPI
value|010
end_define

begin_define
define|#
directive|define
name|T_6250BPI
value|020
end_define

begin_decl_stmt
name|short
name|utdens
index|[]
init|=
block|{
name|UT_NRZI
block|,
name|UT_PE
block|,
name|UT_GCR
block|,
name|UT_NRZI
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* slave to controller mapping table */
end_comment

begin_decl_stmt
name|short
name|tjtout
index|[
name|NTJ
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UTUNIT
parameter_list|(
name|dev
parameter_list|)
value|(tjtout[TJUNIT(dev)])
end_define

begin_define
define|#
directive|define
name|INF
value|(daddr_t)1000000L
end_define

begin_comment
comment|/* a block number that wont exist */
end_comment

begin_struct
struct|struct
name|tj_softc
block|{
name|char
name|sc_openf
decl_stmt|;
comment|/* exclusive open */
name|char
name|sc_lastiow
decl_stmt|;
comment|/* last I/O operation was a write */
name|daddr_t
name|sc_blkno
decl_stmt|;
comment|/* next block to transfer */
name|daddr_t
name|sc_nxrec
decl_stmt|;
comment|/* next record on tape */
name|u_short
name|sc_erreg
decl_stmt|;
comment|/* image of uter */
name|u_short
name|sc_dsreg
decl_stmt|;
comment|/* image of utds */
name|u_short
name|sc_resid
decl_stmt|;
comment|/* residual from transfer */
name|u_short
name|sc_dens
decl_stmt|;
comment|/* sticky selected density */
name|daddr_t
name|sc_timo
decl_stmt|;
comment|/* time until timeout expires */
name|short
name|sc_tact
decl_stmt|;
comment|/* timeout is active flag */
name|caddr_t
name|sc_ctty
decl_stmt|;
comment|/* user's controlling tty (vnode) */
name|int
name|sc_blks
decl_stmt|;
comment|/* number of I/O operations since open */
name|int
name|sc_softerrs
decl_stmt|;
comment|/* number of soft I/O errors since open */
block|}
name|tj_softc
index|[
name|NTJ
index|]
struct|;
end_struct

begin_comment
comment|/*  * Internal per/slave states found in sc_state  */
end_comment

begin_define
define|#
directive|define
name|SSEEK
value|1
end_define

begin_comment
comment|/* seeking */
end_comment

begin_define
define|#
directive|define
name|SIO
value|2
end_define

begin_comment
comment|/* doing sequential I/O */
end_comment

begin_define
define|#
directive|define
name|SCOM
value|3
end_define

begin_comment
comment|/* sending a control command */
end_comment

begin_define
define|#
directive|define
name|SREW
value|4
end_define

begin_comment
comment|/* doing a rewind op */
end_comment

begin_define
define|#
directive|define
name|SERASE
value|5
end_define

begin_comment
comment|/* erase inter-record gap */
end_comment

begin_define
define|#
directive|define
name|SERASED
value|6
end_define

begin_comment
comment|/* erased inter-record gap */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|utprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|utintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The SI documentation says you must set the RDY bit 	 * (even though it's read-only) to force an interrupt. 	 */
operator|(
operator|(
expr|struct
name|utdevice
operator|*
operator|)
name|reg
operator|)
operator|->
name|utcs1
operator|=
name|UT_IE
operator||
name|UT_NOP
operator||
name|UT_RDY
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|utdevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|utslave
argument_list|(
argument|ui
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * A real TU45 would support the slave present bit 	 * int the drive type register, but this thing doesn't, 	 * so there's no way to determine if a slave is present or not. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|utattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tjtout
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|=
name|ui
operator|->
name|ui_mi
operator|->
name|um_ctlr
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Open the device with exclusive access.  */
end_comment

begin_macro
name|utopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|tjunit
init|=
name|TJUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|tj_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|olddens
decl_stmt|,
name|dens
decl_stmt|,
name|error
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
if|if
condition|(
name|tjunit
operator|>=
name|NTJ
operator|||
operator|(
name|ui
operator|=
name|tjdinfo
index|[
name|tjunit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|=
operator|&
name|tj_softc
index|[
name|tjunit
index|]
operator|)
operator|->
name|sc_openf
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|->
name|sc_openf
operator|=
literal|1
expr_stmt|;
name|olddens
operator|=
name|sc
operator|->
name|sc_dens
expr_stmt|;
name|dens
operator|=
name|sc
operator|->
name|sc_dens
operator|=
name|utdens
index|[
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
operator|(
name|T_1600BPI
operator||
name|T_6250BPI
operator|)
operator|)
operator|>>
literal|3
index|]
operator||
name|PDP11FMT
operator||
operator|(
name|ui
operator|->
name|ui_slave
operator|&
literal|07
operator|)
expr_stmt|;
name|get
label|:
name|utcommand
argument_list|(
name|dev
argument_list|,
name|UT_SENSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dsreg
operator|&
name|UTDS_PIP
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
operator|(
name|PZERO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
name|devopn
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
goto|goto
name|get
goto|;
block|}
name|sc
operator|->
name|sc_dens
operator|=
name|olddens
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_dsreg
operator|&
name|UTDS_MOL
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_openf
operator|=
literal|0
expr_stmt|;
name|uprintf
argument_list|(
literal|"tj%d: not online\n"
argument_list|,
name|tjunit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_dsreg
operator|&
name|UTDS_WRL
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_openf
operator|=
literal|0
expr_stmt|;
name|uprintf
argument_list|(
literal|"tj%d: no write ring\n"
argument_list|,
name|tjunit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_dsreg
operator|&
name|UTDS_BOT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
name|dens
operator|!=
name|sc
operator|->
name|sc_dens
condition|)
block|{
name|sc
operator|->
name|sc_openf
operator|=
literal|0
expr_stmt|;
name|uprintf
argument_list|(
literal|"tj%d: can't change density in mid-tape\n"
argument_list|,
name|tjunit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_blkno
operator|=
operator|(
name|daddr_t
operator|)
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_nxrec
operator|=
name|INF
expr_stmt|;
name|sc
operator|->
name|sc_lastiow
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_blks
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_softerrs
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_dens
operator|=
name|dens
expr_stmt|;
name|sc
operator|->
name|sc_ctty
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&
name|SCTTY
condition|?
name|u
operator|.
name|u_procp
operator|->
name|p_session
operator|->
name|s_ttyvp
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * For 6250 bpi take exclusive use of the UNIBUS. 	 */
name|ui
operator|->
name|ui_driver
operator|->
name|ud_xclu
operator|=
operator|(
name|dens
operator|&
operator|(
name|T_1600BPI
operator||
name|T_6250BPI
operator|)
operator|)
operator|==
name|T_6250BPI
expr_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tact
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_timo
operator|=
name|INF
expr_stmt|;
name|sc
operator|->
name|sc_tact
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|uttimer
argument_list|,
operator|(
name|caddr_t
operator|)
name|dev
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|utclose
argument_list|(
name|dev
argument_list|,
name|flag
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|flag
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tj_softc
modifier|*
name|sc
init|=
operator|&
name|tj_softc
index|[
name|TJUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|FWRITE
operator|||
operator|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
name|sc
operator|->
name|sc_lastiow
operator|)
condition|)
block|{
name|utcommand
argument_list|(
name|dev
argument_list|,
name|UT_WEOF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|utcommand
argument_list|(
name|dev
argument_list|,
name|UT_WEOF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|utcommand
argument_list|(
name|dev
argument_list|,
name|UT_SREV
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_NOREWIND
operator|)
operator|==
literal|0
condition|)
name|utcommand
argument_list|(
name|dev
argument_list|,
name|UT_REW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_blks
operator|>
literal|100
operator|&&
name|sc
operator|->
name|sc_softerrs
operator|>
name|sc
operator|->
name|sc_blks
operator|/
literal|100
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"tj%d: %d soft errors in %d blocks\n"
argument_list|,
name|TJUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_softerrs
argument_list|,
name|sc
operator|->
name|sc_blks
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_openf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|utcommand
argument_list|(
argument|dev
argument_list|,
argument|com
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|com
decl_stmt|,
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|bp
operator|=
operator|&
name|cutbuf
index|[
name|UTUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
while|while
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_repcnt
operator|==
literal|0
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
condition|)
break|break;
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_command
operator|=
name|com
expr_stmt|;
name|bp
operator|->
name|b_repcnt
operator|=
name|count
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
literal|0
expr_stmt|;
name|utstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|iowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
name|B_ERROR
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Queue a tape operation.  */
end_comment

begin_expr_stmt
name|utstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|tjunit
init|=
name|TJUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Put transfer at end of unit queue 	 */
name|dp
operator|=
operator|&
name|tjutab
index|[
name|tjunit
index|]
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
name|NULL
expr_stmt|;
name|um
operator|=
name|tjdinfo
index|[
name|tjunit
index|]
operator|->
name|ui_mi
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
operator|==
name|NULL
condition|)
block|{
name|dp
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
comment|/* 		 * Transport not active, so... 		 * put at end of controller queue 		 */
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
block|}
else|else
name|dp
operator|->
name|b_actl
operator|->
name|av_forw
operator|=
name|bp
expr_stmt|;
name|dp
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
comment|/* 	 * If the controller is not busy, set it going. 	 */
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_state
operator|==
literal|0
condition|)
name|utstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|utstart
argument_list|(
name|um
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|utdevice
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|tj_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|int
name|tjunit
decl_stmt|;
name|daddr_t
name|blkno
decl_stmt|;
name|loop
label|:
comment|/* 	 * Scan controller queue looking for units with 	 * transaction queues to dispatch 	 */
if|if
condition|(
operator|(
name|dp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|addr
operator|=
operator|(
expr|struct
name|utdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
name|tjunit
operator|=
name|TJUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|ui
operator|=
name|tjdinfo
index|[
name|tjunit
index|]
expr_stmt|;
name|sc
operator|=
operator|&
name|tj_softc
index|[
name|tjunit
index|]
expr_stmt|;
comment|/* note slave select, density, and format were merged on open */
name|addr
operator|->
name|uttc
operator|=
name|sc
operator|->
name|sc_dens
expr_stmt|;
name|sc
operator|->
name|sc_dsreg
operator|=
name|addr
operator|->
name|utds
expr_stmt|;
name|sc
operator|->
name|sc_erreg
operator|=
name|addr
operator|->
name|uter
expr_stmt|;
name|sc
operator|->
name|sc_resid
operator|=
name|MASKREG
argument_list|(
name|addr
operator|->
name|utfc
argument_list|)
expr_stmt|;
comment|/* 	 * Default is that last command was NOT a write command; 	 * if we do a write command we will notice this in utintr(). 	 */
name|sc
operator|->
name|sc_lastiow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_openf
operator|<
literal|0
operator|||
operator|(
name|addr
operator|->
name|utds
operator|&
name|UTDS_MOL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Have had a hard error on a non-raw tape 		 * or the tape unit is now unavailable 		 * (e.g. taken off line). 		 */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|bp
operator|==
operator|&
name|cutbuf
index|[
name|UTUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
condition|)
block|{
comment|/* 		 * Execute a control operation with the specified 		 * count. 		 */
if|if
condition|(
name|bp
operator|->
name|b_command
operator|==
name|UT_SENSE
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|bp
operator|->
name|b_command
operator|==
name|UT_SFORW
operator|&&
operator|(
name|addr
operator|->
name|utds
operator|&
name|UTDS_EOT
operator|)
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 		 * Set next state; handle timeouts 		 */
if|if
condition|(
name|bp
operator|->
name|b_command
operator|==
name|UT_REW
condition|)
block|{
name|um
operator|->
name|um_tab
operator|.
name|b_state
operator|=
name|SREW
expr_stmt|;
name|sc
operator|->
name|sc_timo
operator|=
literal|5
operator|*
literal|60
expr_stmt|;
block|}
else|else
block|{
name|um
operator|->
name|um_tab
operator|.
name|b_state
operator|=
name|SCOM
expr_stmt|;
name|sc
operator|->
name|sc_timo
operator|=
name|imin
argument_list|(
name|imax
argument_list|(
literal|10
operator|*
operator|(
name|int
operator|)
operator|-
name|bp
operator|->
name|b_repcnt
argument_list|,
literal|60
argument_list|)
argument_list|,
literal|5
operator|*
literal|60
argument_list|)
expr_stmt|;
block|}
comment|/* NOTE: this depends on the ut command values */
if|if
condition|(
name|bp
operator|->
name|b_command
operator|>=
name|UT_SFORW
operator|&&
name|bp
operator|->
name|b_command
operator|<=
name|UT_SREVF
condition|)
name|addr
operator|->
name|utfc
operator|=
operator|-
name|bp
operator|->
name|b_repcnt
expr_stmt|;
goto|goto
name|dobpcmd
goto|;
block|}
comment|/* 	 * For raw I/O, save the current block 	 * number in case we have to retry. 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_RAW
condition|)
block|{
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_blkno
operator|=
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nxrec
operator|=
name|sc
operator|->
name|sc_blkno
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Handle boundary cases for operation 		 * on non-raw tapes. 		 */
if|if
condition|(
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|>
name|sc
operator|->
name|sc_nxrec
condition|)
block|{
comment|/* can't read past end of file */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|==
name|sc
operator|->
name|sc_nxrec
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|)
block|{
comment|/* 			 * Reading at end of file returns 0 bytes. 			 */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_nxrec
operator|=
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 * If the tape is correctly positioned, set up all the 	 * registers but the csr, and give control over to the 	 * UNIBUS adaptor routines, to wait for resources to 	 * start I/O. 	 */
if|if
condition|(
operator|(
name|blkno
operator|=
name|sc
operator|->
name|sc_blkno
operator|)
operator|==
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
condition|)
block|{
name|addr
operator|->
name|utwc
operator|=
operator|-
operator|(
operator|(
operator|(
name|bp
operator|->
name|b_bcount
operator|)
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|addr
operator|->
name|utfc
operator|=
operator|-
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * On write error retries erase the 			 * inter-record gap before rewriting. 			 */
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
condition|)
block|{
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_state
operator|!=
name|SERASED
condition|)
block|{
name|um
operator|->
name|um_tab
operator|.
name|b_state
operator|=
name|SERASE
expr_stmt|;
name|sc
operator|->
name|sc_timo
operator|=
literal|60
expr_stmt|;
name|addr
operator|->
name|utcs1
operator|=
name|UT_ERASE
operator||
name|UT_IE
operator||
name|UT_GO
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|addr
operator|->
name|utds
operator|&
name|UTDS_EOT
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_state
operator|=
literal|0
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|um
operator|->
name|um_cmd
operator|=
name|UT_WCOM
expr_stmt|;
block|}
else|else
name|um
operator|->
name|um_cmd
operator|=
name|UT_RCOM
expr_stmt|;
name|sc
operator|->
name|sc_timo
operator|=
literal|60
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_state
operator|=
name|SIO
expr_stmt|;
operator|(
name|void
operator|)
name|ubago
argument_list|(
name|ui
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Tape positioned incorrectly; seek forwards or 	 * backwards to the correct spot.  This happens for 	 * raw tapes only on error retries. 	 */
name|um
operator|->
name|um_tab
operator|.
name|b_state
operator|=
name|SSEEK
expr_stmt|;
if|if
condition|(
name|blkno
operator|<
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
condition|)
block|{
name|addr
operator|->
name|utfc
operator|=
name|blkno
operator|-
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_command
operator|=
name|UT_SFORW
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|->
name|utfc
operator|=
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|-
name|blkno
expr_stmt|;
name|bp
operator|->
name|b_command
operator|=
name|UT_SREV
expr_stmt|;
block|}
name|sc
operator|->
name|sc_timo
operator|=
name|imin
argument_list|(
name|imax
argument_list|(
literal|10
operator|*
operator|-
name|addr
operator|->
name|utfc
argument_list|,
literal|60
argument_list|)
argument_list|,
literal|5
operator|*
literal|60
argument_list|)
expr_stmt|;
name|dobpcmd
label|:
comment|/* 	 * Perform the command setup in bp. 	 */
name|addr
operator|->
name|utcs1
operator|=
name|bp
operator|->
name|b_command
operator||
name|UT_IE
operator||
name|UT_GO
expr_stmt|;
return|return;
name|next
label|:
comment|/* 	 * Advance to the next command in the slave queue, 	 * posting notice and releasing resources as needed. 	 */
if|if
condition|(
name|um
operator|->
name|um_ubinfo
condition|)
name|ubadone
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/*  * Start operation on controller --  * UNIBUS resources have been allocated.  */
end_comment

begin_expr_stmt
name|utdgo
argument_list|(
name|um
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|utdevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|utdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
decl_stmt|;
name|addr
operator|->
name|utba
operator|=
operator|(
name|u_short
operator|)
name|um
operator|->
name|um_ubinfo
expr_stmt|;
name|addr
operator|->
name|utcs1
operator|=
name|um
operator|->
name|um_cmd
operator||
operator|(
operator|(
name|um
operator|->
name|um_ubinfo
operator|>>
literal|8
operator|)
operator|&
literal|0x300
operator|)
operator||
name|UT_IE
operator||
name|UT_GO
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Ut interrupt handler  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|utintr
argument_list|(
argument|ut11
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ut11
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
init|=
name|utminfo
index|[
name|ut11
index|]
decl_stmt|;
specifier|register
name|struct
name|utdevice
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|tj_softc
modifier|*
name|sc
decl_stmt|;
name|u_short
name|tjunit
decl_stmt|,
name|cs2
decl_stmt|,
name|cs1
decl_stmt|;
specifier|register
name|state
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|tjunit
operator|=
name|TJUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|utdevice
operator|*
operator|)
name|tjdinfo
index|[
name|tjunit
index|]
operator|->
name|ui_addr
expr_stmt|;
name|sc
operator|=
operator|&
name|tj_softc
index|[
name|tjunit
index|]
expr_stmt|;
comment|/* 	 * Record status... 	 */
name|sc
operator|->
name|sc_timo
operator|=
name|INF
expr_stmt|;
name|sc
operator|->
name|sc_dsreg
operator|=
name|addr
operator|->
name|utds
expr_stmt|;
name|sc
operator|->
name|sc_erreg
operator|=
name|addr
operator|->
name|uter
expr_stmt|;
name|sc
operator|->
name|sc_resid
operator|=
name|MASKREG
argument_list|(
name|addr
operator|->
name|utfc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_lastiow
operator|=
literal|1
expr_stmt|;
name|state
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_state
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_state
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check for errors... 	 */
if|if
condition|(
operator|(
name|addr
operator|->
name|utds
operator|&
name|UTDS_ERR
operator|)
operator|||
operator|(
name|addr
operator|->
name|utcs1
operator|&
name|UT_TRE
operator|)
condition|)
block|{
comment|/* 		 * To clear the ERR bit, we must issue a drive clear 		 * command, and to clear the TRE bit we must set the 		 * controller clear bit. 		 */
name|cs2
operator|=
name|addr
operator|->
name|utcs2
expr_stmt|;
if|if
condition|(
operator|(
name|cs1
operator|=
name|addr
operator|->
name|utcs1
operator|)
operator|&
name|UT_TRE
condition|)
name|addr
operator|->
name|utcs2
operator||=
name|UTCS2_CLR
expr_stmt|;
comment|/* is this dangerous ?? */
while|while
condition|(
operator|(
name|addr
operator|->
name|utcs1
operator|&
name|UT_RDY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|addr
operator|->
name|utcs1
operator|=
name|UT_CLEAR
operator||
name|UT_GO
expr_stmt|;
comment|/* 		 * If we were reading at 1600 or 6250 bpi and the error 		 * was corrected, then don't consider this an error. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_erreg
operator|&
name|UTER_COR
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|&&
operator|(
name|addr
operator|->
name|uttc
operator|&
name|UTTC_DEN
operator|)
operator|!=
name|UT_NRZI
condition|)
block|{
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"ut%d: soft error bn%d cs1=%b er=%b cs2=%b ds=%b\n"
argument_list|,
name|tjunit
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|cs1
argument_list|,
name|UT_BITS
argument_list|,
name|sc
operator|->
name|sc_erreg
argument_list|,
name|UTER_BITS
argument_list|,
name|cs2
argument_list|,
name|UTCS2_BITS
argument_list|,
name|sc
operator|->
name|sc_dsreg
argument_list|,
name|UTDS_BITS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_erreg
operator|&=
operator|~
name|UTER_COR
expr_stmt|;
block|}
comment|/* 		 * If we were reading from a raw tape and the only error 		 * was that the record was too long, then we don't consider 		 * this an error. 		 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_READ
operator||
name|B_RAW
operator|)
operator|)
operator|==
operator|(
name|B_READ
operator||
name|B_RAW
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_erreg
operator|&
name|UTER_FCE
operator|)
condition|)
name|sc
operator|->
name|sc_erreg
operator|&=
operator|~
name|UTER_FCE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_erreg
operator|==
literal|0
condition|)
goto|goto
name|ignoreerr
goto|;
comment|/* 		 * Fix up errors which occur due to backspacing 		 * "over" the front of the tape. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_dsreg
operator|&
name|UTDS_BOT
operator|)
operator|&&
name|bp
operator|->
name|b_command
operator|==
name|UT_SREV
operator|&&
operator|(
operator|(
name|sc
operator|->
name|sc_erreg
operator|&=
operator|~
operator|(
name|UTER_NEF
operator||
name|UTER_FCE
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|opdone
goto|;
comment|/* 		 * Retry soft errors up to 8 times 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_erreg
operator|&
name|UTER_HARD
operator|)
operator|==
literal|0
operator|&&
name|state
operator|==
name|SIO
condition|)
block|{
if|if
condition|(
operator|++
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|<
literal|7
condition|)
block|{
name|sc
operator|->
name|sc_blkno
operator|++
expr_stmt|;
name|ubadone
argument_list|(
name|um
argument_list|)
expr_stmt|;
goto|goto
name|opcont
goto|;
block|}
block|}
comment|/* 		 * Hard or non-I/O errors on non-raw tape 		 * cause it to close. 		 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_RAW
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_openf
operator|>
literal|0
condition|)
name|sc
operator|->
name|sc_openf
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Couldn't recover error. 		 */
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"ut%d: hard error bn%d cs1=%b er=%b cs2=%b ds=%b\n"
argument_list|,
name|tjunit
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|cs1
argument_list|,
name|UT_BITS
argument_list|,
name|sc
operator|->
name|sc_erreg
argument_list|,
name|UTER_BITS
argument_list|,
name|cs2
argument_list|,
name|UTCS2_BITS
argument_list|,
name|sc
operator|->
name|sc_dsreg
argument_list|,
name|UTDS_BITS
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|opdone
goto|;
block|}
name|ignoreerr
label|:
comment|/* 	 * If we hit a tape mark update our position. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_dsreg
operator|&
name|UTDS_TM
operator|&&
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
comment|/* 		 * Set blkno and nxrec 		 */
if|if
condition|(
name|bp
operator|==
operator|&
name|cutbuf
index|[
name|UTUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_blkno
operator|>
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_nxrec
operator|=
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|-
name|addr
operator|->
name|utfc
expr_stmt|;
name|sc
operator|->
name|sc_blkno
operator|=
name|sc
operator|->
name|sc_nxrec
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_blkno
operator|=
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|+
name|addr
operator|->
name|utfc
expr_stmt|;
name|sc
operator|->
name|sc_nxrec
operator|=
name|sc
operator|->
name|sc_blkno
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|sc
operator|->
name|sc_nxrec
operator|=
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
comment|/* 		 * Note: if we get a tape mark on a read, the 		 * frame count register will be zero, so b_resid 		 * will be calculated correctly below. 		 */
goto|goto
name|opdone
goto|;
block|}
comment|/* 	 * Advance tape control FSM. 	 */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SIO
case|:
comment|/* read/write increments tape block # */
name|sc
operator|->
name|sc_blkno
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_blks
operator|++
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
condition|)
name|sc
operator|->
name|sc_softerrs
operator|++
expr_stmt|;
break|break;
case|case
name|SCOM
case|:
comment|/* motion commands update current position */
if|if
condition|(
name|bp
operator|==
operator|&
name|cutbuf
index|[
name|UTUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
condition|)
switch|switch
condition|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_command
condition|)
block|{
case|case
name|UT_SFORW
case|:
name|sc
operator|->
name|sc_blkno
operator|-=
name|bp
operator|->
name|b_repcnt
expr_stmt|;
break|break;
case|case
name|UT_SREV
case|:
name|sc
operator|->
name|sc_blkno
operator|+=
name|bp
operator|->
name|b_repcnt
expr_stmt|;
break|break;
case|case
name|UT_REWOFFL
case|:
name|addr
operator|->
name|utcs1
operator|=
name|UT_CLEAR
operator||
name|UT_GO
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SSEEK
case|:
name|sc
operator|->
name|sc_blkno
operator|=
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
goto|goto
name|opcont
goto|;
case|case
name|SERASE
case|:
comment|/* 		 * Completed erase of the inter-record gap due to a 		 * write error; now retry the write operation. 		 */
name|um
operator|->
name|um_tab
operator|.
name|b_state
operator|=
name|SERASED
expr_stmt|;
goto|goto
name|opcont
goto|;
case|case
name|SREW
case|:
comment|/* clear attention bit */
name|addr
operator|->
name|utcs1
operator|=
name|UT_CLEAR
operator||
name|UT_GO
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"bad state %d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"utintr"
argument_list|)
expr_stmt|;
block|}
name|opdone
label|:
comment|/* 	 * Reset error count and remove 	 * from device queue 	 */
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
comment|/* 	 * For read command, frame count register contains 	 * actual length of tape record.  Otherwise, it 	 * holds negative residual count. 	 */
if|if
condition|(
name|state
operator|==
name|SIO
operator|&&
name|um
operator|->
name|um_cmd
operator|==
name|UT_RCOM
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|MASKREG
argument_list|(
name|addr
operator|->
name|utfc
argument_list|)
condition|)
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|MASKREG
argument_list|(
name|addr
operator|->
name|utfc
argument_list|)
expr_stmt|;
block|}
else|else
name|bp
operator|->
name|b_resid
operator|=
name|MASKREG
argument_list|(
operator|-
name|addr
operator|->
name|utfc
argument_list|)
expr_stmt|;
name|ubadone
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Circulate slave to end of controller queue 	 * to give other slaves a chance 	 */
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
block|{
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
block|}
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
literal|0
condition|)
return|return;
name|opcont
label|:
name|utstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Watchdog timer routine.  */
end_comment

begin_macro
name|uttimer
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tj_softc
modifier|*
name|sc
init|=
operator|&
name|tj_softc
index|[
name|TJUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|short
name|x
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_timo
operator|!=
name|INF
operator|&&
operator|(
name|sc
operator|->
name|sc_timo
operator|-=
literal|5
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"tj%d: lost interrupt\n"
argument_list|,
name|TJUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_timo
operator|=
name|INF
expr_stmt|;
name|x
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|utintr
argument_list|(
name|UTUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
name|uttimer
argument_list|,
operator|(
name|caddr_t
operator|)
name|dev
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|utioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tj_softc
modifier|*
name|sc
init|=
operator|&
name|tj_softc
index|[
name|TJUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
operator|&
name|cutbuf
index|[
name|UTUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|callcount
expr_stmt|;
name|int
name|fcount
decl_stmt|;
name|struct
name|mtop
modifier|*
name|mtop
decl_stmt|;
name|struct
name|mtget
modifier|*
name|mtget
decl_stmt|;
comment|/* we depend of the values and order of the MT codes here */
specifier|static
name|utops
index|[]
operator|=
block|{
name|UT_WEOF
block|,
name|UT_SFORWF
block|,
name|UT_SREVF
block|,
name|UT_SFORW
block|,
name|UT_SREV
block|,
name|UT_REW
block|,
name|UT_REWOFFL
block|,
name|UT_SENSE
block|}
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCTOP
case|:
name|mtop
operator|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|mtop
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTWEOF
case|:
case|case
name|MTFSF
case|:
case|case
name|MTBSF
case|:
case|case
name|MTFSR
case|:
case|case
name|MTBSR
case|:
name|callcount
operator|=
name|mtop
operator|->
name|mt_count
expr_stmt|;
name|fcount
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MTREW
case|:
case|case
name|MTOFFL
case|:
case|case
name|MTNOP
case|:
name|callcount
operator|=
literal|1
expr_stmt|;
name|fcount
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|callcount
operator|<=
literal|0
operator|||
name|fcount
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
while|while
condition|(
operator|--
name|callcount
operator|>=
literal|0
condition|)
block|{
name|utcommand
argument_list|(
name|dev
argument_list|,
name|utops
index|[
name|mtop
operator|->
name|mt_op
index|]
argument_list|,
name|fcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_dsreg
operator|&
name|UTDS_BOT
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|geterror
argument_list|(
name|bp
argument_list|)
operator|)
return|;
case|case
name|MTIOCGET
case|:
name|mtget
operator|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|data
expr_stmt|;
name|mtget
operator|->
name|mt_dsreg
operator|=
name|sc
operator|->
name|sc_dsreg
expr_stmt|;
name|mtget
operator|->
name|mt_erreg
operator|=
name|sc
operator|->
name|sc_erreg
expr_stmt|;
name|mtget
operator|->
name|mt_resid
operator|=
name|sc
operator|->
name|sc_resid
expr_stmt|;
name|mtget
operator|->
name|mt_type
operator|=
name|MT_ISUT
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|utreset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|ut11
operator|,
name|tjunit
expr_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|ut11
operator|=
literal|0
init|;
name|ut11
operator|<
name|NUT
condition|;
name|ut11
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|um
operator|=
name|utminfo
index|[
name|ut11
index|]
operator|)
operator|==
literal|0
operator|||
name|um
operator|->
name|um_alive
operator|==
literal|0
operator|||
name|um
operator|->
name|um_ubanum
operator|!=
name|uban
condition|)
continue|continue;
name|printf
argument_list|(
literal|" ut%d"
argument_list|,
name|ut11
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_state
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_ubinfo
condition|)
block|{
name|printf
argument_list|(
literal|"<%d>"
argument_list|,
operator|(
name|um
operator|->
name|um_ubinfo
operator|>>
literal|28
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_ubinfo
operator|=
literal|0
expr_stmt|;
block|}
operator|(
operator|(
expr|struct
name|utdevice
operator|*
operator|)
operator|(
name|um
operator|->
name|um_addr
operator|)
operator|)
operator|->
name|utcs1
operator|=
name|UT_CLEAR
operator||
name|UT_GO
expr_stmt|;
operator|(
operator|(
expr|struct
name|utdevice
operator|*
operator|)
operator|(
name|um
operator|->
name|um_addr
operator|)
operator|)
operator|->
name|utcs2
operator||=
name|UTCS2_CLR
expr_stmt|;
for|for
control|(
name|tjunit
operator|=
literal|0
init|;
name|tjunit
operator|<
name|NTJ
condition|;
name|tjunit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ui
operator|=
name|tjdinfo
index|[
name|tjunit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_mi
operator|!=
name|um
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
continue|continue;
name|dp
operator|=
operator|&
name|tjutab
index|[
name|tjunit
index|]
expr_stmt|;
name|dp
operator|->
name|b_state
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_forw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
if|if
condition|(
name|tj_softc
index|[
name|tjunit
index|]
operator|.
name|sc_openf
operator|>
literal|0
condition|)
name|tj_softc
index|[
name|tjunit
index|]
operator|.
name|sc_openf
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|utstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Do a stand-alone core dump to tape --  * from here down, routines are used only in dump context  */
end_comment

begin_define
define|#
directive|define
name|DBSIZE
value|20
end_define

begin_macro
name|utdump
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|uba_regs
modifier|*
name|up
decl_stmt|;
specifier|register
name|struct
name|utdevice
modifier|*
name|addr
decl_stmt|;
name|int
name|blk
decl_stmt|,
name|num
init|=
name|maxfree
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|phys
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((b)((int)(a)&0x7fffffff))
if|if
condition|(
name|tjdinfo
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ui
operator|=
name|phys
argument_list|(
name|tjdinfo
index|[
literal|0
index|]
argument_list|,
expr|struct
name|uba_device
operator|*
argument_list|)
expr_stmt|;
name|up
operator|=
name|phys
argument_list|(
name|ui
operator|->
name|ui_hd
argument_list|,
expr|struct
name|uba_hd
operator|*
argument_list|)
operator|->
name|uh_physuba
expr_stmt|;
name|ubainit
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|utdevice
operator|*
operator|)
name|ui
operator|->
name|ui_physaddr
expr_stmt|;
name|utwait
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * Be sure to set the appropriate density here.  We use 	 * 6250, but maybe it should be done at 1600 to insure the 	 * tape can be read by most any other tape drive available. 	 */
name|addr
operator|->
name|uttc
operator|=
name|UT_GCR
operator||
name|PDP11FMT
expr_stmt|;
comment|/* implicit slave 0 or-ed in */
name|addr
operator|->
name|utcs1
operator|=
name|UT_CLEAR
operator||
name|UT_GO
expr_stmt|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|blk
operator|=
name|num
operator|>
name|DBSIZE
condition|?
name|DBSIZE
else|:
name|num
expr_stmt|;
name|utdwrite
argument_list|(
name|start
argument_list|,
name|blk
argument_list|,
name|addr
argument_list|,
name|up
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|->
name|utds
operator|&
name|UTDS_ERR
operator|)
operator|||
operator|(
name|addr
operator|->
name|utcs1
operator|&
name|UT_TRE
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|start
operator|+=
name|blk
expr_stmt|;
name|num
operator|-=
name|blk
expr_stmt|;
block|}
name|uteof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|uteof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|utwait
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|->
name|utds
operator|&
name|UTDS_ERR
operator|)
operator|||
operator|(
name|addr
operator|->
name|utcs1
operator|&
name|UT_TRE
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|addr
operator|->
name|utcs1
operator|=
name|UT_REW
operator||
name|UT_GO
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|utdwrite
argument_list|(
name|dbuf
argument_list|,
name|num
argument_list|,
name|addr
argument_list|,
name|up
argument_list|)
specifier|register
name|dbuf
operator|,
name|num
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|utdevice
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_regs
modifier|*
name|up
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|io
decl_stmt|;
specifier|register
name|int
name|npf
decl_stmt|;
name|utwait
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|io
operator|=
name|up
operator|->
name|uba_map
expr_stmt|;
name|npf
operator|=
name|num
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|npf
operator|!=
literal|0
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|io
operator|++
operator|=
operator|(
name|dbuf
operator|++
operator||
operator|(
literal|1
operator|<<
name|UBAMR_DPSHIFT
operator|)
operator||
name|UBAMR_MRV
operator|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|io
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|utwc
operator|=
operator|-
operator|(
operator|(
name|num
operator|*
name|NBPG
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|addr
operator|->
name|utfc
operator|=
operator|-
operator|(
name|num
operator|*
name|NBPG
operator|)
expr_stmt|;
name|addr
operator|->
name|utba
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|utcs1
operator|=
name|UT_WCOM
operator||
name|UT_GO
expr_stmt|;
block|}
end_block

begin_macro
name|utwait
argument_list|(
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|utdevice
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|s
expr_stmt|;
do|do
name|s
operator|=
name|addr
operator|->
name|utds
expr_stmt|;
do|while
condition|(
operator|(
name|s
operator|&
name|UTDS_DRY
operator|)
operator|==
literal|0
condition|)
do|;
block|}
end_block

begin_macro
name|uteof
argument_list|(
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|utdevice
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|utwait
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|->
name|utcs1
operator|=
name|UT_WEOF
operator||
name|UT_GO
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

