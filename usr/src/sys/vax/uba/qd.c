begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  * 	@(#)qd.c	1.3  Berkeley  %G%  *  * derived from: "@(#)qd.c	1.40	ULTRIX	10/2/86";  */
end_comment

begin_comment
comment|/************************************************************************ *									* *			Copyright (c) 1985, 1986 by			* *		Digital Equipment Corporation, Maynard, MA		* *			All rights reserved.				* *									* *   This software is furnished under a license and may be used and	* *   copied  only  in accordance with the terms of such license and	* *   with the  inclusion  of  the  above  copyright  notice.   This	* *   software  or  any  other copies thereof may not be provided or	* *   otherwise made available to any other person.  No title to and	* *   ownership of the software is hereby transferred.			* *									* *   The information in this software is subject to change  without	* *   notice  and should not be construed as a commitment by Digital	* *   Equipment Corporation.						* *									* *   Digital assumes no responsibility for the use  or  reliability	* *   of its software on equipment which is not supplied by Digital.	* *									* *************************************************************************/
end_comment

begin_comment
comment|/*  * qd.c - QDSS display driver  */
end_comment

begin_include
include|#
directive|include
file|"qd.h"
end_include

begin_if
if|#
directive|if
name|NQD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../machine/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"qdioctl.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"clist.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"ubareg.h"
end_include

begin_include
include|#
directive|include
file|"ubavar.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"qduser.h"
end_include

begin_comment
comment|/* definitions shared with client */
end_comment

begin_include
include|#
directive|include
file|"qdreg.h"
end_include

begin_comment
comment|/* * QDSS driver status flags for tracking operational state  */
end_comment

begin_struct
struct|struct
name|qdflags
block|{
name|u_int
name|inuse
decl_stmt|;
comment|/* which minor dev's are in use now */
name|u_int
name|config
decl_stmt|;
comment|/* I/O page register content */
name|u_int
name|mapped
decl_stmt|;
comment|/* user mapping status word */
name|u_int
name|kernel_loop
decl_stmt|;
comment|/* if kernel console is redirected */
name|u_int
name|user_dma
decl_stmt|;
comment|/* DMA from user space in progress */
name|u_short
name|pntr_id
decl_stmt|;
comment|/* type code of pointing device */
name|u_short
name|duart_imask
decl_stmt|;
comment|/* shadowing for duart intrpt mask reg */
name|u_short
name|adder_ie
decl_stmt|;
comment|/* shadowing for adder intrpt enbl reg */
name|u_short
name|curs_acc
decl_stmt|;
comment|/* cursor acceleration factor */
name|u_short
name|curs_thr
decl_stmt|;
comment|/* cursor acceleration threshold level */
name|u_short
name|tab_res
decl_stmt|;
comment|/* tablet resolution factor */
name|u_short
name|selmask
decl_stmt|;
comment|/* mask for active qd select entries */
block|}
struct|;
end_struct

begin_comment
comment|/* #define POSIXTTY (4.4BSD) */
end_comment

begin_comment
comment|/* bit definitions for "inuse" entry  */
end_comment

begin_define
define|#
directive|define
name|CONS_DEV
value|0x01
end_define

begin_define
define|#
directive|define
name|ALTCONS_DEV
value|0x02
end_define

begin_define
define|#
directive|define
name|GRAPHIC_DEV
value|0x04
end_define

begin_comment
comment|/* bit definitions for 'mapped' member of flag structure */
end_comment

begin_define
define|#
directive|define
name|MAPDEV
value|0x01
end_define

begin_comment
comment|/* hardware is mapped */
end_comment

begin_define
define|#
directive|define
name|MAPDMA
value|0x02
end_define

begin_comment
comment|/* DMA buffer mapped */
end_comment

begin_define
define|#
directive|define
name|MAPEQ
value|0x04
end_define

begin_comment
comment|/* event queue buffer mapped */
end_comment

begin_define
define|#
directive|define
name|MAPSCR
value|0x08
end_define

begin_comment
comment|/* scroll param area mapped */
end_comment

begin_define
define|#
directive|define
name|MAPCOLOR
value|0x10
end_define

begin_comment
comment|/* color map writing buffer mapped */
end_comment

begin_comment
comment|/* bit definitions for 'selmask' member of qdflag structure */
end_comment

begin_define
define|#
directive|define
name|SEL_READ
value|0x01
end_define

begin_comment
comment|/* read select is active */
end_comment

begin_define
define|#
directive|define
name|SEL_WRITE
value|0x02
end_define

begin_comment
comment|/* write select is active */
end_comment

begin_comment
comment|/* * constants used in shared memory operations  */
end_comment

begin_define
define|#
directive|define
name|EVENT_BUFSIZE
value|1024
end_define

begin_comment
comment|/* # of bytes per device's event buffer */
end_comment

begin_define
define|#
directive|define
name|MAXEVENTS
value|( (EVENT_BUFSIZE - sizeof(struct qdinput))	 \ 		     / sizeof(struct _vs_event) )
end_define

begin_define
define|#
directive|define
name|DMA_BUFSIZ
value|(1024 * 3)
end_define

begin_define
define|#
directive|define
name|COLOR_BUFSIZ
value|((sizeof(struct color_buf) + 512)& ~0x01FF)
end_define

begin_comment
comment|/* * reference to an array of "uba_device" structures built by the auto * configuration program.  The uba_device structure decribes the device * sufficiently for the driver to talk to it.  The auto configuration code * fills in the uba_device structures (located in ioconf.c) from user * maintained info.   */
end_comment

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|qdinfo
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pntrs to each QDSS's */
end_comment

begin_comment
comment|/* uba structures  */
end_comment

begin_decl_stmt
name|struct
name|tty
name|qd_tty
index|[
name|NQD
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* teletype structures for each.. */
end_comment

begin_comment
comment|/* ..possible minor device */
end_comment

begin_decl_stmt
name|struct
name|qd_softc
name|qd_softc
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * static storage used by multiple functions in this code    */
end_comment

begin_decl_stmt
name|int
name|Qbus_unmap
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Qbus mapper release code */
end_comment

begin_decl_stmt
name|struct
name|qdflags
name|qdflags
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* QDSS device status flags */
end_comment

begin_decl_stmt
name|struct
name|qdmap
name|qdmap
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* QDSS register map structure */
end_comment

begin_decl_stmt
name|caddr_t
name|qdbase
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base address of each QDSS unit */
end_comment

begin_decl_stmt
name|struct
name|buf
name|qdbuf
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buf structs used by strategy */
end_comment

begin_decl_stmt
name|char
name|one_only
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lock for single process access */
end_comment

begin_comment
comment|/* * The array "event_shared[]" is made up of a number of event queue buffers * equal to the number of QDSS's configured into the running kernel (NQD). * Each event queue buffer begins with an event queue header (struct qdinput) * followed by a group of event queue entries (struct _vs_event).  The array * "*eq_header[]" is an array of pointers to the start of each event queue * buffer in "event_shared[]".   */
end_comment

begin_define
define|#
directive|define
name|EQSIZE
value|((EVENT_BUFSIZE * NQD) + 512)
end_define

begin_decl_stmt
name|char
name|event_shared
index|[
name|EQSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reserve space for event bufs */
end_comment

begin_decl_stmt
name|struct
name|qdinput
modifier|*
name|eq_header
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* event queue header pntrs */
end_comment

begin_comment
comment|/* * This allocation method reserves enough memory pages for NQD shared DMA I/O * buffers.  Each buffer must consume an integral number of memory pages to * guarantee that a following buffer will begin on a page boundary.  Also, * enough space is allocated so that the FIRST I/O buffer can start at the * 1st page boundary after "&DMA_shared".  Page boundaries are used so that * memory protections can be turned on/off for individual buffers.  */
end_comment

begin_define
define|#
directive|define
name|IOBUFSIZE
value|((DMA_BUFSIZ * NQD) + 512)
end_define

begin_decl_stmt
name|char
name|DMA_shared
index|[
name|IOBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reserve I/O buffer space */
end_comment

begin_decl_stmt
name|struct
name|DMAreq_header
modifier|*
name|DMAheader
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DMA buffer header pntrs */
end_comment

begin_comment
comment|/* * The driver assists a client in scroll operations by loading dragon * registers from an interrupt service routine.	The loading is done using * parameters found in memory shrade between the driver and it's client. * The scroll parameter structures are ALL loacted in the same memory page * for reasons of memory economy.   */
end_comment

begin_decl_stmt
name|char
name|scroll_shared
index|[
literal|2
operator|*
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reserve space for scroll structs */
end_comment

begin_decl_stmt
name|struct
name|scroll
modifier|*
name|scroll
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to scroll structures */
end_comment

begin_comment
comment|/* * the driver is programmable to provide the user with color map write * services at VSYNC interrupt time.  At interrupt time the driver loads * the color map with any user-requested load data found in shared memory  */
end_comment

begin_define
define|#
directive|define
name|COLOR_SHARED
value|((COLOR_BUFSIZ * NQD) + 512)
end_define

begin_decl_stmt
name|char
name|color_shared
index|[
name|COLOR_SHARED
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* color bufs */
end_comment

begin_decl_stmt
name|struct
name|color_buf
modifier|*
name|color_buf
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to color bufs */
end_comment

begin_comment
comment|/* * mouse input event structures  */
end_comment

begin_decl_stmt
name|struct
name|mouse_report
name|last_rep
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mouse_report
name|current_rep
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* * input event "select" use  */
end_comment

begin_decl_stmt
name|struct
name|proc
modifier|*
name|rsel
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* process waiting for select */
end_comment

begin_comment
comment|/* * console cursor structure  */
end_comment

begin_decl_stmt
name|struct
name|_vs_cursor
name|cursor
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nNQD
init|=
name|NQD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|DMAbuf_size
init|=
name|DMA_BUFSIZ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * macro to get system time.  Used to time stamp event queue entries   */
end_comment

begin_define
define|#
directive|define
name|TOY
value|((time.tv_sec * 100) + (time.tv_usec / 10000))
end_define

begin_comment
comment|/* * the "ioconf.c" program, built and used by auto config, externally refers * to definitions below.   */
end_comment

begin_function_decl
name|int
name|qdprobe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|qdattach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|qddint
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* DMA gate array intrpt service */
end_comment

begin_function_decl
name|int
name|qdaint
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Dragon ADDER intrpt service */
end_comment

begin_function_decl
name|int
name|qdiint
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|u_short
name|qdstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|qddriver
init|=
block|{
comment|/* externally referenced: ioconf.c */
name|qdprobe
block|,
comment|/* device probe entry */
literal|0
block|,
comment|/* no slave device */
name|qdattach
block|,
comment|/* device attach entry */
literal|0
block|,
comment|/* no "fill csr/ba to start" */
name|qdstd
block|,
comment|/* device addresses */
literal|"qd"
block|,
comment|/* device name string */
name|qdinfo
comment|/* ptr to QDSS's uba_device struct */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|qvmem
index|[]
index|[
literal|128
operator|*
name|NBPG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|pte
name|QVmap
index|[]
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * v_putc is used to redirect the console cnputc to the virtual console  * vputc.  consops is used to direct the console device to the qvss console.  */
end_comment

begin_function_decl
specifier|extern
function_decl|(
modifier|*
name|v_putc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|cdevsw
modifier|*
name|consops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* * general defines */
end_comment

begin_define
define|#
directive|define
name|QDPRIOR
value|(PZERO-1)
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|~FALSE
end_define

begin_define
define|#
directive|define
name|BAD
value|-1
end_define

begin_define
define|#
directive|define
name|GOOD
value|0
end_define

begin_comment
comment|/*  * Macro to create a system virtual page number from system virtual adrs.  */
end_comment

begin_define
define|#
directive|define
name|VTOP
parameter_list|(
name|x
parameter_list|)
value|(((int)x& ~0xC0000000)>> PGSHIFT)
end_define

begin_comment
comment|/*  * QDSS register address offsets from start of QDSS address space   */
end_comment

begin_define
define|#
directive|define
name|QDSIZE
value|(52 * 1024)
end_define

begin_comment
comment|/* size of entire QDSS foot print */
end_comment

begin_define
define|#
directive|define
name|TMPSIZE
value|(16 * 1024)
end_define

begin_comment
comment|/* template RAM is 8k SHORT WORDS */
end_comment

begin_define
define|#
directive|define
name|TMPSTART
value|0x8000
end_define

begin_comment
comment|/* offset of template RAM from base adrs */
end_comment

begin_define
define|#
directive|define
name|REGSIZE
value|(5 * 512)
end_define

begin_comment
comment|/* regs touch 2.5k (5 pages) of addr space */
end_comment

begin_define
define|#
directive|define
name|REGSTART
value|0xC000
end_define

begin_comment
comment|/* offset of reg pages from base adrs */
end_comment

begin_define
define|#
directive|define
name|ADDER
value|(REGSTART+0x000)
end_define

begin_define
define|#
directive|define
name|DGA
value|(REGSTART+0x200)
end_define

begin_define
define|#
directive|define
name|DUART
value|(REGSTART+0x400)
end_define

begin_define
define|#
directive|define
name|MEMCSR
value|(REGSTART+0x800)
end_define

begin_define
define|#
directive|define
name|CLRSIZE
value|(3 * 512)
end_define

begin_comment
comment|/* color map size */
end_comment

begin_define
define|#
directive|define
name|CLRSTART
value|(REGSTART+0xA00)
end_define

begin_comment
comment|/* color map start offset from base */
end_comment

begin_comment
comment|/*  0x0C00 really */
end_comment

begin_define
define|#
directive|define
name|RED
value|(CLRSTART+0x000)
end_define

begin_define
define|#
directive|define
name|BLUE
value|(CLRSTART+0x200)
end_define

begin_define
define|#
directive|define
name|GREEN
value|(CLRSTART+0x400)
end_define

begin_comment
comment|/*  * Values used in mapping QDSS hardware into the Q memory space.  */
end_comment

begin_define
define|#
directive|define
name|CHUNK
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|QMEMSIZE
value|(1024 * 1024 * 4)
end_define

begin_comment
comment|/* * QDSS minor device numbers.  The *real* minor device numbers are in * the bottom two bits of the major/minor device spec.  Bits 2 and up are * used to specify the QDSS device number (ie: which one?) */
end_comment

begin_define
define|#
directive|define
name|QDSSMAJOR
value|41
end_define

begin_comment
comment|/* QDSS major device number */
end_comment

begin_define
define|#
directive|define
name|CONS
value|0
end_define

begin_define
define|#
directive|define
name|ALTCONS
value|1
end_define

begin_define
define|#
directive|define
name|GRAPHIC
value|2
end_define

begin_comment
comment|/*  * console cursor bitmap (block cursor type)   */
end_comment

begin_decl_stmt
name|short
name|cons_cursor
index|[
literal|32
index|]
init|=
block|{
comment|/* white block cursor */
comment|/* A */
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
comment|/* B */
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * constants used in font operations   */
end_comment

begin_define
define|#
directive|define
name|CHARS
value|95
end_define

begin_comment
comment|/* # of chars in the font */
end_comment

begin_define
define|#
directive|define
name|CHAR_HEIGHT
value|15
end_define

begin_comment
comment|/* char height in pixels */
end_comment

begin_define
define|#
directive|define
name|CHAR_WIDTH
value|8
end_define

begin_comment
comment|/* char width in pixels*/
end_comment

begin_define
define|#
directive|define
name|FONT_WIDTH
value|(CHAR_WIDTH * CHARS)
end_define

begin_comment
comment|/* font width in pixels */
end_comment

begin_define
define|#
directive|define
name|ROWS
value|CHAR_HEIGHT
end_define

begin_define
define|#
directive|define
name|FONT_X
value|0
end_define

begin_comment
comment|/* font's off screen adrs */
end_comment

begin_define
define|#
directive|define
name|FONT_Y
value|(2048 - CHAR_HEIGHT)
end_define

begin_comment
comment|/* #define FONT_Y		200 */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|q_font
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference font object code */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|q_key
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference key xlation tables */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|q_shift_key
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|q_special
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * definitions for cursor acceleration reporting  */
end_comment

begin_define
define|#
directive|define
name|ACC_OFF
value|0x01
end_define

begin_comment
comment|/* acceleration is inactive */
end_comment

begin_function_decl
name|int
name|qdputc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* used to direct kernel console output * int qdstart();		/* used to direct /dev/console output *  /*  * LK-201 state storage for input console keyboard conversion to ASCII   */
end_comment

begin_struct
struct|struct
name|q_keyboard
block|{
name|int
name|shift
decl_stmt|;
comment|/* state variables	*/
name|int
name|cntrl
decl_stmt|;
name|int
name|lock
decl_stmt|;
name|int
name|lastcode
decl_stmt|;
comment|/* last keycode typed	*/
name|unsigned
name|kup
index|[
literal|8
index|]
decl_stmt|;
comment|/* bits for each keycode*/
name|unsigned
name|dkeys
index|[
literal|8
index|]
decl_stmt|;
comment|/* down/up mode keys	*/
name|char
name|last
decl_stmt|;
comment|/* last character	*/
block|}
name|q_keyboard
struct|;
end_struct

begin_comment
comment|/********************************************************************* * *	qdcons_init - init QDSS as console (BEFORE probe routine) * *********************************************************************/
end_comment

begin_macro
name|qdcons_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|u_int
name|unit
decl_stmt|;
name|struct
name|percpu
modifier|*
name|pcpu
decl_stmt|;
comment|/* pointer to percpu structure */
specifier|register
name|struct
name|qbus
modifier|*
name|qb
decl_stmt|;
name|int
modifier|*
name|ptep
decl_stmt|;
comment|/* page table entry pointer */
name|caddr_t
name|phys_adr
decl_stmt|;
comment|/* physical QDSS base adrs */
name|u_int
name|mapix
decl_stmt|;
comment|/* index into QMEMmap[] array */
name|u_short
modifier|*
name|qdaddr
decl_stmt|;
comment|/* address of QDSS IO page CSR */
name|u_short
modifier|*
name|devptr
decl_stmt|;
comment|/* vitual device space */
extern|extern	cnputc(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* standard serial console putc */
end_comment

begin_define
define|#
directive|define
name|QDSSCSR
value|0x1F00
end_define

begin_comment
comment|/* 	 * if console already configured, dont do again. 	 */
end_comment

begin_if
if|if
condition|(
name|v_putc
operator|!=
name|cnputc
condition|)
return|return;
end_if

begin_expr_stmt
name|unit
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * find the cpusw entry that matches this machine.  	 */
end_comment

begin_for
for|for
control|(
name|pcpu
operator|=
name|percpu
init|;
name|pcpu
operator|&&
name|pcpu
operator|->
name|pc_cputype
operator|!=
name|cpu
condition|;
name|pcpu
operator|++
control|)
empty_stmt|;
end_for

begin_if
if|if
condition|(
name|pcpu
operator|==
name|NULL
condition|)
return|return;
end_if

begin_comment
comment|/* 	 * Map device registers - the last 8K of umem. 	 */
end_comment

begin_expr_stmt
name|qb
operator|=
operator|(
expr|struct
name|qbus
operator|*
operator|)
name|pcpu
operator|->
name|pc_io
operator|->
name|io_details
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ioaccess
argument_list|(
name|qb
operator|->
name|qb_iopage
argument_list|,
name|UMEMmap
index|[
literal|0
index|]
operator|+
name|qb
operator|->
name|qb_memsize
argument_list|,
name|UBAIOPAGES
operator|*
name|NBPG
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|devptr
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|umem
index|[
literal|0
index|]
operator|+
operator|(
name|qb
operator|->
name|qb_memsize
operator|*
name|NBPG
operator|)
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdaddr
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|devptr
operator|+
name|ubdevreg
argument_list|(
name|QDSSCSR
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|badaddr
argument_list|(
name|qdaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't find qdss (badaddr)\n"
argument_list|)
expr_stmt|;
comment|/* debug */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_if

begin_comment
comment|/* 	 * Map q-bus memory used by qdss. (separate map) 	 */
end_comment

begin_expr_stmt
name|mapix
operator|=
name|QMEMSIZE
operator|-
operator|(
name|CHUNK
operator|*
operator|(
name|unit
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|phys_adr
operator|=
name|qb
operator|->
name|qb_maddr
operator|+
name|mapix
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ioaccess
argument_list|(
name|phys_adr
argument_list|,
name|QVmap
index|[
literal|0
index|]
argument_list|,
operator|(
name|CHUNK
operator|*
name|NQD
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * tell QDSS which Q memory address base to decode  	 */
end_comment

begin_comment
comment|/*  	 * shifted right 16 bits - its in 64K units 	 */
end_comment

begin_expr_stmt
operator|*
name|qdaddr
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|int
operator|)
name|mapix
operator|>>
literal|16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdflags
index|[
name|unit
index|]
operator|.
name|config
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
name|qdaddr
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * load qdmap struct with the virtual addresses of the QDSS elements  	 */
end_comment

begin_expr_stmt
name|qdbase
index|[
name|unit
index|]
operator|=
operator|(
name|caddr_t
operator|)
name|qvmem
index|[
literal|0
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|template
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|TMPSTART
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|ADDER
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|DGA
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|DUART
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|MEMCSR
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|red
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|RED
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|blue
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|BLUE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|green
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|GREEN
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* init shadow variables */
end_comment

begin_comment
comment|/* 	 * init the QDSS  	 */
end_comment

begin_comment
comment|/*** 	printf("qdbase[0] = %x, qdmap[0].memcsr = %x\n", 		(char *)qdbase[0], qdmap[0].memcsr); 	***/
end_comment

begin_expr_stmt
operator|*
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
operator||=
name|SYNC_ON
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* once only: turn on sync */
end_comment

begin_expr_stmt
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* init shared memory */
end_comment

begin_expr_stmt
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* init the ADDER/VIPER stuff */
end_comment

begin_expr_stmt
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* clear the screen */
end_comment

begin_expr_stmt
name|ldfont
argument_list|(
name|unit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* load the console font */
end_comment

begin_expr_stmt
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|cons_cursor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* load default cursor map */
end_comment

begin_expr_stmt
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* init the DUART */
end_comment

begin_expr_stmt
name|v_putc
operator|=
name|qdputc
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|consops
operator|=
operator|&
name|cdevsw
index|[
name|QDSSMAJOR
index|]
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|1
operator|)
return|;
end_return

begin_comment
unit|}
comment|/* qdcons_init */
end_comment

begin_comment
comment|/********************************************************************* * *	qdprobe()... configure QDSS into Q memory and make it intrpt * ********************************************************************** * *  calling convention: *			qdprobe(reg, ctlr); *			caddr_t reg; *			int ctlr; * *	where: reg - a character pointer to the QDSS I/O page register *	       ctlr - controller number (?) * *  side effects: QDSS gets mapped into Qbus memory space at the first *		 vacant 64kb boundary counting back from the top of *		 Qbus memory space (qmem+4mb) * *  return: QDSS bus request level and vector address returned in *	   registers by UNIX convention. * *****************/
end_comment

begin_expr_stmt
unit|qdprobe
operator|(
name|reg
operator|)
name|caddr_t
name|reg
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* value-result */
specifier|register
name|int
name|unit
decl_stmt|;
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
comment|/* pointer to gate array structure */
name|struct
name|cpusw
modifier|*
name|cpup
decl_stmt|;
comment|/* pointer to the cpusw structure */
name|int
modifier|*
name|ptep
decl_stmt|;
comment|/* page table entry pointer */
name|int
name|vector
decl_stmt|;
name|caddr_t
name|phys_adr
decl_stmt|;
comment|/* physical QDSS base adrs */
name|u_int
name|mapix
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
endif|#
directive|endif
comment|/* 	* calculate board unit number from I/O page register address   	*/
name|unit
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|reg
operator|>>
literal|1
operator|)
operator|&
literal|0x0007
argument_list|)
expr_stmt|;
comment|/* * QDSS regs must be mapped to Qbus memory space at a 64kb physical boundary. * The Qbus memory space is mapped into the system memory space at config * time.  After config runs, "qmem[0]" (ubavar.h) holds the system virtual adrs * of the start of Qbus memory.	The Qbus memory page table is found via * an array of pte ptrs called "QMEMmap[]" (ubavar.h) which is also loaded at * config time.	These are the variables used below to find a vacant 64kb * boundary in Qbus memory, and load it's corresponding physical adrs into * the QDSS's I/O page CSR.   */
comment|/* if this QDSS is NOT the console, then do init here.. */
comment|/****** XXX - REMOVED (can't test) - STILL NEED TO DO FOR NQD> 1 ***/
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|v_consputc
operator|!=
name|qdputc
operator|||
name|unit
operator|!=
literal|0
condition|)
block|{
comment|/* 	     * read QDSS config info 	     */
name|qdflags
index|[
name|unit
index|]
operator|.
name|config
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
name|reg
expr_stmt|;
comment|/* 	     * find an empty 64kb adrs boundary  	     */
name|qdbase
index|[
name|unit
index|]
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|qmem
index|[
literal|0
index|]
operator|+
name|QMEMSIZE
operator|-
name|CHUNK
argument_list|)
expr_stmt|;
comment|/* 	     * find the cpusw entry that matches this machine.  	     */
name|cpup
operator|=
operator|&
name|cpusw
index|[
name|cpu
index|]
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|BADADDR
argument_list|(
name|qdbase
index|[
name|unit
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
condition|)
name|qdbase
index|[
name|unit
index|]
operator|-=
name|CHUNK
expr_stmt|;
comment|/* 	     * tell QDSS which Q memory address base to decode  	     */
name|mapix
operator|=
call|(
name|int
call|)
argument_list|(
name|VTOP
argument_list|(
name|qdbase
index|[
name|unit
index|]
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qmem
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
name|QMEMmap
index|[
literal|0
index|]
operator|+
name|mapix
expr_stmt|;
name|phys_adr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|ptep
operator|&
literal|0x001FFFFF
operator|)
operator|<<
name|PGSHIFT
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|reg
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|int
operator|)
name|phys_adr
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* 	     * load QDSS adrs map with system addresses of device regs 	     */
name|qdmap
index|[
name|unit
index|]
operator|.
name|template
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|TMPSTART
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|ADDER
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|DGA
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|DUART
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|MEMCSR
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|red
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|RED
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|blue
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|BLUE
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|green
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|GREEN
expr_stmt|;
comment|/* device init */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init shared memory */
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the ADDER/VIPER stuff */
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|cons_cursor
argument_list|)
expr_stmt|;
comment|/* load default cursor map */
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the DUART */
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ldfont
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* load the console font */
comment|/* once only: turn on sync */
operator|*
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
operator||=
name|SYNC_ON
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* notdef */
comment|/*  * the QDSS interrupts at HEX vectors xx0 (DMA) xx4 (ADDER) and xx8 (DUART).  * Therefore, we take three vectors from the vector pool, and then continue  * to take them until we get a xx0 HEX vector.  The pool provides vectors  * in contiguous decending order.    */
name|vector
operator|=
operator|(
name|uba_hd
index|[
literal|0
index|]
operator|.
name|uh_lastiv
operator|-=
literal|4
operator|*
literal|3
operator|)
expr_stmt|;
comment|/* take three vectors */
while|while
condition|(
name|vector
operator|&
literal|0x0F
condition|)
block|{
comment|/* if lo nibble != 0.. */
name|vector
operator|=
operator|(
name|uba_hd
index|[
literal|0
index|]
operator|.
name|uh_lastiv
operator|-=
literal|4
operator|)
expr_stmt|;
comment|/* ..take another vector */
block|}
comment|/* 	 * setup DGA to do a DMA interrupt (transfer count = 0) 	 */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|csr
operator|=
operator|(
name|short
operator|)
name|HALT
expr_stmt|;
comment|/* disable everything */
name|dga
operator|->
name|ivr
operator|=
operator|(
name|short
operator|)
name|vector
expr_stmt|;
comment|/* load intrpt base vector */
name|dga
operator|->
name|bytcnt_lo
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
comment|/* DMA xfer count = 0 */
name|dga
operator|->
name|bytcnt_hi
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
comment|/* turn on DMA interrupts */
name|dga
operator|->
name|csr
operator|&=
operator|~
name|SET_DONE_FIFO
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
operator||
name|DL_ENB
expr_stmt|;
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
comment|/* wait for the intrpt */
name|dga
operator|->
name|csr
operator|=
name|HALT
expr_stmt|;
comment|/* stop the wheels */
if|if
condition|(
name|cvec
operator|!=
name|vector
condition|)
comment|/* if vector != base vector.. */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ..return = 'no device' */
return|return
operator|(
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
return|;
comment|/* return size of QDSS I/O page reg */
block|}
end_block

begin_comment
comment|/* qdprobe */
end_comment

begin_comment
comment|/***************************************************************** * *	qdattach - one-time initialization * ****************************************************************** * *  calling convention: *			qdattach(ui); *			struct uba_device *ui; * *		where: ui - pointer to the QDSS's uba_device structure * *  side effects: none *	 return: none * *************************/
end_comment

begin_macro
name|qdattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_int
name|unit
decl_stmt|;
comment|/* QDSS module # for this call */
name|unit
operator|=
name|ui
operator|->
name|ui_unit
expr_stmt|;
comment|/* get QDSS number */
comment|/* 	 * init "qdflags[]" for this QDSS  	 */
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|=
literal|0
expr_stmt|;
comment|/* init inuse variable EARLY! */
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|kernel_loop
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|user_dma
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_acc
operator|=
name|ACC_OFF
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_thr
operator|=
literal|128
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|tab_res
operator|=
literal|2
expr_stmt|;
comment|/* default tablet resolution factor */
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator|=
literal|0
expr_stmt|;
comment|/* init shadow variables */
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|=
literal|0
expr_stmt|;
comment|/* 	* init structures used in kbd/mouse interrupt service.	This code must 	* come after the "init_shared()" routine has run since that routine  	* inits the eq_header[unit] structure used here.    	*/
comment|/* 	* init the "latest mouse report" structure  	*/
name|last_rep
index|[
name|unit
index|]
operator|.
name|state
operator|=
literal|0
expr_stmt|;
name|last_rep
index|[
name|unit
index|]
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|last_rep
index|[
name|unit
index|]
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|last_rep
index|[
name|unit
index|]
operator|.
name|bytcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	* init the event queue (except mouse position) 	*/
name|eq_header
index|[
name|unit
index|]
operator|->
name|header
operator|.
name|events
operator|=
operator|(
expr|struct
name|_vs_event
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|eq_header
index|[
name|unit
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|qdinput
argument_list|)
operator|)
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|header
operator|.
name|size
operator|=
name|MAXEVENTS
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|header
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|header
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
comment|/* 	* init single process access lock switch  	*/
name|one_only
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* qdattach */
end_comment

begin_comment
comment|/*************************************************************** * *	qdopen - open a minor device * **************************************************************** * *  calling convention: qdopen(dev, flag); *		       dev_t dev; *		       int flag; * *  side effects: none * *********************/
end_comment

begin_macro
name|qdopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
comment|/* ptr to uba structures */
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
comment|/* ptr to gate array struct */
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|qdstart
parameter_list|()
function_decl|;
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|u_int
name|minor_dev
decl_stmt|;
name|int
name|s
decl_stmt|;
name|minor_dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* get QDSS minor device number */
name|unit
operator|=
name|minor_dev
operator|>>
literal|2
expr_stmt|;
comment|/* check for illegal conditions	*/
name|ui
operator|=
name|qdinfo
index|[
name|unit
index|]
expr_stmt|;
comment|/* get ptr to QDSS device struct */
if|if
condition|(
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* no such device or address */
comment|/* init stuff */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
comment|/* if this is the graphic device... */
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|one_only
index|[
name|unit
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
else|else
name|one_only
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator||=
name|GRAPHIC_DEV
expr_stmt|;
comment|/* graphics dev is open */
comment|/* enble kbd& mouse intrpts in DUART mask reg */
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator||=
literal|0x22
expr_stmt|;
name|duart
operator|->
name|imask
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
expr_stmt|;
comment|/* 	 * if the open call is to the console or the alternate console...  	 */
block|}
else|else
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator||=
name|CONS_DEV
expr_stmt|;
comment|/* mark console as open */
name|dga
operator|->
name|csr
operator||=
name|CURS_ENB
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator||=
literal|0x02
expr_stmt|;
name|duart
operator|->
name|imask
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
expr_stmt|;
comment|/*------------------------------- 	    * some setup for tty handling */
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
name|tp
operator|->
name|t_addr
operator|=
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|qdstart
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TS_ISOPEN
operator||
name|TS_CARR_ON
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|B9600
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|B9600
expr_stmt|;
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_flags
operator|=
name|XTABS
operator||
name|EVENP
operator||
name|ECHO
operator||
name|CRMOD
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIXTTY
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|tp
operator|->
name|t_flags
operator|=
name|RAW
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------- 	    * enable intrpts, open line discipline */
name|dga
operator|->
name|csr
operator||=
name|GLOBAL_IE
expr_stmt|;
comment|/* turn on the interrupts */
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
return|;
block|}
name|dga
operator|->
name|csr
operator||=
name|GLOBAL_IE
expr_stmt|;
comment|/* turn on the interrupts */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdopen */
end_comment

begin_comment
comment|/*************************************************************** * *	qdclose - clean up on the way out * **************************************************************** * *  calling convention: qdclose(); * *  side effects: none * *  return: none * *********************/
end_comment

begin_macro
name|qdclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|qdmap
modifier|*
name|qd
decl_stmt|;
specifier|register
name|int
modifier|*
name|ptep
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* SIGNED index */
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
comment|/* gate array register map pointer */
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|u_int
name|minor_dev
decl_stmt|;
name|u_int
name|mapix
decl_stmt|;
name|minor_dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* get minor device number */
name|unit
operator|=
name|minor_dev
operator|>>
literal|2
expr_stmt|;
comment|/* get QDSS number */
name|qd
operator|=
operator|&
name|qdmap
index|[
name|unit
index|]
expr_stmt|;
comment|/* 	 * if this is the graphic device...  	 */
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|one_only
index|[
name|unit
index|]
operator|!=
literal|1
condition|)
comment|/* unlock driver */
return|return
operator|(
name|EBUSY
operator|)
return|;
else|else
name|one_only
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	    * re-protect device memory  	    */
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPDEV
condition|)
block|{
comment|/* TEMPLATE RAM */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|template
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTOP
argument_list|(
name|TMPSIZE
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
comment|/* ADDER */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|adder
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTOP
argument_list|(
name|REGSIZE
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
comment|/* COLOR MAPS */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|red
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTOP
argument_list|(
name|CLRSIZE
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
block|}
comment|/*  	     * re-protect DMA buffer and free the map registers  	     */
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPDMA
condition|)
block|{
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* kill DMA */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* if DMA was running, flush spurious intrpt */
if|if
condition|(
name|dga
operator|->
name|bytcnt_lo
operator|!=
literal|0
condition|)
block|{
name|dga
operator|->
name|bytcnt_lo
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
literal|0
expr_stmt|;
name|DMA_SETIGNORE
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
block|}
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|DMAheader
index|[
name|unit
index|]
operator|*
literal|4
argument_list|)
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|DMAbuf_size
operator|>>
name|PGSHIFT
operator|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
name|ubarelse
argument_list|(
literal|0
argument_list|,
operator|&
name|Qbus_unmap
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * re-protect 1K (2 pages) event queue  	     */
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPEQ
condition|)
block|{
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
block|}
comment|/* 	     * re-protect scroll param area and disable scroll intrpts   	     */
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPSCR
condition|)
block|{
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|scroll
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* re-protect 512 scroll param area */
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|&=
operator|~
name|FRAME_SYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
block|}
comment|/* 	     * re-protect color map write buffer area and kill intrpts  	     */
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPCOLOR
condition|)
block|{
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|color_buf
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|color_buf
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|&=
operator|~
name|VSYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
block|}
comment|/* 	     * flag that everthing is unmapped  	     */
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* invalidate translation buf */
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|=
literal|0
expr_stmt|;
comment|/* flag everything unmapped */
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&=
operator|~
name|GRAPHIC_DEV
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_acc
operator|=
name|ACC_OFF
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_thr
operator|=
literal|128
expr_stmt|;
comment|/* 	     * restore the console  	     */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* halt the DMA! (just in case...) */
name|dga
operator|->
name|csr
operator||=
name|DMA_ERR
expr_stmt|;
comment|/* clear error condition */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* if DMA was running, flush spurious intrpt */
if|if
condition|(
name|dga
operator|->
name|bytcnt_lo
operator|!=
literal|0
condition|)
block|{
name|dga
operator|->
name|bytcnt_lo
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
literal|0
expr_stmt|;
name|DMA_SETIGNORE
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
block|}
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init shared memory */
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init ADDER/VIPER */
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|cons_cursor
argument_list|)
expr_stmt|;
comment|/* load default cursor map */
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the DUART */
name|ldfont
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
comment|/*  	     * shut off the mouse rcv intrpt and turn on kbd intrpts  	     */
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator|&=
operator|~
operator|(
literal|0x20
operator|)
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator||=
literal|0x02
expr_stmt|;
name|duart
operator|->
name|imask
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
expr_stmt|;
comment|/* 	     * shut off interrupts if all is closed   	     */
if|if
condition|(
operator|!
operator|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
operator|(
name|CONS_DEV
operator||
name|ALTCONS_DEV
operator|)
operator|)
condition|)
block|{
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
operator|(
name|GLOBAL_IE
operator||
name|DMA_IE
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* if this is the console or the alternate console  */
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&=
operator|~
name|CONS_DEV
expr_stmt|;
comment|/* 	     * if graphics device is closed, kill interrupts  	     */
if|if
condition|(
operator|!
operator|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
operator|)
condition|)
block|{
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
operator|(
name|GLOBAL_IE
operator||
name|DMA_IE
operator|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdclose */
end_comment

begin_comment
comment|/*************************************************************** * *	qdioctl - provide QDSS control services * **************************************************************** * *  calling convention:	qdioctl(dev, cmd, datap, flags); * *		where:	dev - the major/minor device number *			cmd - the user-passed command argument *			datap - ptr to user input buff (128 bytes max) *			flags - "f_flags" from "struct file" in file.h * * *	- here is the format for the input "cmd" argument * *	31     29 28	23 22	      16 15		8 7		 0 *	+----------------------------------------------------------------+ *	|I/O type|	  | buff length | device ID char |  user command | *	+----------------------------------------------------------------+ * *  Return data is in the data buffer pointed to by "datap" input spec * *********************/
end_comment

begin_macro
name|qdioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|datap
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|datap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|ptep
decl_stmt|;
comment|/* page table entry pointer */
specifier|register
name|int
name|mapix
decl_stmt|;
comment|/* QVmap[] page table index */
specifier|register
name|struct
name|_vs_event
modifier|*
name|event
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|qdmap
modifier|*
name|qd
decl_stmt|;
comment|/* pointer to device map struct */
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
comment|/* Gate Array reg structure pntr */
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
comment|/* DUART reg structure pointer */
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
comment|/* ADDER reg structure pointer */
name|struct
name|prgkbd
modifier|*
name|cmdbuf
decl_stmt|;
name|struct
name|prg_cursor
modifier|*
name|curs
decl_stmt|;
name|struct
name|_vs_cursor
modifier|*
name|pos
decl_stmt|;
name|u_int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|2
decl_stmt|;
comment|/* number of caller's QDSS */
name|u_int
name|minor_dev
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|qdinfo
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|qd_softc
modifier|*
name|sc
init|=
operator|&
name|qd_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
comment|/* struct devget *devget; */
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* SIGNED index */
name|int
name|sbr
decl_stmt|;
comment|/* SBR variable (you silly boy) */
name|u_int
name|ix
decl_stmt|;
name|short
name|status
decl_stmt|;
name|short
modifier|*
name|shortp
decl_stmt|;
comment|/* generic pointer to a short */
name|char
modifier|*
name|chrp
decl_stmt|;
comment|/* generic character pointer */
name|short
modifier|*
name|temp
decl_stmt|;
comment|/* a pointer to template RAM */
comment|/* service graphic device ioctl commands */
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* 	     * extract the oldest event from the event queue  	     */
case|case
name|QD_GETEVENT
case|:
if|if
condition|(
name|ISEMPTY
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
condition|)
block|{
name|event
operator|=
operator|(
expr|struct
name|_vs_event
operator|*
operator|)
name|datap
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_NULL
expr_stmt|;
break|break;
block|}
name|event
operator|=
operator|(
expr|struct
name|_vs_event
operator|*
operator|)
name|GETBEGIN
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|GETEND
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|event
argument_list|,
name|datap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_vs_event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/*------------------------------------------------------- 	    * init the dragon stuff, DUART, and driver variables  */
case|case
name|QD_RESET
case|:
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init shared memory */
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the ADDER/VIPER stuff */
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|cons_cursor
argument_list|)
expr_stmt|;
comment|/* load default cursor map */
name|ldfont
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* load the console font */
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the DUART */
break|break;
comment|/*---------------------------------------- 	    * init the DUART and driver variables  */
case|case
name|QD_SET
case|:
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
break|break;
comment|/*--------------------------------------------------------------- 	    * clear the QDSS screen.  (NOTE that this reinits the dragon) */
case|case
name|QD_CLRSCRN
case|:
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
break|break;
comment|/*------------------------------------ 	    * load a cursor into template RAM  */
case|case
name|QD_WTCURSOR
case|:
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|datap
argument_list|)
expr_stmt|;
break|break;
case|case
name|QD_RDCURSOR
case|:
name|temp
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|template
expr_stmt|;
comment|/* cursor is 32 WORDS from the end of the 8k WORD... 		*  ...template space */
name|temp
operator|+=
operator|(
literal|8
operator|*
literal|1024
operator|)
operator|-
literal|32
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
operator|,
name|datap
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
control|)
operator|*
operator|(
name|short
operator|*
operator|)
name|datap
operator|=
operator|*
name|temp
operator|++
expr_stmt|;
break|break;
comment|/*------------------------------ 	    * position the mouse cursor  */
case|case
name|QD_POSCURSOR
case|:
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|pos
operator|=
operator|(
expr|struct
name|_vs_cursor
operator|*
operator|)
name|datap
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|pos
operator|->
name|x
argument_list|)
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|pos
operator|->
name|y
argument_list|)
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|x
operator|=
name|pos
operator|->
name|x
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|y
operator|=
name|pos
operator|->
name|y
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/*-------------------------------------- 	    * set the cursor acceleration factor */
case|case
name|QD_PRGCURSOR
case|:
name|curs
operator|=
operator|(
expr|struct
name|prg_cursor
operator|*
operator|)
name|datap
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_acc
operator|=
name|curs
operator|->
name|acc_factor
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_thr
operator|=
name|curs
operator|->
name|threshold
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/*--------------------------------------- 	    * enable 'user write' to device pages */
case|case
name|QD_MAPDEVICE
case|:
comment|/*-------------- 		* init stuff */
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPDEV
expr_stmt|;
name|qd
operator|=
operator|(
expr|struct
name|qdmap
operator|*
operator|)
operator|&
name|qdmap
index|[
name|unit
index|]
expr_stmt|;
comment|/*------------------------------------- 		* enable user write to template RAM */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|template
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTOP
argument_list|(
name|TMPSIZE
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
comment|/*---------------------------------- 		* enable user write to registers */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|adder
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTOP
argument_list|(
name|REGSIZE
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
comment|/*----------------------------------- 		* enable user write to color maps */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|red
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTOP
argument_list|(
name|CLRSIZE
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
comment|/*------------------------------ 		* enable user write to DUART */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|duart
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
comment|/* duart page */
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* smash CPU's translation buffer */
comment|/*------------------------------------------ 		* stuff qdmap structure in return buffer */
name|bcopy
argument_list|(
name|qd
argument_list|,
name|datap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qdmap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/*------------------------------------- 	    * do setup for DMA by user process	*/
case|case
name|QD_MAPIOBUF
case|:
comment|/*------------------------------------------------ 		* set 'user write enable' bits for DMA buffer  */
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPDMA
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|DMAbuf_size
operator|>>
name|PGSHIFT
operator|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clr CPU translation buf */
comment|/*------------------------------------- 		* set up QBUS map registers for DMA */
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
operator|=
name|uballoc
argument_list|(
literal|0
argument_list|,
name|DMAheader
index|[
name|unit
index|]
argument_list|,
name|DMAbuf_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"qd%d: qdioctl: QBA setup error\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|Qbus_unmap
index|[
name|unit
index|]
operator|=
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
operator|&=
literal|0x3FFFF
expr_stmt|;
comment|/*---------------------- 		* return I/O buf adr */
operator|*
operator|(
name|int
operator|*
operator|)
name|datap
operator|=
operator|(
name|int
operator|)
name|DMAheader
index|[
name|unit
index|]
expr_stmt|;
break|break;
comment|/*---------------------------------------------------------------- 	    * map the shared scroll param area and enable scroll interpts  */
case|case
name|QD_MAPSCROLL
case|:
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPSCR
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|scroll
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* allow user write to scroll area */
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clr CPU translation buf */
name|scroll
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator||=
name|FRAME_SYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
comment|/* return scroll area address */
operator|*
operator|(
name|int
operator|*
operator|)
name|datap
operator|=
operator|(
name|int
operator|)
name|scroll
index|[
name|unit
index|]
expr_stmt|;
break|break;
comment|/*------------------------------------------------------------- 	    * unmap shared scroll param area and disable scroll intrpts */
case|case
name|QD_UNMAPSCROLL
case|:
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPSCR
condition|)
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&=
operator|~
name|MAPSCR
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|scroll
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* re-protect 512 scroll param area */
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* smash CPU's translation buf */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|&=
operator|~
name|FRAME_SYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
block|}
break|break;
comment|/*----------------------------------------------------------- 	    * map shared color map write buf and turn on vsync intrpt */
case|case
name|QD_MAPCOLOR
case|:
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPCOLOR
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|color_buf
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* allow user write to color map write buffer */
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clr CPU translation buf */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator||=
name|VSYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
comment|/* return scroll area address */
operator|*
operator|(
name|int
operator|*
operator|)
name|datap
operator|=
operator|(
name|int
operator|)
name|color_buf
index|[
name|unit
index|]
expr_stmt|;
break|break;
comment|/*-------------------------------------------------------------- 	    * unmap shared color map write buffer and kill VSYNC intrpts */
case|case
name|QD_UNMAPCOLOR
case|:
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPCOLOR
condition|)
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&=
operator|~
name|MAPCOLOR
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|color_buf
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* re-protect color map write buffer */
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* smash CPU's translation buf */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|&=
operator|~
name|VSYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
block|}
break|break;
comment|/*--------------------------------------------- 	    * give user write access to the event queue */
case|case
name|QD_MAPEVENT
case|:
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPEQ
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* allow user write to 1K event queue */
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clr CPU translation buf */
comment|/* return event queue address */
operator|*
operator|(
name|int
operator|*
operator|)
name|datap
operator|=
operator|(
name|int
operator|)
name|eq_header
index|[
name|unit
index|]
expr_stmt|;
break|break;
comment|/*----------------------------------------------- 	    * pass caller's programming commands to LK201 */
case|case
name|QD_PRGKBD
case|:
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
name|cmdbuf
operator|=
operator|(
expr|struct
name|prgkbd
operator|*
operator|)
name|datap
expr_stmt|;
comment|/* pnt to kbd cmd buf */
comment|/*---------------- 		* send command */
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmdbuf
operator|->
name|cmd
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdioctl: timeout on XMT_RDY [1]\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*---------------- 		* send param1? */
if|if
condition|(
name|cmdbuf
operator|->
name|cmd
operator|&
name|LAST_PARAM
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmdbuf
operator|->
name|param1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nqd%d: qdioctl: timeout on XMT_RDY [2]\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*---------------- 		* send param2? */
if|if
condition|(
name|cmdbuf
operator|->
name|param1
operator|&
name|LAST_PARAM
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmdbuf
operator|->
name|param2
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdioctl: timeout on XMT_RDY [3]\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/*---------------------------------------------------- 	    * pass caller's programming commands to the mouse  */
case|case
name|QD_PRGMOUSE
case|:
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
operator|*
name|datap
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdioctl: timeout on XMT_RDY [4]\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*---------------------------------------------- 	    * get QDSS configuration word and return it  */
case|case
name|QD_RDCONFIG
case|:
operator|*
operator|(
name|short
operator|*
operator|)
name|datap
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|config
expr_stmt|;
break|break;
comment|/*---------------------- 	    * program the tablet */
case|case
name|QD_PRGTABLET
case|:
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
operator|*
name|datap
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdioctl: timeout on XMT_RDY [5]\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*----------------------------------------------- 	    * program the tablet report resolution factor */
case|case
name|QD_PRGTABRES
case|:
name|qdflags
index|[
name|unit
index|]
operator|.
name|tab_res
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
name|datap
expr_stmt|;
break|break;
default|default:
comment|/*----------------------------- 		* service tty type ioctl's  */
if|if
condition|(
operator|!
operator|(
name|minor_dev
operator|&
literal|0x02
operator|)
condition|)
block|{
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|datap
operator|,
name|flags
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|datap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
break|break;
block|}
comment|/*-------------------------------- * clean up and get outta here  */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdioctl */
end_comment

begin_comment
comment|/********************************************************************** * *	qdselect()... service select call for event queue input * **********************************************************************/
end_comment

begin_macro
name|qdselect
argument_list|(
argument|dev
argument_list|,
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|2
expr_stmt|;
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
name|FREAD
case|:
comment|/* event available? */
if|if
condition|(
operator|!
operator|(
name|ISEMPTY
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* return "1" if event exists */
block|}
name|rsel
index|[
name|unit
index|]
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|selmask
operator||=
name|SEL_READ
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FWRITE
case|:
comment|/* DMA done? */
if|if
condition|(
name|DMA_ISEMPTY
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* return "1" if DMA is done */
block|}
name|rsel
index|[
name|unit
index|]
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|selmask
operator||=
name|SEL_WRITE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* qdselect() */
end_comment

begin_comment
comment|/*************************************************************** * *	qdwrite()... output to the QDSS screen as a TTY * ***************************************************************/
end_comment

begin_extern
extern|extern qd_strategy(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_macro
name|qdwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|minor_dev
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|minor_dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
operator|(
name|minor_dev
operator|>>
literal|2
operator|)
operator|&
literal|0x07
expr_stmt|;
comment|/*------------------------------ 	* if this is the console...  */
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|!=
literal|0x02
operator|&&
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|CONS_DEV
condition|)
block|{
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
operator|)
return|;
block|}
comment|/*------------------------------------------------ 	* else this must be a DMA xfer from user space */
elseif|else
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
condition|)
block|{
return|return
operator|(
name|physio
argument_list|(
name|qd_strategy
argument_list|,
operator|&
name|qdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*************************************************************** * *	qdread()... read from QDSS keyboard as a TTY * ***************************************************************/
end_comment

begin_macro
name|qdread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|minor_dev
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|minor_dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
operator|(
name|minor_dev
operator|>>
literal|2
operator|)
operator|&
literal|0x07
expr_stmt|;
comment|/*------------------------------ 	* if this is the console...  */
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|!=
literal|0x02
operator|&&
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|CONS_DEV
condition|)
block|{
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
operator|)
return|;
block|}
comment|/*------------------------------------------------ 	* else this must be a bitmap-to-processor xfer */
elseif|else
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
condition|)
block|{
return|return
operator|(
name|physio
argument_list|(
name|qd_strategy
argument_list|,
operator|&
name|qdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*************************************************************** * *	qd_strategy()... strategy routine to do DMA * ***************************************************************/
end_comment

begin_expr_stmt
name|qd_strategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|char
modifier|*
name|DMAbufp
decl_stmt|;
name|int
name|QBAreg
decl_stmt|;
name|int
name|bytcnt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|cookie
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unit
operator|=
operator|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|>>
literal|2
operator|)
operator|&
literal|0x07
expr_stmt|;
comment|/* 	* init pointers  	*/
if|if
condition|(
operator|(
name|QBAreg
operator|=
name|ubasetup
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qd_strategy: QBA setup error\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|STRAT_ERR
goto|;
block|}
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|user_dma
operator|=
operator|-
literal|1
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
name|cookie
operator|=
name|QBAreg
operator|&
literal|0x3FFFF
expr_stmt|;
name|dga
operator|->
name|adrs_lo
operator|=
operator|(
name|short
operator|)
name|cookie
expr_stmt|;
name|dga
operator|->
name|adrs_hi
operator|=
call|(
name|short
call|)
argument_list|(
name|cookie
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|dga
operator|->
name|bytcnt_lo
operator|=
operator|(
name|short
operator|)
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
call|(
name|short
call|)
argument_list|(
name|bp
operator|->
name|b_bcount
operator|>>
literal|16
argument_list|)
expr_stmt|;
while|while
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|user_dma
condition|)
block|{
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|qdflags
index|[
name|unit
index|]
operator|.
name|user_dma
argument_list|,
name|QDPRIOR
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ubarelse
argument_list|(
literal|0
argument_list|,
operator|&
name|QBAreg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dga
operator|->
name|csr
operator|&
name|DMA_ERR
operator|)
condition|)
block|{
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|STRAT_ERR
label|:
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* cancel adder activity */
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* halt DMA (reset fifo) */
name|dga
operator|->
name|csr
operator||=
name|DMA_ERR
expr_stmt|;
comment|/* clear error condition */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* flag an error to physio() */
comment|/* if DMA was running, flush spurious intrpt */
if|if
condition|(
name|dga
operator|->
name|bytcnt_lo
operator|!=
literal|0
condition|)
block|{
name|dga
operator|->
name|bytcnt_lo
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
literal|0
expr_stmt|;
name|DMA_SETIGNORE
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
block|}
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* qd_strategy */
end_comment

begin_comment
comment|/******************************************************************* * *	qdstart()... startup output to the console screen * ******************************************************************** * NOTE - You must have tty.c fixed so it doesn't try to sleep *	waiting for a transmitter interrupt (which would never occur). *	Writes to the QDSS are synchronous and have (essentially) *	completed by the time the start routine returns. * *	calling convention: * *		qdstart(tp); *		struct tty *tp; 	# pointer to tty structure * ********/
end_comment

begin_expr_stmt
name|qdstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|which_unit
decl_stmt|,
name|unit
decl_stmt|,
name|c
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|which_unit
operator|=
operator|(
name|unit
operator|>>
literal|2
operator|)
operator|&
literal|0x3
expr_stmt|;
comment|/* unit&= 0x03; */
comment|/* If it's currently active, or delaying, no need to do anything. */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * XXX - this loop is at spltty.  not good, but hardly worth 	 * fixing since the glass tty is only used when the window 	 * system isn't running.  if you debug window systems you 	 * might want to rethink this. 	 */
while|while
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|blitc
argument_list|(
name|which_unit
argument_list|,
name|c
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* qdstart */
end_comment

begin_comment
comment|/******************************************************************* * *	qdstop()... stop the tty * *******************************************************************/
end_comment

begin_expr_stmt
name|qdstop
argument_list|(
name|tp
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* not needed - qdss is synchronous */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* block intrpts during state modification */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/******************************************************************* * *	blitc()... output a character to the QDSS screen * ******************************************************************** * *	calling convention: * *		blitc(chr); *		char chr;		;character to be displayed * ********/
end_comment

begin_macro
name|blitc
argument_list|(
argument|unit
argument_list|,
argument|chr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|chr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|short
name|inescape
index|[
name|NQD
index|]
decl_stmt|;
name|short
name|x
decl_stmt|;
comment|/* init stuff  */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|chr
operator|&=
literal|0x7F
expr_stmt|;
comment|/* 	 *  Support cursor addressing so vi will work. 	 *  Decode for "\E=%.%." cursor motion description. 	 * 	 *  If we've seen an escape, grab up to three more 	 *  characters, bailing out if necessary.  	 */
if|if
condition|(
name|inescape
index|[
name|unit
index|]
condition|)
block|{
switch|switch
condition|(
name|inescape
index|[
name|unit
index|]
operator|++
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|chr
operator|!=
literal|'='
condition|)
block|{
comment|/* bogus escape sequence */
name|inescape
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|blitc
argument_list|(
name|unit
argument_list|,
name|chr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|2
case|:
comment|/* position row */
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
name|CHAR_HEIGHT
operator|*
name|chr
expr_stmt|;
if|if
condition|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|>
literal|863
operator|-
name|CHAR_HEIGHT
condition|)
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|863
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|3
case|:
comment|/* position column */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
name|CHAR_WIDTH
operator|*
name|chr
expr_stmt|;
if|if
condition|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|>
literal|1024
operator|-
name|CHAR_WIDTH
condition|)
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|1023
operator|-
name|CHAR_WIDTH
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|inescape
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|inescape
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|blitc
argument_list|(
name|unit
argument_list|,
name|chr
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|chr
condition|)
block|{
case|case
literal|'\r'
case|:
comment|/* return char */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\t'
case|:
comment|/* tab char */
for|for
control|(
name|i
operator|=
literal|8
operator|-
operator|(
operator|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|>>
literal|3
operator|)
operator|&
literal|0x07
operator|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|blitc
argument_list|(
name|unit
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\n'
case|:
comment|/* line feed char */
if|if
condition|(
operator|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|+=
name|CHAR_HEIGHT
operator|)
operator|>
operator|(
literal|863
operator|-
name|CHAR_HEIGHT
operator|)
condition|)
block|{
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
condition|)
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|-=
name|CHAR_HEIGHT
expr_stmt|;
name|scroll_up
argument_list|(
name|adder
argument_list|)
expr_stmt|;
block|}
block|}
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\b'
case|:
comment|/* backspace char */
if|if
condition|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|>
literal|0
condition|)
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|-=
name|CHAR_WIDTH
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CTRL
argument_list|(
literal|'k'
argument_list|)
case|:
comment|/* cursor up */
if|if
condition|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|>
literal|0
condition|)
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|-=
name|CHAR_HEIGHT
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CTRL
argument_list|(
literal|'^'
argument_list|)
case|:
comment|/* home cursor */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CTRL
argument_list|(
literal|'l'
argument_list|)
case|:
comment|/* cursor right */
if|if
condition|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|<
literal|1023
operator|-
name|CHAR_WIDTH
condition|)
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|+=
name|CHAR_WIDTH
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CTRL
argument_list|(
literal|'z'
argument_list|)
case|:
comment|/* clear screen */
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* and home cursor - termcap seems to assume this */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\033'
case|:
comment|/* start escape sequence */
name|inescape
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
if|if
condition|(
name|chr
operator|<
literal|' '
operator|||
name|chr
operator|>
literal|'~'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* setup VIPER operand control registers  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* select plane #0 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FE
argument_list|)
expr_stmt|;
comment|/* select other planes */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_SOURCE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/* select all planes */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* load DESTINATION origin and vectors  */
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|NORMAL
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|RASTEROP_COMPLETE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
name|cursor
index|[
name|unit
index|]
operator|.
name|x
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
name|CHAR_WIDTH
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
name|cursor
index|[
name|unit
index|]
operator|.
name|y
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/* load SOURCE origin and vectors  */
name|adder
operator|->
name|source_1_x
operator|=
name|FONT_X
operator|+
operator|(
operator|(
name|chr
operator|-
literal|' '
operator|)
operator|*
name|CHAR_WIDTH
operator|)
expr_stmt|;
name|adder
operator|->
name|source_1_y
operator|=
name|FONT_Y
expr_stmt|;
name|adder
operator|->
name|source_1_dx
operator|=
name|CHAR_WIDTH
expr_stmt|;
name|adder
operator|->
name|source_1_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R1
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|RASTEROP
operator||
name|OCRB
operator||
literal|0
operator||
name|S1E
operator||
name|DTE
expr_stmt|;
comment|/* update console cursor coordinates */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|+=
name|CHAR_WIDTH
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
comment|/* auto-wrap margin */
if|if
condition|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|>
operator|(
literal|1024
operator|-
name|CHAR_WIDTH
operator|)
condition|)
block|{
name|blitc
argument_list|(
name|unit
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|blitc
argument_list|(
name|unit
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* blitc */
end_comment

begin_macro
name|qdreset
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|qd_init
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_comment
comment|/****************************************************************** * *	INTERRUPT SERVICE ROUTINES START HERE: * ******************************************************************/
end_comment

begin_comment
comment|/***************************************************************** * *	qddint()... service "DMA DONE" interrupt condition * *****************************************************************/
end_comment

begin_macro
name|qddint
argument_list|(
argument|qd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|qd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|DMAreq_header
modifier|*
name|header
decl_stmt|;
specifier|register
name|struct
name|DMAreq
modifier|*
name|request
decl_stmt|;
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|int
name|cookie
decl_stmt|;
comment|/* DMA adrs for QDSS */
name|int
name|i
decl_stmt|;
name|spl4
argument_list|()
expr_stmt|;
comment|/* allow interval timer in */
comment|/* 	* init pointers  	*/
name|header
operator|=
name|DMAheader
index|[
name|qd
index|]
expr_stmt|;
comment|/* register for optimization */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|dga
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|adder
expr_stmt|;
comment|/* 	* if this interrupt flagged as bogus for interrupt flushing purposes..  	*/
if|if
condition|(
name|DMA_ISIGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|DMA_CLRIGNORE
argument_list|(
name|header
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*---------------------------------------------------- * dump a DMA hardware error message if appropriate */
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|DMA_ERR
condition|)
block|{
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|PARITY_ERR
condition|)
name|printf
argument_list|(
literal|"qd%d: qddint: DMA hardware parity fault.\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|BUS_ERR
condition|)
name|printf
argument_list|(
literal|"qd%d: qddint: DMA hardware bus error.\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------- * if this was a DMA from user space... */
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|user_dma
condition|)
block|{
name|qdflags
index|[
name|qd
index|]
operator|.
name|user_dma
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|qdflags
index|[
name|qd
index|]
operator|.
name|user_dma
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*------------------------------------------------------------------------ * if we're doing DMA request queue services, field the error condition */
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|DMA_ERR
condition|)
block|{
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* halt DMA (reset fifo) */
name|dga
operator|->
name|csr
operator||=
name|DMA_ERR
expr_stmt|;
comment|/* clear error condition */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* cancel adder activity */
name|DMA_SETERROR
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* flag error in header status word */
name|DMA_CLRACTIVE
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|header
operator|->
name|DMAreq
index|[
name|header
operator|->
name|oldest
index|]
operator|.
name|DMAdone
operator||=
name|HARD_ERROR
expr_stmt|;
name|header
operator|->
name|newest
operator|=
name|header
operator|->
name|oldest
expr_stmt|;
name|header
operator|->
name|used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rsel
index|[
name|qd
index|]
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&
name|SEL_WRITE
condition|)
block|{
name|selwakeup
argument_list|(
name|rsel
index|[
name|qd
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsel
index|[
name|qd
index|]
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&=
operator|~
name|SEL_WRITE
expr_stmt|;
block|}
if|if
condition|(
name|dga
operator|->
name|bytcnt_lo
operator|!=
literal|0
condition|)
block|{
name|dga
operator|->
name|bytcnt_lo
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
literal|0
expr_stmt|;
name|DMA_SETIGNORE
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*---------------------------------------------------------------------------- * if the DMA request queue is now becoming non-full, wakeup "select" client */
if|if
condition|(
name|DMA_ISFULL
argument_list|(
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|rsel
index|[
name|qd
index|]
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&
name|SEL_WRITE
condition|)
block|{
name|selwakeup
argument_list|(
name|rsel
index|[
name|qd
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsel
index|[
name|qd
index|]
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&=
operator|~
name|SEL_WRITE
expr_stmt|;
block|}
block|}
name|header
operator|->
name|DMAreq
index|[
name|header
operator|->
name|oldest
index|]
operator|.
name|DMAdone
operator||=
name|REQUEST_DONE
expr_stmt|;
if|if
condition|(
name|DMA_ISEMPTY
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qddint: unexpected interrupt\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
return|return;
block|}
name|DMA_GETEND
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* update request queue indices */
comment|/*------------------------------------------------------------ * if no more DMA pending, wake up "select" client and exit */
if|if
condition|(
name|DMA_ISEMPTY
argument_list|(
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|rsel
index|[
name|qd
index|]
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&
name|SEL_WRITE
condition|)
block|{
name|selwakeup
argument_list|(
name|rsel
index|[
name|qd
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsel
index|[
name|qd
index|]
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&=
operator|~
name|SEL_WRITE
expr_stmt|;
block|}
name|DMA_CLRACTIVE
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* flag DMA done */
return|return;
block|}
comment|/*--------------------------- * initiate next DMA xfer  */
name|request
operator|=
name|DMA_GETBEGIN
argument_list|(
name|header
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|request
operator|->
name|DMAtype
condition|)
block|{
case|case
name|DISPLIST
case|:
name|dga
operator|->
name|csr
operator||=
name|DL_ENB
expr_stmt|;
break|break;
case|case
name|PTOB
case|:
name|dga
operator|->
name|csr
operator||=
name|PTOB_ENB
expr_stmt|;
break|break;
case|case
name|BTOP
case|:
name|dga
operator|->
name|csr
operator||=
name|BTOP_ENB
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"qd%d: qddint: illegal DMAtype parameter.\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
name|DMA_CLRACTIVE
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* flag DMA done */
return|return;
block|}
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|COUNT_ZERO
condition|)
block|{
name|dga
operator|->
name|csr
operator|&=
operator|~
name|SET_DONE_FIFO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|FIFO_EMPTY
condition|)
block|{
name|dga
operator|->
name|csr
operator||=
name|SET_DONE_FIFO
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|WORD_PACK
condition|)
name|dga
operator|->
name|csr
operator|&=
operator|~
name|BYTE_DMA
expr_stmt|;
elseif|else
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|BYTE_PACK
condition|)
name|dga
operator|->
name|csr
operator||=
name|BYTE_DMA
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
name|cookie
operator|=
operator|(
operator|(
name|int
operator|)
name|request
operator|->
name|bufp
operator|-
operator|(
name|int
operator|)
name|header
operator|)
operator|+
operator|(
name|int
operator|)
name|header
operator|->
name|QBAreg
expr_stmt|;
name|dga
operator|->
name|adrs_lo
operator|=
operator|(
name|short
operator|)
name|cookie
expr_stmt|;
name|dga
operator|->
name|adrs_hi
operator|=
call|(
name|short
call|)
argument_list|(
name|cookie
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|dga
operator|->
name|bytcnt_lo
operator|=
operator|(
name|short
operator|)
name|request
operator|->
name|length
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
call|(
name|short
call|)
argument_list|(
name|request
operator|->
name|length
operator|>>
literal|16
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/***************************************************************** * *	qdaint()... ADDER interrupt service * *****************************************************************/
end_comment

begin_expr_stmt
name|qdaint
argument_list|(
name|qd
argument_list|)
specifier|register
name|int
name|qd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|struct
name|color_buf
modifier|*
name|cbuf
decl_stmt|;
name|short
name|stat
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|rgb
modifier|*
name|rgbp
decl_stmt|;
specifier|register
name|short
modifier|*
name|red
decl_stmt|;
specifier|register
name|short
modifier|*
name|green
decl_stmt|;
specifier|register
name|short
modifier|*
name|blue
decl_stmt|;
name|spl4
argument_list|()
expr_stmt|;
comment|/* allow interval timer in */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|adder
expr_stmt|;
comment|/*------------------------------------------------------------------------ * service the vertical blank interrupt (VSYNC bit) by loading any pending * color map load request  */
if|if
condition|(
name|adder
operator|->
name|status
operator|&
name|VSYNC
condition|)
block|{
name|adder
operator|->
name|status
operator|&=
operator|~
name|VSYNC
expr_stmt|;
comment|/* clear the interrupt */
name|cbuf
operator|=
name|color_buf
index|[
name|qd
index|]
expr_stmt|;
if|if
condition|(
name|cbuf
operator|->
name|status
operator|&
name|LOAD_COLOR_MAP
condition|)
block|{
name|red
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|red
expr_stmt|;
name|green
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|green
expr_stmt|;
name|blue
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|blue
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cbuf
operator|->
name|count
operator|,
name|rgbp
operator|=
name|cbuf
operator|->
name|rgb
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|rgbp
operator|++
control|)
block|{
name|red
index|[
name|rgbp
operator|->
name|offset
index|]
operator|=
operator|(
name|short
operator|)
name|rgbp
operator|->
name|red
expr_stmt|;
name|green
index|[
name|rgbp
operator|->
name|offset
index|]
operator|=
operator|(
name|short
operator|)
name|rgbp
operator|->
name|green
expr_stmt|;
name|blue
index|[
name|rgbp
operator|->
name|offset
index|]
operator|=
operator|(
name|short
operator|)
name|rgbp
operator|->
name|blue
expr_stmt|;
block|}
name|cbuf
operator|->
name|status
operator|&=
operator|~
name|LOAD_COLOR_MAP
expr_stmt|;
block|}
block|}
comment|/*------------------------------------------------- * service the scroll interrupt (FRAME_SYNC bit) */
if|if
condition|(
name|adder
operator|->
name|status
operator|&
name|FRAME_SYNC
condition|)
block|{
name|adder
operator|->
name|status
operator|&=
operator|~
name|FRAME_SYNC
expr_stmt|;
comment|/* clear the interrupt */
if|if
condition|(
name|scroll
index|[
name|qd
index|]
operator|->
name|status
operator|&
name|LOAD_REGS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|stat
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|ID_SCROLL_READY
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdaint: timeout on ID_SCROLL_READY\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
return|return;
block|}
name|adder
operator|->
name|ID_scroll_data
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|viper_constant
expr_stmt|;
name|adder
operator|->
name|ID_scroll_command
operator|=
name|ID_LOAD
operator||
name|SCROLL_CONSTANT
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|y_scroll_constant
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|y_offset
expr_stmt|;
if|if
condition|(
name|scroll
index|[
name|qd
index|]
operator|->
name|status
operator|&
name|LOAD_INDEX
condition|)
block|{
name|adder
operator|->
name|x_index_pending
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|x_index_pending
expr_stmt|;
name|adder
operator|->
name|y_index_pending
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|y_index_pending
expr_stmt|;
block|}
name|scroll
index|[
name|qd
index|]
operator|->
name|status
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/***************************************************************** * *	qdiint()... DUART input interrupt service routine * *****************************************************************/
end_comment

begin_expr_stmt
name|qdiint
argument_list|(
name|qd
argument_list|)
specifier|register
name|int
name|qd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|_vs_event
modifier|*
name|event
decl_stmt|;
specifier|register
name|struct
name|qdinput
modifier|*
name|eqh
decl_stmt|;
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|struct
name|mouse_report
modifier|*
name|new_rep
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|char
name|chr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|k
decl_stmt|,
name|l
decl_stmt|;
name|u_short
name|status
decl_stmt|;
name|u_short
name|data
decl_stmt|;
name|u_short
name|key
decl_stmt|;
name|char
name|do_wakeup
init|=
literal|0
decl_stmt|;
comment|/* flag to do a select wakeup call */
name|char
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
comment|/* mouse button test variables */
name|spl4
argument_list|()
expr_stmt|;
comment|/* allow interval timer in */
name|eqh
operator|=
name|eq_header
index|[
name|qd
index|]
expr_stmt|;
comment|/* optimized as a register */
name|new_rep
operator|=
operator|&
name|current_rep
index|[
name|qd
index|]
expr_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|duart
expr_stmt|;
comment|/*----------------------------------------- * if the graphic device is turned on..	*/
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
condition|)
block|{
comment|/*--------------- 	    * empty DUART */
while|while
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|RCV_RDY
operator|||
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
comment|/*--------------------------------- 		* pick up LK-201 input (if any) */
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
comment|/* if error condition, then reset it */
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
literal|0x70
condition|)
block|{
name|duart
operator|->
name|cmdA
operator|=
literal|0x40
expr_stmt|;
continue|continue;
block|}
comment|/* event queue full now? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: event queue overflow\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*-------------------------------------- 		    * Check for various keyboard errors  */
name|key
operator|=
name|duart
operator|->
name|dataA
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|LK_POWER_ERROR
operator|||
name|key
operator|==
name|LK_KDOWN_ERROR
operator|||
name|key
operator|==
name|LK_INPUT_ERROR
operator|||
name|key
operator|==
name|LK_OUTPUT_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: keyboard error, code = %x\n"
argument_list|,
name|qd
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|key
operator|<
name|LK_LOWEST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request a select wakeup call */
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
name|event
operator|->
name|vse_key
operator|=
name|key
expr_stmt|;
name|event
operator|->
name|vse_key
operator|&=
literal|0x00FF
expr_stmt|;
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
name|event
operator|->
name|vse_type
operator|=
name|VSE_BUTTON
expr_stmt|;
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTRAW
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_DKB
expr_stmt|;
block|}
comment|/*------------------------------------- 		* pick up the mouse input (if any)  */
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|pntr_id
operator|==
name|MOUSE_ID
condition|)
block|{
if|if
condition|(
name|status
operator|&
literal|0x70
condition|)
block|{
name|duart
operator|->
name|cmdB
operator|=
literal|0x40
expr_stmt|;
continue|continue;
block|}
comment|/* event queue full now? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: event queue overflow\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
comment|/* get report byte */
operator|++
name|new_rep
operator|->
name|bytcnt
expr_stmt|;
comment|/* bump report byte count */
comment|/*--------------------------- 		    * if 1st byte of report.. */
if|if
condition|(
name|data
operator|&
name|START_FRAME
condition|)
block|{
name|new_rep
operator|->
name|state
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|>
literal|1
condition|)
block|{
name|new_rep
operator|->
name|bytcnt
operator|=
literal|1
expr_stmt|;
comment|/* start of new frame */
continue|continue;
comment|/* ..continue looking */
block|}
block|}
comment|/*--------------------------- 		    * if 2nd byte of report.. */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|2
condition|)
block|{
name|new_rep
operator|->
name|dx
operator|=
name|data
operator|&
literal|0x00FF
expr_stmt|;
block|}
comment|/*------------------------------------------------- 		    * if 3rd byte of report, load input event queue */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|3
condition|)
block|{
name|new_rep
operator|->
name|dy
operator|=
name|data
operator|&
literal|0x00FF
expr_stmt|;
name|new_rep
operator|->
name|bytcnt
operator|=
literal|0
expr_stmt|;
comment|/*----------------------------------- 			* if mouse position has changed.. */
if|if
condition|(
name|new_rep
operator|->
name|dx
operator|!=
literal|0
operator|||
name|new_rep
operator|->
name|dy
operator|!=
literal|0
condition|)
block|{
comment|/*--------------------------------------------- 			    * calculate acceleration factor, if needed	*/
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_acc
operator|>
name|ACC_OFF
condition|)
block|{
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_thr
operator|<=
name|new_rep
operator|->
name|dx
condition|)
name|new_rep
operator|->
name|dx
operator|+=
operator|(
name|new_rep
operator|->
name|dx
operator|-
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_thr
operator|)
operator|*
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_acc
expr_stmt|;
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_thr
operator|<=
name|new_rep
operator|->
name|dy
condition|)
name|new_rep
operator|->
name|dy
operator|+=
operator|(
name|new_rep
operator|->
name|dy
operator|-
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_thr
operator|)
operator|*
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_acc
expr_stmt|;
block|}
comment|/*------------------------------------- 			    * update cursor position coordinates */
if|if
condition|(
name|new_rep
operator|->
name|state
operator|&
name|X_SIGN
condition|)
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|+=
name|new_rep
operator|->
name|dx
expr_stmt|;
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|>
literal|1023
condition|)
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|=
literal|1023
expr_stmt|;
block|}
else|else
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|-=
name|new_rep
operator|->
name|dx
expr_stmt|;
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|<
operator|-
literal|15
condition|)
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|=
operator|-
literal|15
expr_stmt|;
block|}
if|if
condition|(
name|new_rep
operator|->
name|state
operator|&
name|Y_SIGN
condition|)
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|-=
name|new_rep
operator|->
name|dy
expr_stmt|;
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|<
operator|-
literal|15
condition|)
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|=
operator|-
literal|15
expr_stmt|;
block|}
else|else
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|+=
name|new_rep
operator|->
name|dy
expr_stmt|;
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|>
literal|863
condition|)
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|=
literal|863
expr_stmt|;
block|}
comment|/*--------------------------------- 			    * update cursor screen position */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
argument_list|)
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|eqh
operator|->
name|curs_pos
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/*-------------------------------------------- 			    * if cursor is in the box, no event report */
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|<=
name|eqh
operator|->
name|curs_box
operator|.
name|right
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|>=
name|eqh
operator|->
name|curs_box
operator|.
name|left
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|>=
name|eqh
operator|->
name|curs_box
operator|.
name|top
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|<=
name|eqh
operator|->
name|curs_box
operator|.
name|bottom
condition|)
block|{
goto|goto
name|GET_MBUTTON
goto|;
block|}
comment|/*--------------------------------- 			    * report the mouse motion event */
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request a select wakeup call */
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_MOUSE
expr_stmt|;
comment|/* mouse */
name|event
operator|->
name|vse_type
operator|=
name|VSE_MMOTION
expr_stmt|;
comment|/* pos changed */
name|event
operator|->
name|vse_key
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|vse_direction
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
comment|/* time stamp */
block|}
name|GET_MBUTTON
label|:
comment|/*------------------------------- 			* if button state has changed */
name|a
operator|=
name|new_rep
operator|->
name|state
operator|&
literal|0x07
expr_stmt|;
comment|/*mask nonbutton bits */
name|b
operator|=
name|last_rep
index|[
name|qd
index|]
operator|.
name|state
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|a
operator|^
name|b
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
literal|8
condition|;
name|c
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|c
operator|&
operator|(
name|a
operator|^
name|b
operator|)
operator|)
condition|)
comment|/* this button change? */
continue|continue;
comment|/* event queue full? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: event queue overflow\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
comment|/* get new event */
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request select wakeup */
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_MOUSE
expr_stmt|;
comment|/* mouse */
name|event
operator|->
name|vse_type
operator|=
name|VSE_BUTTON
expr_stmt|;
comment|/* new button */
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
comment|/* time stamp */
comment|/* flag changed button and if up or down */
if|if
condition|(
name|c
operator|==
name|RIGHT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_RIGHT_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|MIDDLE_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_MIDDLE_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|LEFT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_LEFT_BUTTON
expr_stmt|;
comment|/* set bit = button depressed */
if|if
condition|(
name|c
operator|&
name|a
condition|)
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTDOWN
expr_stmt|;
else|else
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTUP
expr_stmt|;
block|}
block|}
comment|/* refresh last report */
name|last_rep
index|[
name|qd
index|]
operator|=
name|current_rep
index|[
name|qd
index|]
expr_stmt|;
block|}
comment|/* get last byte of report */
block|}
comment|/* pickup mouse input */
comment|/*-------------------------------- 		* pickup tablet input, if any  */
elseif|else
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|pntr_id
operator|==
name|TABLET_ID
condition|)
block|{
if|if
condition|(
name|status
operator|&
literal|0x70
condition|)
block|{
name|duart
operator|->
name|cmdB
operator|=
literal|0x40
expr_stmt|;
continue|continue;
block|}
comment|/* event queue full now? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: event queue overflow\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
comment|/* get report byte */
operator|++
name|new_rep
operator|->
name|bytcnt
expr_stmt|;
comment|/* bump report byte count */
comment|/*--------------------------- 		    * if 1st byte of report.. */
if|if
condition|(
name|data
operator|&
name|START_FRAME
condition|)
block|{
name|new_rep
operator|->
name|state
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|>
literal|1
condition|)
block|{
name|new_rep
operator|->
name|bytcnt
operator|=
literal|1
expr_stmt|;
comment|/* start of new frame */
continue|continue;
comment|/* ..continue looking */
block|}
block|}
comment|/*--------------------------- 		    * if 2nd byte of report.. */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|2
condition|)
block|{
name|new_rep
operator|->
name|dx
operator|=
name|data
operator|&
literal|0x3F
expr_stmt|;
block|}
comment|/*--------------------------- 		    * if 3rd byte of report.. */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|3
condition|)
block|{
name|new_rep
operator|->
name|dx
operator||=
operator|(
name|data
operator|&
literal|0x3F
operator|)
operator|<<
literal|6
expr_stmt|;
block|}
comment|/*--------------------------- 		    * if 4th byte of report.. */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|4
condition|)
block|{
name|new_rep
operator|->
name|dy
operator|=
name|data
operator|&
literal|0x3F
expr_stmt|;
block|}
comment|/*------------------------------------------------- 		    * if 5th byte of report, load input event queue */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|5
condition|)
block|{
name|new_rep
operator|->
name|dy
operator||=
operator|(
name|data
operator|&
literal|0x3F
operator|)
operator|<<
literal|6
expr_stmt|;
name|new_rep
operator|->
name|bytcnt
operator|=
literal|0
expr_stmt|;
comment|/*------------------------------------- 			* update cursor position coordinates */
name|new_rep
operator|->
name|dx
operator|/=
name|qdflags
index|[
name|qd
index|]
operator|.
name|tab_res
expr_stmt|;
name|new_rep
operator|->
name|dy
operator|=
operator|(
literal|2200
operator|-
name|new_rep
operator|->
name|dy
operator|)
operator|/
name|qdflags
index|[
name|qd
index|]
operator|.
name|tab_res
expr_stmt|;
if|if
condition|(
name|new_rep
operator|->
name|dx
operator|>
literal|1023
condition|)
block|{
name|new_rep
operator|->
name|dx
operator|=
literal|1023
expr_stmt|;
block|}
if|if
condition|(
name|new_rep
operator|->
name|dy
operator|>
literal|863
condition|)
block|{
name|new_rep
operator|->
name|dy
operator|=
literal|863
expr_stmt|;
block|}
comment|/* 			 * report an event if the puck/stylus has moved 			 */
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|!=
name|new_rep
operator|->
name|dx
operator|||
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|!=
name|new_rep
operator|->
name|dy
condition|)
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|=
name|new_rep
operator|->
name|dx
expr_stmt|;
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|=
name|new_rep
operator|->
name|dy
expr_stmt|;
comment|/*--------------------------------- 			    * update cursor screen position */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
argument_list|)
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|eqh
operator|->
name|curs_pos
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* 			     * if cursor is in the box, no event report 			     */
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|<=
name|eqh
operator|->
name|curs_box
operator|.
name|right
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|>=
name|eqh
operator|->
name|curs_box
operator|.
name|left
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|>=
name|eqh
operator|->
name|curs_box
operator|.
name|top
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|<=
name|eqh
operator|->
name|curs_box
operator|.
name|bottom
condition|)
block|{
goto|goto
name|GET_TBUTTON
goto|;
block|}
comment|/*--------------------------------- 			    * report the tablet motion event */
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request a select wakeup call */
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_TABLET
expr_stmt|;
comment|/* tablet */
comment|/* 			     * right now, X handles tablet motion the same 			     * as mouse motion 			     */
name|event
operator|->
name|vse_type
operator|=
name|VSE_MMOTION
expr_stmt|;
comment|/* pos changed */
name|event
operator|->
name|vse_key
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|vse_direction
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
comment|/* time stamp */
block|}
name|GET_TBUTTON
label|:
comment|/*------------------------------- 			* if button state has changed */
name|a
operator|=
name|new_rep
operator|->
name|state
operator|&
literal|0x1E
expr_stmt|;
comment|/* mask nonbutton bits */
name|b
operator|=
name|last_rep
index|[
name|qd
index|]
operator|.
name|state
operator|&
literal|0x1E
expr_stmt|;
if|if
condition|(
name|a
operator|^
name|b
condition|)
block|{
comment|/* event queue full now? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: event queue overflow\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
comment|/* get new event */
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request a select wakeup call */
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_TABLET
expr_stmt|;
comment|/* tablet */
name|event
operator|->
name|vse_type
operator|=
name|VSE_BUTTON
expr_stmt|;
comment|/* button changed */
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
comment|/* time stamp */
comment|/* define the changed button and if up or down */
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<=
literal|0x10
condition|;
name|c
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|c
operator|&
operator|(
name|a
operator|^
name|b
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|T_LEFT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_T_LEFT_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|T_FRONT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_T_FRONT_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|T_RIGHT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_T_RIGHT_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|T_BACK_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_T_BACK_BUTTON
expr_stmt|;
break|break;
block|}
block|}
comment|/* set bit = button depressed */
if|if
condition|(
name|c
operator|&
name|a
condition|)
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTDOWN
expr_stmt|;
else|else
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTUP
expr_stmt|;
block|}
comment|/* refresh last report */
name|last_rep
index|[
name|qd
index|]
operator|=
name|current_rep
index|[
name|qd
index|]
expr_stmt|;
block|}
comment|/* get last byte of report */
block|}
comment|/* pick up tablet input */
block|}
comment|/* while input available.. */
comment|/*--------------------- 	    * do select wakeup	*/
if|if
condition|(
name|rsel
index|[
name|qd
index|]
operator|&&
name|do_wakeup
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&
name|SEL_READ
condition|)
block|{
name|selwakeup
argument_list|(
name|rsel
index|[
name|qd
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsel
index|[
name|qd
index|]
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&=
operator|~
name|SEL_READ
expr_stmt|;
name|do_wakeup
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*----------------------------------------------------------------- 	* if the graphic device is not turned on, this is console input */
else|else
block|{
name|ui
operator|=
name|qdinfo
index|[
name|qd
index|]
expr_stmt|;
if|if
condition|(
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|qd
operator|<<
literal|2
index|]
expr_stmt|;
comment|/*-------------------------------------- 	    * Get a character from the keyboard. */
while|while
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
name|key
operator|=
name|duart
operator|->
name|dataA
expr_stmt|;
name|key
operator|&=
literal|0xFF
expr_stmt|;
comment|/*-------------------------------------- 		* Check for various keyboard errors  */
if|if
condition|(
name|key
operator|==
name|LK_POWER_ERROR
operator|||
name|key
operator|==
name|LK_KDOWN_ERROR
operator|||
name|key
operator|==
name|LK_INPUT_ERROR
operator|||
name|key
operator|==
name|LK_OUTPUT_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: Keyboard error, code = %x\n"
argument_list|,
name|qd
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|key
operator|<
name|LK_LOWEST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*--------------------------------- 		* See if its a state change key */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|LOCK
case|:
name|q_keyboard
operator|.
name|lock
operator|^=
literal|0xffff
expr_stmt|;
comment|/* toggle */
if|if
condition|(
name|q_keyboard
operator|.
name|lock
condition|)
name|led_control
argument_list|(
name|qd
argument_list|,
name|LK_LED_ENABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
else|else
name|led_control
argument_list|(
name|qd
argument_list|,
name|LK_LED_DISABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
return|return;
case|case
name|SHIFT
case|:
name|q_keyboard
operator|.
name|shift
operator|^=
literal|0xFFFF
expr_stmt|;
return|return;
case|case
name|CNTRL
case|:
name|q_keyboard
operator|.
name|cntrl
operator|^=
literal|0xFFFF
expr_stmt|;
return|return;
case|case
name|ALLUP
case|:
name|q_keyboard
operator|.
name|cntrl
operator|=
literal|0
expr_stmt|;
name|q_keyboard
operator|.
name|shift
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|REPEAT
case|:
name|chr
operator|=
name|q_keyboard
operator|.
name|last
expr_stmt|;
break|break;
comment|/*------------------------------------------------------- 		    * Test for cntrl characters. If set, see if the character 		    * is elligible to become a control character. */
default|default:
if|if
condition|(
name|q_keyboard
operator|.
name|cntrl
condition|)
block|{
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|chr
operator|>=
literal|' '
operator|&&
name|chr
operator|<=
literal|'~'
condition|)
name|chr
operator|&=
literal|0x1F
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q_keyboard
operator|.
name|lock
operator|||
name|q_keyboard
operator|.
name|shift
condition|)
name|chr
operator|=
name|q_shift_key
index|[
name|key
index|]
expr_stmt|;
else|else
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
break|break;
block|}
name|q_keyboard
operator|.
name|last
operator|=
name|chr
expr_stmt|;
comment|/*----------------------------------- 		* Check for special function keys */
if|if
condition|(
name|chr
operator|&
literal|0x80
condition|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|string
operator|=
name|q_special
index|[
name|chr
operator|&
literal|0x7F
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|string
operator|++
operator|,
name|tp
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|chr
operator|,
name|tp
operator|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdiint */
end_comment

begin_comment
comment|/****************************************************************** * *	THE SUBROUTINES START HERE: * ******************************************************************/
end_comment

begin_comment
comment|/***************************************************************** * *	clear_qd_screen()... clear the QDSS screen * ****************************************************************** * *>>> NOTE<<< * *   This code requires that certain adder initialization be valid.  To *   assure that this requirement is satisfied, this routine should be *   called only after calling the "setup_dragon()" function. * *   Clear the bitmap a piece at a time. Since the fast scroll clear *   only clears the current displayed portion of the bitmap put a *   temporary value in the y limit register so we can access whole *   bitmap * ****************/
end_comment

begin_macro
name|clear_qd_screen
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|adder
operator|->
name|x_limit
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|y_limit
operator|=
literal|2048
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|0
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* wait at LEAST 1 full frame */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|SCROLL_ERASE
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|864
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|SCROLL_ERASE
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|1728
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|SCROLL_ERASE
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|0
expr_stmt|;
comment|/* back to normal */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|x_limit
operator|=
name|MAX_SCREEN_X
expr_stmt|;
name|adder
operator|->
name|y_limit
operator|=
name|MAX_SCREEN_Y
operator|+
name|FONT_HEIGHT
expr_stmt|;
block|}
end_block

begin_comment
comment|/* clear_qd_screen */
end_comment

begin_comment
comment|/********************************************************************** * *	qdputc()... route kernel console output to display destination * *********************************************************************** * *	calling convention: * *		qdputc(chr); * *	where:	char chr;	 ;character for output * ****************/
end_comment

begin_expr_stmt
name|qdputc
argument_list|(
name|chr
argument_list|)
specifier|register
name|char
name|chr
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* if system is now physical, forget it (ie: crash DUMP) */
if|if
condition|(
operator|(
name|mfpr
argument_list|(
name|MAPEN
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return;
name|blitc
argument_list|(
literal|0
argument_list|,
name|chr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chr
operator|&
literal|0177
operator|)
operator|==
literal|'\n'
condition|)
name|blitc
argument_list|(
literal|0
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* qdputc */
end_comment

begin_comment
comment|/******************************************************************* * *	qdgetc()... get a character from the LK201 * ******************************************************************* * *	calling convention: * *		qdgetc(); * *	returns:  the character read. * ****************/
end_comment

begin_macro
name|qdgetc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|short
name|key
decl_stmt|;
specifier|register
name|char
name|chr
decl_stmt|;
specifier|register
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
literal|0
index|]
operator|.
name|duart
expr_stmt|;
comment|/*-------------------------------------- 	* Get a character from the keyboard. */
name|LOOP
label|:
while|while
condition|(
operator|!
operator|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|RCV_RDY
operator|)
condition|)
empty_stmt|;
name|key
operator|=
name|duart
operator|->
name|dataA
expr_stmt|;
name|key
operator|&=
literal|0xFF
expr_stmt|;
comment|/*-------------------------------------- 	* Check for various keyboard errors  */
if|if
condition|(
name|key
operator|==
name|LK_POWER_ERROR
operator|||
name|key
operator|==
name|LK_KDOWN_ERROR
operator|||
name|key
operator|==
name|LK_INPUT_ERROR
operator|||
name|key
operator|==
name|LK_OUTPUT_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"Keyboard error, code = %x\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|key
operator|<
name|LK_LOWEST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*--------------------------------- 	* See if its a state change key */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|LOCK
case|:
name|q_keyboard
operator|.
name|lock
operator|^=
literal|0xffff
expr_stmt|;
comment|/* toggle */
if|if
condition|(
name|q_keyboard
operator|.
name|lock
condition|)
name|led_control
argument_list|(
name|LK_LED_ENABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
else|else
name|led_control
argument_list|(
name|LK_LED_DISABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|SHIFT
case|:
name|q_keyboard
operator|.
name|shift
operator|^=
literal|0xFFFF
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|CNTRL
case|:
name|q_keyboard
operator|.
name|cntrl
operator|^=
literal|0xFFFF
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|ALLUP
case|:
name|q_keyboard
operator|.
name|cntrl
operator|=
literal|0
expr_stmt|;
name|q_keyboard
operator|.
name|shift
operator|=
literal|0
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|REPEAT
case|:
name|chr
operator|=
name|q_keyboard
operator|.
name|last
expr_stmt|;
break|break;
comment|/*------------------------------------------------------- 	    * Test for cntrl characters. If set, see if the character 	    * is elligible to become a control character. */
default|default:
if|if
condition|(
name|q_keyboard
operator|.
name|cntrl
condition|)
block|{
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|chr
operator|>=
literal|' '
operator|&&
name|chr
operator|<=
literal|'~'
condition|)
name|chr
operator|&=
literal|0x1F
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q_keyboard
operator|.
name|lock
operator|||
name|q_keyboard
operator|.
name|shift
condition|)
name|chr
operator|=
name|q_shift_key
index|[
name|key
index|]
expr_stmt|;
else|else
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chr
operator|<
literal|' '
operator|&&
name|chr
operator|>
literal|'~'
condition|)
comment|/* if input is non-displayable */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ..then pitch it! */
name|q_keyboard
operator|.
name|last
operator|=
name|chr
expr_stmt|;
comment|/*----------------------------------- 	* Check for special function keys */
if|if
condition|(
name|chr
operator|&
literal|0x80
condition|)
comment|/* pitch the function keys */
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|chr
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdgetc */
end_comment

begin_comment
comment|/********************************************************************** * *	ldcursor()... load the mouse cursor's template RAM bitmap * ********************************************************************* * *	calling convention: * *		ldcursor(unit, bitmap); *		u_int unit; *		short *bitmap; * ****************/
end_comment

begin_macro
name|ldcursor
argument_list|(
argument|unit
argument_list|,
argument|bitmap
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|bitmap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
specifier|register
name|short
modifier|*
name|temp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|cursor
decl_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|temp
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|template
expr_stmt|;
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|CURS_ENB
condition|)
block|{
comment|/* if the cursor is enabled.. */
name|cursor
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* ..note that.. */
name|dga
operator|->
name|csr
operator|&=
operator|~
name|CURS_ENB
expr_stmt|;
comment|/* ..and shut it off */
block|}
else|else
block|{
name|cursor
operator|=
literal|0
expr_stmt|;
block|}
name|dga
operator|->
name|csr
operator|&=
operator|~
name|CURS_ENB
expr_stmt|;
comment|/* shut off the cursor */
name|temp
operator|+=
operator|(
literal|8
operator|*
literal|1024
operator|)
operator|-
literal|32
expr_stmt|;
comment|/* cursor is 32 WORDS from the end */
comment|/* ..of the 8k WORD template space */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
operator|*
name|temp
operator|++
operator|=
operator|*
name|bitmap
operator|++
expr_stmt|;
if|if
condition|(
name|cursor
condition|)
block|{
comment|/* if cursor was enabled.. */
name|dga
operator|->
name|csr
operator||=
name|CURS_ENB
expr_stmt|;
comment|/* ..turn it back on */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ldcursor */
end_comment

begin_comment
comment|/********************************************************************** * *	ldfont()... put the console font in the QDSS off-screen memory * *********************************************************************** * *	calling convention: * *		ldfont(unit); *		u_int unit;	;QDSS unit number * ****************/
end_comment

begin_macro
name|ldfont
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* scratch variables */
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|short
name|packed
decl_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
comment|/*------------------------------------------ 	* setup VIPER operand control registers  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC2_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_SOURCE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|DST_INDEX_ENABLE
operator||
name|NORMAL
expr_stmt|;
comment|/*-------------------------- 	* load destination data  */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|RASTEROP_COMPLETE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
name|FONT_X
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
name|FONT_Y
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
name|FONT_WIDTH
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/*--------------------------------------- 	* setup for processor to bitmap xfer  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|PBT
operator||
name|OCRB
operator||
literal|2
operator||
name|DTE
operator||
literal|2
expr_stmt|;
comment|/*----------------------------------------------- 	* iteratively do the processor to bitmap xfer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ROWS
condition|;
operator|++
name|i
control|)
block|{
comment|/* PTOB a scan line */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|i
init|;
name|j
operator|<
literal|48
condition|;
operator|++
name|j
control|)
block|{
comment|/* PTOB one scan of a char cell */
name|packed
operator|=
name|q_font
index|[
name|k
index|]
expr_stmt|;
name|k
operator|+=
name|ROWS
expr_stmt|;
name|packed
operator||=
operator|(
operator|(
name|short
operator|)
name|q_font
index|[
name|k
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|k
operator|+=
name|ROWS
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|TX_READY
argument_list|)
expr_stmt|;
name|adder
operator|->
name|id_data
operator|=
name|packed
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* ldfont */
end_comment

begin_comment
comment|/********************************************************************* * *	led_control()... twiddle LK-201 LED's * ********************************************************************** * *	led_control(unit, cmd, led_mask); *	u_int unit;	QDSS number *	int cmd;	LED enable/disable command *	int led_mask;	which LED(s) to twiddle * *************/
end_comment

begin_macro
name|led_control
argument_list|(
argument|unit
argument_list|,
argument|cmd
argument_list|,
argument|led_mask
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|led_mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
specifier|register
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmd
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|led_mask
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_comment
comment|/* led_control */
end_comment

begin_comment
comment|/******************************************************************* * *	scroll_up()... move the screen up one character height * ******************************************************************** * *	calling convention: * *		scroll_up(adder); *		struct adder *adder;	;address of adder * ********/
end_comment

begin_expr_stmt
name|scroll_up
argument_list|(
name|adder
argument_list|)
specifier|register
expr|struct
name|adder
operator|*
name|adder
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*------------------------------------------ 	* setup VIPER operand control registers  */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|ADDRESS_COMPLETE
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/* select all planes */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
comment|/*---------------------------------------- 	* load DESTINATION origin and vectors  */
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|NORMAL
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
literal|864
operator|-
name|CHAR_HEIGHT
expr_stmt|;
comment|/*----------------------------------- 	* load SOURCE origin and vectors  */
name|adder
operator|->
name|source_1_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_1_dx
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|source_1_y
operator|=
literal|0
operator|+
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|source_1_dy
operator|=
literal|864
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R1
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|RASTEROP
operator||
name|OCRB
operator||
literal|0
operator||
name|S1E
operator||
name|DTE
expr_stmt|;
comment|/*-------------------------------------------- 	* do a rectangle clear of last screen line */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SOURCE
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
operator|(
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
operator|)
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
comment|/* set up the width of	*/
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/* rectangle */
name|adder
operator|->
name|rasterop_mode
operator|=
operator|(
name|NORMAL
operator||
name|DST_WRITE_ENABLE
operator|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|RASTEROP_COMPLETE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
literal|864
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
literal|1024
expr_stmt|;
comment|/* set up the height	*/
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
comment|/* of rectangle 	*/
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R2
argument_list|,
operator|(
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
operator|)
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
operator|(
name|RASTEROP
operator||
name|OCRB
operator||
name|LF_R2
operator||
name|DTE
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* scroll_up */
end_comment

begin_comment
comment|/******************************************************************** * *	init_shared()... init shared memory pointers and structures * ********************************************************************* * *	calling convention: * *		init_shared(unit); *		u_int unit; * ****************/
end_comment

begin_expr_stmt
name|init_shared
argument_list|(
name|unit
argument_list|)
specifier|register
name|u_int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
comment|/*-------------------------------------------------- 	* initialize the event queue pointers and header */
name|eq_header
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|qdinput
operator|*
operator|)
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
name|event_shared
operator|&
operator|~
operator|(
literal|0x01FF
operator|)
operator|)
operator|+
literal|512
operator|)
operator|+
operator|(
name|EVENT_BUFSIZE
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|x
argument_list|)
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|y
argument_list|)
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_box
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_box
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_box
operator|.
name|top
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_box
operator|.
name|bottom
operator|=
literal|0
expr_stmt|;
comment|/*--------------------------------------------------------- 	* assign a pointer to the DMA I/O buffer for this QDSS. */
name|DMAheader
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|DMAreq_header
operator|*
operator|)
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|&
name|DMA_shared
index|[
literal|0
index|]
operator|+
literal|512
argument_list|)
operator|&
operator|~
literal|0x1FF
operator|)
operator|+
operator|(
name|DMAbuf_size
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|DMAreq
operator|=
operator|(
expr|struct
name|DMAreq
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|DMAheader
index|[
name|unit
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|DMAreq_header
argument_list|)
operator|)
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
operator|=
literal|0
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|shared_size
operator|=
name|DMAbuf_size
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|size
operator|=
literal|10
expr_stmt|;
comment|/* default = 10 requests */
name|DMAheader
index|[
name|unit
index|]
operator|->
name|oldest
operator|=
literal|0
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|newest
operator|=
literal|0
expr_stmt|;
comment|/*----------------------------------------------------------- 	* assign a pointer to the scroll structure for this QDSS. */
name|scroll
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|scroll
operator|*
operator|)
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|&
name|scroll_shared
index|[
literal|0
index|]
operator|+
literal|512
argument_list|)
operator|&
operator|~
literal|0x1FF
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scroll
argument_list|)
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|viper_constant
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|y_scroll_constant
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|y_offset
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|x_index_pending
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|y_index_pending
operator|=
literal|0
expr_stmt|;
comment|/*---------------------------------------------------------------- 	* assign a pointer to the color map write buffer for this QDSS */
name|color_buf
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|color_buf
operator|*
operator|)
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|&
name|color_shared
index|[
literal|0
index|]
operator|+
literal|512
argument_list|)
operator|&
operator|~
literal|0x1FF
operator|)
operator|+
operator|(
name|COLOR_BUFSIZ
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
name|color_buf
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|color_buf
index|[
name|unit
index|]
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* init_shared */
end_comment

begin_comment
comment|/********************************************************************* * *	setup_dragon()... init the ADDER, VIPER, bitmaps,& color map * ********************************************************************** * *	calling convention: * *		setup_dragon(); * *	return: NONE * ************************/
end_comment

begin_macro
name|setup_dragon
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|short
modifier|*
name|memcsr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* general purpose variables */
name|int
name|status
decl_stmt|;
name|short
name|top
decl_stmt|;
comment|/* clipping/scrolling boundaries */
name|short
name|bottom
decl_stmt|;
name|short
name|right
decl_stmt|;
name|short
name|left
decl_stmt|;
name|short
modifier|*
name|red
decl_stmt|;
comment|/* color map pointers */
name|short
modifier|*
name|green
decl_stmt|;
name|short
modifier|*
name|blue
decl_stmt|;
comment|/*------------------ 	* init for setup */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|memcsr
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
operator|(
name|DMA_IE
operator||
literal|0x700
operator|)
expr_stmt|;
comment|/* halt DMA and kill the intrpts */
operator|*
name|memcsr
operator|=
name|SYNC_ON
expr_stmt|;
comment|/* blank screen and turn off LED's */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/*---------------------- 	* set monitor timing */
name|adder
operator|->
name|x_scan_count_0
operator|=
literal|0x2800
expr_stmt|;
name|adder
operator|->
name|x_scan_count_1
operator|=
literal|0x1020
expr_stmt|;
name|adder
operator|->
name|x_scan_count_2
operator|=
literal|0x003A
expr_stmt|;
name|adder
operator|->
name|x_scan_count_3
operator|=
literal|0x38F0
expr_stmt|;
name|adder
operator|->
name|x_scan_count_4
operator|=
literal|0x6128
expr_stmt|;
name|adder
operator|->
name|x_scan_count_5
operator|=
literal|0x093A
expr_stmt|;
name|adder
operator|->
name|x_scan_count_6
operator|=
literal|0x313C
expr_stmt|;
name|adder
operator|->
name|sync_phase_adj
operator|=
literal|0x0100
expr_stmt|;
name|adder
operator|->
name|x_scan_conf
operator|=
literal|0x00C8
expr_stmt|;
comment|/*--------------------------------------------------------- 	* got a bug in secound pass ADDER! lets take care of it */
comment|/* normally, just use the code in the following bug fix code, but to 	* make repeated demos look pretty, load the registers as if there was 	* no bug and then test to see if we are getting sync */
name|adder
operator|->
name|y_scan_count_0
operator|=
literal|0x135F
expr_stmt|;
name|adder
operator|->
name|y_scan_count_1
operator|=
literal|0x3363
expr_stmt|;
name|adder
operator|->
name|y_scan_count_2
operator|=
literal|0x2366
expr_stmt|;
name|adder
operator|->
name|y_scan_count_3
operator|=
literal|0x0388
expr_stmt|;
comment|/* if no sync, do the bug fix code */
if|if
condition|(
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
operator|==
name|BAD
condition|)
block|{
comment|/* first load all Y scan registers with very short frame and 	    * wait for scroll service.	This guarantees at least one SYNC 	    * to fix the pass 2 Adder initialization bug (synchronizes 	    * XCINCH with DMSEEDH) */
name|adder
operator|->
name|y_scan_count_0
operator|=
literal|0x01
expr_stmt|;
name|adder
operator|->
name|y_scan_count_1
operator|=
literal|0x01
expr_stmt|;
name|adder
operator|->
name|y_scan_count_2
operator|=
literal|0x01
expr_stmt|;
name|adder
operator|->
name|y_scan_count_3
operator|=
literal|0x01
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* delay at least 1 full frame time */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* now load the REAL sync values (in reverse order just to 	    *  be safe.  */
name|adder
operator|->
name|y_scan_count_3
operator|=
literal|0x0388
expr_stmt|;
name|adder
operator|->
name|y_scan_count_2
operator|=
literal|0x2366
expr_stmt|;
name|adder
operator|->
name|y_scan_count_1
operator|=
literal|0x3363
expr_stmt|;
name|adder
operator|->
name|y_scan_count_0
operator|=
literal|0x135F
expr_stmt|;
block|}
operator|*
name|memcsr
operator|=
name|SYNC_ON
operator||
name|UNBLANK
expr_stmt|;
comment|/* turn off leds and turn on video */
comment|/*---------------------------- 	* zero the index registers */
name|adder
operator|->
name|x_index_pending
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_index_pending
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|x_index_new
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_index_new
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|x_index_old
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_index_old
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|pause
operator|=
literal|0
expr_stmt|;
comment|/*---------------------------------------- 	* set rasterop mode to normal pen down */
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|DST_INDEX_ENABLE
operator||
name|NORMAL
expr_stmt|;
comment|/*-------------------------------------------------- 	* set the rasterop registers to a default values */
name|adder
operator|->
name|source_1_dx
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|source_1_dy
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|source_1_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_1_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
comment|/*------------------------ 	* scale factor = unity */
name|adder
operator|->
name|fast_scale
operator|=
name|UNITY
expr_stmt|;
name|adder
operator|->
name|slow_scale
operator|=
name|UNITY
expr_stmt|;
comment|/*------------------------------- 	* set the source 2 parameters */
name|adder
operator|->
name|source_2_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_2_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_2_size
operator|=
literal|0x0022
expr_stmt|;
comment|/*----------------------------------------------- 	* initialize plane addresses for eight vipers */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0002
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0002
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0010
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0020
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0040
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0006
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0080
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0007
argument_list|)
expr_stmt|;
comment|/* initialize the external registers. */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_SCROLL_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/* initialize resolution mode */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MEMORY_BUS_WIDTH
argument_list|,
literal|0x000C
argument_list|)
expr_stmt|;
comment|/* bus width = 16 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|RESOLUTION_MODE
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* one bit/pixel */
comment|/* initialize viper registers */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SCROLL_CONSTANT
argument_list|,
name|SCROLL_ENABLE
operator||
name|VIPER_LEFT
operator||
name|VIPER_UP
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SCROLL_FILL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/*---------------------------------------------------- 	* set clipping and scrolling limits to full screen */
for|for
control|(
name|i
operator|=
literal|1000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|ADDRESS_COMPLETE
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"qd%d: setup_dragon: timeout on ADDRESS_COMPLETE\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|bottom
operator|=
literal|2048
expr_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
name|right
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|x_clip_min
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|x_clip_max
operator|=
name|right
expr_stmt|;
name|adder
operator|->
name|y_clip_min
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|y_clip_max
operator|=
name|bottom
expr_stmt|;
name|adder
operator|->
name|scroll_x_min
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|scroll_x_max
operator|=
name|right
expr_stmt|;
name|adder
operator|->
name|scroll_y_min
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|scroll_y_max
operator|=
name|bottom
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* wait at LEAST 1 full frame */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|x_index_pending
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|y_index_pending
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|x_index_new
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|y_index_new
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|x_index_old
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|y_index_old
operator|=
name|top
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|ADDRESS_COMPLETE
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"qd%d: setup_dragon: timeout on ADDRESS_COMPLETE\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LEFT_SCROLL_MASK
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|RIGHT_SCROLL_MASK
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/*------------------------------------------------------------ 	* set source and the mask register to all ones (ie: white) */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SOURCE
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*-------------------------------------------------------------- 	* initialize Operand Control Register banks for fill command */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_A
argument_list|,
name|EXT_NONE
operator||
name|INT_M1_M2
operator||
name|NO_ID
operator||
name|WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC2_OCR_A
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_A
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|NO_ID
operator||
name|WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC2_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_M1_M2
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
comment|/*------------------------------------------------------------------ 	* init Logic Unit Function registers, (these are just common values, * and may be changed as required).  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R1
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R2
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
operator||
name|INV_M1_M2
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R3
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_D_OR_S
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R4
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_D_XOR_S
argument_list|)
expr_stmt|;
comment|/*---------------------------------------- 	* load the color map for black& white */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|VSYNC
operator|)
condition|;
operator|++
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"qd%d: setup_dragon: timeout on VSYNC\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|red
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|red
expr_stmt|;
name|green
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|green
expr_stmt|;
name|blue
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|blue
expr_stmt|;
operator|*
name|red
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* black */
operator|*
name|green
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|blue
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|red
operator|--
operator|=
literal|0xFF
expr_stmt|;
comment|/* white */
operator|*
name|green
operator|--
operator|=
literal|0xFF
expr_stmt|;
operator|*
name|blue
operator|--
operator|=
literal|0xFF
expr_stmt|;
comment|/*---------------------------------- 	* set color map for mouse cursor */
name|red
operator|+=
literal|254
expr_stmt|;
name|green
operator|+=
literal|254
expr_stmt|;
name|blue
operator|+=
literal|254
expr_stmt|;
operator|*
name|red
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* black */
operator|*
name|green
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|blue
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|red
operator|=
literal|0xFF
expr_stmt|;
comment|/* white */
operator|*
name|green
operator|=
literal|0xFF
expr_stmt|;
operator|*
name|blue
operator|=
literal|0xFF
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* setup_dragon */
end_comment

begin_comment
comment|/****************************************************************** * *	setup_input()... init the DUART and set defaults in input *			 devices * ******************************************************************* * *	calling convention: * *		setup_input(unit); * *	where: unit - is the QDSS unit number to be setup * *********/
end_comment

begin_macro
name|setup_input
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
comment|/* DUART register structure pointer */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* scratch variable */
specifier|register
name|int
name|bits
decl_stmt|;
name|char
name|id_byte
decl_stmt|;
name|short
name|status
decl_stmt|;
comment|/*--------------- 	* init stuff */
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
name|duart
operator|->
name|imask
operator|=
literal|0
expr_stmt|;
comment|/*--------------------------------------------- 	* setup the DUART for kbd& pointing device */
name|duart
operator|->
name|cmdA
operator|=
name|RESET_M
expr_stmt|;
comment|/* reset mode reg ptr for kbd */
name|duart
operator|->
name|modeA
operator|=
literal|0x13
expr_stmt|;
comment|/* 8 bits, no parity, rcv IE, */
comment|/* no RTS control,char error mode */
name|duart
operator|->
name|modeA
operator|=
literal|0x07
expr_stmt|;
comment|/* 1 stop bit,CTS does not IE XMT */
comment|/* no RTS control,no echo or loop */
name|duart
operator|->
name|cmdB
operator|=
name|RESET_M
expr_stmt|;
comment|/* reset mode reg pntr for host */
name|duart
operator|->
name|modeB
operator|=
literal|0x07
expr_stmt|;
comment|/* 8 bits, odd parity, rcv IE.. */
comment|/* ..no RTS cntrl, char error mode */
name|duart
operator|->
name|modeB
operator|=
literal|0x07
expr_stmt|;
comment|/* 1 stop bit,CTS does not IE XMT */
comment|/* no RTS control,no echo or loop */
name|duart
operator|->
name|auxctl
operator|=
literal|0x00
expr_stmt|;
comment|/* baud rate set 1 */
name|duart
operator|->
name|clkselA
operator|=
literal|0x99
expr_stmt|;
comment|/* 4800 baud for kbd */
name|duart
operator|->
name|clkselB
operator|=
literal|0x99
expr_stmt|;
comment|/* 4800 baud for mouse */
comment|/* reset everything for keyboard */
for|for
control|(
name|bits
operator|=
name|RESET_M
init|;
name|bits
operator|<
name|START_BREAK
condition|;
name|bits
operator|+=
literal|0x10
control|)
name|duart
operator|->
name|cmdA
operator|=
name|bits
expr_stmt|;
comment|/* reset everything for host */
for|for
control|(
name|bits
operator|=
name|RESET_M
init|;
name|bits
operator|<
name|START_BREAK
condition|;
name|bits
operator|+=
literal|0x10
control|)
name|duart
operator|->
name|cmdB
operator|=
name|bits
expr_stmt|;
name|duart
operator|->
name|cmdA
operator|=
name|EN_RCV
operator||
name|EN_XMT
expr_stmt|;
comment|/* enbl xmt& rcv for kbd */
name|duart
operator|->
name|cmdB
operator|=
name|EN_RCV
operator||
name|EN_XMT
expr_stmt|;
comment|/* enbl xmt& rcv for pointer device */
comment|/*-------------------------------------------- 	* init keyboard defaults (DUART channel A) */
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|LK_DEFAULTS
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
break|break;
block|}
block|}
name|status
operator|=
name|duart
operator|->
name|dataA
expr_stmt|;
comment|/* flush the ACK */
comment|/*-------------------------------- 	* identify the pointing device */
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
name|SELF_TEST
expr_stmt|;
break|break;
block|}
block|}
comment|/*----------------------------------------- 	* wait for 1st byte of self test report */
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd[%d]: setup_input: timeout on 1st byte of self test\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|OUT
goto|;
block|}
name|status
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
comment|/*----------------------------------------- 	* wait for ID byte of self test report	*/
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd[%d]: setup_input: timeout on 2nd byte of self test\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|OUT
goto|;
block|}
name|id_byte
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
comment|/*------------------------------------ 	* wait for other bytes to come in  */
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
name|status
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd[%d]: setup_input: timeout on 3rd byte of self test\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|OUT
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
name|status
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd[%d]: setup_input: timeout on 4th byte of self test\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|OUT
goto|;
block|}
comment|/*---------------------------------------------- 	* flag pointing device type and set defaults */
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|id_byte
operator|&
literal|0x0F
operator|)
operator|!=
name|TABLET_ID
condition|)
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|pntr_id
operator|=
name|MOUSE_ID
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
name|INC_STREAM_MODE
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|pntr_id
operator|=
name|TABLET_ID
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
name|T_STREAM
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*-------- 	* exit */
name|OUT
label|:
name|duart
operator|->
name|imask
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* setup_input */
end_comment

begin_comment
comment|/********************************************************************** * *	wait_status()... delay for at least one display frame time * *********************************************************************** * *	calling convention: * *		wait_status(adder, mask); *		struct *adder adder; *		int mask; * *	return: BAD means that we timed out without ever seeing the *		      vertical sync status bit *		GOOD otherwise * **************/
end_comment

begin_expr_stmt
name|wait_status
argument_list|(
name|adder
argument_list|,
name|mask
argument_list|)
specifier|register
expr|struct
name|adder
operator|*
name|adder
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|10000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|mask
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"wait_status: timeout polling for 0x%x in adder->status\n"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|BAD
operator|)
return|;
block|}
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_comment
comment|/* wait_status */
end_comment

begin_comment
comment|/********************************************************************** * *	write_ID()... write out onto the ID bus * *********************************************************************** * *	calling convention: * *		struct *adder adder;	;pntr to ADDER structure *		short adrs;		;VIPER address *		short data;		;data to be written *		write_ID(adder); * *	return: BAD means that we timed out waiting for status bits *		      VIPER-access-specific status bits *		GOOD otherwise * **************/
end_comment

begin_expr_stmt
name|write_ID
argument_list|(
name|adder
argument_list|,
name|adrs
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|adder
operator|*
name|adder
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|short
name|adrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|short
name|status
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|100000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|ADDRESS_COMPLETE
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|ERR
goto|;
for|for
control|(
name|i
operator|=
literal|100000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|TX_READY
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|adder
operator|->
name|id_data
operator|=
name|data
expr_stmt|;
name|adder
operator|->
name|command
operator|=
name|ID_LOAD
operator||
name|adrs
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
name|ERR
label|:
name|printf
argument_list|(
literal|"write_ID: timeout trying to write to VIPER\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BAD
operator|)
return|;
block|}
end_block

begin_comment
comment|/* write_ID */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

