begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)qd.c	1.14 (Berkeley) %G%  */
end_comment

begin_comment
comment|/************************************************************************ *									* *			Copyright (c) 1985-1988 by			* *		Digital Equipment Corporation, Maynard, MA		* *			All rights reserved.				* *									* *   This software is furnished under a license and may be used and	* *   copied  only  in accordance with the terms of such license and	* *   with the  inclusion  of  the  above  copyright  notice.   This	* *   software  or  any  other copies thereof may not be provided or	* *   otherwise made available to any other person.  No title to and	* *   ownership of the software is hereby transferred.			* *									* *   The information in this software is subject to change  without	* *   notice  and should not be construed as a commitment by Digital	* *   Equipment Corporation.						* *									* *   Digital assumes no responsibility for the use  or  reliability	* *   of its software on equipment which is not supplied by Digital.	* *									* *************************************************************************/
end_comment

begin_comment
comment|/*  * qd.c - QDSS display driver for VAXSTATION-II GPX workstation  */
end_comment

begin_include
include|#
directive|include
file|"qd.h"
end_include

begin_if
if|#
directive|if
name|NQD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"machine/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"qdioctl.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"clist.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"ubareg.h"
end_include

begin_include
include|#
directive|include
file|"ubavar.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"qduser.h"
end_include

begin_comment
comment|/* definitions shared with user level client */
end_comment

begin_include
include|#
directive|include
file|"qdreg.h"
end_include

begin_comment
comment|/* QDSS device register structures */
end_comment

begin_comment
comment|/*  * QDSS driver status flags for tracking operational state   */
end_comment

begin_struct
struct|struct
name|qdflags
block|{
name|u_int
name|inuse
decl_stmt|;
comment|/* which minor dev's are in use now */
name|u_int
name|config
decl_stmt|;
comment|/* I/O page register content */
name|u_int
name|mapped
decl_stmt|;
comment|/* user mapping status word */
name|u_int
name|kernel_loop
decl_stmt|;
comment|/* if kernel console is redirected */
name|u_int
name|user_dma
decl_stmt|;
comment|/* DMA from user space in progress */
name|u_short
name|pntr_id
decl_stmt|;
comment|/* type code of pointing device */
name|u_short
name|duart_imask
decl_stmt|;
comment|/* shadowing for duart intrpt mask reg */
name|u_short
name|adder_ie
decl_stmt|;
comment|/* shadowing for adder intrpt enbl reg */
name|u_short
name|curs_acc
decl_stmt|;
comment|/* cursor acceleration factor */
name|u_short
name|curs_thr
decl_stmt|;
comment|/* cursor acceleration threshold level */
name|u_short
name|tab_res
decl_stmt|;
comment|/* tablet resolution factor */
name|u_short
name|selmask
decl_stmt|;
comment|/* mask for active qd select entries */
block|}
struct|;
end_struct

begin_comment
comment|/*  * bit definitions for 'inuse' entry    */
end_comment

begin_define
define|#
directive|define
name|CONS_DEV
value|0x01
end_define

begin_define
define|#
directive|define
name|GRAPHIC_DEV
value|0x04
end_define

begin_comment
comment|/*  * bit definitions for 'mapped' member of flag structure   */
end_comment

begin_define
define|#
directive|define
name|MAPDEV
value|0x01
end_define

begin_comment
comment|/* hardware is mapped */
end_comment

begin_define
define|#
directive|define
name|MAPDMA
value|0x02
end_define

begin_comment
comment|/* DMA buffer mapped */
end_comment

begin_define
define|#
directive|define
name|MAPEQ
value|0x04
end_define

begin_comment
comment|/* event queue buffer mapped */
end_comment

begin_define
define|#
directive|define
name|MAPSCR
value|0x08
end_define

begin_comment
comment|/* scroll param area mapped */
end_comment

begin_define
define|#
directive|define
name|MAPCOLOR
value|0x10
end_define

begin_comment
comment|/* color map writing buffer mapped */
end_comment

begin_comment
comment|/*  * bit definitions for 'selmask' member of qdflag structure   */
end_comment

begin_define
define|#
directive|define
name|SEL_READ
value|0x01
end_define

begin_comment
comment|/* read select is active */
end_comment

begin_define
define|#
directive|define
name|SEL_WRITE
value|0x02
end_define

begin_comment
comment|/* write select is active */
end_comment

begin_comment
comment|/*  * constants used in shared memory operations   */
end_comment

begin_define
define|#
directive|define
name|EVENT_BUFSIZE
value|1024
end_define

begin_comment
comment|/* # of bytes per device's event buffer */
end_comment

begin_define
define|#
directive|define
name|MAXEVENTS
value|( (EVENT_BUFSIZE - sizeof(struct qdinput))	 \ 	/ sizeof(struct _vs_event) )
end_define

begin_define
define|#
directive|define
name|DMA_BUFSIZ
value|(1024 * 10)
end_define

begin_define
define|#
directive|define
name|COLOR_BUFSIZ
value|((sizeof(struct color_buf) + 512)& ~0x01FF)
end_define

begin_comment
comment|/*  * reference to an array of "uba_device" structures built by the auto  * configuration program.  The uba_device structure decribes the device  * sufficiently for the driver to talk to it.  The auto configuration code  * fills in the uba_device structures (located in ioconf.c) from user  * maintained info.    */
end_comment

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|qdinfo
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pntrs to each QDSS's */
end_comment

begin_decl_stmt
name|struct
name|tty
name|qd_tty
index|[
name|NQD
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* teletype structures for each.. */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|qvmem
index|[]
index|[
literal|128
operator|*
name|NBPG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|pte
name|QVmap
index|[]
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHUNK
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|QMEMSIZE
value|(1024 * 1024 * 4)
end_define

begin_comment
comment|/* 4 meg */
end_comment

begin_comment
comment|/*  * static storage used by multiple functions in this code    */
end_comment

begin_decl_stmt
name|int
name|Qbus_unmap
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Qbus mapper release code */
end_comment

begin_decl_stmt
name|struct
name|qdflags
name|qdflags
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* QDSS device status flags */
end_comment

begin_decl_stmt
name|struct
name|qdmap
name|qdmap
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* QDSS register map structure */
end_comment

begin_decl_stmt
name|caddr_t
name|qdbase
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base address of each QDSS unit */
end_comment

begin_decl_stmt
name|struct
name|buf
name|qdbuf
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buf structs used by strategy */
end_comment

begin_decl_stmt
name|short
name|qdopened
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* graphics device is open exclusive use */
end_comment

begin_comment
comment|/*  * the array "event_shared[]" is made up of a number of event queue buffers  * equal to the number of QDSS's configured into the running kernel (NQD).  * Each event queue buffer begins with an event queue header (struct qdinput)  * followed by a group of event queue entries (struct _vs_event).  The array  * "*eq_header[]" is an array of pointers to the start of each event queue  * buffer in "event_shared[]".    */
end_comment

begin_define
define|#
directive|define
name|EQSIZE
value|((EVENT_BUFSIZE * NQD) + 512)
end_define

begin_decl_stmt
name|char
name|event_shared
index|[
name|EQSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reserve space for event bufs */
end_comment

begin_decl_stmt
name|struct
name|qdinput
modifier|*
name|eq_header
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* event queue header pntrs */
end_comment

begin_comment
comment|/*  * This allocation method reserves enough memory pages for NQD shared DMA I/O  * buffers.  Each buffer must consume an integral number of memory pages to  * guarantee that a following buffer will begin on a page boundary.  Also,  * enough space is allocated so that the FIRST I/O buffer can start at the  * 1st page boundary after "&DMA_shared".  Page boundaries are used so that  * memory protections can be turned on/off for individual buffers.   */
end_comment

begin_define
define|#
directive|define
name|IOBUFSIZE
value|((DMA_BUFSIZ * NQD) + 512)
end_define

begin_decl_stmt
name|char
name|DMA_shared
index|[
name|IOBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reserve I/O buffer space */
end_comment

begin_decl_stmt
name|struct
name|DMAreq_header
modifier|*
name|DMAheader
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DMA buffer header pntrs */
end_comment

begin_comment
comment|/*  * The driver assists a client in scroll operations by loading dragon  * registers from an interrupt service routine.	The loading is done using  * parameters found in memory shrade between the driver and it's client.  * The scroll parameter structures are ALL loacted in the same memory page  * for reasons of memory economy.    */
end_comment

begin_decl_stmt
name|char
name|scroll_shared
index|[
literal|2
operator|*
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reserve space for scroll structs */
end_comment

begin_decl_stmt
name|struct
name|scroll
modifier|*
name|scroll
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to scroll structures */
end_comment

begin_comment
comment|/*  * the driver is programmable to provide the user with color map write  * services at VSYNC interrupt time.  At interrupt time the driver loads  * the color map with any user-requested load data found in shared memory   */
end_comment

begin_define
define|#
directive|define
name|COLOR_SHARED
value|((COLOR_BUFSIZ * NQD) + 512)
end_define

begin_decl_stmt
name|char
name|color_shared
index|[
name|COLOR_SHARED
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reserve space: color bufs */
end_comment

begin_decl_stmt
name|struct
name|color_buf
modifier|*
name|color_buf
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to color bufs */
end_comment

begin_comment
comment|/*  * mouse input event structures   */
end_comment

begin_decl_stmt
name|struct
name|mouse_report
name|last_rep
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mouse_report
name|current_rep
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|qdrsel
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* process waiting for select */
end_comment

begin_decl_stmt
name|struct
name|_vs_cursor
name|cursor
index|[
name|NQD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* console cursor */
end_comment

begin_decl_stmt
name|int
name|qdcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of successfully probed qd's */
end_comment

begin_decl_stmt
name|int
name|nNQD
init|=
name|NQD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|DMAbuf_size
init|=
name|DMA_BUFSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|QDlast_DMAtype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of the last DMA operation */
end_comment

begin_define
define|#
directive|define
name|QDSSMAJOR
value|41
end_define

begin_comment
comment|/* QDSS major device number */
end_comment

begin_comment
comment|/*  * macro to get system time.  Used to time stamp event queue entries   */
end_comment

begin_define
define|#
directive|define
name|TOY
value|((time.tv_sec * 100) + (time.tv_usec / 10000))
end_define

begin_function_decl
name|int
name|qdprobe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|qdattach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|qddint
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* DMA gate array intrpt service */
end_comment

begin_function_decl
name|int
name|qdaint
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Dragon ADDER intrpt service */
end_comment

begin_function_decl
name|int
name|qdiint
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|u_short
name|qdstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|qddriver
init|=
block|{
name|qdprobe
block|,
comment|/* device probe entry */
literal|0
block|,
comment|/* no slave device */
name|qdattach
block|,
comment|/* device attach entry */
literal|0
block|,
comment|/* no "fill csr/ba to start" */
name|qdstd
block|,
comment|/* device addresses */
literal|"qd"
block|,
comment|/* device name string */
name|qdinfo
comment|/* ptr to QDSS's uba_device struct */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|QDPRIOR
value|(PZERO-1)
end_define

begin_comment
comment|/* must be negative */
end_comment

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|~FALSE
end_define

begin_define
define|#
directive|define
name|BAD
value|-1
end_define

begin_define
define|#
directive|define
name|GOOD
value|0
end_define

begin_comment
comment|/*  * macro to create a system virtual page number from system virtual adrs   */
end_comment

begin_define
define|#
directive|define
name|VTOP
parameter_list|(
name|x
parameter_list|)
value|(((int)x& ~0xC0000000)>> PGSHIFT)
end_define

begin_comment
comment|/*  * QDSS register address offsets from start of QDSS address space   */
end_comment

begin_define
define|#
directive|define
name|QDSIZE
value|(52 * 1024)
end_define

begin_comment
comment|/* size of entire QDSS foot print */
end_comment

begin_define
define|#
directive|define
name|TMPSIZE
value|(16 * 1024)
end_define

begin_comment
comment|/* template RAM is 8k SHORT WORDS */
end_comment

begin_define
define|#
directive|define
name|TMPSTART
value|0x8000
end_define

begin_comment
comment|/* offset of template RAM from base adrs */
end_comment

begin_define
define|#
directive|define
name|REGSIZE
value|(5 * 512)
end_define

begin_comment
comment|/* regs touch 2.5k (5 pages) of addr space */
end_comment

begin_define
define|#
directive|define
name|REGSTART
value|0xC000
end_define

begin_comment
comment|/* offset of reg pages from base adrs */
end_comment

begin_define
define|#
directive|define
name|ADDER
value|(REGSTART+0x000)
end_define

begin_define
define|#
directive|define
name|DGA
value|(REGSTART+0x200)
end_define

begin_define
define|#
directive|define
name|DUART
value|(REGSTART+0x400)
end_define

begin_define
define|#
directive|define
name|MEMCSR
value|(REGSTART+0x800)
end_define

begin_define
define|#
directive|define
name|CLRSIZE
value|(3 * 512)
end_define

begin_comment
comment|/* color map size */
end_comment

begin_define
define|#
directive|define
name|CLRSTART
value|(REGSTART+0xA00)
end_define

begin_comment
comment|/* color map start offset from base */
end_comment

begin_comment
comment|/*  0x0C00 really */
end_comment

begin_define
define|#
directive|define
name|RED
value|(CLRSTART+0x000)
end_define

begin_define
define|#
directive|define
name|BLUE
value|(CLRSTART+0x200)
end_define

begin_define
define|#
directive|define
name|GREEN
value|(CLRSTART+0x400)
end_define

begin_comment
comment|/*  * QDSS minor device numbers.  The *real* minor device numbers are in  * the bottom two bits of the major/minor device spec.  Bits 2 and up are  * used to specify the QDSS device number (ie: which one?)   */
end_comment

begin_define
define|#
directive|define
name|CONS
value|0
end_define

begin_define
define|#
directive|define
name|GRAPHIC
value|2
end_define

begin_comment
comment|/*  * console cursor bitmap (white block cursor)    */
end_comment

begin_decl_stmt
name|short
name|cons_cursor
index|[
literal|32
index|]
init|=
block|{
comment|/* A */
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
comment|/* B */
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * constants used in font operations   */
end_comment

begin_define
define|#
directive|define
name|CHARS
value|190
end_define

begin_comment
comment|/* # of chars in the font */
end_comment

begin_define
define|#
directive|define
name|CHAR_HEIGHT
value|15
end_define

begin_comment
comment|/* char height in pixels */
end_comment

begin_define
define|#
directive|define
name|CHAR_WIDTH
value|8
end_define

begin_comment
comment|/* char width in pixels*/
end_comment

begin_define
define|#
directive|define
name|FONT_WIDTH
value|(CHAR_WIDTH * CHARS)
end_define

begin_comment
comment|/* font width in pixels */
end_comment

begin_define
define|#
directive|define
name|ROWS
value|CHAR_HEIGHT
end_define

begin_define
define|#
directive|define
name|FONT_X
value|0
end_define

begin_comment
comment|/* font's off screen adrs */
end_comment

begin_define
define|#
directive|define
name|FONT_Y
value|(2048 - CHAR_HEIGHT)
end_define

begin_comment
comment|/* Offset to second row characters (XXX - should remove) */
end_comment

begin_define
define|#
directive|define
name|FONT_OFFSET
value|((MAX_SCREEN_X/CHAR_WIDTH)*CHAR_HEIGHT)
end_define

begin_decl_stmt
specifier|extern
name|char
name|q_font
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference font object code */
end_comment

begin_decl_stmt
specifier|extern
name|u_short
name|q_key
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference key xlation tables */
end_comment

begin_decl_stmt
specifier|extern
name|u_short
name|q_shift_key
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|q_special
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * definitions for cursor acceleration reporting    */
end_comment

begin_define
define|#
directive|define
name|ACC_OFF
value|0x01
end_define

begin_comment
comment|/* acceleration is inactive */
end_comment

begin_comment
comment|/*  * virtual console support.  */
end_comment

begin_function_decl
specifier|extern
function_decl|(
modifier|*
name|v_putc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|cdevsw
modifier|*
name|consops
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|qdputc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|qdstart
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * LK-201 state storage for input console keyboard conversion to ASCII   */
end_comment

begin_struct
struct|struct
name|q_keyboard
block|{
name|int
name|shift
decl_stmt|;
comment|/* state variables	*/
name|int
name|cntrl
decl_stmt|;
name|int
name|lock
decl_stmt|;
name|int
name|lastcode
decl_stmt|;
comment|/* last keycode typed	*/
name|unsigned
name|kup
index|[
literal|8
index|]
decl_stmt|;
comment|/* bits for each keycode*/
name|unsigned
name|dkeys
index|[
literal|8
index|]
decl_stmt|;
comment|/* down/up mode keys	*/
name|char
name|last
decl_stmt|;
comment|/* last character	*/
block|}
name|q_keyboard
struct|;
end_struct

begin_comment
comment|/*  * tty settings on first open  */
end_comment

begin_define
define|#
directive|define
name|IFLAGS
value|(EVENP|ECHO|XTABS|CRMOD)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|POSIXTTY
end_ifdef

begin_define
define|#
directive|define
name|IFLAG
value|(BRKINT|ISTRIP|IXON|IXANY|ICRNL|IEXTEN|IMAXBEL)
end_define

begin_define
define|#
directive|define
name|OFLAG
value|(OPOST|OXTABS|ONLCR)
end_define

begin_define
define|#
directive|define
name|LFLAG
value|(ISIG|ICANON|ECHO)
end_define

begin_define
define|#
directive|define
name|CFLAG
value|(PARENB|CREAD|CS7|CLOCAL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Init QDSS as console (before probe routine)  */
end_comment

begin_macro
name|qdcons_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|unit
expr_stmt|;
name|caddr_t
name|phys_adr
decl_stmt|;
comment|/* physical QDSS base adrs */
name|u_int
name|mapix
decl_stmt|;
comment|/* index into QVmap[] array */
name|struct
name|percpu
modifier|*
name|pcpu
decl_stmt|;
comment|/* pointer to cpusw structure  */
specifier|register
name|struct
name|qbus
modifier|*
name|qb
decl_stmt|;
name|u_short
modifier|*
name|qdaddr
decl_stmt|;
comment|/* address of QDSS IO page CSR */
name|u_short
modifier|*
name|devptr
decl_stmt|;
comment|/* vitual device space */
extern|extern cnputc(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|QDSSCSR
value|0x1F00
end_define

begin_if
if|if
condition|(
name|v_putc
operator|!=
name|cnputc
condition|)
return|return
literal|0
return|;
end_if

begin_expr_stmt
name|unit
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * find the cpusw entry that matches this machine.  	 */
end_comment

begin_for
for|for
control|(
name|pcpu
operator|=
name|percpu
init|;
name|pcpu
operator|&&
name|pcpu
operator|->
name|pc_cputype
operator|!=
name|cpu
condition|;
name|pcpu
operator|++
control|)
empty_stmt|;
end_for

begin_if
if|if
condition|(
name|pcpu
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
end_if

begin_if
if|if
condition|(
name|pcpu
operator|->
name|pc_io
operator|->
name|io_type
operator|!=
name|IO_QBUS
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|/* 	 * Map device registers - the last 8K of qvmem. 	 */
end_comment

begin_expr_stmt
name|qb
operator|=
operator|(
expr|struct
name|qbus
operator|*
operator|)
name|pcpu
operator|->
name|pc_io
operator|->
name|io_details
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ioaccess
argument_list|(
name|qb
operator|->
name|qb_iopage
argument_list|,
name|UMEMmap
index|[
literal|0
index|]
operator|+
name|qb
operator|->
name|qb_memsize
argument_list|,
name|UBAIOPAGES
operator|*
name|NBPG
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|devptr
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|umem
index|[
literal|0
index|]
operator|+
operator|(
name|qb
operator|->
name|qb_memsize
operator|*
name|NBPG
operator|)
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdaddr
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|devptr
operator|+
name|ubdevreg
argument_list|(
name|QDSSCSR
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|qdaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|/* 	 * Map q-bus memory used by qdss. (separate map) 	 */
end_comment

begin_expr_stmt
name|mapix
operator|=
name|QMEMSIZE
operator|-
operator|(
name|CHUNK
operator|*
operator|(
name|unit
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|phys_adr
operator|=
name|qb
operator|->
name|qb_maddr
operator|+
name|mapix
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ioaccess
argument_list|(
name|phys_adr
argument_list|,
name|QVmap
index|[
literal|0
index|]
argument_list|,
operator|(
name|CHUNK
operator|*
name|NQD
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * tell QDSS which Q memory address base to decode  	 * (shifted right 16 bits - its in 64K units) 	 */
end_comment

begin_expr_stmt
operator|*
name|qdaddr
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|int
operator|)
name|mapix
operator|>>
literal|16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdflags
index|[
name|unit
index|]
operator|.
name|config
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
name|qdaddr
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * load qdmap struct with the virtual addresses of the QDSS elements  	 */
end_comment

begin_expr_stmt
name|qdbase
index|[
name|unit
index|]
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|template
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|TMPSTART
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|ADDER
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|DGA
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|DUART
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|MEMCSR
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|red
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|RED
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|blue
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|BLUE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdmap
index|[
name|unit
index|]
operator|.
name|green
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|GREEN
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* init shadow variables */
end_comment

begin_comment
comment|/* 	 * init the QDSS   	 */
end_comment

begin_comment
comment|/*  	printf("qdbase[0] = %x, qdmap[0].memcsr = %x\n", 		(char *)qdbase[0], qdmap[0].memcsr); 	*/
end_comment

begin_expr_stmt
operator|*
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
operator||=
name|SYNC_ON
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* once only: turn on sync */
end_comment

begin_expr_stmt
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* init shared memory */
end_comment

begin_expr_stmt
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* init the ADDER/VIPER stuff */
end_comment

begin_expr_stmt
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* clear the screen */
end_comment

begin_expr_stmt
name|ldfont
argument_list|(
name|unit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* load the console font */
end_comment

begin_expr_stmt
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|cons_cursor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* load default cursor map */
end_comment

begin_expr_stmt
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* init the DUART */
end_comment

begin_expr_stmt
name|v_putc
operator|=
name|qdputc
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* kernel console output to qdss */
end_comment

begin_expr_stmt
name|consops
operator|=
operator|&
name|cdevsw
index|[
name|QDSSMAJOR
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* virtual console is qdss */
end_comment

begin_return
return|return
literal|1
return|;
end_return

begin_comment
unit|}
comment|/* qdcons_init */
end_comment

begin_comment
comment|/*  *  Configure QDSS into Q memory and make it intrpt.  *  *  side effects: QDSS gets mapped into Qbus memory space at the first  *		 vacant 64kb boundary counting back from the top of  *		 Qbus memory space (qvmem+4mb)  *  *  return: QDSS bus request level and vector address returned in  *	   registers by UNIX convention.  *  */
end_comment

begin_expr_stmt
unit|qdprobe
operator|(
name|reg
operator|)
name|caddr_t
name|reg
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* character pointer to the QDSS I/O page register */
end_comment

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* value-result */
specifier|register
name|int
name|unit
decl_stmt|;
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
comment|/* pointer to gate array structure */
name|int
name|vector
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|int
modifier|*
name|ptep
decl_stmt|;
comment|/* page table entry pointer */
name|caddr_t
name|phys_adr
decl_stmt|;
comment|/* physical QDSS base adrs */
name|u_int
name|mapix
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|nNQD
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|nNQD
expr_stmt|;
name|qddint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|qdaint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|qdiint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|qdgetc
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * calculate board unit number from I/O page register address   	 */
name|unit
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|reg
operator|>>
literal|1
operator|)
operator|&
literal|0x0007
argument_list|)
expr_stmt|;
comment|/* 	 * QDSS regs must be mapped to Qbus memory space at a 64kb  	 * physical boundary.  The Qbus memory space is mapped into 	 * the system memory space at config time.  After config 	 * runs, "qvmem[0]" (ubavar.h) holds the system virtual adrs 	 * of the start of Qbus memory.   The Qbus memory page table 	 * is found via an array of pte ptrs called "QVmap[]" (ubavar.h) 	 * which is also loaded at config time.   These are the 	 * variables used below to find a vacant 64kb boundary in 	 * Qbus memory, and load it's corresponding physical adrs 	 * into the QDSS's I/O page CSR.   	 */
comment|/* 	 * Only if QD is the graphics device. 	 */
comment|/* if this QDSS is NOT the console, then do init here.. */
if|if
condition|(
name|unit
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd: can't support two qdss's (yet)\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* can't test */
if|if
condition|(
name|v_consputc
operator|!=
name|qdputc
operator|||
name|unit
operator|!=
literal|0
condition|)
block|{
comment|/* 			* read QDSS config info  			*/
name|qdflags
index|[
name|unit
index|]
operator|.
name|config
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
name|reg
expr_stmt|;
comment|/* 			* find an empty 64kb adrs boundary  			*/
name|qdbase
index|[
name|unit
index|]
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|qvmem
index|[
literal|0
index|]
operator|+
name|QMEMSIZE
operator|-
name|CHUNK
argument_list|)
expr_stmt|;
comment|/* 			* find the cpusw entry that matches this machine.  			*/
name|cpup
operator|=
operator|&
name|cpusw
index|[
name|cpu
index|]
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|BADADDR
argument_list|(
name|qdbase
index|[
name|unit
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
condition|)
name|qdbase
index|[
name|unit
index|]
operator|-=
name|CHUNK
expr_stmt|;
comment|/* 			* tell QDSS which Q memory address base to decode  			*/
name|mapix
operator|=
call|(
name|int
call|)
argument_list|(
name|VTOP
argument_list|(
name|qdbase
index|[
name|unit
index|]
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
expr_stmt|;
name|phys_adr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|ptep
operator|&
literal|0x001FFFFF
operator|)
operator|<<
name|PGSHIFT
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|reg
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|int
operator|)
name|phys_adr
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* 			* load QDSS adrs map with system addresses  			* of device regs  			*/
name|qdmap
index|[
name|unit
index|]
operator|.
name|template
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|TMPSTART
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|ADDER
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|DGA
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|DUART
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|MEMCSR
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|red
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|RED
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|blue
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|BLUE
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|green
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|GREEN
expr_stmt|;
comment|/* device init */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init shared memory */
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the ADDER/VIPER stuff */
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|cons_cursor
argument_list|)
expr_stmt|;
comment|/* load default cursor map */
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the DUART */
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ldfont
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* load the console font */
comment|/* once only: turn on sync */
operator|*
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
operator||=
name|SYNC_ON
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*notdef*/
block|}
comment|/* 	* The QDSS interrupts at HEX vectors xx0 (DMA) xx4 	* (ADDER) and xx8 (DUART).  Therefore, we take three 	* vectors from the vector pool, and then continue 	* to take them until we get a xx0 HEX vector.  The 	* pool provides vectors in contiguous decending 	* order.   	*/
name|vector
operator|=
operator|(
name|uba_hd
index|[
literal|0
index|]
operator|.
name|uh_lastiv
operator|-=
literal|4
operator|*
literal|3
operator|)
expr_stmt|;
comment|/* take three vectors */
while|while
condition|(
name|vector
operator|&
literal|0x0F
condition|)
block|{
comment|/* if lo nibble != 0.. */
comment|/* ..take another vector */
name|vector
operator|=
operator|(
name|uba_hd
index|[
literal|0
index|]
operator|.
name|uh_lastiv
operator|-=
literal|4
operator|)
expr_stmt|;
block|}
comment|/* 	* setup DGA to do a DMA interrupt (transfer count = 0)	 	*/
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|csr
operator|=
operator|(
name|short
operator|)
name|HALT
expr_stmt|;
comment|/* disable everything */
name|dga
operator|->
name|ivr
operator|=
operator|(
name|short
operator|)
name|vector
expr_stmt|;
comment|/* load intrpt base vector */
name|dga
operator|->
name|bytcnt_lo
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
comment|/* DMA xfer count = 0 */
name|dga
operator|->
name|bytcnt_hi
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
comment|/*  	* turn on DMA interrupts  	*/
name|dga
operator|->
name|csr
operator|&=
operator|~
name|SET_DONE_FIFO
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
operator||
name|DL_ENB
expr_stmt|;
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
comment|/* wait for the intrpt */
name|dga
operator|->
name|csr
operator|=
name|HALT
expr_stmt|;
comment|/* stop the wheels */
if|if
condition|(
name|cvec
operator|!=
name|vector
condition|)
comment|/* if vector != base vector.. */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ..return = 'no device' */
comment|/* 	* score this as an existing qdss 	*/
name|qdcount
operator|++
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
return|;
comment|/* return size of QDSS I/O page reg */
block|}
end_block

begin_comment
comment|/* qdprobe */
end_comment

begin_macro
name|qdattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unit
expr_stmt|;
comment|/* QDSS module # for this call */
name|unit
operator|=
name|ui
operator|->
name|ui_unit
expr_stmt|;
comment|/* get QDSS number */
comment|/* 	* init "qdflags[]" for this QDSS  	*/
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|=
literal|0
expr_stmt|;
comment|/* init inuse variable EARLY! */
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|kernel_loop
operator|=
operator|-
literal|1
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|user_dma
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_acc
operator|=
name|ACC_OFF
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_thr
operator|=
literal|128
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|tab_res
operator|=
literal|2
expr_stmt|;
comment|/* default tablet resolution factor */
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator|=
literal|0
expr_stmt|;
comment|/* init shadow variables */
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|=
literal|0
expr_stmt|;
comment|/* 	* init structures used in kbd/mouse interrupt service.	This code must 	* come after the "init_shared()" routine has run since that routine  	* inits the eq_header[unit] structure used here.    	*/
comment|/* 	* init the "latest mouse report" structure  	*/
name|last_rep
index|[
name|unit
index|]
operator|.
name|state
operator|=
literal|0
expr_stmt|;
name|last_rep
index|[
name|unit
index|]
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|last_rep
index|[
name|unit
index|]
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|last_rep
index|[
name|unit
index|]
operator|.
name|bytcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	* init the event queue (except mouse position)  	*/
name|eq_header
index|[
name|unit
index|]
operator|->
name|header
operator|.
name|events
operator|=
operator|(
expr|struct
name|_vs_event
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|eq_header
index|[
name|unit
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|qdinput
argument_list|)
operator|)
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|header
operator|.
name|size
operator|=
name|MAXEVENTS
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|header
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|header
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
comment|/* 	 * open exclusive for graphics device. 	 */
name|qdopened
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* qdattach */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|qdopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
comment|/* ptr to uba structures */
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
comment|/* ptr to gate array struct */
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|minor_dev
decl_stmt|;
name|minor_dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* get QDSS minor device number */
name|unit
operator|=
name|minor_dev
operator|>>
literal|2
expr_stmt|;
comment|/* 	* check for illegal conditions	 	*/
name|ui
operator|=
name|qdinfo
index|[
name|unit
index|]
expr_stmt|;
comment|/* get ptr to QDSS device struct */
if|if
condition|(
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* no such device or address */
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|==
literal|2
condition|)
block|{
comment|/* 		* this is the graphic device...  		*/
if|if
condition|(
name|qdopened
index|[
name|unit
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
else|else
name|qdopened
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator||=
name|GRAPHIC_DEV
expr_stmt|;
comment|/* graphics dev is open */
comment|/* 		 * enble kbd& mouse intrpts in DUART mask reg  		 */
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator||=
literal|0x22
expr_stmt|;
name|duart
operator|->
name|imask
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
expr_stmt|;
block|}
else|else
block|{
comment|/* 		* this is the console  		*/
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator||=
name|CONS_DEV
expr_stmt|;
comment|/* mark console as open */
name|dga
operator|->
name|csr
operator||=
name|CURS_ENB
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator||=
literal|0x02
expr_stmt|;
name|duart
operator|->
name|imask
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
expr_stmt|;
comment|/* 		* some setup for tty handling  		*/
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
name|tp
operator|->
name|t_addr
operator|=
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|qdstart
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|=
name|IFLAGS
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|B9600
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|B9600
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TS_ISOPEN
operator||
name|TS_CARR_ON
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIXTTY
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		* enable intrpts, open line discipline  		*/
name|dga
operator|->
name|csr
operator||=
name|GLOBAL_IE
expr_stmt|;
comment|/* turn on the interrupts */
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
return|;
block|}
name|dga
operator|->
name|csr
operator||=
name|GLOBAL_IE
expr_stmt|;
comment|/* turn on the interrupts */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdopen */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|qdclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|qdmap
modifier|*
name|qd
decl_stmt|;
specifier|register
name|int
modifier|*
name|ptep
decl_stmt|;
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
comment|/* gate array register map pointer */
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|minor_dev
decl_stmt|;
name|u_int
name|mapix
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* SIGNED index */
name|minor_dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* get minor device number */
name|unit
operator|=
name|minor_dev
operator|>>
literal|2
expr_stmt|;
comment|/* get QDSS number */
name|qd
operator|=
operator|&
name|qdmap
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|==
literal|2
condition|)
block|{
comment|/* 		* this is the graphic device...  		*/
if|if
condition|(
name|qdopened
index|[
name|unit
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
else|else
name|qdopened
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
comment|/* allow it to be re-opened */
comment|/* 		* re-protect device memory  		*/
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPDEV
condition|)
block|{
comment|/* 			* TEMPLATE RAM  			*/
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|template
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|btop
argument_list|(
name|TMPSIZE
argument_list|)
condition|;
name|i
operator|++
operator|,
name|ptep
operator|++
control|)
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
comment|/* 			* ADDER  			*/
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|adder
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|btop
argument_list|(
name|REGSIZE
argument_list|)
condition|;
name|i
operator|++
operator|,
name|ptep
operator|++
control|)
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
comment|/* 			* COLOR MAPS  			*/
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|red
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|btop
argument_list|(
name|CLRSIZE
argument_list|)
condition|;
name|i
operator|++
operator|,
name|ptep
operator|++
control|)
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
block|}
comment|/* 		* re-protect DMA buffer and free the map registers  		*/
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPDMA
condition|)
block|{
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* kill DMA */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/*  			 * if DMA was running, flush spurious intrpt  			 */
if|if
condition|(
name|dga
operator|->
name|bytcnt_lo
operator|!=
literal|0
condition|)
block|{
name|dga
operator|->
name|bytcnt_lo
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
literal|0
expr_stmt|;
name|DMA_SETIGNORE
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
block|}
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|DMAheader
index|[
name|unit
index|]
operator|*
literal|4
argument_list|)
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|btop
argument_list|(
name|DMAbuf_size
argument_list|)
condition|;
name|i
operator|++
operator|,
name|ptep
operator|++
control|)
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
name|ubarelse
argument_list|(
literal|0
argument_list|,
operator|&
name|Qbus_unmap
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 		* re-protect 1K (2 pages) event queue  		*/
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPEQ
condition|)
block|{
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
block|}
comment|/* 		* re-protect scroll param area and disable scroll intrpts   		*/
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPSCR
condition|)
block|{
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|scroll
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* 			 * re-protect 512 scroll param area  			 */
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|&=
operator|~
name|FRAME_SYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
block|}
comment|/* 		* re-protect color map write buffer area and kill intrpts  		*/
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPCOLOR
condition|)
block|{
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|color_buf
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|color_buf
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|&=
operator|~
name|VSYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
block|}
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flag everything now unmapped */
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&=
operator|~
name|GRAPHIC_DEV
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_acc
operator|=
name|ACC_OFF
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_thr
operator|=
literal|128
expr_stmt|;
comment|/* 		* restore the console  		*/
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* halt the DMA! (just in case...) */
name|dga
operator|->
name|csr
operator||=
name|DMA_ERR
expr_stmt|;
comment|/* clear error condition */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* 		 * if DMA was running, flush spurious intrpt  		 */
if|if
condition|(
name|dga
operator|->
name|bytcnt_lo
operator|!=
literal|0
condition|)
block|{
name|dga
operator|->
name|bytcnt_lo
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
literal|0
expr_stmt|;
name|DMA_SETIGNORE
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
block|}
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init shared memory */
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init ADDER/VIPER */
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|cons_cursor
argument_list|)
expr_stmt|;
comment|/* load default cursor map */
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the DUART */
name|ldfont
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
comment|/* 		 * shut off the mouse rcv intrpt and turn on kbd intrpts  		 */
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator|&=
operator|~
operator|(
literal|0x20
operator|)
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator||=
literal|0x02
expr_stmt|;
name|duart
operator|->
name|imask
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
expr_stmt|;
comment|/* 		* shut off interrupts if all is closed   		*/
if|if
condition|(
operator|!
operator|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|CONS_DEV
operator|)
condition|)
block|{
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
operator|(
name|GLOBAL_IE
operator||
name|DMA_IE
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		* this is the console  		*/
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&=
operator|~
name|CONS_DEV
expr_stmt|;
comment|/* 		* if graphics device is closed, kill interrupts  		*/
if|if
condition|(
operator|!
operator|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
operator|)
condition|)
block|{
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
operator|(
name|GLOBAL_IE
operator||
name|DMA_IE
operator|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdclose */
end_comment

begin_macro
name|qdioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|datap
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|caddr_t
name|datap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|ptep
decl_stmt|;
comment|/* page table entry pointer */
specifier|register
name|int
name|mapix
decl_stmt|;
comment|/* QVmap[] page table index */
specifier|register
name|struct
name|_vs_event
modifier|*
name|event
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|struct
name|qdmap
modifier|*
name|qd
decl_stmt|;
comment|/* pointer to device map struct */
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
comment|/* Gate Array reg structure pntr */
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
comment|/* DUART reg structure pointer */
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
comment|/* ADDER reg structure pointer */
name|struct
name|prgkbd
modifier|*
name|cmdbuf
decl_stmt|;
name|struct
name|prg_cursor
modifier|*
name|curs
decl_stmt|;
name|struct
name|_vs_cursor
modifier|*
name|pos
decl_stmt|;
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|2
decl_stmt|;
comment|/* number of caller's QDSS */
name|u_int
name|minor_dev
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|short
modifier|*
name|temp
decl_stmt|;
comment|/* a pointer to template RAM */
comment|/* 	* service graphic device ioctl commands  	*/
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|QD_GETEVENT
case|:
comment|/* 		* extract the oldest event from the event queue  		*/
if|if
condition|(
name|ISEMPTY
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
condition|)
block|{
name|event
operator|=
operator|(
expr|struct
name|_vs_event
operator|*
operator|)
name|datap
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_NULL
expr_stmt|;
break|break;
block|}
name|event
operator|=
operator|(
expr|struct
name|_vs_event
operator|*
operator|)
name|GETBEGIN
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|GETEND
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|event
argument_list|,
name|datap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_vs_event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QD_RESET
case|:
comment|/* 		* init the dragon stuff, DUART, and driver variables   		*/
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init shared memory */
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the ADDER/VIPER stuff */
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|cons_cursor
argument_list|)
expr_stmt|;
comment|/* load default cursor map */
name|ldfont
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* load the console font */
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the DUART */
break|break;
case|case
name|QD_SET
case|:
comment|/* 		* init the DUART and driver variables   		*/
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|QD_CLRSCRN
case|:
comment|/* 		* clear the QDSS screen.  (NOTE that this reinits the dragon)  		*/
ifdef|#
directive|ifdef
name|notdef
comment|/* has caused problems and isn't necessary */
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|QD_WTCURSOR
case|:
comment|/* 		* load a cursor into template RAM   		*/
name|ldcursor
argument_list|(
name|unit
argument_list|,
operator|(
name|short
operator|*
operator|)
name|datap
argument_list|)
expr_stmt|;
break|break;
case|case
name|QD_RDCURSOR
case|:
name|temp
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|template
expr_stmt|;
comment|/* 		 * cursor is 32 WORDS from the end of the 8k WORD... 		 *  ...template space  		 */
name|temp
operator|+=
operator|(
literal|8
operator|*
literal|1024
operator|)
operator|-
literal|32
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
operator|,
name|datap
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
control|)
operator|*
operator|(
name|short
operator|*
operator|)
name|datap
operator|=
operator|*
name|temp
operator|++
expr_stmt|;
break|break;
case|case
name|QD_POSCURSOR
case|:
comment|/* 		* position the mouse cursor   		*/
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|pos
operator|=
operator|(
expr|struct
name|_vs_cursor
operator|*
operator|)
name|datap
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|pos
operator|->
name|x
argument_list|)
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|pos
operator|->
name|y
argument_list|)
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|x
operator|=
name|pos
operator|->
name|x
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|y
operator|=
name|pos
operator|->
name|y
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|QD_PRGCURSOR
case|:
comment|/* 		* set the cursor acceleration factor  		*/
name|curs
operator|=
operator|(
expr|struct
name|prg_cursor
operator|*
operator|)
name|datap
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_acc
operator|=
name|curs
operator|->
name|acc_factor
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_thr
operator|=
name|curs
operator|->
name|threshold
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|QD_MAPDEVICE
case|:
comment|/* 		* enable 'user write' to device pages  		*/
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPDEV
expr_stmt|;
name|qd
operator|=
operator|(
expr|struct
name|qdmap
operator|*
operator|)
operator|&
name|qdmap
index|[
name|unit
index|]
expr_stmt|;
comment|/* 		* enable user write to template RAM  		*/
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|template
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|btop
argument_list|(
name|TMPSIZE
argument_list|)
condition|;
name|i
operator|++
operator|,
name|ptep
operator|++
control|)
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
comment|/* 		* enable user write to registers  		*/
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|adder
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|btop
argument_list|(
name|REGSIZE
argument_list|)
condition|;
name|i
operator|++
operator|,
name|ptep
operator|++
control|)
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
comment|/* 		* enable user write to color maps  		*/
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|red
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|btop
argument_list|(
name|CLRSIZE
argument_list|)
condition|;
name|i
operator|++
operator|,
name|ptep
operator|++
control|)
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
comment|/* 		* enable user write to DUART  		*/
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|duart
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qvmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QVmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
comment|/* duart page */
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* invalidate translation buffer */
comment|/* 		 * stuff qdmap structure in return buffer  		 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|qd
argument_list|,
name|datap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qdmap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QD_MAPIOBUF
case|:
comment|/* 		 * do setup for DMA by user process	 		 * 		 * set 'user write enable' bits for DMA buffer   		 */
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPDMA
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|btop
argument_list|(
name|DMAbuf_size
argument_list|)
condition|;
name|i
operator|++
operator|,
name|ptep
operator|++
control|)
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* invalidate translation buffer */
comment|/* 		* set up QBUS map registers for DMA  		*/
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
operator|=
name|uballoc
argument_list|(
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
name|DMAheader
index|[
name|unit
index|]
argument_list|,
name|DMAbuf_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"qd%d: qdioctl: QBA setup error\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|Qbus_unmap
index|[
name|unit
index|]
operator|=
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
operator|&=
literal|0x3FFFF
expr_stmt|;
comment|/* 		* return I/O buf adr  		*/
operator|*
operator|(
name|int
operator|*
operator|)
name|datap
operator|=
operator|(
name|int
operator|)
name|DMAheader
index|[
name|unit
index|]
expr_stmt|;
break|break;
case|case
name|QD_MAPSCROLL
case|:
comment|/* 		* map the shared scroll param area and enable scroll interpts   		*/
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPSCR
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|scroll
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* 		 * allow user write to scroll area  		 */
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* invalidate translation buf */
name|scroll
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator||=
name|FRAME_SYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|datap
operator|=
operator|(
name|int
operator|)
name|scroll
index|[
name|unit
index|]
expr_stmt|;
comment|/* return scroll area */
break|break;
case|case
name|QD_UNMAPSCROLL
case|:
comment|/* 		* unmap shared scroll param area and disable scroll intrpts  		*/
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPSCR
condition|)
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&=
operator|~
name|MAPSCR
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|scroll
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* 			 * re-protect 512 scroll param area  			 */
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* smash CPU's translation buf */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|&=
operator|~
name|FRAME_SYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
block|}
break|break;
case|case
name|QD_MAPCOLOR
case|:
comment|/* 		* map shared color map write buf and turn on vsync intrpt  		*/
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPCOLOR
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|color_buf
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* 		 * allow user write to color map write buffer  		 */
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clr CPU translation buf */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator||=
name|VSYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
comment|/* 		 * return color area address  		 */
operator|*
operator|(
name|int
operator|*
operator|)
name|datap
operator|=
operator|(
name|int
operator|)
name|color_buf
index|[
name|unit
index|]
expr_stmt|;
break|break;
case|case
name|QD_UNMAPCOLOR
case|:
comment|/* 		 * unmap shared color map write buffer and kill VSYNC intrpts  		 */
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPCOLOR
condition|)
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&=
operator|~
name|MAPCOLOR
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|color_buf
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* 			 * re-protect color map write buffer  			 */
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|&=
operator|~
name|VSYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
block|}
break|break;
case|case
name|QD_MAPEVENT
case|:
comment|/* 		* give user write access to the event queue  		*/
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPEQ
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* 		 * allow user write to 1K event queue  		 */
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clr CPU translation buf */
comment|/* 		 * return event queue address  		 */
operator|*
operator|(
name|int
operator|*
operator|)
name|datap
operator|=
operator|(
name|int
operator|)
name|eq_header
index|[
name|unit
index|]
expr_stmt|;
break|break;
case|case
name|QD_PRGKBD
case|:
comment|/* 		* pass caller's programming commands to LK201  		*/
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
name|cmdbuf
operator|=
operator|(
expr|struct
name|prgkbd
operator|*
operator|)
name|datap
expr_stmt|;
comment|/* pnt to kbd cmd buf */
comment|/* 		* send command  		*/
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusA
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmdbuf
operator|->
name|cmd
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdioctl: timeout on XMT_RDY [1]\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		* send param1?  		*/
if|if
condition|(
name|cmdbuf
operator|->
name|cmd
operator|&
name|LAST_PARAM
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusA
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmdbuf
operator|->
name|param1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdioctl: timeout on XMT_RDY [2]\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		* send param2?  		*/
if|if
condition|(
name|cmdbuf
operator|->
name|param1
operator|&
name|LAST_PARAM
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusA
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmdbuf
operator|->
name|param2
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdioctl: timeout on XMT_RDY [3]\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|QD_PRGMOUSE
case|:
comment|/* 		* pass caller's programming commands to the mouse   		*/
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusB
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
operator|*
name|datap
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdioctl: timeout on XMT_RDY [4]\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QD_RDCONFIG
case|:
comment|/* 		* get QDSS configuration word and return it   		*/
operator|*
operator|(
name|short
operator|*
operator|)
name|datap
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|config
expr_stmt|;
break|break;
case|case
name|QD_KERN_LOOP
case|:
case|case
name|QD_KERN_UNLOOP
case|:
comment|/* 		 * vestige from ultrix.  BSD uses TIOCCONS to redirect 		 * kernel console output. 		 */
break|break;
case|case
name|QD_PRGTABLET
case|:
comment|/* 		* program the tablet  		*/
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusB
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
operator|*
name|datap
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdioctl: timeout on XMT_RDY [5]\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QD_PRGTABRES
case|:
comment|/* 		* program the tablet report resolution factor  		*/
name|qdflags
index|[
name|unit
index|]
operator|.
name|tab_res
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
name|datap
expr_stmt|;
break|break;
default|default:
comment|/* 		* service tty ioctl's   		*/
if|if
condition|(
operator|!
operator|(
name|minor_dev
operator|&
literal|0x02
operator|)
condition|)
block|{
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|datap
operator|,
name|flags
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|datap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdioctl */
end_comment

begin_macro
name|qdselect
argument_list|(
argument|dev
argument_list|,
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|s
expr_stmt|;
specifier|register
name|unit
expr_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|u_int
name|minor_dev
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|unit
operator|=
name|minor_dev
operator|>>
literal|2
expr_stmt|;
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
name|FREAD
case|:
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|==
literal|2
condition|)
block|{
comment|/* 			* this is a graphics device, so check for events 			*/
if|if
condition|(
operator|!
operator|(
name|ISEMPTY
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|qdrsel
index|[
name|unit
index|]
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|selmask
operator||=
name|SEL_READ
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* 			* this is a tty device 			*/
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
if|if
condition|(
name|ttnread
argument_list|(
name|tp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tp
operator|->
name|t_rsel
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|FWRITE
case|:
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x03
operator|)
operator|==
literal|2
condition|)
block|{
comment|/* 			* this is a graphics device, so check for dma buffers 			*/
if|if
condition|(
name|DMA_ISEMPTY
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|qdrsel
index|[
name|unit
index|]
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|selmask
operator||=
name|SEL_WRITE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* 			* this is a tty device 			*/
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tp
operator|->
name|t_wsel
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdselect() */
end_comment

begin_extern
extern|extern qd_strategy(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_macro
name|qdwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|minor_dev
expr_stmt|;
specifier|register
name|unit
expr_stmt|;
name|minor_dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
operator|(
name|minor_dev
operator|>>
literal|2
operator|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|!=
literal|0x02
operator|)
operator|&&
operator|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|CONS_DEV
operator|)
condition|)
block|{
comment|/* 		* this is the console...   		*/
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
condition|)
block|{
comment|/* 		* this is a DMA xfer from user space  		*/
return|return
operator|(
name|physio
argument_list|(
name|qd_strategy
argument_list|,
operator|&
name|qdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_block

begin_macro
name|qdread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|minor_dev
expr_stmt|;
specifier|register
name|unit
expr_stmt|;
name|minor_dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
operator|(
name|minor_dev
operator|>>
literal|2
operator|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|!=
literal|0x02
operator|&&
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|CONS_DEV
condition|)
block|{
comment|/* 		* this is the console 		*/
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
condition|)
block|{
comment|/* 		* this is a bitmap-to-processor xfer  		*/
return|return
operator|(
name|physio
argument_list|(
name|qd_strategy
argument_list|,
operator|&
name|qdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_block

begin_comment
comment|/*************************************************************** * *	qd_strategy()... strategy routine to do DMA * ***************************************************************/
end_comment

begin_expr_stmt
name|qd_strategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
specifier|register
name|unit
expr_stmt|;
name|int
name|QBAreg
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|cookie
decl_stmt|;
name|unit
operator|=
operator|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|>>
literal|2
operator|)
operator|&
literal|0x07
expr_stmt|;
comment|/* 	* init pointers  	*/
if|if
condition|(
operator|(
name|QBAreg
operator|=
name|ubasetup
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qd_strategy: QBA setup error\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|STRAT_ERR
goto|;
block|}
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|user_dma
operator|=
operator|-
literal|1
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
name|cookie
operator|=
name|QBAreg
operator|&
literal|0x3FFFF
expr_stmt|;
name|dga
operator|->
name|adrs_lo
operator|=
operator|(
name|short
operator|)
name|cookie
expr_stmt|;
name|dga
operator|->
name|adrs_hi
operator|=
call|(
name|short
call|)
argument_list|(
name|cookie
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|dga
operator|->
name|bytcnt_lo
operator|=
operator|(
name|short
operator|)
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
call|(
name|short
call|)
argument_list|(
name|bp
operator|->
name|b_bcount
operator|>>
literal|16
argument_list|)
expr_stmt|;
while|while
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|user_dma
condition|)
block|{
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|qdflags
index|[
name|unit
index|]
operator|.
name|user_dma
argument_list|,
name|QDPRIOR
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ubarelse
argument_list|(
literal|0
argument_list|,
operator|&
name|QBAreg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dga
operator|->
name|csr
operator|&
name|DMA_ERR
operator|)
condition|)
block|{
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|STRAT_ERR
label|:
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* cancel adder activity */
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* halt DMA (reset fifo) */
name|dga
operator|->
name|csr
operator||=
name|DMA_ERR
expr_stmt|;
comment|/* clear error condition */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* flag an error to physio() */
comment|/* 	 * if DMA was running, flush spurious intrpt  	 */
if|if
condition|(
name|dga
operator|->
name|bytcnt_lo
operator|!=
literal|0
condition|)
block|{
name|dga
operator|->
name|bytcnt_lo
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
literal|0
expr_stmt|;
name|DMA_SETIGNORE
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
block|}
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* qd_strategy */
end_comment

begin_comment
comment|/*  *  Start output to the console screen  */
end_comment

begin_expr_stmt
name|qdstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|which_unit
operator|,
name|unit
operator|,
name|c
expr_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|which_unit
operator|=
operator|(
name|unit
operator|>>
literal|2
operator|)
operator|&
literal|0x3
expr_stmt|;
name|unit
operator|&=
literal|0x03
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
comment|/* 	* If it's currently active, or delaying, no need to do anything.  	*/
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	* Display chars until the queue is empty. 	* Drop input from anything but the console 	* device on the floor.	 	* 	* XXX - this loop is done at spltty. 	* 	*/
while|while
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
name|blitc
argument_list|(
name|which_unit
argument_list|,
operator|(
name|u_char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* 	* If there are sleepers, and output has drained below low 	* water mark, wake up the sleepers.  	*/
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* qdstart */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|qdstop
argument_list|(
name|tp
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
comment|/* block intrpts during state modification */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Output a character to the QDSS screen  */
end_comment

begin_expr_stmt
name|blitc
argument_list|(
name|unit
argument_list|,
name|chr
argument_list|)
specifier|register
name|unit
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|u_char
name|chr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|nograph
init|=
operator|!
operator|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
operator|)
decl_stmt|;
specifier|static
name|short
name|inescape
index|[
name|NQD
index|]
decl_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
comment|/*  	 * BSD comment: this (&=0177) defeats the extended character  	 * set code for the glass tty, but if i had the time i would  	 * spend it ripping out the code completely.  This driver 	 * is too big for its own good. 	 */
name|chr
operator|&=
literal|0177
expr_stmt|;
comment|/* 	 * Cursor addressing (so vi will work). 	 * Decode for "\E=%.%." cursor motion description. 	 * Corresponds to type "qdcons" in /etc/termcap: 	 * 	 *    qd|qdss|qdcons|qdss glass tty (4.4 BSD):\ 	 *      :am:do=^J:le=^H:bs:cm=\E=%.%.:cl=1^Z:co#128:li#57::nd=^L:up=^K: 	 * 	 */
if|if
condition|(
name|inescape
index|[
name|unit
index|]
operator|&&
name|nograph
condition|)
block|{
switch|switch
condition|(
name|inescape
index|[
name|unit
index|]
operator|++
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|chr
operator|!=
literal|'='
condition|)
block|{
comment|/* abort escape sequence */
name|inescape
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|blitc
argument_list|(
name|unit
argument_list|,
name|chr
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|2
case|:
comment|/* position row */
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
name|CHAR_HEIGHT
operator|*
name|chr
expr_stmt|;
if|if
condition|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|>
literal|863
operator|-
name|CHAR_HEIGHT
condition|)
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|863
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* position column */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
name|CHAR_WIDTH
operator|*
name|chr
expr_stmt|;
if|if
condition|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|>
literal|1024
operator|-
name|CHAR_WIDTH
condition|)
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|1023
operator|-
name|CHAR_WIDTH
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|inescape
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
name|inescape
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|blitc
argument_list|(
name|unit
argument_list|,
name|chr
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|chr
condition|)
block|{
case|case
literal|'\r'
case|:
comment|/* return char */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nograph
condition|)
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'\t'
case|:
comment|/* tab char */
for|for
control|(
name|i
operator|=
literal|8
operator|-
operator|(
operator|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|>>
literal|3
operator|)
operator|&
literal|0x07
operator|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|blitc
argument_list|(
name|unit
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'\n'
case|:
comment|/* line feed char */
if|if
condition|(
operator|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|+=
name|CHAR_HEIGHT
operator|)
operator|>
operator|(
literal|863
operator|-
name|CHAR_HEIGHT
operator|)
condition|)
block|{
if|if
condition|(
name|nograph
condition|)
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|-=
name|CHAR_HEIGHT
expr_stmt|;
name|scroll_up
argument_list|(
name|adder
argument_list|)
expr_stmt|;
block|}
else|else
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nograph
condition|)
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'\b'
case|:
comment|/* backspace char */
if|if
condition|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|>
literal|0
condition|)
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|-=
name|CHAR_WIDTH
expr_stmt|;
if|if
condition|(
name|nograph
condition|)
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|CTRL
argument_list|(
literal|'k'
argument_list|)
case|:
comment|/* cursor up */
if|if
condition|(
name|nograph
operator|&&
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|>
literal|0
condition|)
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|-=
name|CHAR_HEIGHT
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|CTRL
argument_list|(
literal|'^'
argument_list|)
case|:
comment|/* home cursor */
if|if
condition|(
name|nograph
condition|)
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|CTRL
argument_list|(
literal|'l'
argument_list|)
case|:
comment|/* cursor right */
if|if
condition|(
name|nograph
operator|&&
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|<
literal|1023
operator|-
name|CHAR_WIDTH
condition|)
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|+=
name|CHAR_WIDTH
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|CTRL
argument_list|(
literal|'z'
argument_list|)
case|:
comment|/* clear screen */
if|if
condition|(
name|nograph
condition|)
block|{
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* home cursor - termcap seems to assume this */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'\033'
case|:
comment|/* start escape sequence */
if|if
condition|(
name|nograph
condition|)
name|inescape
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
return|return;
default|default:
if|if
condition|(
operator|(
name|chr
operator|<
literal|' '
operator|)
operator|||
operator|(
name|chr
operator|>
literal|'~'
operator|)
condition|)
return|return;
block|}
comment|/* 	 * setup VIPER operand control registers   	 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* select plane #0 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FE
argument_list|)
expr_stmt|;
comment|/* select other planes */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_SOURCE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/* select all planes */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adder
operator|->
name|x_clip_min
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|x_clip_max
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|y_clip_min
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_clip_max
operator|=
literal|864
expr_stmt|;
comment|/* 	 * load DESTINATION origin and vectors   	 */
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|NORMAL
expr_stmt|;
operator|(
name|void
operator|)
name|wait_status
argument_list|(
name|adder
argument_list|,
name|RASTEROP_COMPLETE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
name|cursor
index|[
name|unit
index|]
operator|.
name|x
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
name|CHAR_WIDTH
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
name|cursor
index|[
name|unit
index|]
operator|.
name|y
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/* 	 * load SOURCE origin and vectors   	 */
if|if
condition|(
operator|(
name|chr
operator|-
literal|' '
operator|)
operator|>
operator|(
name|CHARS
operator|-
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid character (x)%x in blitc\n"
argument_list|,
name|chr
argument_list|)
expr_stmt|;
name|chr
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* 	 * X position is modulo the number of characters per line  	 */
name|adder
operator|->
name|source_1_x
operator|=
name|FONT_X
operator|+
operator|(
operator|(
operator|(
name|chr
operator|-
literal|' '
operator|)
operator|%
operator|(
name|MAX_SCREEN_X
operator|/
name|CHAR_WIDTH
operator|)
operator|)
operator|*
name|CHAR_WIDTH
operator|)
expr_stmt|;
comment|/* 	 * Point to either first or second row  	 */
name|adder
operator|->
name|source_1_y
operator|=
literal|2048
operator|-
literal|15
operator|*
operator|(
operator|(
operator|(
name|chr
operator|-
literal|' '
operator|)
operator|/
operator|(
name|MAX_SCREEN_X
operator|/
name|CHAR_WIDTH
operator|)
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|adder
operator|->
name|source_1_dx
operator|=
name|CHAR_WIDTH
expr_stmt|;
name|adder
operator|->
name|source_1_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R1
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|RASTEROP
operator||
name|OCRB
operator||
literal|0
operator||
name|S1E
operator||
name|DTE
expr_stmt|;
comment|/* 	 * update console cursor coordinates  	 */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|+=
name|CHAR_WIDTH
expr_stmt|;
if|if
condition|(
name|nograph
condition|)
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|>
operator|(
literal|1024
operator|-
name|CHAR_WIDTH
operator|)
condition|)
block|{
name|blitc
argument_list|(
name|unit
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|blitc
argument_list|(
name|unit
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* blitc */
end_comment

begin_macro
name|qdreset
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|/*  *  INTERRUPT SERVICE ROUTINES  */
end_comment

begin_comment
comment|/*  *  Service "DMA DONE" interrupt condition  */
end_comment

begin_expr_stmt
name|qddint
argument_list|(
name|qd
argument_list|)
specifier|register
name|qd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|DMAreq_header
modifier|*
name|header
decl_stmt|;
specifier|register
name|struct
name|DMAreq
modifier|*
name|request
decl_stmt|;
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|int
name|cookie
decl_stmt|;
comment|/* DMA adrs for QDSS */
operator|(
name|void
operator|)
name|spl4
argument_list|()
expr_stmt|;
comment|/* allow interval timer in */
comment|/* 	* init pointers  	*/
name|header
operator|=
name|DMAheader
index|[
name|qd
index|]
expr_stmt|;
comment|/* register for optimization */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|dga
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|adder
expr_stmt|;
comment|/* 	* if this interrupt flagged as bogus for interrupt flushing purposes..  	*/
if|if
condition|(
name|DMA_ISIGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|DMA_CLRIGNORE
argument_list|(
name|header
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	* dump a DMA hardware error message if appropriate 	*/
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|DMA_ERR
condition|)
block|{
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|PARITY_ERR
condition|)
name|printf
argument_list|(
literal|"qd%d: qddint: DMA hardware parity fault.\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|BUS_ERR
condition|)
name|printf
argument_list|(
literal|"qd%d: qddint: DMA hardware bus error.\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
block|}
comment|/* 	* if this was a DMA from user space...  	*/
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|user_dma
condition|)
block|{
name|qdflags
index|[
name|qd
index|]
operator|.
name|user_dma
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|qdflags
index|[
name|qd
index|]
operator|.
name|user_dma
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	* if we're doing DMA request queue services, field the error condition  	*/
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|DMA_ERR
condition|)
block|{
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* halt DMA (reset fifo) */
name|dga
operator|->
name|csr
operator||=
name|DMA_ERR
expr_stmt|;
comment|/* clear error condition */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* cancel adder activity */
name|DMA_SETERROR
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* flag error in header status word */
name|DMA_CLRACTIVE
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|header
operator|->
name|DMAreq
index|[
name|header
operator|->
name|oldest
index|]
operator|.
name|DMAdone
operator||=
name|HARD_ERROR
expr_stmt|;
name|header
operator|->
name|newest
operator|=
name|header
operator|->
name|oldest
expr_stmt|;
name|header
operator|->
name|used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qdrsel
index|[
name|qd
index|]
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&
name|SEL_WRITE
condition|)
block|{
name|selwakeup
argument_list|(
name|qdrsel
index|[
name|qd
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qdrsel
index|[
name|qd
index|]
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&=
operator|~
name|SEL_WRITE
expr_stmt|;
block|}
if|if
condition|(
name|dga
operator|->
name|bytcnt_lo
operator|!=
literal|0
condition|)
block|{
name|dga
operator|->
name|bytcnt_lo
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
literal|0
expr_stmt|;
name|DMA_SETIGNORE
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	* if the DMA request queue is now becoming non-full,  	* wakeup "select" client. 	*/
if|if
condition|(
name|DMA_ISFULL
argument_list|(
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|qdrsel
index|[
name|qd
index|]
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&
name|SEL_WRITE
condition|)
block|{
name|selwakeup
argument_list|(
name|qdrsel
index|[
name|qd
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qdrsel
index|[
name|qd
index|]
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&=
operator|~
name|SEL_WRITE
expr_stmt|;
block|}
block|}
name|header
operator|->
name|DMAreq
index|[
name|header
operator|->
name|oldest
index|]
operator|.
name|DMAdone
operator||=
name|REQUEST_DONE
expr_stmt|;
name|QDlast_DMAtype
operator|=
name|header
operator|->
name|DMAreq
index|[
name|header
operator|->
name|oldest
index|]
operator|.
name|DMAtype
expr_stmt|;
comment|/* check for unexpected interrupt */
if|if
condition|(
name|DMA_ISEMPTY
argument_list|(
name|header
argument_list|)
condition|)
return|return;
name|DMA_GETEND
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* update request queue indices */
comment|/* 	* if no more DMA pending, wake up "select" client and exit  	*/
if|if
condition|(
name|DMA_ISEMPTY
argument_list|(
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|qdrsel
index|[
name|qd
index|]
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&
name|SEL_WRITE
condition|)
block|{
name|selwakeup
argument_list|(
name|qdrsel
index|[
name|qd
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qdrsel
index|[
name|qd
index|]
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&=
operator|~
name|SEL_WRITE
expr_stmt|;
block|}
name|DMA_CLRACTIVE
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* flag DMA done */
return|return;
block|}
comment|/* 	* initiate next DMA xfer   	*/
name|request
operator|=
name|DMA_GETBEGIN
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|DMAtype
operator|!=
name|QDlast_DMAtype
condition|)
block|{
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* halt DMA (reset fifo) */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* cancel adder activity */
block|}
switch|switch
condition|(
name|request
operator|->
name|DMAtype
condition|)
block|{
case|case
name|DISPLIST
case|:
if|if
condition|(
name|request
operator|->
name|DMAtype
operator|!=
name|QDlast_DMAtype
condition|)
block|{
name|dga
operator|->
name|csr
operator||=
name|DL_ENB
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
operator|(
name|BTOP_ENB
operator||
name|BYTE_DMA
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|PTOB
case|:
if|if
condition|(
name|request
operator|->
name|DMAtype
operator|!=
name|QDlast_DMAtype
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|BYTE_PACK
condition|)
name|dga
operator|->
name|csr
operator||=
operator|(
name|PTOB_ENB
operator||
name|BYTE_DMA
operator|)
expr_stmt|;
else|else
block|{
name|dga
operator|->
name|csr
operator||=
name|PTOB_ENB
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|BYTE_DMA
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BTOP
case|:
if|if
condition|(
name|request
operator|->
name|DMAtype
operator|!=
name|QDlast_DMAtype
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|BYTE_PACK
condition|)
block|{
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DL_ENB
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
operator|(
name|BTOP_ENB
operator||
name|BYTE_DMA
operator|)
expr_stmt|;
block|}
else|else
block|{
name|dga
operator|->
name|csr
operator||=
name|BTOP_ENB
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
operator|(
name|BYTE_DMA
operator||
name|DL_ENB
operator|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"qd%d: qddint: illegal DMAtype parameter.\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
name|DMA_CLRACTIVE
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* flag DMA done */
return|return;
block|}
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|COUNT_ZERO
condition|)
block|{
name|dga
operator|->
name|csr
operator|&=
operator|~
name|SET_DONE_FIFO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|FIFO_EMPTY
condition|)
block|{
name|dga
operator|->
name|csr
operator||=
name|SET_DONE_FIFO
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|WORD_PACK
condition|)
name|dga
operator|->
name|csr
operator|&=
operator|~
name|BYTE_DMA
expr_stmt|;
elseif|else
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|BYTE_PACK
condition|)
name|dga
operator|->
name|csr
operator||=
name|BYTE_DMA
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
name|QDlast_DMAtype
operator|=
name|request
operator|->
name|DMAtype
expr_stmt|;
name|cookie
operator|=
operator|(
operator|(
name|int
operator|)
name|request
operator|->
name|bufp
operator|-
operator|(
name|int
operator|)
name|header
operator|)
operator|+
operator|(
name|int
operator|)
name|header
operator|->
name|QBAreg
expr_stmt|;
name|dga
operator|->
name|adrs_lo
operator|=
operator|(
name|short
operator|)
name|cookie
expr_stmt|;
name|dga
operator|->
name|adrs_hi
operator|=
call|(
name|short
call|)
argument_list|(
name|cookie
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|dga
operator|->
name|bytcnt_lo
operator|=
operator|(
name|short
operator|)
name|request
operator|->
name|length
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
call|(
name|short
call|)
argument_list|(
name|request
operator|->
name|length
operator|>>
literal|16
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * ADDER interrupt service routine  */
end_comment

begin_expr_stmt
name|qdaint
argument_list|(
name|qd
argument_list|)
specifier|register
name|qd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|struct
name|color_buf
modifier|*
name|cbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|rgb
modifier|*
name|rgbp
decl_stmt|;
specifier|register
name|short
modifier|*
name|red
decl_stmt|;
specifier|register
name|short
modifier|*
name|green
decl_stmt|;
specifier|register
name|short
modifier|*
name|blue
decl_stmt|;
operator|(
name|void
operator|)
name|spl4
argument_list|()
expr_stmt|;
comment|/* allow interval timer in */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|adder
expr_stmt|;
comment|/* 	* service the vertical blank interrupt (VSYNC bit) by loading  	* any pending color map load request   	*/
if|if
condition|(
name|adder
operator|->
name|status
operator|&
name|VSYNC
condition|)
block|{
name|adder
operator|->
name|status
operator|&=
operator|~
name|VSYNC
expr_stmt|;
comment|/* clear the interrupt */
name|cbuf
operator|=
name|color_buf
index|[
name|qd
index|]
expr_stmt|;
if|if
condition|(
name|cbuf
operator|->
name|status
operator|&
name|LOAD_COLOR_MAP
condition|)
block|{
name|red
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|red
expr_stmt|;
name|green
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|green
expr_stmt|;
name|blue
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|blue
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cbuf
operator|->
name|count
operator|,
name|rgbp
operator|=
name|cbuf
operator|->
name|rgb
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|rgbp
operator|++
control|)
block|{
name|red
index|[
name|rgbp
operator|->
name|offset
index|]
operator|=
operator|(
name|short
operator|)
name|rgbp
operator|->
name|red
expr_stmt|;
name|green
index|[
name|rgbp
operator|->
name|offset
index|]
operator|=
operator|(
name|short
operator|)
name|rgbp
operator|->
name|green
expr_stmt|;
name|blue
index|[
name|rgbp
operator|->
name|offset
index|]
operator|=
operator|(
name|short
operator|)
name|rgbp
operator|->
name|blue
expr_stmt|;
block|}
name|cbuf
operator|->
name|status
operator|&=
operator|~
name|LOAD_COLOR_MAP
expr_stmt|;
block|}
block|}
comment|/* 	* service the scroll interrupt (FRAME_SYNC bit)  	*/
if|if
condition|(
name|adder
operator|->
name|status
operator|&
name|FRAME_SYNC
condition|)
block|{
name|adder
operator|->
name|status
operator|&=
operator|~
name|FRAME_SYNC
expr_stmt|;
comment|/* clear the interrupt */
if|if
condition|(
name|scroll
index|[
name|qd
index|]
operator|->
name|status
operator|&
name|LOAD_REGS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
name|adder
operator|->
name|status
operator|&
name|ID_SCROLL_READY
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdaint: timeout on ID_SCROLL_READY\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
return|return;
block|}
name|adder
operator|->
name|ID_scroll_data
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|viper_constant
expr_stmt|;
name|adder
operator|->
name|ID_scroll_command
operator|=
name|ID_LOAD
operator||
name|SCROLL_CONSTANT
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|y_scroll_constant
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|y_offset
expr_stmt|;
if|if
condition|(
name|scroll
index|[
name|qd
index|]
operator|->
name|status
operator|&
name|LOAD_INDEX
condition|)
block|{
name|adder
operator|->
name|x_index_pending
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|x_index_pending
expr_stmt|;
name|adder
operator|->
name|y_index_pending
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|y_index_pending
expr_stmt|;
block|}
name|scroll
index|[
name|qd
index|]
operator|->
name|status
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *  DUART input interrupt service routine  *  *  XXX - this routine should be broken out - it is essentially  *	      straight line code.  */
end_comment

begin_expr_stmt
name|qdiint
argument_list|(
name|qd
argument_list|)
specifier|register
name|qd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|_vs_event
modifier|*
name|event
decl_stmt|;
specifier|register
name|struct
name|qdinput
modifier|*
name|eqh
decl_stmt|;
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|struct
name|mouse_report
modifier|*
name|new_rep
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|u_short
name|chr
decl_stmt|;
name|u_short
name|status
decl_stmt|;
name|u_short
name|data
decl_stmt|;
name|u_short
name|key
decl_stmt|;
name|char
name|do_wakeup
init|=
literal|0
decl_stmt|;
comment|/* flag to do a select wakeup call */
name|char
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
comment|/* mouse button test variables */
operator|(
name|void
operator|)
name|spl4
argument_list|()
expr_stmt|;
comment|/* allow interval timer in */
name|eqh
operator|=
name|eq_header
index|[
name|qd
index|]
expr_stmt|;
comment|/* optimized as a register */
name|new_rep
operator|=
operator|&
name|current_rep
index|[
name|qd
index|]
expr_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|duart
expr_stmt|;
comment|/* 	* if the graphic device is turned on..	 	*/
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
condition|)
block|{
comment|/* 		* empty DUART  		*/
while|while
condition|(
name|duart
operator|->
name|statusA
operator|&
name|RCV_RDY
operator|||
name|duart
operator|->
name|statusB
operator|&
name|RCV_RDY
condition|)
block|{
comment|/* 			 * pick up LK-201 input (if any)  			 */
if|if
condition|(
name|duart
operator|->
name|statusA
operator|&
name|RCV_RDY
condition|)
block|{
comment|/* if error condition, then reset it */
if|if
condition|(
name|duart
operator|->
name|statusA
operator|&
literal|0x70
condition|)
block|{
name|duart
operator|->
name|cmdA
operator|=
literal|0x40
expr_stmt|;
continue|continue;
block|}
comment|/* event queue full now? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: event queue overflow\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 				* Check for various keyboard errors  */
name|key
operator|=
name|duart
operator|->
name|dataA
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|LK_POWER_ERROR
operator|||
name|key
operator|==
name|LK_KDOWN_ERROR
operator|||
name|key
operator|==
name|LK_INPUT_ERROR
operator|||
name|key
operator|==
name|LK_OUTPUT_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: keyboard error, code = %x\n"
argument_list|,
name|qd
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|key
operator|<
name|LK_LOWEST
condition|)
return|return;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request a select wakeup call */
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
name|event
operator|->
name|vse_key
operator|=
name|key
expr_stmt|;
name|event
operator|->
name|vse_key
operator|&=
literal|0x00FF
expr_stmt|;
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
name|event
operator|->
name|vse_type
operator|=
name|VSE_BUTTON
expr_stmt|;
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTRAW
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_DKB
expr_stmt|;
block|}
comment|/* 			* pick up the mouse input (if any)  */
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|pntr_id
operator|==
name|MOUSE_ID
condition|)
block|{
if|if
condition|(
name|status
operator|&
literal|0x70
condition|)
block|{
name|duart
operator|->
name|cmdB
operator|=
literal|0x40
expr_stmt|;
continue|continue;
block|}
comment|/* event queue full now? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: event queue overflow\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
comment|/* get report byte */
operator|++
name|new_rep
operator|->
name|bytcnt
expr_stmt|;
comment|/* bump report byte count */
comment|/* 				* if 1st byte of report.. */
if|if
condition|(
name|data
operator|&
name|START_FRAME
condition|)
block|{
name|new_rep
operator|->
name|state
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|>
literal|1
condition|)
block|{
comment|/* start of new frame */
name|new_rep
operator|->
name|bytcnt
operator|=
literal|1
expr_stmt|;
comment|/* ..continue looking */
continue|continue;
block|}
block|}
comment|/* 				* if 2nd byte of report.. */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|2
condition|)
block|{
name|new_rep
operator|->
name|dx
operator|=
name|data
operator|&
literal|0x00FF
expr_stmt|;
block|}
comment|/* 				* if 3rd byte of report, load input event queue */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|3
condition|)
block|{
name|new_rep
operator|->
name|dy
operator|=
name|data
operator|&
literal|0x00FF
expr_stmt|;
name|new_rep
operator|->
name|bytcnt
operator|=
literal|0
expr_stmt|;
comment|/* 					* if mouse position has changed.. */
if|if
condition|(
name|new_rep
operator|->
name|dx
operator|!=
literal|0
operator|||
name|new_rep
operator|->
name|dy
operator|!=
literal|0
condition|)
block|{
comment|/* 						* calculate acceleration factor, if needed	*/
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_acc
operator|>
name|ACC_OFF
condition|)
block|{
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_thr
operator|<=
name|new_rep
operator|->
name|dx
condition|)
name|new_rep
operator|->
name|dx
operator|+=
operator|(
name|new_rep
operator|->
name|dx
operator|-
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_thr
operator|)
operator|*
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_acc
expr_stmt|;
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_thr
operator|<=
name|new_rep
operator|->
name|dy
condition|)
name|new_rep
operator|->
name|dy
operator|+=
operator|(
name|new_rep
operator|->
name|dy
operator|-
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_thr
operator|)
operator|*
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_acc
expr_stmt|;
block|}
comment|/* 						* update cursor position coordinates */
if|if
condition|(
name|new_rep
operator|->
name|state
operator|&
name|X_SIGN
condition|)
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|+=
name|new_rep
operator|->
name|dx
expr_stmt|;
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|>
literal|1023
condition|)
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|=
literal|1023
expr_stmt|;
block|}
else|else
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|-=
name|new_rep
operator|->
name|dx
expr_stmt|;
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|<
operator|-
literal|15
condition|)
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|=
operator|-
literal|15
expr_stmt|;
block|}
if|if
condition|(
name|new_rep
operator|->
name|state
operator|&
name|Y_SIGN
condition|)
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|-=
name|new_rep
operator|->
name|dy
expr_stmt|;
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|<
operator|-
literal|15
condition|)
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|=
operator|-
literal|15
expr_stmt|;
block|}
else|else
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|+=
name|new_rep
operator|->
name|dy
expr_stmt|;
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|>
literal|863
condition|)
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|=
literal|863
expr_stmt|;
block|}
comment|/* 						* update cursor screen position */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
argument_list|)
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|eqh
operator|->
name|curs_pos
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* 						* if cursor is in the box, no event report */
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|<=
name|eqh
operator|->
name|curs_box
operator|.
name|right
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|>=
name|eqh
operator|->
name|curs_box
operator|.
name|left
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|>=
name|eqh
operator|->
name|curs_box
operator|.
name|top
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|<=
name|eqh
operator|->
name|curs_box
operator|.
name|bottom
condition|)
block|{
goto|goto
name|GET_MBUTTON
goto|;
block|}
comment|/* 						* report the mouse motion event */
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request a select wakeup call */
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_MOUSE
expr_stmt|;
comment|/* mouse */
name|event
operator|->
name|vse_type
operator|=
name|VSE_MMOTION
expr_stmt|;
comment|/* pos changed */
name|event
operator|->
name|vse_key
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|vse_direction
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
comment|/* time stamp */
block|}
name|GET_MBUTTON
label|:
comment|/* 					* if button state has changed */
name|a
operator|=
name|new_rep
operator|->
name|state
operator|&
literal|0x07
expr_stmt|;
comment|/*mask nonbutton bits */
name|b
operator|=
name|last_rep
index|[
name|qd
index|]
operator|.
name|state
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|a
operator|^
name|b
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
literal|8
condition|;
name|c
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|c
operator|&
operator|(
name|a
operator|^
name|b
operator|)
operator|)
condition|)
comment|/* this button change? */
continue|continue;
comment|/* event queue full? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: event queue overflow\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
comment|/* get new event */
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request select wakeup */
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_MOUSE
expr_stmt|;
comment|/* mouse */
name|event
operator|->
name|vse_type
operator|=
name|VSE_BUTTON
expr_stmt|;
comment|/* new button */
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
comment|/* time stamp */
comment|/* flag changed button and if up or down */
if|if
condition|(
name|c
operator|==
name|RIGHT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_RIGHT_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|MIDDLE_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_MIDDLE_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|LEFT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_LEFT_BUTTON
expr_stmt|;
comment|/* set bit = button depressed */
if|if
condition|(
name|c
operator|&
name|a
condition|)
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTDOWN
expr_stmt|;
else|else
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTUP
expr_stmt|;
block|}
block|}
comment|/* refresh last report */
name|last_rep
index|[
name|qd
index|]
operator|=
name|current_rep
index|[
name|qd
index|]
expr_stmt|;
block|}
comment|/* get last byte of report */
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|pntr_id
operator|==
name|TABLET_ID
condition|)
block|{
comment|/* 				* pickup tablet input, if any   				*/
if|if
condition|(
name|status
operator|&
literal|0x70
condition|)
block|{
name|duart
operator|->
name|cmdB
operator|=
literal|0x40
expr_stmt|;
continue|continue;
block|}
comment|/*  				 * event queue full now? (overflow condition)  				 */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: event queue overflow\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
comment|/* get report byte */
operator|++
name|new_rep
operator|->
name|bytcnt
expr_stmt|;
comment|/* bump report byte count */
comment|/* 				* if 1st byte of report.. */
if|if
condition|(
name|data
operator|&
name|START_FRAME
condition|)
block|{
name|new_rep
operator|->
name|state
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|>
literal|1
condition|)
block|{
name|new_rep
operator|->
name|bytcnt
operator|=
literal|1
expr_stmt|;
comment|/* start of new frame */
continue|continue;
comment|/* ..continue looking */
block|}
block|}
comment|/* 				* if 2nd byte of report.. */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|2
condition|)
block|{
name|new_rep
operator|->
name|dx
operator|=
name|data
operator|&
literal|0x3F
expr_stmt|;
block|}
comment|/* 				* if 3rd byte of report.. */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|3
condition|)
block|{
name|new_rep
operator|->
name|dx
operator||=
operator|(
name|data
operator|&
literal|0x3F
operator|)
operator|<<
literal|6
expr_stmt|;
block|}
comment|/* 				* if 4th byte of report.. */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|4
condition|)
block|{
name|new_rep
operator|->
name|dy
operator|=
name|data
operator|&
literal|0x3F
expr_stmt|;
block|}
comment|/* 				* if 5th byte of report, load input event queue */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|5
condition|)
block|{
name|new_rep
operator|->
name|dy
operator||=
operator|(
name|data
operator|&
literal|0x3F
operator|)
operator|<<
literal|6
expr_stmt|;
name|new_rep
operator|->
name|bytcnt
operator|=
literal|0
expr_stmt|;
comment|/* 					* update cursor position coordinates */
name|new_rep
operator|->
name|dx
operator|/=
name|qdflags
index|[
name|qd
index|]
operator|.
name|tab_res
expr_stmt|;
name|new_rep
operator|->
name|dy
operator|=
operator|(
literal|2200
operator|-
name|new_rep
operator|->
name|dy
operator|)
operator|/
name|qdflags
index|[
name|qd
index|]
operator|.
name|tab_res
expr_stmt|;
if|if
condition|(
name|new_rep
operator|->
name|dx
operator|>
literal|1023
condition|)
block|{
name|new_rep
operator|->
name|dx
operator|=
literal|1023
expr_stmt|;
block|}
if|if
condition|(
name|new_rep
operator|->
name|dy
operator|>
literal|863
condition|)
block|{
name|new_rep
operator|->
name|dy
operator|=
literal|863
expr_stmt|;
block|}
comment|/* 					* report an event if the puck/stylus has moved 					*/
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|!=
name|new_rep
operator|->
name|dx
operator|||
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|!=
name|new_rep
operator|->
name|dy
condition|)
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|=
name|new_rep
operator|->
name|dx
expr_stmt|;
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|=
name|new_rep
operator|->
name|dy
expr_stmt|;
comment|/* 						* update cursor screen position */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
argument_list|)
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|eqh
operator|->
name|curs_pos
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* 						* if cursor is in the box, no event report 						*/
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|<=
name|eqh
operator|->
name|curs_box
operator|.
name|right
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|>=
name|eqh
operator|->
name|curs_box
operator|.
name|left
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|>=
name|eqh
operator|->
name|curs_box
operator|.
name|top
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|<=
name|eqh
operator|->
name|curs_box
operator|.
name|bottom
condition|)
block|{
goto|goto
name|GET_TBUTTON
goto|;
block|}
comment|/* 						* report the tablet motion event */
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request a select wakeup call */
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_TABLET
expr_stmt|;
comment|/* tablet */
comment|/* 						* right now, X handles tablet motion the same 						* as mouse motion 						*/
name|event
operator|->
name|vse_type
operator|=
name|VSE_MMOTION
expr_stmt|;
comment|/* pos changed */
name|event
operator|->
name|vse_key
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|vse_direction
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
comment|/* time stamp */
block|}
name|GET_TBUTTON
label|:
comment|/* 					* if button state has changed */
name|a
operator|=
name|new_rep
operator|->
name|state
operator|&
literal|0x1E
expr_stmt|;
comment|/* mask nonbutton bits */
name|b
operator|=
name|last_rep
index|[
name|qd
index|]
operator|.
name|state
operator|&
literal|0x1E
expr_stmt|;
if|if
condition|(
name|a
operator|^
name|b
condition|)
block|{
comment|/* event queue full now? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: event queue overflow\n"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
comment|/* get new event */
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request a select wakeup call */
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_TABLET
expr_stmt|;
comment|/* tablet */
name|event
operator|->
name|vse_type
operator|=
name|VSE_BUTTON
expr_stmt|;
comment|/* button changed */
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
comment|/* time stamp */
comment|/* define the changed button and if up or down */
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<=
literal|0x10
condition|;
name|c
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|c
operator|&
operator|(
name|a
operator|^
name|b
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|T_LEFT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_T_LEFT_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|T_FRONT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_T_FRONT_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|T_RIGHT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_T_RIGHT_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|T_BACK_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_T_BACK_BUTTON
expr_stmt|;
break|break;
block|}
block|}
comment|/* set bit = button depressed */
if|if
condition|(
name|c
operator|&
name|a
condition|)
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTDOWN
expr_stmt|;
else|else
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTUP
expr_stmt|;
block|}
comment|/* refresh last report */
name|last_rep
index|[
name|qd
index|]
operator|=
name|current_rep
index|[
name|qd
index|]
expr_stmt|;
block|}
comment|/* get last byte of report */
block|}
comment|/* pick up tablet input */
block|}
comment|/* while input available.. */
comment|/* 		* do select wakeup	 		*/
if|if
condition|(
name|qdrsel
index|[
name|qd
index|]
operator|&&
name|do_wakeup
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&
name|SEL_READ
condition|)
block|{
name|selwakeup
argument_list|(
name|qdrsel
index|[
name|qd
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qdrsel
index|[
name|qd
index|]
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&=
operator|~
name|SEL_READ
expr_stmt|;
name|do_wakeup
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * if the graphic device is not turned on, this is console input 		 */
name|ui
operator|=
name|qdinfo
index|[
name|qd
index|]
expr_stmt|;
if|if
condition|(
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return;
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|qd
operator|<<
literal|2
index|]
expr_stmt|;
comment|/* 		 * Get a character from the keyboard.  		 */
while|while
condition|(
name|duart
operator|->
name|statusA
operator|&
name|RCV_RDY
condition|)
block|{
name|key
operator|=
name|duart
operator|->
name|dataA
expr_stmt|;
name|key
operator|&=
literal|0xFF
expr_stmt|;
comment|/* 			* Check for various keyboard errors   			*/
if|if
condition|(
name|key
operator|==
name|LK_POWER_ERROR
operator|||
name|key
operator|==
name|LK_KDOWN_ERROR
operator|||
name|key
operator|==
name|LK_INPUT_ERROR
operator|||
name|key
operator|==
name|LK_OUTPUT_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"qd%d: qdiint: Keyboard error, code = %x\n"
argument_list|,
name|qd
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|key
operator|<
name|LK_LOWEST
condition|)
return|return;
comment|/* 			* See if its a state change key */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|LOCK
case|:
name|q_keyboard
operator|.
name|lock
operator|^=
literal|0xffff
expr_stmt|;
comment|/* toggle */
if|if
condition|(
name|q_keyboard
operator|.
name|lock
condition|)
operator|(
name|void
operator|)
name|led_control
argument_list|(
name|qd
argument_list|,
name|LK_LED_ENABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|led_control
argument_list|(
name|qd
argument_list|,
name|LK_LED_DISABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
return|return;
case|case
name|SHIFT
case|:
name|q_keyboard
operator|.
name|shift
operator|^=
literal|0xFFFF
expr_stmt|;
return|return;
case|case
name|CNTRL
case|:
name|q_keyboard
operator|.
name|cntrl
operator|^=
literal|0xFFFF
expr_stmt|;
return|return;
case|case
name|ALLUP
case|:
name|q_keyboard
operator|.
name|cntrl
operator|=
literal|0
expr_stmt|;
name|q_keyboard
operator|.
name|shift
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|REPEAT
case|:
name|chr
operator|=
name|q_keyboard
operator|.
name|last
expr_stmt|;
break|break;
comment|/* 				* Test for cntrl characters. If set, see if the character 				* is elligible to become a control character. */
default|default:
if|if
condition|(
name|q_keyboard
operator|.
name|cntrl
condition|)
block|{
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|chr
operator|>=
literal|' '
operator|&&
name|chr
operator|<=
literal|'~'
condition|)
name|chr
operator|&=
literal|0x1F
expr_stmt|;
elseif|else
if|if
condition|(
name|chr
operator|>=
literal|0xA1
operator|&&
name|chr
operator|<=
literal|0xFE
condition|)
name|chr
operator|&=
literal|0x9F
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q_keyboard
operator|.
name|lock
operator|||
name|q_keyboard
operator|.
name|shift
condition|)
name|chr
operator|=
name|q_shift_key
index|[
name|key
index|]
expr_stmt|;
else|else
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
break|break;
block|}
name|q_keyboard
operator|.
name|last
operator|=
name|chr
expr_stmt|;
comment|/* 			* Check for special function keys */
if|if
condition|(
name|chr
operator|&
literal|0x100
condition|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|string
operator|=
name|q_special
index|[
name|chr
operator|&
literal|0x7F
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|string
operator|++
operator|,
name|tp
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|chr
operator|&
literal|0177
operator|,
name|tp
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* qdiint */
end_comment

begin_comment
comment|/*  *  * Clear the QDSS screen  *  *>>> NOTE<<<  *  *   This code requires that certain adder initialization be valid.  To  *   assure that this requirement is satisfied, this routine should be  *   called only after calling the "setup_dragon()" function.  *  *   Clear the bitmap a piece at a time. Since the fast scroll clear  *   only clears the current displayed portion of the bitmap put a  *   temporary value in the y limit register so we can access whole  *   bitmap  *  */
end_comment

begin_macro
name|clear_qd_screen
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|adder
operator|->
name|x_limit
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|y_limit
operator|=
literal|2048
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|WSV
value|(void)wait_status(adder, VSYNC); (void)wait_status(adder, VSYNC)
name|WSV
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|SCROLL_ERASE
expr_stmt|;
name|WSV
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|864
expr_stmt|;
name|WSV
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|SCROLL_ERASE
expr_stmt|;
name|WSV
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|1728
expr_stmt|;
name|WSV
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|SCROLL_ERASE
expr_stmt|;
name|WSV
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|0
expr_stmt|;
comment|/* back to normal */
name|WSV
expr_stmt|;
name|adder
operator|->
name|x_limit
operator|=
name|MAX_SCREEN_X
expr_stmt|;
name|adder
operator|->
name|y_limit
operator|=
name|MAX_SCREEN_Y
operator|+
name|FONT_HEIGHT
expr_stmt|;
undef|#
directive|undef
name|WSV
block|}
end_block

begin_comment
comment|/* clear_qd_screen */
end_comment

begin_comment
comment|/*  *  kernel console output to the glass tty  */
end_comment

begin_expr_stmt
name|qdputc
argument_list|(
name|chr
argument_list|)
specifier|register
name|char
name|chr
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 	 * if system is now physical, forget it (ie: crash DUMP)  	 */
if|if
condition|(
operator|(
name|mfpr
argument_list|(
name|MAPEN
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return;
name|blitc
argument_list|(
literal|0
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|chr
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chr
operator|&
literal|0177
operator|)
operator|==
literal|'\n'
condition|)
name|blitc
argument_list|(
literal|0
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* qdputc */
end_comment

begin_comment
comment|/*  *  load the mouse cursor's template RAM bitmap  */
end_comment

begin_macro
name|ldcursor
argument_list|(
argument|unit
argument_list|,
argument|bitmap
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
modifier|*
name|bitmap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
specifier|register
name|short
modifier|*
name|temp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|curs
decl_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|temp
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|template
expr_stmt|;
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|CURS_ENB
condition|)
block|{
comment|/* if the cursor is enabled.. */
name|curs
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* ..note that.. */
name|dga
operator|->
name|csr
operator|&=
operator|~
name|CURS_ENB
expr_stmt|;
comment|/* ..and shut it off */
block|}
else|else
name|curs
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|CURS_ENB
expr_stmt|;
comment|/* shut off the cursor */
name|temp
operator|+=
operator|(
literal|8
operator|*
literal|1024
operator|)
operator|-
literal|32
expr_stmt|;
comment|/* cursor is 32 WORDS from the end */
comment|/* ..of the 8k WORD template space */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
operator|*
name|temp
operator|++
operator|=
operator|*
name|bitmap
operator|++
expr_stmt|;
if|if
condition|(
name|curs
condition|)
block|{
comment|/* if cursor was enabled.. */
name|dga
operator|->
name|csr
operator||=
name|CURS_ENB
expr_stmt|;
comment|/* ..turn it back on */
block|}
block|}
end_block

begin_comment
comment|/* ldcursor */
end_comment

begin_comment
comment|/*  *  Put the console font in the QDSS off-screen memory  */
end_comment

begin_macro
name|ldfont
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
specifier|register
name|i
operator|,
name|j
operator|,
name|k
operator|,
name|max_chars_line
expr_stmt|;
specifier|register
name|short
name|packed
decl_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
comment|/* 	* setup VIPER operand control registers   	*/
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC2_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_SOURCE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|DST_INDEX_ENABLE
operator||
name|NORMAL
expr_stmt|;
comment|/* 	* load destination data   	*/
operator|(
name|void
operator|)
name|wait_status
argument_list|(
name|adder
argument_list|,
name|RASTEROP_COMPLETE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
name|FONT_X
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
name|FONT_Y
expr_stmt|;
if|#
directive|if
name|FONT_WIDTH
operator|>
name|MAX_SCREEN_X
name|adder
operator|->
name|fast_dest_dx
operator|=
name|MAX_SCREEN_X
expr_stmt|;
else|#
directive|else
name|adder
operator|->
name|fast_dest_dx
operator|=
name|FONT_WIDTH
expr_stmt|;
endif|#
directive|endif
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/* 	* setup for processor to bitmap xfer  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|PBT
operator||
name|OCRB
operator||
literal|2
operator||
name|DTE
operator||
literal|2
expr_stmt|;
comment|/* 	* Figure out how many characters can be stored on one "line" of  	* offscreen memory. 	*/
name|max_chars_line
operator|=
name|MAX_SCREEN_X
operator|/
operator|(
name|CHAR_WIDTH
operator|*
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|CHARS
operator|/
literal|2
operator|+
name|CHARS
operator|%
literal|2
operator|)
operator|<
name|max_chars_line
condition|)
name|max_chars_line
operator|=
name|CHARS
operator|/
literal|2
operator|+
name|CHARS
operator|%
literal|2
expr_stmt|;
comment|/* 	* iteratively do the processor to bitmap xfer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ROWS
condition|;
operator|++
name|i
control|)
block|{
comment|/* PTOB a scan line */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|i
init|;
name|j
operator|<
name|max_chars_line
condition|;
operator|++
name|j
control|)
block|{
comment|/* PTOB one scan of a char cell */
name|packed
operator|=
name|q_font
index|[
name|k
index|]
expr_stmt|;
name|k
operator|+=
name|ROWS
expr_stmt|;
name|packed
operator||=
operator|(
operator|(
name|short
operator|)
name|q_font
index|[
name|k
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|k
operator|+=
name|ROWS
expr_stmt|;
operator|(
name|void
operator|)
name|wait_status
argument_list|(
name|adder
argument_list|,
name|TX_READY
argument_list|)
expr_stmt|;
name|adder
operator|->
name|id_data
operator|=
name|packed
expr_stmt|;
block|}
block|}
comment|/* 	 * (XXX XXX XXX - should remove) 	 * 	 * Copy the second row of characters.  Subtract the first 	 * row from the total number.  Divide this quantity by 2 	 * because 2 chars are stored in a short in the PTOB loop 	 * below.  Figure out how many characters can be stored on 	 * one "line" of offscreen memory  	 */
name|max_chars_line
operator|=
name|MAX_SCREEN_X
operator|/
operator|(
name|CHAR_WIDTH
operator|*
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|CHARS
operator|/
literal|2
operator|+
name|CHARS
operator|%
literal|2
operator|)
operator|<
name|max_chars_line
condition|)
return|return;
name|max_chars_line
operator|=
operator|(
name|CHARS
operator|/
literal|2
operator|+
name|CHARS
operator|%
literal|2
operator|)
operator|-
name|max_chars_line
expr_stmt|;
comment|/* 95 - 64 */
comment|/* Paranoia check to see if 3rd row may be needed */
if|if
condition|(
name|max_chars_line
operator|>
operator|(
name|MAX_SCREEN_X
operator|/
operator|(
name|CHAR_WIDTH
operator|*
literal|2
operator|)
operator|)
condition|)
name|max_chars_line
operator|=
name|MAX_SCREEN_X
operator|/
operator|(
name|CHAR_WIDTH
operator|*
literal|2
operator|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
name|FONT_X
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
name|FONT_Y
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
name|max_chars_line
operator|*
name|CHAR_WIDTH
operator|*
literal|2
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/* 	* setup for processor to bitmap xfer   	*/
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|PBT
operator||
name|OCRB
operator||
literal|2
operator||
name|DTE
operator||
literal|2
expr_stmt|;
comment|/* 	* iteratively do the processor to bitmap xfer  	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ROWS
condition|;
operator|++
name|i
control|)
block|{
comment|/*  		 * PTOB a scan line  		 */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|i
init|;
name|j
operator|<
name|max_chars_line
condition|;
operator|++
name|j
control|)
block|{
comment|/* 			 * PTOB one scan of a char cell  			 */
name|packed
operator|=
name|q_font
index|[
name|k
operator|+
name|FONT_OFFSET
index|]
expr_stmt|;
name|k
operator|+=
name|ROWS
expr_stmt|;
name|packed
operator||=
operator|(
operator|(
name|short
operator|)
name|q_font
index|[
name|k
operator|+
name|FONT_OFFSET
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|k
operator|+=
name|ROWS
expr_stmt|;
operator|(
name|void
operator|)
name|wait_status
argument_list|(
name|adder
argument_list|,
name|TX_READY
argument_list|)
expr_stmt|;
name|adder
operator|->
name|id_data
operator|=
name|packed
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* ldfont */
end_comment

begin_comment
comment|/*  *  Get a character from the LK201 (polled)  */
end_comment

begin_macro
name|qdgetc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|short
name|key
decl_stmt|;
specifier|register
name|char
name|chr
decl_stmt|;
specifier|register
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
literal|0
index|]
operator|.
name|duart
expr_stmt|;
comment|/* 	* Get a character from the keyboard.  	*/
name|LOOP
label|:
while|while
condition|(
operator|!
operator|(
name|duart
operator|->
name|statusA
operator|&
name|RCV_RDY
operator|)
condition|)
empty_stmt|;
name|key
operator|=
name|duart
operator|->
name|dataA
expr_stmt|;
name|key
operator|&=
literal|0xFF
expr_stmt|;
comment|/* 	* Check for various keyboard errors  */
if|if
condition|(
name|key
operator|==
name|LK_POWER_ERROR
operator|||
name|key
operator|==
name|LK_KDOWN_ERROR
operator|||
name|key
operator|==
name|LK_INPUT_ERROR
operator|||
name|key
operator|==
name|LK_OUTPUT_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"Keyboard error, code = %x\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|key
operator|<
name|LK_LOWEST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * See if its a state change key  	 */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|LOCK
case|:
name|q_keyboard
operator|.
name|lock
operator|^=
literal|0xffff
expr_stmt|;
comment|/* toggle */
if|if
condition|(
name|q_keyboard
operator|.
name|lock
condition|)
operator|(
name|void
operator|)
name|led_control
argument_list|(
literal|0
argument_list|,
name|LK_LED_ENABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|led_control
argument_list|(
literal|0
argument_list|,
name|LK_LED_DISABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|SHIFT
case|:
name|q_keyboard
operator|.
name|shift
operator|^=
literal|0xFFFF
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|CNTRL
case|:
name|q_keyboard
operator|.
name|cntrl
operator|^=
literal|0xFFFF
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|ALLUP
case|:
name|q_keyboard
operator|.
name|cntrl
operator|=
literal|0
expr_stmt|;
name|q_keyboard
operator|.
name|shift
operator|=
literal|0
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|REPEAT
case|:
name|chr
operator|=
name|q_keyboard
operator|.
name|last
expr_stmt|;
break|break;
comment|/* 		* Test for cntrl characters. If set, see if the character 		* is elligible to become a control character.  		*/
default|default:
if|if
condition|(
name|q_keyboard
operator|.
name|cntrl
condition|)
block|{
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|chr
operator|>=
literal|' '
operator|&&
name|chr
operator|<=
literal|'~'
condition|)
name|chr
operator|&=
literal|0x1F
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q_keyboard
operator|.
name|lock
operator|||
name|q_keyboard
operator|.
name|shift
condition|)
name|chr
operator|=
name|q_shift_key
index|[
name|key
index|]
expr_stmt|;
else|else
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chr
operator|<
literal|' '
operator|&&
name|chr
operator|>
literal|'~'
condition|)
comment|/* if input is non-displayable */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ..then pitch it! */
name|q_keyboard
operator|.
name|last
operator|=
name|chr
expr_stmt|;
comment|/* 	* Check for special function keys */
if|if
condition|(
name|chr
operator|&
literal|0x80
condition|)
comment|/* pitch the function keys */
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|chr
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdgetc */
end_comment

begin_comment
comment|/*  *  led_control()... twiddle LK-201 LED's  */
end_comment

begin_macro
name|led_control
argument_list|(
argument|unit
argument_list|,
argument|cmd
argument_list|,
argument|led_mask
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|cmd
decl_stmt|,
name|led_mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusA
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmd
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusA
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|led_mask
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_comment
comment|/* led_control */
end_comment

begin_comment
comment|/*  *  scroll_up()... move the screen up one character height  */
end_comment

begin_expr_stmt
name|scroll_up
argument_list|(
name|adder
argument_list|)
specifier|register
expr|struct
name|adder
operator|*
name|adder
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 	* setup VIPER operand control registers   	*/
operator|(
name|void
operator|)
name|wait_status
argument_list|(
name|adder
argument_list|,
name|ADDRESS_COMPLETE
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/* select all planes */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
comment|/* 	 * load DESTINATION origin and vectors   	 */
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|NORMAL
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
literal|864
operator|-
name|CHAR_HEIGHT
expr_stmt|;
comment|/* 	 * load SOURCE origin and vectors   	 */
name|adder
operator|->
name|source_1_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_1_dx
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|source_1_y
operator|=
literal|0
operator|+
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|source_1_dy
operator|=
literal|864
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R1
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|RASTEROP
operator||
name|OCRB
operator||
literal|0
operator||
name|S1E
operator||
name|DTE
expr_stmt|;
comment|/* 	 * do a rectangle clear of last screen line  	 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SOURCE
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
operator|(
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
operator|)
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
comment|/* set up the width of	*/
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/* rectangle */
name|adder
operator|->
name|rasterop_mode
operator|=
operator|(
name|NORMAL
operator||
name|DST_WRITE_ENABLE
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|wait_status
argument_list|(
name|adder
argument_list|,
name|RASTEROP_COMPLETE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
literal|864
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
literal|1024
expr_stmt|;
comment|/* set up the height	*/
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
comment|/* of rectangle 	*/
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R2
argument_list|,
operator|(
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
operator|)
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
operator|(
name|RASTEROP
operator||
name|OCRB
operator||
name|LF_R2
operator||
name|DTE
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* scroll_up */
end_comment

begin_comment
comment|/*  *  init shared memory pointers and structures  */
end_comment

begin_expr_stmt
name|init_shared
argument_list|(
name|unit
argument_list|)
specifier|register
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
comment|/* 	* initialize the event queue pointers and header */
name|eq_header
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|qdinput
operator|*
operator|)
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
name|event_shared
operator|&
operator|~
operator|(
literal|0x01FF
operator|)
operator|)
operator|+
literal|512
operator|)
operator|+
operator|(
name|EVENT_BUFSIZE
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|x
argument_list|)
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|y
argument_list|)
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_box
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_box
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_box
operator|.
name|top
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_box
operator|.
name|bottom
operator|=
literal|0
expr_stmt|;
comment|/* 	 * assign a pointer to the DMA I/O buffer for this QDSS.  	 */
name|DMAheader
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|DMAreq_header
operator|*
operator|)
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|&
name|DMA_shared
index|[
literal|0
index|]
operator|+
literal|512
argument_list|)
operator|&
operator|~
literal|0x1FF
operator|)
operator|+
operator|(
name|DMAbuf_size
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|DMAreq
operator|=
operator|(
expr|struct
name|DMAreq
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|DMAheader
index|[
name|unit
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|DMAreq_header
argument_list|)
operator|)
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
operator|=
literal|0
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|shared_size
operator|=
name|DMAbuf_size
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|size
operator|=
literal|10
expr_stmt|;
comment|/* default = 10 requests */
name|DMAheader
index|[
name|unit
index|]
operator|->
name|oldest
operator|=
literal|0
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|newest
operator|=
literal|0
expr_stmt|;
comment|/* 	* assign a pointer to the scroll structure for this QDSS.  	*/
name|scroll
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|scroll
operator|*
operator|)
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|&
name|scroll_shared
index|[
literal|0
index|]
operator|+
literal|512
argument_list|)
operator|&
operator|~
literal|0x1FF
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scroll
argument_list|)
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|viper_constant
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|y_scroll_constant
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|y_offset
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|x_index_pending
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|y_index_pending
operator|=
literal|0
expr_stmt|;
comment|/* 	* assign a pointer to the color map write buffer for this QDSS  	*/
name|color_buf
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|color_buf
operator|*
operator|)
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|&
name|color_shared
index|[
literal|0
index|]
operator|+
literal|512
argument_list|)
operator|&
operator|~
literal|0x1FF
operator|)
operator|+
operator|(
name|COLOR_BUFSIZ
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
name|color_buf
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|color_buf
index|[
name|unit
index|]
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* init_shared */
end_comment

begin_comment
comment|/*  * init the ADDER, VIPER, bitmaps,& color map  */
end_comment

begin_macro
name|setup_dragon
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|short
modifier|*
name|memcsr
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|short
name|top
decl_stmt|;
comment|/* clipping/scrolling boundaries */
name|short
name|bottom
decl_stmt|;
name|short
name|right
decl_stmt|;
name|short
name|left
decl_stmt|;
name|short
modifier|*
name|red
decl_stmt|;
comment|/* color map pointers */
name|short
modifier|*
name|green
decl_stmt|;
name|short
modifier|*
name|blue
decl_stmt|;
comment|/* 	* init for setup  	*/
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|memcsr
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
operator|(
name|DMA_IE
operator||
literal|0x700
operator|)
expr_stmt|;
comment|/* halt DMA and kill the intrpts */
operator|*
name|memcsr
operator|=
name|SYNC_ON
expr_stmt|;
comment|/* blank screen and turn off LED's */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* 	* set monitor timing  	*/
name|adder
operator|->
name|x_scan_count_0
operator|=
literal|0x2800
expr_stmt|;
name|adder
operator|->
name|x_scan_count_1
operator|=
literal|0x1020
expr_stmt|;
name|adder
operator|->
name|x_scan_count_2
operator|=
literal|0x003A
expr_stmt|;
name|adder
operator|->
name|x_scan_count_3
operator|=
literal|0x38F0
expr_stmt|;
name|adder
operator|->
name|x_scan_count_4
operator|=
literal|0x6128
expr_stmt|;
name|adder
operator|->
name|x_scan_count_5
operator|=
literal|0x093A
expr_stmt|;
name|adder
operator|->
name|x_scan_count_6
operator|=
literal|0x313C
expr_stmt|;
name|adder
operator|->
name|sync_phase_adj
operator|=
literal|0x0100
expr_stmt|;
name|adder
operator|->
name|x_scan_conf
operator|=
literal|0x00C8
expr_stmt|;
comment|/* 	 * got a bug in secound pass ADDER! lets take care of it  	 * 	 * normally, just use the code in the following bug fix code, but to 	 * make repeated demos look pretty, load the registers as if there was 	 * no bug and then test to see if we are getting sync  	 */
name|adder
operator|->
name|y_scan_count_0
operator|=
literal|0x135F
expr_stmt|;
name|adder
operator|->
name|y_scan_count_1
operator|=
literal|0x3363
expr_stmt|;
name|adder
operator|->
name|y_scan_count_2
operator|=
literal|0x2366
expr_stmt|;
name|adder
operator|->
name|y_scan_count_3
operator|=
literal|0x0388
expr_stmt|;
comment|/* 	 * if no sync, do the bug fix code  	 */
if|if
condition|(
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
operator|==
name|BAD
condition|)
block|{
comment|/* first load all Y scan registers with very short frame and 		 * wait for scroll service.  This guarantees at least one SYNC 		 * to fix the pass 2 Adder initialization bug (synchronizes 		 * XCINCH with DMSEEDH)  		 */
name|adder
operator|->
name|y_scan_count_0
operator|=
literal|0x01
expr_stmt|;
name|adder
operator|->
name|y_scan_count_1
operator|=
literal|0x01
expr_stmt|;
name|adder
operator|->
name|y_scan_count_2
operator|=
literal|0x01
expr_stmt|;
name|adder
operator|->
name|y_scan_count_3
operator|=
literal|0x01
expr_stmt|;
comment|/* 		 * delay at least 1 full frame time  		 */
operator|(
name|void
operator|)
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* 		 * now load the REAL sync values (in reverse order just to 		 * be safe.   		 */
name|adder
operator|->
name|y_scan_count_3
operator|=
literal|0x0388
expr_stmt|;
name|adder
operator|->
name|y_scan_count_2
operator|=
literal|0x2366
expr_stmt|;
name|adder
operator|->
name|y_scan_count_1
operator|=
literal|0x3363
expr_stmt|;
name|adder
operator|->
name|y_scan_count_0
operator|=
literal|0x135F
expr_stmt|;
block|}
operator|*
name|memcsr
operator|=
name|SYNC_ON
operator||
name|UNBLANK
expr_stmt|;
comment|/* turn off leds and turn on video */
comment|/* 	 * zero the index registers  	 */
name|adder
operator|->
name|x_index_pending
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_index_pending
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|x_index_new
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_index_new
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|x_index_old
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_index_old
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|pause
operator|=
literal|0
expr_stmt|;
comment|/* 	 * set rasterop mode to normal pen down  	 */
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|DST_INDEX_ENABLE
operator||
name|NORMAL
expr_stmt|;
comment|/* 	 * set the rasterop registers to a default values  	 */
name|adder
operator|->
name|source_1_dx
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|source_1_dy
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|source_1_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_1_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
comment|/* 	 * scale factor = UNITY  	 */
name|adder
operator|->
name|fast_scale
operator|=
name|UNITY
expr_stmt|;
name|adder
operator|->
name|slow_scale
operator|=
name|UNITY
expr_stmt|;
comment|/* 	 * set the source 2 parameters  	 */
name|adder
operator|->
name|source_2_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_2_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_2_size
operator|=
literal|0x0022
expr_stmt|;
comment|/* 	* initialize plane addresses for eight vipers  	*/
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0002
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0002
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0010
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0020
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0040
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0006
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0080
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0007
argument_list|)
expr_stmt|;
comment|/* 	 * initialize the external registers.  	 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_SCROLL_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/* 	 * initialize resolution mode  	 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MEMORY_BUS_WIDTH
argument_list|,
literal|0x000C
argument_list|)
expr_stmt|;
comment|/* bus width = 16 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|RESOLUTION_MODE
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* one bit/pixel */
comment|/* 	 * initialize viper registers  	 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SCROLL_CONSTANT
argument_list|,
name|SCROLL_ENABLE
operator||
name|VIPER_LEFT
operator||
name|VIPER_UP
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SCROLL_FILL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* 	 * set clipping and scrolling limits to full screen  	 */
for|for
control|(
name|i
operator|=
literal|1000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
name|adder
operator|->
name|status
operator|&
name|ADDRESS_COMPLETE
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"qd%d: setup_dragon: timeout on ADDRESS_COMPLETE\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|bottom
operator|=
literal|2048
expr_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
name|right
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|x_clip_min
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|x_clip_max
operator|=
name|right
expr_stmt|;
name|adder
operator|->
name|y_clip_min
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|y_clip_max
operator|=
name|bottom
expr_stmt|;
name|adder
operator|->
name|scroll_x_min
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|scroll_x_max
operator|=
name|right
expr_stmt|;
name|adder
operator|->
name|scroll_y_min
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|scroll_y_max
operator|=
name|bottom
expr_stmt|;
operator|(
name|void
operator|)
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* wait at LEAST 1 full frame */
operator|(
name|void
operator|)
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|x_index_pending
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|y_index_pending
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|x_index_new
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|y_index_new
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|x_index_old
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|y_index_old
operator|=
name|top
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
name|adder
operator|->
name|status
operator|&
name|ADDRESS_COMPLETE
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"qd%d: setup_dragon: timeout on ADDRESS_COMPLETE\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LEFT_SCROLL_MASK
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|RIGHT_SCROLL_MASK
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* 	* set source and the mask register to all ones (ie: white) o 	*/
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SOURCE
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	* initialize Operand Control Register banks for fill command  	*/
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_A
argument_list|,
name|EXT_NONE
operator||
name|INT_M1_M2
operator||
name|NO_ID
operator||
name|WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC2_OCR_A
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_A
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|NO_ID
operator||
name|WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC2_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_M1_M2
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
comment|/* 	* init Logic Unit Function registers, (these are just common values, 	* and may be changed as required).   	*/
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R1
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R2
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
operator||
name|INV_M1_M2
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R3
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_D_OR_S
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R4
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_D_XOR_S
argument_list|)
expr_stmt|;
comment|/* 	* load the color map for black& white  	*/
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
operator|&&
operator|!
operator|(
name|adder
operator|->
name|status
operator|&
name|VSYNC
operator|)
condition|;
operator|++
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"qd%d: setup_dragon: timeout on VSYNC\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|red
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|red
expr_stmt|;
name|green
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|green
expr_stmt|;
name|blue
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|blue
expr_stmt|;
operator|*
name|red
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* black */
operator|*
name|green
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|blue
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|red
operator|--
operator|=
literal|0xFF
expr_stmt|;
comment|/* white */
operator|*
name|green
operator|--
operator|=
literal|0xFF
expr_stmt|;
operator|*
name|blue
operator|--
operator|=
literal|0xFF
expr_stmt|;
comment|/* 	* set color map for mouse cursor  	*/
name|red
operator|+=
literal|254
expr_stmt|;
name|green
operator|+=
literal|254
expr_stmt|;
name|blue
operator|+=
literal|254
expr_stmt|;
operator|*
name|red
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* black */
operator|*
name|green
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|blue
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|red
operator|=
literal|0xFF
expr_stmt|;
comment|/* white */
operator|*
name|green
operator|=
literal|0xFF
expr_stmt|;
operator|*
name|blue
operator|=
literal|0xFF
expr_stmt|;
block|}
end_block

begin_comment
comment|/* setup_dragon */
end_comment

begin_comment
comment|/*  * Init the DUART and set defaults in input  */
end_comment

begin_macro
name|setup_input
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
comment|/* DUART register structure pointer */
specifier|register
name|i
operator|,
name|bits
expr_stmt|;
name|char
name|id_byte
decl_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
name|duart
operator|->
name|imask
operator|=
literal|0
expr_stmt|;
comment|/* 	* setup the DUART for kbd& pointing device  	*/
name|duart
operator|->
name|cmdA
operator|=
name|RESET_M
expr_stmt|;
comment|/* reset mode reg ptr for kbd */
name|duart
operator|->
name|modeA
operator|=
literal|0x13
expr_stmt|;
comment|/* 8 bits, no parity, rcv IE, */
comment|/* no RTS control,char error mode */
name|duart
operator|->
name|modeA
operator|=
literal|0x07
expr_stmt|;
comment|/* 1 stop bit,CTS does not IE XMT */
comment|/* no RTS control,no echo or loop */
name|duart
operator|->
name|cmdB
operator|=
name|RESET_M
expr_stmt|;
comment|/* reset mode reg pntr for host */
name|duart
operator|->
name|modeB
operator|=
literal|0x07
expr_stmt|;
comment|/* 8 bits, odd parity, rcv IE.. */
comment|/* ..no RTS cntrl, char error mode */
name|duart
operator|->
name|modeB
operator|=
literal|0x07
expr_stmt|;
comment|/* 1 stop bit,CTS does not IE XMT */
comment|/* no RTS control,no echo or loop */
name|duart
operator|->
name|auxctl
operator|=
literal|0x00
expr_stmt|;
comment|/* baud rate set 1 */
name|duart
operator|->
name|clkselA
operator|=
literal|0x99
expr_stmt|;
comment|/* 4800 baud for kbd */
name|duart
operator|->
name|clkselB
operator|=
literal|0x99
expr_stmt|;
comment|/* 4800 baud for mouse */
comment|/* reset everything for keyboard */
for|for
control|(
name|bits
operator|=
name|RESET_M
init|;
name|bits
operator|<
name|START_BREAK
condition|;
name|bits
operator|+=
literal|0x10
control|)
name|duart
operator|->
name|cmdA
operator|=
name|bits
expr_stmt|;
comment|/* reset everything for host */
for|for
control|(
name|bits
operator|=
name|RESET_M
init|;
name|bits
operator|<
name|START_BREAK
condition|;
name|bits
operator|+=
literal|0x10
control|)
name|duart
operator|->
name|cmdB
operator|=
name|bits
expr_stmt|;
name|duart
operator|->
name|cmdA
operator|=
name|EN_RCV
operator||
name|EN_XMT
expr_stmt|;
comment|/* enbl xmt& rcv for kbd */
name|duart
operator|->
name|cmdB
operator|=
name|EN_RCV
operator||
name|EN_XMT
expr_stmt|;
comment|/* enbl xmt& rcv for pointer device */
comment|/* 	* init keyboard defaults (DUART channel A)  	*/
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusA
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|LK_DEFAULTS
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusA
operator|&
name|RCV_RDY
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|duart
operator|->
name|dataA
condition|)
comment|/* flush the ACK */
empty_stmt|;
comment|/* 	* identify the pointing device  	*/
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusB
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
name|SELF_TEST
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	* wait for 1st byte of self test report */
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusB
operator|&
name|RCV_RDY
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd[%d]: setup_input: timeout on 1st byte of self test\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|OUT
goto|;
block|}
if|if
condition|(
name|duart
operator|->
name|dataB
condition|)
empty_stmt|;
comment|/* 	* wait for ID byte of self test report	 	*/
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusB
operator|&
name|RCV_RDY
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd[%d]: setup_input: timeout on 2nd byte of self test\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|OUT
goto|;
block|}
name|id_byte
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
comment|/* 	* wait for other bytes to come in   	*/
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusB
operator|&
name|RCV_RDY
condition|)
block|{
if|if
condition|(
name|duart
operator|->
name|dataB
condition|)
empty_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd[%d]: setup_input: timeout on 3rd byte of self test\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|OUT
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusB
operator|&
name|RCV_RDY
condition|)
block|{
if|if
condition|(
name|duart
operator|->
name|dataB
condition|)
empty_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"qd[%d]: setup_input: timeout on 4th byte of self test\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|OUT
goto|;
block|}
comment|/* 	* flag pointing device type and set defaults  	*/
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
empty_stmt|;
comment|/*XXX*/
if|if
condition|(
operator|(
name|id_byte
operator|&
literal|0x0F
operator|)
operator|!=
name|TABLET_ID
condition|)
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|pntr_id
operator|=
name|MOUSE_ID
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusB
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
name|INC_STREAM_MODE
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|pntr_id
operator|=
name|TABLET_ID
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|duart
operator|->
name|statusB
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
name|T_STREAM
expr_stmt|;
break|break;
block|}
block|}
block|}
name|OUT
label|:
name|duart
operator|->
name|imask
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
expr_stmt|;
block|}
end_block

begin_comment
comment|/* setup_input */
end_comment

begin_comment
comment|/*  * delay for at least one display frame time  *  *	return: BAD means that we timed out without ever seeing the  *		      vertical sync status bit  *		GOOD otherwise  */
end_comment

begin_expr_stmt
name|wait_status
argument_list|(
name|adder
argument_list|,
name|mask
argument_list|)
specifier|register
expr|struct
name|adder
operator|*
name|adder
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|10000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
name|adder
operator|->
name|status
operator|&
name|mask
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"wait_status: timeout polling for 0x%x in adder->status\n"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|BAD
operator|)
return|;
block|}
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_comment
comment|/* wait_status */
end_comment

begin_comment
comment|/*  * write out onto the ID bus  */
end_comment

begin_expr_stmt
name|write_ID
argument_list|(
name|adder
argument_list|,
name|adrs
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|adder
operator|*
name|adder
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|short
name|adrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|100000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
name|adder
operator|->
name|status
operator|&
name|ADDRESS_COMPLETE
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|ERR
goto|;
for|for
control|(
name|i
operator|=
literal|100000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
name|adder
operator|->
name|status
operator|&
name|TX_READY
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|adder
operator|->
name|id_data
operator|=
name|data
expr_stmt|;
name|adder
operator|->
name|command
operator|=
name|ID_LOAD
operator||
name|adrs
expr_stmt|;
return|return ;
block|}
name|ERR
label|:
name|printf
argument_list|(
literal|"write_ID: timeout trying to write to VIPER\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
end_block

begin_comment
comment|/* write_ID */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

