begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1986 MICOM-Interlan, Inc., Boxborough Mass  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)np.c	7.6 (Berkeley) %G%  *  * From:  *	np.c version 1.5  *  *	This version retrieved: 8/18/86 @ 18:58:54  *	    This delta created: 8/18/86 @ 18:19:24  *  *	static		char	*SCCSID = "@(#)np.c	1.5";  *  */
end_comment

begin_comment
comment|/******************************************  		*					  *  		*		NPDRIVER		  *  		*					  *  		******************************************/
end_comment

begin_comment
comment|/*  * The NP Driver is used to route requests, independent of protocol type,  * to the NP series Intelligent Board. The facilities it provides are  * used for board maintainance by the superuser and by protocol pseudo-drivers,   * such as WN, for sending requests to a board. The board maintainance and  * control functions are accessed via npioctl() by the NP support utilities.  */
end_comment

begin_comment
comment|/*  * Modification History:  * 4/9/86 DDW Removed pseudo-driver initialization flag resets from NpReset  * 5/28/86 CJM Changed iodone() to wakeup() in NpProcQueue().  *  */
end_comment

begin_comment
comment|/*  * Include Files  */
end_comment

begin_include
include|#
directive|include
file|"np.h"
end_include

begin_if
if|#
directive|if
name|NNP
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"ubavar.h"
end_include

begin_include
include|#
directive|include
file|"signal.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/npreg.h"
end_include

begin_define
define|#
directive|define
name|b_uio
value|b_forw
end_define

begin_define
define|#
directive|define
name|b_rp
value|av_back
end_define

begin_comment
comment|/*  * Global variables for pseudo-drivers.  */
end_comment

begin_decl_stmt
name|int
name|WnInitFlag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|IsInitFlag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|IxAttach
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|IxReset
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Debugging level.  */
end_comment

begin_decl_stmt
name|int
name|NpDebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Driver Wide State used by the ICP */
end_comment

begin_decl_stmt
name|int
name|NpState
init|=
name|NPCLEAR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Master structure, one per board, contains request queue header,  * shared memory address, and memory mapping information.  */
end_comment

begin_decl_stmt
name|struct
name|npmaster
name|npmasters
index|[
name|NNP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure of the shared memory area */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|npspace
name|npspaces
index|[
name|NNP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Panic Message data structures */
end_comment

begin_decl_stmt
specifier|static
name|int
name|panicmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping information */
end_comment

begin_decl_stmt
specifier|static
name|char
name|NpPbuf
index|[
name|PANLEN
index|]
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Panic message buffer */
end_comment

begin_decl_stmt
specifier|static
name|caddr_t
name|pstring
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Panic string address on board, absolute */
end_comment

begin_decl_stmt
specifier|static
name|unsign16
name|panaddr
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Panic string address on board (seg/offset) */
end_comment

begin_comment
comment|/* Driver Wide Connection Table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|npconn
name|npcnxtab
index|[
name|NNP
index|]
index|[
name|NNPCNN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Head of the request queue, one per board */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|npreq
name|reqhdr
index|[
name|NNP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Require for diagnostic packages */
end_comment

begin_typedef
typedef|typedef
name|struct
name|npreq
modifier|*
name|reqptr
typedef|;
end_typedef

begin_decl_stmt
name|reqptr
name|np_mapreq
index|[
name|NNP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The request structures, one pool per board */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|npreq
name|npreqs
index|[
name|NNP
index|]
index|[
name|NUMCQE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data structures needed for BSD 4.2 Device Drivers  */
end_comment

begin_decl_stmt
name|int
name|npprobe
argument_list|()
decl_stmt|,
name|npattach
argument_list|()
decl_stmt|,
name|npintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|npdinfo
index|[
name|NNP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* UNIBUS address of Network Processors */
end_comment

begin_decl_stmt
name|u_short
name|npstd
index|[]
init|=
block|{
literal|0166000
block|,
literal|0166020
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interrupt vectors used by the Network Processors */
end_comment

begin_decl_stmt
specifier|static
name|unsign16
name|npvectors
index|[
name|NNP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|npdriver
init|=
block|{
name|npprobe
block|,
literal|0
block|,
name|npattach
block|,
literal|0
block|,
name|npstd
block|,
literal|"np"
block|,
name|npdinfo
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|np_tab
index|[
name|NNP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|np_icount
index|[
name|NNP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * External function and data structure declarations.  */
end_comment

begin_function_decl
name|struct
name|npreq
modifier|*
name|NpGetReq
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|npmaster
modifier|*
name|NpBoardChange
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|NpTimer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|CQE
modifier|*
name|NpRemCQE
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|user
name|u
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Np_init() is responsible for hardware initializiation and the software   * initialization of the connection table and driver software data structures.  */
end_comment

begin_macro
name|npinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
comment|/* Software Initialization */
name|npmasters
index|[
name|unit
index|]
operator|.
name|flags
operator|=
name|NPCLEAR
expr_stmt|;
name|NpSWinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* Hardware Initialization */
name|NpHWinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* Connection Table Initialization */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NNPCNN
condition|;
name|j
operator|++
control|)
block|{
name|npcnxtab
index|[
name|unit
index|]
index|[
name|j
index|]
operator|.
name|protocol
operator|=
name|NPCLCONN
expr_stmt|;
name|npcnxtab
index|[
name|unit
index|]
index|[
name|j
index|]
operator|.
name|unit
operator|=
operator|&
name|npmasters
index|[
name|unit
index|]
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Np_open establishes a connection to the NP Driver using the minor  * device number as an identifier. A default protocol, NPMAINT, is assigned  * with the specified unit. Protocol and unit may be changed using the   * NpProtChange and NpBoardChange functions.  * Since the maintainance protocol does not need a working I-Board, entries  * are always made in the Connection Table, npcnxtab, if the board exists.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|npopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
decl_stmt|;
name|unsign16
name|conn
decl_stmt|;
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npopen\n"
argument_list|)
expr_stmt|;
comment|/* Clear error */
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Make sure it's the superuser */
if|if
condition|(
name|u
operator|.
name|u_uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* Get the connection identifier */
if|if
condition|(
operator|(
operator|(
name|conn
operator|=
name|NPCONN
argument_list|(
name|dev
argument_list|)
operator|)
operator|>=
name|NNPCNN
operator|)
operator|||
operator|(
operator|(
name|unit
operator|=
name|NPUNIT
argument_list|(
name|dev
argument_list|)
operator|)
operator|>=
name|NNP
operator|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBOPEN
condition|)
name|printf
argument_list|(
literal|"conn = %x unit = %d\n"
argument_list|,
name|conn
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* Get the board for the specified unit */
name|mp
operator|=
name|NpBoardChange
argument_list|(
name|NPMAINT
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|!=
operator|(
expr|struct
name|npmaster
operator|*
operator|)
literal|0
condition|)
block|{
name|npcnxtab
index|[
name|unit
index|]
index|[
name|conn
index|]
operator|.
name|unit
operator|=
name|mp
expr_stmt|;
name|npcnxtab
index|[
name|unit
index|]
index|[
name|conn
index|]
operator|.
name|protocol
operator|=
name|NPMAINT
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npopen...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Np_close is responsible updating the connection table for  * that connection by marking it closed.  */
end_comment

begin_macro
name|npclose
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npclose\n"
argument_list|)
expr_stmt|;
comment|/* Get the connection identifier */
name|npcnxtab
index|[
name|NPUNIT
argument_list|(
name|dev
argument_list|)
index|]
index|[
name|NPCONN
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|protocol
operator|=
name|NPCLCONN
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npclose...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Npioctl is the main conduit of commands between the I-Board and the  * NP support utilities. Relevant information for the request is found in the  * cmd and addr parameters. Cmd specifies the function to perform, addr is   * command specific. Npioctl returns 0 if successful, or an error number  * (which winds up in errno).  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|npioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|addr
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsign16
name|protocol
decl_stmt|;
name|unsign16
name|conn
decl_stmt|;
name|unsign16
name|unit
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|register
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|npreq
modifier|*
name|rp
decl_stmt|;
name|unsigned
name|usrarg
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npioctl\n"
argument_list|)
expr_stmt|;
comment|/* Clear error */
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Strip off IOC_VOID bit */
name|cmd
operator|&=
name|CMDMASK
expr_stmt|;
comment|/* Get connection identifier */
name|conn
operator|=
name|NPCONN
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|NPUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Master pointer for this unit */
name|mp
operator|=
name|npcnxtab
index|[
name|unit
index|]
index|[
name|conn
index|]
operator|.
name|unit
expr_stmt|;
name|protocol
operator|=
name|npcnxtab
index|[
name|unit
index|]
index|[
name|conn
index|]
operator|.
name|protocol
expr_stmt|;
comment|/* Get a request structure from the pool and initialize it */
while|while
condition|(
operator|(
name|rp
operator|=
name|NpGetReq
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|reqtab
operator|->
name|flags
operator||=
name|WANTREQ
expr_stmt|;
name|sleep
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|)
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NpDebug
operator|&
name|DEBREQ
condition|)
name|printf
argument_list|(
literal|"NP Reqp is %x\n"
argument_list|,
name|rp
argument_list|)
expr_stmt|;
comment|/* Initializations of request structure */
name|rp
operator|->
name|intr
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
expr_stmt|;
comment|/* Do not call interrupt routine */
name|rp
operator|->
name|bufoffset
operator|=
literal|0
expr_stmt|;
comment|/* Offset into data buffer */
name|rp
operator|->
name|procp
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
comment|/* Process structure for this user */
comment|/* Copy in user's argument to ioctl() call */
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
operator|*
name|addr
argument_list|,
operator|&
name|usrarg
argument_list|,
sizeof|sizeof
argument_list|(
name|usrarg
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBIOCTL
condition|)
name|printf
argument_list|(
literal|"arg = %x\n"
argument_list|,
name|usrarg
argument_list|)
expr_stmt|;
comment|/* Execute the specified command */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NPSETPROT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|NpProtChange
argument_list|(
name|usrarg
argument_list|,
name|mp
operator|->
name|unit
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|npcnxtab
index|[
name|unit
index|]
index|[
name|conn
index|]
operator|.
name|protocol
operator|=
name|usrarg
expr_stmt|;
break|break;
case|case
name|NPSETBOARD
case|:
if|if
condition|(
name|mp
operator|=
name|NpBoardChange
argument_list|(
name|protocol
argument_list|,
name|usrarg
argument_list|)
condition|)
name|npcnxtab
index|[
name|unit
index|]
index|[
name|conn
index|]
operator|.
name|unit
operator|=
name|mp
expr_stmt|;
else|else
block|{
name|mp
operator|=
name|npcnxtab
index|[
name|unit
index|]
index|[
name|conn
index|]
operator|.
name|unit
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
break|break;
case|case
name|NPRESET
case|:
name|error
operator|=
name|NpReset
argument_list|(
name|mp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPSETNPDEB
case|:
name|NpDebug
operator|=
name|usrarg
expr_stmt|;
break|break;
case|case
name|NPINIT
case|:
name|error
operator|=
name|NpSWinit
argument_list|(
name|mp
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPSTART
case|:
ifdef|#
directive|ifdef
name|OLDROM
comment|/* 		 * Kludge to work around I-Board boot from Host. Read two bytes 		 * from the board into the Device Configuration Word 		 * in Shared Memory. 		 */
name|NPIO
argument_list|(
name|mp
argument_list|,
operator|(
name|paddr_t
operator|)
literal|0x500
argument_list|,
call|(
name|paddr_t
call|)
argument_list|(
operator|&
name|mp
operator|->
name|shmemp
operator|->
name|statblock
operator|.
name|sb_dcw
argument_list|)
argument_list|,
literal|2
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
name|mp
operator|->
name|shmemp
operator|->
name|statblock
operator|.
name|sb_drw
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Set the Address at which to begin On-Board execution */
name|error
operator|=
name|NpSetXeqAddr
argument_list|(
name|mp
argument_list|,
operator|(
name|caddr_t
operator|)
name|usrarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPSTATS
case|:
name|error
operator|=
name|NpStats
argument_list|()
expr_stmt|;
break|break;
case|case
name|NPGPANIC
case|:
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|NpPbuf
argument_list|,
operator|*
name|addr
argument_list|,
name|PANLEN
argument_list|)
expr_stmt|;
comment|/* Clear panic request flag and leave */
name|mp
operator|->
name|flags
operator|&=
operator|~
name|PANICREQ
expr_stmt|;
break|break;
case|case
name|NPPOLL
case|:
name|error
operator|=
name|NpPoll
argument_list|(
name|mp
argument_list|,
operator|*
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPKILL
case|:
name|error
operator|=
name|NpKill
argument_list|(
name|mp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPSETADDR
case|:
name|error
operator|=
name|NpSetMemAddr
argument_list|(
name|mp
argument_list|,
operator|*
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPRCSR0
case|:
name|usrarg
operator|=
name|RCSR0
argument_list|(
name|mp
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|usrarg
argument_list|,
operator|*
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|usrarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPRCSR1
case|:
name|usrarg
operator|=
name|RCSR1
argument_list|(
name|mp
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|usrarg
argument_list|,
operator|*
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|usrarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPRCSR2
case|:
name|usrarg
operator|=
name|RCSR2
argument_list|(
name|mp
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|usrarg
argument_list|,
operator|*
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|usrarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPRCSR3
case|:
name|usrarg
operator|=
name|RCSR3
argument_list|(
name|mp
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|usrarg
argument_list|,
operator|*
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|usrarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPWCSR0
case|:
name|WCSR0
argument_list|(
name|mp
operator|->
name|iobase
argument_list|,
name|usrarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPWCSR1
case|:
name|WCSR1
argument_list|(
name|mp
operator|->
name|iobase
argument_list|,
name|usrarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPWCSR2
case|:
name|WCSR2
argument_list|(
name|mp
operator|->
name|iobase
argument_list|,
name|usrarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPWCSR3
case|:
name|WCSR3
argument_list|(
name|mp
operator|->
name|iobase
argument_list|,
name|usrarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPNETBOOT
case|:
name|error
operator|=
name|NpSetIntLevel
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|NpSetXeqAddr
argument_list|(
name|mp
argument_list|,
operator|(
name|caddr_t
operator|)
name|INETBOOT
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPSETLAST
case|:
if|if
condition|(
name|usrarg
condition|)
name|mp
operator|->
name|flags
operator|&=
operator|~
name|LSTCMD
expr_stmt|;
else|else
name|mp
operator|->
name|flags
operator||=
name|LSTCMD
expr_stmt|;
break|break;
case|case
name|NPCLRICNT
case|:
name|np_icount
index|[
name|unit
index|]
operator|=
name|NPCLEAR
expr_stmt|;
break|break;
case|case
name|NPGETICNT
case|:
name|usrarg
operator|=
name|np_icount
index|[
name|unit
index|]
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|usrarg
argument_list|,
operator|*
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|usrarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPGETIVEC
case|:
name|usrarg
operator|=
name|mp
operator|->
name|vector
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|usrarg
argument_list|,
operator|*
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|usrarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPMAPMEM
case|:
name|error
operator|=
name|NpMem
argument_list|(
name|mp
argument_list|,
name|rp
argument_list|,
operator|*
name|addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Bad Maintenance command: %d!\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|cmd
operator|!=
name|NPRESET
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|NPINIT
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|NPMAPMEM
operator|)
condition|)
name|NpFreeReq
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npioctl...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * np_start - start io activity  */
end_comment

begin_expr_stmt
name|npstart
argument_list|(
name|mp
argument_list|)
specifier|register
expr|struct
name|npmaster
operator|*
name|mp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|npreq
modifier|*
name|rp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Return from NPIO call */
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npstart\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|np_tab
index|[
name|mp
operator|->
name|unit
index|]
operator|.
name|b_actf
operator|)
operator|==
operator|(
expr|struct
name|buf
operator|*
operator|)
literal|0
condition|)
block|{
name|np_tab
index|[
name|mp
operator|->
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|rp
operator|=
operator|(
expr|struct
name|npreq
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_rp
operator|)
operator|)
operator|==
operator|(
expr|struct
name|npreq
operator|*
operator|)
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|uio
operator|=
operator|(
expr|struct
name|uio
operator|*
operator|)
name|bp
operator|->
name|b_uio
operator|)
operator|==
operator|(
expr|struct
name|uio
operator|*
operator|)
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|np_tab
index|[
name|mp
operator|->
name|unit
index|]
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBIO
condition|)
name|printf
argument_list|(
literal|"NP IO src %x dst = %x cnt = %x\n"
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
comment|/* Send the request to the board via the CSR0 command interface */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|error
operator|=
name|NPIO
argument_list|(
name|mp
argument_list|,
operator|(
name|paddr_t
operator|)
name|uio
operator|->
name|uio_offset
argument_list|,
operator|(
name|paddr_t
operator|)
name|rp
operator|->
name|bufaddr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|NPIO
argument_list|(
name|mp
argument_list|,
operator|(
name|paddr_t
operator|)
name|rp
operator|->
name|bufaddr
argument_list|,
operator|(
name|paddr_t
operator|)
name|uio
operator|->
name|uio_offset
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
argument_list|)
expr_stmt|;
comment|/* Check return from I/O */
if|if
condition|(
name|error
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|np_tab
index|[
name|mp
operator|->
name|unit
index|]
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBIO
condition|)
name|printf
argument_list|(
literal|"NPIO return error: b_flags is %x \n"
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|)
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npstart...\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * npstrategy - the strategy routine  */
end_comment

begin_expr_stmt
name|npstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|ip
decl_stmt|;
comment|/* quick pointer */
specifier|register
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
comment|/* master structure for this device */
specifier|register
name|struct
name|npreq
modifier|*
name|rp
decl_stmt|;
comment|/* reqest struct pointer */
name|int
name|s
decl_stmt|;
comment|/* priority to return to */
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npstrategy\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBIO
condition|)
name|printf
argument_list|(
literal|"flag = %x count = %x paddr = %x %x blkno = %x %x\n"
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
comment|/* get master structure */
name|mp
operator|=
name|npcnxtab
index|[
name|NPUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
index|[
name|NPCONN
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|unit
expr_stmt|;
comment|/* make sure the boards ok */
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|BADBOARD
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBMEM
condition|)
name|printf
argument_list|(
literal|"Bad Board %x bp %x\n"
argument_list|,
name|mp
operator|->
name|flags
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|)
expr_stmt|;
name|np_tab
index|[
name|mp
operator|->
name|unit
index|]
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Initializations of request structure */
while|while
condition|(
operator|(
name|rp
operator|=
name|NpGetReq
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|reqtab
operator|->
name|flags
operator||=
name|WANTREQ
expr_stmt|;
name|sleep
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|)
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|rp
operator|->
name|bufoffset
operator|=
literal|0
expr_stmt|;
comment|/* This is the start of the buffer */
name|ip
operator|=
operator|&
name|np_tab
index|[
name|mp
operator|->
name|unit
index|]
expr_stmt|;
name|bp
operator|->
name|b_rp
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|rp
expr_stmt|;
name|rp
operator|->
name|flags
operator||=
name|KERNREQ
expr_stmt|;
comment|/* Mark it as kernel so not to map */
name|rp
operator|->
name|mapbase
operator|=
name|ubasetup
argument_list|(
name|mp
operator|->
name|devp
operator|->
name|ui_ubanum
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rp
operator|->
name|bufaddr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|rp
operator|->
name|mapbase
argument_list|)
operator|&
name|UBADDRMASK
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|b_actf
operator|==
operator|(
expr|struct
name|buf
operator|*
operator|)
literal|0
condition|)
name|ip
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ip
operator|->
name|b_actf
operator|->
name|av_forw
condition|)
name|printf
argument_list|(
literal|"Panic NP100 bad buffer chain\n"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|b_actf
operator|->
name|av_forw
operator|=
name|bp
expr_stmt|;
block|}
name|ip
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
name|NpAddReq
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|,
name|rp
argument_list|)
expr_stmt|;
comment|/* Queue onto active list */
if|if
condition|(
name|ip
operator|->
name|b_active
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|NpDebug
operator|&
name|DEBIO
condition|)
name|printf
argument_list|(
literal|"calling npstart %x\n"
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|npstart
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBIO
condition|)
name|printf
argument_list|(
literal|"back from npstart\n"
argument_list|)
expr_stmt|;
comment|/* Await completion of I/O */
name|iowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBIO
condition|)
name|printf
argument_list|(
literal|"after iowait in npstrategy\n"
argument_list|)
expr_stmt|;
comment|/* Remove request from queue */
name|NpRemReq
argument_list|(
name|rp
argument_list|)
expr_stmt|;
comment|/* Release mapping registers */
name|ubarelse
argument_list|(
name|mp
operator|->
name|devp
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|rp
operator|->
name|mapbase
argument_list|)
expr_stmt|;
comment|/* Free up request structure */
name|NpFreeReq
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"Leaving npstrategy flags is %x\n"
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|unsigned
name|nptrim
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|NPMAXXFR
condition|)
name|bp
operator|->
name|b_bcount
operator|=
name|NPMAXXFR
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Npread dumps data from the board to the user's buffer  */
end_comment

begin_macro
name|npread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
operator|&
name|npcnxtab
index|[
name|NPUNIT
argument_list|(
name|dev
argument_list|)
index|]
index|[
name|NPCONN
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|np_rbuf
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"in npread\n"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_uio
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|uio
expr_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|npstrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|nptrim
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Npwrite loads the np100 board from the user's buffer  */
end_comment

begin_macro
name|npwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
operator|&
name|npcnxtab
index|[
name|NPUNIT
argument_list|(
name|dev
argument_list|)
index|]
index|[
name|NPCONN
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|np_wbuf
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"in npwrite \n"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_uio
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|uio
expr_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|npstrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|nptrim
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * npreset - called as result of a UNIBUS reset.  */
end_comment

begin_macro
name|npreset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|npreq
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npreset(ubareset)\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NNP
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ui
operator|=
name|npdinfo
index|[
name|i
index|]
operator|)
operator|==
operator|(
expr|struct
name|uba_device
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|ui
operator|->
name|ui_ubanum
operator|!=
name|uban
operator|)
condition|)
continue|continue;
name|mp
operator|=
operator|&
name|npmasters
index|[
name|i
index|]
expr_stmt|;
comment|/* Get a Request structure */
while|while
condition|(
operator|(
name|rp
operator|=
name|NpGetReq
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|reqtab
operator|->
name|flags
operator||=
name|WANTREQ
expr_stmt|;
name|sleep
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|)
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|NpReset
argument_list|(
name|mp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npreset(ubareset)...\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Nppoll looks for work by polling each board. He goes to sleep if there are  * no outstanding requests for him but reminds the board that he's there when  * needed.  */
end_comment

begin_macro
name|NpPoll
argument_list|(
argument|mp
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
struct|struct
block|{
name|unsign16
name|request
decl_stmt|;
name|unsign16
name|unit
decl_stmt|;
block|}
name|icpreq
struct|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBMAINT
condition|)
name|printf
argument_list|(
literal|"NpPoll: flags is %x.\n"
argument_list|,
name|mp
operator|->
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
for|for
control|(
name|mp
operator|=
name|npmasters
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|BOARDREQ
condition|)
block|{
comment|/* Get request type from master structure */
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|BRDRESET
condition|)
block|{
name|icpreq
operator|.
name|request
operator|=
name|ICPPOLL
expr_stmt|;
name|mp
operator|->
name|reqtab
operator|->
name|reqcnt
operator|--
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBMAINT
condition|)
name|printf
argument_list|(
literal|"Waking NpResetter!\n"
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
operator|&
name|mp
operator|->
name|reqtab
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|PANICREQ
condition|)
name|icpreq
operator|.
name|request
operator|=
name|ICPPANIC
expr_stmt|;
elseif|else
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|DUMPREQ
condition|)
name|icpreq
operator|.
name|request
operator|=
name|ICPDUMP
expr_stmt|;
elseif|else
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|LOADREQ
condition|)
name|icpreq
operator|.
name|request
operator|=
name|ICPLOAD
expr_stmt|;
else|else
block|{
name|mp
operator|->
name|flags
operator|&=
operator|~
name|BOARDREQ
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|NpDebug
operator|&
name|DEBMAINT
condition|)
name|printf
argument_list|(
literal|"ProcICP servicing %d \n"
argument_list|,
name|icpreq
operator|.
name|request
argument_list|)
expr_stmt|;
comment|/* Request and unit number to be sent */
name|icpreq
operator|.
name|unit
operator|=
name|mp
operator|->
name|unit
expr_stmt|;
comment|/* Copy service request to calling process */
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|icpreq
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|icpreq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark Poller as being unavailable */
name|NpState
operator|&=
operator|~
name|ICPAVAIL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Mark Poller as being available */
name|NpState
operator||=
name|ICPAVAIL
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|NpState
argument_list|,
operator|(
name|PZERO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
name|devio
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBMAINT
condition|)
name|printf
argument_list|(
literal|"wakeup in NpPoll\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Software initialization of Driver data structures for the specified unit.  */
end_comment

begin_macro
name|NpSWinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|npspace
modifier|*
name|npsp
decl_stmt|;
specifier|register
name|struct
name|CmdQue
modifier|*
name|cqp
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBINIT
condition|)
name|printf
argument_list|(
literal|"SW reset on unit %d.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|np_icount
index|[
name|unit
index|]
operator|=
name|NPCLEAR
expr_stmt|;
name|np_mapreq
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|npreq
operator|*
operator|)
name|NPCLEAR
expr_stmt|;
comment|/* Initialize master structure pointer for this unit */
name|mp
operator|=
operator|&
name|npmasters
index|[
name|unit
index|]
expr_stmt|;
comment|/* Initialize unit buffer headers */
name|np_tab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|np_tab
index|[
name|unit
index|]
operator|.
name|b_actf
operator|=
literal|0
expr_stmt|;
comment|/* UBA device structure for this unit */
name|mp
operator|->
name|devp
operator|=
name|npdinfo
index|[
name|unit
index|]
expr_stmt|;
comment|/* Interrupt vector for this unit */
name|mp
operator|->
name|vector
operator|=
name|npvectors
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|unit
operator|==
operator|(
name|NNP
operator|-
literal|1
operator|)
condition|)
name|mp
operator|->
name|next
operator|=
operator|(
expr|struct
name|npmaster
operator|*
operator|)
name|NULL
expr_stmt|;
else|else
name|mp
operator|->
name|next
operator|=
operator|&
name|npmasters
index|[
name|unit
operator|+
literal|1
index|]
expr_stmt|;
comment|/* 	 * Guarantee alignment of shared memory area on a          * 16 byte boundary as required by I-Board 	 */
name|mp
operator|->
name|shmemp
operator|=
operator|&
name|npspaces
index|[
name|unit
index|]
expr_stmt|;
name|mp
operator|->
name|shmemp
operator|=
operator|(
expr|struct
name|npspace
operator|*
operator|)
name|ROUND16
argument_list|(
call|(
name|int
call|)
argument_list|(
name|mp
operator|->
name|shmemp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Base address of this controller */
name|mp
operator|->
name|iobase
operator|=
operator|(
expr|struct
name|NPREG
operator|*
operator|)
operator|(
name|mp
operator|->
name|devp
operator|->
name|ui_addr
operator|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBMEM
condition|)
block|{
name|printf
argument_list|(
literal|"Npspaces starts at %x.\n"
argument_list|,
name|npspaces
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Shared memory starts at %x.\n"
argument_list|,
name|mp
operator|->
name|shmemp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"End of shared memory is %x.\n"
argument_list|,
operator|&
name|npspaces
index|[
name|unit
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Iobase is %x.\n"
argument_list|,
name|mp
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Npmasters start at %x\n"
argument_list|,
name|npmasters
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Reqhdr start at %x\n"
argument_list|,
name|reqhdr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Npreqs start at %x\n"
argument_list|,
name|npreqs
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the request header */
name|mp
operator|->
name|reqtab
operator|=
operator|&
name|reqhdr
index|[
name|unit
index|]
expr_stmt|;
comment|/* Unit initialization */
name|mp
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
comment|/* Initialize Status Block */
name|npsp
operator|=
name|mp
operator|->
name|shmemp
expr_stmt|;
name|offset
operator|=
call|(
name|int
call|)
argument_list|(
name|mp
operator|->
name|shmemp
argument_list|)
expr_stmt|;
name|npsp
operator|->
name|statblock
operator|.
name|sb_drw
operator|=
literal|0
expr_stmt|;
name|npsp
operator|->
name|statblock
operator|.
name|sb_hcw
operator|=
name|HOSTCONF
expr_stmt|;
name|npsp
operator|->
name|statblock
operator|.
name|sb_dcw
operator|=
literal|0
expr_stmt|;
name|npsp
operator|->
name|statblock
operator|.
name|sb_dpm
operator|=
literal|0
expr_stmt|;
name|npsp
operator|->
name|statblock
operator|.
name|sb_dcq
operator|=
call|(
name|unsign16
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|&
name|npsp
operator|->
name|devcq
argument_list|)
argument_list|)
operator|-
name|offset
expr_stmt|;
name|npsp
operator|->
name|statblock
operator|.
name|sb_hcq
operator|=
call|(
name|unsign16
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|&
name|npsp
operator|->
name|hostcq
argument_list|)
argument_list|)
operator|-
name|offset
expr_stmt|;
comment|/* Initialize Device Command Queue */
name|cqp
operator|=
operator|(
expr|struct
name|CmdQue
operator|*
operator|)
operator|&
name|npsp
operator|->
name|devcq
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBCQ
condition|)
name|printf
argument_list|(
literal|"Device CQ at %x\n"
argument_list|,
name|cqp
argument_list|)
expr_stmt|;
name|cqp
operator|->
name|scanflag
operator|=
name|NPCLEAR
expr_stmt|;
name|cqp
operator|->
name|chngflag
operator|=
name|NPCLEAR
expr_stmt|;
name|cqp
operator|->
name|cq_add
operator|=
call|(
name|unsign16
call|)
argument_list|(
name|int
argument_list|)
argument_list|(
operator|&
name|cqp
operator|->
name|cq_cqe
index|[
literal|0
index|]
argument_list|)
operator|-
name|offset
expr_stmt|;
name|cqp
operator|->
name|cq_rem
operator|=
name|cqp
operator|->
name|cq_add
expr_stmt|;
name|cqp
operator|->
name|cq_wrap
operator|=
call|(
name|unsign16
call|)
argument_list|(
name|int
argument_list|)
argument_list|(
operator|&
name|cqp
operator|->
name|cq_cqe
index|[
name|NUMCQE
index|]
argument_list|)
operator|-
name|offset
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUMCQE
condition|;
name|j
operator|++
control|)
name|cqp
operator|->
name|cq_cqe
index|[
name|j
index|]
operator|=
operator|(
name|unsign16
operator|)
name|NULL
expr_stmt|;
comment|/* Initialize Host Command Queue */
name|cqp
operator|=
operator|(
expr|struct
name|CmdQue
operator|*
operator|)
operator|&
name|npsp
operator|->
name|hostcq
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBCQ
condition|)
name|printf
argument_list|(
literal|"HOST CQ at %x\n"
argument_list|,
name|cqp
argument_list|)
expr_stmt|;
name|cqp
operator|->
name|scanflag
operator|=
name|NPCLEAR
expr_stmt|;
name|cqp
operator|->
name|chngflag
operator|=
name|NPCLEAR
expr_stmt|;
name|cqp
operator|->
name|cq_add
operator|=
call|(
name|unsign16
call|)
argument_list|(
name|int
argument_list|)
argument_list|(
operator|&
name|cqp
operator|->
name|cq_cqe
index|[
literal|0
index|]
argument_list|)
operator|-
name|offset
expr_stmt|;
name|cqp
operator|->
name|cq_rem
operator|=
name|cqp
operator|->
name|cq_add
expr_stmt|;
name|cqp
operator|->
name|cq_wrap
operator|=
call|(
name|unsign16
call|)
argument_list|(
name|int
argument_list|)
argument_list|(
operator|&
name|cqp
operator|->
name|cq_cqe
index|[
name|NUMCQE
index|]
argument_list|)
operator|-
name|offset
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUMCQE
condition|;
name|j
operator|++
control|)
name|cqp
operator|->
name|cq_cqe
index|[
name|j
index|]
operator|=
operator|(
name|unsign16
operator|)
name|NULL
expr_stmt|;
comment|/* 	 * Initialize the reqid of the elements to the address 	 * of the corresponding Npreq structure. These don't change.  	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUMCQE
condition|;
name|j
operator|++
control|)
name|npsp
operator|->
name|elements
index|[
name|j
index|]
operator|.
name|cqe_reqid
operator|=
operator|&
name|npreqs
index|[
name|unit
index|]
index|[
name|j
index|]
expr_stmt|;
comment|/* 	 * Initialize the Request Header (reqhdr), free list of  	 * npreqs, and pointers to CQEs.  	 */
name|reqhdr
index|[
name|unit
index|]
operator|.
name|forw
operator|=
name|reqhdr
index|[
name|unit
index|]
operator|.
name|back
operator|=
operator|&
name|reqhdr
index|[
name|unit
index|]
expr_stmt|;
name|reqhdr
index|[
name|unit
index|]
operator|.
name|free
operator|=
operator|&
name|npreqs
index|[
name|unit
index|]
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUMCQE
condition|;
name|j
operator|++
control|)
block|{
name|npreqs
index|[
name|unit
index|]
index|[
name|j
index|]
operator|.
name|free
operator|=
operator|&
name|npreqs
index|[
name|unit
index|]
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|npreqs
index|[
name|unit
index|]
index|[
name|j
index|]
operator|.
name|element
operator|=
operator|&
name|npsp
operator|->
name|elements
index|[
name|j
index|]
expr_stmt|;
name|npreqs
index|[
name|unit
index|]
index|[
name|j
index|]
operator|.
name|forw
operator|=
name|npreqs
index|[
name|unit
index|]
index|[
name|j
index|]
operator|.
name|back
operator|=
operator|(
expr|struct
name|npreq
operator|*
operator|)
name|NULL
expr_stmt|;
name|npreqs
index|[
name|unit
index|]
index|[
name|j
index|]
operator|.
name|flags
operator|=
name|NPCLEAR
expr_stmt|;
block|}
name|npreqs
index|[
name|unit
index|]
index|[
operator|--
name|j
index|]
operator|.
name|free
operator|=
operator|&
name|reqhdr
index|[
name|unit
index|]
expr_stmt|;
comment|/* 	 * Set up the UNIBUS I/O Map Registers for the 	 * Shared memory area.  	 */
name|mp
operator|->
name|iomapbase
operator|=
name|uballoc
argument_list|(
name|mp
operator|->
name|devp
operator|->
name|ui_ubanum
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|mp
operator|->
name|shmemp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|npspace
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"SW_Init...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * NpHWinit() issues a hardware reset to the specified board and waits  * for on-board diagnostics to complete. It returns 0 if the board is  * present and passed diagnostics, an error value otherwise.  */
end_comment

begin_macro
name|NpHWinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
name|struct
name|NPREG
modifier|*
name|REG
decl_stmt|;
name|unsign16
name|status
decl_stmt|;
name|int
name|dflag
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NNP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mp
operator|=
operator|&
name|npmasters
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpHWinit\n"
argument_list|)
expr_stmt|;
comment|/* See if the board is out there */
name|REG
operator|=
operator|(
expr|struct
name|NPREG
operator|*
operator|)
name|mp
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBINIT
condition|)
name|printf
argument_list|(
literal|"REG in HWinit is %x.\n"
argument_list|,
name|mp
operator|->
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|flags
operator|&
name|BRDRESET
operator|)
condition|)
if|if
condition|(
name|badaddr
argument_list|(
name|REG
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|mp
operator|->
name|flags
operator||=
name|BADBOARD
expr_stmt|;
name|printf
argument_list|(
literal|"\nNP100 unit %d not found!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|mc500
if|if
condition|(
name|setjmp
argument_list|(
name|u
operator|.
name|u_tsav
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u
operator|.
name|u_nofault
operator|=
name|TRUE
expr_stmt|;
name|status
operator|=
name|RCSR1
argument_list|(
name|mp
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_nofault
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|np__addr
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|flags
operator||=
name|BADBOARD
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|ENXIO
expr_stmt|;
name|printf
argument_list|(
literal|"\nNP100 Unit %x not here!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"Resetting the NP100 Board at %x\n"
argument_list|,
name|mp
operator|->
name|iobase
argument_list|)
expr_stmt|;
comment|/* Reset the Board */
name|RESET
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|dflag
operator|=
name|NPCLEAR
expr_stmt|;
name|timeout
argument_list|(
name|NpTimer
argument_list|,
operator|&
name|dflag
argument_list|,
name|DIAGTIME
argument_list|)
expr_stmt|;
comment|/* Wait for Enable and Read Data Ready to go high */
while|while
condition|(
operator|!
operator|(
operator|(
name|RCSR1
argument_list|(
name|mp
operator|->
name|iobase
argument_list|)
operator|&
name|NPENB
operator|)
operator|&&
operator|(
name|RCSR1
argument_list|(
name|mp
operator|->
name|iobase
argument_list|)
operator|&
name|NPRDR
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|dflag
condition|)
break|break;
block|}
name|untimeout
argument_list|(
name|NpTimer
argument_list|,
operator|&
name|dflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBINIT
condition|)
name|printf
argument_list|(
literal|"np reset %d \n"
argument_list|,
name|dflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
block|{
name|mp
operator|->
name|flags
operator||=
name|BADBOARD
expr_stmt|;
name|printf
argument_list|(
literal|"NP100 Unit %d timed out!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|status
operator|=
name|RCSR0
argument_list|(
name|mp
operator|->
name|iobase
argument_list|)
expr_stmt|;
comment|/* Check for Hardware OK */
if|if
condition|(
operator|!
operator|(
name|RCSR1
argument_list|(
name|mp
operator|->
name|iobase
argument_list|)
operator|&
name|NPHOK
operator|)
condition|)
block|{
name|mp
operator|->
name|flags
operator||=
name|BADBOARD
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|EIO
expr_stmt|;
name|printf
argument_list|(
literal|"NP100 Unit %d Failed diagnostics!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Status from CSR0: %x.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"HWinit...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * NP Driver Interrupt Handler  */
end_comment

begin_macro
name|npintr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npintr on unit %d!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|mp
operator|=
operator|&
name|npmasters
index|[
name|unit
index|]
expr_stmt|;
name|np_icount
index|[
name|unit
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBINTR
condition|)
name|printf
argument_list|(
literal|"npintr mp->flags = %x  interupt count = %x\n"
argument_list|,
name|mp
operator|->
name|flags
argument_list|,
name|np_icount
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
comment|/* Wake up anyone sleeping on a CSR0 Command */
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|CSRPEND
condition|)
block|{
name|mp
operator|->
name|flags
operator|&=
operator|~
name|CSRPEND
expr_stmt|;
if|if
condition|(
name|np_tab
index|[
name|mp
operator|->
name|unit
index|]
operator|.
name|b_active
condition|)
block|{
name|np_tab
index|[
name|mp
operator|->
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|np_tab
index|[
name|mp
operator|->
name|unit
index|]
operator|.
name|b_actf
expr_stmt|;
name|np_tab
index|[
name|mp
operator|->
name|unit
index|]
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBINTR
condition|)
name|printf
argument_list|(
literal|"bp = %x resid = %d forw = %x\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|b_resid
argument_list|,
name|bp
operator|->
name|av_forw
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|PANIC3
condition|)
block|{
name|mp
operator|->
name|flags
operator|&=
operator|~
name|PANIC3
expr_stmt|;
name|mp
operator|->
name|flags
operator|=
name|AVAILABLE
expr_stmt|;
name|ubarelse
argument_list|(
name|mp
operator|->
name|devp
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|panicmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|PANIC2
condition|)
block|{
name|mp
operator|->
name|flags
operator|&=
operator|~
name|PANIC2
expr_stmt|;
name|printf
argument_list|(
literal|"Panic Message: %s"
argument_list|,
name|NpPbuf
argument_list|)
expr_stmt|;
name|mp
operator|->
name|flags
operator||=
name|PANIC3
expr_stmt|;
name|NpPbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|NPIO
argument_list|(
name|mp
argument_list|,
call|(
name|paddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|panicmap
operator|&
name|UBADDRMASK
argument_list|)
argument_list|,
operator|(
name|paddr_t
operator|)
name|pstring
argument_list|,
sizeof|sizeof
argument_list|(
name|NpPbuf
argument_list|)
argument_list|,
name|B_WRITE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|PANIC1
condition|)
block|{
name|mp
operator|->
name|flags
operator|&=
operator|~
name|PANIC1
expr_stmt|;
name|mp
operator|->
name|flags
operator||=
name|PANIC2
expr_stmt|;
name|ubarelse
argument_list|(
name|mp
operator|->
name|devp
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|panicmap
argument_list|)
expr_stmt|;
name|panicmap
operator|=
name|uballoc
argument_list|(
name|mp
operator|->
name|devp
operator|->
name|ui_ubanum
argument_list|,
operator|(
name|caddr_t
operator|)
name|NpPbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|NpPbuf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pstring
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|panaddr
index|[
literal|1
index|]
operator|<<
literal|4
operator|)
operator|+
name|panaddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|NPIO
argument_list|(
name|mp
argument_list|,
operator|(
name|paddr_t
operator|)
name|pstring
argument_list|,
call|(
name|paddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|panicmap
operator|&
name|UBADDRMASK
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|NpPbuf
argument_list|)
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Mark unit as being available if Device Protocol Mask set */
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|flags
operator|&
name|AVAILABLE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|mp
operator|->
name|shmemp
operator|->
name|statblock
operator|.
name|sb_dpm
operator|)
operator|&&
operator|(
operator|!
operator|(
name|mp
operator|->
name|flags
operator|&
name|BRDRESET
operator|)
operator|)
condition|)
block|{
name|mp
operator|->
name|flags
operator|=
name|AVAILABLE
expr_stmt|;
name|printf
argument_list|(
literal|"\nNP100 unit #%d available!\n"
argument_list|,
name|mp
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Honor service requests from the device */
switch|switch
condition|(
name|mp
operator|->
name|shmemp
operator|->
name|statblock
operator|.
name|sb_drw
condition|)
block|{
case|case
name|NOREQ
case|:
break|break;
case|case
name|NPPANIC
case|:
name|printf
argument_list|(
literal|"\nPanic from NP100 unit %d!\n"
argument_list|,
name|mp
operator|->
name|unit
argument_list|)
expr_stmt|;
name|mp
operator|->
name|flags
operator|&=
operator|~
name|AVAILABLE
expr_stmt|;
name|mp
operator|->
name|flags
operator||=
name|PANIC1
expr_stmt|;
comment|/* Clear device request word */
name|mp
operator|->
name|shmemp
operator|->
name|statblock
operator|.
name|sb_drw
operator|=
literal|0
expr_stmt|;
name|panicmap
operator|=
name|uballoc
argument_list|(
name|mp
operator|->
name|devp
operator|->
name|ui_ubanum
argument_list|,
operator|(
name|caddr_t
operator|)
name|panaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|panaddr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NPIO
argument_list|(
name|mp
argument_list|,
operator|(
name|paddr_t
operator|)
name|NPPSADDR
argument_list|,
call|(
name|paddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|panicmap
operator|&
name|UBADDRMASK
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|panaddr
argument_list|)
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
case|case
name|NPDUMP
case|:
name|mp
operator|->
name|flags
operator||=
operator|(
name|DUMPREQ
operator||
name|BOARDREQ
operator|)
expr_stmt|;
comment|/* Clear device request word */
name|mp
operator|->
name|shmemp
operator|->
name|statblock
operator|.
name|sb_drw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NpState
operator|&
name|ICPAVAIL
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|NpState
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPLOAD
case|:
name|mp
operator|->
name|flags
operator||=
operator|(
name|LOADREQ
operator||
name|BOARDREQ
operator|)
expr_stmt|;
comment|/* Clear device request word */
name|mp
operator|->
name|shmemp
operator|->
name|statblock
operator|.
name|sb_drw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NpState
operator|&
name|ICPAVAIL
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|NpState
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Bad Req: %x.\n"
argument_list|,
name|mp
operator|->
name|shmemp
operator|->
name|statblock
operator|.
name|sb_drw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Process the Host Command Queue for this device */
name|NpProcQueue
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|out
label|:
name|CLEARINT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* Clear the interrupt */
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npintr...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Interrupt serviced */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * This routine, called from the interrupt handler, is used to process the  * Host Command Queue for the specified device.  */
end_comment

begin_macro
name|NpProcQueue
argument_list|(
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|CmdQue
modifier|*
name|cqp
decl_stmt|;
specifier|register
name|struct
name|CQE
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|npreq
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|base
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpProcQueue\n"
argument_list|)
expr_stmt|;
name|cqp
operator|=
operator|&
name|mp
operator|->
name|shmemp
operator|->
name|hostcq
expr_stmt|;
comment|/* Command Queue pointer */
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|SCANNING
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|mp
operator|->
name|flags
operator||=
name|SCANNING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cqp
operator|->
name|scanflag
operator||
operator|=
name|ON
expr_stmt|;
name|base
operator|=
operator|(
name|int
operator|)
name|mp
operator|->
name|shmemp
expr_stmt|;
comment|/* Shared memory base address */
while|while
condition|(
literal|1
condition|)
block|{
name|cqp
operator|->
name|scanflag
operator||=
name|ON
expr_stmt|;
name|cqp
operator|->
name|chngflag
operator|&=
operator|~
name|ON
expr_stmt|;
while|while
condition|(
name|ep
operator|=
name|NpRemCQE
argument_list|(
name|cqp
argument_list|,
name|base
argument_list|)
condition|)
block|{
name|rp
operator|=
name|ep
operator|->
name|cqe_reqid
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBCQE
condition|)
name|printf
argument_list|(
literal|"cqe_sts is %x ep = %x\n"
argument_list|,
name|ep
operator|->
name|cqe_sts
argument_list|,
name|ep
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|cqe_sts
condition|)
block|{
case|case
name|NPDONE
case|:
name|rp
operator|->
name|flags
operator||=
name|REQDONE
expr_stmt|;
comment|/* Normal completion */
break|break;
case|case
name|NPIFC
case|:
comment|/* IFC Request */
name|rp
operator|->
name|flags
operator||=
name|IOIFC
expr_stmt|;
break|break;
case|case
name|NPPERR
case|:
comment|/* Protocol Error */
name|rp
operator|->
name|flags
operator||=
operator|(
name|NPPERR
operator||
name|REQDONE
operator|)
expr_stmt|;
break|break;
case|case
name|NPMERR
case|:
comment|/* Memory allocation */
name|rp
operator|->
name|flags
operator||=
operator|(
name|NPMERR
operator||
name|REQDONE
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Error on Board */
name|rp
operator|->
name|flags
operator||=
operator|(
name|IOERR
operator||
name|REQDONE
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|NpDebug
operator|&
name|DEBCQE
condition|)
block|{
name|printf
argument_list|(
literal|"flag is %x reqid = %x\n"
argument_list|,
name|rp
operator|->
name|flags
argument_list|,
name|ep
operator|->
name|cqe_reqid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wakeup in procqueue\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|intr
condition|)
block|{
if|if
condition|(
name|NpDebug
operator|&
name|DEBINTR
condition|)
name|printf
argument_list|(
literal|"calling usr intr at %x\n"
argument_list|,
name|rp
operator|->
name|intr
argument_list|)
expr_stmt|;
comment|/* Call interrupt routine */
call|(
modifier|*
name|rp
operator|->
name|intr
call|)
argument_list|(
name|mp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|NpDebug
operator|&
name|DEBINTR
condition|)
name|printf
argument_list|(
literal|"waking up %x\n"
argument_list|,
name|rp
argument_list|)
expr_stmt|;
comment|/* if(rp->flags& NPUIO) 					iodone(&rp->buf); 				else	wakeup((caddr_t) (rp)); /* Awaken */
name|wakeup
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Awaken */
if|if
condition|(
name|NpDebug
operator|&
name|DEBINTR
condition|)
name|printf
argument_list|(
literal|"AWAKE\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|cqp
operator|->
name|scanflag
operator|&=
operator|~
name|ON
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cqp
operator|->
name|chngflag
operator|&
name|ON
operator|)
condition|)
break|break;
block|}
name|mp
operator|->
name|flags
operator|&=
operator|~
name|SCANNING
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpProcQueue...\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * NpIFC - processes an IFC (Internal Fuction Call) request   *		NOTE: this function must be called from the user context  *			on all virtual pageing systems  *  */
end_comment

begin_expr_stmt
name|NpIFC
argument_list|(
name|mp
argument_list|,
name|rp
argument_list|)
specifier|register
expr|struct
name|npmaster
operator|*
name|mp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|npreq
modifier|*
name|rp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|CQE
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpIFC\n"
argument_list|)
expr_stmt|;
name|ep
operator|=
name|rp
operator|->
name|element
expr_stmt|;
name|rp
operator|->
name|flags
operator|&=
operator|~
name|IOIFC
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|cqe_func
condition|)
block|{
case|case
name|NPUNLOCK
case|:
comment|/* Unlock process, free up mapping registers  */
if|if
condition|(
name|NpDebug
operator|&
name|DEBIFC
condition|)
name|printf
argument_list|(
literal|"NPUNLOCK\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|mapbase
condition|)
name|NpUnMapMem
argument_list|(
name|mp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPLOCK
case|:
comment|/* Lock process, get mapping registers */
if|if
condition|(
name|NpDebug
operator|&
name|DEBIFC
condition|)
name|printf
argument_list|(
literal|"NPLOCK\n"
argument_list|)
expr_stmt|;
name|NpMapMem
argument_list|(
name|mp
argument_list|,
name|rp
argument_list|,
name|rp
operator|->
name|virtmem
argument_list|,
name|rp
operator|->
name|bytecnt
argument_list|)
expr_stmt|;
name|ep
operator|->
name|cqe_dma
index|[
literal|0
index|]
operator|=
name|LOWORD
argument_list|(
name|rp
operator|->
name|bufaddr
argument_list|)
expr_stmt|;
name|ep
operator|->
name|cqe_dma
index|[
literal|1
index|]
operator|=
name|HIWORD
argument_list|(
name|rp
operator|->
name|bufaddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPREMAP
case|:
if|if
condition|(
name|NpDebug
operator|&
name|DEBIFC
condition|)
name|printf
argument_list|(
literal|"NPREMAP\n"
argument_list|)
expr_stmt|;
comment|/* Remap user buffer and update buffer offset */
ifdef|#
directive|ifdef
name|USG
name|np_remapmem
argument_list|(
name|rp
argument_list|,
name|rp
operator|->
name|virtmem
argument_list|)
expr_stmt|;
name|ep
operator|->
name|cqe_dma
index|[
literal|0
index|]
operator|=
name|LOWORD
argument_list|(
name|rp
operator|->
name|bufaddr
argument_list|)
expr_stmt|;
name|ep
operator|->
name|cqe_dma
index|[
literal|1
index|]
operator|=
name|HIWORD
argument_list|(
name|rp
operator|->
name|bufaddr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|NpDebug
operator|&
name|DEBIFC
condition|)
name|printf
argument_list|(
literal|"Bad case %x in IFC\n"
argument_list|,
name|ep
operator|->
name|cqe_func
argument_list|)
expr_stmt|;
name|rp
operator|->
name|flags
operator||=
operator|(
name|REQDONE
operator||
name|IOERR
operator|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * The following contains various routines for allocating and deallocating  * structures used by the NP Driver. Routines are also here for addding  * and removing Command Queue Elements from a Command Queue.  */
end_comment

begin_comment
comment|/*  * Get a free NP Request structure from the list pointed to by head. Returns  * a pointer to a npreq or NULL if none left.  */
end_comment

begin_function
name|struct
name|npreq
modifier|*
name|NpGetReq
parameter_list|(
name|head
parameter_list|)
name|struct
name|npreq
modifier|*
name|head
decl_stmt|;
block|{
specifier|register
name|struct
name|npreq
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|head
operator|->
name|free
expr_stmt|;
name|head
operator|->
name|free
operator|=
name|p
operator|->
name|free
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|REQALOC
condition|)
name|printf
argument_list|(
literal|"GetReq: Req %x already allocated\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
name|WANTREQ
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|head
condition|)
name|p
operator|->
name|flags
operator||=
name|REQALOC
expr_stmt|;
return|return
operator|(
name|p
operator|==
name|head
condition|?
operator|(
expr|struct
name|npreq
operator|*
operator|)
name|NULL
else|:
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a NP Request structure to the free list pointed to by head.  */
end_comment

begin_expr_stmt
name|NpFreeReq
argument_list|(
name|head
argument_list|,
name|nprp
argument_list|)
specifier|register
expr|struct
name|npreq
operator|*
name|head
operator|,
operator|*
name|nprp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBREQ
condition|)
name|printf
argument_list|(
literal|"NpFreeReq, head is %x rp is %x\n"
argument_list|,
name|head
argument_list|,
name|nprp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nprp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"FREEREQ: attempt to free null pointer\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|nprp
operator|->
name|flags
operator|&
name|REQALOC
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"FREEREQ: attempt to free unallocated request %x\n"
argument_list|,
name|nprp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nprp
operator|->
name|flags
operator|&
name|REQUSE
condition|)
name|printf
argument_list|(
literal|"FREEREQ: freeing unremoved request %x\n"
argument_list|,
name|nprp
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|nprp
operator|->
name|forw
operator|=
name|nprp
operator|->
name|back
operator|=
operator|(
expr|struct
name|npreq
operator|*
operator|)
name|NULL
expr_stmt|;
name|nprp
operator|->
name|free
operator|=
name|head
operator|->
name|free
expr_stmt|;
name|head
operator|->
name|free
operator|=
name|nprp
expr_stmt|;
name|nprp
operator|->
name|flags
operator|&=
operator|~
name|REQALOC
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Wake up any processes waiting for a request structure */
if|if
condition|(
name|head
operator|->
name|flags
operator|&
name|WANTREQ
condition|)
block|{
name|head
operator|->
name|flags
operator|&=
operator|~
name|WANTREQ
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpFreeReq...\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Add a Command Queue Element onto the specified Command Queue and  * update its Add offset.  */
end_comment

begin_macro
name|NpAddCQE
argument_list|(
argument|ep
argument_list|,
argument|cqp
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|CQE
modifier|*
name|ep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|CmdQue
modifier|*
name|cqp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsign16
modifier|*
name|temp
decl_stmt|;
specifier|register
name|unsign16
name|cqe_offset
decl_stmt|;
specifier|register
name|int
name|base
decl_stmt|;
name|base
operator|=
operator|(
name|int
operator|)
name|mp
operator|->
name|shmemp
expr_stmt|;
comment|/* Shared memory base address */
name|temp
operator|=
operator|(
name|unsign16
operator|*
operator|)
operator|(
name|base
operator|+
name|cqp
operator|->
name|cq_add
operator|)
expr_stmt|;
comment|/* Offset to add element */
name|cqe_offset
operator|=
call|(
name|unsign16
call|)
argument_list|(
operator|(
name|int
operator|)
name|ep
operator|-
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|temp
condition|)
block|{
comment|/* Should never happen */
name|printf
argument_list|(
literal|"No more room on Command Queue!\n"
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|EIO
expr_stmt|;
return|return;
block|}
else|else
operator|*
name|temp
operator|=
name|cqe_offset
expr_stmt|;
comment|/* Enter this request's offset */
comment|/* Update cqe_add where next request is to be added */
name|cqp
operator|->
name|cq_add
operator|+=
sizeof|sizeof
argument_list|(
name|unsign16
argument_list|)
expr_stmt|;
if|if
condition|(
name|cqp
operator|->
name|cq_add
operator|==
name|cqp
operator|->
name|cq_wrap
condition|)
comment|/* Wrap if necessary */
name|cqp
operator|->
name|cq_add
operator|=
call|(
name|unsign16
call|)
argument_list|(
operator|(
name|int
operator|)
name|cqp
operator|->
name|cq_cqe
operator|-
name|base
argument_list|)
expr_stmt|;
name|cqp
operator|->
name|chngflag
operator||=
name|ON
expr_stmt|;
comment|/* Set change flag unconditionally */
comment|/* Interrupt the Board if his scan flag isn't on */
if|if
condition|(
operator|!
operator|(
name|cqp
operator|->
name|scanflag
operator|&
name|ON
operator|)
condition|)
name|INTNI
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* Interrupt the Board */
block|}
end_block

begin_comment
comment|/*  * The NpRemCQE routine is used to remove the next CQE from the Command Queue  * specified by cqp. The common offset of shared memory used by the device  * is specified by base. NpRemCQE returns a pointer to the next CQE or  * NULL if there are none left. This routine will also update the cqe_rem  * offset which specifies where the next element to be removed from the  * queue is located.  */
end_comment

begin_function
name|struct
name|CQE
modifier|*
name|NpRemCQE
parameter_list|(
name|cqp
parameter_list|,
name|base
parameter_list|)
name|struct
name|CmdQue
modifier|*
name|cqp
decl_stmt|;
name|int
name|base
decl_stmt|;
block|{
specifier|register
name|unsign16
modifier|*
name|temp
decl_stmt|;
specifier|register
name|unsign16
name|cqe_offset
decl_stmt|;
name|cqp
operator|->
name|chngflag
operator|&=
operator|~
name|ON
expr_stmt|;
comment|/* Turn off unconditionally */
comment|/* Get address of element to remove */
name|temp
operator|=
operator|(
name|unsign16
operator|*
operator|)
operator|(
name|base
operator|+
name|cqp
operator|->
name|cq_rem
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|temp
operator|==
name|NULL
condition|)
comment|/* If none left, go home */
return|return
operator|(
operator|(
expr|struct
name|CQE
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
name|cqe_offset
operator|=
operator|*
name|temp
expr_stmt|;
comment|/* Offset of CQE to remove */
comment|/* Update the Command Queue's cqe_rem offset */
operator|*
name|temp
operator|=
name|NULL
expr_stmt|;
comment|/* Clear out this entry */
name|cqp
operator|->
name|cq_rem
operator|+=
sizeof|sizeof
argument_list|(
name|unsign16
argument_list|)
expr_stmt|;
comment|/* Bump offset */
if|if
condition|(
name|cqp
operator|->
name|cq_rem
operator|==
name|cqp
operator|->
name|cq_wrap
condition|)
comment|/* Wrap if necessary */
name|cqp
operator|->
name|cq_rem
operator|=
call|(
name|unsign16
call|)
argument_list|(
operator|(
name|int
operator|)
name|cqp
operator|->
name|cq_cqe
operator|-
name|base
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|unsign16
operator|*
operator|)
operator|(
name|base
operator|+
name|cqe_offset
operator|)
expr_stmt|;
comment|/* CQE address */
return|return
operator|(
operator|(
expr|struct
name|CQE
operator|*
operator|)
name|temp
operator|)
return|;
comment|/* is returned */
block|}
end_function

begin_comment
comment|/*  * NpAddReq will add the specified npreq structure to the queue controlled  * by head.  */
end_comment

begin_expr_stmt
name|NpAddReq
argument_list|(
name|head
argument_list|,
name|rp
argument_list|)
specifier|register
expr|struct
name|npreq
operator|*
name|head
operator|,
operator|*
name|rp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
operator|(
name|DEBENTRY
operator||
name|DEBREQ
operator|)
condition|)
name|printf
argument_list|(
literal|"NpAddReq: %x\n"
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|flags
operator|&
name|REQUSE
condition|)
name|printf
argument_list|(
literal|"ADDREQ: Request %x allready in use\n"
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
name|rp
operator|->
name|forw
operator|=
name|head
operator|->
name|forw
expr_stmt|;
name|rp
operator|->
name|forw
operator|->
name|back
operator|=
name|rp
expr_stmt|;
name|rp
operator|->
name|back
operator|=
name|head
expr_stmt|;
name|head
operator|->
name|forw
operator|=
name|rp
expr_stmt|;
name|rp
operator|->
name|flags
operator||=
name|REQUSE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpAddReq...\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * NpRemReq is used to remove a npreq structure from the queue specified by  * head.  */
end_comment

begin_expr_stmt
name|NpRemReq
argument_list|(
name|rp
argument_list|)
specifier|register
expr|struct
name|npreq
operator|*
name|rp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
operator|(
name|DEBENTRY
operator||
name|DEBREQ
operator|)
condition|)
name|printf
argument_list|(
literal|"NpRemReq: %x\n"
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"REMREQ: null pointer removal requested\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|flags
operator|&
name|REQUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"REMREQ: trying to rem unused req %x\n"
argument_list|,
name|rp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|flags
operator|&
name|REQALOC
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"REMREQ: trying to rem unallocated req %x\n"
argument_list|,
name|rp
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
name|rp
operator|->
name|back
operator|->
name|forw
operator|=
name|rp
operator|->
name|forw
expr_stmt|;
name|rp
operator|->
name|forw
operator|->
name|back
operator|=
name|rp
operator|->
name|back
expr_stmt|;
name|rp
operator|->
name|flags
operator|&=
operator|~
name|REQUSE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpRemReq...\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * The following routines are used to communicate with the  * NI Hardware via the CSR0 commands. These commands are issued during  * the hardware initializtion process and may also be used subsequently  * by privileged processes who wish to communicate in this way. The  * convention for passing data as a Command Block is discussed in detail  * in the NI1510 UNIBUS Compatible Ethernet Communications Processor  * Hardware Specification.  */
end_comment

begin_macro
name|NpSendCSR0
argument_list|(
argument|iobase
argument_list|,
argument|src
argument_list|,
argument|bcount
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|NPREG
modifier|*
name|iobase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|unsign16
modifier|*
name|src
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bcount
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|wcount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|csrflag
decl_stmt|;
name|unsign16
name|tmp
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpSendCSR0\n"
argument_list|)
expr_stmt|;
comment|/* Jolt the board into CSR0 command mode if necessary */
if|if
condition|(
operator|!
operator|(
name|RCSR1
argument_list|(
name|iobase
argument_list|)
operator|&
name|NPENB
operator|)
condition|)
block|{
name|tmp
operator|=
name|NPCLEAR
expr_stmt|;
comment|/* MC68000 clr reads before writing */
name|WCSR0
argument_list|(
name|iobase
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|wcount
operator|=
operator|(
name|bcount
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* Convert byte count to word count */
comment|/* Clear timer flag before beginning the timer */
name|csrflag
operator|=
name|NPCLEAR
expr_stmt|;
name|timeout
argument_list|(
name|NpTimer
argument_list|,
operator|&
name|csrflag
argument_list|,
name|DIAGTIME
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|wcount
operator|)
operator|&
operator|(
name|csrflag
operator|==
name|NPCLEAR
operator|)
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|!
operator|(
operator|(
name|RCSR1
argument_list|(
name|iobase
argument_list|)
operator|&
name|NPENB
operator|)
operator|&&
operator|(
name|RCSR1
argument_list|(
name|iobase
argument_list|)
operator|&
name|NPRDY
operator|)
operator|)
condition|)
if|if
condition|(
name|csrflag
condition|)
break|break;
name|WCSR0
argument_list|(
name|iobase
argument_list|,
operator|*
name|src
argument_list|)
expr_stmt|;
name|src
operator|++
expr_stmt|;
comment|/* Better do this WCSR is a macro */
block|}
comment|/* Clear the timer entry */
name|untimeout
argument_list|(
name|NpTimer
argument_list|,
operator|&
name|csrflag
argument_list|)
expr_stmt|;
comment|/* Error if timer went off */
if|if
condition|(
name|csrflag
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpSendCSR0...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * NpSetIntLev sets the UNIBUS interrupt vector to be used by the NP board when  * interupting the host. The board is specified by mp.  */
end_comment

begin_macro
name|NpSetIntLevel
argument_list|(
argument|mp
argument_list|,
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
struct|struct
block|{
name|unsign16
name|cmd_word
decl_stmt|;
name|unsign16
name|int_level
decl_stmt|;
block|}
name|cmd_block
struct|;
name|cmd_block
operator|.
name|cmd_word
operator|=
name|NPCBI
operator||
name|CBICNT
expr_stmt|;
name|cmd_block
operator|.
name|int_level
operator|=
name|level
expr_stmt|;
return|return
operator|(
name|NpSendCSR0
argument_list|(
name|mp
operator|->
name|iobase
argument_list|,
operator|(
name|unsign16
operator|*
operator|)
operator|&
name|cmd_block
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|cmd_block
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * NpSetMemAddr is used to declare the shared memory area address to be used  * for communication between the driver and the device. This address is used  * to access data structures by acting as a base from which defined offsets  * locate data. The board is specified by mp.  */
end_comment

begin_macro
name|NpSetMemAddr
argument_list|(
argument|mp
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|caddr_t
name|shmaddr
decl_stmt|;
name|int
name|error
decl_stmt|;
struct|struct
block|{
name|unsign16
name|cmd_word
decl_stmt|;
name|unsign16
name|hi_addr
decl_stmt|;
name|unsign16
name|lo_addr
decl_stmt|;
block|}
name|cmd_block
struct|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpSetMemAddr\n"
argument_list|)
expr_stmt|;
name|shmaddr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBMEM
condition|)
name|printf
argument_list|(
literal|"NpSetMemAddr, addr is %x shmaddr is %x.\n"
argument_list|,
name|addr
argument_list|,
name|shmaddr
argument_list|)
expr_stmt|;
name|cmd_block
operator|.
name|cmd_word
operator|=
name|NPCMD
operator||
name|CMDCNT
expr_stmt|;
name|cmd_block
operator|.
name|hi_addr
operator|=
name|HIWORD
argument_list|(
name|shmaddr
argument_list|)
expr_stmt|;
name|cmd_block
operator|.
name|lo_addr
operator|=
name|LOWORD
argument_list|(
name|shmaddr
argument_list|)
expr_stmt|;
name|error
operator|=
name|NpSendCSR0
argument_list|(
name|mp
operator|->
name|iobase
argument_list|,
operator|(
name|unsign16
operator|*
operator|)
operator|&
name|cmd_block
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|cmd_block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpSetMemAddr...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * NpSetXeqAddr specifies the address at which the board should begin  * execution of its on-board software. It also indicates the shared memory  * address to be used. The board is specified by mp.  */
end_comment

begin_macro
name|NpSetXeqAddr
argument_list|(
argument|mp
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|caddr_t
name|shmaddr
decl_stmt|;
name|int
name|error
decl_stmt|;
struct|struct
block|{
name|unsign16
name|cmd_word
decl_stmt|;
name|unsign16
name|hi_addr
decl_stmt|;
name|unsign16
name|lo_addr
decl_stmt|;
name|unsign16
name|mhi_addr
decl_stmt|;
name|unsign16
name|mlo_addr
decl_stmt|;
block|}
name|cmd_block
struct|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpSetXeqAddr\n"
argument_list|)
expr_stmt|;
name|shmaddr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|mp
operator|->
name|iomapbase
operator|&
name|UBADDRMASK
argument_list|)
expr_stmt|;
name|cmd_block
operator|.
name|cmd_word
operator|=
name|NPBGN
operator||
name|NPCMD
operator||
name|NPLST
operator||
operator|(
name|BGNCNT
operator|+
name|CMDCNT
operator|)
expr_stmt|;
name|cmd_block
operator|.
name|hi_addr
operator|=
name|HIWORD
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|cmd_block
operator|.
name|lo_addr
operator|=
name|LOWORD
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|cmd_block
operator|.
name|mhi_addr
operator|=
name|HIWORD
argument_list|(
name|shmaddr
argument_list|)
expr_stmt|;
name|cmd_block
operator|.
name|mlo_addr
operator|=
name|LOWORD
argument_list|(
name|shmaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBINIT
condition|)
block|{
name|printf
argument_list|(
literal|"NpSetXeqAdddr: hi: %x lo: %x\n"
argument_list|,
name|HIWORD
argument_list|(
name|addr
argument_list|)
argument_list|,
name|LOWORD
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"NpSetXeqAdddr: mhi: %x mlo: %x\n"
argument_list|,
name|HIWORD
argument_list|(
name|shmaddr
argument_list|)
argument_list|,
name|LOWORD
argument_list|(
name|shmaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|NpSendCSR0
argument_list|(
name|mp
operator|->
name|iobase
argument_list|,
operator|(
name|unsign16
operator|*
operator|)
operator|&
name|cmd_block
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|cmd_block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpSetXeqAddr...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * NPIO issues a CSR0 load or dump request to the I-Board after packaging a  * CSR0 Command Block.  */
end_comment

begin_macro
name|NPIO
argument_list|(
argument|mp
argument_list|,
argument|src
argument_list|,
argument|dest
argument_list|,
argument|count
argument_list|,
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|paddr_t
name|dest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|paddr_t
name|src
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsign16
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Direction  READ/WRITE */
end_comment

begin_block
block|{
name|int
name|error
decl_stmt|;
struct|struct
block|{
name|unsign16
name|cmd_word
decl_stmt|;
comment|/* Command Word */
name|unsign16
name|shi_addr
decl_stmt|;
comment|/* High word of Source Address */
name|unsign16
name|slo_addr
decl_stmt|;
comment|/* Low word of Source Address */
name|unsign16
name|dhi_addr
decl_stmt|;
comment|/* High word of Destination Address */
name|unsign16
name|dlo_addr
decl_stmt|;
comment|/* Low word of Destination Address */
name|unsign16
name|count
decl_stmt|;
comment|/* Byte count */
name|unsign16
name|intlevel
decl_stmt|;
comment|/* Interrupt level to host */
block|}
name|cmd_block
struct|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NPIO\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBMAINT
condition|)
block|{
name|printf
argument_list|(
literal|"I/O src addr = %x, dest addr = %x \n"
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"I/O count = %d \n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|cmd_block
operator|.
name|cmd_word
operator|=
name|NPCBI
operator||
operator|(
name|CBICNT
operator|+
name|IOCNT
operator|)
expr_stmt|;
name|cmd_block
operator|.
name|intlevel
operator|=
name|mp
operator|->
name|vector
expr_stmt|;
name|cmd_block
operator|.
name|shi_addr
operator|=
name|HIWORD
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|cmd_block
operator|.
name|slo_addr
operator|=
name|LOWORD
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|cmd_block
operator|.
name|dhi_addr
operator|=
name|HIWORD
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cmd_block
operator|.
name|dlo_addr
operator|=
name|LOWORD
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cmd_block
operator|.
name|count
operator|=
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|flags
operator|&
name|LSTCMD
operator|)
operator|==
literal|0
condition|)
name|cmd_block
operator|.
name|cmd_word
operator||=
name|NPLST
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|B_READ
condition|)
name|cmd_block
operator|.
name|cmd_word
operator||=
name|NPDMP
expr_stmt|;
else|else
name|cmd_block
operator|.
name|cmd_word
operator||=
name|NPLD
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBIO
condition|)
block|{
name|printf
argument_list|(
literal|"cmd: %x int: %o shi: %x slo: %x dhi: %x dlo: %x cnt: %x\n"
argument_list|,
name|cmd_block
operator|.
name|cmd_word
argument_list|,
name|cmd_block
operator|.
name|intlevel
argument_list|,
name|cmd_block
operator|.
name|shi_addr
argument_list|,
name|cmd_block
operator|.
name|slo_addr
argument_list|,
name|cmd_block
operator|.
name|dhi_addr
argument_list|,
name|cmd_block
operator|.
name|dlo_addr
argument_list|,
name|cmd_block
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|flags
operator||=
name|CSRPEND
expr_stmt|;
comment|/* CSR0 command pending */
name|error
operator|=
name|NpSendCSR0
argument_list|(
name|mp
operator|->
name|iobase
argument_list|,
operator|(
name|unsign16
operator|*
operator|)
operator|&
name|cmd_block
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|cmd_block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NPIO...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * NpKill will terminate all outstanding requests for the specified board.  */
end_comment

begin_macro
name|NpKill
argument_list|(
argument|mp
argument_list|,
argument|curr_rp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|npreq
modifier|*
name|curr_rp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|npreq
modifier|*
name|rp
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpKill\n"
argument_list|)
expr_stmt|;
name|mp
operator|->
name|reqtab
operator|->
name|reqcnt
operator|=
literal|0
expr_stmt|;
comment|/* Init request count */
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
comment|/* Disable interrupts */
comment|/* Mark each active request as having an error and wake him up */
for|for
control|(
name|rp
operator|=
name|mp
operator|->
name|reqtab
operator|->
name|forw
init|;
name|rp
operator|!=
name|mp
operator|->
name|reqtab
condition|;
name|rp
operator|=
name|rp
operator|->
name|forw
control|)
block|{
if|if
condition|(
name|rp
operator|==
name|curr_rp
condition|)
continue|continue;
name|rp
operator|->
name|flags
operator||=
operator|(
name|IOABORT
operator||
name|REQDONE
operator|)
expr_stmt|;
name|mp
operator|->
name|reqtab
operator|->
name|reqcnt
operator|++
expr_stmt|;
comment|/* if(rp->flags& NPUIO) 			iodone(&rp->buf); 		else */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|rp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NpDebug
operator|&
name|DEBMAINT
condition|)
name|printf
argument_list|(
literal|"NpKill, req count is %d\n"
argument_list|,
name|mp
operator|->
name|reqtab
operator|->
name|reqcnt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpKill...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Hardware and Software Initializations for the specified unit */
end_comment

begin_expr_stmt
name|NpReset
argument_list|(
name|mp
argument_list|,
name|rp
argument_list|)
specifier|register
expr|struct
name|npmaster
operator|*
name|mp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|npreq
modifier|*
name|rp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpReset!\n"
argument_list|)
expr_stmt|;
comment|/* Mark board as being reset and make unavailable */
name|mp
operator|->
name|flags
operator|=
name|BRDRESET
expr_stmt|;
comment|/* Abort outstanding requests for this board */
name|mp
operator|->
name|reqtab
operator|->
name|reqcnt
operator|=
literal|0
expr_stmt|;
comment|/* Init request count */
comment|/* Wakeup Poller if available and wait until he's gone */
if|if
condition|(
name|NpState
operator|&
name|ICPAVAIL
condition|)
block|{
name|mp
operator|->
name|flags
operator||=
name|BOARDREQ
expr_stmt|;
name|mp
operator|->
name|reqtab
operator|->
name|reqcnt
operator|++
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBMAINT
condition|)
name|printf
argument_list|(
literal|"Waking ICP in reset!\n"
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|NpState
argument_list|)
expr_stmt|;
while|while
condition|(
name|mp
operator|->
name|reqtab
operator|->
name|reqcnt
condition|)
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
operator|&
name|mp
operator|->
name|reqtab
argument_list|)
argument_list|,
operator|(
name|PZERO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
name|devio
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBMAINT
condition|)
name|printf
argument_list|(
literal|"Reset:awoken by ICP senior!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Abort outstanding requests and wait till they're gone */
name|NpKill
argument_list|(
name|mp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
while|while
condition|(
name|mp
operator|->
name|reqtab
operator|->
name|reqcnt
condition|)
block|{
if|if
condition|(
name|NpDebug
operator|&
name|DEBMAINT
condition|)
block|{
name|printf
argument_list|(
literal|"Sleeping in NpReset on reqtab!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Reqcnt is %d.\n"
argument_list|,
name|mp
operator|->
name|reqtab
operator|->
name|reqcnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
operator|&
name|mp
operator|->
name|reqtab
argument_list|)
argument_list|,
operator|(
name|PZERO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
name|devio
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Free up I/O Map registers if any allocated */
if|if
condition|(
name|mp
operator|->
name|iomapbase
condition|)
block|{
if|if
condition|(
name|NpDebug
operator|&
name|DEBMEM
condition|)
name|printf
argument_list|(
literal|"freeing shared memory map.\n"
argument_list|)
expr_stmt|;
name|ubarelse
argument_list|(
name|mp
operator|->
name|devp
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|mp
operator|->
name|iomapbase
argument_list|)
expr_stmt|;
name|mp
operator|->
name|iomapbase
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Initialize S/W data structures in NP Driver */
name|NpSWinit
argument_list|(
name|mp
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* Software initialization */
comment|/* Hardware initialization of the board */
name|error
operator|=
name|NpHWinit
argument_list|(
name|mp
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* Hardware initialization */
name|mp
operator|->
name|flags
operator|&=
operator|~
name|BRDRESET
expr_stmt|;
comment|/* Initialization complete */
comment|/* Initialize Pseudo-Drivers */
if|if
condition|(
name|IxReset
condition|)
call|(
modifier|*
name|IxReset
call|)
argument_list|(
name|mp
operator|->
name|unit
argument_list|,
name|mp
operator|->
name|devp
operator|->
name|ui_ubanum
argument_list|,
name|rp
argument_list|)
expr_stmt|;
comment|/* Clear Poller's State Flag */
name|NpState
operator|=
name|NPCLEAR
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpReset...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * General purpose timeout function which sets the flag passed to it  * as argument.  */
end_comment

begin_macro
name|NpTimer
argument_list|(
argument|flagp
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|flagp
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|flagp
operator|=
name|NPSET
expr_stmt|;
block|}
end_block

begin_macro
name|NpStats
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npstats\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * NpCloseConn is called to issue a close connection command to the I-Board.  */
end_comment

begin_macro
name|NpCloseConn
argument_list|(
argument|mp
argument_list|,
argument|protocol
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsign16
name|protocol
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|npreq
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|CQE
modifier|*
name|ep
decl_stmt|;
name|int
name|pri
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpCloseConn\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Don't issue the Close Connection command if the Board          * isn't up.          */
if|if
condition|(
operator|!
operator|(
operator|(
name|mp
operator|->
name|shmemp
operator|->
name|statblock
operator|.
name|sb_dpm
operator|)
operator|&
name|PROTOMASK
argument_list|(
name|protocol
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
comment|/* Get a Request structure */
while|while
condition|(
operator|(
name|rp
operator|=
name|NpGetReq
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|reqtab
operator|->
name|flags
operator||=
name|WANTREQ
expr_stmt|;
name|sleep
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|)
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|rp
operator|->
name|intr
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
expr_stmt|;
comment|/* Do not call interrupt routine */
name|rp
operator|->
name|mapbase
operator|=
literal|0
expr_stmt|;
comment|/* Clear mapping information */
name|ep
operator|=
name|rp
operator|->
name|element
expr_stmt|;
comment|/* Handy pointer */
comment|/* Fill in CQE */
name|ep
operator|->
name|cqe_wind
operator|=
literal|0
expr_stmt|;
comment|/* Entire buffer mapped */
name|ep
operator|->
name|cqe_nbuf
operator|=
literal|1
expr_stmt|;
comment|/* Must be 1, no buffer chaining */
name|ep
operator|->
name|cqe_char
operator|=
literal|0
expr_stmt|;
comment|/* Set to 0 for now */
name|ep
operator|->
name|cqe_func
operator|=
name|NPSTOP
expr_stmt|;
comment|/* OS_STP to I-Board */
name|ep
operator|->
name|cqe_prot
operator|=
name|protocol
expr_stmt|;
comment|/* Protocol of this connection */
name|ep
operator|->
name|cqe_lenrpb
operator|=
literal|0
expr_stmt|;
comment|/* Parameter block length */
name|ep
operator|->
name|cqe_ust0
operator|=
name|ep
operator|->
name|cqe_ust1
operator|=
name|NPCLEAR
expr_stmt|;
comment|/* Clear status flags */
name|ep
operator|->
name|cqe_famid
operator|=
operator|(
name|unsign32
operator|)
name|u
operator|.
name|u_procp
operator|->
name|p_pid
expr_stmt|;
comment|/* Process ID */
name|NpAddReq
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|,
name|rp
argument_list|)
expr_stmt|;
comment|/* Queue onto active list */
name|pri
operator|=
name|spl5
argument_list|()
expr_stmt|;
comment|/* Mask our interrupts */
name|NpAddCQE
argument_list|(
name|ep
argument_list|,
operator|&
name|mp
operator|->
name|shmemp
operator|->
name|devcq
argument_list|,
name|mp
argument_list|)
expr_stmt|;
comment|/* Add CQE to device's queue */
comment|/* Wait for command to complete */
while|while
condition|(
operator|!
operator|(
name|rp
operator|->
name|flags
operator|&
name|REQDONE
operator|)
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|rp
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|pri
argument_list|)
expr_stmt|;
name|NpRemReq
argument_list|(
name|rp
argument_list|)
expr_stmt|;
comment|/* Remove request from active list */
name|NpFreeReq
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|,
name|rp
argument_list|)
expr_stmt|;
comment|/* Deallocate request structure */
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpCloseConn...\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This function allows the protocol to be changed for a given connection.  * It returns 0 for success, error code otherwise.  */
end_comment

begin_expr_stmt
name|NpProtChange
argument_list|(
name|protocol
argument_list|,
name|unit
argument_list|)
specifier|register
name|unsign16
name|protocol
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
comment|/* Privileged users only for Maintenance Protocol */
if|if
condition|(
operator|(
name|protocol
operator|==
name|NPMAINT
operator|)
operator|&&
operator|(
name|u
operator|.
name|u_uid
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBMAINT
condition|)
name|printf
argument_list|(
literal|"NpProtChange = %x\n"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
operator|!=
name|NPMAINT
condition|)
block|{
comment|/* Make sure the I-Board supports the protocol */
name|mp
operator|=
operator|&
name|npmasters
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|mp
operator|->
name|shmemp
operator|->
name|statblock
operator|.
name|sb_dpm
operator|)
operator|&
name|PROTOMASK
argument_list|(
name|protocol
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * This function allows for the changing of the unit for a given connection.  */
end_comment

begin_function
name|struct
name|npmaster
modifier|*
name|NpBoardChange
parameter_list|(
name|protocol
parameter_list|,
name|unit
parameter_list|)
specifier|register
name|unsign16
name|protocol
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
comment|/* Unit number */
block|{
specifier|register
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|unit
operator|>
name|NNP
condition|)
return|return
operator|(
operator|(
expr|struct
name|npmaster
operator|*
operator|)
literal|0
operator|)
return|;
if|if
condition|(
name|protocol
operator|!=
name|NPMAINT
condition|)
block|{
comment|/* 		 * Loop through the master structures finding a board which  		 * supports the requested protocol. 		 */
for|for
control|(
name|mp
operator|=
name|npmasters
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|BADBOARD
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|mp
operator|->
name|shmemp
operator|->
name|statblock
operator|.
name|sb_dpm
operator|)
operator|&
name|PROTOMASK
argument_list|(
name|protocol
argument_list|)
operator|)
condition|)
return|return
operator|(
name|mp
operator|)
return|;
block|}
return|return
operator|(
operator|(
expr|struct
name|npmaster
operator|*
operator|)
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|&
name|npmasters
index|[
name|unit
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NpMapMem - maps the user's memory updating the fields in the npreq  * structure and returning the mapped address in rp->buffaddr.  */
end_comment

begin_expr_stmt
name|NpMapMem
argument_list|(
name|mp
argument_list|,
name|rp
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
specifier|register
expr|struct
name|npmaster
operator|*
name|mp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|npreq
modifier|*
name|rp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpMapMem\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBIO
condition|)
name|printf
argument_list|(
literal|"mp %x rp %x addr %x count %x\n"
argument_list|,
name|mp
argument_list|,
name|rp
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|rp
operator|->
name|virtmem
operator|=
name|addr
expr_stmt|;
name|rp
operator|->
name|bytecnt
operator|=
name|count
expr_stmt|;
name|rp
operator|->
name|buf
operator|.
name|b_un
operator|.
name|b_addr
operator|=
name|addr
expr_stmt|;
name|rp
operator|->
name|buf
operator|.
name|b_flags
operator|=
name|B_PHYS
operator||
name|B_BUSY
expr_stmt|;
name|rp
operator|->
name|buf
operator|.
name|b_bcount
operator|=
name|count
expr_stmt|;
name|rp
operator|->
name|buf
operator|.
name|b_proc
operator|=
name|rp
operator|->
name|procp
expr_stmt|;
name|rp
operator|->
name|procp
operator|->
name|p_flag
operator||=
name|SPHYSIO
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"vslock\n"
argument_list|)
expr_stmt|;
name|vslock
argument_list|(
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"vslock...\n"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|mapbase
operator|=
name|ubasetup
argument_list|(
name|mp
operator|->
name|devp
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|rp
operator|->
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rp
operator|->
name|bufaddr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|rp
operator|->
name|mapbase
operator|&
name|UBADDRMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpMapMem...\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Unmap the user's memory and free up mapping registers   */
end_comment

begin_macro
name|NpUnMapMem
argument_list|(
argument|mp
argument_list|,
argument|rp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|npreq
modifier|*
name|rp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpUnMapMem\n"
argument_list|)
expr_stmt|;
name|ubarelse
argument_list|(
name|mp
operator|->
name|devp
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|rp
operator|->
name|mapbase
argument_list|)
expr_stmt|;
name|rp
operator|->
name|mapbase
operator|=
literal|0
expr_stmt|;
name|vsunlock
argument_list|(
name|rp
operator|->
name|virtmem
argument_list|,
name|rp
operator|->
name|bytecnt
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
name|rp
operator|->
name|procp
operator|->
name|p_flag
operator|&=
operator|~
name|SPHYSIO
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"NpUnMapMem...\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|npprobe
argument_list|(
argument|reg
argument_list|,
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
name|u_short
name|csraddr
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|NpDebug
operator|&
name|DEBINIT
condition|)
name|printf
argument_list|(
literal|"In npprobe, regaddr is %x!\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cvec
operator|=
operator|(
name|uba_hd
index|[
name|numuba
index|]
operator|.
name|uh_lastiv
operator|-=
literal|4
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OLDBSD
comment|/* Find unit number from npstd[] by matching the csr address */
name|csraddr
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|int
operator|)
name|reg
operator|&
literal|0x0FFFF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NNP
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|csraddr
operator|==
name|npstd
index|[
name|i
index|]
condition|)
block|{
name|npvectors
index|[
name|i
index|]
operator|=
name|cvec
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|NNP
condition|)
name|printf
argument_list|(
literal|"Couldn't find device in npstd[]!\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|npvectors
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|=
name|cvec
expr_stmt|;
endif|#
directive|endif
name|br
operator|=
literal|0x15
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBINIT
condition|)
name|printf
argument_list|(
literal|"npprobe...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|NPREG
argument_list|)
operator|)
return|;
comment|/* CSR Registers */
block|}
end_block

begin_expr_stmt
name|npattach
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NpDebug
operator|&
name|DEBINIT
condition|)
name|printf
argument_list|(
literal|"In npattach, ui is %x.\n"
argument_list|,
name|ui
argument_list|)
expr_stmt|;
name|npinit
argument_list|(
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|IxAttach
condition|)
call|(
modifier|*
name|IxAttach
call|)
argument_list|(
name|ui
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBINIT
condition|)
name|printf
argument_list|(
literal|"npattach...\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|NpMem
argument_list|(
argument|mp
argument_list|,
argument|rp
argument_list|,
argument|uaddr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|npmaster
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|npreq
modifier|*
name|rp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|uaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|np_mem
name|mem
decl_stmt|;
specifier|register
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npmem\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uaddr
argument_list|,
operator|&
name|mem
argument_list|,
sizeof|sizeof
argument_list|(
name|mem
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|mem
operator|.
name|mem_type
operator|==
name|NP_SET
condition|)
block|{
if|if
condition|(
name|np_mapreq
index|[
name|mp
operator|->
name|unit
index|]
operator|!=
operator|(
expr|struct
name|npreq
operator|*
operator|)
name|NPCLEAR
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
else|else
block|{
name|error
operator|=
name|NpMapMem
argument_list|(
name|mp
argument_list|,
name|rp
argument_list|,
name|mem
operator|.
name|mem_addr
argument_list|,
name|mem
operator|.
name|mem_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|np_mapreq
index|[
name|mp
operator|->
name|unit
index|]
operator|=
name|rp
expr_stmt|;
name|mem
operator|.
name|mem_addr
operator|=
name|rp
operator|->
name|bufaddr
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mem
operator|.
name|mem_type
operator|==
name|NP_USET
condition|)
block|{
name|error
operator|=
name|NpUnMapMem
argument_list|(
name|mp
argument_list|,
name|np_mapreq
index|[
name|mp
operator|->
name|unit
index|]
argument_list|)
expr_stmt|;
name|NpFreeReq
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|NpFreeReq
argument_list|(
name|mp
operator|->
name|reqtab
argument_list|,
name|np_mapreq
index|[
name|mp
operator|->
name|unit
index|]
argument_list|)
expr_stmt|;
name|np_mapreq
index|[
name|mp
operator|->
name|unit
index|]
operator|=
operator|(
expr|struct
name|npreq
operator|*
operator|)
name|NPCLEAR
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|mem
argument_list|,
name|uaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NpDebug
operator|&
name|DEBENTRY
condition|)
name|printf
argument_list|(
literal|"npmem...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

