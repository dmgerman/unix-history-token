begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)uda.c	7.25 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * UDA50/MSCP device driver  */
end_comment

begin_define
define|#
directive|define
name|POLLSTATS
end_define

begin_comment
comment|/*  * TODO  *	write bad block forwarding code  */
end_comment

begin_include
include|#
directive|include
file|"ra.h"
end_include

begin_if
if|#
directive|if
name|NUDA
operator|>
literal|0
end_if

begin_comment
comment|/*  * CONFIGURATION OPTIONS.  The next three defines are tunable -- tune away!  *  * COMPAT_42 enables 4.2/4.3 compatibility (label mapping)  *  * NRSPL2 and NCMDL2 control the number of response and command  * packets respectively.  They may be any value from 0 to 7, though  * setting them higher than 5 is unlikely to be of any value.  * If you get warnings about your command ring being too small,  * try increasing the values by one.  *  * MAXUNIT controls the maximum unit number (number of drives per  * controller) we are prepared to handle.  *  * DEFAULT_BURST must be at least 1.  */
end_comment

begin_define
define|#
directive|define
name|COMPAT_42
end_define

begin_define
define|#
directive|define
name|NRSPL2
value|5
end_define

begin_comment
comment|/* log2 number of response packets */
end_comment

begin_define
define|#
directive|define
name|NCMDL2
value|5
end_define

begin_comment
comment|/* log2 number of command packets */
end_comment

begin_define
define|#
directive|define
name|MAXUNIT
value|8
end_define

begin_comment
comment|/* maximum allowed unit number */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_BURST
value|4
end_define

begin_comment
comment|/* default DMA burst size */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"dkstat.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"disklabel.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"tsleep.h"
end_include

begin_include
include|#
directive|include
file|"machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"ubareg.h"
end_include

begin_include
include|#
directive|include
file|"ubavar.h"
end_include

begin_define
define|#
directive|define
name|NRSP
value|(1<< NRSPL2)
end_define

begin_define
define|#
directive|define
name|NCMD
value|(1<< NCMDL2)
end_define

begin_include
include|#
directive|include
file|"udareg.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mscp.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mscpvar.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_comment
comment|/*  * UDA communications area and MSCP packet pools, per controller.  */
end_comment

begin_struct
struct|struct
name|uda
block|{
name|struct
name|udaca
name|uda_ca
decl_stmt|;
comment|/* communications area */
name|struct
name|mscp
name|uda_rsp
index|[
name|NRSP
index|]
decl_stmt|;
comment|/* response packets */
name|struct
name|mscp
name|uda_cmd
index|[
name|NCMD
index|]
decl_stmt|;
comment|/* command packets */
block|}
name|uda
index|[
name|NUDA
index|]
struct|;
end_struct

begin_comment
comment|/*  * Software status, per controller.  */
end_comment

begin_struct
struct|struct
name|uda_softc
block|{
name|struct
name|uda
modifier|*
name|sc_uda
decl_stmt|;
comment|/* Unibus address of uda struct */
name|short
name|sc_state
decl_stmt|;
comment|/* UDA50 state; see below */
name|short
name|sc_flags
decl_stmt|;
comment|/* flags; see below */
name|int
name|sc_micro
decl_stmt|;
comment|/* microcode revision */
name|int
name|sc_ivec
decl_stmt|;
comment|/* interrupt vector address */
name|short
name|sc_ipl
decl_stmt|;
comment|/* interrupt priority, Q-bus */
name|struct
name|mscp_info
name|sc_mi
decl_stmt|;
comment|/* MSCP info (per mscpvar.h) */
ifndef|#
directive|ifndef
name|POLLSTATS
name|int
name|sc_wticks
decl_stmt|;
comment|/* watchdog timer ticks */
else|#
directive|else
name|short
name|sc_wticks
decl_stmt|;
name|short
name|sc_ncmd
decl_stmt|;
endif|#
directive|endif
block|}
name|uda_softc
index|[
name|NUDA
index|]
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|POLLSTATS
end_ifdef

begin_struct
struct|struct
name|udastats
block|{
name|int
name|ncmd
decl_stmt|;
name|int
name|cmd
index|[
name|NCMD
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|udastats
init|=
block|{
name|NCMD
operator|+
literal|1
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Controller states  */
end_comment

begin_define
define|#
directive|define
name|ST_IDLE
value|0
end_define

begin_comment
comment|/* uninitialised */
end_comment

begin_define
define|#
directive|define
name|ST_STEP1
value|1
end_define

begin_comment
comment|/* in `STEP 1' */
end_comment

begin_define
define|#
directive|define
name|ST_STEP2
value|2
end_define

begin_comment
comment|/* in `STEP 2' */
end_comment

begin_define
define|#
directive|define
name|ST_STEP3
value|3
end_define

begin_comment
comment|/* in `STEP 3' */
end_comment

begin_define
define|#
directive|define
name|ST_SETCHAR
value|4
end_define

begin_comment
comment|/* in `Set Controller Characteristics' */
end_comment

begin_define
define|#
directive|define
name|ST_RUN
value|5
end_define

begin_comment
comment|/* up and running */
end_comment

begin_comment
comment|/*  * Flags  */
end_comment

begin_define
define|#
directive|define
name|SC_MAPPED
value|0x01
end_define

begin_comment
comment|/* mapped in Unibus I/O space */
end_comment

begin_define
define|#
directive|define
name|SC_INSTART
value|0x02
end_define

begin_comment
comment|/* inside udastart() */
end_comment

begin_define
define|#
directive|define
name|SC_GRIPED
value|0x04
end_define

begin_comment
comment|/* griped about cmd ring too small */
end_comment

begin_define
define|#
directive|define
name|SC_INSLAVE
value|0x08
end_define

begin_comment
comment|/* inside udaslave() */
end_comment

begin_define
define|#
directive|define
name|SC_DOWAKE
value|0x10
end_define

begin_comment
comment|/* wakeup when ctlr init done */
end_comment

begin_define
define|#
directive|define
name|SC_STARTPOLL
value|0x20
end_define

begin_comment
comment|/* need to initiate polling */
end_comment

begin_comment
comment|/*  * Device to unit number and partition and back  */
end_comment

begin_define
define|#
directive|define
name|UNITSHIFT
value|3
end_define

begin_define
define|#
directive|define
name|UNITMASK
value|7
end_define

begin_define
define|#
directive|define
name|udaunit
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> UNITSHIFT)
end_define

begin_define
define|#
directive|define
name|udapart
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& UNITMASK)
end_define

begin_define
define|#
directive|define
name|udaminor
parameter_list|(
name|u
parameter_list|,
name|p
parameter_list|)
value|(((u)<< UNITSHIFT) | (p))
end_define

begin_comment
comment|/*  * Drive status, per drive  */
end_comment

begin_struct
struct|struct
name|ra_info
block|{
name|daddr_t
name|ra_dsize
decl_stmt|;
comment|/* size in sectors */
comment|/*	u_long	ra_type;	/* drive type */
name|u_long
name|ra_mediaid
decl_stmt|;
comment|/* media id */
name|int
name|ra_state
decl_stmt|;
comment|/* open/closed state */
struct|struct
name|ra_geom
block|{
comment|/* geometry information */
name|u_short
name|rg_nsectors
decl_stmt|;
comment|/* sectors/track */
name|u_short
name|rg_ngroups
decl_stmt|;
comment|/* track groups */
name|u_short
name|rg_ngpc
decl_stmt|;
comment|/* groups/cylinder */
name|u_short
name|rg_ntracks
decl_stmt|;
comment|/* ngroups*ngpc */
name|u_short
name|rg_ncyl
decl_stmt|;
comment|/* ra_dsize/ntracks/nsectors */
ifdef|#
directive|ifdef
name|notyet
name|u_short
name|rg_rctsize
decl_stmt|;
comment|/* size of rct */
name|u_short
name|rg_rbns
decl_stmt|;
comment|/* replacement blocks per track */
name|u_short
name|rg_nrct
decl_stmt|;
comment|/* number of rct copies */
endif|#
directive|endif
block|}
name|ra_geom
struct|;
name|int
name|ra_wlabel
decl_stmt|;
comment|/* label sector is currently writable */
name|u_long
name|ra_openpart
decl_stmt|;
comment|/* partitions open */
name|u_long
name|ra_bopenpart
decl_stmt|;
comment|/* block partitions open */
name|u_long
name|ra_copenpart
decl_stmt|;
comment|/* character partitions open */
block|}
name|ra_info
index|[
name|NRA
index|]
struct|;
end_struct

begin_comment
comment|/*  * Software state, per drive  */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|0
end_define

begin_define
define|#
directive|define
name|WANTOPEN
value|1
end_define

begin_define
define|#
directive|define
name|RDLABEL
value|2
end_define

begin_define
define|#
directive|define
name|OPEN
value|3
end_define

begin_define
define|#
directive|define
name|OPENRAW
value|4
end_define

begin_comment
comment|/*  * Definition of the driver for autoconf.  */
end_comment

begin_decl_stmt
name|int
name|udaprobe
argument_list|()
decl_stmt|,
name|udaslave
argument_list|()
decl_stmt|,
name|udaattach
argument_list|()
decl_stmt|,
name|udadgo
argument_list|()
decl_stmt|,
name|udaintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_ctlr
modifier|*
name|udaminfo
index|[
name|NUDA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|udadinfo
index|[
name|NRA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|disklabel
name|udalabel
index|[
name|NRA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|udastd
index|[]
init|=
block|{
literal|0772150
block|,
literal|0772550
block|,
literal|0777550
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|udadriver
init|=
block|{
name|udaprobe
block|,
name|udaslave
block|,
name|udaattach
block|,
name|udadgo
block|,
name|udastd
block|,
literal|"ra"
block|,
name|udadinfo
block|,
literal|"uda"
block|,
name|udaminfo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * More driver definitions, for generic MSCP code.  */
end_comment

begin_decl_stmt
name|int
name|udadgram
argument_list|()
decl_stmt|,
name|udactlrdone
argument_list|()
decl_stmt|,
name|udaunconf
argument_list|()
decl_stmt|,
name|udaiodone
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|udaonline
argument_list|()
decl_stmt|,
name|udagotstatus
argument_list|()
decl_stmt|,
name|udaioerror
argument_list|()
decl_stmt|,
name|udareplace
argument_list|()
decl_stmt|,
name|udabb
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|udautab
index|[
name|NRA
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per drive transfer queue */
end_comment

begin_decl_stmt
name|struct
name|mscp_driver
name|udamscpdriver
init|=
block|{
name|MAXUNIT
block|,
name|NRA
block|,
name|UNITSHIFT
block|,
name|udautab
block|,
name|udalabel
block|,
name|udadinfo
block|,
name|udadgram
block|,
name|udactlrdone
block|,
name|udaunconf
block|,
name|udaiodone
block|,
name|udaonline
block|,
name|udagotstatus
block|,
name|udareplace
block|,
name|udaioerror
block|,
name|udabb
block|,
literal|"uda"
block|,
literal|"ra"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Miscellaneous private variables.  */
end_comment

begin_decl_stmt
name|char
name|udasr_bits
index|[]
init|=
name|UDASR_BITS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|udaip
index|[
name|NUDA
index|]
index|[
name|MAXUNIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inverting pointers: ctlr& unit => Unibus 				   device pointer */
end_comment

begin_decl_stmt
name|int
name|udaburst
index|[
name|NUDA
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* burst size, per UDA50, zero => default; 				   in data space so patchable via adb */
end_comment

begin_decl_stmt
name|struct
name|mscp
name|udaslavereply
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* get unit status response packet, set 				   for udaslave by udaunconf, via udaintr */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|uba_ctlr
modifier|*
name|probeum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this is a hack---autoconf should pass ctlr 				   info to slave routine; instead, we remember 				   the last ctlr argument to probe */
end_comment

begin_decl_stmt
name|int
name|udawstart
decl_stmt|,
name|udawatch
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* watchdog timer */
end_comment

begin_comment
comment|/*  * Externals  */
end_comment

begin_function_decl
name|int
name|wakeup
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Poke at a supposed UDA50 to see if it is there.  * This routine duplicates some of the code in udainit() only  * because autoconf has not set up the right information yet.  * We have to do everything `by hand'.  */
end_comment

begin_macro
name|udaprobe
argument_list|(
argument|reg
argument_list|,
argument|ctlr
argument_list|,
argument|um
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
specifier|register
name|struct
name|uda_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|udadevice
modifier|*
name|udaddr
decl_stmt|;
specifier|register
name|struct
name|mscp_info
modifier|*
name|mi
decl_stmt|;
name|int
name|timeout
decl_stmt|,
name|tries
decl_stmt|,
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|VAX750
comment|/* 	 * The UDA50 wants to share BDPs on 750s, but not on 780s or 	 * 8600s.  (730s have no BDPs anyway.)  Toward this end, we 	 * here set the `keep bdp' flag in the per-driver information 	 * if this is a 750.  (We just need to do it once, but it is 	 * easiest to do it now, for each UDA50.) 	 */
if|if
condition|(
name|cpu
operator|==
name|VAX_750
condition|)
name|udadriver
operator|.
name|ud_keepbdp
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|probeum
operator|=
name|um
expr_stmt|;
comment|/* remember for udaslave() */
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|udaintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set up the controller-specific generic MSCP driver info. 	 * Note that this should really be done in the (nonexistent) 	 * controller attach routine. 	 */
name|sc
operator|=
operator|&
name|uda_softc
index|[
name|ctlr
index|]
expr_stmt|;
name|mi
operator|=
operator|&
name|sc
operator|->
name|sc_mi
expr_stmt|;
name|mi
operator|->
name|mi_md
operator|=
operator|&
name|udamscpdriver
expr_stmt|;
name|mi
operator|->
name|mi_ctlr
operator|=
name|um
operator|->
name|um_ctlr
expr_stmt|;
name|mi
operator|->
name|mi_tab
operator|=
operator|&
name|um
operator|->
name|um_tab
expr_stmt|;
name|mi
operator|->
name|mi_ip
operator|=
name|udaip
index|[
name|ctlr
index|]
expr_stmt|;
name|mi
operator|->
name|mi_cmd
operator|.
name|mri_size
operator|=
name|NCMD
expr_stmt|;
name|mi
operator|->
name|mi_cmd
operator|.
name|mri_desc
operator|=
name|uda
index|[
name|ctlr
index|]
operator|.
name|uda_ca
operator|.
name|ca_cmddsc
expr_stmt|;
name|mi
operator|->
name|mi_cmd
operator|.
name|mri_ring
operator|=
name|uda
index|[
name|ctlr
index|]
operator|.
name|uda_cmd
expr_stmt|;
name|mi
operator|->
name|mi_rsp
operator|.
name|mri_size
operator|=
name|NRSP
expr_stmt|;
name|mi
operator|->
name|mi_rsp
operator|.
name|mri_desc
operator|=
name|uda
index|[
name|ctlr
index|]
operator|.
name|uda_ca
operator|.
name|ca_rspdsc
expr_stmt|;
name|mi
operator|->
name|mi_rsp
operator|.
name|mri_ring
operator|=
name|uda
index|[
name|ctlr
index|]
operator|.
name|uda_rsp
expr_stmt|;
name|mi
operator|->
name|mi_wtab
operator|.
name|av_forw
operator|=
name|mi
operator|->
name|mi_wtab
operator|.
name|av_back
operator|=
operator|&
name|mi
operator|->
name|mi_wtab
expr_stmt|;
comment|/* 	 * More controller specific variables.  Again, this should 	 * be in the controller attach routine. 	 */
if|if
condition|(
name|udaburst
index|[
name|ctlr
index|]
operator|==
literal|0
condition|)
name|udaburst
index|[
name|ctlr
index|]
operator|=
name|DEFAULT_BURST
expr_stmt|;
comment|/* 	 * Get an interrupt vector.  Note that even if the controller 	 * does not respond, we keep the vector.  This is not a serious 	 * problem; but it would be easily fixed if we had a controller 	 * attach routine.  Sigh. 	 */
name|sc
operator|->
name|sc_ivec
operator|=
operator|(
name|uba_hd
index|[
name|numuba
index|]
operator|.
name|uh_lastiv
operator|-=
literal|4
operator|)
expr_stmt|;
name|udaddr
operator|=
operator|(
expr|struct
name|udadevice
operator|*
operator|)
name|reg
expr_stmt|;
comment|/* 	 * Initialise the controller (partially).  The UDA50 programmer's 	 * manual states that if initialisation fails, it should be retried 	 * at least once, but after a second failure the port should be 	 * considered `down'; it also mentions that the controller should 	 * initialise within ten seconds.  Or so I hear; I have not seen 	 * this manual myself. 	 */
ifdef|#
directive|ifdef
name|QBA
name|s
operator|=
name|spl6
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|tries
operator|=
literal|0
expr_stmt|;
name|again
label|:
name|udaddr
operator|->
name|udaip
operator|=
literal|0
expr_stmt|;
comment|/* start initialisation */
name|timeout
operator|=
name|todr
argument_list|()
operator|+
literal|1000
expr_stmt|;
comment|/* timeout in 10 seconds */
while|while
condition|(
operator|(
name|udaddr
operator|->
name|udasa
operator|&
name|UDA_STEP1
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|todr
argument_list|()
operator|>
name|timeout
condition|)
goto|goto
name|bad
goto|;
name|udaddr
operator|->
name|udasa
operator|=
name|UDA_ERR
operator||
operator|(
name|NCMDL2
operator|<<
literal|11
operator|)
operator||
operator|(
name|NRSPL2
operator|<<
literal|8
operator|)
operator||
name|UDA_IE
operator||
operator|(
name|sc
operator|->
name|sc_ivec
operator|>>
literal|2
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|udaddr
operator|->
name|udasa
operator|&
name|UDA_STEP2
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|todr
argument_list|()
operator|>
name|timeout
condition|)
goto|goto
name|bad
goto|;
comment|/* should have interrupted by now */
ifdef|#
directive|ifdef
name|QBA
name|sc
operator|->
name|sc_ipl
operator|=
name|br
operator|=
name|qbgetpri
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|udadevice
argument_list|)
operator|)
return|;
name|bad
label|:
if|if
condition|(
operator|++
name|tries
operator|<
literal|2
condition|)
goto|goto
name|again
goto|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Find a slave.  We allow wildcard slave numbers (something autoconf  * is not really prepared to deal with); and we need to know the  * controller number to talk to the UDA.  For the latter, we keep  * track of the last controller probed, since a controller probe  * immediately precedes all slave probes for that controller.  For the  * former, we simply put the unit number into ui->ui_slave after we  * have found one.  *  * Note that by the time udaslave is called, the interrupt vector  * for the UDA50 has been set up (so that udaunconf() will be called).  */
end_comment

begin_expr_stmt
name|udaslave
argument_list|(
name|ui
argument_list|,
name|reg
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
init|=
name|probeum
decl_stmt|;
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|uda_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|next
init|=
literal|0
decl_stmt|,
name|timeout
decl_stmt|,
name|tries
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|i
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Make sure the controller is fully initialised, by waiting 	 * for it if necessary. 	 */
name|sc
operator|=
operator|&
name|uda_softc
index|[
name|um
operator|->
name|um_ctlr
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ST_RUN
condition|)
goto|goto
name|findunit
goto|;
name|tries
operator|=
literal|0
expr_stmt|;
name|again
label|:
if|if
condition|(
name|udainit
argument_list|(
name|ui
operator|->
name|ui_ctlr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|timeout
operator|=
name|todr
argument_list|()
operator|+
literal|1000
expr_stmt|;
comment|/* 10 seconds */
while|while
condition|(
name|todr
argument_list|()
operator|<
name|timeout
condition|)
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ST_RUN
condition|)
comment|/* made it */
goto|goto
name|findunit
goto|;
if|if
condition|(
operator|++
name|tries
operator|<
literal|2
condition|)
goto|goto
name|again
goto|;
name|printf
argument_list|(
literal|"uda%d: controller hung\n"
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The controller is all set; go find the unit.  Grab an 	 * MSCP packet and send out a Get Unit Status command, with 	 * the `next unit' modifier if we are looking for a generic 	 * unit.  We set the `in slave' flag so that udaunconf() 	 * knows to copy the response to `udaslavereply'. 	 */
name|findunit
label|:
name|udaslavereply
operator|.
name|mscp_opcode
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_INSLAVE
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|=
name|mscp_getcp
argument_list|(
operator|&
name|sc
operator|->
name|sc_mi
argument_list|,
name|MSCP_DONTWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"udaslave"
argument_list|)
expr_stmt|;
comment|/* `cannot happen' */
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_GETUNITST
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|ui_slave
operator|==
literal|'?'
condition|)
block|{
name|mp
operator|->
name|mscp_unit
operator|=
name|next
expr_stmt|;
name|mp
operator|->
name|mscp_modifier
operator|=
name|M_GUM_NEXTUNIT
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|mp
operator|->
name|mscp_modifier
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|mp
operator|->
name|mscp_addr
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
name|i
operator|=
operator|(
operator|(
expr|struct
name|udadevice
operator|*
operator|)
name|reg
operator|)
operator|->
name|udaip
expr_stmt|;
comment|/* initiate polling */
name|mp
operator|=
operator|&
name|udaslavereply
expr_stmt|;
name|timeout
operator|=
name|todr
argument_list|()
operator|+
literal|1000
expr_stmt|;
while|while
condition|(
name|todr
argument_list|()
operator|<
name|timeout
condition|)
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
condition|)
goto|goto
name|gotit
goto|;
name|printf
argument_list|(
literal|"uda%d: no response to Get Unit Status request\n"
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_INSLAVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|gotit
label|:
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_INSLAVE
expr_stmt|;
comment|/* 	 * Got a slave response.  If the unit is there, use it. 	 */
switch|switch
condition|(
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
condition|)
block|{
case|case
name|M_ST_SUCCESS
case|:
comment|/* worked */
case|case
name|M_ST_AVAILABLE
case|:
comment|/* found another drive */
break|break;
comment|/* use it */
case|case
name|M_ST_OFFLINE
case|:
comment|/* 		 * Figure out why it is off line.  It may be because 		 * it is nonexistent, or because it is spun down, or 		 * for some other reason. 		 */
switch|switch
condition|(
name|mp
operator|->
name|mscp_status
operator|&
operator|~
name|M_ST_MASK
condition|)
block|{
case|case
name|M_OFFLINE_UNKNOWN
case|:
comment|/* 			 * No such drive, and there are none with 			 * higher unit numbers either, if we are 			 * using M_GUM_NEXTUNIT. 			 */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|M_OFFLINE_UNMOUNTED
case|:
comment|/* 			 * The drive is not spun up.  Use it anyway. 			 * 			 * N.B.: this seems to be a common occurrance 			 * after a power failure.  The first attempt 			 * to bring it on line seems to spin it up 			 * (and thus takes several minutes).  Perhaps 			 * we should note here that the on-line may 			 * take longer than usual. 			 */
break|break;
default|default:
comment|/* 			 * In service, or something else equally unusable. 			 */
name|printf
argument_list|(
literal|"uda%d: unit %d off line: "
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|)
expr_stmt|;
name|mscp_printevent
argument_list|(
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|try_another
goto|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"uda%d: unable to get unit status: "
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
name|mscp_printevent
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Does this ever happen?  What (if anything) does it mean? 	 */
if|if
condition|(
name|mp
operator|->
name|mscp_unit
operator|<
name|next
condition|)
block|{
name|printf
argument_list|(
literal|"uda%d: unit %d, next %d\n"
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|mp
operator|->
name|mscp_unit
operator|>=
name|MAXUNIT
condition|)
block|{
name|printf
argument_list|(
literal|"uda%d: cannot handle unit number %d (max is %d)\n"
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|MAXUNIT
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * See if we already handle this drive. 	 * (Only likely if ui->ui_slave=='?'.) 	 */
if|if
condition|(
name|udaip
index|[
name|um
operator|->
name|um_ctlr
index|]
index|[
name|mp
operator|->
name|mscp_unit
index|]
operator|!=
name|NULL
condition|)
block|{
name|try_another
label|:
if|if
condition|(
name|ui
operator|->
name|ui_slave
operator|!=
literal|'?'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|next
operator|=
name|mp
operator|->
name|mscp_unit
operator|+
literal|1
expr_stmt|;
goto|goto
name|findunit
goto|;
block|}
comment|/* 	 * Voila! 	 */
name|uda_rasave
argument_list|(
name|ui
operator|->
name|ui_unit
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ui
operator|->
name|ui_flags
operator|=
literal|0
expr_stmt|;
comment|/* not on line, nor anything else */
name|ui
operator|->
name|ui_slave
operator|=
name|mp
operator|->
name|mscp_unit
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Attach a found slave.  Make sure the watchdog timer is running.  * If this disk is being profiled, fill in the `wpms' value (used by  * what?).  Set up the inverting pointer, and attempt to bring the  * drive on line and read its label.  */
end_comment

begin_expr_stmt
name|udaattach
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|ui
operator|->
name|ui_unit
decl_stmt|;
if|if
condition|(
name|udawstart
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|udawatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|udawstart
operator|++
expr_stmt|;
block|}
comment|/* 	 * Floppies cannot be brought on line unless there is 	 * a disk in the drive.  Since an ONLINE while cold 	 * takes ten seconds to fail, and (when notyet becomes now) 	 * no sensible person will swap to one, we just 	 * defer the ONLINE until someone tries to use the drive. 	 * 	 * THIS ASSUMES THAT DRIVE TYPES ?X? ARE FLOPPIES 	 */
if|if
condition|(
name|MSCP_MID_ECH
argument_list|(
literal|1
argument_list|,
name|ra_info
index|[
name|unit
index|]
operator|.
name|ra_mediaid
argument_list|)
operator|==
literal|'X'
operator|-
literal|'@'
condition|)
block|{
name|printf
argument_list|(
literal|": floppy"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ui
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
name|dk_wpms
index|[
name|ui
operator|->
name|ui_dk
index|]
operator|=
operator|(
literal|60
operator|*
literal|31
operator|*
literal|256
operator|)
expr_stmt|;
comment|/* approx */
name|udaip
index|[
name|ui
operator|->
name|ui_ctlr
index|]
index|[
name|ui
operator|->
name|ui_slave
index|]
operator|=
name|ui
expr_stmt|;
if|if
condition|(
name|uda_rainit
argument_list|(
name|ui
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|": offline"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ra_info
index|[
name|unit
index|]
operator|.
name|ra_state
operator|==
name|OPEN
condition|)
block|{
name|printf
argument_list|(
literal|": %s, size = %d sectors"
argument_list|,
name|udalabel
index|[
name|unit
index|]
operator|.
name|d_typename
argument_list|,
name|ra_info
index|[
name|unit
index|]
operator|.
name|ra_dsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|addswap
argument_list|(
name|makedev
argument_list|(
name|UDADEVNUM
argument_list|,
name|udaminor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
operator|&
name|udalabel
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_comment
comment|/*  * Initialise a UDA50.  Return true iff something goes wrong.  */
end_comment

begin_macro
name|udainit
argument_list|(
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uda_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|udadevice
modifier|*
name|udaddr
decl_stmt|;
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
name|int
name|timo
decl_stmt|,
name|ubinfo
decl_stmt|;
name|sc
operator|=
operator|&
name|uda_softc
index|[
name|ctlr
index|]
expr_stmt|;
name|um
operator|=
name|udaminfo
index|[
name|ctlr
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_MAPPED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Map the communication area and command and 		 * response packets into Unibus space. 		 */
name|ubinfo
operator|=
name|uballoc
argument_list|(
name|um
operator|->
name|um_ubanum
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|uda
index|[
name|ctlr
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uda
argument_list|)
argument_list|,
name|UBA_CANTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ubinfo
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uda%d: uballoc map failed\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|sc_uda
operator|=
operator|(
expr|struct
name|uda
operator|*
operator|)
name|UBAI_ADDR
argument_list|(
name|ubinfo
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_MAPPED
expr_stmt|;
block|}
comment|/* 	 * While we are thinking about it, reset the next command 	 * and response indicies. 	 */
name|sc
operator|->
name|sc_mi
operator|.
name|mi_cmd
operator|.
name|mri_next
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mi
operator|.
name|mi_rsp
operator|.
name|mri_next
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Start up the hardware initialisation sequence. 	 */
define|#
directive|define
name|STEP0MASK
value|(UDA_ERR | UDA_STEP4 | UDA_STEP3 | UDA_STEP2 | \ 			 UDA_STEP1 | UDA_NV)
name|sc
operator|->
name|sc_state
operator|=
name|ST_IDLE
expr_stmt|;
comment|/* in case init fails */
name|udaddr
operator|=
operator|(
expr|struct
name|udadevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
name|udaddr
operator|->
name|udaip
operator|=
literal|0
expr_stmt|;
name|timo
operator|=
name|todr
argument_list|()
operator|+
literal|1000
expr_stmt|;
while|while
condition|(
operator|(
name|udaddr
operator|->
name|udasa
operator|&
name|STEP0MASK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|todr
argument_list|()
operator|>
name|timo
condition|)
block|{
name|printf
argument_list|(
literal|"uda%d: timeout during init\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|udaddr
operator|->
name|udasa
operator|&
name|STEP0MASK
operator|)
operator|!=
name|UDA_STEP1
condition|)
block|{
name|printf
argument_list|(
literal|"uda%d: init failed, sa=%b\n"
argument_list|,
name|ctlr
argument_list|,
name|udaddr
operator|->
name|udasa
argument_list|,
name|udasr_bits
argument_list|)
expr_stmt|;
name|udasaerror
argument_list|(
name|um
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Success!  Record new state, and start step 1 initialisation. 	 * The rest is done in the interrupt handler. 	 */
name|sc
operator|->
name|sc_state
operator|=
name|ST_STEP1
expr_stmt|;
name|udaddr
operator|->
name|udasa
operator|=
name|UDA_ERR
operator||
operator|(
name|NCMDL2
operator|<<
literal|11
operator|)
operator||
operator|(
name|NRSPL2
operator|<<
literal|8
operator|)
operator||
name|UDA_IE
operator||
operator|(
name|sc
operator|->
name|sc_ivec
operator|>>
literal|2
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Open a drive.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|udaopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|uda_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|ra_info
modifier|*
name|ra
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|,
name|part
decl_stmt|,
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|daddr_t
name|start
decl_stmt|,
name|end
decl_stmt|;
comment|/* 	 * Make sure this is a reasonable open request. 	 */
name|unit
operator|=
name|udaunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRA
operator|||
operator|(
name|ui
operator|=
name|udadinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Make sure the controller is running, by (re)initialising it if 	 * necessary. 	 */
name|sc
operator|=
operator|&
name|uda_softc
index|[
name|ui
operator|->
name|ui_ctlr
index|]
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|ST_RUN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ST_IDLE
operator|&&
name|udainit
argument_list|(
name|ui
operator|->
name|ui_ctlr
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 		 * In case it does not come up, make sure we will be 		 * restarted in 10 seconds.  This corresponds to the 		 * 10 second timeouts in udaprobe() and udaslave(). 		 */
name|sc
operator|->
name|sc_flags
operator||=
name|SC_DOWAKE
expr_stmt|;
name|timeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|ST_RUN
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"uda%d: controller hung\n"
argument_list|,
name|ui
operator|->
name|ui_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|untimeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for the state to settle 	 */
name|ra
operator|=
operator|&
name|ra_info
index|[
name|unit
index|]
expr_stmt|;
while|while
condition|(
name|ra
operator|->
name|ra_state
operator|!=
name|OPEN
operator|&&
name|ra
operator|->
name|ra_state
operator|!=
name|OPENRAW
operator|&&
name|ra
operator|->
name|ra_state
operator|!=
name|CLOSED
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|ra
argument_list|,
name|PZERO
operator|+
literal|1
argument_list|,
name|SLP_UDA_OPN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If not on line, or we are not sure of the label, reinitialise 	 * the drive. 	 */
if|if
condition|(
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_ONLINE
operator|)
operator|==
literal|0
operator|||
operator|(
name|ra
operator|->
name|ra_state
operator|!=
name|OPEN
operator|&&
name|ra
operator|->
name|ra_state
operator|!=
name|OPENRAW
operator|)
condition|)
name|error
operator|=
name|uda_rainit
argument_list|(
name|ui
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|part
operator|=
name|udapart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|&
name|udalabel
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|part
operator|>=
name|lp
operator|->
name|d_npartitions
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Warn if a partition is opened that overlaps another 	 * already open, unless either is the `raw' partition 	 * (whole disk). 	 */
define|#
directive|define
name|RAWPART
value|2
comment|/* 'c' partition */
comment|/* XXX */
name|mask
operator|=
literal|1
operator|<<
name|part
expr_stmt|;
if|if
condition|(
operator|(
name|ra
operator|->
name|ra_openpart
operator|&
name|mask
operator|)
operator|==
literal|0
operator|&&
name|part
operator|!=
name|RAWPART
condition|)
block|{
name|pp
operator|=
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
expr_stmt|;
name|start
operator|=
name|pp
operator|->
name|p_offset
expr_stmt|;
name|end
operator|=
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|lp
operator|->
name|d_partitions
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lp
operator|->
name|d_npartitions
condition|;
name|pp
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
operator|<=
name|start
operator|||
name|pp
operator|->
name|p_offset
operator|>=
name|end
operator|||
name|i
operator|==
name|RAWPART
condition|)
continue|continue;
if|if
condition|(
name|ra
operator|->
name|ra_openpart
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"ra%d%c: overlaps open partition (%c)\n"
argument_list|,
name|unit
argument_list|,
name|part
operator|+
literal|'a'
argument_list|,
name|i
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|ra
operator|->
name|ra_copenpart
operator||=
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|ra
operator|->
name|ra_bopenpart
operator||=
name|mask
expr_stmt|;
break|break;
block|}
name|ra
operator|->
name|ra_openpart
operator||=
name|mask
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|udaclose
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|,
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|udaunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|ra_info
modifier|*
name|ra
init|=
operator|&
name|ra_info
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|,
name|mask
init|=
operator|(
literal|1
operator|<<
name|udapart
argument_list|(
name|dev
argument_list|)
operator|)
decl_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|ra
operator|->
name|ra_copenpart
operator|&=
operator|~
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|ra
operator|->
name|ra_bopenpart
operator|&=
operator|~
name|mask
expr_stmt|;
break|break;
block|}
name|ra
operator|->
name|ra_openpart
operator|=
name|ra
operator|->
name|ra_copenpart
operator||
name|ra
operator|->
name|ra_bopenpart
expr_stmt|;
comment|/* 	 * Should wait for I/O to complete on this partition even if 	 * others are open, but wait for work on blkflush(). 	 */
if|if
condition|(
name|ra
operator|->
name|ra_openpart
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
while|while
condition|(
name|udautab
index|[
name|unit
index|]
operator|.
name|b_actf
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|udautab
index|[
name|unit
index|]
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ra
operator|->
name|ra_state
operator|=
name|CLOSED
expr_stmt|;
name|ra
operator|->
name|ra_wlabel
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Initialise a drive.  If it is not already, bring it on line,  * and set a timeout on it in case it fails to respond.  * When on line, read in the pack label.  */
end_comment

begin_expr_stmt
name|uda_rainit
argument_list|(
name|ui
argument_list|,
name|flags
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uda_softc
modifier|*
name|sc
init|=
operator|&
name|uda_softc
index|[
name|ui
operator|->
name|ui_ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|ui
operator|->
name|ui_unit
decl_stmt|;
specifier|register
name|struct
name|ra_info
modifier|*
name|ra
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|readdisklabel
argument_list|()
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|,
name|udastrategy
argument_list|()
decl_stmt|;
specifier|extern
name|int
name|cold
decl_stmt|;
name|ra
operator|=
operator|&
name|ra_info
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_ONLINE
operator|)
operator|==
literal|0
condition|)
block|{
name|mp
operator|=
name|mscp_getcp
argument_list|(
operator|&
name|sc
operator|->
name|sc_mi
argument_list|,
name|MSCP_WAIT
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_ONLINE
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|mp
operator|->
name|mscp_cmdref
operator|=
operator|(
name|long
operator|)
operator|&
name|ui
operator|->
name|ui_flags
expr_stmt|;
operator|*
name|mp
operator|->
name|mscp_addr
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
name|ra
operator|->
name|ra_state
operator|=
name|WANTOPEN
expr_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|i
operator|=
operator|(
operator|(
expr|struct
name|udadevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
operator|)
operator|->
name|udaip
expr_stmt|;
if|if
condition|(
name|cold
condition|)
block|{
name|i
operator|=
name|todr
argument_list|()
operator|+
literal|1000
expr_stmt|;
while|while
condition|(
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_ONLINE
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|todr
argument_list|()
operator|>
name|i
condition|)
break|break;
block|}
else|else
block|{
name|timeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ui
operator|->
name|ui_flags
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ui
operator|->
name|ui_flags
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ui
operator|->
name|ui_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ra
operator|->
name|ra_state
operator|!=
name|OPENRAW
condition|)
block|{
name|ra
operator|->
name|ra_state
operator|=
name|CLOSED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|ra
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
name|lp
operator|=
operator|&
name|udalabel
index|[
name|unit
index|]
expr_stmt|;
name|lp
operator|->
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|lp
operator|->
name|d_secperunit
operator|=
name|ra
operator|->
name|ra_dsize
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_NDELAY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ra
operator|->
name|ra_state
operator|=
name|RDLABEL
expr_stmt|;
comment|/* 	 * Set up default sizes until we have the label, or longer 	 * if there is none.  Set secpercyl, as readdisklabel wants 	 * to compute b_cylin (although we do not need it), and set 	 * nsectors in case diskerr is called. 	 */
name|lp
operator|->
name|d_secpercyl
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|d_secsize
operator|=
literal|512
expr_stmt|;
name|lp
operator|->
name|d_secperunit
operator|=
name|ra
operator|->
name|ra_dsize
expr_stmt|;
name|lp
operator|->
name|d_nsectors
operator|=
name|ra
operator|->
name|ra_geom
operator|.
name|rg_nsectors
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|lp
operator|->
name|d_secperunit
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Read pack label. 	 */
if|if
condition|(
operator|(
name|msg
operator|=
name|readdisklabel
argument_list|(
name|udaminor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
argument_list|,
name|udastrategy
argument_list|,
name|lp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cold
condition|)
name|printf
argument_list|(
literal|": %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ra%d: %s"
argument_list|,
name|unit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_42
if|if
condition|(
name|udamaptype
argument_list|(
name|unit
argument_list|,
name|lp
argument_list|)
condition|)
name|ra
operator|->
name|ra_state
operator|=
name|OPEN
expr_stmt|;
else|else
name|ra
operator|->
name|ra_state
operator|=
name|OPENRAW
expr_stmt|;
else|#
directive|else
name|ra
operator|->
name|ra_state
operator|=
name|OPENRAW
expr_stmt|;
name|uda_makefakelabel
argument_list|(
name|ra
argument_list|,
name|lp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|ra
operator|->
name|ra_state
operator|=
name|OPEN
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|ra
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Copy the geometry information for the given ra from a  * GET UNIT STATUS response.  If check, see if it changed.  */
end_comment

begin_macro
name|uda_rasave
argument_list|(
argument|unit
argument_list|,
argument|mp
argument_list|,
argument|check
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|check
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ra_info
modifier|*
name|ra
init|=
operator|&
name|ra_info
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|check
operator|&&
name|ra
operator|->
name|ra_mediaid
operator|!=
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_mediaid
condition|)
block|{
name|printf
argument_list|(
literal|"ra%d: changed types! was %d now %d\n"
argument_list|,
name|unit
argument_list|,
name|ra
operator|->
name|ra_mediaid
argument_list|,
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_mediaid
argument_list|)
expr_stmt|;
name|ra
operator|->
name|ra_state
operator|=
name|CLOSED
expr_stmt|;
comment|/* ??? */
block|}
comment|/* ra->ra_type = mp->mscp_guse.guse_drivetype; */
name|ra
operator|->
name|ra_mediaid
operator|=
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_mediaid
expr_stmt|;
name|ra
operator|->
name|ra_geom
operator|.
name|rg_nsectors
operator|=
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_nspt
expr_stmt|;
name|ra
operator|->
name|ra_geom
operator|.
name|rg_ngroups
operator|=
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_group
expr_stmt|;
name|ra
operator|->
name|ra_geom
operator|.
name|rg_ngpc
operator|=
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_ngpc
expr_stmt|;
name|ra
operator|->
name|ra_geom
operator|.
name|rg_ntracks
operator|=
name|ra
operator|->
name|ra_geom
operator|.
name|rg_ngroups
operator|*
name|ra
operator|->
name|ra_geom
operator|.
name|rg_ngpc
expr_stmt|;
comment|/* ra_geom.rg_ncyl cannot be computed until we have ra_dsize */
ifdef|#
directive|ifdef
name|notyet
name|ra
operator|->
name|ra_geom
operator|.
name|rg_rctsize
operator|=
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_rctsize
expr_stmt|;
name|ra
operator|->
name|ra_geom
operator|.
name|rg_rbns
operator|=
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_nrpt
expr_stmt|;
name|ra
operator|->
name|ra_geom
operator|.
name|rg_nrct
operator|=
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_nrct
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Queue a transfer request, and if possible, hand it to the controller.  *  * This routine is broken into two so that the internal version  * udastrat1() can be called by the (nonexistent, as yet) bad block  * revectoring routine.  */
end_comment

begin_expr_stmt
name|udastrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|ra_info
modifier|*
name|ra
decl_stmt|;
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
name|int
name|p
decl_stmt|;
name|daddr_t
name|sz
decl_stmt|,
name|maxsz
decl_stmt|;
comment|/* 	 * Make sure this is a reasonable drive to use. 	 */
if|if
condition|(
operator|(
name|unit
operator|=
name|udaunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|)
operator|>=
name|NRA
operator|||
operator|(
name|ui
operator|=
name|udadinfo
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
operator|||
operator|(
name|ra
operator|=
operator|&
name|ra_info
index|[
name|unit
index|]
operator|)
operator|->
name|ra_state
operator|==
name|CLOSED
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * If drive is open `raw' or reading label, let it at it. 	 */
if|if
condition|(
name|ra
operator|->
name|ra_state
operator|<
name|OPEN
condition|)
block|{
name|udastrat1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|udapart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ra
operator|->
name|ra_openpart
operator|&
operator|(
literal|1
operator|<<
name|p
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Determine the size of the transfer, and make sure it is 	 * within the boundaries of the partition. 	 */
name|pp
operator|=
operator|&
name|udalabel
index|[
name|unit
index|]
operator|.
name|d_partitions
index|[
name|p
index|]
expr_stmt|;
name|maxsz
operator|=
name|pp
operator|->
name|p_size
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
operator|>
name|ra
operator|->
name|ra_dsize
condition|)
name|maxsz
operator|=
name|ra
operator|->
name|ra_dsize
operator|-
name|pp
operator|->
name|p_offset
expr_stmt|;
name|sz
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|>>
name|DEV_BSHIFT
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|+
name|pp
operator|->
name|p_offset
operator|<=
name|LABELSECTOR
operator|&&
if|#
directive|if
name|LABELSECTOR
operator|!=
literal|0
name|bp
operator|->
name|b_blkno
operator|+
name|pp
operator|->
name|p_offset
operator|+
name|sz
operator|>
name|LABELSECTOR
operator|&&
endif|#
directive|endif
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|&&
name|ra
operator|->
name|ra_wlabel
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|||
name|bp
operator|->
name|b_blkno
operator|+
name|sz
operator|>
name|maxsz
condition|)
block|{
comment|/* if exactly at end of disk, return an EOF */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|maxsz
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* or truncate if part of it fits */
name|sz
operator|=
name|maxsz
operator|-
name|bp
operator|->
name|b_blkno
expr_stmt|;
if|if
condition|(
name|sz
operator|<=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
comment|/* or hang it up */
goto|goto
name|bad
goto|;
block|}
name|bp
operator|->
name|b_bcount
operator|=
name|sz
operator|<<
name|DEV_BSHIFT
expr_stmt|;
block|}
name|udastrat1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Work routine for udastrategy.  */
end_comment

begin_expr_stmt
name|udastrat1
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|udaunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|int
name|s
init|=
name|spl5
argument_list|()
decl_stmt|;
comment|/* 	 * Append the buffer to the drive queue, and if it is not 	 * already there, the drive to the controller queue.  (However, 	 * if the drive queue is marked to be requeued, we must be 	 * awaiting an on line or get unit status command; in this 	 * case, leave it off the controller queue.) 	 */
name|um
operator|=
operator|(
name|ui
operator|=
name|udadinfo
index|[
name|unit
index|]
operator|)
operator|->
name|ui_mi
expr_stmt|;
name|dp
operator|=
operator|&
name|udautab
index|[
name|unit
index|]
expr_stmt|;
name|APPEND
argument_list|(
name|bp
argument_list|,
name|dp
argument_list|,
name|av_forw
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
operator|&&
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_REQUEUE
operator|)
operator|==
literal|0
condition|)
block|{
name|APPEND
argument_list|(
name|dp
argument_list|,
operator|&
name|um
operator|->
name|um_tab
argument_list|,
name|b_forw
argument_list|)
expr_stmt|;
name|dp
operator|->
name|b_active
operator|++
expr_stmt|;
block|}
comment|/* 	 * Start activity on the controller.  Note that unlike other 	 * Unibus drivers, we must always do this, not just when the 	 * controller is not active. 	 */
name|udastart
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start up whatever transfers we can find.  * Note that udastart() must be called at spl5().  */
end_comment

begin_expr_stmt
name|udastart
argument_list|(
name|um
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|uda_softc
modifier|*
name|sc
init|=
operator|&
name|uda_softc
index|[
name|um
operator|->
name|um_ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|struct
name|udadevice
modifier|*
name|udaddr
decl_stmt|;
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sz
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|i
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If it is not running, try (again and again...) to initialise 	 * it.  If it is currently initialising just ignore it for now. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|ST_RUN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ST_IDLE
operator|&&
name|udainit
argument_list|(
name|um
operator|->
name|um_ctlr
argument_list|)
condition|)
name|printf
argument_list|(
literal|"uda%d: still hung\n"
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If um_cmd is nonzero, this controller is on the Unibus 	 * resource wait queue.  It will not help to try more requests; 	 * instead, when the Unibus unblocks and calls udadgo(), we 	 * will call udastart() again. 	 */
if|if
condition|(
name|um
operator|->
name|um_cmd
condition|)
return|return;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_INSTART
expr_stmt|;
name|udaddr
operator|=
operator|(
expr|struct
name|udadevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
name|loop
label|:
comment|/* 	 * Service the drive at the head of the queue.  It may not 	 * need anything, in which case it might be shutting down 	 * in udaclose(). 	 */
if|if
condition|(
operator|(
name|dp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
if|if
condition|(
name|ra_info
index|[
name|dp
operator|-
name|udautab
index|]
operator|.
name|ra_openpart
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|)
expr_stmt|;
comment|/* finish close protocol */
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|udaddr
operator|->
name|udasa
operator|&
name|UDA_ERR
condition|)
block|{
comment|/* ctlr fatal error */
name|udasaerror
argument_list|(
name|um
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Get an MSCP packet, then figure out what to do.  If 	 * we cannot get a command packet, the command ring may 	 * be too small:  We should have at least as many command 	 * packets as credits, for best performance. 	 */
if|if
condition|(
operator|(
name|mp
operator|=
name|mscp_getcp
argument_list|(
operator|&
name|sc
operator|->
name|sc_mi
argument_list|,
name|MSCP_DONTWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_mi
operator|.
name|mi_credits
operator|>
name|MSCP_MINCREDITS
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_GRIPED
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"uda%d: command ring too small\n"
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_GRIPED
expr_stmt|;
comment|/* complain only once */
block|}
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Bring the drive on line if it is not already.  Get its status 	 * if we do not already have it.  Otherwise just start the transfer. 	 */
name|ui
operator|=
name|udadinfo
index|[
name|udaunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_ONLINE
operator|)
operator|==
literal|0
condition|)
block|{
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_ONLINE
expr_stmt|;
goto|goto
name|common
goto|;
block|}
if|if
condition|(
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_HAVESTATUS
operator|)
operator|==
literal|0
condition|)
block|{
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_GETUNITST
expr_stmt|;
name|common
label|:
if|if
condition|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_REQUEUE
condition|)
name|panic
argument_list|(
literal|"udastart"
argument_list|)
expr_stmt|;
comment|/* 		 * Take the drive off the controller queue.  When the 		 * command finishes, make sure the drive is requeued. 		 */
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|ui_flags
operator||=
name|UNIT_REQUEUE
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
operator|*
name|mp
operator|->
name|mscp_addr
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_STARTPOLL
expr_stmt|;
ifdef|#
directive|ifdef
name|POLLSTATS
name|sc
operator|->
name|sc_ncmd
operator|++
expr_stmt|;
endif|#
directive|endif
goto|goto
name|loop
goto|;
block|}
name|pp
operator|=
operator|&
name|udalabel
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|d_partitions
index|[
name|udapart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|mp
operator|->
name|mscp_opcode
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|M_OP_READ
else|:
name|M_OP_WRITE
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_lbn
operator|=
name|bp
operator|->
name|b_blkno
operator|+
name|pp
operator|->
name|p_offset
expr_stmt|;
name|sz
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|>>
name|DEV_BSHIFT
expr_stmt|;
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_bytecount
operator|=
name|bp
operator|->
name|b_blkno
operator|+
name|sz
operator|>
name|pp
operator|->
name|p_size
condition|?
operator|(
name|pp
operator|->
name|p_size
operator|-
name|bp
operator|->
name|b_blkno
operator|)
operator|>>
name|DEV_BSHIFT
else|:
name|bp
operator|->
name|b_bcount
expr_stmt|;
comment|/* mscp_cmdref is filled in by mscp_go() */
comment|/* 	 * Drop the packet pointer into the `command' field so udadgo() 	 * can tell what to start.  If ubago returns 1, we can do another 	 * transfer.  If not, um_cmd will still point at mp, so we will 	 * know that we are waiting for resources. 	 */
name|um
operator|->
name|um_cmd
operator|=
operator|(
name|int
operator|)
name|mp
expr_stmt|;
if|if
condition|(
name|ubago
argument_list|(
name|ui
argument_list|)
condition|)
goto|goto
name|loop
goto|;
comment|/* 	 * All done, or blocked in ubago().  If we managed to 	 * issue some commands, start up the beast. 	 */
name|out
label|:
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_STARTPOLL
condition|)
block|{
ifdef|#
directive|ifdef
name|POLLSTATS
name|udastats
operator|.
name|cmd
index|[
name|sc
operator|->
name|sc_ncmd
index|]
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ncmd
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
operator|(
operator|(
expr|struct
name|udadevice
operator|*
operator|)
name|um
operator|->
name|um_addr
operator|)
operator|->
name|udaip
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|SC_INSTART
operator||
name|SC_STARTPOLL
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start a transfer.  *  * If we are not called from within udastart(), we must have been  * blocked, so call udastart to do more requests (if any).  If  * this calls us again immediately we will not recurse, because  * that time we will be in udastart().  Clever....  */
end_comment

begin_expr_stmt
name|udadgo
argument_list|(
name|um
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|uda_softc
modifier|*
name|sc
init|=
operator|&
name|uda_softc
index|[
name|um
operator|->
name|um_ctlr
index|]
decl_stmt|;
name|struct
name|mscp
modifier|*
name|mp
init|=
operator|(
expr|struct
name|mscp
operator|*
operator|)
name|um
operator|->
name|um_cmd
decl_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|++
expr_stmt|;
comment|/* another transfer going */
comment|/* 	 * Fill in the MSCP packet and move the buffer to the 	 * I/O wait queue.  Mark the controller as no longer on 	 * the resource queue, and remember to initiate polling. 	 */
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_buffer
operator|=
name|UBAI_ADDR
argument_list|(
name|um
operator|->
name|um_ubinfo
argument_list|)
operator||
operator|(
name|UBAI_BDP
argument_list|(
name|um
operator|->
name|um_ubinfo
argument_list|)
operator|<<
literal|24
operator|)
expr_stmt|;
name|mscp_go
argument_list|(
operator|&
name|sc
operator|->
name|sc_mi
argument_list|,
name|mp
argument_list|,
name|um
operator|->
name|um_ubinfo
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_cmd
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_ubinfo
operator|=
literal|0
expr_stmt|;
comment|/* tyke it awye */
name|sc
operator|->
name|sc_flags
operator||=
name|SC_STARTPOLL
expr_stmt|;
ifdef|#
directive|ifdef
name|POLLSTATS
name|sc
operator|->
name|sc_ncmd
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_INSTART
operator|)
operator|==
literal|0
condition|)
name|udastart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|udaiodone
argument_list|(
name|mi
argument_list|,
name|bp
argument_list|,
name|info
argument_list|)
specifier|register
expr|struct
name|mscp_info
operator|*
name|mi
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|info
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
init|=
name|udaminfo
index|[
name|mi
operator|->
name|mi_ctlr
index|]
decl_stmt|;
name|um
operator|->
name|um_ubinfo
operator|=
name|info
expr_stmt|;
name|ubadone
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_bdp
operator|&&
name|mi
operator|->
name|mi_wtab
operator|.
name|av_forw
operator|==
operator|&
name|mi
operator|->
name|mi_wtab
condition|)
name|ubarelse
argument_list|(
name|um
operator|->
name|um_ubanum
argument_list|,
operator|&
name|um
operator|->
name|um_bdp
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|--
expr_stmt|;
comment|/* another transfer done */
block|}
end_block

begin_struct
specifier|static
struct|struct
name|saerr
block|{
name|int
name|code
decl_stmt|;
comment|/* error code (including UDA_ERR) */
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* what it means: Efoo => foo error */
block|}
name|saerr
index|[]
init|=
block|{
block|{
literal|0100001
block|,
literal|"Eunibus packet read"
block|}
block|,
block|{
literal|0100002
block|,
literal|"Eunibus packet write"
block|}
block|,
block|{
literal|0100003
block|,
literal|"EUDA ROM and RAM parity"
block|}
block|,
block|{
literal|0100004
block|,
literal|"EUDA RAM parity"
block|}
block|,
block|{
literal|0100005
block|,
literal|"EUDA ROM parity"
block|}
block|,
block|{
literal|0100006
block|,
literal|"Eunibus ring read"
block|}
block|,
block|{
literal|0100007
block|,
literal|"Eunibus ring write"
block|}
block|,
block|{
literal|0100010
block|,
literal|" unibus interrupt master failure"
block|}
block|,
block|{
literal|0100011
block|,
literal|"Ehost access timeout"
block|}
block|,
block|{
literal|0100012
block|,
literal|" host exceeded command limit"
block|}
block|,
block|{
literal|0100013
block|,
literal|" unibus bus master failure"
block|}
block|,
block|{
literal|0100014
block|,
literal|" DM XFC fatal error"
block|}
block|,
block|{
literal|0100015
block|,
literal|" hardware timeout of instruction loop"
block|}
block|,
block|{
literal|0100016
block|,
literal|" invalid virtual circuit id"
block|}
block|,
block|{
literal|0100017
block|,
literal|"Eunibus interrupt write"
block|}
block|,
block|{
literal|0104000
block|,
literal|"Efatal sequence"
block|}
block|,
block|{
literal|0104040
block|,
literal|" D proc ALU"
block|}
block|,
block|{
literal|0104041
block|,
literal|"ED proc control ROM parity"
block|}
block|,
block|{
literal|0105102
block|,
literal|"ED proc w/no BD#2 or RAM parity"
block|}
block|,
block|{
literal|0105105
block|,
literal|"ED proc RAM buffer"
block|}
block|,
block|{
literal|0105152
block|,
literal|"ED proc SDI"
block|}
block|,
block|{
literal|0105153
block|,
literal|"ED proc write mode wrap serdes"
block|}
block|,
block|{
literal|0105154
block|,
literal|"ED proc read mode serdes, RSGEN& ECC"
block|}
block|,
block|{
literal|0106040
block|,
literal|"EU proc ALU"
block|}
block|,
block|{
literal|0106041
block|,
literal|"EU proc control reg"
block|}
block|,
block|{
literal|0106042
block|,
literal|" U proc DFAIL/cntl ROM parity/BD #1 test CNT"
block|}
block|,
block|{
literal|0106047
block|,
literal|" U proc const PROM err w/D proc running SDI test"
block|}
block|,
block|{
literal|0106055
block|,
literal|" unexpected trap"
block|}
block|,
block|{
literal|0106071
block|,
literal|"EU proc const PROM"
block|}
block|,
block|{
literal|0106072
block|,
literal|"EU proc control ROM parity"
block|}
block|,
block|{
literal|0106200
block|,
literal|"Estep 1 data"
block|}
block|,
block|{
literal|0107103
block|,
literal|"EU proc RAM parity"
block|}
block|,
block|{
literal|0107107
block|,
literal|"EU proc RAM buffer"
block|}
block|,
block|{
literal|0107115
block|,
literal|" test count wrong (BD 12)"
block|}
block|,
block|{
literal|0112300
block|,
literal|"Estep 2"
block|}
block|,
block|{
literal|0122240
block|,
literal|"ENPR"
block|}
block|,
block|{
literal|0122300
block|,
literal|"Estep 3"
block|}
block|,
block|{
literal|0142300
block|,
literal|"Estep 4"
block|}
block|,
block|{
literal|0
block|,
literal|" unknown error code"
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * If the error bit was set in the controller status register, gripe,  * then (optionally) reset the controller and requeue pending transfers.  */
end_comment

begin_expr_stmt
name|udasaerror
argument_list|(
name|um
argument_list|,
name|doreset
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|doreset
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|code
init|=
operator|(
operator|(
expr|struct
name|udadevice
operator|*
operator|)
name|um
operator|->
name|um_addr
operator|)
operator|->
name|udasa
decl_stmt|;
specifier|register
name|struct
name|saerr
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
name|UDA_ERR
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|e
operator|=
name|saerr
init|;
name|e
operator|->
name|code
condition|;
name|e
operator|++
control|)
if|if
condition|(
name|e
operator|->
name|code
operator|==
name|code
condition|)
break|break;
name|printf
argument_list|(
literal|"uda%d: controller error, sa=0%o (%s%s)\n"
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|,
name|code
argument_list|,
name|e
operator|->
name|desc
operator|+
literal|1
argument_list|,
operator|*
name|e
operator|->
name|desc
operator|==
literal|'E'
condition|?
literal|" error"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|doreset
condition|)
block|{
name|mscp_requeue
argument_list|(
operator|&
name|uda_softc
index|[
name|um
operator|->
name|um_ctlr
index|]
operator|.
name|sc_mi
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|udainit
argument_list|(
name|um
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Interrupt routine.  Depending on the state of the controller,  * continue initialisation, or acknowledge command and response  * interrupts, and process responses.  */
end_comment

begin_macro
name|udaintr
argument_list|(
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
init|=
name|udaminfo
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|uda_softc
modifier|*
name|sc
init|=
operator|&
name|uda_softc
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|udadevice
modifier|*
name|udaddr
init|=
operator|(
expr|struct
name|udadevice
operator|*
operator|)
name|um
operator|->
name|um_addr
decl_stmt|;
specifier|register
name|struct
name|uda
modifier|*
name|ud
decl_stmt|;
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|QBA
name|splx
argument_list|(
name|sc
operator|->
name|sc_ipl
argument_list|)
expr_stmt|;
comment|/* Qbus interrupt protocol is odd */
endif|#
directive|endif
name|sc
operator|->
name|sc_wticks
operator|=
literal|0
expr_stmt|;
comment|/* reset interrupt watchdog */
comment|/* 	 * Combinations during steps 1, 2, and 3: STEPnMASK 	 * corresponds to which bits should be tested; 	 * STEPnGOOD corresponds to the pattern that should 	 * appear after the interrupt from STEPn initialisation. 	 * All steps test the bits in ALLSTEPS. 	 */
define|#
directive|define
name|ALLSTEPS
value|(UDA_ERR|UDA_STEP4|UDA_STEP3|UDA_STEP2|UDA_STEP1)
define|#
directive|define
name|STEP1MASK
value|(ALLSTEPS | UDA_IE | UDA_NCNRMASK)
define|#
directive|define
name|STEP1GOOD
value|(UDA_STEP2 | UDA_IE | (NCMDL2<< 3) | NRSPL2)
define|#
directive|define
name|STEP2MASK
value|(ALLSTEPS | UDA_IE | UDA_IVECMASK)
define|#
directive|define
name|STEP2GOOD
value|(UDA_STEP3 | UDA_IE | (sc->sc_ivec>> 2))
define|#
directive|define
name|STEP3MASK
value|ALLSTEPS
define|#
directive|define
name|STEP3GOOD
value|UDA_STEP4
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|ST_IDLE
case|:
comment|/* 		 * Ignore unsolicited interrupts. 		 */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"uda%d: stray intr\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return;
case|case
name|ST_STEP1
case|:
comment|/* 		 * Begin step two initialisation. 		 */
if|if
condition|(
operator|(
name|udaddr
operator|->
name|udasa
operator|&
name|STEP1MASK
operator|)
operator|!=
name|STEP1GOOD
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|initfailed
label|:
name|printf
argument_list|(
literal|"uda%d: init step %d failed, sa=%b\n"
argument_list|,
name|ctlr
argument_list|,
name|i
argument_list|,
name|udaddr
operator|->
name|udasa
argument_list|,
name|udasr_bits
argument_list|)
expr_stmt|;
name|udasaerror
argument_list|(
name|um
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_IDLE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DOWAKE
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_DOWAKE
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|udaddr
operator|->
name|udasa
operator|=
operator|(
name|int
operator|)
operator|&
name|sc
operator|->
name|sc_uda
operator|->
name|uda_ca
operator|.
name|ca_rspdsc
index|[
literal|0
index|]
operator||
operator|(
name|cpu
operator|==
name|VAX_780
operator|||
name|cpu
operator|==
name|VAX_8600
condition|?
name|UDA_PI
else|:
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_STEP2
expr_stmt|;
return|return;
case|case
name|ST_STEP2
case|:
comment|/* 		 * Begin step 3 initialisation. 		 */
if|if
condition|(
operator|(
name|udaddr
operator|->
name|udasa
operator|&
name|STEP2MASK
operator|)
operator|!=
name|STEP2GOOD
condition|)
block|{
name|i
operator|=
literal|2
expr_stmt|;
goto|goto
name|initfailed
goto|;
block|}
name|udaddr
operator|->
name|udasa
operator|=
operator|(
operator|(
name|int
operator|)
operator|&
name|sc
operator|->
name|sc_uda
operator|->
name|uda_ca
operator|.
name|ca_rspdsc
index|[
literal|0
index|]
operator|)
operator|>>
literal|16
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_STEP3
expr_stmt|;
return|return;
case|case
name|ST_STEP3
case|:
comment|/* 		 * Set controller characteristics (finish initialisation). 		 */
if|if
condition|(
operator|(
name|udaddr
operator|->
name|udasa
operator|&
name|STEP3MASK
operator|)
operator|!=
name|STEP3GOOD
condition|)
block|{
name|i
operator|=
literal|3
expr_stmt|;
goto|goto
name|initfailed
goto|;
block|}
name|i
operator|=
name|udaddr
operator|->
name|udasa
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|sc
operator|->
name|sc_micro
condition|)
block|{
name|sc
operator|->
name|sc_micro
operator|=
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"uda%d: version %d model %d\n"
argument_list|,
name|ctlr
argument_list|,
name|i
operator|&
literal|0xf
argument_list|,
name|i
operator|>>
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Present the burst size, then remove it.  Why this 		 * should be done this way, I have no idea. 		 * 		 * Note that this assumes udaburst[ctlr]> 0. 		 */
name|udaddr
operator|->
name|udasa
operator|=
name|UDA_GO
operator||
operator|(
name|udaburst
index|[
name|ctlr
index|]
operator|-
literal|1
operator|)
operator|<<
literal|2
expr_stmt|;
name|udaddr
operator|->
name|udasa
operator|=
name|UDA_GO
expr_stmt|;
name|printf
argument_list|(
literal|"uda%d: DMA burst size set to %d\n"
argument_list|,
name|ctlr
argument_list|,
name|udaburst
index|[
name|ctlr
index|]
argument_list|)
expr_stmt|;
name|udainitds
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
comment|/* initialise data structures */
comment|/* 		 * Before we can get a command packet, we need some 		 * credits.  Fake some up to keep mscp_getcp() happy, 		 * get a packet, and cancel all credits (the right 		 * number should come back in the response to the 		 * SCC packet). 		 */
name|sc
operator|->
name|sc_mi
operator|.
name|mi_credits
operator|=
name|MSCP_MINCREDITS
operator|+
literal|1
expr_stmt|;
name|mp
operator|=
name|mscp_getcp
argument_list|(
operator|&
name|sc
operator|->
name|sc_mi
argument_list|,
name|MSCP_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
comment|/* `cannot happen' */
name|panic
argument_list|(
literal|"udaintr"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mi
operator|.
name|mi_credits
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_SETCTLRC
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_sccc
operator|.
name|sccc_ctlrflags
operator|=
name|M_CF_ATTN
operator||
name|M_CF_MISC
operator||
name|M_CF_THIS
expr_stmt|;
operator|*
name|mp
operator|->
name|mscp_addr
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
name|i
operator|=
name|udaddr
operator|->
name|udaip
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_SETCHAR
expr_stmt|;
return|return;
case|case
name|ST_SETCHAR
case|:
case|case
name|ST_RUN
case|:
comment|/* 		 * Handle Set Ctlr Characteristics responses and operational 		 * responses (via mscp_dorsp). 		 */
break|break;
default|default:
name|printf
argument_list|(
literal|"uda%d: driver bug, state %d\n"
argument_list|,
name|ctlr
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"udastate"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|udaddr
operator|->
name|udasa
operator|&
name|UDA_ERR
condition|)
block|{
comment|/* ctlr fatal error */
name|udasaerror
argument_list|(
name|um
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ud
operator|=
operator|&
name|uda
index|[
name|ctlr
index|]
expr_stmt|;
comment|/* 	 * Handle buffer purge requests. 	 */
if|if
condition|(
name|ud
operator|->
name|uda_ca
operator|.
name|ca_bdp
condition|)
block|{
name|UBAPURGE
argument_list|(
name|um
operator|->
name|um_hd
operator|->
name|uh_uba
argument_list|,
name|ud
operator|->
name|uda_ca
operator|.
name|ca_bdp
argument_list|)
expr_stmt|;
name|ud
operator|->
name|uda_ca
operator|.
name|ca_bdp
operator|=
literal|0
expr_stmt|;
name|udaddr
operator|->
name|udasa
operator|=
literal|0
expr_stmt|;
comment|/* signal purge complete */
block|}
comment|/* 	 * Check for response and command ring transitions. 	 */
if|if
condition|(
name|ud
operator|->
name|uda_ca
operator|.
name|ca_rspint
condition|)
block|{
name|ud
operator|->
name|uda_ca
operator|.
name|ca_rspint
operator|=
literal|0
expr_stmt|;
name|mscp_dorsp
argument_list|(
operator|&
name|sc
operator|->
name|sc_mi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ud
operator|->
name|uda_ca
operator|.
name|ca_cmdint
condition|)
block|{
name|ud
operator|->
name|uda_ca
operator|.
name|ca_cmdint
operator|=
literal|0
expr_stmt|;
name|MSCP_DOCMD
argument_list|(
operator|&
name|sc
operator|->
name|sc_mi
argument_list|)
expr_stmt|;
block|}
name|udastart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialise the various data structures that control the UDA50.  */
end_comment

begin_macro
name|udainitds
argument_list|(
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uda
modifier|*
name|ud
init|=
operator|&
name|uda
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|uda
modifier|*
name|uud
init|=
name|uda_softc
index|[
name|ctlr
index|]
operator|.
name|sc_uda
decl_stmt|;
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mp
operator|=
name|ud
operator|->
name|uda_rsp
init|;
name|i
operator|<
name|NRSP
condition|;
name|i
operator|++
operator|,
name|mp
operator|++
control|)
block|{
name|ud
operator|->
name|uda_ca
operator|.
name|ca_rspdsc
index|[
name|i
index|]
operator|=
name|MSCP_OWN
operator||
name|MSCP_INT
operator||
operator|(
name|long
operator|)
operator|&
name|uud
operator|->
name|uda_rsp
index|[
name|i
index|]
operator|.
name|mscp_cmdref
expr_stmt|;
name|mp
operator|->
name|mscp_addr
operator|=
operator|&
name|ud
operator|->
name|uda_ca
operator|.
name|ca_rspdsc
index|[
name|i
index|]
expr_stmt|;
name|mp
operator|->
name|mscp_msglen
operator|=
name|MSCP_MSGLEN
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mp
operator|=
name|ud
operator|->
name|uda_cmd
init|;
name|i
operator|<
name|NCMD
condition|;
name|i
operator|++
operator|,
name|mp
operator|++
control|)
block|{
name|ud
operator|->
name|uda_ca
operator|.
name|ca_cmddsc
index|[
name|i
index|]
operator|=
name|MSCP_INT
operator||
operator|(
name|long
operator|)
operator|&
name|uud
operator|->
name|uda_cmd
index|[
name|i
index|]
operator|.
name|mscp_cmdref
expr_stmt|;
name|mp
operator|->
name|mscp_addr
operator|=
operator|&
name|ud
operator|->
name|uda_ca
operator|.
name|ca_cmddsc
index|[
name|i
index|]
expr_stmt|;
name|mp
operator|->
name|mscp_msglen
operator|=
name|MSCP_MSGLEN
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Handle an error datagram.  */
end_comment

begin_macro
name|udadgram
argument_list|(
argument|mi
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mscp_info
modifier|*
name|mi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mscp_decodeerror
argument_list|(
name|mi
operator|->
name|mi_md
operator|->
name|md_mname
argument_list|,
name|mi
operator|->
name|mi_ctlr
argument_list|,
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * SDI status information bytes 10 and 11 are the microprocessor 	 * error code and front panel code respectively.  These vary per 	 * drive type and are printed purely for field service information. 	 */
if|if
condition|(
name|mp
operator|->
name|mscp_format
operator|==
name|M_FM_SDI
condition|)
name|printf
argument_list|(
literal|"\tsdi uproc error code 0x%x, front panel code 0x%x\n"
argument_list|,
name|mp
operator|->
name|mscp_erd
operator|.
name|erd_sdistat
index|[
literal|10
index|]
argument_list|,
name|mp
operator|->
name|mscp_erd
operator|.
name|erd_sdistat
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The Set Controller Characteristics command finished.  * Record the new state of the controller.  */
end_comment

begin_expr_stmt
name|udactlrdone
argument_list|(
name|mi
argument_list|,
name|mp
argument_list|)
specifier|register
expr|struct
name|mscp_info
operator|*
name|mi
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uda_softc
modifier|*
name|sc
init|=
operator|&
name|uda_softc
index|[
name|mi
operator|->
name|mi_ctlr
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
operator|)
operator|==
name|M_ST_SUCCESS
condition|)
name|sc
operator|->
name|sc_state
operator|=
name|ST_RUN
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"uda%d: SETCTLRC failed: "
argument_list|,
name|mi
operator|->
name|mi_ctlr
argument_list|,
name|mp
operator|->
name|mscp_status
argument_list|)
expr_stmt|;
name|mscp_printevent
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_IDLE
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DOWAKE
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_DOWAKE
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Received a response from an as-yet unconfigured drive.  Configure it  * in, if possible.  */
end_comment

begin_macro
name|udaunconf
argument_list|(
argument|mi
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mscp_info
modifier|*
name|mi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * If it is a slave response, copy it to udaslavereply for 	 * udaslave() to look at. 	 */
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
operator|==
operator|(
name|M_OP_GETUNITST
operator||
name|M_OP_END
operator|)
operator|&&
operator|(
name|uda_softc
index|[
name|mi
operator|->
name|mi_ctlr
index|]
operator|.
name|sc_flags
operator|&
name|SC_INSLAVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|udaslavereply
operator|=
operator|*
name|mp
expr_stmt|;
return|return
operator|(
name|MSCP_DONE
operator|)
return|;
block|}
comment|/* 	 * Otherwise, it had better be an available attention response. 	 */
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
operator|!=
name|M_OP_AVAILATTN
condition|)
return|return
operator|(
name|MSCP_FAILED
operator|)
return|;
comment|/* do what autoconf does */
return|return
operator|(
name|MSCP_FAILED
operator|)
return|;
comment|/* not yet, arwhite, not yet */
block|}
end_block

begin_comment
comment|/*  * A drive came on line.  Check its type and size.  Return DONE if  * we think the drive is truly on line.  In any case, awaken anyone  * sleeping on the drive on-line-ness.  */
end_comment

begin_expr_stmt
name|udaonline
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ra_info
modifier|*
name|ra
init|=
operator|&
name|ra_info
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ui
operator|->
name|ui_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
operator|)
operator|!=
name|M_ST_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|cold
condition|)
name|printf
argument_list|(
literal|"uda%d: ra%d"
argument_list|,
name|ui
operator|->
name|ui_ctlr
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": attempt to bring on line failed: "
argument_list|)
expr_stmt|;
name|mscp_printevent
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ra
operator|->
name|ra_state
operator|=
name|CLOSED
expr_stmt|;
return|return
operator|(
name|MSCP_FAILED
operator|)
return|;
block|}
name|ra
operator|->
name|ra_state
operator|=
name|OPENRAW
expr_stmt|;
name|ra
operator|->
name|ra_dsize
operator|=
operator|(
name|daddr_t
operator|)
name|mp
operator|->
name|mscp_onle
operator|.
name|onle_unitsize
expr_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
name|printf
argument_list|(
literal|"ra%d: uda%d, unit %d, size = %d sectors\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|ui
operator|->
name|ui_ctlr
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|ra
operator|->
name|ra_dsize
argument_list|)
expr_stmt|;
comment|/* can now compute ncyl */
name|ra
operator|->
name|ra_geom
operator|.
name|rg_ncyl
operator|=
name|ra
operator|->
name|ra_dsize
operator|/
name|ra
operator|->
name|ra_geom
operator|.
name|rg_ntracks
operator|/
name|ra
operator|->
name|ra_geom
operator|.
name|rg_nsectors
expr_stmt|;
return|return
operator|(
name|MSCP_DONE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * We got some (configured) unit's status.  Return DONE if it succeeded.  */
end_comment

begin_expr_stmt
name|udagotstatus
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
operator|)
operator|!=
name|M_ST_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"uda%d: attempt to get status for ra%d failed: "
argument_list|,
name|ui
operator|->
name|ui_ctlr
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
name|mscp_printevent
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|MSCP_FAILED
operator|)
return|;
block|}
comment|/* record for (future) bad block forwarding and whatever else */
name|uda_rasave
argument_list|(
name|ui
operator|->
name|ui_unit
argument_list|,
name|mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|MSCP_DONE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * A transfer failed.  We get a chance to fix or restart it.  * Need to write the bad block forwaring code first....  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|udaioerror
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|mp
operator|->
name|mscp_flags
operator|&
name|M_EF_BBLKR
condition|)
block|{
comment|/* 		 * A bad block report.  Eventually we will 		 * restart this transfer, but for now, just 		 * log it and give up. 		 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ra%d: bad block report: %d%s\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_lbn
argument_list|,
name|mp
operator|->
name|mscp_flags
operator|&
name|M_EF_BBLKU
condition|?
literal|" + others"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * What the heck IS a `serious exception' anyway? 		 * IT SURE WOULD BE NICE IF DEC SOLD DOCUMENTATION 		 * FOR THEIR OWN CONTROLLERS. 		 */
if|if
condition|(
name|mp
operator|->
name|mscp_flags
operator|&
name|M_EF_SEREX
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ra%d: serious exception reported\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|MSCP_FAILED
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * A replace operation finished.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|udareplace
argument_list|(
argument|ui
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|panic
argument_list|(
literal|"udareplace"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * A bad block related operation finished.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|udabb
argument_list|(
argument|ui
argument_list|,
argument|mp
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|panic
argument_list|(
literal|"udabb"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * I/O controls.  */
end_comment

begin_macro
name|udaioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|udaunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|ra_info
modifier|*
name|ra
init|=
operator|&
name|ra_info
index|[
name|unit
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|lp
operator|=
operator|&
name|udalabel
index|[
name|unit
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
operator|=
operator|*
name|lp
expr_stmt|;
break|break;
case|case
name|DIOCGPART
case|:
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|disklab
operator|=
name|lp
expr_stmt|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|part
operator|=
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|udapart
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|DIOCSDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|error
operator|=
name|setdisklabel
argument_list|(
name|lp
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
argument_list|,
operator|(
name|ra
operator|->
name|ra_state
operator|==
name|OPENRAW
operator|)
condition|?
literal|0
else|:
name|ra
operator|->
name|ra_openpart
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIOCWLABEL
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|ra
operator|->
name|ra_wlabel
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|DIOCWDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|setdisklabel
argument_list|(
name|lp
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
argument_list|,
operator|(
name|ra
operator|->
name|ra_state
operator|==
name|OPENRAW
operator|)
condition|?
literal|0
else|:
name|ra
operator|->
name|ra_openpart
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|wlab
decl_stmt|;
name|ra
operator|->
name|ra_state
operator|=
name|OPEN
expr_stmt|;
comment|/* simulate opening partition 0 so write succeeds */
name|ra
operator|->
name|ra_openpart
operator||=
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
comment|/* XXX */
name|wlab
operator|=
name|ra
operator|->
name|ra_wlabel
expr_stmt|;
name|ra
operator|->
name|ra_wlabel
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|writedisklabel
argument_list|(
name|dev
argument_list|,
name|udastrategy
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|ra
operator|->
name|ra_openpart
operator|=
name|ra
operator|->
name|ra_copenpart
operator||
name|ra
operator|->
name|ra_bopenpart
expr_stmt|;
name|ra
operator|->
name|ra_wlabel
operator|=
name|wlab
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|notyet
case|case
name|UDAIOCREPLACE
case|:
comment|/* 		 * Initiate bad block replacement for the given LBN. 		 * (Should we allow modifiers?) 		 */
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
case|case
name|UDAIOCGMICRO
case|:
comment|/* 		 * Return the microcode revision for the UDA50 running 		 * this drive. 		 */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|uda_softc
index|[
name|uddinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
index|]
operator|.
name|sc_micro
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * A Unibus reset has occurred on UBA uban.  Reinitialise the controller(s)  * on that Unibus, and requeue outstanding I/O.  */
end_comment

begin_macro
name|udareset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|struct
name|uda_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|;
for|for
control|(
name|ctlr
operator|=
literal|0
operator|,
name|sc
operator|=
name|uda_softc
init|;
name|ctlr
operator|<
name|NUDA
condition|;
name|ctlr
operator|++
operator|,
name|sc
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|um
operator|=
name|udaminfo
index|[
name|ctlr
index|]
operator|)
operator|==
name|NULL
operator|||
name|um
operator|->
name|um_ubanum
operator|!=
name|uban
operator|||
name|um
operator|->
name|um_alive
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|" uda%d"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
comment|/* 		 * Our BDP (if any) is gone; our command (if any) is 		 * flushed; the device is no longer mapped; and the 		 * UDA50 is not yet initialised. 		 */
if|if
condition|(
name|um
operator|->
name|um_bdp
condition|)
block|{
name|printf
argument_list|(
literal|"<%d>"
argument_list|,
name|UBAI_BDP
argument_list|(
name|um
operator|->
name|um_bdp
argument_list|)
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_bdp
operator|=
literal|0
expr_stmt|;
block|}
name|um
operator|->
name|um_ubinfo
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_cmd
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_MAPPED
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_IDLE
expr_stmt|;
comment|/* reset queues and requeue pending transfers */
name|mscp_requeue
argument_list|(
operator|&
name|sc
operator|->
name|sc_mi
argument_list|)
expr_stmt|;
comment|/* 		 * If it fails to initialise we will notice later and 		 * try again (and again...).  Do not call udastart() 		 * here; it will be done after the controller finishes 		 * initialisation. 		 */
if|if
condition|(
name|udainit
argument_list|(
name|ctlr
argument_list|)
condition|)
name|printf
argument_list|(
literal|" (hung)"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Watchdog timer:  If the controller is active, and no interrupts  * have occurred for 30 seconds, assume it has gone away.  */
end_comment

begin_macro
name|udawatch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|struct
name|uda_softc
modifier|*
name|sc
decl_stmt|;
name|timeout
argument_list|(
name|udawatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* every second */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sc
operator|=
name|uda_softc
init|;
name|i
operator|<
name|NUDA
condition|;
name|i
operator|++
operator|,
name|sc
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|um
operator|=
name|udaminfo
index|[
name|i
index|]
operator|)
operator|==
literal|0
operator|||
operator|!
name|um
operator|->
name|um_alive
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ST_IDLE
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ST_RUN
operator|&&
operator|!
name|um
operator|->
name|um_tab
operator|.
name|b_active
condition|)
name|sc
operator|->
name|sc_wticks
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_wticks
operator|>=
literal|30
condition|)
block|{
name|sc
operator|->
name|sc_wticks
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"uda%d: lost interrupt\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ubareset
argument_list|(
name|um
operator|->
name|um_ubanum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Do a panic dump.  We set up the controller for one command packet  * and one response packet, for which we use `struct uda1'.  */
end_comment

begin_struct
struct|struct
name|uda1
block|{
name|struct
name|uda1ca
name|uda1_ca
decl_stmt|;
comment|/* communications area */
name|struct
name|mscp
name|uda1_rsp
decl_stmt|;
comment|/* response packet */
name|struct
name|mscp
name|uda1_cmd
decl_stmt|;
comment|/* command packet */
block|}
name|uda1
struct|;
end_struct

begin_define
define|#
directive|define
name|DBSIZE
value|32
end_define

begin_comment
comment|/* dump 16K at a time */
end_comment

begin_macro
name|udadump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|udadevice
modifier|*
name|udaddr
decl_stmt|;
name|struct
name|uda1
modifier|*
name|ud_ubaddr
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|num
decl_stmt|,
name|blk
decl_stmt|,
name|unit
decl_stmt|,
name|maxsz
decl_stmt|,
name|blkoff
decl_stmt|,
name|reg
decl_stmt|;
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|uba_regs
modifier|*
name|uba
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|uda1
modifier|*
name|ud
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|io
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Make sure the device is a reasonable place on which to dump. 	 */
name|unit
operator|=
name|udaunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRA
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
define|#
directive|define
name|phys
parameter_list|(
name|cast
parameter_list|,
name|addr
parameter_list|)
value|((cast) ((int)addr& 0x7fffffff))
name|ui
operator|=
name|phys
argument_list|(
expr|struct
name|uba_device
operator|*
argument_list|,
name|udadinfo
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
operator|==
name|NULL
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Find and initialise the UBA; get the physical address of the 	 * device registers, and of communications area and command and 	 * response packet. 	 */
name|uba
operator|=
name|phys
argument_list|(
expr|struct
name|uba_hd
operator|*
argument_list|,
name|ui
operator|->
name|ui_hd
argument_list|)
operator|->
name|uh_physuba
expr_stmt|;
name|ubainit
argument_list|(
name|uba
argument_list|)
expr_stmt|;
name|udaddr
operator|=
operator|(
expr|struct
name|udadevice
operator|*
operator|)
name|ui
operator|->
name|ui_physaddr
expr_stmt|;
name|ud
operator|=
name|phys
argument_list|(
expr|struct
name|uda1
operator|*
argument_list|,
operator|&
name|uda1
argument_list|)
expr_stmt|;
comment|/* 	 * Map the ca+packets into Unibus I/O space so the UDA50 can get 	 * at them.  Use the registers at the end of the Unibus map (since 	 * we will use the registers at the beginning to map the memory 	 * we are dumping). 	 */
name|num
operator|=
name|btoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uda1
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|reg
operator|=
name|NUBMREG
operator|-
name|num
expr_stmt|;
name|io
operator|=
operator|&
name|uba
operator|->
name|uba_map
index|[
name|reg
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
name|io
operator|++
operator|=
name|UBAMR_MRV
operator||
operator|(
name|btop
argument_list|(
name|ud
argument_list|)
operator|+
name|i
operator|)
expr_stmt|;
name|ud_ubaddr
operator|=
operator|(
expr|struct
name|uda1
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|ud
operator|&
name|PGOFSET
operator|)
operator||
operator|(
name|reg
operator|<<
literal|9
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Initialise the controller, with one command and one response 	 * packet. 	 */
name|udaddr
operator|->
name|udaip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|udadumpwait
argument_list|(
name|udaddr
argument_list|,
name|UDA_STEP1
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|udaddr
operator|->
name|udasa
operator|=
name|UDA_ERR
expr_stmt|;
if|if
condition|(
name|udadumpwait
argument_list|(
name|udaddr
argument_list|,
name|UDA_STEP2
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|udaddr
operator|->
name|udasa
operator|=
operator|(
name|int
operator|)
operator|&
name|ud_ubaddr
operator|->
name|uda1_ca
operator|.
name|ca_rspdsc
expr_stmt|;
if|if
condition|(
name|udadumpwait
argument_list|(
name|udaddr
argument_list|,
name|UDA_STEP3
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|udaddr
operator|->
name|udasa
operator|=
operator|(
operator|(
name|int
operator|)
operator|&
name|ud_ubaddr
operator|->
name|uda1_ca
operator|.
name|ca_rspdsc
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|udadumpwait
argument_list|(
name|udaddr
argument_list|,
name|UDA_STEP4
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|uda_softc
index|[
name|ui
operator|->
name|ui_ctlr
index|]
operator|.
name|sc_micro
operator|=
name|udaddr
operator|->
name|udasa
operator|&
literal|0xff
expr_stmt|;
name|udaddr
operator|->
name|udasa
operator|=
name|UDA_GO
expr_stmt|;
comment|/* 	 * Set up the command and response descriptor, then set the 	 * controller characteristics and bring the drive on line. 	 * Note that all uninitialised locations in uda1_cmd are zero. 	 */
name|ud
operator|->
name|uda1_ca
operator|.
name|ca_rspdsc
operator|=
operator|(
name|long
operator|)
operator|&
name|ud_ubaddr
operator|->
name|uda1_rsp
operator|.
name|mscp_cmdref
expr_stmt|;
name|ud
operator|->
name|uda1_ca
operator|.
name|ca_cmddsc
operator|=
operator|(
name|long
operator|)
operator|&
name|ud_ubaddr
operator|->
name|uda1_cmd
operator|.
name|mscp_cmdref
expr_stmt|;
comment|/* ud->uda1_cmd.mscp_sccc.sccc_ctlrflags = 0; */
comment|/* ud->uda1_cmd.mscp_sccc.sccc_version = 0; */
if|if
condition|(
name|udadumpcmd
argument_list|(
name|M_OP_SETCTLRC
argument_list|,
name|ud
argument_list|,
name|ui
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|ud
operator|->
name|uda1_cmd
operator|.
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
if|if
condition|(
name|udadumpcmd
argument_list|(
name|M_OP_ONLINE
argument_list|,
name|ud
argument_list|,
name|ui
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|pp
operator|=
name|phys
argument_list|(
expr|struct
name|partition
operator|*
argument_list|,
operator|&
name|udalabel
index|[
name|unit
index|]
operator|.
name|d_partitions
index|[
name|udapart
argument_list|(
name|dev
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|maxsz
operator|=
name|pp
operator|->
name|p_size
expr_stmt|;
name|blkoff
operator|=
name|pp
operator|->
name|p_offset
expr_stmt|;
comment|/* 	 * Dump all of physical memory, or as much as will fit in the 	 * space provided. 	 */
name|start
operator|=
literal|0
expr_stmt|;
name|num
operator|=
name|maxfree
expr_stmt|;
if|if
condition|(
name|dumplo
operator|+
name|num
operator|>=
name|maxsz
condition|)
name|num
operator|=
name|maxsz
operator|-
name|dumplo
expr_stmt|;
name|blkoff
operator|+=
name|dumplo
expr_stmt|;
comment|/* 	 * Write out memory, DBSIZE pages at a time. 	 * N.B.: this code depends on the fact that the sector 	 * size == the page size. 	 */
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|blk
operator|=
name|num
operator|>
name|DBSIZE
condition|?
name|DBSIZE
else|:
name|num
expr_stmt|;
name|io
operator|=
name|uba
operator|->
name|uba_map
expr_stmt|;
comment|/* 		 * Map in the pages to write, leaving an invalid entry 		 * at the end to guard against wild Unibus transfers. 		 * Then do the write. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blk
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
name|io
operator|++
operator|=
name|UBAMR_MRV
operator||
operator|(
name|btop
argument_list|(
name|start
argument_list|)
operator|+
name|i
operator|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|io
operator|=
literal|0
expr_stmt|;
name|ud
operator|->
name|uda1_cmd
operator|.
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|ud
operator|->
name|uda1_cmd
operator|.
name|mscp_seq
operator|.
name|seq_lbn
operator|=
name|btop
argument_list|(
name|start
argument_list|)
operator|+
name|blkoff
expr_stmt|;
name|ud
operator|->
name|uda1_cmd
operator|.
name|mscp_seq
operator|.
name|seq_bytecount
operator|=
name|blk
operator|<<
name|PGSHIFT
expr_stmt|;
if|if
condition|(
name|udadumpcmd
argument_list|(
name|M_OP_WRITE
argument_list|,
name|ud
argument_list|,
name|ui
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|start
operator|+=
name|blk
operator|<<
name|PGSHIFT
expr_stmt|;
name|num
operator|-=
name|blk
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* made it! */
block|}
end_block

begin_comment
comment|/*  * Wait for some of the bits in `bits' to come on.  If the error bit  * comes on, or ten seconds pass without response, return true (error).  */
end_comment

begin_expr_stmt
name|udadumpwait
argument_list|(
name|udaddr
argument_list|,
name|bits
argument_list|)
specifier|register
expr|struct
name|udadevice
operator|*
name|udaddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|bits
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|timo
init|=
name|todr
argument_list|()
operator|+
literal|1000
decl_stmt|;
while|while
condition|(
operator|(
name|udaddr
operator|->
name|udasa
operator|&
name|bits
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|udaddr
operator|->
name|udasa
operator|&
name|UDA_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"udasa=%b\ndump "
argument_list|,
name|udaddr
operator|->
name|udasa
argument_list|,
name|udasr_bits
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|todr
argument_list|()
operator|>=
name|timo
condition|)
block|{
name|printf
argument_list|(
literal|"timeout\ndump "
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Feed a command to the UDA50, wait for its response, and return  * true iff something went wrong.  */
end_comment

begin_macro
name|udadumpcmd
argument_list|(
argument|op
argument_list|,
argument|ud
argument_list|,
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|uda1
modifier|*
name|ud
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|udadevice
modifier|*
name|udaddr
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
define|#
directive|define
name|mp
value|(&ud->uda1_rsp)
name|udaddr
operator|=
operator|(
expr|struct
name|udadevice
operator|*
operator|)
name|ui
operator|->
name|ui_physaddr
expr_stmt|;
name|ud
operator|->
name|uda1_cmd
operator|.
name|mscp_opcode
operator|=
name|op
expr_stmt|;
name|ud
operator|->
name|uda1_cmd
operator|.
name|mscp_msglen
operator|=
name|MSCP_MSGLEN
expr_stmt|;
name|ud
operator|->
name|uda1_rsp
operator|.
name|mscp_msglen
operator|=
name|MSCP_MSGLEN
expr_stmt|;
name|ud
operator|->
name|uda1_ca
operator|.
name|ca_rspdsc
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
name|ud
operator|->
name|uda1_ca
operator|.
name|ca_cmddsc
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
if|if
condition|(
name|udaddr
operator|->
name|udasa
operator|&
name|UDA_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"udasa=%b\ndump "
argument_list|,
name|udaddr
operator|->
name|udasa
argument_list|,
name|udasr_bits
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|n
operator|=
name|udaddr
operator|->
name|udaip
expr_stmt|;
name|n
operator|=
name|todr
argument_list|()
operator|+
literal|1000
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|todr
argument_list|()
operator|>
name|n
condition|)
block|{
name|printf
argument_list|(
literal|"timeout\ndump "
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ud
operator|->
name|uda1_ca
operator|.
name|ca_cmdint
condition|)
name|ud
operator|->
name|uda1_ca
operator|.
name|ca_cmdint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|uda1_ca
operator|.
name|ca_rspint
operator|==
literal|0
condition|)
continue|continue;
name|ud
operator|->
name|uda1_ca
operator|.
name|ca_rspint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
operator|==
operator|(
name|op
operator||
name|M_OP_END
operator|)
condition|)
break|break;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|MSCP_MSGTYPE
argument_list|(
name|mp
operator|->
name|mscp_msgtc
argument_list|)
condition|)
block|{
case|case
name|MSCPT_SEQ
case|:
name|printf
argument_list|(
literal|"sequential"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSCPT_DATAGRAM
case|:
name|mscp_decodeerror
argument_list|(
literal|"uda"
argument_list|,
name|ui
operator|->
name|ui_ctlr
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"datagram"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSCPT_CREDITS
case|:
name|printf
argument_list|(
literal|"credits"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSCPT_MAINTENANCE
case|:
name|printf
argument_list|(
literal|"maintenance"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown (type 0x%x)"
argument_list|,
name|MSCP_MSGTYPE
argument_list|(
name|mp
operator|->
name|mscp_msgtc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|" ignored\ndump "
argument_list|)
expr_stmt|;
name|ud
operator|->
name|uda1_ca
operator|.
name|ca_rspdsc
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
operator|)
operator|!=
name|M_ST_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"error: op 0x%x => 0x%x status 0x%x\ndump "
argument_list|,
name|op
argument_list|,
name|mp
operator|->
name|mscp_opcode
argument_list|,
name|mp
operator|->
name|mscp_status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|mp
block|}
end_block

begin_comment
comment|/*  * Return the size of a partition, if known, or -1 if not.  */
end_comment

begin_macro
name|udasize
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|udaunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRA
operator|||
operator|(
name|ui
operator|=
name|udadinfo
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
operator|||
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_ONLINE
operator|)
operator|==
literal|0
operator|||
name|ra_info
index|[
name|unit
index|]
operator|.
name|ra_state
operator|!=
name|OPEN
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|(
name|int
operator|)
name|udalabel
index|[
name|unit
index|]
operator|.
name|d_partitions
index|[
name|udapart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_42
end_ifdef

begin_comment
comment|/*  * Tables mapping unlabelled drives.  */
end_comment

begin_struct
struct|struct
name|size
block|{
name|daddr_t
name|nblocks
decl_stmt|;
name|daddr_t
name|blkoff
decl_stmt|;
block|}
name|ra60_sizes
index|[
literal|8
index|]
init|=
block|{
literal|15884
block|,
literal|0
block|,
comment|/* A=sectors 0 thru 15883 */
literal|33440
block|,
literal|15884
block|,
comment|/* B=sectors 15884 thru 49323 */
literal|400176
block|,
literal|0
block|,
comment|/* C=sectors 0 thru 400175 */
literal|82080
block|,
literal|49324
block|,
comment|/* 4.2 G => D=sectors 49324 thru 131403 */
literal|268772
block|,
literal|131404
block|,
comment|/* 4.2 H => E=sectors 131404 thru 400175 */
literal|350852
block|,
literal|49324
block|,
comment|/* F=sectors 49324 thru 400175 */
literal|157570
block|,
literal|242606
block|,
comment|/* UCB G => G=sectors 242606 thru 400175 */
literal|193282
block|,
literal|49324
block|,
comment|/* UCB H => H=sectors 49324 thru 242605 */
block|}
struct|,
name|ra70_sizes
index|[
literal|8
index|]
init|=
block|{
literal|15884
block|,
literal|0
block|,
comment|/* A=blk 0 thru 15883 */
literal|33440
block|,
literal|15972
block|,
comment|/* B=blk 15972 thru 49323 */
operator|-
literal|1
block|,
literal|0
block|,
comment|/* C=blk 0 thru end */
literal|15884
block|,
literal|341220
block|,
comment|/* D=blk 341220 thru 357103 */
literal|55936
block|,
literal|357192
block|,
comment|/* E=blk 357192 thru 413127 */
operator|-
literal|1
block|,
literal|413457
block|,
comment|/* F=blk 413457 thru end */
operator|-
literal|1
block|,
literal|341220
block|,
comment|/* G=blk 341220 thru end */
literal|291346
block|,
literal|49731
block|,
comment|/* H=blk 49731 thru 341076 */
block|}
struct|,
name|ra80_sizes
index|[
literal|8
index|]
init|=
block|{
literal|15884
block|,
literal|0
block|,
comment|/* A=sectors 0 thru 15883 */
literal|33440
block|,
literal|15884
block|,
comment|/* B=sectors 15884 thru 49323 */
literal|242606
block|,
literal|0
block|,
comment|/* C=sectors 0 thru 242605 */
literal|0
block|,
literal|0
block|,
comment|/* D=unused */
literal|193282
block|,
literal|49324
block|,
comment|/* UCB H => E=sectors 49324 thru 242605 */
literal|82080
block|,
literal|49324
block|,
comment|/* 4.2 G => F=sectors 49324 thru 131403 */
literal|192696
block|,
literal|49910
block|,
comment|/* G=sectors 49910 thru 242605 */
literal|111202
block|,
literal|131404
block|,
comment|/* 4.2 H => H=sectors 131404 thru 242605 */
block|}
struct|,
name|ra81_sizes
index|[
literal|8
index|]
init|=
block|{
comment|/*  * These are the new standard partition sizes for ra81's.  * An RA_COMPAT system is compiled with D, E, and F corresponding  * to the 4.2 partitions for G, H, and F respectively.  */
ifndef|#
directive|ifndef
name|UCBRA
literal|15884
block|,
literal|0
block|,
comment|/* A=sectors 0 thru 15883 */
literal|66880
block|,
literal|16422
block|,
comment|/* B=sectors 16422 thru 83301 */
literal|891072
block|,
literal|0
block|,
comment|/* C=sectors 0 thru 891071 */
ifdef|#
directive|ifdef
name|RA_COMPAT
literal|82080
block|,
literal|49324
block|,
comment|/* 4.2 G => D=sectors 49324 thru 131403 */
literal|759668
block|,
literal|131404
block|,
comment|/* 4.2 H => E=sectors 131404 thru 891071 */
literal|478582
block|,
literal|412490
block|,
comment|/* 4.2 F => F=sectors 412490 thru 891071 */
else|#
directive|else
literal|15884
block|,
literal|375564
block|,
comment|/* D=sectors 375564 thru 391447 */
literal|307200
block|,
literal|391986
block|,
comment|/* E=sectors 391986 thru 699185 */
literal|191352
block|,
literal|699720
block|,
comment|/* F=sectors 699720 thru 891071 */
endif|#
directive|endif
endif|RA_COMPAT
literal|515508
block|,
literal|375564
block|,
comment|/* G=sectors 375564 thru 891071 */
literal|291346
block|,
literal|83538
block|,
comment|/* H=sectors 83538 thru 374883 */
comment|/*  * These partitions correspond to the sizes used by sites at Berkeley,  * and by those sites that have received copies of the Berkeley driver  * with deltas 6.2 or greater (11/15/83).  */
else|#
directive|else
else|UCBRA
literal|15884
block|,
literal|0
block|,
comment|/* A=sectors 0 thru 15883 */
literal|33440
block|,
literal|15884
block|,
comment|/* B=sectors 15884 thru 49323 */
literal|891072
block|,
literal|0
block|,
comment|/* C=sectors 0 thru 891071 */
literal|15884
block|,
literal|242606
block|,
comment|/* D=sectors 242606 thru 258489 */
literal|307200
block|,
literal|258490
block|,
comment|/* E=sectors 258490 thru 565689 */
literal|325382
block|,
literal|565690
block|,
comment|/* F=sectors 565690 thru 891071 */
literal|648466
block|,
literal|242606
block|,
comment|/* G=sectors 242606 thru 891071 */
literal|193282
block|,
literal|49324
block|,
comment|/* H=sectors 49324 thru 242605 */
endif|#
directive|endif
endif|UCBRA
block|}
struct|,
name|ra82_sizes
index|[
literal|8
index|]
init|=
block|{
literal|15884
block|,
literal|0
block|,
comment|/* A=blk 0 thru 15883 */
literal|66880
block|,
literal|16245
block|,
comment|/* B=blk 16245 thru 83124 */
operator|-
literal|1
block|,
literal|0
block|,
comment|/* C=blk 0 thru end */
literal|15884
block|,
literal|375345
block|,
comment|/* D=blk 375345 thru 391228 */
literal|307200
block|,
literal|391590
block|,
comment|/* E=blk 391590 thru 698789 */
operator|-
literal|1
block|,
literal|699390
block|,
comment|/* F=blk 699390 thru end */
operator|-
literal|1
block|,
literal|375345
block|,
comment|/* G=blk 375345 thru end */
literal|291346
block|,
literal|83790
block|,
comment|/* H=blk 83790 thru 375135 */
block|}
struct|,
name|rc25_sizes
index|[
literal|8
index|]
init|=
block|{
literal|15884
block|,
literal|0
block|,
comment|/* A=blk 0 thru 15883 */
literal|10032
block|,
literal|15884
block|,
comment|/* B=blk 15884 thru 49323 */
operator|-
literal|1
block|,
literal|0
block|,
comment|/* C=blk 0 thru end */
literal|0
block|,
literal|0
block|,
comment|/* D=blk 340670 thru 356553 */
literal|0
block|,
literal|0
block|,
comment|/* E=blk 356554 thru 412489 */
literal|0
block|,
literal|0
block|,
comment|/* F=blk 412490 thru end */
operator|-
literal|1
block|,
literal|25916
block|,
comment|/* G=blk 49324 thru 131403 */
literal|0
block|,
literal|0
block|,
comment|/* H=blk 131404 thru end */
block|}
struct|,
name|rd52_sizes
index|[
literal|8
index|]
init|=
block|{
literal|15884
block|,
literal|0
block|,
comment|/* A=blk 0 thru 15883 */
literal|9766
block|,
literal|15884
block|,
comment|/* B=blk 15884 thru 25649 */
operator|-
literal|1
block|,
literal|0
block|,
comment|/* C=blk 0 thru end */
literal|0
block|,
literal|0
block|,
comment|/* D=unused */
literal|0
block|,
literal|0
block|,
comment|/* E=unused */
literal|0
block|,
literal|0
block|,
comment|/* F=unused */
operator|-
literal|1
block|,
literal|25650
block|,
comment|/* G=blk 25650 thru end */
literal|0
block|,
literal|0
block|,
comment|/* H=unused */
block|}
struct|,
name|rd53_sizes
index|[
literal|8
index|]
init|=
block|{
literal|15884
block|,
literal|0
block|,
comment|/* A=blk 0 thru 15883 */
literal|33440
block|,
literal|15884
block|,
comment|/* B=blk 15884 thru 49323 */
operator|-
literal|1
block|,
literal|0
block|,
comment|/* C=blk 0 thru end */
literal|0
block|,
literal|0
block|,
comment|/* D=unused */
literal|33440
block|,
literal|0
block|,
comment|/* E=blk 0 thru 33439 */
operator|-
literal|1
block|,
literal|33440
block|,
comment|/* F=blk 33440 thru end */
operator|-
literal|1
block|,
literal|49324
block|,
comment|/* G=blk 49324 thru end */
operator|-
literal|1
block|,
literal|15884
block|,
comment|/* H=blk 15884 thru end */
block|}
struct|,
name|rx50_sizes
index|[
literal|8
index|]
init|=
block|{
literal|800
block|,
literal|0
block|,
comment|/* A=blk 0 thru 799 */
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
comment|/* C=blk 0 thru end */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
struct|;
end_struct

begin_comment
comment|/*  * Media ID decoding table.  */
end_comment

begin_struct
struct|struct
name|udatypes
block|{
name|u_long
name|ut_id
decl_stmt|;
comment|/* media drive ID */
name|char
modifier|*
name|ut_name
decl_stmt|;
comment|/* drive type name */
name|struct
name|size
modifier|*
name|ut_sizes
decl_stmt|;
comment|/* partition tables */
name|int
name|ut_nsectors
decl_stmt|,
name|ut_ntracks
decl_stmt|,
name|ut_ncylinders
decl_stmt|;
block|}
name|udatypes
index|[]
init|=
block|{
block|{
name|MSCP_MKDRIVE2
argument_list|(
literal|'R'
argument_list|,
literal|'A'
argument_list|,
literal|60
argument_list|)
block|,
literal|"ra60"
block|,
name|ra60_sizes
block|,
literal|42
block|,
literal|4
block|,
literal|2382
block|}
block|,
block|{
name|MSCP_MKDRIVE2
argument_list|(
literal|'R'
argument_list|,
literal|'A'
argument_list|,
literal|70
argument_list|)
block|,
literal|"ra70"
block|,
name|ra70_sizes
block|,
literal|33
block|,
literal|11
block|,
literal|1507
block|}
block|,
block|{
name|MSCP_MKDRIVE2
argument_list|(
literal|'R'
argument_list|,
literal|'A'
argument_list|,
literal|80
argument_list|)
block|,
literal|"ra80"
block|,
name|ra80_sizes
block|,
literal|31
block|,
literal|14
block|,
literal|559
block|}
block|,
block|{
name|MSCP_MKDRIVE2
argument_list|(
literal|'R'
argument_list|,
literal|'A'
argument_list|,
literal|81
argument_list|)
block|,
literal|"ra81"
block|,
name|ra81_sizes
block|,
literal|51
block|,
literal|14
block|,
literal|1248
block|}
block|,
block|{
name|MSCP_MKDRIVE2
argument_list|(
literal|'R'
argument_list|,
literal|'A'
argument_list|,
literal|82
argument_list|)
block|,
literal|"ra82"
block|,
name|ra82_sizes
block|,
literal|57
block|,
literal|14
block|,
literal|1423
block|}
block|,
block|{
name|MSCP_MKDRIVE2
argument_list|(
literal|'R'
argument_list|,
literal|'C'
argument_list|,
literal|25
argument_list|)
block|,
literal|"rc25-removable"
block|,
name|rc25_sizes
block|,
literal|42
block|,
literal|4
block|,
literal|302
block|}
block|,
block|{
name|MSCP_MKDRIVE3
argument_list|(
literal|'R'
argument_list|,
literal|'C'
argument_list|,
literal|'F'
argument_list|,
literal|25
argument_list|)
block|,
literal|"rc25-fixed"
block|,
name|rc25_sizes
block|,
literal|42
block|,
literal|4
block|,
literal|302
block|}
block|,
block|{
name|MSCP_MKDRIVE2
argument_list|(
literal|'R'
argument_list|,
literal|'D'
argument_list|,
literal|52
argument_list|)
block|,
literal|"rd52"
block|,
name|rd52_sizes
block|,
literal|18
block|,
literal|7
block|,
literal|480
block|}
block|,
block|{
name|MSCP_MKDRIVE2
argument_list|(
literal|'R'
argument_list|,
literal|'D'
argument_list|,
literal|53
argument_list|)
block|,
literal|"rd53"
block|,
name|rd53_sizes
block|,
literal|18
block|,
literal|8
block|,
literal|963
block|}
block|,
block|{
name|MSCP_MKDRIVE2
argument_list|(
literal|'R'
argument_list|,
literal|'X'
argument_list|,
literal|50
argument_list|)
block|,
literal|"rx50"
block|,
name|rx50_sizes
block|,
literal|10
block|,
literal|1
block|,
literal|80
block|}
block|,
literal|0
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NTYPES
value|(sizeof(udatypes) / sizeof(*udatypes))
end_define

begin_macro
name|udamaptype
argument_list|(
argument|unit
argument_list|,
argument|lp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|udatypes
modifier|*
name|ut
decl_stmt|;
specifier|register
name|struct
name|size
modifier|*
name|sz
decl_stmt|;
specifier|register
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|ra_info
modifier|*
name|ra
init|=
operator|&
name|ra_info
index|[
name|unit
index|]
decl_stmt|;
name|i
operator|=
name|MSCP_MEDIA_DRIVE
argument_list|(
name|ra
operator|->
name|ra_mediaid
argument_list|)
expr_stmt|;
for|for
control|(
name|ut
operator|=
name|udatypes
init|;
name|ut
operator|->
name|ut_id
condition|;
name|ut
operator|++
control|)
if|if
condition|(
name|ut
operator|->
name|ut_id
operator|==
name|i
operator|&&
name|ut
operator|->
name|ut_nsectors
operator|==
name|ra
operator|->
name|ra_geom
operator|.
name|rg_nsectors
operator|&&
name|ut
operator|->
name|ut_ntracks
operator|==
name|ra
operator|->
name|ra_geom
operator|.
name|rg_ntracks
operator|&&
name|ut
operator|->
name|ut_ncylinders
operator|==
name|ra
operator|->
name|ra_geom
operator|.
name|rg_ncyl
condition|)
goto|goto
name|found
goto|;
comment|/* not one we know; fake up a label for the whole drive */
name|uda_makefakelabel
argument_list|(
name|ra
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|i
operator|=
name|ra
operator|->
name|ra_mediaid
expr_stmt|;
comment|/* print the port type too */
name|addlog
argument_list|(
literal|": no partition table for %c%c %c%c%c%d, size %d;\n\ using (s,t,c)=(%d,%d,%d)"
argument_list|,
name|MSCP_MID_CHAR
argument_list|(
literal|4
argument_list|,
name|i
argument_list|)
argument_list|,
name|MSCP_MID_CHAR
argument_list|(
literal|3
argument_list|,
name|i
argument_list|)
argument_list|,
name|MSCP_MID_CHAR
argument_list|(
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
name|MSCP_MID_CHAR
argument_list|(
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|MSCP_MID_CHAR
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|MSCP_MID_NUM
argument_list|(
name|i
argument_list|)
argument_list|,
name|lp
operator|->
name|d_secperunit
argument_list|,
name|lp
operator|->
name|d_nsectors
argument_list|,
name|lp
operator|->
name|d_ntracks
argument_list|,
name|lp
operator|->
name|d_ncylinders
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
name|addlog
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|found
label|:
name|p
operator|=
name|ut
operator|->
name|ut_name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|lp
operator|->
name|d_typename
argument_list|)
operator|-
literal|1
operator|&&
operator|*
name|p
condition|;
name|i
operator|++
control|)
name|lp
operator|->
name|d_typename
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|lp
operator|->
name|d_typename
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sz
operator|=
name|ut
operator|->
name|ut_sizes
expr_stmt|;
name|lp
operator|->
name|d_nsectors
operator|=
name|ut
operator|->
name|ut_nsectors
expr_stmt|;
name|lp
operator|->
name|d_ntracks
operator|=
name|ut
operator|->
name|ut_ntracks
expr_stmt|;
name|lp
operator|->
name|d_ncylinders
operator|=
name|ut
operator|->
name|ut_ncylinders
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
literal|8
expr_stmt|;
name|lp
operator|->
name|d_secpercyl
operator|=
name|lp
operator|->
name|d_nsectors
operator|*
name|lp
operator|->
name|d_ntracks
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|lp
operator|->
name|d_partitions
init|;
name|pp
operator|<
operator|&
name|lp
operator|->
name|d_partitions
index|[
literal|8
index|]
condition|;
name|pp
operator|++
operator|,
name|sz
operator|++
control|)
block|{
name|pp
operator|->
name|p_offset
operator|=
name|sz
operator|->
name|blkoff
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|->
name|p_size
operator|=
name|sz
operator|->
name|nblocks
operator|)
operator|==
operator|(
name|u_long
operator|)
operator|-
literal|1
condition|)
name|pp
operator|->
name|p_size
operator|=
name|ra
operator|->
name|ra_dsize
operator|-
name|sz
operator|->
name|blkoff
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_42 */
end_comment

begin_comment
comment|/*  * Construct a label for a drive from geometry information  * if we have no better information.  */
end_comment

begin_expr_stmt
name|uda_makefakelabel
argument_list|(
name|ra
argument_list|,
name|lp
argument_list|)
specifier|register
expr|struct
name|ra_info
operator|*
name|ra
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lp
operator|->
name|d_nsectors
operator|=
name|ra
operator|->
name|ra_geom
operator|.
name|rg_nsectors
expr_stmt|;
name|lp
operator|->
name|d_ntracks
operator|=
name|ra
operator|->
name|ra_geom
operator|.
name|rg_ntracks
expr_stmt|;
name|lp
operator|->
name|d_ncylinders
operator|=
name|ra
operator|->
name|ra_geom
operator|.
name|rg_ncyl
expr_stmt|;
name|lp
operator|->
name|d_secpercyl
operator|=
name|lp
operator|->
name|d_nsectors
operator|*
name|lp
operator|->
name|d_ntracks
expr_stmt|;
name|bcopy
argument_list|(
literal|"ra??"
argument_list|,
name|lp
operator|->
name|d_typename
argument_list|,
sizeof|sizeof
argument_list|(
literal|"ra??"
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|lp
operator|->
name|d_secperunit
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NUDA> 0 */
end_comment

end_unit

