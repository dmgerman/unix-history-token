begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	rx.c	4.2	83/02/21	*/
end_comment

begin_include
include|#
directive|include
file|"rx.h"
end_include

begin_if
if|#
directive|if
name|NFX
operator|>
literal|0
end_if

begin_comment
comment|/*  * RX02 floppy disk device driver  *  * WARNING, UNTESTED  */
end_comment

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/conf.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/time.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../h/uio.h"
end_include

begin_include
include|#
directive|include
file|"../h/file.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vax/nexus.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/rxreg.h"
end_include

begin_comment
comment|/* per-controller data */
end_comment

begin_struct
struct|struct
name|rx_ctlr
block|{
name|int
name|rxc_state
decl_stmt|;
comment|/* controller state */
define|#
directive|define
name|RXS_READ
value|1
comment|/* read started	*/
define|#
directive|define
name|RXS_EMPTY
value|2
comment|/* empty started */
define|#
directive|define
name|RXS_FILL
value|3
comment|/* fill started	*/
define|#
directive|define
name|RXS_WRITE
value|4
comment|/* write started */
define|#
directive|define
name|RXS_FORMAT
value|5
comment|/* format started */
define|#
directive|define
name|RXS_RDSTAT
value|6
comment|/* status read started */
define|#
directive|define
name|RXS_RDERR
value|7
comment|/* error read started */
define|#
directive|define
name|RXS_IDLE
value|8
comment|/* device is idle */
name|u_short
name|rxc_rxcs
decl_stmt|;
comment|/* extended error status */
name|u_short
name|rxc_rxdb
decl_stmt|;
name|u_short
name|rxc_rxxt
index|[
literal|4
index|]
decl_stmt|;
define|#
directive|define
name|RX_MAXTIMEOUT
value|30
comment|/* # seconds to wait before giving up */
block|}
name|rx_ctlr
index|[
name|NFX
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|buf
name|rrxbuf
index|[
name|NFX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for I/O */
end_comment

begin_decl_stmt
name|struct
name|buf
name|erxbuf
index|[
name|NFX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for reading error status */
end_comment

begin_comment
comment|/* per-drive data */
end_comment

begin_struct
struct|struct
name|rx_softc
block|{
name|int
name|sc_flags
decl_stmt|;
comment|/* drive status flags */
define|#
directive|define
name|RXF_DBLDEN
value|0x01
comment|/* use double density */
define|#
directive|define
name|RXF_DIRECT
value|0x02
comment|/* use direct sector mapping */
define|#
directive|define
name|RXF_TRKZERO
value|0x04
comment|/* start mapping on track 0 */
define|#
directive|define
name|RXF_DEVTYPE
value|0x07
comment|/* density and mapping flags */
define|#
directive|define
name|RXF_OPEN
value|0x10
comment|/* open */
define|#
directive|define
name|RXF_DDMK
value|0x20
comment|/* deleted-data mark detected */
define|#
directive|define
name|RXF_USEWDDS
value|0x40
comment|/* write deleted-data sector */
name|int
name|sc_csbits
decl_stmt|;
comment|/* constant bits for CS register */
name|int
name|sc_tocnt
decl_stmt|;
comment|/* for watchdog routine */
block|}
name|rx_softc
index|[
name|NRX
index|]
struct|;
end_struct

begin_struct
struct|struct
name|rxerr
block|{
name|short
name|rxcs
decl_stmt|;
name|short
name|rxdb
decl_stmt|;
name|short
name|rxxt
index|[
literal|4
index|]
decl_stmt|;
comment|/* error code dump from controller */
block|}
name|rxerr
index|[
name|NFX
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|rxdinfo
index|[
name|NRX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_ctlr
modifier|*
name|rxminfo
index|[
name|NFX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rxprobe
argument_list|()
decl_stmt|,
name|rxslave
argument_list|()
decl_stmt|,
name|rxattach
argument_list|()
decl_stmt|,
name|rxdgo
argument_list|()
decl_stmt|,
name|rxintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rxwatch
argument_list|()
decl_stmt|,
name|rxphys
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|rxstd
index|[]
init|=
block|{
literal|0177170
block|,
literal|0177150
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|fxdriver
init|=
block|{
name|rxprobe
block|,
name|rxslave
block|,
name|rxattach
block|,
name|rxdgo
block|,
name|rxstd
block|,
literal|"rx"
block|,
name|rxdinfo
block|,
literal|"fx"
block|,
name|rxminfo
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rxwstart
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RXUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>>4)
end_define

begin_comment
comment|/* constants related to floppy data capacity */
end_comment

begin_define
define|#
directive|define
name|RXSECS
value|2002
end_define

begin_comment
comment|/* # sectors on a floppy */
end_comment

begin_define
define|#
directive|define
name|DDSTATE
value|(sc->sc_flags&RXF_DBLDEN)
end_define

begin_define
define|#
directive|define
name|NBPS
value|(DDSTATE ? 256 : 128)
end_define

begin_comment
comment|/* # bytes per sector */
end_comment

begin_define
define|#
directive|define
name|NWPS
value|(DDSTATE ? 128 : 64)
end_define

begin_comment
comment|/* # words per sector */
end_comment

begin_define
define|#
directive|define
name|RXSIZE
value|(DDSTATE ? 512512 : 256256)
end_define

begin_comment
comment|/* # bytes per disk */
end_comment

begin_define
define|#
directive|define
name|SECSHFT
value|(DDSTATE ? 8 : 7)
end_define

begin_comment
comment|/* # bits to shift for sctr # */
end_comment

begin_define
define|#
directive|define
name|SECMASK
value|(DDSTATE ? 0xff : 0x7f)
end_define

begin_comment
comment|/* shifted-out bits of offset */
end_comment

begin_define
define|#
directive|define
name|B_CTRL
value|0x80000000
end_define

begin_comment
comment|/* control (format) request */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rxprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* value-result */
name|struct
name|rxdevice
modifier|*
name|rxaddr
init|=
operator|(
expr|struct
name|rxdevice
operator|*
operator|)
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|rxintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|lint
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_INTR
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
literal|0
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|rxaddr
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|rxslave
argument_list|(
argument|ui
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ui
operator|->
name|ui_dk
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ui
operator|->
name|ui_slave
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_slave
operator|==
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rxattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{  }
end_block

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_macro
name|rxopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|RXUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rx_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRX
operator|||
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x8
operator|)
operator|||
operator|(
name|ui
operator|=
name|rxdinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
operator|&
name|rx_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|->
name|sc_flags
operator|=
name|RXF_OPEN
operator||
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|RXF_DEVTYPE
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_csbits
operator|=
name|RX_INTR
expr_stmt|;
name|sc
operator|->
name|sc_csbits
operator||=
name|ui
operator|->
name|ui_slave
operator|==
literal|0
condition|?
name|RX_DRV0
else|:
name|RX_DRV1
expr_stmt|;
name|sc
operator|->
name|sc_csbits
operator||=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|RXF_DBLDEN
condition|?
name|RX_DDEN
else|:
name|RX_SDEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_macro
name|rxclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|RXUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RXF_OPEN
expr_stmt|;
name|sc
operator|->
name|sc_csbits
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rxstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|rx_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ui
operator|=
name|rxdinfo
index|[
name|RXUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|um
operator|=
name|ui
operator|->
name|ui_mi
expr_stmt|;
name|bp
operator|->
name|b_actf
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
else|else
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actl
operator|->
name|b_forw
operator|=
name|bp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
name|bp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
expr_stmt|;
if|if
condition|(
operator|!
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|&&
name|bp
operator|->
name|b_actf
condition|)
name|rxstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Sector mapping routine.  * Two independent sets of choices are available:  *  * (a) The first logical sector may either be on track 1 or track 0.  * (b) The sectors on a track may either be taken in 2-for-1 interleaved  *	 fashion or directly.  * This gives a total of four possible mapping schemes.  *  * Physical tracks on the RX02 are numbered 0-76.  Physical sectors on  * each track are numbered 1-26.  *  * When interleaving is used, sectors on the first logical track are  * taken in the order 1, 3, 5, ..., 25, 2, 4, 6, ..., 26.  A skew of  * six sectors per track is also used (to allow time for the heads to  * move); hence, the sectors on the second logical track are taken in  * the order 7, 9, 11, ..., 25, 1, 3, 5, 8, 10, 12, ..., 26, 2, 4, 6;  * the third logical track starts with sector 13; and so on.  *  * When the mapping starts with track 1, track 0 is the last logical  * track, and this track is always handled directly (without inter-  * leaving), even when the rest of the disk is interleaved.  (This is  * still compatible with DEC RT-11, which does not use track 0 at all.)  */
end_comment

begin_macro
name|rxmap
argument_list|(
argument|bp
argument_list|,
argument|psector
argument_list|,
argument|ptrack
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|psector
decl_stmt|,
modifier|*
name|ptrack
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|lt
decl_stmt|,
name|ls
decl_stmt|,
name|ptoff
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|RXUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
name|ls
operator|=
name|bp
operator|->
name|b_blkno
operator|*
operator|(
name|NBPS
operator|/
name|DEV_BSIZE
operator|)
expr_stmt|;
name|lt
operator|=
name|ls
operator|/
literal|26
expr_stmt|;
name|ls
operator|%=
literal|26
expr_stmt|;
comment|/* 	 * The "physical track offset" (ptoff) takes the 	 * starting physical track (0 or 1) and the desired 	 * interleaving into account.  If lt+ptoff>= 77, 	 * then interleaving is not performed. 	 */
name|ptoff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_DIRECT
condition|)
name|ptoff
operator|=
literal|77
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_TRKZERO
condition|)
name|ptoff
operator|++
expr_stmt|;
if|if
condition|(
name|lt
operator|+
name|ptoff
operator|<
literal|77
condition|)
name|ls
operator|=
operator|(
operator|(
name|ls
operator|<<
literal|1
operator|)
operator|+
operator|(
name|ls
operator|>=
literal|13
operator|)
operator|+
operator|(
literal|6
operator|*
name|lt
operator|)
operator|)
operator|%
literal|26
expr_stmt|;
operator|*
name|ptrack
operator|=
operator|(
name|lt
operator|+
name|ptoff
operator|)
operator|%
literal|77
expr_stmt|;
operator|*
name|psector
operator|=
name|ls
operator|+
literal|1
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rxstart
argument_list|(
name|um
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rxdevice
modifier|*
name|rxaddr
decl_stmt|;
specifier|register
name|struct
name|rx_ctlr
modifier|*
name|rxc
decl_stmt|;
specifier|register
name|struct
name|rx_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|sector
decl_stmt|,
name|track
decl_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|||
operator|(
name|bp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|++
expr_stmt|;
name|unit
operator|=
name|RXUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|rx_softc
index|[
name|unit
index|]
expr_stmt|;
name|rxaddr
operator|=
operator|(
expr|struct
name|rxdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
name|rxc
operator|=
operator|&
name|rx_ctlr
index|[
name|um
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|rxtimo
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
comment|/* start watchdog */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CTRL
condition|)
block|{
comment|/* format */
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_FORMAT
expr_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_FORMAT
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
literal|'I'
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
comment|/* read */
name|rxmap
argument_list|(
name|bp
argument_list|,
operator|&
name|sector
argument_list|,
operator|&
name|track
argument_list|)
expr_stmt|;
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_READ
expr_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_READ
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
operator|(
name|u_short
operator|)
name|sector
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
operator|(
name|u_short
operator|)
name|track
expr_stmt|;
return|return;
block|}
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_FILL
expr_stmt|;
comment|/* write */
name|um
operator|->
name|um_cmd
operator|=
name|RX_FILL
expr_stmt|;
operator|(
name|void
operator|)
name|ubago
argument_list|(
name|rxdinfo
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rxdgo
argument_list|(
argument|um
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|rxdevice
modifier|*
name|rxaddr
init|=
operator|(
expr|struct
name|rxdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
decl_stmt|;
name|int
name|ubinfo
init|=
name|um
operator|->
name|um_ubinfo
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
operator|&
name|rrxbuf
index|[
name|um
operator|->
name|um_ctlr
index|]
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|RXUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
name|struct
name|rx_ctlr
modifier|*
name|rxc
init|=
operator|&
name|rx_ctlr
index|[
name|um
operator|->
name|um_ctlr
index|]
decl_stmt|;
name|bp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
expr_stmt|;
name|sc
operator|->
name|sc_tocnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rxc
operator|->
name|rxc_state
operator|!=
name|RXS_RDERR
condition|)
block|{
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
name|bp
operator|->
name|b_bcount
operator|>>
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
name|ubinfo
expr_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|um
operator|->
name|um_cmd
operator||
operator|(
operator|(
name|ubinfo
operator|&
literal|0x30000
operator|)
operator|>>
literal|4
operator|)
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
block|}
end_block

begin_macro
name|rxintr
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|RXUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|sector
decl_stmt|,
name|track
decl_stmt|;
name|struct
name|uba_ctlr
modifier|*
name|um
init|=
name|rxminfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|rxdevice
modifier|*
name|rxaddr
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|rxdinfo
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|rxerr
modifier|*
name|er
decl_stmt|;
specifier|register
name|struct
name|rx_ctlr
modifier|*
name|rxc
decl_stmt|;
name|sc
operator|->
name|sc_tocnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|um
operator|->
name|um_tab
operator|.
name|b_active
condition|)
return|return;
name|rxaddr
operator|=
operator|(
expr|struct
name|rxdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
name|rxc
operator|=
operator|&
name|rx_ctlr
index|[
name|um
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|er
operator|=
operator|&
name|rxerr
index|[
name|um
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|bp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_ERR
operator|)
operator|&&
name|rxc
operator|->
name|rxc_state
operator|!=
name|RXS_RDSTAT
operator|&&
name|rxc
operator|->
name|rxc_state
operator|!=
name|RXS_RDERR
condition|)
goto|goto
name|error
goto|;
switch|switch
condition|(
name|rxc
operator|->
name|rxc_state
condition|)
block|{
comment|/* 	 * Incomplete commands.  Perform next step 	 * and return.  Note that b_active is set on 	 * entrance and, therefore, also on exit. 	 */
case|case
name|RXS_READ
case|:
if|if
condition|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RXES_DDMARK
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|RXF_DDMK
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RXF_DDMK
expr_stmt|;
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_EMPTY
expr_stmt|;
name|um
operator|->
name|um_cmd
operator|=
name|RX_EMPTY
expr_stmt|;
operator|(
name|void
operator|)
name|ubago
argument_list|(
name|ui
argument_list|)
expr_stmt|;
return|return;
case|case
name|RXS_FILL
case|:
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_WRITE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_USEWDDS
condition|)
block|{
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_WDDS
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RXF_USEWDDS
expr_stmt|;
block|}
else|else
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_WRITE
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxmap
argument_list|(
name|bp
argument_list|,
operator|&
name|sector
argument_list|,
operator|&
name|track
argument_list|)
expr_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
name|sector
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
name|track
expr_stmt|;
return|return;
comment|/* 	 * Possibly completed command. 	 */
case|case
name|RXS_RDSTAT
case|:
if|if
condition|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RXES_READY
condition|)
goto|goto
name|rderr
goto|;
name|bp
operator|->
name|b_error
operator|=
name|EBUSY
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* 	 * Command completed. 	 */
case|case
name|RXS_EMPTY
case|:
case|case
name|RXS_WRITE
case|:
case|case
name|RXS_FORMAT
case|:
goto|goto
name|done
goto|;
case|case
name|RXS_RDERR
case|:
name|rxmap
argument_list|(
name|bp
argument_list|,
operator|&
name|sector
argument_list|,
operator|&
name|track
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rx%d: hard error, lsn%d (trk %d psec %d) "
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_blkno
operator|*
operator|(
name|NBPS
operator|/
name|DEV_BSIZE
operator|)
argument_list|,
name|track
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cs=%b, db=%b, err=%x\n"
argument_list|,
name|er
operator|->
name|rxcs
argument_list|,
name|RXCS_BITS
argument_list|,
name|er
operator|->
name|rxdb
argument_list|,
name|RXES_BITS
argument_list|,
name|er
operator|->
name|rxxt
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
name|printf
argument_list|(
literal|"rx%d: state %d (reset)"
argument_list|,
name|unit
argument_list|,
name|rxc
operator|->
name|rxc_state
argument_list|)
expr_stmt|;
name|rxreset
argument_list|(
name|um
operator|->
name|um_ubanum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
label|:
comment|/* 	 * In case of an error: 	 *  (a) Give up now if a format (ioctl) was in progress, or if a 	 *	  density error was detected. 	 *  (b) Retry up to nine times if a CRC (data) error was detected, 	 *	  then give up if the error persists. 	 *  (c) In all other cases, reinitialize the drive and try the 	 *	  operation once more before giving up. 	 */
if|if
condition|(
name|rxc
operator|->
name|rxc_state
operator|==
name|RXS_FORMAT
operator|||
operator|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RXES_DENERR
operator|)
condition|)
goto|goto
name|giveup
goto|;
if|if
condition|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RXES_CRCERR
condition|)
block|{
if|if
condition|(
operator|++
name|bp
operator|->
name|b_errcnt
operator|>=
literal|10
condition|)
goto|goto
name|giveup
goto|;
goto|goto
name|retry
goto|;
block|}
name|bp
operator|->
name|b_errcnt
operator|+=
literal|9
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_errcnt
operator|>=
literal|10
condition|)
goto|goto
name|giveup
goto|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_INIT
expr_stmt|;
comment|/* no way to get an interrupt for "init done", so just wait */
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RX_DONE
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|retry
label|:
comment|/* 	 * In case we already have UNIBUS resources, give 	 * them back since we reallocate things in rxstart. 	 */
if|if
condition|(
name|um
operator|->
name|um_ubinfo
condition|)
name|ubadone
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|rxstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
return|return;
name|giveup
label|:
comment|/* 	 * Hard I/O error -- 	 * Density errors are not noted on the console since the 	 * only way to determine the density of an unknown disk 	 * is to try one density or the other at random and see 	 * which one doesn't give a density error. 	 */
if|if
condition|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RXES_DENERR
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_RDSTAT
expr_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_RDSTAT
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
return|return;
name|rderr
label|:
comment|/* 	 * A hard error (other than not ready or density) has occurred. 	 * Read the extended error status information. 	 * Before doing this, save the current CS and DB register values, 	 * because the read error status operation may modify them. 	 * Insert buffer with request at the head of the queue. 	 */
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|ubadone
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|er
operator|->
name|rxcs
operator|=
name|rxaddr
operator|->
name|rxcs
expr_stmt|;
name|er
operator|->
name|rxdb
operator|=
name|rxaddr
operator|->
name|rxdb
expr_stmt|;
name|bp
operator|=
operator|&
name|erxbuf
index|[
name|unit
index|]
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
operator|(
name|caddr_t
operator|)
name|er
operator|->
name|rxxt
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
sizeof|sizeof
argument_list|(
name|er
operator|->
name|rxxt
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DIRTY
operator||
name|B_UAREA
operator||
name|B_PHYS
operator||
name|B_PAGET
operator|)
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_forw
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actf
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_RDERR
expr_stmt|;
name|um
operator|->
name|um_cmd
operator|=
name|RX_RDERR
expr_stmt|;
operator|(
name|void
operator|)
name|ubago
argument_list|(
name|ui
argument_list|)
expr_stmt|;
return|return;
name|done
label|:
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|b_forw
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_IDLE
expr_stmt|;
name|ubadone
argument_list|(
name|um
argument_list|)
expr_stmt|;
comment|/* 	 * If this unit has more work to do, 	 * start it up right away 	 */
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actf
condition|)
name|rxstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|minrxphys
argument_list|(
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|RXUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|NBPS
condition|)
name|bp
operator|->
name|b_bcount
operator|=
name|NBPS
expr_stmt|;
block|}
end_block

begin_macro
name|rxtimo
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|RXUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_OPEN
condition|)
name|timeout
argument_list|(
name|rxtimo
argument_list|,
operator|(
name|caddr_t
operator|)
name|dev
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_tocnt
operator|<
name|RX_MAXTIMEOUT
condition|)
return|return;
name|rxintr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rxreset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|struct
name|rxdevice
modifier|*
name|rxaddr
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|;
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|NFX
condition|;
name|ctlr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|um
operator|=
name|rxminfo
index|[
name|ctlr
index|]
operator|)
operator|==
literal|0
operator|||
name|um
operator|->
name|um_ubanum
operator|!=
name|uban
operator|||
name|um
operator|->
name|um_alive
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|" fx%d"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_ubinfo
condition|)
block|{
name|printf
argument_list|(
literal|"<%d>"
argument_list|,
operator|(
name|um
operator|->
name|um_ubinfo
operator|>>
literal|28
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_ubinfo
operator|=
literal|0
expr_stmt|;
block|}
name|rx_ctlr
index|[
name|ctlr
index|]
operator|.
name|rxc_state
operator|=
name|RXS_IDLE
expr_stmt|;
name|rxaddr
operator|=
operator|(
expr|struct
name|rxdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_INIT
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RX_DONE
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rxread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|RXUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|ctlr
init|=
name|rxdinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|RXUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
operator|>
name|RXSIZE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
operator|||
operator|(
name|uio
operator|->
name|uio_offset
operator|&
name|SECMASK
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
name|physio
argument_list|(
name|rxstrategy
argument_list|,
operator|&
name|rrxbuf
index|[
name|ctlr
index|]
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minrxphys
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|rxwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|RXUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|ctlr
init|=
name|rxdinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|RXUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
operator|>
name|RXSIZE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
operator|||
operator|(
name|uio
operator|->
name|uio_offset
operator|&
name|SECMASK
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
name|physio
argument_list|(
name|rxstrategy
argument_list|,
operator|&
name|rrxbuf
index|[
name|ctlr
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minrxphys
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Control routine:  * processes three kinds of requests:  *  *	(1) Set density according to that specified by the open device.  *	(2) Arrange for the next sector to be written with a deleted-  *		  data mark.  *	(3) Report whether the last sector read had a deleted-data mark  *		  (by returning with an EIO error code if it did).  *  * Requests relating to deleted-data marks can be handled right here.  * A "set density" request, however, must additionally be processed  * through "rxstart", just like a read or write request.  */
end_comment

begin_comment
comment|/*ARGSUSED3*/
end_comment

begin_macro
name|rxioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|RXUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|unit
index|]
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RXIOC_FORMAT
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
return|return
operator|(
name|rxformat
argument_list|(
name|dev
argument_list|)
operator|)
return|;
case|case
name|RXIOC_WDDS
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|RXF_USEWDDS
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RXIOC_RDDSMK
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_DDMK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Initiate a format command.  */
end_comment

begin_macro
name|rxformat
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ctlr
init|=
name|rxdinfo
index|[
name|RXUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|ui_mi
operator|->
name|um_ctlr
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|RXUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|bp
operator|=
operator|&
name|rrxbuf
index|[
name|ctlr
index|]
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
while|while
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
name|sleep
argument_list|(
name|bp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_CTRL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|RXS_FORMAT
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|rxstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|iowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
name|error
operator|=
name|bp
operator|->
name|b_error
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_BUSY
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

