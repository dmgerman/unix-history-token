begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	rx.c	4.19	83/05/21	*/
end_comment

begin_include
include|#
directive|include
file|"rx.h"
end_include

begin_if
if|#
directive|if
name|NFX
operator|>
literal|0
end_if

begin_comment
comment|/*  * RX02 floppy disk device driver  *  */
end_comment

begin_comment
comment|/*  * TODO:  *	- clean up the code for multisector transfers using  *	  a 'transfer in progress' flag  *	- Test Deleted Data read/write   *	- Test error handling/reporting and 'volume valid' stuff  *  * 	Note: If the drive subsystem is  * 	powered off at boot time, the controller won't interrupt!  */
end_comment

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/conf.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/time.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../h/uio.h"
end_include

begin_include
include|#
directive|include
file|"../h/file.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vax/nexus.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/rxreg.h"
end_include

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_comment
comment|/* per-controller data */
end_comment

begin_struct
struct|struct
name|rx_ctlr
block|{
name|int
name|rxc_state
decl_stmt|;
comment|/* controller state */
define|#
directive|define
name|RXS_READ
value|1
comment|/* read started	*/
define|#
directive|define
name|RXS_EMPTY
value|2
comment|/* empty started */
define|#
directive|define
name|RXS_FILL
value|3
comment|/* fill started	*/
define|#
directive|define
name|RXS_WRITE
value|4
comment|/* write started */
define|#
directive|define
name|RXS_FORMAT
value|5
comment|/* format started */
define|#
directive|define
name|RXS_RDSTAT
value|6
comment|/* status read started */
define|#
directive|define
name|RXS_RDERR
value|7
comment|/* error read started */
define|#
directive|define
name|RXS_IDLE
value|8
comment|/* device is idle */
name|u_short
name|rxc_rxcs
decl_stmt|;
comment|/* extended error status */
name|u_short
name|rxc_rxdb
decl_stmt|;
name|u_short
name|rxc_rxxt
index|[
literal|4
index|]
decl_stmt|;
name|int
name|rxc_tocnt
decl_stmt|;
comment|/* for watchdog routine */
define|#
directive|define
name|RX_MAXTIMEOUT
value|30
comment|/* # seconds to wait before giving up */
block|}
name|rx_ctlr
index|[
name|NFX
index|]
struct|;
end_struct

begin_comment
comment|/* per-drive buffers */
end_comment

begin_decl_stmt
name|struct
name|buf
name|rrxbuf
index|[
name|NRX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers for raw I/O */
end_comment

begin_decl_stmt
name|struct
name|buf
name|erxbuf
index|[
name|NRX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers for reading error status */
end_comment

begin_decl_stmt
name|struct
name|buf
name|rxutab
index|[
name|NRX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per drive buffers */
end_comment

begin_comment
comment|/* per-drive data */
end_comment

begin_struct
struct|struct
name|rx_softc
block|{
name|int
name|sc_flags
decl_stmt|;
comment|/* drive status flags */
define|#
directive|define
name|RXF_DIRECT
value|0x01
comment|/* if set: use direct sector mapping */
define|#
directive|define
name|RXF_TRKONE
value|0x02
comment|/* if set: start mapping on track 1 */
define|#
directive|define
name|RXF_DBLDEN
value|0x04
comment|/* use double density */
define|#
directive|define
name|RXF_DEVTYPE
value|0x07
comment|/* mapping flags */
define|#
directive|define
name|RXF_LOCK
value|0x10
comment|/* exclusive use */
define|#
directive|define
name|RXF_DDMK
value|0x20
comment|/* deleted-data mark detected */
define|#
directive|define
name|RXF_USEWDDS
value|0x40
comment|/* write deleted-data sector */
define|#
directive|define
name|RXF_FORMAT
value|0x80
comment|/* format in progress */
define|#
directive|define
name|RXF_BAD
value|0x100
comment|/* drive bad, cannot be used */
name|int
name|sc_csbits
decl_stmt|;
comment|/* constant bits for CS register */
name|int
name|sc_open
decl_stmt|;
comment|/* count number of opens */
name|int
name|sc_offset
decl_stmt|;
comment|/* raw mode kludge to avoid restricting */
comment|/* single sector transfers to start on */
comment|/* DEV_BSIZE boundaries */
comment|/* 	 * The rest of this structure is used to  	 * store temporaries while simulating multi  	 * sector transfers 	 */
name|caddr_t
name|sc_uaddr
decl_stmt|;
comment|/* unibus base address */
name|long
name|sc_bcnt
decl_stmt|;
comment|/* total transfer count */
name|long
name|sc_resid
decl_stmt|;
comment|/* no. of bytes left to transfer */
block|}
name|rx_softc
index|[
name|NRX
index|]
struct|;
end_struct

begin_struct
struct|struct
name|rxerr
block|{
name|short
name|rxcs
decl_stmt|;
name|short
name|rxdb
decl_stmt|;
name|short
name|rxxt
index|[
literal|4
index|]
decl_stmt|;
comment|/* error code dump from controller */
block|}
name|rxerr
index|[
name|NRX
index|]
struct|;
end_struct

begin_comment
comment|/* End of per-drive data */
end_comment

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|rxdinfo
index|[
name|NRX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_ctlr
modifier|*
name|rxminfo
index|[
name|NFX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|savebp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rxprobe
argument_list|()
decl_stmt|,
name|rxslave
argument_list|()
decl_stmt|,
name|rxattach
argument_list|()
decl_stmt|,
name|rxdgo
argument_list|()
decl_stmt|,
name|rxintr
argument_list|()
decl_stmt|,
name|rxwatch
argument_list|()
decl_stmt|,
name|rxphys
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|rxstd
index|[]
init|=
block|{
literal|0177170
block|,
literal|0177150
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|fxdriver
init|=
block|{
name|rxprobe
block|,
name|rxslave
block|,
name|rxattach
block|,
name|rxdgo
block|,
name|rxstd
block|,
literal|"rx"
block|,
name|rxdinfo
block|,
literal|"fx"
block|,
name|rxminfo
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rxwstart
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RXUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>>3)
end_define

begin_define
define|#
directive|define
name|MASKREG
parameter_list|(
name|reg
parameter_list|)
value|(reg&0xffff)
end_define

begin_comment
comment|/* constants related to floppy data capacity */
end_comment

begin_define
define|#
directive|define
name|RXSECS
value|2002
end_define

begin_comment
comment|/* # sectors on a floppy */
end_comment

begin_define
define|#
directive|define
name|DDSTATE
value|(sc->sc_csbits&RX_DDEN)
end_define

begin_define
define|#
directive|define
name|NBPS
value|(DDSTATE ? 256 : 128)
end_define

begin_comment
comment|/* # bytes per sector */
end_comment

begin_define
define|#
directive|define
name|RXSIZE
value|(DDSTATE ? 512512 : 256256)
end_define

begin_comment
comment|/* # bytes per disk */
end_comment

begin_define
define|#
directive|define
name|SECMASK
value|(DDSTATE ? 0xff : 0x7f)
end_define

begin_comment
comment|/* shifted-out bits of offset */
end_comment

begin_define
define|#
directive|define
name|B_CTRL
value|0x80000000
end_define

begin_comment
comment|/* control (format) request */
end_comment

begin_define
define|#
directive|define
name|B_RDSTAT
value|0x40000000
end_define

begin_comment
comment|/* read drive status (open) */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rxprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* value-result */
name|struct
name|rxdevice
modifier|*
name|rxaddr
init|=
operator|(
expr|struct
name|rxdevice
operator|*
operator|)
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|rxintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|lint
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_INTR
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
literal|0
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|rxaddr
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|rxslave
argument_list|(
argument|ui
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ui
operator|->
name|ui_dk
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ui
operator|->
name|ui_slave
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_slave
operator|==
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rxattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{  }
end_block

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_macro
name|rxopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|RXUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rx_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|struct
name|rx_ctlr
modifier|*
name|rxc
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRX
operator|||
operator|(
name|ui
operator|=
name|rxdinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
operator|&
name|rx_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_open
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_csbits
operator|==
literal|0
condition|)
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
operator|&
name|erxbuf
index|[
name|unit
index|]
decl_stmt|;
comment|/* 		 * lock the device while an open  		 * is in progress 		 */
name|sc
operator|->
name|sc_flags
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|RXF_DEVTYPE
operator|)
operator||
name|RXF_LOCK
expr_stmt|;
name|sc
operator|->
name|sc_csbits
operator|=
name|RX_INTR
expr_stmt|;
name|sc
operator|->
name|sc_csbits
operator||=
name|ui
operator|->
name|ui_slave
operator|==
literal|0
condition|?
name|RX_DRV0
else|:
name|RX_DRV1
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_RDSTAT
operator||
name|B_BUSY
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_offset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_resid
operator|=
literal|0
expr_stmt|;
comment|/* 		 * read device status to determine if 		 * a floppy is present in the drive and 		 * what density it is 		 */
name|rxstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|iowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|sc
operator|->
name|sc_csbits
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|bp
operator|->
name|b_error
operator|)
return|;
block|}
if|if
condition|(
name|rxwstart
operator|++
operator|==
literal|0
condition|)
block|{
name|rxc
operator|=
operator|&
name|rx_ctlr
index|[
name|ui
operator|->
name|ui_mi
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|rxc
operator|->
name|rxc_tocnt
operator|=
literal|0
expr_stmt|;
name|timeout
argument_list|(
name|rxwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* start watchdog */
block|}
ifdef|#
directive|ifdef
name|RXDEBUG
name|printf
argument_list|(
literal|"rxopen: csbits=0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_csbits
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RXF_LOCK
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_LOCK
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|sc
operator|->
name|sc_open
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_macro
name|rxclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|RXUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
operator|--
name|sc
operator|->
name|sc_open
expr_stmt|;
ifdef|#
directive|ifdef
name|RXDEBUG
name|printf
argument_list|(
literal|"rxclose: dev=0x%x, sc_open=%d\n"
argument_list|,
name|dev
argument_list|,
name|sc
operator|->
name|sc_open
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|rxstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|unit
init|=
name|RXUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRX
condition|)
goto|goto
name|bad
goto|;
name|ui
operator|=
name|rxdinfo
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|sc
operator|=
operator|&
name|rx_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|||
name|dbtob
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|>
name|RXSIZE
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_BAD
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|dbad
goto|;
block|}
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|RXDEBUG
name|printf
argument_list|(
literal|"rxstrat: bp=0x%x, fl=0x%x, un=%d, bl=%d, cnt=%d\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|b_cylin
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
comment|/* don't care to calculate trackno */
name|dp
operator|=
operator|&
name|rxutab
index|[
name|unit
index|]
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
block|{
name|rxustart
argument_list|(
name|ui
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|ui
operator|->
name|ui_mi
operator|->
name|um_tab
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_actf
operator|&&
name|bp
operator|->
name|b_active
operator|==
literal|0
condition|)
name|rxstart
argument_list|(
name|ui
operator|->
name|ui_mi
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|dbad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Unit start routine.  * Put this unit on the ready queue for the controller  */
end_comment

begin_expr_stmt
name|rxustart
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buf
modifier|*
name|dp
init|=
operator|&
name|rxutab
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
name|struct
name|uba_ctlr
modifier|*
name|um
init|=
name|ui
operator|->
name|ui_mi
decl_stmt|;
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|b_active
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Sector mapping routine.  * Two independent sets of choices are available:  *  * (a) The first logical sector may either be on track 1 or track 0.  * (b) The sectors on a track may either be taken in 2-for-1 interleaved  *	 fashion or directly.  * This gives a total of four possible mapping schemes.  *  * Physical tracks on the RX02 are numbered 0-76.  Physical sectors on  * each track are numbered 1-26.  *  * When interleaving is used, sectors on the first logical track are  * taken in the order 1, 3, 5, ..., 25, 2, 4, 6, ..., 26.  A skew of  * six sectors per track is also used (to allow time for the heads to  * move); hence, the sectors on the second logical track are taken in  * the order 7, 9, 11, ..., 25, 1, 3, 5, 8, 10, 12, ..., 26, 2, 4, 6;  * the third logical track starts with sector 13; and so on.  *  * When the mapping starts with track 1, track 0 is the last logical  * track, and this track is always handled directly (without inter-  * leaving), even when the rest of the disk is interleaved.  (This is  * still compatible with DEC RT-11, which does not use track 0 at all.)  */
end_comment

begin_macro
name|rxmap
argument_list|(
argument|bp
argument_list|,
argument|psector
argument_list|,
argument|ptrack
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|psector
decl_stmt|,
modifier|*
name|ptrack
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|lt
decl_stmt|,
name|ls
decl_stmt|,
name|ptoff
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|RXUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
name|ls
operator|=
operator|(
name|dbtob
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|+
operator|(
name|sc
operator|->
name|sc_offset
operator|-
name|sc
operator|->
name|sc_resid
operator|)
operator|)
operator|/
name|NBPS
expr_stmt|;
name|lt
operator|=
name|ls
operator|/
literal|26
expr_stmt|;
name|ls
operator|%=
literal|26
expr_stmt|;
comment|/* 	 * The "physical track offset" (ptoff) takes the 	 * starting physical track (0 or 1) and the desired 	 * interleaving into account.  If lt+ptoff>= 77, 	 * then interleaving is not performed. 	 */
name|ptoff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_DIRECT
condition|)
name|ptoff
operator|=
literal|77
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_TRKONE
condition|)
name|ptoff
operator|++
expr_stmt|;
if|if
condition|(
name|lt
operator|+
name|ptoff
operator|<
literal|77
condition|)
name|ls
operator|=
operator|(
operator|(
name|ls
operator|<<
literal|1
operator|)
operator|+
operator|(
name|ls
operator|>=
literal|13
operator|)
operator|+
operator|(
literal|6
operator|*
name|lt
operator|)
operator|)
operator|%
literal|26
expr_stmt|;
operator|*
name|ptrack
operator|=
operator|(
name|lt
operator|+
name|ptoff
operator|)
operator|%
literal|77
expr_stmt|;
operator|*
name|psector
operator|=
name|ls
operator|+
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Controller start routine.  * Start a new transfer or continue a multisector  * transfer. If this is a new transfer (dp->b_active == 1)  * save the start address of the data buffer and the total  * byte count in the soft control structure. These are  * restored into the buffer structure when the transfer has  * been completed, before calling 'iodone'.  */
end_comment

begin_expr_stmt
name|rxstart
argument_list|(
name|um
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rxdevice
modifier|*
name|rxaddr
decl_stmt|;
specifier|register
name|struct
name|rx_ctlr
modifier|*
name|rxc
decl_stmt|;
specifier|register
name|struct
name|rx_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|sector
decl_stmt|,
name|track
decl_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_active
condition|)
return|return;
name|loop
label|:
if|if
condition|(
operator|(
name|dp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|++
expr_stmt|;
name|unit
operator|=
name|RXUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|rx_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_BAD
condition|)
block|{
name|rxpurge
argument_list|(
name|um
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|sc
operator|->
name|sc_uaddr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|sc
operator|->
name|sc_bcnt
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|sc
operator|->
name|sc_offset
operator|+=
name|sc
operator|->
name|sc_bcnt
expr_stmt|;
name|dp
operator|->
name|b_active
operator|++
expr_stmt|;
block|}
name|rxaddr
operator|=
operator|(
expr|struct
name|rxdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
name|rxc
operator|=
operator|&
name|rx_ctlr
index|[
name|um
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|sc
operator|->
name|sc_resid
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|NBPS
condition|)
name|bp
operator|->
name|b_bcount
operator|=
name|NBPS
expr_stmt|;
name|rxc
operator|->
name|rxc_tocnt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RXDEBUG
name|printf
argument_list|(
literal|"rxstart: "
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rxaddr
operator|->
name|rxcs
operator|==
literal|0x800
condition|)
block|{
comment|/* 		 * 'Volume valid'? (check if the  		 * drive unit has been powered down) 		 */
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_INIT
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_DONE
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CTRL
condition|)
block|{
comment|/* format */
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_FORMAT
expr_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_FORMAT
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
literal|'I'
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_RDSTAT
condition|)
block|{
comment|/* read drive status */
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_RDSTAT
expr_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_RDSTAT
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|rxmap
argument_list|(
name|bp
argument_list|,
operator|&
name|sector
argument_list|,
operator|&
name|track
argument_list|)
expr_stmt|;
comment|/* read */
ifdef|#
directive|ifdef
name|RXDEBUG
name|printf
argument_list|(
literal|"read tr=%d, sc=%d"
argument_list|,
name|track
argument_list|,
name|sector
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_READ
expr_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_READ
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
operator|(
name|u_short
operator|)
name|sector
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
operator|(
name|u_short
operator|)
name|track
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|RXDEBUG
name|printf
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_FILL
expr_stmt|;
comment|/* write */
name|um
operator|->
name|um_cmd
operator|=
name|RX_FILL
expr_stmt|;
operator|(
name|void
operator|)
name|ubago
argument_list|(
name|rxdinfo
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RXDEBUG
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|rxdgo
argument_list|(
argument|um
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|rxdevice
modifier|*
name|rxaddr
init|=
operator|(
expr|struct
name|rxdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
decl_stmt|;
name|int
name|ubinfo
init|=
name|um
operator|->
name|um_ubinfo
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|->
name|b_actf
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|RXUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
name|struct
name|rx_ctlr
modifier|*
name|rxc
init|=
operator|&
name|rx_ctlr
index|[
name|um
operator|->
name|um_ctlr
index|]
decl_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|um
operator|->
name|um_cmd
operator||
operator|(
operator|(
name|ubinfo
operator|&
literal|0x30000
operator|)
operator|>>
literal|4
operator|)
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
if|if
condition|(
name|rxc
operator|->
name|rxc_state
operator|!=
name|RXS_RDERR
condition|)
block|{
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
operator|(
name|u_short
operator|)
name|bp
operator|->
name|b_bcount
operator|>>
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
operator|(
name|u_short
operator|)
name|ubinfo
expr_stmt|;
block|}
end_block

begin_macro
name|rxintr
argument_list|(
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
decl_stmt|,
name|sector
decl_stmt|,
name|track
decl_stmt|;
name|struct
name|uba_ctlr
modifier|*
name|um
init|=
name|rxminfo
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|rxdevice
modifier|*
name|rxaddr
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|rx_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|struct
name|rxerr
modifier|*
name|er
decl_stmt|;
name|struct
name|rx_ctlr
modifier|*
name|rxc
decl_stmt|;
if|if
condition|(
operator|!
name|um
operator|->
name|um_tab
operator|.
name|b_active
condition|)
return|return;
name|dp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
expr_stmt|;
if|if
condition|(
operator|!
name|dp
operator|->
name|b_active
condition|)
return|return;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|unit
operator|=
name|RXUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|rx_softc
index|[
name|unit
index|]
expr_stmt|;
name|ui
operator|=
name|rxdinfo
index|[
name|unit
index|]
expr_stmt|;
name|rxaddr
operator|=
operator|(
expr|struct
name|rxdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
name|rxc
operator|=
operator|&
name|rx_ctlr
index|[
name|um
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|rxc
operator|->
name|rxc_tocnt
operator|=
literal|0
expr_stmt|;
name|er
operator|=
operator|&
name|rxerr
index|[
name|unit
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|RXDEBUG
name|printf
argument_list|(
literal|"rxint: dev=%x, st=%d, cs=0x%x, db=0x%x\n"
argument_list|,
name|bp
operator|->
name|b_dev
argument_list|,
name|rxc
operator|->
name|rxc_state
argument_list|,
name|rxaddr
operator|->
name|rxcs
argument_list|,
name|rxaddr
operator|->
name|rxdb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_ERR
operator|)
operator|&&
operator|(
name|rxc
operator|->
name|rxc_state
operator|!=
name|RXS_RDSTAT
operator|)
operator|&&
operator|(
name|rxc
operator|->
name|rxc_state
operator|!=
name|RXS_RDERR
operator|)
condition|)
goto|goto
name|error
goto|;
switch|switch
condition|(
name|rxc
operator|->
name|rxc_state
condition|)
block|{
comment|/* 	 * Incomplete commands.  Perform next step 	 * and return.  Note that b_active is set on 	 * entrance and, therefore, also on exit. 	 */
case|case
name|RXS_READ
case|:
if|if
condition|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RXES_DDMARK
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|RXF_DDMK
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RXF_DDMK
expr_stmt|;
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_EMPTY
expr_stmt|;
name|um
operator|->
name|um_cmd
operator|=
name|RX_EMPTY
expr_stmt|;
operator|(
name|void
operator|)
name|ubago
argument_list|(
name|ui
argument_list|)
expr_stmt|;
return|return;
case|case
name|RXS_FILL
case|:
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_WRITE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_USEWDDS
condition|)
block|{
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_WDDS
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RXF_USEWDDS
expr_stmt|;
block|}
else|else
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_WRITE
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
name|rxmap
argument_list|(
name|bp
argument_list|,
operator|&
name|sector
argument_list|,
operator|&
name|track
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
name|sector
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_TREQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxaddr
operator|->
name|rxdb
operator|=
name|track
expr_stmt|;
return|return;
comment|/* 	 * Possibly completed command. 	 */
case|case
name|RXS_RDSTAT
case|:
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_RDSTAT
condition|)
block|{
if|if
condition|(
operator|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RXES_READY
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENODEV
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_csbits
operator||=
name|rxaddr
operator|->
name|rxdb
operator|&
name|RXES_DBLDEN
condition|?
name|RX_DDEN
else|:
name|RX_SDEN
expr_stmt|;
block|}
goto|goto
name|rdone
goto|;
block|}
if|if
condition|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RXES_READY
condition|)
goto|goto
name|rderr
goto|;
name|bp
operator|->
name|b_error
operator|=
name|ENODEV
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* 	 * Command completed. 	 */
case|case
name|RXS_EMPTY
case|:
case|case
name|RXS_WRITE
case|:
goto|goto
name|done
goto|;
case|case
name|RXS_FORMAT
case|:
goto|goto
name|rdone
goto|;
case|case
name|RXS_RDERR
case|:
name|bp
operator|=
name|savebp
expr_stmt|;
name|rxmap
argument_list|(
name|bp
argument_list|,
operator|&
name|sector
argument_list|,
operator|&
name|track
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rx%d: hard error, trk %d psec %d "
argument_list|,
name|unit
argument_list|,
name|track
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cs=%b, db=%b, err="
argument_list|,
name|MASKREG
argument_list|(
name|er
operator|->
name|rxcs
argument_list|)
argument_list|,
name|RXCS_BITS
argument_list|,
name|MASKREG
argument_list|(
name|er
operator|->
name|rxdb
argument_list|)
argument_list|,
name|RXES_BITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x, %x, %x, %x\n"
argument_list|,
name|MASKREG
argument_list|(
name|er
operator|->
name|rxxt
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MASKREG
argument_list|(
name|er
operator|->
name|rxxt
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|MASKREG
argument_list|(
name|er
operator|->
name|rxxt
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|MASKREG
argument_list|(
name|er
operator|->
name|rxxt
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
name|printf
argument_list|(
literal|"rx%d: state %d (reset)\n"
argument_list|,
name|unit
argument_list|,
name|rxc
operator|->
name|rxc_state
argument_list|)
expr_stmt|;
name|rxreset
argument_list|(
name|um
operator|->
name|um_ubanum
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
label|:
comment|/* 	 * In case of an error: 	 *  (a) Give up now if a format (ioctl) was in progress, if a 	 *	  density error was detected, or if the drive went offline 	 *  (b) Retry up to nine times if a CRC (data) error was detected, 	 *	  then give up if the error persists. 	 *  (c) In all other cases, reinitialize the drive and try the 	 *	  operation once more before giving up. 	 */
if|if
condition|(
name|rxc
operator|->
name|rxc_state
operator|==
name|RXS_FORMAT
operator|||
operator|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RXES_DENERR
operator|)
condition|)
goto|goto
name|giveup
goto|;
if|if
condition|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RXES_CRCERR
condition|)
block|{
if|if
condition|(
operator|++
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|>=
literal|10
condition|)
goto|goto
name|giveup
goto|;
goto|goto
name|retry
goto|;
block|}
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|+=
literal|9
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|>=
literal|10
condition|)
goto|goto
name|giveup
goto|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_INIT
expr_stmt|;
comment|/* no way to get an interrupt for "init done", so just wait */
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_DONE
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* if someone opened the drive: give up */
if|if
condition|(
operator|(
name|rxaddr
operator|->
name|rxdb
operator|&
name|RXES_READY
operator|)
operator|==
literal|0
condition|)
goto|goto
name|giveup
goto|;
name|retry
label|:
comment|/* 	 * In case we already have UNIBUS resources, give 	 * them back since we reallocate things in rxstart. 	 */
if|if
condition|(
name|um
operator|->
name|um_ubinfo
condition|)
name|ubadone
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|rxstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
return|return;
name|giveup
label|:
comment|/* 	 * Hard I/O error -- 	 * ALL errors are considered fatal and will abort the 	 * transfer and purge the i/o request queue 	 */
name|sc
operator|->
name|sc_flags
operator||=
name|RXF_BAD
expr_stmt|;
name|sc
operator|->
name|sc_resid
operator|=
literal|0
expr_stmt|;
comment|/* make sure the transfer is terminated */
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_RDSTAT
expr_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_RDSTAT
operator||
name|sc
operator|->
name|sc_csbits
expr_stmt|;
return|return;
name|rderr
label|:
comment|/* 	 * A hard error (other than not ready) has occurred. 	 * Read the extended error status information. 	 * Before doing this, save the current CS and DB register values, 	 * because the read error status operation may modify them. 	 * Insert buffer with request at the head of the queue. 	 */
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_ubinfo
condition|)
name|ubadone
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|savebp
operator|=
name|bp
expr_stmt|;
name|er
operator|->
name|rxcs
operator|=
name|rxaddr
operator|->
name|rxcs
expr_stmt|;
name|er
operator|->
name|rxdb
operator|=
name|rxaddr
operator|->
name|rxdb
expr_stmt|;
name|bp
operator|=
operator|&
name|erxbuf
index|[
name|unit
index|]
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
operator|(
name|caddr_t
operator|)
name|er
operator|->
name|rxxt
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
sizeof|sizeof
argument_list|(
name|er
operator|->
name|rxxt
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DIRTY
operator||
name|B_UAREA
operator||
name|B_PHYS
operator||
name|B_PAGET
operator|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
operator|==
name|NULL
condition|)
name|dp
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_forw
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_RDERR
expr_stmt|;
name|um
operator|->
name|um_cmd
operator|=
name|RX_RDERR
expr_stmt|;
operator|(
name|void
operator|)
name|ubago
argument_list|(
name|ui
argument_list|)
expr_stmt|;
return|return;
name|done
label|:
name|ubadone
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|rdone
label|:
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_resid
operator|-=
name|NBPS
operator|)
operator|>
literal|0
condition|)
block|{
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+=
name|NBPS
expr_stmt|;
name|rxstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
name|sc
operator|->
name|sc_uaddr
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|sc
operator|->
name|sc_bcnt
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_offset
operator|=
literal|0
expr_stmt|;
name|rxc
operator|->
name|rxc_state
operator|=
name|RXS_IDLE
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RXDEBUG
name|printf
argument_list|(
literal|".. bp=%x, new=%x\n"
argument_list|,
name|bp
argument_list|,
name|dp
operator|->
name|b_actf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If this unit has more work to do, 	 * start it up right away 	 */
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
name|rxustart
argument_list|(
name|ui
argument_list|)
expr_stmt|;
name|rxstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rxwatch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|struct
name|rx_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|rx_ctlr
modifier|*
name|rxc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dopen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRX
condition|;
name|i
operator|++
control|)
block|{
name|ui
operator|=
name|rxdinfo
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
continue|continue;
name|sc
operator|=
operator|&
name|rx_softc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_open
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rxutab
index|[
name|i
index|]
operator|.
name|b_active
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_csbits
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|dopen
operator|++
expr_stmt|;
name|um
operator|=
name|ui
operator|->
name|ui_mi
expr_stmt|;
name|rxc
operator|=
operator|&
name|rx_ctlr
index|[
name|um
operator|->
name|um_ctlr
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|rxc
operator|->
name|rxc_tocnt
operator|>=
name|RX_MAXTIMEOUT
condition|)
block|{
name|rxc
operator|->
name|rxc_tocnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_active
condition|)
block|{
name|printf
argument_list|(
literal|"rx%d: timeout\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* for debugging */
name|rxintr
argument_list|(
name|um
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dopen
condition|)
name|timeout
argument_list|(
name|rxwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
else|else
name|rxwstart
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|rxreset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|struct
name|rxdevice
modifier|*
name|rxaddr
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|;
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|NFX
condition|;
name|ctlr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|um
operator|=
name|rxminfo
index|[
name|ctlr
index|]
operator|)
operator|==
literal|0
operator|||
name|um
operator|->
name|um_ubanum
operator|!=
name|uban
operator|||
name|um
operator|->
name|um_alive
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|um
operator|->
name|um_ubinfo
condition|)
name|um
operator|->
name|um_ubinfo
operator|=
literal|0
expr_stmt|;
name|rx_ctlr
index|[
name|ctlr
index|]
operator|.
name|rxc_state
operator|=
name|RXS_IDLE
expr_stmt|;
name|rxaddr
operator|=
operator|(
expr|struct
name|rxdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
name|rxaddr
operator|->
name|rxcs
operator|=
name|RX_INIT
expr_stmt|;
while|while
condition|(
operator|(
name|rxaddr
operator|->
name|rxcs
operator|&
name|RX_DONE
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rxstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rxread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|RXUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
operator|>
name|RXSIZE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
operator|||
operator|(
name|uio
operator|->
name|uio_offset
operator|&
name|SECMASK
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|->
name|sc_offset
operator|=
name|uio
operator|->
name|uio_offset
operator|%
name|DEV_BSIZE
expr_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|rxstrategy
argument_list|,
operator|&
name|rrxbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|rxwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|RXUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
operator|>
name|RXSIZE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
operator|||
operator|(
name|uio
operator|->
name|uio_offset
operator|&
name|SECMASK
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|->
name|sc_offset
operator|=
name|uio
operator|->
name|uio_offset
operator|%
name|DEV_BSIZE
expr_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|rxstrategy
argument_list|,
operator|&
name|rrxbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Control routine:  * processes four kinds of requests:  *  *	(1) Set density (i.e., format the diskette) according to   *		  that specified data parameter  *	(2) Arrange for the next sector to be written with a deleted-  *		  data mark.  *	(3) Report whether the last sector read had a deleted-data mark  *	(4) Report the density of the diskette in the indicated drive  *	    (since the density it automatically determined by the driver,  *	     this is the only way to let an application program know the  *	     density)  *  * Requests relating to deleted-data marks can be handled right here.  * A "set density" (format) request, however, must additionally be   * processed through "rxstart", just like a read or write request.  */
end_comment

begin_comment
comment|/*ARGSUSED3*/
end_comment

begin_macro
name|rxioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|RXUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|unit
index|]
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RXIOC_FORMAT
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_open
operator|>
literal|1
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|sc
operator|->
name|sc_csbits
operator||=
name|RX_DDEN
expr_stmt|;
else|else
name|sc
operator|->
name|sc_csbits
operator|&=
operator|~
name|RX_DDEN
expr_stmt|;
return|return
operator|(
name|rxformat
argument_list|(
name|dev
argument_list|)
operator|)
return|;
case|case
name|RXIOC_WDDS
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|RXF_USEWDDS
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RXIOC_RDDSMK
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_flags
operator|&
name|RXF_DDMK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RXIOC_GDENS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_csbits
operator|&
name|RX_DDEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Initiate a format command.  */
end_comment

begin_macro
name|rxformat
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|RXUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|rx_softc
modifier|*
name|sc
init|=
operator|&
name|rx_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|bp
operator|=
operator|&
name|rrxbuf
index|[
name|unit
index|]
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_CTRL
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|RXF_FORMAT
operator||
name|RXF_LOCK
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
literal|0
expr_stmt|;
name|rxstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|iowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
name|error
operator|=
name|bp
operator|->
name|b_error
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_BUSY
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RXF_LOCK
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * A permanent hard error condition has occured,  * purge the buffer queue  */
end_comment

begin_expr_stmt
name|rxpurge
argument_list|(
name|um
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
expr_stmt|;
while|while
condition|(
name|dp
operator|->
name|b_actf
condition|)
block|{
name|dp
operator|->
name|b_errcnt
operator|++
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

