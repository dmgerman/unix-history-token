begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)dmx.c	1.3 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Common code for DMF32 and DMZ32 drivers  */
end_comment

begin_include
include|#
directive|include
file|"dmf.h"
end_include

begin_include
include|#
directive|include
file|"dmz.h"
end_include

begin_if
if|#
directive|if
name|NDMF
operator|+
name|NDMZ
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"bk.h"
end_include

begin_include
include|#
directive|include
file|"uba.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"bkmac.h"
end_include

begin_include
include|#
directive|include
file|"clist.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"tsleep.h"
end_include

begin_include
include|#
directive|include
file|"dmx.h"
end_include

begin_include
include|#
directive|include
file|"ubareg.h"
end_include

begin_include
include|#
directive|include
file|"ubavar.h"
end_include

begin_include
include|#
directive|include
file|"dmxreg.h"
end_include

begin_include
include|#
directive|include
file|"dmreg.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PORTSELECTOR
end_ifndef

begin_define
define|#
directive|define
name|ISPEED
value|TTYDEF_SPEED
end_define

begin_define
define|#
directive|define
name|LFLAG
value|TTYDEF_LFLAG
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISPEED
value|B4800
end_define

begin_define
define|#
directive|define
name|IFLAGS
value|(TTYDEF_LFLAG&~ECHO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DMX_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|DMX_TIMEOUT
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|dmx_timeout
init|=
name|DMX_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* silo timeout, in ms */
end_comment

begin_decl_stmt
name|int
name|dmx_mindma
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't dma below this point */
end_comment

begin_decl_stmt
name|struct
name|speedtab
name|dmxspeedtab
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|75
block|,
literal|1
block|,
literal|110
block|,
literal|2
block|,
literal|134
block|,
literal|3
block|,
literal|150
block|,
literal|4
block|,
literal|300
block|,
literal|5
block|,
literal|600
block|,
literal|6
block|,
literal|1200
block|,
literal|7
block|,
literal|1800
block|,
literal|010
block|,
literal|2400
block|,
literal|012
block|,
literal|4800
block|,
literal|014
block|,
literal|9600
block|,
literal|016
block|,
literal|19200
block|,
literal|017
block|,
name|EXTA
block|,
literal|017
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The clist space is mapped by the drivers onto each UNIBUS.  * The UBACVT macro converts a clist space address for unibus uban  * into an I/O space address for the DMA routine.  */
end_comment

begin_decl_stmt
name|int
name|cbase
index|[
name|NUBA
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base address in unibus map */
end_comment

begin_define
define|#
directive|define
name|UBACVT
parameter_list|(
name|x
parameter_list|,
name|uban
parameter_list|)
value|(cbase[uban] + ((x)-(char *)cfree))
end_define

begin_function_decl
name|int
name|ttrstrt
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * DMF/DMZ open common code  */
end_comment

begin_expr_stmt
name|dmxopen
argument_list|(
name|tp
argument_list|,
name|sc
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|dmx_softc
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|,
name|unit
decl_stmt|;
name|int
name|dmxparam
parameter_list|()
function_decl|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|dmx_flags
operator|&
name|DMX_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|dmx_octet
operator|->
name|csr
operator||=
name|DMF_IE
expr_stmt|;
name|sc
operator|->
name|dmx_flags
operator||=
name|DMX_ACTIVE
expr_stmt|;
name|sc
operator|->
name|dmx_octet
operator|->
name|rsp
operator|=
name|dmx_timeout
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|u
operator|.
name|u_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* 	 * If this is first open, initialize tty state to default. 	 */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PORTSELECTOR
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|ISPEED
expr_stmt|;
ifdef|#
directive|ifdef
name|PORTSELECTOR
name|tp
operator|->
name|t_cflag
operator||=
name|HUPCL
expr_stmt|;
else|#
directive|else
block|}
endif|#
directive|endif
block|}
name|dmxparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|07
expr_stmt|;
comment|/* 	 * Wait for carrier, then process line discipline specific open. 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|dmxmctl
argument_list|(
name|tp
argument_list|,
name|DMF_ON
argument_list|,
name|DMSET
argument_list|)
operator|&
name|DMF_CAR
operator|)
operator|||
operator|(
name|sc
operator|->
name|dmx_softCAR
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
operator|)
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|||
name|flag
operator|&
name|O_NONBLOCK
operator|||
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
condition|)
break|break;
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
argument_list|,
name|SLP_DMX_OPN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|tp
operator|->
name|t_dev
operator|,
name|tp
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|dmxclose
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmxmctl
argument_list|(
name|tp
argument_list|,
name|DMF_BRK
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|||
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|dmxmctl
argument_list|(
name|tp
argument_list|,
name|DMF_OFF
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dmxrint
argument_list|(
name|sc
argument_list|)
specifier|register
expr|struct
name|dmx_softc
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|c
operator|,
name|cc
expr_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|dmx_octet
modifier|*
name|addr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|overrun
init|=
literal|0
decl_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|dmx_octet
operator|*
operator|)
name|sc
operator|->
name|dmx_octet
expr_stmt|;
comment|/* 	 * Loop fetching characters from the silo for this 	 * octet until there are no more in the silo. 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|addr
operator|->
name|rbuf
operator|)
operator|<
literal|0
condition|)
block|{
name|cc
operator|=
name|c
operator|&
literal|0xff
expr_stmt|;
name|unit
operator|=
operator|(
name|c
operator|>>
literal|8
operator|)
operator|&
literal|07
expr_stmt|;
name|tp
operator|=
name|sc
operator|->
name|dmx_tty
operator|+
name|unit
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|DMF_DSC
condition|)
block|{
name|addr
operator|->
name|csr
operator|=
name|DMF_IE
operator||
name|DMFIR_RMSTSC
operator||
name|unit
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|rmstsc
operator|&
name|DMF_CAR
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|dmx_softCAR
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|->
name|csr
operator|=
name|DMF_IE
operator||
name|DMFIR_LCR
operator||
name|unit
expr_stmt|;
name|addr
operator|->
name|lctms
operator|=
name|DMF_ENA
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PORTSELECTOR
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_WOPEN
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|c
operator|&
operator|(
name|DMF_PE
operator||
name|DMF_DO
operator||
name|DMF_FE
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|&
name|DMF_PE
condition|)
name|cc
operator||=
name|TTY_PE
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
name|DMF_DO
operator|)
operator|&&
name|overrun
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dm%c%d: silo overflow, line %d\n"
argument_list|,
name|sc
operator|->
name|dmx_type
argument_list|,
name|sc
operator|->
name|dmx_unit
argument_list|,
name|sc
operator|->
name|dmx_unit0
operator|+
name|unit
argument_list|)
expr_stmt|;
name|overrun
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|&
name|DMF_FE
condition|)
name|cc
operator||=
name|TTY_FE
expr_stmt|;
block|}
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|cc
operator|,
name|tp
operator|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|dmxioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
operator|(
name|void
operator|)
name|dmxmctl
argument_list|(
name|tp
argument_list|,
name|DMF_BRK
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
operator|(
name|void
operator|)
name|dmxmctl
argument_list|(
name|tp
argument_list|,
name|DMF_BRK
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCSDTR
case|:
operator|(
name|void
operator|)
name|dmxmctl
argument_list|(
name|tp
argument_list|,
name|DMF_DTR
operator||
name|DMF_RTS
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
operator|(
name|void
operator|)
name|dmxmctl
argument_list|(
name|tp
argument_list|,
name|DMF_DTR
operator||
name|DMF_RTS
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
operator|(
name|void
operator|)
name|dmxmctl
argument_list|(
name|tp
argument_list|,
name|dmtodmx
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
operator|(
name|void
operator|)
name|dmxmctl
argument_list|(
name|tp
argument_list|,
name|dmtodmx
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
operator|(
name|void
operator|)
name|dmxmctl
argument_list|(
name|tp
argument_list|,
name|dmtodmx
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|dmxmctl
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|DMGET
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * modem control  * "bits" are dmf/dmz lcr format;  * return of DMGET is DM11 format.  */
end_comment

begin_macro
name|dmxmctl
argument_list|(
argument|tp
argument_list|,
argument|bits
argument_list|,
argument|how
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bits
decl_stmt|,
name|how
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dmx_octet
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|,
name|mbits
decl_stmt|,
name|lcr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|07
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|dmx_octet
operator|*
operator|)
operator|(
name|tp
operator|->
name|t_addr
operator|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
name|DMF_IE
operator||
name|DMFIR_RMSTSC
operator||
name|unit
expr_stmt|;
name|mbits
operator|=
name|addr
operator|->
name|rmstsc
operator|&
literal|0xff00
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
name|DMF_IE
operator||
name|DMFIR_LCR
operator||
name|unit
expr_stmt|;
name|lcr
operator|=
name|addr
operator|->
name|lctms
expr_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|DMSET
case|:
name|lcr
operator|=
name|bits
expr_stmt|;
break|break;
case|case
name|DMBIS
case|:
name|lcr
operator||=
name|bits
expr_stmt|;
break|break;
case|case
name|DMBIC
case|:
name|lcr
operator|&=
operator|~
name|bits
expr_stmt|;
break|break;
case|case
name|DMGET
case|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|dmxtodm
argument_list|(
name|mbits
argument_list|,
name|lcr
argument_list|)
operator|)
return|;
block|}
name|addr
operator|->
name|lctms
operator|=
name|lcr
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|mbits
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Routine to convert modem status from dm to dmf/dmz lctmr format.  */
end_comment

begin_expr_stmt
name|dmtodmx
argument_list|(
name|bits
argument_list|)
specifier|register
name|int
name|bits
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|lcr
init|=
name|DMF_ENA
decl_stmt|;
if|if
condition|(
name|bits
operator|&
name|DML_DTR
condition|)
name|lcr
operator||=
name|DMF_DTR
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|DML_RTS
condition|)
name|lcr
operator||=
name|DMF_RTS
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|DML_ST
condition|)
name|lcr
operator||=
name|DMF_SRTS
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|DML_USR
condition|)
name|lcr
operator||=
name|DMF_USRW
expr_stmt|;
return|return
operator|(
name|lcr
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Routine to convert modem status from dmf/dmz receive modem status  * and line control register to dm format.  * If dmf/dmz user modem read bit set, set DML_USR.  */
end_comment

begin_expr_stmt
name|dmxtodm
argument_list|(
name|mstat
argument_list|,
name|lcr
argument_list|)
specifier|register
name|int
name|mstat
operator|,
name|lcr
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|mstat
operator|=
operator|(
operator|(
name|mstat
operator|&
operator|(
name|DMF_DSR
operator||
name|DMF_RNG
operator||
name|DMF_CAR
operator||
name|DMF_CTS
operator||
name|DMF_SR
operator|)
operator|)
operator|>>
literal|7
operator|)
operator||
operator|(
operator|(
name|mstat
operator|&
name|DMF_USRR
operator|)
operator|>>
literal|1
operator|)
operator||
name|DML_LE
expr_stmt|;
if|if
condition|(
name|lcr
operator|&
name|DMF_DTR
condition|)
name|mstat
operator||=
name|DML_DTR
expr_stmt|;
if|if
condition|(
name|lcr
operator|&
name|DMF_SRTS
condition|)
name|mstat
operator||=
name|DML_ST
expr_stmt|;
if|if
condition|(
name|lcr
operator|&
name|DMF_RTS
condition|)
name|mstat
operator||=
name|DML_RTS
expr_stmt|;
return|return
operator|(
name|mstat
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Set parameters from open or ioctl into the hardware registers.  */
end_comment

begin_expr_stmt
name|dmxparam
argument_list|(
name|tp
argument_list|,
name|t
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dmx_octet
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|lpar
decl_stmt|,
name|lcr
decl_stmt|;
specifier|register
name|int
name|cflag
init|=
name|t
operator|->
name|c_cflag
decl_stmt|;
name|int
name|s
decl_stmt|,
name|unit
decl_stmt|;
name|int
name|ispeed
init|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ispeed
argument_list|,
name|dmxspeedtab
argument_list|)
decl_stmt|;
name|int
name|ospeed
init|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
name|dmxspeedtab
argument_list|)
decl_stmt|;
comment|/* check requested parameters */
if|if
condition|(
name|ospeed
operator|<
literal|0
operator|||
name|ispeed
operator|<
literal|0
operator|||
operator|(
name|cflag
operator|&
name|CSIZE
operator|)
operator|==
name|CS5
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ispeed
operator|==
literal|0
condition|)
name|ispeed
operator|=
name|ospeed
expr_stmt|;
comment|/* and copy to tty */
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|cflag
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|dmx_octet
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|07
expr_stmt|;
comment|/* 	 * Block interrupts so parameters will be set 	 * before the line interrupts. 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
name|unit
operator||
name|DMFIR_LCR
operator||
name|DMF_IE
expr_stmt|;
if|if
condition|(
name|ospeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_cflag
operator||=
name|HUPCL
expr_stmt|;
operator|(
name|void
operator|)
name|dmxmctl
argument_list|(
name|tp
argument_list|,
name|DMF_OFF
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|lpar
operator|=
operator|(
name|ospeed
operator|<<
literal|12
operator|)
operator||
operator|(
name|ispeed
operator|<<
literal|8
operator|)
expr_stmt|;
name|lcr
operator|=
name|DMF_ENA
expr_stmt|;
switch|switch
condition|(
name|cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS6
case|:
name|lpar
operator||=
name|BITS6
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|lpar
operator||=
name|BITS7
expr_stmt|;
break|break;
case|case
name|CS8
case|:
name|lpar
operator||=
name|BITS8
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
name|lpar
operator||=
name|PENABLE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cflag
operator|&
name|PARODD
operator|)
condition|)
name|lpar
operator||=
name|EPAR
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
name|lpar
operator||=
name|TWOSB
expr_stmt|;
name|lpar
operator||=
operator|(
name|unit
operator|&
literal|07
operator|)
expr_stmt|;
name|addr
operator|->
name|lpr
operator|=
name|lpar
expr_stmt|;
name|addr
operator|->
name|lctms
operator|=
operator|(
name|addr
operator|->
name|lctms
operator|&
operator|~
literal|0xff
operator|)
operator||
name|lcr
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Process a transmit interrupt on an octet.  */
end_comment

begin_expr_stmt
name|dmxxint
argument_list|(
name|sc
argument_list|)
specifier|register
expr|struct
name|dmx_softc
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|dmx_octet
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|dmx_octet
operator|*
operator|)
name|sc
operator|->
name|dmx_octet
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|addr
operator|->
name|csr
operator|)
operator|&
name|DMF_TI
condition|)
block|{
if|if
condition|(
name|t
operator|&
name|DMF_NXM
condition|)
comment|/* SHOULD RESTART OR SOMETHING... */
name|printf
argument_list|(
literal|"dm%c%d: NXM line %d\n"
argument_list|,
name|sc
operator|->
name|dmx_type
argument_list|,
name|sc
operator|->
name|dmx_unit
argument_list|,
name|sc
operator|->
name|dmx_unit0
operator|+
operator|(
name|t
operator|>>
literal|8
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|>>
literal|8
operator|&
literal|7
expr_stmt|;
name|tp
operator|=
name|sc
operator|->
name|dmx_tty
operator|+
name|t
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_FLUSH
expr_stmt|;
define|#
directive|define
name|new
ifndef|#
directive|ifndef
name|new
elseif|else
if|if
condition|(
name|sc
operator|->
name|dmx_dmacount
index|[
name|t
index|]
condition|)
block|{
name|short
name|cntr
decl_stmt|;
comment|/* 			 * Do arithmetic in a short to make up 			 * for lost 16&17 bits. 			 */
name|addr
operator|->
name|csr
operator|=
name|DMFIR_TBA
operator||
name|DMF_IE
operator||
name|t
expr_stmt|;
name|cntr
operator|=
name|addr
operator|->
name|tba
operator|-
name|UBACVT
argument_list|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cf
argument_list|,
name|sc
operator|->
name|dmx_ubanum
argument_list|)
expr_stmt|;
name|ndflush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
operator|(
name|int
operator|)
name|cntr
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
elseif|else
if|if
condition|(
name|sc
operator|->
name|dmx_dmacount
index|[
name|t
index|]
condition|)
name|ndflush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|sc
operator|->
name|dmx_dmacount
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dmx_dmacount
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|dmxstart
argument_list|(
name|tp
argument_list|,
name|sc
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|dmx_softc
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dmx_octet
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|,
name|nch
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|07
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|dmx_octet
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
comment|/* 	 * Must hold interrupts in following code to prevent 	 * state of the tp from changing. 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* 	 * If it's currently active, or delaying, no need to do anything. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * If there are still characters to dma or in the silo, 	 * just reenable the transmitter. 	 */
name|addr
operator|->
name|csr
operator|=
name|DMF_IE
operator||
name|DMFIR_TBUF
operator||
name|unit
expr_stmt|;
ifdef|#
directive|ifdef
name|new
if|if
condition|(
name|addr
operator|->
name|tsc
operator|||
name|sc
operator|->
name|dmx_dmacount
index|[
name|unit
index|]
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|addr
operator|->
name|tsc
condition|)
block|{
endif|#
directive|endif
name|addr
operator|->
name|csr
operator|=
name|DMF_IE
operator||
name|DMFIR_LCR
operator||
name|unit
expr_stmt|;
name|addr
operator|->
name|lctms
operator|=
name|addr
operator|->
name|lctms
operator||
name|DMF_TE
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If there are sleepers, and output has drained below low 	 * water mark, wake up the sleepers. 	 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_wsel
condition|)
block|{
name|selwakeup
argument_list|(
name|tp
operator|->
name|t_wsel
argument_list|,
name|tp
operator|->
name|t_state
operator|&
name|TS_WCOLL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_wsel
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_WCOLL
expr_stmt|;
block|}
block|}
comment|/* 	 * Now restart transmission unless the output queue is 	 * empty. 	 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
literal|1
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_oflag
operator|&
name|OPOST
operator|)
condition|)
comment|/*XXX*/
name|nch
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|nch
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0200
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 	* If first thing on queue is a delay process it. 		 	*/
name|nch
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ttrstrt
argument_list|,
operator|(
name|caddr_t
operator|)
name|tp
argument_list|,
operator|(
name|nch
operator|&
literal|0x7f
operator|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_TIMEOUT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * If characters to transmit, restart transmission. 	 */
if|if
condition|(
name|nch
operator|>=
name|dmx_mindma
condition|)
block|{
specifier|register
name|car
expr_stmt|;
name|sc
operator|->
name|dmx_dmacount
index|[
name|unit
index|]
operator|=
name|nch
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
name|DMF_IE
operator||
name|DMFIR_LCR
operator||
name|unit
expr_stmt|;
name|addr
operator|->
name|lctms
operator|=
name|addr
operator|->
name|lctms
operator||
name|DMF_TE
expr_stmt|;
name|car
operator|=
name|UBACVT
argument_list|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cf
argument_list|,
name|sc
operator|->
name|dmx_ubanum
argument_list|)
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
name|DMF_IE
operator||
name|DMFIR_TBA
operator||
name|unit
expr_stmt|;
name|addr
operator|->
name|tba
operator|=
name|car
expr_stmt|;
name|addr
operator|->
name|tcc
operator|=
operator|(
operator|(
name|car
operator|>>
literal|2
operator|)
operator|&
literal|0xc000
operator|)
operator||
name|nch
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nch
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|tp
operator|->
name|t_outq
operator|.
name|c_cf
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|new
name|sc
operator|->
name|dmx_dmacount
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|nch
operator|=
name|MIN
argument_list|(
name|nch
argument_list|,
name|DMF_SILOCNT
argument_list|)
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
name|DMF_IE
operator||
name|DMFIR_LCR
operator||
name|unit
expr_stmt|;
name|addr
operator|->
name|lctms
operator|=
name|addr
operator|->
name|lctms
operator||
name|DMF_TE
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
name|DMF_IE
operator||
name|DMFIR_TBUF
operator||
name|unit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nch
condition|;
name|i
operator|++
control|)
name|addr
operator|->
name|tbuf
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|ndflush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|nch
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|dmxstop
argument_list|(
name|tp
argument_list|,
name|sc
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
name|struct
name|dmx_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|struct
name|dmx_octet
modifier|*
name|addr
decl_stmt|;
specifier|register
name|unit
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|7
expr_stmt|;
name|int
name|s
decl_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|dmx_octet
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
comment|/* 	 * Block input/output interrupts while messing with state. 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|addr
operator|->
name|csr
operator|=
name|DMF_IE
operator||
name|DMFIR_TBUF
operator||
name|unit
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|tsc
condition|)
block|{
comment|/* 			 * Flush regardless of whether we're transmitting 			 * (TS_BUSY), if the silo contains untransmitted 			 * characters. 			 */
name|addr
operator|->
name|csr
operator|=
name|DMFIR_LCR
operator||
name|unit
operator||
name|DMF_IE
expr_stmt|;
name|addr
operator|->
name|lctms
operator|=
name|addr
operator|->
name|lctms
operator||
name|DMF_TE
operator||
name|DMF_FLUSH
expr_stmt|;
comment|/* this will interrupt so let dmxxint handle the rest */
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
operator||
name|TS_BUSY
expr_stmt|;
block|}
comment|/*#ifdef new*/
name|sc
operator|->
name|dmx_dmacount
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
comment|/*#endif*/
block|}
else|else
block|{
comment|/* 		 * Stop transmission by disabling 		 * the transmitter.  We'll pick up where we 		 * left off by reenabling in dmxstart. 		 */
name|addr
operator|->
name|csr
operator|=
name|DMFIR_LCR
operator||
name|unit
operator||
name|DMF_IE
expr_stmt|;
name|addr
operator|->
name|lctms
operator|=
name|addr
operator|->
name|lctms
operator|&
operator|~
name|DMF_TE
expr_stmt|;
comment|/* no interrupt here */
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|NDMF + NDMZ
end_endif

end_unit

