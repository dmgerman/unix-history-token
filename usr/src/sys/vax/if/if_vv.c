begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	if_vv.c	4.20	83/05/27	*/
end_comment

begin_include
include|#
directive|include
file|"vv.h"
end_include

begin_comment
comment|/*  * Proteon 10 Meg Ring Driver.  * This device is called "vv" because its "real name",  * V2LNI won't work if shortened to the obvious "v2".  * Hence the subterfuge.  *  */
end_comment

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/vmmac.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/time.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip_var.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_include
include|#
directive|include
file|"../vaxif/if_vv.h"
end_include

begin_include
include|#
directive|include
file|"../vaxif/if_uba.h"
end_include

begin_comment
comment|/*  * N.B. - if WIRECENTER is defined wrong, it can well break  * the hardware!!  */
end_comment

begin_define
define|#
directive|define
name|WIRECENTER
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|WIRECENTER
end_ifdef

begin_define
define|#
directive|define
name|VV_CONF
value|VV_HEN
end_define

begin_comment
comment|/* drive wire center relay */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VV_CONF
value|VV_STE
end_define

begin_comment
comment|/* allow operation without wire center */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VVMTU
value|(1024+512)
end_define

begin_define
define|#
directive|define
name|VVMRU
value|(1024+512+16)
end_define

begin_comment
comment|/* space for trailer */
end_comment

begin_decl_stmt
name|int
name|vv_dotrailer
init|=
literal|0
decl_stmt|,
comment|/* 1 => do trailer protocol */
name|vv_tracehdr
init|=
literal|0
decl_stmt|,
comment|/* 1 => trace headers (slowly!!) */
name|vv_tracetimeout
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => trace input error-rate limiting */
end_comment

begin_expr_stmt
name|vv_logreaderrors
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 1 => log all read errors */
end_comment

begin_define
define|#
directive|define
name|vvtracehdr
value|if (vv_tracehdr) vvprt_hdr
end_define

begin_define
define|#
directive|define
name|vvtrprintf
value|if (vv_tracetimeout) printf
end_define

begin_decl_stmt
name|int
name|vv_ticking
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error flywheel is running */
end_comment

begin_comment
comment|/*  * Interval in HZ - 50 msec.  * N.B. all times below are in units of flywheel ticks  */
end_comment

begin_define
define|#
directive|define
name|VV_FLYWHEEL
value|3
end_define

begin_define
define|#
directive|define
name|VV_ERRORTHRESHOLD
value|100
end_define

begin_comment
comment|/* errors/flywheel-interval */
end_comment

begin_define
define|#
directive|define
name|VV_MODE1ATTEMPTS
value|10
end_define

begin_comment
comment|/* number mode 1 retries */
end_comment

begin_define
define|#
directive|define
name|VV_MODE1DELAY
value|2
end_define

begin_comment
comment|/* period interface is PAUSEd - 100ms */
end_comment

begin_define
define|#
directive|define
name|VV_MODE2DELAY
value|4
end_define

begin_comment
comment|/* base interval host relay is off - 200ms */
end_comment

begin_define
define|#
directive|define
name|VV_MAXDELAY
value|6400
end_define

begin_comment
comment|/* max interval host relay is off - 2 minutes */
end_comment

begin_decl_stmt
name|int
name|vvprobe
argument_list|()
decl_stmt|,
name|vvattach
argument_list|()
decl_stmt|,
name|vvrint
argument_list|()
decl_stmt|,
name|vvxint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|vvinfo
index|[
name|NVV
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|vvstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|vvdriver
init|=
block|{
name|vvprobe
block|,
literal|0
block|,
name|vvattach
block|,
literal|0
block|,
name|vvstd
block|,
literal|"vv"
block|,
name|vvinfo
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VVUNIT
parameter_list|(
name|x
parameter_list|)
value|minor(x)
end_define

begin_decl_stmt
name|int
name|vvinit
argument_list|()
decl_stmt|,
name|vvoutput
argument_list|()
decl_stmt|,
name|vvreset
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Software status of each interface.  *  * Each interface is referenced by a network interface structure,  * vs_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  * We also have, for each interface, a UBA interface structure, which  * contains information about the UNIBUS resources held by the interface:  * map registers, buffered data paths, etc.  Information is cached in this  * structure for use by the if_uba.c routines in running the interface  * efficiently.  */
end_comment

begin_struct
struct|struct
name|vv_softc
block|{
name|struct
name|ifnet
name|vs_if
decl_stmt|;
comment|/* network-visible interface */
name|struct
name|ifuba
name|vs_ifuba
decl_stmt|;
comment|/* UNIBUS resources */
name|short
name|vs_oactive
decl_stmt|;
comment|/* is output active */
name|short
name|vs_iactive
decl_stmt|;
comment|/* is input active */
name|short
name|vs_olen
decl_stmt|;
comment|/* length of last output */
name|u_short
name|vs_lastx
decl_stmt|;
comment|/* last destination address */
name|short
name|vs_tries
decl_stmt|;
comment|/* transmit current retry count */
name|short
name|vs_init
decl_stmt|;
comment|/* number of ring inits */
name|short
name|vs_nottaken
decl_stmt|;
comment|/* number of packets refused */
comment|/* input error rate limiting state */
name|short
name|vs_major
decl_stmt|;
comment|/* recovery major state */
name|short
name|vs_minor
decl_stmt|;
comment|/* recovery minor state */
name|short
name|vs_retry
decl_stmt|;
comment|/* recovery retry count */
name|short
name|vs_delayclock
decl_stmt|;
comment|/* recovery delay clock */
name|short
name|vs_delayrange
decl_stmt|;
comment|/* increasing delay interval */
name|short
name|vs_dropped
decl_stmt|;
comment|/* number of packes tossed in last dt */
block|}
name|vv_softc
index|[
name|NVV
index|]
struct|;
end_struct

begin_comment
comment|/*  * States of vs_iactive.  */
end_comment

begin_define
define|#
directive|define
name|ACTIVE
value|1
end_define

begin_comment
comment|/* interface should post new receives */
end_comment

begin_define
define|#
directive|define
name|PAUSE
value|0
end_define

begin_comment
comment|/* interface should NOT post new receives */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|-1
end_define

begin_comment
comment|/* PAUSE and open host relay */
end_comment

begin_comment
comment|/*  * Recovery major states.  */
end_comment

begin_define
define|#
directive|define
name|MODE0
value|0
end_define

begin_comment
comment|/* everything is wonderful */
end_comment

begin_define
define|#
directive|define
name|MODE1
value|1
end_define

begin_comment
comment|/* hopefully whatever will go away */
end_comment

begin_define
define|#
directive|define
name|MODE2
value|2
end_define

begin_comment
comment|/* drastic measures - open host relay for increasing intervals */
end_comment

begin_macro
name|vvprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
init|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|vvrint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* reset interface, enable, and wait till dust settles */
name|addr
operator|->
name|vvicsr
operator|=
name|VV_RST
expr_stmt|;
name|addr
operator|->
name|vvocsr
operator|=
name|VV_RST
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* generate interrupt by doing 1 word DMA from 0 in uba space!! */
name|addr
operator|->
name|vvocsr
operator|=
name|VV_IEN
expr_stmt|;
comment|/* enable interrupt */
name|addr
operator|->
name|vvoba
operator|=
literal|0
expr_stmt|;
comment|/* low 16 bits */
name|addr
operator|->
name|vvoea
operator|=
literal|0
expr_stmt|;
comment|/* extended bits */
name|addr
operator|->
name|vvowc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* for 1 word */
name|addr
operator|->
name|vvocsr
operator||=
name|VV_DEN
expr_stmt|;
comment|/* start the DMA */
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vvocsr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cvec
operator|&&
name|cvec
operator|!=
literal|0x200
condition|)
name|cvec
operator|-=
literal|4
expr_stmt|;
comment|/* backup so vector => recieve */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_macro
name|vvattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
init|=
operator|&
name|vv_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_unit
operator|=
name|ui
operator|->
name|ui_unit
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_name
operator|=
literal|"vv"
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_mtu
operator|=
name|VVMTU
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_net
operator|=
name|ui
operator|->
name|ui_flags
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_host
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* this will be reset in vvinit() */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|vs
operator|->
name|vs_if
operator|.
name|if_addr
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|if_makeaddr
argument_list|(
name|vs
operator|->
name|vs_if
operator|.
name|if_net
argument_list|,
name|vs
operator|->
name|vs_if
operator|.
name|if_host
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|vs
operator|->
name|vs_if
operator|.
name|if_broadaddr
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|if_makeaddr
argument_list|(
name|vs
operator|->
name|vs_if
operator|.
name|if_net
argument_list|,
name|VV_BROADCAST
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_flags
operator|=
name|IFF_BROADCAST
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_init
operator|=
name|vvinit
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_output
operator|=
name|vvoutput
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_reset
operator|=
name|vvreset
expr_stmt|;
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|=
name|UBA_CANTWAIT
operator||
name|UBA_NEEDBDP
operator||
name|UBA_NEED16
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VAX750
argument_list|)
comment|/* don't chew up 750 bdp's */
if|if
condition|(
name|cpu
operator|==
name|VAX_750
operator|&&
name|ui
operator|->
name|ui_unit
operator|>
literal|0
condition|)
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|&=
operator|~
name|UBA_NEEDBDP
expr_stmt|;
endif|#
directive|endif
name|if_attach
argument_list|(
operator|&
name|vs
operator|->
name|vs_if
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset of interface after UNIBUS reset.  * If interface is on specified uba, reset its state.  */
end_comment

begin_macro
name|vvreset
argument_list|(
argument|unit
argument_list|,
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NVV
operator|||
operator|(
name|ui
operator|=
name|vvinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_ubanum
operator|!=
name|uban
condition|)
return|return;
name|printf
argument_list|(
literal|" vv%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|vvinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialization of interface; clear recorded pending  * operations, and reinitialize UNIBUS usage.  */
end_comment

begin_macro
name|vvinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
init|=
operator|&
name|vv_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|vvinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|ubainfo
decl_stmt|,
name|s
decl_stmt|;
name|int
name|vvtimeout
parameter_list|()
function_decl|;
name|addr
operator|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
if|if
condition|(
name|if_ubainit
argument_list|(
operator|&
name|vs
operator|->
name|vs_ifuba
argument_list|,
name|ui
operator|->
name|ui_ubanum
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|btoc
argument_list|(
name|VVMTU
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vv%d: can't initialize\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vv_ticking
operator|++
operator|==
literal|0
condition|)
name|timeout
argument_list|(
name|vvtimeout
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|VV_FLYWHEEL
argument_list|)
expr_stmt|;
comment|/* 	 * Discover our host address and post it 	 */
name|vs
operator|->
name|vs_if
operator|.
name|if_host
index|[
literal|0
index|]
operator|=
name|vvidentify
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vv%d: host %d\n"
argument_list|,
name|unit
argument_list|,
name|vs
operator|->
name|vs_if
operator|.
name|if_host
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|vs
operator|->
name|vs_if
operator|.
name|if_addr
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|if_makeaddr
argument_list|(
name|vs
operator|->
name|vs_if
operator|.
name|if_net
argument_list|,
name|vs
operator|->
name|vs_if
operator|.
name|if_host
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the interface, and join the ring 	 */
name|addr
operator|->
name|vvocsr
operator|=
name|VV_RST
operator||
name|VV_CPB
expr_stmt|;
comment|/* clear packet buffer */
name|addr
operator|->
name|vvicsr
operator|=
name|VV_RST
operator||
name|VV_CONF
expr_stmt|;
comment|/* close logical relay */
name|DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
comment|/* let contacts settle */
name|vs
operator|->
name|vs_init
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_dropped
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_nottaken
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Hang a receive and start any 	 * pending writes by faking a transmit complete. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ubainfo
operator|=
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
expr_stmt|;
name|addr
operator|->
name|vviba
operator|=
operator|(
name|u_short
operator|)
name|ubainfo
expr_stmt|;
name|addr
operator|->
name|vviea
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ubainfo
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vviwc
operator|=
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
operator|+
name|VVMTU
operator|)
operator|>>
literal|1
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
name|VV_IEN
operator||
name|VV_CONF
operator||
name|VV_DEN
operator||
name|VV_ENB
expr_stmt|;
name|vs
operator|->
name|vs_iactive
operator|=
name|ACTIVE
expr_stmt|;
name|vs
operator|->
name|vs_oactive
operator|=
literal|1
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|vvxint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|if_rtinit
argument_list|(
operator|&
name|vs
operator|->
name|vs_if
argument_list|,
name|RTF_UP
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * vvidentify() - return our host address  */
end_comment

begin_macro
name|vvidentify
argument_list|(
argument|unit
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
init|=
operator|&
name|vv_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|vvinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|vv_header
modifier|*
name|v
decl_stmt|;
name|int
name|ubainfo
decl_stmt|,
name|attempts
decl_stmt|,
name|waitcount
decl_stmt|;
comment|/* 	 * Build a multicast message to identify our address 	 */
name|addr
operator|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|attempts
operator|=
literal|0
expr_stmt|;
comment|/* total attempts, including bad msg type */
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"vvinit: can't get mbuf"
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMINOFF
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
expr_stmt|;
name|v
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|vv_header
operator|*
argument_list|)
expr_stmt|;
name|v
operator|->
name|vh_dhost
operator|=
name|VV_BROADCAST
expr_stmt|;
comment|/* multicast destination address */
name|v
operator|->
name|vh_shost
operator|=
literal|0
expr_stmt|;
comment|/* will be overwritten with ours */
name|v
operator|->
name|vh_version
operator|=
name|RING_VERSION
expr_stmt|;
name|v
operator|->
name|vh_type
operator|=
name|RING_WHOAMI
expr_stmt|;
name|v
operator|->
name|vh_info
operator|=
literal|0
expr_stmt|;
comment|/* map xmit message into uba */
name|vs
operator|->
name|vs_olen
operator|=
name|if_wubaput
argument_list|(
operator|&
name|vs
operator|->
name|vs_ifuba
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_uba
argument_list|,
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
comment|/* 	 * Reset interface, establish Digital Loopback Mode, and 	 * send the multicast (to myself) with Input Copy enabled. 	 */
name|retry
label|:
name|ubainfo
operator|=
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
name|VV_RST
expr_stmt|;
name|addr
operator|->
name|vviba
operator|=
operator|(
name|u_short
operator|)
name|ubainfo
expr_stmt|;
name|addr
operator|->
name|vviea
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ubainfo
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vviwc
operator|=
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
operator|+
name|VVMTU
operator|)
operator|>>
literal|1
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
name|VV_STE
operator||
name|VV_DEN
operator||
name|VV_ENB
operator||
name|VV_LPB
expr_stmt|;
comment|/* let flag timers fire so ring will initialize */
name|DELAY
argument_list|(
literal|2000000
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vvocsr
operator|=
name|VV_RST
operator||
name|VV_CPB
expr_stmt|;
comment|/* clear packet buffer */
name|ubainfo
operator|=
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_info
expr_stmt|;
name|addr
operator|->
name|vvoba
operator|=
operator|(
name|u_short
operator|)
name|ubainfo
expr_stmt|;
name|addr
operator|->
name|vvoea
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ubainfo
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vvowc
operator|=
operator|-
operator|(
operator|(
name|vs
operator|->
name|vs_olen
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|addr
operator|->
name|vvocsr
operator|=
name|VV_CPB
operator||
name|VV_DEN
operator||
name|VV_INR
operator||
name|VV_ENB
expr_stmt|;
comment|/* 	 * Wait for receive side to finish. 	 * Extract source address (which will our own), 	 * and post to interface structure. 	 */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|waitcount
operator|=
literal|0
init|;
operator|(
name|addr
operator|->
name|vvicsr
operator|&
name|VV_RDY
operator|)
operator|==
literal|0
condition|;
name|waitcount
operator|++
control|)
block|{
if|if
condition|(
name|waitcount
operator|<
literal|10
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|attempts
operator|++
operator|>=
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"vv%d: can't initialize\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vvinit loopwait: icsr = %b\n"
argument_list|,
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|vvicsr
operator|)
argument_list|,
name|VV_IBITS
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_uba
argument_list|,
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_xtofree
condition|)
name|m_freem
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_xtofree
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_uba
argument_list|,
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
name|m
operator|=
name|if_rubaget
argument_list|(
operator|&
name|vs
operator|->
name|vs_ifuba
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Check message type before we believe the source host address 	 */
name|v
operator|=
operator|(
expr|struct
name|vv_header
operator|*
operator|)
operator|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
operator|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vh_type
operator|!=
name|RING_WHOAMI
condition|)
goto|goto
name|retry
goto|;
return|return
operator|(
name|v
operator|->
name|vh_shost
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * vvtimeout() - called by timer flywheel to monitor input packet  * discard rate.  Interfaces getting too many errors are shut  * down for a while.  If the condition persists, the interface  * is marked down.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vvtimeout
argument_list|(
argument|junk
argument_list|)
end_macro

begin_decl_stmt
name|int
name|junk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
decl_stmt|;
name|int
name|ubainfo
decl_stmt|;
name|timeout
argument_list|(
name|vvtimeout
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|VV_FLYWHEEL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVV
condition|;
name|i
operator|++
control|)
block|{
name|vs
operator|=
operator|&
name|vv_softc
index|[
name|i
index|]
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|vvinfo
index|[
name|i
index|]
operator|->
name|ui_addr
expr_stmt|;
if|if
condition|(
operator|(
name|vs
operator|->
name|vs_if
operator|.
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|vs
operator|->
name|vs_major
condition|)
block|{
comment|/* 		 * MODE0: generally OK, just check error rate  		 */
case|case
name|MODE0
case|:
if|if
condition|(
name|vs
operator|->
name|vs_dropped
operator|<
name|VV_ERRORTHRESHOLD
condition|)
block|{
name|vs
operator|->
name|vs_dropped
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* suspend reads for a while */
name|vvtrprintf
argument_list|(
literal|"vv%d going MODE1 in vvtimeout\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_major
operator|=
name|MODE1
expr_stmt|;
name|vs
operator|->
name|vs_iactive
operator|=
name|PAUSE
expr_stmt|;
comment|/* no new reads */
name|vs
operator|->
name|vs_retry
operator|=
name|VV_MODE1ATTEMPTS
expr_stmt|;
name|vs
operator|->
name|vs_delayclock
operator|=
name|VV_MODE1DELAY
expr_stmt|;
name|vs
operator|->
name|vs_minor
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* 		 * MODE1: excessive error rate observed 		 * Scheme: try simply suspending reads for a 		 * short while a small number of times 		 */
case|case
name|MODE1
case|:
if|if
condition|(
name|vs
operator|->
name|vs_delayclock
operator|>
literal|0
condition|)
block|{
name|vs
operator|->
name|vs_delayclock
operator|--
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|vs
operator|->
name|vs_minor
condition|)
block|{
case|case
literal|0
case|:
comment|/* reenable reads */
name|vvtrprintf
argument_list|(
literal|"vv%d M1m0\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_dropped
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_iactive
operator|=
name|ACTIVE
expr_stmt|;
name|vs
operator|->
name|vs_minor
operator|=
literal|1
expr_stmt|;
comment|/* next state */
name|ubainfo
operator|=
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
expr_stmt|;
name|addr
operator|->
name|vviba
operator|=
operator|(
name|u_short
operator|)
name|ubainfo
expr_stmt|;
name|addr
operator|->
name|vviea
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ubainfo
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vviwc
operator|=
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
operator|+
name|VVMTU
operator|)
operator|>>
literal|1
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
name|VV_RST
operator||
name|VV_CONF
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator||=
name|VV_IEN
operator||
name|VV_DEN
operator||
name|VV_ENB
expr_stmt|;
continue|continue;
case|case
literal|1
case|:
comment|/* see if it worked */
name|vvtrprintf
argument_list|(
literal|"vv%d M1m1\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_dropped
operator|<
name|VV_ERRORTHRESHOLD
condition|)
block|{
name|vs
operator|->
name|vs_dropped
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_major
operator|=
name|MODE0
expr_stmt|;
comment|/* yeah!! */
continue|continue;
block|}
if|if
condition|(
name|vs
operator|->
name|vs_retry
operator|--
operator|>
literal|0
condition|)
block|{
name|vs
operator|->
name|vs_dropped
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_iactive
operator|=
name|PAUSE
expr_stmt|;
name|vs
operator|->
name|vs_delayclock
operator|=
name|VV_MODE1DELAY
expr_stmt|;
name|vs
operator|->
name|vs_minor
operator|=
literal|0
expr_stmt|;
comment|/* recheck */
continue|continue;
block|}
name|vs
operator|->
name|vs_major
operator|=
name|MODE2
expr_stmt|;
name|vs
operator|->
name|vs_minor
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_dropped
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_iactive
operator|=
name|OPEN
expr_stmt|;
name|vs
operator|->
name|vs_delayrange
operator|=
name|VV_MODE2DELAY
expr_stmt|;
name|vs
operator|->
name|vs_delayclock
operator|=
name|VV_MODE2DELAY
expr_stmt|;
comment|/* fall thru ... */
block|}
comment|/* 		 * MODE2: simply ignoring traffic didn't relieve condition 		 * Scheme: open host relay for intervals linearly 		 * increasing up to some maximum of a several minutes. 		 * This allows broken networks to return to operation 		 * without rebooting. 		 */
case|case
name|MODE2
case|:
if|if
condition|(
name|vs
operator|->
name|vs_delayclock
operator|>
literal|0
condition|)
block|{
name|vs
operator|->
name|vs_delayclock
operator|--
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|vs
operator|->
name|vs_minor
condition|)
block|{
case|case
literal|0
case|:
comment|/* close relay and reenable reads */
name|vvtrprintf
argument_list|(
literal|"vv%d M2m0\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_dropped
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_iactive
operator|=
name|ACTIVE
expr_stmt|;
name|vs
operator|->
name|vs_minor
operator|=
literal|1
expr_stmt|;
comment|/* next state */
name|ubainfo
operator|=
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
expr_stmt|;
name|addr
operator|->
name|vviba
operator|=
operator|(
name|u_short
operator|)
name|ubainfo
expr_stmt|;
name|addr
operator|->
name|vviea
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ubainfo
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vviwc
operator|=
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
operator|+
name|VVMTU
operator|)
operator|>>
literal|1
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
name|VV_RST
operator||
name|VV_CONF
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator||=
name|VV_IEN
operator||
name|VV_DEN
operator||
name|VV_ENB
expr_stmt|;
continue|continue;
case|case
literal|1
case|:
comment|/* see if it worked */
name|vvtrprintf
argument_list|(
literal|"vv%d M2m1\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_dropped
operator|<
name|VV_ERRORTHRESHOLD
condition|)
block|{
name|vs
operator|->
name|vs_dropped
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_major
operator|=
name|MODE0
expr_stmt|;
comment|/* yeah!! */
continue|continue;
block|}
name|vvtrprintf
argument_list|(
literal|"vv%d M2m1 ++ delay\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_dropped
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_iactive
operator|=
name|OPEN
expr_stmt|;
name|vs
operator|->
name|vs_minor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_delayrange
operator|<
name|VV_MAXDELAY
condition|)
name|vs
operator|->
name|vs_delayrange
operator|+=
operator|(
name|vs
operator|->
name|vs_delayrange
operator|/
literal|2
operator|)
expr_stmt|;
name|vs
operator|->
name|vs_delayclock
operator|=
name|vs
operator|->
name|vs_delayrange
expr_stmt|;
continue|continue;
block|}
default|default:
name|printf
argument_list|(
literal|"vv%d: major state screwed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Start or restart output on interface.  * If interface is active, this is a retransmit, so just  * restuff registers and go.  * If interface is not already active, get another datagram  * to send off of the interface queue, and map it to the interface  * before starting the output.  */
end_comment

begin_macro
name|vvstart
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|VVUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|vvinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
init|=
operator|&
name|vv_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ubainfo
decl_stmt|;
name|int
name|dest
decl_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_oactive
condition|)
goto|goto
name|restart
goto|;
comment|/* 	 * Not already active: dequeue another request 	 * and map it to the UNIBUS.  If no more requests, 	 * just return. 	 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|vs
operator|->
name|vs_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|vs
operator|->
name|vs_oactive
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|dest
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|vv_header
operator|*
argument_list|)
operator|->
name|vh_dhost
expr_stmt|;
name|vs
operator|->
name|vs_olen
operator|=
name|if_wubaput
argument_list|(
operator|&
name|vs
operator|->
name|vs_ifuba
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_lastx
operator|=
name|dest
expr_stmt|;
name|restart
label|:
comment|/* 	 * Have request mapped to UNIBUS for transmission. 	 * Purge any stale data from this BDP, and start the otput. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_olen
operator|>
name|VVMTU
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"vv%d vs_olen: %d> VVMTU\n"
argument_list|,
name|unit
argument_list|,
name|vs
operator|->
name|vs_olen
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"vvdriver vs_olen botch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_uba
argument_list|,
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|ubainfo
operator|=
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_info
expr_stmt|;
name|addr
operator|->
name|vvoba
operator|=
operator|(
name|u_short
operator|)
name|ubainfo
expr_stmt|;
name|addr
operator|->
name|vvoea
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ubainfo
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vvowc
operator|=
operator|-
operator|(
operator|(
name|vs
operator|->
name|vs_olen
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|addr
operator|->
name|vvocsr
operator|=
name|VV_IEN
operator||
name|VV_CPB
operator||
name|VV_DEN
operator||
name|VV_INR
operator||
name|VV_ENB
expr_stmt|;
name|vs
operator|->
name|vs_oactive
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * VVLNI transmit interrupt  * Start another output if more data to send.  */
end_comment

begin_macro
name|vvxint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|vvinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
init|=
operator|&
name|vv_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|oc
decl_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|oc
operator|=
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|vvocsr
operator|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_oactive
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vv%d: stray interrupt vvocsr = %b\n"
argument_list|,
name|unit
argument_list|,
name|oc
argument_list|,
name|VV_OBITS
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|oc
operator|&
operator|(
name|VV_OPT
operator||
name|VV_RFS
operator|)
condition|)
block|{
name|vs
operator|->
name|vs_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_tries
operator|++
operator|<
name|VVRETRY
condition|)
block|{
if|if
condition|(
name|oc
operator|&
name|VV_OPT
condition|)
name|vs
operator|->
name|vs_init
operator|++
expr_stmt|;
if|if
condition|(
name|oc
operator|&
name|VV_RFS
condition|)
name|vs
operator|->
name|vs_nottaken
operator|++
expr_stmt|;
name|vvstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* restart this message */
return|return;
block|}
if|if
condition|(
name|oc
operator|&
name|VV_OPT
condition|)
name|printf
argument_list|(
literal|"vv%d: output timeout\n"
argument_list|)
expr_stmt|;
block|}
name|vs
operator|->
name|vs_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|vs
operator|->
name|vs_oactive
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_tries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oc
operator|&
name|VVXERR
condition|)
block|{
name|vs
operator|->
name|vs_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"vv%d: error vvocsr = %b\n"
argument_list|,
name|unit
argument_list|,
literal|0xffff
operator|&
name|oc
argument_list|,
name|VV_OBITS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_xtofree
condition|)
block|{
name|m_freem
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_xtofree
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_xtofree
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|vs
operator|->
name|vs_if
operator|.
name|if_snd
operator|.
name|ifq_head
operator|==
literal|0
condition|)
block|{
name|vs
operator|->
name|vs_lastx
operator|=
literal|256
expr_stmt|;
comment|/* an invalid address */
return|return;
block|}
name|vvstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * V2lni interface receiver interrupt.  * If input error just drop packet.  * Otherwise purge input buffered data path and examine   * packet to determine type.  If can't determine length  * from type, then have to drop packet.  Othewise decapsulate  * packet based on type and pass to type specific higher-level  * input routine.  */
end_comment

begin_macro
name|vvrint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
init|=
operator|&
name|vv_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|vvreg
modifier|*
name|addr
init|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|vvinfo
index|[
name|unit
index|]
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|vv_header
modifier|*
name|vv
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ubainfo
decl_stmt|,
name|len
decl_stmt|,
name|off
decl_stmt|;
name|short
name|resid
decl_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
comment|/* 	 * Purge BDP; drop if input error indicated. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_uba
argument_list|,
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|vvicsr
operator|&
name|VVRERR
condition|)
block|{
if|if
condition|(
name|vv_logreaderrors
condition|)
name|printf
argument_list|(
literal|"vv%d: error vvicsr = %b\n"
argument_list|,
name|unit
argument_list|,
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|vvicsr
operator|)
argument_list|,
name|VV_IBITS
argument_list|)
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
comment|/* 	 * Get packet length from word count residue 	 * 	 * Compute header offset if trailer protocol 	 * 	 * Pull packet off interface.  Off is nonzero if packet 	 * has trailing header; if_rubaget will then force this header 	 * information to be at the front.  The vh_info field 	 * carries the offset to the trailer data in trailer 	 * format packets. 	 */
name|vv
operator|=
operator|(
expr|struct
name|vv_header
operator|*
operator|)
operator|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
operator|)
expr_stmt|;
name|vvtracehdr
argument_list|(
literal|"vi"
argument_list|,
name|vv
argument_list|)
expr_stmt|;
name|resid
operator|=
name|addr
operator|->
name|vviwc
expr_stmt|;
if|if
condition|(
name|resid
condition|)
name|resid
operator||=
literal|0176000
expr_stmt|;
comment|/* ugly!!!! */
name|len
operator|=
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
operator|+
name|VVMRU
operator|)
operator|>>
literal|1
operator|)
operator|+
name|resid
operator|)
operator|<<
literal|1
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|VVMRU
operator|||
name|len
operator|<=
literal|0
condition|)
goto|goto
name|dropit
goto|;
define|#
directive|define
name|vvdataaddr
parameter_list|(
name|vv
parameter_list|,
name|off
parameter_list|,
name|type
parameter_list|)
value|((type)(((caddr_t)((vv)+1)+(off))))
if|if
condition|(
name|vv_dotrailer
operator|&&
name|vv
operator|->
name|vh_type
operator|>=
name|RING_IPTrailer
operator|&&
name|vv
operator|->
name|vh_type
operator|<
name|RING_IPTrailer
operator|+
name|RING_IPNTrailer
condition|)
block|{
name|off
operator|=
operator|(
name|vv
operator|->
name|vh_type
operator|-
name|RING_IPTrailer
operator|)
operator|*
literal|512
expr_stmt|;
if|if
condition|(
name|off
operator|>
name|VVMTU
condition|)
goto|goto
name|dropit
goto|;
name|vv
operator|->
name|vh_type
operator|=
operator|*
name|vvdataaddr
argument_list|(
name|vv
argument_list|,
name|off
argument_list|,
name|u_short
operator|*
argument_list|)
expr_stmt|;
name|resid
operator|=
operator|*
operator|(
name|vvdataaddr
argument_list|(
name|vv
argument_list|,
name|off
operator|+
literal|2
argument_list|,
name|u_short
operator|*
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|resid
operator|>
name|len
condition|)
goto|goto
name|dropit
goto|;
name|len
operator|=
name|off
operator|+
name|resid
expr_stmt|;
block|}
else|else
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|dropit
goto|;
name|m
operator|=
name|if_rubaget
argument_list|(
operator|&
name|vs
operator|->
name|vs_ifuba
argument_list|,
name|len
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|dropit
goto|;
if|if
condition|(
name|off
condition|)
block|{
name|m
operator|->
name|m_off
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Demultiplex on packet type  	 */
switch|switch
condition|(
name|vv
operator|->
name|vh_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|RING_IP
case|:
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"vv%d: unknown pkt type 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|vv
operator|->
name|vh_type
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|setup
goto|;
block|}
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|setup
label|:
comment|/* 	 * Check the error rate and start recovery if needed 	 * this has to go here since the timer flywheel runs at 	 * a lower ipl and never gets a chance to change the mode 	 */
if|if
condition|(
name|vs
operator|->
name|vs_major
operator|==
name|MODE0
operator|&&
name|vs
operator|->
name|vs_dropped
operator|>
name|VV_ERRORTHRESHOLD
condition|)
block|{
name|vvtrprintf
argument_list|(
literal|"vv%d going MODE1 in vvrint\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_major
operator|=
name|MODE1
expr_stmt|;
name|vs
operator|->
name|vs_iactive
operator|=
name|PAUSE
expr_stmt|;
comment|/* no new reads */
name|vs
operator|->
name|vs_retry
operator|=
name|VV_MODE1ATTEMPTS
expr_stmt|;
name|vs
operator|->
name|vs_delayclock
operator|=
name|VV_MODE1DELAY
expr_stmt|;
name|vs
operator|->
name|vs_minor
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_dropped
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|vs
operator|->
name|vs_iactive
condition|)
block|{
case|case
name|ACTIVE
case|:
comment|/* Restart the read for next packet */
name|ubainfo
operator|=
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
expr_stmt|;
name|addr
operator|->
name|vviba
operator|=
operator|(
name|u_short
operator|)
name|ubainfo
expr_stmt|;
name|addr
operator|->
name|vviea
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ubainfo
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vviwc
operator|=
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
operator|+
name|VVMTU
operator|)
operator|>>
literal|1
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
name|VV_RST
operator||
name|VV_CONF
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator||=
name|VV_IEN
operator||
name|VV_DEN
operator||
name|VV_ENB
expr_stmt|;
return|return;
case|case
name|PAUSE
case|:
comment|/* requested to not start any new reads */
name|vs
operator|->
name|vs_dropped
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|OPEN
case|:
comment|/* request to open host relay */
name|vs
operator|->
name|vs_dropped
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
name|printf
argument_list|(
literal|"vv%d: vs_iactive = %d\n"
argument_list|,
name|unit
argument_list|,
name|vs
operator|->
name|vs_iactive
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Drop packet on floor -- count them!! 	 */
name|dropit
label|:
name|vs
operator|->
name|vs_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|vs
operator|->
name|vs_dropped
operator|++
expr_stmt|;
comment|/* 	printf("vv%d: error vvicsr = %b\n", unit, 		0xffff&(addr->vvicsr), VV_IBITS); 	*/
goto|goto
name|setup
goto|;
block|}
end_block

begin_comment
comment|/*  * V2lni output routine.  * Encapsulate a packet of type family for the local net.  * Use trailer local net encapsulation if enough data in first  * packet leaves a multiple of 512 bytes of data in remainder.  */
end_comment

begin_macro
name|vvoutput
argument_list|(
argument|ifp
argument_list|,
argument|m0
argument_list|,
argument|dst
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
specifier|register
name|struct
name|vv_header
modifier|*
name|vv
decl_stmt|;
specifier|register
name|int
name|off
decl_stmt|;
name|int
name|type
decl_stmt|,
name|dest
decl_stmt|,
name|s
decl_stmt|,
name|error
decl_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|dest
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
operator|(
name|dest
operator|=
name|in_lnaof
argument_list|(
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|dest
operator|)
argument_list|)
operator|)
operator|>=
literal|0x100
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|off
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|->
name|ip_len
argument_list|)
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|vv_dotrailer
operator|&&
name|off
operator|>
literal|0
operator|&&
operator|(
name|off
operator|&
literal|0x1ff
operator|)
operator|==
literal|0
operator|&&
name|m
operator|->
name|m_off
operator|>=
name|MMINOFF
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
block|{
name|type
operator|=
name|RING_IPTrailer
operator|+
operator|(
name|off
operator|>>
literal|9
operator|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_short
operator|*
argument_list|)
operator|=
name|RING_IP
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_short
operator|*
argument_list|)
operator|+
literal|1
operator|)
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
goto|goto
name|gottrailertype
goto|;
block|}
name|type
operator|=
name|RING_IP
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
goto|goto
name|gottype
goto|;
block|}
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"vv%d: can't handle af%d\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|gottrailertype
label|:
comment|/* 	 * Packet to be sent as trailer: move first packet 	 * (control information) to end of chain. 	 */
while|while
condition|(
name|m
operator|->
name|m_next
condition|)
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|m
operator|=
name|m0
operator|->
name|m_next
expr_stmt|;
name|m0
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
name|gottype
label|:
comment|/* 	 * Add local net header.  If no space in first mbuf, 	 * allocate another. 	 */
if|if
condition|(
name|m
operator|->
name|m_off
operator|>
name|MMAXOFF
operator|||
name|MMINOFF
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
operator|>
name|m
operator|->
name|m_off
condition|)
block|{
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMINOFF
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
expr_stmt|;
block|}
name|vv
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|vv_header
operator|*
argument_list|)
expr_stmt|;
name|vv
operator|->
name|vh_shost
operator|=
name|ifp
operator|->
name|if_host
index|[
literal|0
index|]
expr_stmt|;
name|vv
operator|->
name|vh_dhost
operator|=
name|dest
expr_stmt|;
name|vv
operator|->
name|vh_version
operator|=
name|RING_VERSION
expr_stmt|;
name|vv
operator|->
name|vh_type
operator|=
name|type
expr_stmt|;
name|vv
operator|->
name|vh_info
operator|=
name|off
expr_stmt|;
name|vvtracehdr
argument_list|(
literal|"vo"
argument_list|,
name|vv
argument_list|)
expr_stmt|;
comment|/* 	 * Queue message on interface, and start output if interface 	 * not yet active. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|qfull
goto|;
block|}
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|vv_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|vs_oactive
operator|==
literal|0
condition|)
name|vvstart
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|qfull
label|:
name|m0
operator|=
name|m
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bad
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * vvprt_hdr(s, v) print the local net header in "v"  * 	with title is "s"  */
end_comment

begin_macro
name|vvprt_hdr
argument_list|(
argument|s
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|vv_header
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%s: dsvti: 0x%x 0x%x 0x%x 0x%x 0x%x\n"
argument_list|,
name|s
argument_list|,
literal|0xff
operator|&
call|(
name|int
call|)
argument_list|(
name|v
operator|->
name|vh_dhost
argument_list|)
argument_list|,
literal|0xff
operator|&
call|(
name|int
call|)
argument_list|(
name|v
operator|->
name|vh_shost
argument_list|)
argument_list|,
literal|0xff
operator|&
call|(
name|int
call|)
argument_list|(
name|v
operator|->
name|vh_version
argument_list|)
argument_list|,
literal|0xff
operator|&
call|(
name|int
call|)
argument_list|(
name|v
operator|->
name|vh_type
argument_list|)
argument_list|,
literal|0xffff
operator|&
call|(
name|int
call|)
argument_list|(
name|v
operator|->
name|vh_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * print "l" hex bytes starting at "s"  */
end_comment

begin_macro
name|vvprt_hex
argument_list|(
argument|s
argument_list|,
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|z
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
name|z
operator|=
literal|0xff
operator|&
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
name|s
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%c "
argument_list|,
literal|"0123456789abcdef"
index|[
operator|(
name|z
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
index|]
argument_list|,
literal|"0123456789abcdef"
index|[
name|z
operator|&
literal|0x0f
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

