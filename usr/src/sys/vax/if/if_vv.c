begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)if_vv.c	7.7 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"vv.h"
end_include

begin_if
if|#
directive|if
name|NVV
operator|>
literal|0
end_if

begin_comment
comment|/*  * Proteon ProNET-10 and ProNET-80 token ring driver.  * The name of this device driver derives from the old MIT  * name of V2LNI for the proNET hardware, would would abbreviate  * to "v2", but this won't work right in config. Thus the name is "vv".  *  * This driver is compatible with the Unibus ProNET 10 megabit and  * 80 megabit token ring interfaces (models p1000 and p1080).  * A unit may be marked as 80 megabit using "flags 1" in the  * config file.  *  * This driver is also compatible with the Q-bus ProNET 10 megabit and  * 80 megabit token ring interfaces (models p1100 and p1180), but  * only on a MicroVAX-II or MicroVAX-III.  No attempt is made to  * support the MicroVAX-I.  *  * TRAILERS: This driver has a new implementation of trailers that  * is at least a tolerable neighbor on the ring. The offset is not  * stored in the protocol type, but instead only in the vh_info  * field. Also, the vh_info field, and the two shorts before the  * trailing header, are in network byte order, not VAX byte order.  *  * Of course, nothing but BSD UNIX supports trailers on ProNET.  * If you need interoperability with anything else (like the p4200),  * turn off trailers using the -trailers option to /etc/ifconfig!  *  * HARDWARE COMPATABILITY: This driver prefers that the HSBU (p1001)  * have a serial number>= 040, which is about March, 1982. Older  * HSBUs do not carry across 64kbyte boundaries. They can be supported  * by adding "| UBA_NEED16" to the vs_ifuba.ifu_flags initialization  * in vvattach().  *  * The old warning about use without Wire Centers applies only to CTL  * (p1002) cards with serial<= 057, which have not received ECO 176-743,  * which was implemented in March, 1982. Most such CTLs have received  * this ECO.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/if_types.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../vax/pte.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"if_vv.h"
end_include

begin_include
include|#
directive|include
file|"if_uba.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_comment
comment|/*  *    maximum transmission unit definition --  *        you can set VVMTU at anything from 576 to 2036.  *        1536 is a popular "large" value, because it is a multiple  *	  of 512, which the trailer scheme likes.  *        The absolute maximum size is 2036, which is enforced.  */
end_comment

begin_define
define|#
directive|define
name|VVMTU
value|(2036)
end_define

begin_define
define|#
directive|define
name|VVMRU
value|(VVMTU + (2 * sizeof(u_short)))
end_define

begin_define
define|#
directive|define
name|VVBUFSIZE
value|(VVMRU + sizeof(struct vv_header))
end_define

begin_if
if|#
directive|if
name|VVMTU
operator|>
literal|2036
end_if

begin_undef
undef|#
directive|undef
name|VVMTU
end_undef

begin_undef
undef|#
directive|undef
name|VVMRU
end_undef

begin_undef
undef|#
directive|undef
name|VVBUFSIZE
end_undef

begin_define
define|#
directive|define
name|VVBUFSIZE
value|(2046)
end_define

begin_define
define|#
directive|define
name|VVMRU
value|(VVBUFSIZE - sizeof (struct vv_header))
end_define

begin_define
define|#
directive|define
name|VVMTU
value|(VVMRU - (2 * sizeof(u_short)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *   debugging and tracing stuff  */
end_comment

begin_decl_stmt
name|int
name|vv_tracehdr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => trace headers (slowly!!) */
end_comment

begin_define
define|#
directive|define
name|vvtracehdr
value|if (vv_tracehdr) vvprt_hdr
end_define

begin_define
define|#
directive|define
name|vvlog
value|if (vs->vs_if.if_flags& IFF_DEBUG) log
end_define

begin_comment
comment|/*  * externals, types, etc.  */
end_comment

begin_decl_stmt
name|int
name|vvprobe
argument_list|()
decl_stmt|,
name|vvattach
argument_list|()
decl_stmt|,
name|vvreset
argument_list|()
decl_stmt|,
name|vvinit
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vvidentify
argument_list|()
decl_stmt|,
name|vvstart
argument_list|()
decl_stmt|,
name|vvxint
argument_list|()
decl_stmt|,
name|vvwatchdog
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vvrint
argument_list|()
decl_stmt|,
name|vvoutput
argument_list|()
decl_stmt|,
name|vvioctl
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|vvinfo
index|[
name|NVV
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|vvstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|vvdriver
init|=
block|{
name|vvprobe
block|,
literal|0
block|,
name|vvattach
block|,
literal|0
block|,
name|vvstd
block|,
literal|"vv"
block|,
name|vvinfo
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VVUNIT
parameter_list|(
name|x
parameter_list|)
value|minor(x)
end_define

begin_define
define|#
directive|define
name|LOOPBACK
end_define

begin_comment
comment|/* use loopback for packets meant for us */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LOOPBACK
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
name|loif
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_extern
extern|extern wakeup(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * Software status of each interface.  *  * Each interface is referenced by a network interface structure,  * vs_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  * We also have, for each interface, a UBA interface structure, which  * contains information about the UNIBUS resources held by the interface:  * map registers, buffered data paths, etc.  Information is cached in this  * structure for use by the if_uba.c routines in running the interface  * efficiently.  */
end_comment

begin_struct
struct|struct
name|vv_softc
block|{
name|struct
name|ifnet
name|vs_if
decl_stmt|;
comment|/* network-visible interface */
name|struct
name|ifuba
name|vs_ifuba
decl_stmt|;
comment|/* UNIBUS resources */
name|u_short
name|vs_host
decl_stmt|;
comment|/* this interface address */
name|short
name|vs_oactive
decl_stmt|;
comment|/* is output active */
name|short
name|vs_is80
decl_stmt|;
comment|/* is 80 megabit version */
name|short
name|vs_olen
decl_stmt|;
comment|/* length of last output */
name|u_short
name|vs_lastx
decl_stmt|;
comment|/* address of last packet sent */
name|u_short
name|vs_lastr
decl_stmt|;
comment|/* address of last packet received */
name|short
name|vs_tries
decl_stmt|;
comment|/* transmit current retry count */
name|short
name|vs_init
decl_stmt|;
comment|/* number of ring inits */
name|short
name|vs_refused
decl_stmt|;
comment|/* number of packets refused */
name|short
name|vs_timeouts
decl_stmt|;
comment|/* number of transmit timeouts */
name|short
name|vs_otimeout
decl_stmt|;
comment|/* number of output timeouts */
name|short
name|vs_ibadf
decl_stmt|;
comment|/* number of input bad formats */
name|short
name|vs_parity
decl_stmt|;
comment|/* number of parity errors on 10 meg, */
comment|/* link data errors on 80 meg */
name|short
name|vs_ipl
decl_stmt|;
comment|/* interrupt priority on Q-bus */
name|short
name|vs_flags
decl_stmt|;
comment|/* board state: */
define|#
directive|define
name|VS_RUNNING
value|0x01
comment|/* board has been initialized */
define|#
directive|define
name|VS_INIT
value|0x02
comment|/* board being initialized */
block|}
name|vv_softc
index|[
name|NVV
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|NOHOST
value|0xff
end_define

begin_comment
comment|/* illegal host number */
end_comment

begin_comment
comment|/*  * probe the interface to see that the registers exist, and then  * cause an interrupt to find its vector  */
end_comment

begin_macro
name|vvprobe
argument_list|(
argument|reg
argument_list|,
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|reg
expr_stmt|;
comment|/* reset interface, enable, and wait till dust settles */
ifdef|#
directive|ifdef
name|QBA
operator|(
name|void
operator|)
name|spl6
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|addr
operator|->
name|vvicsr
operator|=
name|VV_RST
expr_stmt|;
name|addr
operator|->
name|vvocsr
operator|=
name|VV_RST
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* generate interrupt by doing 1 word DMA from 0 in uba space!! */
name|addr
operator|->
name|vvoba
operator|=
literal|0
expr_stmt|;
comment|/* low 16 bits */
name|addr
operator|->
name|vvoea
operator|=
literal|0
expr_stmt|;
comment|/* extended bits */
name|addr
operator|->
name|vvowc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* for 1 word */
name|addr
operator|->
name|vvocsr
operator|=
name|VV_IEN
operator||
name|VV_DEN
expr_stmt|;
comment|/* start the DMA, with interrupt */
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QBA
name|vv_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|vs_ipl
operator|=
name|br
operator|=
name|qbgetpri
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|addr
operator|->
name|vvocsr
operator|=
name|VV_RST
expr_stmt|;
comment|/* clear out the CSR */
if|if
condition|(
name|cvec
operator|&&
name|cvec
operator|!=
literal|0x200
condition|)
name|cvec
operator|-=
literal|4
expr_stmt|;
comment|/* backup so vector => receive */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|vvreg
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_macro
name|vvattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
decl_stmt|;
name|vs
operator|=
operator|&
name|vv_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_unit
operator|=
name|ui
operator|->
name|ui_unit
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_name
operator|=
literal|"vv"
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_mtu
operator|=
name|VVMTU
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_flags
operator|=
name|IFF_BROADCAST
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_init
operator|=
name|vvinit
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_ioctl
operator|=
name|vvioctl
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_output
operator|=
name|vvoutput
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_reset
operator|=
name|vvreset
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_watchdog
operator|=
name|vvwatchdog
expr_stmt|;
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|=
name|UBA_CANTWAIT
operator||
name|UBA_NEEDBDP
expr_stmt|;
comment|/* use flag to determine if this is proNET-80 */
if|if
condition|(
name|vs
operator|->
name|vs_is80
operator|=
call|(
name|short
call|)
argument_list|(
name|ui
operator|->
name|ui_flags
operator|&
literal|01
argument_list|)
condition|)
block|{
name|vs
operator|->
name|vs_if
operator|.
name|if_type
operator|=
name|IFT_P80
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_baudrate
operator|=
literal|80
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
block|}
else|else
block|{
name|vs
operator|->
name|vs_if
operator|.
name|if_type
operator|=
name|IFT_P10
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_baudrate
operator|=
literal|10
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
block|}
name|vs
operator|->
name|vs_host
operator|=
name|NOHOST
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VAX750
argument_list|)
comment|/* don't chew up 750 bdp's */
if|if
condition|(
name|cpu
operator|==
name|VAX_750
operator|&&
name|ui
operator|->
name|ui_unit
operator|>
literal|0
condition|)
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|&=
operator|~
name|UBA_NEEDBDP
expr_stmt|;
endif|#
directive|endif
name|if_attach
argument_list|(
operator|&
name|vs
operator|->
name|vs_if
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset of interface after UNIBUS reset.  * If interface is on specified uba, reset its state.  */
end_comment

begin_macro
name|vvreset
argument_list|(
argument|unit
argument_list|,
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NVV
operator|||
operator|(
name|ui
operator|=
name|vvinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_ubanum
operator|!=
name|uban
condition|)
return|return;
name|printf
argument_list|(
literal|" vv%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|vv_softc
index|[
name|unit
index|]
operator|.
name|vs_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|vv_softc
index|[
name|unit
index|]
operator|.
name|vs_flags
operator|&=
operator|~
name|VS_RUNNING
expr_stmt|;
name|vvinit
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialization of interface; clear recorded pending  * operations, and reinitialize UNIBUS usage.  */
end_comment

begin_macro
name|vvinit
argument_list|(
argument|unit
argument_list|,
argument|cansleep
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|cansleep
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|ubaaddr
decl_stmt|,
name|s
decl_stmt|;
name|vs
operator|=
operator|&
name|vv_softc
index|[
name|unit
index|]
expr_stmt|;
name|ui
operator|=
name|vvinfo
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_if
operator|.
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* 	 * Prevent multiple instances of vvinit 	 * from trying simultaneously. 	 */
while|while
condition|(
name|vs
operator|->
name|vs_flags
operator|&
name|VS_INIT
condition|)
block|{
if|if
condition|(
name|cansleep
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vs
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
if|if
condition|(
name|vs
operator|->
name|vs_flags
operator|&
name|VS_RUNNING
condition|)
return|return;
name|vs
operator|->
name|vs_flags
operator|=
name|VS_INIT
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
if|if
condition|(
operator|(
name|vs
operator|->
name|vs_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|&&
name|if_ubainit
argument_list|(
operator|&
name|vs
operator|->
name|vs_ifuba
argument_list|,
name|ui
operator|->
name|ui_ubanum
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|btoc
argument_list|(
name|VVMRU
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vv%d: can't initialize, if_ubainit() failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|vs
operator|->
name|vs_flags
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|vs
operator|->
name|vs_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
comment|/* 	 * Now that the uba is set up, figure out our address and 	 * update complete our host address. 	 */
if|if
condition|(
name|cansleep
condition|)
name|vs
operator|->
name|vs_host
operator|=
name|vvidentify
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_host
operator|==
name|NOHOST
condition|)
block|{
name|vs
operator|->
name|vs_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|vs
operator|->
name|vs_flags
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|vvlog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vv%d: host %u\n"
argument_list|,
name|unit
argument_list|,
name|vs
operator|->
name|vs_host
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the interface, and stay in the ring 	 */
name|addr
operator|->
name|vvocsr
operator|=
name|VV_RST
expr_stmt|;
comment|/* take over output */
name|addr
operator|->
name|vvocsr
operator|=
name|VV_CPB
expr_stmt|;
comment|/* clear packet buffer */
name|addr
operator|->
name|vvicsr
operator|=
name|VV_RST
operator||
name|VV_HEN
expr_stmt|;
comment|/* take over input, */
comment|/* keep relay closed */
if|if
condition|(
name|cansleep
condition|)
block|{
name|timeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
name|vs
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vs
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
comment|/* let contacts settle */
block|}
else|else
name|DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
comment|/* let contacts settle */
name|vs
operator|->
name|vs_init
operator|=
literal|0
expr_stmt|;
comment|/* clear counters, etc. */
name|vs
operator|->
name|vs_refused
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_timeouts
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_otimeout
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_ibadf
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_parity
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_lastx
operator|=
literal|256
expr_stmt|;
comment|/* an invalid address */
name|vs
operator|->
name|vs_lastr
operator|=
literal|256
expr_stmt|;
comment|/* an invalid address */
comment|/* 	 * Hang a receive and start any 	 * pending writes by faking a transmit complete. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ubaaddr
operator|=
name|UBAI_ADDR
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vviba
operator|=
operator|(
name|u_short
operator|)
name|ubaaddr
expr_stmt|;
name|addr
operator|->
name|vviea
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ubaaddr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vviwc
operator|=
operator|-
operator|(
name|VVBUFSIZE
operator|)
operator|>>
literal|1
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
name|VV_IEN
operator||
name|VV_HEN
operator||
name|VV_DEN
operator||
name|VV_ENB
expr_stmt|;
name|vs
operator|->
name|vs_oactive
operator|=
literal|1
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|vs
operator|->
name|vs_flags
operator|=
name|VS_RUNNING
expr_stmt|;
comment|/* clear VS_INIT */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|vs
argument_list|)
expr_stmt|;
name|vvxint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do a moderately thorough self-test in all three modes. Mostly  * to keeps defective nodes off the ring, rather than to be especially  * thorough. The key issue is to detect any cable breaks before joining  * the ring. Return our node address on success, return -1 on failure.  *  */
end_comment

begin_comment
comment|/* the three self-test modes */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|vv_modes
index|[]
init|=
block|{
name|VV_STE
operator||
name|VV_LPB
block|,
comment|/* digital loopback */
name|VV_STE
block|,
comment|/* analog loopback */
name|VV_HEN
comment|/* network mode */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|vvidentify
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|vv_header
modifier|*
name|v
decl_stmt|;
specifier|register
name|int
name|ubaaddr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|successes
decl_stmt|,
name|failures
decl_stmt|,
name|waitcount
decl_stmt|;
name|u_short
name|shost
init|=
name|NOHOST
decl_stmt|;
name|vs
operator|=
operator|&
name|vv_softc
index|[
name|unit
index|]
expr_stmt|;
name|ui
operator|=
name|vvinfo
index|[
name|unit
index|]
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
comment|/* 	 * Build a multicast message to identify our address 	 * We need do this only once, since nobody else is about to use 	 * the intermediate transmit buffer (ifu_w.ifrw_addr) that 	 * if_ubainit() aquired for us. 	 */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"vv%d: can't initialize, m_get() failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOHOST
operator|)
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
expr_stmt|;
name|v
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|vv_header
operator|*
argument_list|)
expr_stmt|;
name|v
operator|->
name|vh_dhost
operator|=
name|VV_BROADCAST
expr_stmt|;
comment|/* multicast destination address */
name|v
operator|->
name|vh_shost
operator|=
literal|0
expr_stmt|;
comment|/* will be overwritten with ours */
name|v
operator|->
name|vh_version
operator|=
name|RING_VERSION
expr_stmt|;
name|v
operator|->
name|vh_type
operator|=
name|RING_DIAGNOSTICS
expr_stmt|;
name|v
operator|->
name|vh_info
operator|=
literal|0
expr_stmt|;
comment|/* map xmit message into uba, copying to intermediate buffer */
name|vs
operator|->
name|vs_olen
operator|=
name|if_wubaput
argument_list|(
operator|&
name|vs
operator|->
name|vs_ifuba
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * For each of the modes (digital, analog, network), go through 	 * a self-test that requires me to send VVIDENTSUCC good packets 	 * in VVIDENTRETRY attempts. Use broadcast destination to find out 	 * who I am, then use this as my address to check my address match 	 * logic. Only data checked is the vh_type field. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|successes
operator|=
literal|0
expr_stmt|;
comment|/* clear successes for this mode */
name|failures
operator|=
literal|0
expr_stmt|;
comment|/* and clear failures, too */
comment|/* take over device, and leave ring */
name|addr
operator|->
name|vvicsr
operator|=
name|VV_RST
expr_stmt|;
name|addr
operator|->
name|vvocsr
operator|=
name|VV_RST
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
name|vv_modes
index|[
name|i
index|]
expr_stmt|;
comment|/* test mode */
comment|/* 		 * let the flag and token timers pop so that the init ring bit 		 * will be allowed to work, by waiting about 1 second 		 */
name|timeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
name|vs
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vs
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
comment|/* 		 * retry loop  		 */
while|while
condition|(
operator|(
name|successes
operator|<
name|VVIDENTSUCC
operator|)
operator|&&
operator|(
name|failures
operator|<
name|VVIDENTRETRY
operator|)
condition|)
block|{
comment|/* start a receive */
name|ubaaddr
operator|=
name|UBAI_ADDR
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
name|VV_RST
operator||
name|vv_modes
index|[
name|i
index|]
expr_stmt|;
comment|/* abort last */
name|addr
operator|->
name|vviba
operator|=
operator|(
name|u_short
operator|)
name|ubaaddr
expr_stmt|;
name|addr
operator|->
name|vviea
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ubaaddr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vviwc
operator|=
operator|-
operator|(
name|VVBUFSIZE
operator|)
operator|>>
literal|1
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
name|vv_modes
index|[
name|i
index|]
operator||
name|VV_DEN
operator||
name|VV_ENB
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* purge stale data from BDP */
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_uba
argument_list|,
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* do a transmit */
name|ubaaddr
operator|=
name|UBAI_ADDR
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_info
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vvocsr
operator|=
name|VV_RST
expr_stmt|;
comment|/* abort last try */
name|addr
operator|->
name|vvoba
operator|=
operator|(
name|u_short
operator|)
name|ubaaddr
expr_stmt|;
name|addr
operator|->
name|vvoea
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ubaaddr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vvowc
operator|=
operator|-
operator|(
operator|(
name|vs
operator|->
name|vs_olen
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|addr
operator|->
name|vvocsr
operator|=
name|VV_CPB
operator||
name|VV_DEN
operator||
name|VV_INR
operator||
name|VV_ENB
expr_stmt|;
comment|/* poll receive side for completion */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* give it a chance */
for|for
control|(
name|waitcount
operator|=
literal|0
init|;
name|waitcount
operator|<
literal|10
condition|;
name|waitcount
operator|++
control|)
block|{
if|if
condition|(
name|addr
operator|->
name|vvicsr
operator|&
name|VV_RDY
condition|)
goto|goto
name|gotit
goto|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|failures
operator|++
expr_stmt|;
comment|/* no luck */
continue|continue;
name|gotit
label|:
comment|/* we got something--is it any good? */
if|if
condition|(
operator|(
name|addr
operator|->
name|vvicsr
operator|&
operator|(
name|VVRERR
operator||
name|VV_LDE
operator|)
operator|)
operator|||
operator|(
name|addr
operator|->
name|vvocsr
operator|&
operator|(
name|VVXERR
operator||
name|VV_RFS
operator|)
operator|)
condition|)
block|{
name|failures
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Purge BDP before looking at received packet */
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_uba
argument_list|,
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|m
operator|=
name|if_rubaget
argument_list|(
operator|&
name|vs
operator|->
name|vs_ifuba
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|vs
operator|->
name|vs_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
operator|(
expr|struct
name|vv_header
operator|*
operator|)
operator|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
operator|)
expr_stmt|;
comment|/* check message type, catch our node address */
if|if
condition|(
operator|(
name|v
operator|->
name|vh_type
operator|&
literal|0xff
operator|)
operator|==
name|RING_DIAGNOSTICS
condition|)
block|{
if|if
condition|(
name|shost
operator|==
name|NOHOST
condition|)
block|{
name|shost
operator|=
name|v
operator|->
name|vh_shost
operator|&
literal|0xff
expr_stmt|;
comment|/* send to ourself now */
operator|(
operator|(
expr|struct
name|vv_header
operator|*
operator|)
operator|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
operator|)
operator|)
operator|->
name|vh_dhost
operator|=
name|shost
expr_stmt|;
block|}
name|successes
operator|++
expr_stmt|;
block|}
else|else
block|{
name|failures
operator|++
expr_stmt|;
block|}
name|v
operator|->
name|vh_type
operator|=
literal|0
expr_stmt|;
comment|/* clear to check again */
block|}
if|if
condition|(
name|failures
operator|>=
name|VVIDENTRETRY
condition|)
block|{
name|printf
argument_list|(
literal|"vv%d: failed self-test after %d tries \ in %s mode\n"
argument_list|,
name|unit
argument_list|,
name|VVIDENTRETRY
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|"digital loopback"
else|:
operator|(
name|i
operator|==
literal|1
condition|?
literal|"analog loopback"
else|:
literal|"network"
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vv%d: icsr = %b, ocsr = %b\n"
argument_list|,
name|unit
argument_list|,
literal|0xffff
operator|&
name|addr
operator|->
name|vvicsr
argument_list|,
name|VV_IBITS
argument_list|,
literal|0xffff
operator|&
name|addr
operator|->
name|vvocsr
argument_list|,
name|VV_OBITS
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
name|VV_RST
expr_stmt|;
comment|/* kill the sick board */
name|addr
operator|->
name|vvocsr
operator|=
name|VV_RST
expr_stmt|;
name|shost
operator|=
name|NOHOST
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
comment|/* deallocate mbuf used for send packet (won't be one, anyways) */
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_xtofree
condition|)
block|{
name|m_freem
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_xtofree
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_xtofree
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|shost
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Start or restart output on interface.  * If interface is active, this is a retransmit, so just  * restuff registers and go.  * If interface is not already active, get another datagram  * to send off of the interface queue, and map it to the interface  * before starting the output.  */
end_comment

begin_macro
name|vvstart
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|,
name|ubaaddr
decl_stmt|,
name|dest
decl_stmt|,
name|s
decl_stmt|;
name|unit
operator|=
name|VVUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ui
operator|=
name|vvinfo
index|[
name|unit
index|]
expr_stmt|;
name|vs
operator|=
operator|&
name|vv_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_oactive
condition|)
goto|goto
name|restart
goto|;
comment|/* 	 * Not already active: dequeue another request 	 * and map it to the UNIBUS.  If no more requests, 	 * just return. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|vs
operator|->
name|vs_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|vs
operator|->
name|vs_oactive
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|dest
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|vv_header
operator|*
argument_list|)
operator|->
name|vh_dhost
expr_stmt|;
name|vs
operator|->
name|vs_olen
operator|=
name|if_wubaput
argument_list|(
operator|&
name|vs
operator|->
name|vs_ifuba
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_lastx
operator|=
name|dest
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_obytes
operator|+=
name|vs
operator|->
name|vs_olen
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_lastchange
operator|=
name|time
expr_stmt|;
name|restart
label|:
comment|/* 	 * Have request mapped to UNIBUS for transmission. 	 * Purge any stale data from this BDP, and start the output. 	 * 	 * Make sure this packet will fit in the interface. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_olen
operator|>
name|VVBUFSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"vv%d vs_olen: %d> VVBUFSIZE\n"
argument_list|,
name|unit
argument_list|,
name|vs
operator|->
name|vs_olen
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"vvdriver vs_olen botch"
argument_list|)
expr_stmt|;
block|}
name|vs
operator|->
name|vs_if
operator|.
name|if_timer
operator|=
name|VVTIMEOUT
expr_stmt|;
name|vs
operator|->
name|vs_oactive
operator|=
literal|1
expr_stmt|;
comment|/* ship it */
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_uba
argument_list|,
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|ubaaddr
operator|=
name|UBAI_ADDR
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_info
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vvoba
operator|=
operator|(
name|u_short
operator|)
name|ubaaddr
expr_stmt|;
name|addr
operator|->
name|vvoea
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ubaaddr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vvowc
operator|=
operator|-
operator|(
operator|(
name|vs
operator|->
name|vs_olen
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|addr
operator|->
name|vvowc
operator|=
operator|-
operator|(
operator|(
name|vs
operator|->
name|vs_olen
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* extra byte is garbage */
if|if
condition|(
name|addr
operator|->
name|vvocsr
operator|&
name|VV_NOK
condition|)
name|vs
operator|->
name|vs_init
operator|++
expr_stmt|;
comment|/* count ring inits */
name|addr
operator|->
name|vvocsr
operator|=
name|VV_IEN
operator||
name|VV_CPB
operator||
name|VV_DEN
operator||
name|VV_INR
operator||
name|VV_ENB
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * proNET transmit interrupt  * Start another output if more data to send.  */
end_comment

begin_macro
name|vvxint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|oc
decl_stmt|;
name|ui
operator|=
name|vvinfo
index|[
name|unit
index|]
expr_stmt|;
name|vs
operator|=
operator|&
name|vv_softc
index|[
name|unit
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|QBA
name|splx
argument_list|(
name|vs
operator|->
name|vs_ipl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vs
operator|->
name|vs_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|oc
operator|=
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|vvocsr
operator|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_oactive
operator|==
literal|0
condition|)
block|{
name|vvlog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vv%d: stray interrupt vvocsr = %b\n"
argument_list|,
name|unit
argument_list|,
name|oc
argument_list|,
name|VV_OBITS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * we retransmit on soft error 	 * TODO: sort retransmits to end of queue if possible! 	 */
if|if
condition|(
name|oc
operator|&
operator|(
name|VV_OPT
operator||
name|VV_RFS
operator|)
condition|)
block|{
if|if
condition|(
name|vs
operator|->
name|vs_tries
operator|++
operator|<
name|VVRETRY
condition|)
block|{
if|if
condition|(
name|oc
operator|&
name|VV_OPT
condition|)
name|vs
operator|->
name|vs_otimeout
operator|++
expr_stmt|;
if|if
condition|(
name|oc
operator|&
name|VV_RFS
condition|)
block|{
name|vs
operator|->
name|vs_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
name|vs
operator|->
name|vs_refused
operator|++
expr_stmt|;
block|}
name|vvstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* restart this message */
return|return;
block|}
block|}
name|vs
operator|->
name|vs_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|vs
operator|->
name|vs_oactive
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_tries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oc
operator|&
name|VVXERR
condition|)
block|{
name|vs
operator|->
name|vs_if
operator|.
name|if_obytes
operator|-=
name|vs
operator|->
name|vs_olen
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|vvlog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vv%d: error vvocsr = %b\n"
argument_list|,
name|unit
argument_list|,
literal|0xffff
operator|&
name|oc
argument_list|,
name|VV_OBITS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_xtofree
condition|)
block|{
name|m_freem
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_xtofree
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_xtofree
operator|=
literal|0
expr_stmt|;
block|}
name|vvstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Transmit watchdog timer routine.  * This routine gets called when we lose a transmit interrupt.  * The best we can do is try to restart output.  */
end_comment

begin_macro
name|vvwatchdog
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
decl_stmt|;
name|vs
operator|=
operator|&
name|vv_softc
index|[
name|unit
index|]
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vv%d: lost transmit interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_timeouts
operator|++
expr_stmt|;
name|vvstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * proNET interface receiver interrupt.  * If input error just drop packet.  * Otherwise purge input buffered data path and examine  * packet to determine type.  If can't determine length  * from type, then have to drop packet.  Otherwise decapsulate  * packet based on type and pass to type specific higher-level  * input routine.  */
end_comment

begin_macro
name|vvrint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|vv_header
modifier|*
name|vv
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ubaaddr
decl_stmt|,
name|len
decl_stmt|,
name|off
decl_stmt|,
name|s
decl_stmt|;
name|short
name|resid
decl_stmt|;
name|vs
operator|=
operator|&
name|vv_softc
index|[
name|unit
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|QBA
name|splx
argument_list|(
name|vs
operator|->
name|vs_ipl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vs
operator|->
name|vs_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_lastchange
operator|=
name|time
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|vvinfo
index|[
name|unit
index|]
operator|->
name|ui_addr
expr_stmt|;
comment|/* 	 * Purge BDP 	 */
if|if
condition|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_uba
argument_list|,
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
comment|/* 	 * receive errors? 	 */
if|if
condition|(
name|addr
operator|->
name|vvicsr
operator|&
name|VVRERR
condition|)
block|{
name|vvlog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vv%d: receive error, vvicsr = %b\n"
argument_list|,
name|unit
argument_list|,
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|vvicsr
operator|)
argument_list|,
name|VV_IBITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|vvicsr
operator|&
name|VV_BDF
condition|)
name|vs
operator|->
name|vs_ibadf
operator|++
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
comment|/* 	 * parity errors? 	 */
if|if
condition|(
name|addr
operator|->
name|vvicsr
operator|&
name|VV_LDE
condition|)
block|{
comment|/* we don't have to clear it because the receive command */
comment|/* writes 0 to parity bit */
name|vs
operator|->
name|vs_parity
operator|++
expr_stmt|;
comment|/* 		 * only on 10 megabit proNET is VV_LDE an end-to-end parity 		 * bit. On 80 megabit, it returns to the intended use of 		 * node-to-node parity. End-to-end parity errors on 80 megabit 		 * give VV_BDF. 		 */
if|if
condition|(
name|vs
operator|->
name|vs_is80
operator|==
literal|0
condition|)
goto|goto
name|dropit
goto|;
block|}
comment|/* 	 * Get packet length from residual word count 	 * 	 * Compute header offset if trailer protocol 	 * 	 * Pull packet off interface.  Off is nonzero if packet 	 * has trailing header; if_rubaget will then force this header 	 * information to be at the front.  The vh_info field 	 * carries the offset to the trailer data in trailer 	 * format packets. 	 */
name|vv
operator|=
operator|(
expr|struct
name|vv_header
operator|*
operator|)
operator|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
operator|)
expr_stmt|;
name|vvtracehdr
argument_list|(
literal|"vi"
argument_list|,
name|vv
argument_list|)
expr_stmt|;
name|resid
operator|=
name|addr
operator|->
name|vviwc
operator|&
literal|01777
expr_stmt|;
comment|/* only low 10 bits valid */
if|if
condition|(
name|resid
condition|)
name|resid
operator||=
literal|0176000
expr_stmt|;
comment|/* high 6 bits are undefined */
name|len
operator|=
operator|(
operator|(
name|VVBUFSIZE
operator|>>
literal|1
operator|)
operator|+
name|resid
operator|)
operator|<<
literal|1
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|->
name|vvicsr
operator|&
name|VV_DPR
operator|)
operator|||
name|len
operator|>
name|VVMRU
operator|||
name|len
operator|<=
literal|0
condition|)
block|{
name|vvlog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vv%d: len too long or short, \ len = %d, vvicsr = %b\n"
argument_list|,
name|unit
argument_list|,
name|len
argument_list|,
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|vvicsr
operator|)
argument_list|,
name|VV_IBITS
argument_list|)
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
comment|/* check the protocol header version */
if|if
condition|(
name|vv
operator|->
name|vh_version
operator|!=
name|RING_VERSION
condition|)
block|{
name|vvlog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vv%d: bad protocol header version %d\n"
argument_list|,
name|unit
argument_list|,
name|vv
operator|->
name|vh_version
operator|&
literal|0xff
argument_list|)
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
define|#
directive|define
name|vvdataaddr
parameter_list|(
name|vv
parameter_list|,
name|off
parameter_list|,
name|type
parameter_list|)
value|((type)(((caddr_t)((vv)+1)+(off))))
if|if
condition|(
name|vv
operator|->
name|vh_type
operator|==
name|RING_TRAILER
condition|)
block|{
name|off
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|vv
operator|->
name|vh_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>
name|VVMTU
condition|)
block|{
name|vvlog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vv%d: off> VVMTU, off = %d, vvicsr = %b\n"
argument_list|,
name|unit
argument_list|,
name|off
argument_list|,
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|vvicsr
operator|)
argument_list|,
name|VV_IBITS
argument_list|)
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
name|vv
operator|->
name|vh_type
operator|=
name|ntohs
argument_list|(
operator|*
name|vvdataaddr
argument_list|(
name|vv
argument_list|,
name|off
argument_list|,
name|u_short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ntohs
argument_list|(
operator|*
operator|(
name|vvdataaddr
argument_list|(
name|vv
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|u_short
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|resid
operator|>
name|len
condition|)
block|{
name|vvlog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vv%d: trailer packet too short\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|vvlog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vv%d: off = %d, resid = %d, vvicsr = %b\n"
argument_list|,
name|unit
argument_list|,
name|off
argument_list|,
name|resid
argument_list|,
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|vvicsr
operator|)
argument_list|,
name|VV_IBITS
argument_list|)
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
name|len
operator|=
name|off
operator|+
name|resid
expr_stmt|;
block|}
else|else
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|vvlog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vv%d: len is zero, vvicsr = %b\n"
argument_list|,
name|unit
argument_list|,
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|vvicsr
operator|)
argument_list|,
name|VV_IBITS
argument_list|)
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
name|m
operator|=
name|if_rubaget
argument_list|(
operator|&
name|vs
operator|->
name|vs_ifuba
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
operator|&
name|vs
operator|->
name|vs_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|vvlog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vv%d: if_rubaget() failed, vvicsr = %b\n"
argument_list|,
name|unit
argument_list|,
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|vvicsr
operator|)
argument_list|,
name|VV_IBITS
argument_list|)
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
name|vs
operator|->
name|vs_if
operator|.
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|vv
operator|->
name|vh_dhost
operator|==
name|VV_BROADCAST
condition|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_BCAST
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_imcasts
operator|++
expr_stmt|;
block|}
comment|/* Keep track of source address of this packet */
name|vs
operator|->
name|vs_lastr
operator|=
name|vv
operator|->
name|vh_shost
expr_stmt|;
comment|/* 	 * Demultiplex on packet type 	 */
switch|switch
condition|(
name|vv
operator|->
name|vh_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|RING_IP
case|:
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|vvlog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vv%d: unknown pkt type 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|vv
operator|->
name|vh_type
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_noproto
operator|++
expr_stmt|;
goto|goto
name|setup
goto|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_if
operator|.
name|if_iqdrops
operator|++
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Reset for the next packet. 	 */
name|setup
label|:
name|ubaaddr
operator|=
name|UBAI_ADDR
argument_list|(
name|vs
operator|->
name|vs_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vviba
operator|=
operator|(
name|u_short
operator|)
name|ubaaddr
expr_stmt|;
name|addr
operator|->
name|vviea
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ubaaddr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|->
name|vviwc
operator|=
operator|-
operator|(
name|VVBUFSIZE
operator|)
operator|>>
literal|1
expr_stmt|;
name|addr
operator|->
name|vvicsr
operator|=
name|VV_HEN
operator||
name|VV_IEN
operator||
name|VV_DEN
operator||
name|VV_ENB
expr_stmt|;
return|return;
comment|/* 	 * Drop packet on floor -- count them!! 	 */
name|dropit
label|:
name|vs
operator|->
name|vs_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|setup
goto|;
block|}
end_block

begin_comment
comment|/*  * proNET output routine.  * Encapsulate a packet of type family for the local net.  * Use trailer local net encapsulation if enough data in first  * packet leaves a multiple of 512 bytes of data in remainder.  */
end_comment

begin_macro
name|vvoutput
argument_list|(
argument|ifp
argument_list|,
argument|m0
argument_list|,
argument|dst
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|vv_header
modifier|*
name|vv
decl_stmt|;
specifier|register
name|int
name|off
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|vvreg
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|type
decl_stmt|,
name|dest
decl_stmt|,
name|error
decl_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
name|unit
operator|=
name|ifp
operator|->
name|if_unit
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
name|addr
operator|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
name|vvinfo
index|[
name|unit
index|]
operator|->
name|ui_addr
expr_stmt|;
name|vs
operator|=
operator|&
name|vv_softc
index|[
name|unit
index|]
expr_stmt|;
comment|/* 	 * Check to see if the input side has wedged due the UBA 	 * vectoring through 0. 	 * 	 * We are lower than device ipl when we enter this routine, 	 * so if the interface is ready with an input packet then 	 * an input interrupt must have slipped through the cracks. 	 * 	 * Avoid the race with an input interrupt by watching to see 	 * if any packets come in. 	 */
name|s
operator|=
name|vs
operator|->
name|vs_if
operator|.
name|if_ipackets
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|vvicsr
operator|&
name|VV_RDY
operator|&&
name|s
operator|==
name|vs
operator|->
name|vs_if
operator|.
name|if_ipackets
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vv%d: lost a receive interrupt, icsr = %b\n"
argument_list|,
name|unit
argument_list|,
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|vvicsr
operator|)
argument_list|,
name|VV_IBITS
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|vvrint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|in_broadcast
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_addr
argument_list|)
condition|)
name|dest
operator|=
name|VV_BROADCAST
expr_stmt|;
else|else
name|dest
operator|=
name|in_lnaof
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOOPBACK
if|if
condition|(
name|dest
operator|==
name|vs
operator|->
name|vs_host
operator|&&
operator|(
name|loif
operator|.
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
return|return
operator|(
name|looutput
argument_list|(
operator|&
name|loif
argument_list|,
name|m0
argument_list|,
name|dst
argument_list|)
operator|)
return|;
endif|#
directive|endif
endif|LOOPBACK
if|if
condition|(
name|dest
operator|>=
literal|0x100
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|off
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|->
name|ip_len
argument_list|)
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
comment|/* 		 * Trailerize, if the configuration allows it. 		 * TODO: Need per host negotiation. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOTRAILERS
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|off
operator|>
literal|0
operator|&&
operator|(
name|off
operator|&
literal|0x1ff
operator|)
operator|==
literal|0
operator|&&
name|m
operator|->
name|m_data
operator|>=
name|m
operator|->
name|m_pktdat
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
block|{
name|type
operator|=
name|RING_TRAILER
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_short
operator|*
argument_list|)
operator|=
name|htons
argument_list|(
operator|(
name|short
operator|)
name|RING_IP
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_short
operator|*
argument_list|)
operator|+
literal|1
operator|)
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
goto|goto
name|gottrailertype
goto|;
block|}
name|type
operator|=
name|RING_IP
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
goto|goto
name|gottype
goto|;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"vv%d: can't handle af%d\n"
argument_list|,
name|unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|gottrailertype
label|:
comment|/* 	 * Packet to be sent as trailer: move first packet 	 * (control information) to end of chain. 	 */
while|while
condition|(
name|m
operator|->
name|m_next
condition|)
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|m
operator|=
name|m0
operator|->
name|m_next
expr_stmt|;
name|m0
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
name|gottype
label|:
comment|/* 	 * Add local net header.  If no space in first mbuf, 	 * allocate another. 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vv_header
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|vv
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|vv_header
operator|*
argument_list|)
expr_stmt|;
name|vv
operator|->
name|vh_shost
operator|=
name|vs
operator|->
name|vs_host
expr_stmt|;
name|vv
operator|->
name|vh_dhost
operator|=
name|dest
expr_stmt|;
name|vv
operator|->
name|vh_version
operator|=
name|RING_VERSION
expr_stmt|;
name|vv
operator|->
name|vh_type
operator|=
name|type
expr_stmt|;
name|vv
operator|->
name|vh_info
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|off
argument_list|)
expr_stmt|;
name|vvtracehdr
argument_list|(
literal|"vo"
argument_list|,
name|vv
argument_list|)
expr_stmt|;
comment|/* 	 * Queue message on interface, and start output if interface 	 * not yet active. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|qfull
goto|;
block|}
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_oactive
operator|==
literal|0
condition|)
name|vvstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|qfull
label|:
name|m0
operator|=
name|m
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bad
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|vvioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vv_softc
modifier|*
name|vs
init|=
operator|&
name|vv_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|vvreg
modifier|*
name|addr
init|=
operator|(
expr|struct
name|vvreg
operator|*
operator|)
operator|(
name|vvinfo
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|)
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
operator|(
name|vs
operator|->
name|vs_flags
operator|&
name|VS_RUNNING
operator|)
operator|==
literal|0
condition|)
name|vvinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Did self-test succeed? 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|ENETDOWN
expr_stmt|;
else|else
block|{
comment|/* 			 * Attempt to check agreement of protocol address 			 * and board address. 			 */
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
operator|(
name|in_lnaof
argument_list|(
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
operator|&
literal|0xff
operator|)
operator|!=
name|vs
operator|->
name|vs_host
condition|)
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|vs
operator|->
name|vs_flags
operator|&
name|VS_RUNNING
condition|)
block|{
name|addr
operator|->
name|vvicsr
operator|=
name|VV_RST
expr_stmt|;
name|addr
operator|->
name|vvocsr
operator|=
name|VV_RST
expr_stmt|;
name|vs
operator|->
name|vs_flags
operator|&=
operator|~
name|VS_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|vs
operator|->
name|vs_flags
operator|&
name|VS_RUNNING
operator|)
operator|==
literal|0
condition|)
name|vvinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * vvprt_hdr(s, v) print the local net header in "v"  *	with title is "s"  */
end_comment

begin_macro
name|vvprt_hdr
argument_list|(
argument|s
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|vv_header
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%s: dsvti: 0x%x 0x%x 0x%x 0x%x 0x%x\n"
argument_list|,
name|s
argument_list|,
literal|0xff
operator|&
call|(
name|int
call|)
argument_list|(
name|v
operator|->
name|vh_dhost
argument_list|)
argument_list|,
literal|0xff
operator|&
call|(
name|int
call|)
argument_list|(
name|v
operator|->
name|vh_shost
argument_list|)
argument_list|,
literal|0xff
operator|&
call|(
name|int
call|)
argument_list|(
name|v
operator|->
name|vh_version
argument_list|)
argument_list|,
literal|0xff
operator|&
call|(
name|int
call|)
argument_list|(
name|v
operator|->
name|vh_type
argument_list|)
argument_list|,
literal|0xffff
operator|&
call|(
name|int
call|)
argument_list|(
name|v
operator|->
name|vh_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|NVV
end_endif

end_unit

