begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   *     X.29 option for dda driver for UNIX and Ultrix  *      ________________________________________________________  *     /                                                        \  *    |          AAA          CCCCCCCCCCCCCC    CCCCCCCCCCCCCC   |  *    |         AAAAA        CCCCCCCCCCCCCCCC  CCCCCCCCCCCCCCCC  |  *    |        AAAAAAA       CCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCC |  *    |       AAAA AAAA      CCCC              CCCC              |  *    |      AAAA   AAAA     CCCC              CCCC              |  *    |     AAAA     AAAA    CCCC              CCCC              |  *    |    AAAA       AAAA   CCCC              CCCC              |  *    |   AAAA  AAAAAAAAAAA  CCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCC |  *    |  AAAA    AAAAAAAAAAA CCCCCCCCCCCCCCCC  CCCCCCCCCCCCCCCC  |  *    | AAAA      AAAAAAAAA   CCCCCCCCCCCCCC    CCCCCCCCCCCCCC   |  *     \________________________________________________________/  *   *      Copyright (c) 1987 by Advanced Computer Communications  *      720 Santa Barbara Street, Santa Barbara, California  93101  *      (805) 963-9431  *   * File:  *      if_x29.c  *   * Author:  *   * Project:  *      Development of PAD on 6250 software.  *   * Function:  *      To enable network connections on ACP_XX to communicate with UNIX.  *   * Components:  *      - files if_x29.c  *   * Configuration Entry:  *  *      device dda0 at uba? csr 0166740 vector ddainta ddaintb  *  * Usage Notes:  *  *      - make devices in /dev and edit /etc/ttys for those x29  *        devices which you want in your configuration  *   * System Notes:  *   *       Refer to the installation instructions, readme.txt, which  *       are included on the driver distribution medium.  *  * Revision History at end of file  */
end_comment

begin_comment
comment|/*  *	For efficiency, it is a good idea to modify XXBOARDS when using  *	less than 4 boards with the X29 option.  If using more than 32  *	lines per board, you should modify XXBOARDS, XXLPERBRD, LOG2_XXBOARDS  *	and LOG2_XXLPERBRD.  *  *	Minor numbers are laid out as follows (by default):  *		(MSB) PBBLLLLL (LSB)  *	Where P is a flag to determine if the line is outbound (pad) or  *	inbound (tty).  BB is the board number (0-3), and LLLLL is the  *	X29 line on a board (0-31).  Some customers may need more than  *	32 lines/board.  If there are less than 2 boards,  one may shift  *	the break-point between lines and boards:  *  *	up to 4 boards, 32 lines/board	(default)  *		(MSB) PBBLLLLL (LSB)  *			XXBOARDS  = 4,   LOG2_XXBOARDS  = 2  *			XXLPERBRD = 32,	 LOG2_XXLPERBRD = 5  *	up to 2 boards, 64 lines/board:  *		(MSB) PBLLLLLL (LSB)  *			XXBOARDS  = 2,   LOG2_XXBOARDS  = 1  *			XXLPERBRD = 64,  LOG2_XXLPERBRD = 6  *	only 1 board, 128 (actually, 126, as 126 = max svc):  *		(MSB) PLLLLLLL (LSB)  *			XXBOARDS  = 1,   LOG2_XXBOARDS  = 0  *			XXLPERBRD = 128, LOG2_XXLPERBRD = 7  *  *	(obviously, these are all powers of two)  */
end_comment

begin_define
define|#
directive|define
name|XXBOARDS
value|4
end_define

begin_comment
comment|/* # boards running x29 */
end_comment

begin_define
define|#
directive|define
name|LOG2_XXBOARDS
value|2
end_define

begin_comment
comment|/* # bits of board info */
end_comment

begin_define
define|#
directive|define
name|XXLPERBRD
value|32
end_define

begin_comment
comment|/* # lines per board */
end_comment

begin_define
define|#
directive|define
name|LOG2_XXLPERBRD
value|5
end_define

begin_comment
comment|/* # bits of line info */
end_comment

begin_comment
comment|/*  * If you require an 8-bit data path and have no parity misconfigurations,  * you may change PARITY_MASKs to 0377.  This will leave parity stripping  * to the ttdriver.  However,  the ttdriver won't strip parity when in  * raw mode (e.g. at the Password: prompt),  so one symptom of a parity  * misconfiguration is that users can't login (CR gets received as 0x8D).  */
end_comment

begin_define
define|#
directive|define
name|INPUT_PARITY_MASK
value|0177
end_define

begin_comment
comment|/* strip off the 8th bit */
end_comment

begin_define
define|#
directive|define
name|OUTPUT_PARITY_MASK
value|0377
end_define

begin_comment
comment|/* don't strip off the 8th bit */
end_comment

begin_comment
comment|/*  * macro to translate a device number to the unit (i.e. ACP_n250)  * with which it is associated and the port on said unit  */
end_comment

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|((minor(x)>> LOG2_XXLPERBRD)& LOG2_XXBOARDS)
end_define

begin_define
define|#
directive|define
name|LINE
parameter_list|(
name|x
parameter_list|)
value|(minor(x)& 0177)
end_define

begin_comment
comment|/* index into line table */
end_comment

begin_define
define|#
directive|define
name|XXSHOW
parameter_list|(
name|x
parameter_list|)
value|(minor(x) == 255)
end_define

begin_comment
comment|/* special "show" device */
end_comment

begin_define
define|#
directive|define
name|IS_PAD
parameter_list|(
name|x
parameter_list|)
value|(minor(x)& 0200)
end_define

begin_comment
comment|/* msb is the pad/tty selector */
end_comment

begin_define
define|#
directive|define
name|MAJLINE
parameter_list|(
name|x
parameter_list|)
value|((x)& ~0x80)
end_define

begin_comment
comment|/* major plus corrected minor # */
end_comment

begin_define
define|#
directive|define
name|NXXLINES
value|(XXBOARDS * XXLPERBRD)
end_define

begin_comment
comment|/* number of total x29 lines */
end_comment

begin_comment
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
end_comment

begin_comment
comment|/*%%                                                             %%*/
end_comment

begin_comment
comment|/*%%                   LOCAL  FUNCTIONS                          %%*/
end_comment

begin_comment
comment|/*%%                                                             %%*/
end_comment

begin_comment
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
end_comment

begin_function_decl
name|PRIVATE
name|void
name|xxcntl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|xxclear
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|xxshow
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|xxpadhandle
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|int
name|xxpadparse
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|int
name|xxpadcall
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|xxpadmsg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|xx_qbit_msg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|xx_tp_hangup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|x29_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|x29_dhandle
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|int
name|x29_break_reply_is_required
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|ACC_ULTRIX
operator|>=
literal|30
end_if

begin_function_decl
specifier|static
name|int
name|ttbreakc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* always keep this private */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
end_comment

begin_comment
comment|/*%%                                                             %%*/
end_comment

begin_comment
comment|/*%%                   LOCAL  VARIABLES                          %%*/
end_comment

begin_comment
comment|/*%%                                                             %%*/
end_comment

begin_comment
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
end_comment

begin_define
define|#
directive|define
name|SET_PAD
value|2
end_define

begin_define
define|#
directive|define
name|READ_PAD
value|4
end_define

begin_define
define|#
directive|define
name|SET_READ_PAD
value|6
end_define

begin_define
define|#
directive|define
name|PAR_INDICATION
value|0
end_define

begin_define
define|#
directive|define
name|INVITE_CLEAR
value|1
end_define

begin_define
define|#
directive|define
name|BREAK_INDIC
value|3
end_define

begin_define
define|#
directive|define
name|PAD_ERROR
value|5
end_define

begin_comment
comment|/* command codes */
end_comment

begin_define
define|#
directive|define
name|XX_C_BREAK
value|001
end_define

begin_define
define|#
directive|define
name|XX_C_PAD
value|002
end_define

begin_define
define|#
directive|define
name|XX_C_CLOSE
value|003
end_define

begin_define
define|#
directive|define
name|XX_C_HOST
value|004
end_define

begin_decl_stmt
name|struct
name|tty
name|xx_tty
index|[
name|NXXLINES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tty structures */
end_comment

begin_define
define|#
directive|define
name|MODE_UNUSED
value|0
end_define

begin_comment
comment|/* !just for sanity checks only! */
end_comment

begin_define
define|#
directive|define
name|MODE_HOST
value|1
end_define

begin_comment
comment|/* port in host mode (incoming) */
end_comment

begin_define
define|#
directive|define
name|MODE_PAD
value|2
end_define

begin_comment
comment|/* port in pad mode (outgoing) */
end_comment

begin_decl_stmt
name|char
name|xxmode
index|[
name|NXXLINES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mode of port */
end_comment

begin_function_decl
name|int
name|xxstart
parameter_list|()
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
name|ref
decl_stmt|;
name|char
name|val
decl_stmt|;
block|}
name|x29_pad_pair
typedef|;
end_typedef

begin_decl_stmt
name|PRIVATE
name|x29_pad_pair
name|x29_break_ack_params
index|[]
init|=
block|{
literal|8
block|,
literal|0
comment|/* ref 8 -- normal output to terminal */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|x29_pad_pair
name|x29_callout_params
index|[]
init|=
block|{
literal|1
block|,
literal|0
comment|/* ref 1 -- no recall char */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|x29_pad_pair
name|x29_callin_setparams
index|[]
init|=
block|{
comment|/* these are the preferred paramters when calling in to Unix */
literal|2
block|,
literal|0
block|,
comment|/* ref 2 -- no echo */
literal|3
block|,
literal|127
block|,
comment|/* ref 3 -- forward data on any char */
literal|8
block|,
literal|0
block|,
comment|/* ref 8 -- normal data delivery to terminal */
literal|9
block|,
literal|0
block|,
comment|/* ref 9 -- no padding after carriage return */
literal|10
block|,
literal|0
block|,
comment|/* ref 10 -- no line folding */
literal|13
block|,
literal|0
block|,
comment|/* ref 13 -- no line feed after CR */
literal|15
block|,
literal|0
comment|/* ref 15 -- no local edit */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************  *  PAD CONTROL INFORMATION AND DEFINITIONS  ******************************************************************************/
end_comment

begin_comment
comment|/* definitions for the pad state field p_state */
end_comment

begin_define
define|#
directive|define
name|PS_IDLE
value|0
end_define

begin_comment
comment|/* not opened state */
end_comment

begin_define
define|#
directive|define
name|PS_COM
value|1
end_define

begin_comment
comment|/* the pad for this line is in command state */
end_comment

begin_define
define|#
directive|define
name|PS_PAD
value|2
end_define

begin_comment
comment|/* this line has data passing though the pad */
end_comment

begin_define
define|#
directive|define
name|PS_WAIT
value|3
end_define

begin_comment
comment|/* waiting state */
end_comment

begin_define
define|#
directive|define
name|PS_XFR
value|4
end_define

begin_comment
comment|/* data transfer state */
end_comment

begin_define
define|#
directive|define
name|P_LINELEN
value|20
end_define

begin_define
define|#
directive|define
name|P_NOBLOCK
value|0
end_define

begin_typedef
typedef|typedef
struct|struct
name|padinfo
block|{
name|short
name|p_state
decl_stmt|;
comment|/* pad state */
name|char
name|p_line
index|[
name|P_LINELEN
index|]
decl_stmt|;
comment|/* built up line */
name|char
name|p_idx
decl_stmt|;
comment|/* index into p_line */
name|int
name|p_flow
decl_stmt|;
comment|/* index into mbuf when flow off, 				   P_NOBLOCK if not flowed off */
name|struct
name|mbuf
modifier|*
name|p_msav
decl_stmt|;
comment|/* place to hang mbuf when flow controlled */
name|struct
name|mbuf
modifier|*
name|p_mchsav
decl_stmt|;
comment|/* place to save mbuf chain '' '' '' */
block|}
name|padinfo
typedef|;
end_typedef

begin_decl_stmt
name|padinfo
name|xx_padinfo
index|[
name|NXXLINES
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
end_comment

begin_comment
comment|/*%%                                                             %%*/
end_comment

begin_comment
comment|/*%%                   GLOBAL ROUTINES                           %%*/
end_comment

begin_comment
comment|/*%%                                                             %%*/
end_comment

begin_comment
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
end_comment

begin_comment
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
end_comment

begin_comment
comment|/*%%                       XXOPEN()                              %%*/
end_comment

begin_comment
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
end_comment

begin_comment
comment|/*                                                                 */
end_comment

begin_comment
comment|/*  Purpose:                                                       */
end_comment

begin_comment
comment|/*                                                                 */
end_comment

begin_comment
comment|/*  Open a line.                                                   */
end_comment

begin_comment
comment|/*                                                                 */
end_comment

begin_comment
comment|/*  Call:           xxopen(dev, flag)                              */
end_comment

begin_comment
comment|/*  Argument:       dev:   device                                  */
end_comment

begin_comment
comment|/*                  flag:  indicates type of open, "nonblocking"   */
end_comment

begin_comment
comment|/*                         "or block if in use"                    */
end_comment

begin_comment
comment|/*  Returns:        0 for success, else nonzero error code         */
end_comment

begin_comment
comment|/*  Called by:      kernel software software,  this routine is in  */
end_comment

begin_comment
comment|/*                  the cdevsw table                               */
end_comment

begin_comment
comment|/*                                                                 */
end_comment

begin_comment
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|xxopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|d
expr_stmt|;
specifier|register
name|s
expr_stmt|;
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
if|#
directive|if
name|ACC_ULTRIX
operator|>
literal|00
name|int
name|inuse
decl_stmt|;
comment|/* store inuse bit while sleeping */
endif|#
directive|endif
name|unit
operator|=
name|UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|LINE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|XXSHOW
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* minor device 255 */
name|xxshow
argument_list|()
expr_stmt|;
return|return
operator|(
name|EPIPE
operator|)
return|;
block|}
comment|/* PST NOTE TO SELF: change the test as follows:      *	make this d>= NXXLINES, then check to see if unit is present,      *  Keep that sleep() in the thingy below, so we don't get bouncing      *  gettys eating up cpu time.      */
if|if
condition|(
operator|(
name|d
operator|>=
name|NXXLINES
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* wait for interface to come up */
while|while
condition|(
name|dda_softc
index|[
name|unit
index|]
operator|.
name|dda_state
operator|!=
name|S_LINK_UP
condition|)
name|sleep
argument_list|(
operator|&
name|dda_softc
index|[
name|unit
index|]
operator|.
name|dda_state
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|d
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|)
operator|&&
name|u
operator|.
name|u_uid
operator|!=
literal|0
condition|)
return|return
name|EBUSY
return|;
comment|/* make sure the port isn't already open in a conflicting manner */
comment|/* i.e. can't open /dev/padJ0 and /dev/ttyJ0 at the same time */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_WOPEN
operator||
name|TS_ISOPEN
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|IS_PAD
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|xxmode
index|[
name|d
index|]
operator|==
name|MODE_HOST
operator|)
operator|)
operator|||
operator|(
operator|(
operator|!
name|IS_PAD
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|(
name|xxmode
index|[
name|d
index|]
operator|==
name|MODE_PAD
operator|)
operator|)
condition|)
return|return
name|EBUSY
return|;
block|}
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|96
argument_list|,
name|unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) open line %d flag %o in %s mode\n"
operator|,
name|unit
operator|,
name|d
operator|,
name|flag
operator|,
operator|(
name|IS_PAD
argument_list|(
name|dev
argument_list|)
condition|?
literal|"pad"
else|:
literal|"host"
operator|)
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
name|tp
operator|->
name|t_oproc
operator|=
name|xxstart
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
comment|/* if first open initialize state */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|#
directive|if
name|ACC_ULTRIX
operator|>=
literal|30
comment|/* posix compliant tty driver */
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|CBAUD
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_iflag
operator|=
name|IGNPAR
operator||
name|ICRNL
operator||
name|IXON
operator||
name|IXANY
operator||
name|IXOFF
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|OPOST
operator||
name|ONLCR
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|B9600
operator||
name|CS8
operator||
name|CREAD
operator||
name|HUPCL
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|ISIG
operator||
name|ICANON
operator||
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
operator||
name|ECHONL
expr_stmt|;
name|tp
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* v7 tty driver */
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_ispeed
operator|=
name|B9600
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|B9600
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|=
name|CRMOD
operator||
name|ANYP
expr_stmt|;
block|}
endif|#
directive|endif
name|xxparam
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_PAD
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
name|xxmode
index|[
name|d
index|]
operator|=
name|MODE_PAD
expr_stmt|;
name|xxcntl
argument_list|(
name|tp
argument_list|,
name|XX_C_PAD
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
block|{
name|xxmode
index|[
name|d
index|]
operator|=
name|MODE_HOST
expr_stmt|;
name|xxcntl
argument_list|(
name|tp
argument_list|,
name|XX_C_HOST
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|ECHO
expr_stmt|;
if|#
directive|if
name|ACC_ULTRIX
operator|<
literal|31
comment|/* on everything other than Ultrix 3.1 */
comment|/* on close tell ACP_XX to drop line */
name|tp
operator|->
name|t_state
operator||=
name|TS_HUPCLS
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* if xxcntl did not get called (state had carrier off) or xxcntl's      * search for a free lcn failed, then t_addr will be 0, so punt */
if|if
condition|(
name|tp
operator|->
name|t_addr
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_pgrp
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
literal|0
expr_stmt|;
name|xxmode
index|[
name|d
index|]
operator|=
name|MODE_UNUSED
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|xx_padinfo
index|[
name|d
index|]
operator|.
name|p_flow
operator|=
name|P_NOBLOCK
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|#
directive|if
name|ACC_ULTRIX
operator|>
literal|00
if|if
condition|(
name|flag
operator|&
name|O_NDELAY
condition|)
block|{
if|if
condition|(
operator|!
name|IS_PAD
argument_list|(
name|dev
argument_list|)
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_ONDELAY
expr_stmt|;
block|}
else|else
endif|#
directive|endif
while|while
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
if|#
directive|if
name|ACC_ULTRIX
operator|>
literal|00
name|inuse
operator|=
name|tp
operator|->
name|t_state
operator|&
name|TS_INUSE
expr_stmt|;
endif|#
directive|endif
name|sleep
argument_list|(
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
comment|/* wakeup came from xxclear */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_WOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPIPE
operator|)
return|;
block|}
if|#
directive|if
name|ACC_ULTRIX
operator|>
literal|00
comment|/* if port became "inuse" while we slept, return */
if|if
condition|(
operator|(
name|flag
operator|&
name|O_BLKINUSE
operator|)
operator|&&
operator|(
operator|!
name|inuse
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_INUSE
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_pgrp
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_pgrp
operator|=
name|u
operator|.
name|u_procp
operator|->
name|p_pid
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
end_comment

begin_comment
comment|/*%%                       XXCLOSE()                             %%*/
end_comment

begin_comment
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
end_comment

begin_comment
comment|/*                                                                 */
end_comment

begin_comment
comment|/*  Purpose:                                                       */
end_comment

begin_comment
comment|/*                                                                 */
end_comment

begin_comment
comment|/*  Close a line.                                                  */
end_comment

begin_comment
comment|/*                                                                 */
end_comment

begin_comment
comment|/*  Call:           xxclose(dev, flag)                             */
end_comment

begin_comment
comment|/*  Argument:       dev:   device                                  */
end_comment

begin_comment
comment|/*                  flag:  unused                                  */
end_comment

begin_comment
comment|/*  Returns:        nothing                                        */
end_comment

begin_comment
comment|/*  Called by:      kernel software,  this routine is in the	   */
end_comment

begin_comment
comment|/*		    cdevsw table                                   */
end_comment

begin_comment
comment|/*                                                                 */
end_comment

begin_comment
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|xxclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|d
expr_stmt|;
name|d
operator|=
name|LINE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|d
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|97
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) closing line %d\n"
operator|,
name|UNIT
argument_list|(
name|dev
argument_list|)
operator|,
name|d
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
comment|/* PST NOTE TO SELF: 	 *	Add the 629 driver code for timing out the close below, 	 *	because the line could be flowed off and it would hang 	 * 	forever */
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
if|#
directive|if
name|ACC_ULTRIX
operator|>=
literal|31
if|if
condition|(
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|)
operator|||
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_HUPCLS
operator|)
operator|||
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|97
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) close: tp->t_state = %x\n"
operator|,
name|UNIT
argument_list|(
name|dev
argument_list|)
operator|,
name|tp
operator|->
name|t_state
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
condition|)
name|xxcntl
argument_list|(
name|tp
argument_list|,
name|XX_C_CLOSE
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CARR_ON
expr_stmt|;
name|xxmode
index|[
name|d
index|]
operator|=
name|MODE_UNUSED
expr_stmt|;
block|}
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                       XXREAD()                              %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*  Read from a line.                                              */
comment|/*                                                                 */
comment|/*  Call:           xxread(dev, uio)                               */
comment|/*  Argument:       dev:   device                                  */
comment|/*                  uio:   pointer to uio structure                */
comment|/*  Returns:        0 for success, else nonzero error code         */
comment|/*  Called by:      kernel software,  this routine is in	   */
comment|/*                  the cdevsw table                               */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
name|xxread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|dda_softc
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|dda_state
operator|!=
name|S_LINK_UP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|l
operator|=
name|LINE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|l
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
expr_stmt|;
if|if
condition|(
name|xx_padinfo
index|[
name|l
index|]
operator|.
name|p_flow
operator|!=
name|P_NOBLOCK
condition|)
block|{
comment|/* currently blocked? */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|CBREAK
operator|)
condition|)
block|{
comment|/* using raw q? */
if|if
condition|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|<
name|TTYHOG
operator|/
literal|8
condition|)
block|{
comment|/* if rawq is low, then 						 * it's time to unblock */
name|x29_dhandle
argument_list|(
operator|&
name|dda_softc
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
argument_list|,
operator|(
expr|struct
name|dda_cb
operator|*
operator|)
operator|(
name|tp
operator|->
name|t_addr
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* else cooked mode, different test */
comment|/* canonical q empty? then it's time to unblock */
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_canq
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
name|x29_dhandle
argument_list|(
operator|&
name|dda_softc
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
argument_list|,
operator|(
expr|struct
name|dda_cb
operator|*
operator|)
operator|(
name|tp
operator|->
name|t_addr
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                       XXWRITE()                             %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*  Write on a line.                                               */
comment|/*                                                                 */
comment|/*  Call:           xxwrite(dev, uio)                              */
comment|/*  Argument:       dev:   device                                  */
comment|/*                  uio:   pointer to uio structure                */
comment|/*  Returns:        0 for success, else nonzero error code         */
comment|/*  Called by:      kernel software software,  this routine is in  */
comment|/*                  the cdevsw table                               */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
name|xxwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|dda_softc
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|dda_state
operator|!=
name|S_LINK_UP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|LINE
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
return|;
block|}
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                       XXIOCTL()                             %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*  Process ioctl request.                                         */
comment|/*                                                                 */
comment|/*  Call:           xxioctl(dev, cmd, data, flag)                  */
comment|/*  Argument:       dev:   device                                  */
comment|/*                  cmd:   ioctl command                           */
comment|/*                  data:  pointer to data                         */
comment|/*                  flag:  ignored                                 */
comment|/*  Returns:        0 for sucess, else nonzero error code          */
comment|/*  Called by:      kernel software software,  this routine is in  */
comment|/*                  the cdevsw table                               */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
define|#
directive|define
name|TIOACCQBIT
value|(int)(0x80800000|('t'<<8)|125)
name|xxioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
name|dev_t
name|dev
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|LINE
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|TIOACCQBIT
condition|)
block|{
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|98
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) ioctl qbit msg: cmd=%x ACC=%x\n"
operator|,
name|UNIT
argument_list|(
name|dev
argument_list|)
operator|,
name|cmd
operator|,
name|TIOACCQBIT
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
name|xx_qbit_msg
argument_list|(
name|tp
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|TIOCSETP
operator|||
name|cmd
operator|==
name|TIOCSETN
condition|)
name|xxparam
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCREMOTE
case|:
if|if
condition|(
name|xxmode
index|[
name|LINE
argument_list|(
name|dev
argument_list|)
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|xxcntl
argument_list|(
name|tp
argument_list|,
name|XX_C_PAD
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCSBRK
case|:
name|xxcntl
argument_list|(
name|tp
argument_list|,
name|XX_C_BREAK
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
case|case
name|TIOCSDTR
case|:
case|case
name|TIOCCDTR
case|:
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                        XXPARAM()                            %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*  Set parameters from open or stty.                              */
comment|/*  This routine is being left in as a dummy in case in the future */
comment|/*  there is a mechanism for the host to send information i.e.     */
comment|/*  "hangup line" to the ACP _XX                                   */
comment|/*                                                                 */
comment|/*  Call:           xxparam(dev)                                   */
comment|/*  Argument:       dev:   device                                  */
comment|/*  Returns:        none                                           */
comment|/*  Called by:      none                                           */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*ARGSUSED*/
name|xxparam
argument_list|(
argument|dev
argument_list|)
name|dev_t
name|dev
decl_stmt|;
block|{ }
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                        XXSTART()                            %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*  Start (restart) transmission on a given line.  This is the     */
comment|/*  start routine which is called from above by the tty driver and */
comment|/*  from below on a transmission complete interrupt for a given    */
comment|/*  line.                                                          */
comment|/*                                                                 */
comment|/*  Call:           xxstart(tp)                                    */
comment|/*  Argument:       tp:   pointer to tty structure                 */
comment|/*  Returns:        none                                           */
comment|/*  Called by:      tty driver                                     */
comment|/*                  xxreset()                                      */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
name|xxstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
block|{
specifier|register
name|struct
name|dda_softc
modifier|*
name|ds
decl_stmt|;
specifier|register
name|int
name|nch
decl_stmt|,
name|cc
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|struct
name|dda_cb
modifier|*
name|dc
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|oq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|padinfo
modifier|*
name|pp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|line
decl_stmt|,
name|s
decl_stmt|,
name|j
decl_stmt|;
specifier|extern
name|int
name|ttrstrt
parameter_list|()
function_decl|;
name|line
operator|=
name|tp
operator|-
name|xx_tty
expr_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|dc
operator|=
operator|(
expr|struct
name|dda_cb
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
name|ds
operator|=
operator|&
name|dda_softc
index|[
name|unit
index|]
expr_stmt|;
name|pp
operator|=
operator|&
name|xx_padinfo
index|[
name|line
index|]
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|99
argument_list|,
name|unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) xxstart: line %d t_state = %x\n"
operator|,
name|unit
operator|,
name|line
operator|,
name|tp
operator|->
name|t_state
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
comment|/* If it's currently active, or delaying, no need to do anything. */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_TTSTOP
operator||
name|TS_BUSY
operator|)
expr_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* wait for free */
if|if
condition|(
name|dda_softc
index|[
name|unit
index|]
operator|.
name|dda_state
operator|!=
name|S_LINK_UP
condition|)
block|{
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|DMESG
argument_list|(
name|unit
argument_list|,
literal|96
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) xxstart: unit offline\n"
operator|,
name|unit
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* If the writer was sleeping on output overflow, wake him when low tide      * is reached. */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|TTLOWAT
argument_list|(
name|tp
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_wsel
condition|)
block|{
name|selwakeup
argument_list|(
name|tp
operator|->
name|t_wsel
argument_list|,
name|tp
operator|->
name|t_state
operator|&
name|TS_WCOLL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_wsel
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_WCOLL
expr_stmt|;
block|}
block|}
comment|/* restart transmission unless output queue is empty */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* if this is an outbound pad line and it's in command mode */
if|if
condition|(
name|pp
operator|->
name|p_state
operator|==
name|PS_COM
condition|)
block|{
name|xxpadhandle
argument_list|(
name|ds
argument_list|,
name|tp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Allocate an mbuf to stuff the chars into */
name|m
operator|=
literal|0
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|DMESG
argument_list|(
name|unit
argument_list|,
literal|97
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) xxstart: could not get mbuf\n"
operator|,
name|unit
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|cc
operator|=
literal|0
expr_stmt|;
comment|/* copy at most MLEN-1 chars out -- must save one byte for subfunc */
while|while
condition|(
operator|(
name|cc
operator|<
name|MLEN
operator|-
literal|1
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator|)
condition|)
name|nch
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|nch
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0200
argument_list|)
expr_stmt|;
if|if
condition|(
name|nch
operator|==
literal|0
condition|)
block|{
comment|/* if first item was a delay */
operator|(
name|void
operator|)
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
comment|/* discard the character */
continue|continue;
block|}
block|}
if|if
condition|(
name|nch
operator|>
operator|(
name|MLEN
operator|-
literal|1
operator|)
operator|-
name|cc
condition|)
name|nch
operator|=
operator|(
name|MLEN
operator|-
literal|1
operator|)
operator|-
name|cc
expr_stmt|;
comment|/* If any characters were set up, start transmission; */
if|if
condition|(
name|nch
condition|)
block|{
name|j
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|cp
argument_list|,
name|nch
argument_list|)
expr_stmt|;
if|#
directive|if
name|OUTPUT_PARITY_MASK
operator|!=
literal|0377
comment|/* strip all characters as desired */
for|for
control|(
name|p
operator|=
name|cp
operator|,
name|k
operator|=
name|j
init|;
name|k
condition|;
name|k
operator|--
operator|,
name|p
operator|++
control|)
operator|*
name|p
operator|&=
name|OUTPUT_PARITY_MASK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|100
argument_list|,
name|unit
argument_list|)
operator|&&
name|j
operator|!=
name|nch
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) xxstart: asked for %d got %d chars\n"
operator|,
name|unit
operator|,
name|nch
operator|,
name|j
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
name|cc
operator|+=
name|nch
expr_stmt|;
name|cp
operator|+=
name|nch
expr_stmt|;
block|}
else|else
break|break;
block|}
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|101
argument_list|,
name|unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) xxstart: mbuf %x len %d\n"
operator|,
name|unit
operator|,
name|m
operator|,
name|m
operator|->
name|m_len
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* if any data was stuffed into the mbuf then send it */
if|if
condition|(
name|cc
condition|)
block|{
name|m
operator|->
name|m_dat
index|[
name|MLEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* subfunction: no Q-bit */
name|m
operator|->
name|m_len
operator|=
name|cc
expr_stmt|;
name|oq
operator|=
operator|&
operator|(
name|dc
operator|->
name|dc_oq
operator|)
expr_stmt|;
comment|/* point to output queue */
if|if
condition|(
name|IF_QFULL
argument_list|(
name|oq
argument_list|)
condition|)
block|{
comment|/* if q full */
name|IF_DROP
argument_list|(
name|oq
argument_list|)
expr_stmt|;
comment|/* drop the data */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ds
operator|->
name|dda_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
comment|/* for netstat display */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|IF_ENQUEUE
argument_list|(
name|oq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* otherwise queue it */
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|dda_start
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|)
expr_stmt|;
comment|/* and try to output */
block|}
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|dc
operator|->
name|dc_lcn
operator|!=
literal|0
condition|)
comment|/* something left in oq? */
name|dda_start
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|)
expr_stmt|;
comment|/* restart output */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                        XXRESET()                            %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*  In response to UNIBUS reset, reset state and restart           */
comment|/*  transmitters.                                                  */
comment|/*                                                                 */
comment|/*  Call:           xxreset(uban)                                  */
comment|/*  Argument:       uban:  UNIBUS adaptor number                   */
comment|/*  Returns:        none                                           */
comment|/*  Called by:      kernel software in response to UNIBUS reset    */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*ARGSUSED*/
name|xxreset
argument_list|(
argument|uban
argument_list|)
name|int
name|uban
decl_stmt|;
block|{ }
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                        XXSTOP()                             %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*  Dummy stop routine.                                            */
comment|/*                                                                 */
comment|/*  Call:           xxstop(tp, flag)                               */
comment|/*  Argument:       tp:    pointer to tty structure                */
comment|/*                  flag:  indicates                               */
comment|/*  Returns:        none                                           */
comment|/*  Called by:      none                                           */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*ARGSUSED*/
name|xxstop
argument_list|(
argument|tp
argument_list|,
argument|flag
argument_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{ }
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                        XXSELECT()                           %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*  Circumvent bug in our bastardized design which causes ttselect */
comment|/*  to fail.							   */
comment|/*                                                                 */
comment|/*  Call:           xxselect(dev, rw)                              */
comment|/*  Argument:       dev:   device                                  */
comment|/*                  rw:    read or write indicator                 */
comment|/*  Returns:        0 or 1                                         */
comment|/*  Called by:      none                                           */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
name|xxselect
argument_list|(
argument|dev
argument_list|,
argument|rw
argument_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DDADEBUG
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|DDADBCH
argument_list|(
literal|102
argument_list|,
name|unit
argument_list|)
condition|)
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) select()\n"
operator|,
name|unit
name|DDAELOG
expr_stmt|;
endif|#
directive|endif
endif|DDADEBUG
return|return
operator|(
name|ttselect
argument_list|(
name|MAJLINE
argument_list|(
name|dev
argument_list|)
argument_list|,
name|rw
argument_list|)
operator|)
return|;
block|}
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                                                             %%*/
comment|/*%%                   LOCAL  FUNCTIONS                          %%*/
comment|/*%%                                                             %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                      X29_SUPR()                             %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*       This routine processes received supervisor messages.      */
comment|/*       Depending on the message type, the appropriate action is  */
comment|/*       taken.                                                    */
comment|/*                                                                 */
comment|/*  Call:              x29_supr(ds, p)                             */
comment|/*  Arguments:         ds:  pointer to dev control block struct    */
comment|/*                     p:   pointer to a character array           */
comment|/*                              containing the supervisor message  */
comment|/*  Returns:           nothing                                     */
comment|/*  Called by:         dda_supr()                                  */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
name|PRIVATE
name|void
name|x29_supr
parameter_list|(
name|ds
parameter_list|,
name|p
parameter_list|)
name|struct
name|dda_softc
modifier|*
name|ds
decl_stmt|;
name|u_char
name|p
index|[]
decl_stmt|;
block|{
specifier|register
name|struct
name|dda_cb
modifier|*
name|dc
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|lcn
decl_stmt|;
name|int
name|maxlcn
decl_stmt|;
name|int
name|line
decl_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|103
argument_list|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) x29_supr()\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
name|LINE_STATUS
case|:
comment|/* link status msg */
case|case
name|RESTART
case|:
comment|/* restart received */
case|case
name|RSTRT_ACK
case|:
comment|/* restart ack */
case|case
name|STATRESP
case|:
comment|/* Statistics Response from FEP */
name|DMESG
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|98
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) x29_supr: unexpected message type\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANSWER
case|:
comment|/* call answered */
name|lcn
operator|=
name|p
index|[
literal|1
index|]
operator|/
literal|2
expr_stmt|;
name|dc
operator|=
operator|&
operator|(
name|ds
operator|->
name|dda_cb
index|[
name|lcn
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|dc
operator|->
name|dc_state
operator|==
name|LC_CALL_PENDING
condition|)
block|{
comment|/* if a call pending */
name|decode_answer
argument_list|(
name|p
argument_list|,
name|dc
argument_list|)
expr_stmt|;
name|dc
operator|->
name|dc_state
operator|=
name|LC_DATA_IDLE
expr_stmt|;
comment|/* set state */
name|dc
operator|->
name|dc_flags
operator|=
name|DC_X29
expr_stmt|;
name|line
operator|=
name|dc
operator|->
name|dc_line
expr_stmt|;
comment|/* which line are we? */
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|114
argument_list|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) x29_supr: answer: line=%d\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|line
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
if|if
condition|(
name|line
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* fubar! */
name|DMESG
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|107
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) x29_supr: answer: line was -1, VC 0x%x\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|p
index|[
literal|1
index|]
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
block|}
name|xx_padinfo
index|[
name|line
index|]
operator|.
name|p_state
operator|=
name|PS_PAD
expr_stmt|;
name|xxstart
argument_list|(
operator|&
name|xx_tty
index|[
name|line
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DMESG
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|108
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) x29_supr: unexpected answer on LCN %d\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|lcn
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG_CALLS
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_INFO
argument_list|)
literal|"dda%d:(x29) LCN %d: connected\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|lcn
name|DDAELOG
expr_stmt|;
block|}
break|break;
case|case
name|RING
case|:
comment|/* incoming call */
if|if
condition|(
name|decode_ring
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* find a free lcn associated with a XX_HOST open */
name|dc
operator|=
operator|&
name|ds
operator|->
name|dda_cb
index|[
literal|1
index|]
expr_stmt|;
name|maxlcn
operator|=
name|nddach
index|[
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
index|]
expr_stmt|;
for|for
control|(
name|lcn
operator|=
literal|1
init|;
name|lcn
operator|<=
name|maxlcn
condition|;
name|lcn
operator|++
control|)
block|{
if|if
condition|(
name|dc
operator|->
name|dc_state
operator|==
name|LC_IDLE
operator|&&
name|dc
operator|->
name|dc_flags
operator|&
name|DC_X29W
condition|)
break|break;
name|dc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lcn
operator|>
name|maxlcn
condition|)
block|{
comment|/* if no free lcn's */
if|if
condition|(
name|LOG_BUSY
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) no free X29W lcns, call rejected, vc=0x%x\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|p
index|[
literal|1
index|]
name|DDAELOG
expr_stmt|;
block|}
name|send_supr
argument_list|(
name|ds
argument_list|,
name|CLEARVC
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear call */
break|break;
comment|/* exit case */
block|}
comment|/* got a good lcn, now use it */
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|103
argument_list|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) supr_msg: call from 0x%0x\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
operator|(
name|u_long
operator|)
name|dc
operator|->
name|dc_inaddr
operator|.
name|s_addr
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
name|dc
operator|->
name|dc_state
operator|=
name|LC_DATA_IDLE
expr_stmt|;
comment|/* set state */
name|dc
operator|->
name|dc_pktsizein
operator|=
literal|0
expr_stmt|;
name|dc
operator|->
name|dc_pktsizeout
operator|=
literal|0
expr_stmt|;
name|dc
operator|->
name|dc_wsizein
operator|=
literal|0
expr_stmt|;
name|dc
operator|->
name|dc_wsizeout
operator|=
literal|0
expr_stmt|;
name|dc
operator|->
name|dc_flags
operator|=
name|DC_X29
expr_stmt|;
name|send_supr
argument_list|(
name|ds
argument_list|,
name|ANSWER
argument_list|,
name|lcn
operator|*
literal|2
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* send answer */
if|if
condition|(
name|LOG_CALLS
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_INFO
argument_list|)
literal|"dda%d:(x29) Call accepted LCN %d\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|dc
operator|->
name|dc_lcn
name|DDAELOG
expr_stmt|;
block|}
name|line
operator|=
name|dc
operator|->
name|dc_line
expr_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|114
argument_list|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) x29_supr: ring: line=%d\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|line
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
if|if
condition|(
name|line
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* fubar! */
name|DMESG
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|107
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) x29_supr: ring: line was -1, VC 0x%x\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|p
index|[
literal|1
index|]
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|line
index|]
expr_stmt|;
name|xx_padinfo
index|[
name|line
index|]
operator|.
name|p_state
operator|=
name|PS_XFR
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
if|#
directive|if
name|ACC_ULTRIX
operator|>
literal|00
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ONDELAY
expr_stmt|;
endif|#
directive|endif
comment|/* I would prefer to wait a bit before sending this */
name|send_x29_param_msg
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|,
name|SET_PAD
argument_list|,
name|x29_callin_setparams
argument_list|,
sizeof|sizeof
argument_list|(
name|x29_callin_setparams
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* bad decode */
name|send_supr
argument_list|(
name|ds
argument_list|,
name|CLEARVC
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear call */
name|DMESG
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|100
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) Bad decode, call REJECTED VC 0x%x\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|p
index|[
literal|1
index|]
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLEARLC
case|:
comment|/* clear by LCN */
name|lcn
operator|=
name|p
index|[
literal|1
index|]
operator|/
literal|2
expr_stmt|;
comment|/* get LCN */
name|dc
operator|=
operator|&
operator|(
name|ds
operator|->
name|dda_cb
index|[
name|lcn
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|dc
operator|->
name|dc_state
operator|!=
name|LC_CLR_PENDING
condition|)
block|{
comment|/* if no clear pending */
name|send_supr
argument_list|(
name|ds
argument_list|,
name|CLEARLC
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ack the clear */
block|}
if|if
condition|(
name|dc
operator|->
name|dc_state
operator|==
name|LC_CALL_PENDING
condition|)
comment|/* call is cleared */
name|DMESG
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|101
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) Call cleared LCN %d (%x %x)\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|dc
operator|->
name|dc_lcn
operator|,
name|p
index|[
literal|2
index|]
operator|,
name|p
index|[
literal|4
index|]
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
name|hist_lcn_state
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
name|dc
operator|->
name|dc_state
argument_list|,
name|LC_IDLE
argument_list|)
expr_stmt|;
name|dc
operator|->
name|dc_state
operator|=
name|LC_IDLE
expr_stmt|;
name|dc
operator|->
name|dc_timer
operator|=
name|TMO_OFF
expr_stmt|;
comment|/* stop timer */
name|dc
operator|->
name|dc_wsizein
operator|=
name|dc
operator|->
name|dc_wsizeout
operator|=
literal|0
expr_stmt|;
name|dc
operator|->
name|dc_pktsizein
operator|=
name|dc
operator|->
name|dc_pktsizeout
operator|=
literal|0
expr_stmt|;
name|abort_io
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
name|lcn
argument_list|)
expr_stmt|;
name|xx_tp_hangup
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|)
expr_stmt|;
comment|/* will clear flags */
break|break;
case|case
name|CLEARVC
case|:
comment|/* clear by VCN */
name|send_supr
argument_list|(
name|ds
argument_list|,
name|CLEARVC
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send clear ack */
if|if
condition|(
name|LOG_CALLS
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_INFO
argument_list|)
literal|"dda%d:(x29) Network cleared VC %x (%x %x)\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|p
index|[
literal|1
index|]
operator|,
name|p
index|[
literal|2
index|]
operator|,
name|p
index|[
literal|4
index|]
name|DDAELOG
expr_stmt|;
block|}
break|break;
case|case
name|RESET
case|:
comment|/* X25 reset */
name|send_supr
argument_list|(
name|ds
argument_list|,
name|RESET_ACK
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send reset ack */
name|abort_io
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
operator|(
name|int
operator|)
name|p
index|[
literal|1
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
name|DMESG
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|102
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) X25 RESET on LCN %d (%x %x)\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|p
index|[
literal|1
index|]
operator|/
literal|2
operator|,
name|p
index|[
literal|2
index|]
operator|,
name|p
index|[
literal|4
index|]
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTERRUPT
case|:
comment|/* X25 interrupt */
ifdef|#
directive|ifdef
name|INDICATE_BREAK_ON_INTERRUPT
name|lcn
operator|=
name|p
index|[
literal|1
index|]
operator|/
literal|2
expr_stmt|;
name|dc
operator|=
operator|&
operator|(
name|ds
operator|->
name|dda_cb
index|[
name|lcn
index|]
operator|)
expr_stmt|;
name|line
operator|=
name|dc
operator|->
name|dc_line
expr_stmt|;
if|if
condition|(
name|line
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* fubar! */
name|DMESG
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|107
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) x29_supr: break: line was -1, VC 0x%x\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|p
index|[
literal|1
index|]
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|line
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
condition|)
name|c
operator|=
literal|0
expr_stmt|;
else|else
if|#
directive|if
name|ACC_ULTRIX
operator|>=
literal|30
name|c
operator|=
name|tp
operator|->
name|c_cc
index|[
name|VINTR
index|]
expr_stmt|;
comment|/* else make it the interrupt */
else|#
directive|else
name|c
operator|=
name|tp
operator|->
name|t_intrc
expr_stmt|;
comment|/* else make it the interrupt */
endif|#
directive|endif
if|#
directive|if
name|NBK
operator|>
literal|0
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
name|NETLDISC
condition|)
block|{
name|BKINPUT
argument_list|(
name|c
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|,
name|tp
operator|)
expr_stmt|;
comment|/* send_supr (ds, INTR_ACK, p[1], 0); 	not needed -- done by FE */
endif|#
directive|endif
break|break;
case|case
name|INTR_ACK
case|:
comment|/* quietly drop the acknowledgement */
break|break;
default|default:
name|DMESG
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|104
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) supervisor error (%x %x %x %x)\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|p
index|[
literal|0
index|]
operator|,
name|p
index|[
literal|1
index|]
operator|,
name|p
index|[
literal|2
index|]
operator|,
name|p
index|[
literal|3
index|]
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* hangup any attached processes */
name|PRIVATE
name|void
name|xx_tp_hangup
parameter_list|(
name|ds
parameter_list|,
name|dc
parameter_list|)
name|struct
name|dda_softc
modifier|*
name|ds
decl_stmt|;
specifier|register
name|struct
name|dda_cb
modifier|*
name|dc
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|padinfo
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|line
decl_stmt|;
name|line
operator|=
name|dc
operator|->
name|dc_line
expr_stmt|;
if|if
condition|(
name|line
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* fubar! */
name|DMESG
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|107
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) xx_tp_hangup: line was -1\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|line
index|]
expr_stmt|;
name|pp
operator|=
operator|&
name|xx_padinfo
index|[
name|line
index|]
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_flow
operator|!=
name|P_NOBLOCK
condition|)
block|{
comment|/* currently blocked? */
specifier|register
name|struct
name|hdx_chan
modifier|*
name|hc
decl_stmt|;
name|hc
operator|=
operator|(
expr|struct
name|hdx_chan
operator|*
operator|)
operator|&
name|dc
operator|->
name|dc_rchan
expr_stmt|;
name|dda_rrq
argument_list|(
name|ds
argument_list|,
name|hc
argument_list|)
expr_stmt|;
comment|/* make sure we hang a read */
block|}
name|pp
operator|->
name|p_flow
operator|=
name|P_NOBLOCK
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_CARR_ON
operator||
name|TS_ASLEEP
operator||
name|TS_BUSY
operator|)
expr_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|gsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|gsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|xxmode
index|[
name|line
index|]
operator|=
name|MODE_UNUSED
expr_stmt|;
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
name|pp
operator|->
name|p_state
operator|=
name|PS_IDLE
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_mchsav
condition|)
block|{
name|m_freem
argument_list|(
name|pp
operator|->
name|p_mchsav
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_msav
operator|=
name|pp
operator|->
name|p_mchsav
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|dc
operator|->
name|dc_flags
operator|&=
operator|~
operator|(
name|DC_X29
operator||
name|DC_X29W
operator|)
expr_stmt|;
comment|/* release to others */
block|}
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                      X29_DATA()                             %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*    This routine is called when a data channel I/O completes.    */
comment|/*    If the completion was for a write, an attempt is made to     */
comment|/*    start output on the next packet waiting for output on that   */
comment|/*    LCN.  If the completion was for a read, the received packet  */
comment|/*    is sent to the IP input queue (if no error) and another read */
comment|/*    is started on the LCN.                                       */
comment|/*                                                                 */
comment|/*  Call:              x29_data(ds, hc, cc, cnt)                   */
comment|/*  Argument:          ds:  device control block                   */
comment|/*                     hc:  half duplex channel control block      */
comment|/*                     cc:   Mailbox I/O completion status         */
comment|/*                     cnt:  byte count                            */
comment|/*  Returns:           nothing                                     */
comment|/*  Called by:         ddainta()                                   */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
define|#
directive|define
name|QBIT
value|0x80
name|PRIVATE
name|void
name|x29_data
parameter_list|(
name|ds
parameter_list|,
name|hc
parameter_list|,
name|cc
parameter_list|,
name|cnt
parameter_list|,
name|subcc
parameter_list|)
specifier|register
name|struct
name|dda_softc
modifier|*
name|ds
decl_stmt|;
specifier|register
name|struct
name|hdx_chan
modifier|*
name|hc
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|cnt
decl_stmt|,
name|subcc
decl_stmt|;
block|{
specifier|register
name|struct
name|dda_cb
modifier|*
name|dc
init|=
operator|&
operator|(
name|ds
operator|->
name|dda_cb
index|[
name|hc
operator|->
name|hc_chan
operator|/
literal|2
index|]
operator|)
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|104
argument_list|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) x29_data: chan=%x cc=%x cnt=%x subcc=%x\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|hc
operator|->
name|hc_chan
operator|,
name|cc
operator|,
name|cnt
operator|,
name|subcc
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
if|if
condition|(
name|hc
operator|->
name|hc_chan
operator|&
literal|0x01
condition|)
block|{
comment|/* if write, fire up next output */
ifdef|#
directive|ifdef
name|DDADEBUG
name|dc
operator|->
name|dc_out_t
operator|=
name|TMO_OFF
expr_stmt|;
comment|/* turn off output completion timer */
endif|#
directive|endif
if|if
condition|(
operator|(
name|hc
operator|->
name|hc_func
operator|!=
name|DDAABT
operator|)
operator|&&
operator|(
name|hc
operator|->
name|hc_curr
operator|=
name|hc
operator|->
name|hc_curr
operator|->
name|m_next
operator|)
condition|)
name|dda_wrq
argument_list|(
name|ds
argument_list|,
name|hc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* it is abort | no more data left */
name|char
name|qbit_indicator
decl_stmt|;
name|qbit_indicator
operator|=
name|hc
operator|->
name|hc_mbuf
operator|->
name|m_dat
index|[
name|MLEN
operator|-
literal|1
index|]
expr_stmt|;
name|m_freem
argument_list|(
name|hc
operator|->
name|hc_mbuf
argument_list|)
expr_stmt|;
name|hc
operator|->
name|hc_mbuf
operator|=
name|hc
operator|->
name|hc_curr
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|hc
operator|->
name|hc_func
operator|==
name|DDAABT
condition|)
block|{
name|hc
operator|->
name|hc_func
operator|&=
operator|~
name|DDAABT
expr_stmt|;
name|hc
operator|->
name|hc_inv
operator|&=
operator|~
name|INVALID_MBUF
expr_stmt|;
block|}
else|else
name|ds
operator|->
name|dda_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|dc
operator|->
name|dc_flags
operator|&=
operator|~
name|DC_OBUSY
expr_stmt|;
if|if
condition|(
name|qbit_indicator
operator|==
name|QBIT
condition|)
block|{
comment|/* Q-bit packet? */
name|dda_start
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|)
expr_stmt|;
comment|/* restart output */
block|}
else|else
block|{
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|dc
operator|->
name|dc_line
index|]
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|xxstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* restart tty output */
block|}
block|}
comment|/* it's a packet coming in from the front end to the host */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DDADEBUG
name|dc
operator|->
name|dc_flags
operator|&=
operator|~
name|DC_IPEND
expr_stmt|;
endif|#
directive|endif
name|hc
operator|=
operator|&
name|dc
operator|->
name|dc_rchan
expr_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|105
argument_list|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|)
condition|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) "
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
name|DDAELOG
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|hc
operator|->
name|hc_curr
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|prt_bytes
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|"received data"
argument_list|,
name|p
argument_list|,
operator|(
name|cnt
operator|<
literal|64
condition|?
name|cnt
else|:
literal|64
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DDADBCH
argument_list|(
literal|106
argument_list|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) x29_data: read complete mbuf=%x curr=%x\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|hc
operator|->
name|hc_mbuf
operator|,
name|hc
operator|->
name|hc_curr
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
if|if
condition|(
name|dc
operator|->
name|dc_state
operator|!=
name|LC_DATA_IDLE
condition|)
block|{
name|m_freem
argument_list|(
name|hc
operator|->
name|hc_mbuf
argument_list|)
expr_stmt|;
comment|/* toss the packet, lcn is dead */
name|hc
operator|->
name|hc_mbuf
operator|=
name|hc
operator|->
name|hc_curr
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
name|DDAIOCOK
operator|||
operator|(
name|cc
operator|==
name|DDAIOCOKP
operator|&&
operator|!
operator|(
name|subcc
operator|&
name|QBIT
operator|)
operator|)
condition|)
block|{
comment|/* Queue up I/O completion OK transfers and I/O OK with more data 	 * pending transfers (as long as it's not a Qbit message). 	 * This algorythm operates differently than the IP handler due 	 * to the fact that we don't need to wait for the entire X.25 	 * packet to arrive on the host before we assemble it.  To do 	 * so should be OK,  but unfortunately it seems some brain-dead 	 * PAD's generate packets with the M-bit set if they have more 	 * data in their internal buffers.  This can cause the system 	 * to burn up mbufs waiting for us to finally receive a packet 	 * with the M-bit not set.  However, we should hold up on processing 	 * packets with both the Q-bit and the M-bit set until we receive 	 * the entire Q-bit message.  If we get 30k Q-bit packets, we will 	 * die, but that is obscenely absurd in the first place. 	 * (sigh)	-- pst 7-19-89 	 */
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|107
argument_list|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) x29_data: chan=%x DDAIOCOK\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|hc
operator|->
name|hc_chan
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
name|hc
operator|->
name|hc_curr
operator|->
name|m_len
operator|+=
name|cnt
expr_stmt|;
comment|/* update byte count */
name|ds
operator|->
name|dda_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
comment|/* HANDLE THE DATA HERE */
if|if
condition|(
name|subcc
operator|&
name|QBIT
condition|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|mcp
decl_stmt|;
name|mcp
operator|=
name|mtod
argument_list|(
name|hc
operator|->
name|hc_curr
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|hc
operator|->
name|hc_curr
operator|->
name|m_len
expr_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|108
argument_list|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|)
condition|)
name|prt_bytes
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|"(x29) Qbit:"
argument_list|,
name|mcp
argument_list|,
operator|(
name|len
operator|<
literal|64
condition|?
name|len
else|:
literal|64
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DDADEBUG
if|if
condition|(
operator|*
name|mcp
operator|==
name|BREAK_INDIC
condition|)
block|{
comment|/* Break indication? */
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|x29_break_reply_is_required
argument_list|(
name|mcp
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|/* tell pad to stop discarding output */
name|send_x29_param_msg
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|,
name|SET_PAD
argument_list|,
name|x29_break_ack_params
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|hc
operator|->
name|hc_curr
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
comment|/* change data to single byte */
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|dc
operator|->
name|dc_line
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
condition|)
comment|/* if port is in raw mode, */
operator|*
name|mcp
operator|=
literal|0
expr_stmt|;
comment|/* make the byte a null */
else|else
if|#
directive|if
name|ACC_ULTRIX
operator|>=
literal|30
operator|*
name|mcp
operator|=
name|tp
operator|->
name|t_cc
index|[
name|VINTR
index|]
expr_stmt|;
comment|/* else make it the interrupt */
else|#
directive|else
operator|*
name|mcp
operator|=
name|tp
operator|->
name|t_intrc
expr_stmt|;
comment|/* else make it the interrupt */
endif|#
directive|endif
name|x29_dhandle
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|mcp
operator|&
name|READ_PAD
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|1
condition|)
comment|/* just a message, no params? */
name|send_x29_param_msg
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|,
name|PAR_INDICATION
argument_list|,
name|x29_callout_params
argument_list|,
sizeof|sizeof
argument_list|(
name|x29_callout_params
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|send_x29_param_msg
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|,
name|PAR_INDICATION
argument_list|,
name|mcp
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|hc
operator|->
name|hc_mbuf
argument_list|)
expr_stmt|;
name|hc
operator|->
name|hc_mbuf
operator|=
name|hc
operator|->
name|hc_curr
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|hc
operator|->
name|hc_mbuf
argument_list|)
expr_stmt|;
name|hc
operator|->
name|hc_mbuf
operator|=
name|hc
operator|->
name|hc_curr
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not Qbit data, process normally */
name|x29_dhandle
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
name|DDAIOCOKP
condition|)
block|{
comment|/* good completion, more data pending */
name|hc
operator|->
name|hc_curr
operator|->
name|m_len
operator|+=
name|cnt
expr_stmt|;
block|}
else|else
block|{
comment|/* toss packet */
name|m_freem
argument_list|(
name|hc
operator|->
name|hc_mbuf
argument_list|)
expr_stmt|;
name|hc
operator|->
name|hc_mbuf
operator|=
name|hc
operator|->
name|hc_curr
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* hang a new data read */
ifdef|#
directive|ifdef
name|DDADEBUG
name|dc
operator|->
name|dc_flags
operator||=
name|DC_IPEND
expr_stmt|;
endif|#
directive|endif
name|dda_rrq
argument_list|(
name|ds
argument_list|,
name|hc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* this routine copies chars from the dc_rchan mbuf to the upper  * level software.  If all the characters are read then the mbuf is  * freed and a new read is hung on the channel.  *  * This routine is called from below by the int A handler and from above  * by the device read routine.  */
name|PRIVATE
name|void
name|x29_dhandle
parameter_list|(
name|ds
parameter_list|,
name|dc
parameter_list|,
name|restart
parameter_list|)
specifier|register
name|struct
name|dda_softc
modifier|*
name|ds
decl_stmt|;
specifier|register
name|struct
name|dda_cb
modifier|*
name|dc
decl_stmt|;
name|int
name|restart
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|hdx_chan
modifier|*
name|hc
decl_stmt|;
specifier|register
name|padinfo
modifier|*
name|pp
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|s
decl_stmt|,
name|line
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|static
name|int
name|recurse
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|recurse
condition|)
block|{
comment|/* don't allow ourselves to be called recursively */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|recurse
operator|=
literal|1
expr_stmt|;
name|hc
operator|=
operator|(
expr|struct
name|hdx_chan
operator|*
operator|)
operator|&
name|dc
operator|->
name|dc_rchan
expr_stmt|;
name|line
operator|=
name|dc
operator|->
name|dc_line
expr_stmt|;
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|line
index|]
expr_stmt|;
name|pp
operator|=
operator|&
name|xx_padinfo
index|[
name|line
index|]
expr_stmt|;
if|if
condition|(
name|restart
condition|)
block|{
comment|/* trying to restart input? */
name|j
operator|=
name|pp
operator|->
name|p_flow
expr_stmt|;
name|m
operator|=
name|pp
operator|->
name|p_mchsav
expr_stmt|;
name|m2
operator|=
name|pp
operator|->
name|p_msav
expr_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|109
argument_list|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) flow restart [%d] in %x\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|j
operator|,
name|m
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
block|}
else|else
block|{
name|j
operator|=
name|P_NOBLOCK
expr_stmt|;
name|m2
operator|=
name|m
operator|=
name|hc
operator|->
name|hc_mbuf
expr_stmt|;
comment|/* que mbuf chain */
block|}
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|DMESG
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|105
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) x29_dhandle: null mbuf\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
name|hc
operator|->
name|hc_mbuf
operator|=
name|hc
operator|->
name|hc_curr
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
expr_stmt|;
name|dda_rrq
argument_list|(
name|ds
argument_list|,
name|hc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
while|while
condition|(
name|m2
condition|)
block|{
name|cp
operator|=
name|mtod
argument_list|(
name|m2
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|m2
operator|->
name|m_len
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|=
name|cp
index|[
name|j
index|]
operator|&
name|INPUT_PARITY_MASK
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|tp
operator|->
name|t_canq
operator|.
name|c_cc
operator|>=
name|TTYHOG
operator|-
literal|2
condition|)
if|if
condition|(
operator|!
name|ttbreakc
argument_list|(
name|c
argument_list|,
name|tp
argument_list|)
condition|)
continue|continue;
comment|/* dump the character */
if|#
directive|if
name|NBK
operator|>
literal|0
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
name|NETLDISC
condition|)
block|{
name|BKINPUT
argument_list|(
name|c
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|,
name|tp
operator|)
expr_stmt|;
comment|/* Block further input iff: Current input> threshold AND input 	     * is available to user program */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|tp
operator|->
name|t_canq
operator|.
name|c_cc
operator|)
operator|>=
name|TTYHOG
operator|/
literal|4
operator|&&
operator|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|CBREAK
operator|)
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_canq
operator|.
name|c_cc
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|109
argument_list|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) flow on [%d] in %x of %d\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
operator|,
name|j
operator|,
name|m2
operator|,
name|m2
operator|->
name|m_len
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
name|pp
operator|->
name|p_flow
operator|=
name|j
operator|+
literal|1
expr_stmt|;
name|pp
operator|->
name|p_msav
operator|=
name|m2
expr_stmt|;
name|pp
operator|->
name|p_mchsav
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|restart
operator|==
literal|0
condition|)
name|hc
operator|->
name|hc_mbuf
operator|=
name|hc
operator|->
name|hc_curr
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|m2
operator|=
name|m2
operator|->
name|m_next
expr_stmt|;
name|j
operator|=
name|P_NOBLOCK
expr_stmt|;
block|}
if|if
condition|(
name|restart
condition|)
name|pp
operator|->
name|p_msav
operator|=
name|pp
operator|->
name|p_mchsav
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|hc
operator|->
name|hc_mbuf
operator|=
name|hc
operator|->
name|hc_curr
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
expr_stmt|;
name|pp
operator|->
name|p_flow
operator|=
name|P_NOBLOCK
expr_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
name|dc
operator|->
name|dc_flags
operator||=
name|DC_IPEND
expr_stmt|;
endif|#
directive|endif
name|dda_rrq
argument_list|(
name|ds
argument_list|,
name|hc
argument_list|)
expr_stmt|;
name|out
label|:
name|recurse
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|PRIVATE
name|void
name|xx_qbit_msg
parameter_list|(
name|tp
parameter_list|,
name|unit
parameter_list|,
name|msg
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
specifier|register
name|struct
name|dda_cb
modifier|*
name|dc
decl_stmt|;
specifier|register
name|struct
name|dda_softc
modifier|*
name|ds
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ds
operator|=
operator|&
name|dda_softc
index|[
name|unit
index|]
expr_stmt|;
name|dc
operator|=
operator|(
expr|struct
name|dda_cb
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|110
argument_list|,
name|unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) xx_qbit_msg: %d %d %d\n"
operator|,
name|unit
operator|,
name|msg
index|[
literal|0
index|]
operator|,
name|msg
index|[
literal|1
index|]
operator|,
name|msg
index|[
literal|2
index|]
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|<
operator|(
name|MLEN
operator|-
literal|4
operator|)
condition|)
name|send_x29_param_msg
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|,
name|msg
index|[
literal|0
index|]
argument_list|,
name|msg
operator|+
literal|2
argument_list|,
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                        XXCNTL()                             %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*  Do modem control functions on a line.                          */
comment|/*                                                                 */
comment|/*  Call:           xxcntl(tp, c, d)                               */
comment|/*  Argument:       tp:   pointer to tty structure                 */
comment|/*                  c:    function code                            */
comment|/*                  unit: for unit number                          */
comment|/*  Returns:        none                                           */
comment|/*  Called by:      xxopen()                                       */
comment|/*                  xxclose()                                      */
comment|/*                  xxread()                                       */
comment|/*                  xxint()                                        */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
name|PRIVATE
name|void
name|xxcntl
parameter_list|(
name|tp
parameter_list|,
name|c
parameter_list|,
name|unit
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|dda_cb
modifier|*
name|dc
decl_stmt|;
specifier|register
name|struct
name|dda_softc
modifier|*
name|ds
decl_stmt|;
specifier|register
name|padinfo
modifier|*
name|pp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|l
decl_stmt|;
name|l
operator|=
name|tp
operator|-
name|xx_tty
expr_stmt|;
name|ds
operator|=
operator|&
name|dda_softc
index|[
name|unit
index|]
expr_stmt|;
name|pp
operator|=
operator|&
name|xx_padinfo
index|[
name|l
index|]
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|111
argument_list|,
name|unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) xxcntl: tp=0x%x line=%d\n"
operator|,
name|unit
operator|,
name|tp
operator|,
name|l
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|XX_C_PAD
case|:
if|if
condition|(
name|tp
operator|->
name|t_addr
condition|)
break|break;
if|if
condition|(
name|dc
operator|=
name|find_free_lcn
argument_list|(
name|ds
argument_list|)
condition|)
block|{
comment|/* race against locate_x25_lcn */
name|dc
operator|->
name|dc_flags
operator|=
name|DC_X29
expr_stmt|;
name|dc
operator|->
name|dc_line
operator|=
name|l
expr_stmt|;
name|pp
operator|->
name|p_state
operator|=
name|PS_COM
expr_stmt|;
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
name|dc
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
name|pp
operator|->
name|p_flow
operator|=
name|P_NOBLOCK
expr_stmt|;
name|pp
operator|->
name|p_msav
operator|=
name|pp
operator|->
name|p_mchsav
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
expr_stmt|;
name|pp
operator|->
name|p_idx
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|p_line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
break|break;
case|case
name|XX_C_HOST
case|:
if|if
condition|(
name|tp
operator|->
name|t_addr
condition|)
break|break;
if|if
condition|(
name|dc
operator|=
name|find_free_lcn
argument_list|(
name|ds
argument_list|)
condition|)
block|{
comment|/* race against locate_x25_lcn */
name|dc
operator|->
name|dc_flags
operator|=
name|DC_X29W
expr_stmt|;
name|dc
operator|->
name|dc_line
operator|=
name|l
expr_stmt|;
name|pp
operator|->
name|p_state
operator|=
name|PS_WAIT
expr_stmt|;
name|pp
operator|->
name|p_flow
operator|=
name|P_NOBLOCK
expr_stmt|;
name|pp
operator|->
name|p_msav
operator|=
name|pp
operator|->
name|p_mchsav
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
name|dc
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
break|break;
case|case
name|XX_C_CLOSE
case|:
name|pp
operator|->
name|p_state
operator|=
name|PS_IDLE
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_mchsav
condition|)
block|{
name|m_freem
argument_list|(
name|pp
operator|->
name|p_mchsav
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_msav
operator|=
name|pp
operator|->
name|p_mchsav
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|dc
operator|=
operator|(
expr|struct
name|dda_cb
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
if|if
condition|(
name|dc
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|pp
operator|->
name|p_flow
operator|!=
name|P_NOBLOCK
condition|)
block|{
comment|/* currently blocked? */
specifier|register
name|struct
name|hdx_chan
modifier|*
name|hc
decl_stmt|;
name|hc
operator|=
operator|(
expr|struct
name|hdx_chan
operator|*
operator|)
operator|&
name|dc
operator|->
name|dc_rchan
expr_stmt|;
name|dda_rrq
argument_list|(
name|ds
argument_list|,
name|hc
argument_list|)
expr_stmt|;
comment|/* make sure we hang a read */
block|}
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|111
argument_list|,
name|unit
argument_list|)
condition|)
block|{
specifier|static
name|char
modifier|*
name|st
index|[]
init|=
block|{
literal|"lcn down"
block|,
literal|"lcn restart"
block|,
literal|"idle"
block|,
literal|"call pending"
block|,
literal|"data idle"
block|,
literal|"clear pending"
block|}
decl_stmt|;
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) xxcntl: close state: %s\n"
operator|,
name|unit
operator|,
name|st
index|[
name|dc
operator|->
name|dc_state
index|]
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
if|if
condition|(
name|dc
operator|->
name|dc_state
operator|==
name|LC_DATA_IDLE
operator|||
name|dc
operator|->
name|dc_state
operator|==
name|LC_CALL_PENDING
condition|)
name|clear_lcn
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|)
expr_stmt|;
comment|/* send clear& set state to clr_pending */
comment|/* timers will convert it to LC_IDLE later */
ifdef|#
directive|ifdef
name|DDADEBUG
elseif|else
if|if
condition|(
name|DDADBCH
argument_list|(
literal|111
argument_list|,
name|unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) xxcntl: warning: state not data_idle\n"
operator|,
name|unit
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
name|dc
operator|->
name|dc_flags
operator|&=
operator|~
operator|(
name|DC_X29
operator||
name|DC_X29W
operator|)
expr_stmt|;
comment|/* release to others */
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
break|break;
case|case
name|XX_C_BREAK
case|:
comment|/* really should look at X.3 parameters to decide if an interrupt 	 * packet should be sent. instead, we take an action which assumes 	 * PAD parameter 7 has value 21 */
name|dc
operator|=
operator|(
expr|struct
name|dda_cb
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
name|send_supr
argument_list|(
name|ds
argument_list|,
name|INTERRUPT
argument_list|,
name|dc
operator|->
name|dc_lcn
operator|*
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_x29_param_msg
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|,
name|BREAK_INDIC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                     X29_INIT()                              %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*  Software reset, clear lines.                                   */
comment|/*                                                                 */
comment|/*  Call:           x29_init(unit, active);                        */
comment|/*  Argument:       unit:  ACP _XX device                          */
comment|/*  Returns:        none                                           */
comment|/*  Called by:      none                                           */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
name|PRIVATE
name|void
name|x29_init
parameter_list|(
name|unit
parameter_list|,
name|active
parameter_list|)
name|int
name|unit
decl_stmt|,
name|active
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|padinfo
modifier|*
name|pp
decl_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|113
argument_list|,
name|unit
argument_list|)
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) x29_init() active=%d\n"
operator|,
name|unit
operator|,
name|active
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
if|if
condition|(
name|active
condition|)
name|xxclear
argument_list|(
name|unit
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XXLPERBRD
condition|;
name|i
operator|++
control|)
block|{
name|xx_tty
index|[
name|unit
operator|*
name|XXLPERBRD
operator|+
name|i
index|]
operator|.
name|t_state
operator|=
name|PS_IDLE
expr_stmt|;
name|pp
operator|=
operator|&
name|xx_padinfo
index|[
name|unit
operator|*
name|XXLPERBRD
operator|+
name|i
index|]
expr_stmt|;
name|pp
operator|->
name|p_state
operator|=
name|PS_IDLE
expr_stmt|;
name|pp
operator|->
name|p_flow
operator|=
name|P_NOBLOCK
expr_stmt|;
name|pp
operator|->
name|p_msav
operator|=
name|pp
operator|->
name|p_mchsav
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|PRIVATE
name|void
name|xxclear
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|dda_softc
modifier|*
name|ds
decl_stmt|;
specifier|register
name|struct
name|dda_cb
modifier|*
name|dc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|state
decl_stmt|;
name|ds
operator|=
operator|&
name|dda_softc
index|[
name|unit
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|unit
operator|*
name|XXLPERBRD
index|]
init|;
name|i
operator|<
name|XXLPERBRD
condition|;
name|i
operator|++
operator|,
name|tp
operator|++
control|)
block|{
name|state
operator|=
name|tp
operator|->
name|t_state
expr_stmt|;
ifdef|#
directive|ifdef
name|DDADEBUG
if|if
condition|(
name|DDADBCH
argument_list|(
literal|112
argument_list|,
name|unit
argument_list|)
operator|&&
name|state
condition|)
block|{
name|DDALOG
argument_list|(
name|LOG_DEBUG
argument_list|)
literal|"dda%d:(x29) xxclear: line=%d pgrp=%d state=%d\n"
operator|,
name|unit
operator|,
name|i
operator|,
name|tp
operator|->
name|t_pgrp
operator|,
name|state
name|DDAELOG
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDADEBUG
if|if
condition|(
name|state
operator|&
name|TS_WOPEN
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_WOPEN
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
name|dc
operator|=
operator|(
expr|struct
name|dda_cb
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
if|if
condition|(
name|dc
condition|)
block|{
name|xx_tp_hangup
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|)
expr_stmt|;
name|dc
operator|->
name|dc_line
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* break correspondence */
block|}
block|}
block|}
block|}
comment|/*@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*%%                        XXSHOW()                             %%*/
comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
comment|/*                                                                 */
comment|/*  Purpose:                                                       */
comment|/*                                                                 */
comment|/*      Show status of each active unit                            */
comment|/*                                                                 */
comment|/*  Call:           xxshow()                                       */
comment|/*  Argument:       none		                           */
comment|/*  Returns:        none                                           */
comment|/*  Called by:      none                                           */
comment|/*                                                                 */
comment|/*##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
name|PRIVATE
name|void
name|xxshow
parameter_list|()
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|padinfo
modifier|*
name|pp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
name|st
index|[]
init|=
block|{
literal|"idle"
block|,
literal|" com"
block|,
literal|" pad"
block|,
literal|"wait"
block|,
literal|"xfer"
block|}
decl_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
operator|(
name|NDDA
operator|<
name|XXBOARDS
condition|?
name|NDDA
else|:
name|XXBOARDS
operator|)
condition|;
name|unit
operator|++
control|)
block|{
name|uprintf
argument_list|(
literal|"\nACP5250/6250 X29 driver: state of unit %d -\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"line\tstate\tlcn\tflow\ttstate\ttflags\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tp
operator|=
operator|&
name|xx_tty
index|[
name|unit
operator|*
name|XXLPERBRD
index|]
init|;
name|i
operator|<
name|XXLPERBRD
condition|;
name|i
operator|++
operator|,
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
name|pp
operator|=
operator|&
name|xx_padinfo
index|[
name|i
index|]
expr_stmt|;
name|uprintf
argument_list|(
literal|"%d:\t%s\t%d\t%d\t%x\t%x\n"
argument_list|,
name|i
argument_list|,
name|st
index|[
name|pp
operator|->
name|p_state
index|]
argument_list|,
operator|(
expr|struct
name|dda_cb
operator|*
operator|)
operator|(
name|tp
operator|->
name|t_addr
operator|)
operator|-
name|dda_softc
index|[
name|unit
index|]
operator|.
name|dda_cb
argument_list|,
name|pp
operator|->
name|p_flow
argument_list|,
name|tp
operator|->
name|t_state
argument_list|,
name|tp
operator|->
name|t_flags
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|uprintf
argument_list|(
literal|"remaining lines free\n"
argument_list|)
expr_stmt|;
block|}
comment|/******************************************************************************  *                           PAD CODE  ******************************************************************************/
comment|/* PADCHARUP - Pass a character up towards the user */
define|#
directive|define
name|PADCHARUP
parameter_list|(
name|c
parameter_list|,
name|tp
parameter_list|)
value|(*linesw[(tp)->t_line].l_rint) ((c), (tp))
name|PRIVATE
name|void
name|xxpadhandle
parameter_list|(
name|ds
parameter_list|,
name|tp
parameter_list|,
name|pi
parameter_list|)
name|struct
name|dda_softc
modifier|*
name|ds
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* pointer to relevant tty structure */
name|padinfo
modifier|*
name|pi
decl_stmt|;
comment|/* pointer to relevant padinfo structure */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|struct
name|dda_cb
modifier|*
name|dc
decl_stmt|;
name|int
name|nch
decl_stmt|;
name|char
name|tbuf
index|[
name|CBSIZE
index|]
decl_stmt|;
comment|/* CBSIZE is number of char in a 					 * cblock */
name|nch
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|tbuf
argument_list|,
name|CBSIZE
argument_list|)
expr_stmt|;
comment|/* handle characters in command state. Its OK if were slow here because      * there is a person on the other end of the discussion */
name|dc
operator|=
operator|(
expr|struct
name|dda_cb
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nch
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pi
operator|->
name|p_idx
operator|>=
name|P_LINELEN
condition|)
block|{
name|xxpadmsg
argument_list|(
literal|"\r\ncommand too long\r\n@"
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|pi
operator|->
name|p_idx
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|c
operator|=
name|pi
operator|->
name|p_line
index|[
name|pi
operator|->
name|p_idx
index|]
operator|=
name|tbuf
index|[
name|i
index|]
operator|&
name|INPUT_PARITY_MASK
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
name|PADCHARUP
argument_list|(
literal|'\r'
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|PADCHARUP
argument_list|(
literal|'\n'
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|pi
operator|->
name|p_line
index|[
name|pi
operator|->
name|p_idx
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dc
operator|&&
name|dc
operator|->
name|dc_state
operator|!=
name|LC_IDLE
condition|)
block|{
name|xxpadmsg
argument_list|(
literal|"cannot call, line is in transition\r\n"
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|&&
name|dc
operator|->
name|dc_state
operator|==
name|LC_CALL_PENDING
condition|)
name|xxpadmsg
argument_list|(
literal|"previous call still pending\r\n"
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xxpadparse
argument_list|(
name|ds
argument_list|,
name|pi
argument_list|,
name|tp
argument_list|)
operator|==
literal|0
condition|)
name|PADCHARUP
argument_list|(
literal|'@'
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|pi
operator|->
name|p_idx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\b'
operator|||
name|c
operator|==
literal|'\177'
condition|)
block|{
if|if
condition|(
name|pi
operator|->
name|p_idx
condition|)
block|{
name|pi
operator|->
name|p_idx
operator|--
expr_stmt|;
name|xxpadmsg
argument_list|(
literal|"\b \b"
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pi
operator|->
name|p_idx
operator|++
expr_stmt|;
name|PADCHARUP
argument_list|(
name|c
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|PRIVATE
name|int
name|xxpadparse
parameter_list|(
name|ds
parameter_list|,
name|pi
parameter_list|,
name|tp
parameter_list|)
name|struct
name|dda_softc
modifier|*
name|ds
decl_stmt|;
name|padinfo
modifier|*
name|pi
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|pi
operator|->
name|p_line
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'c'
operator|||
operator|*
name|p
operator|==
literal|'C'
condition|)
block|{
comment|/* connect command */
for|for
control|(
name|p
operator|++
init|;
operator|*
name|p
operator|==
literal|' '
condition|;
operator|*
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
name|xxpadmsg
argument_list|(
literal|"???\r\n"
argument_list|,
name|tp
argument_list|)
expr_stmt|;
else|else
comment|/* place a call */
return|return
name|xxpadcall
argument_list|(
name|ds
argument_list|,
name|p
argument_list|,
name|tp
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
condition|)
name|xxpadmsg
argument_list|(
literal|"invalid command\r\n"
argument_list|,
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|PRIVATE
name|int
name|xxpadcall
parameter_list|(
name|ds
parameter_list|,
name|addr
parameter_list|,
name|tp
parameter_list|)
name|struct
name|dda_softc
modifier|*
name|ds
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|in_addr
name|in
decl_stmt|;
while|while
condition|(
name|addr
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|addr
index|[
name|i
index|]
operator|<
literal|'0'
operator|||
name|addr
index|[
name|i
index|]
operator|>
literal|'9'
condition|)
block|{
name|xxpadmsg
argument_list|(
literal|"invalid address\r\n"
argument_list|,
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|ddacb_called_addr
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|ddacb_called_addr
operator|+
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ddacb_user_data
index|[
literal|0
index|]
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
comment|/* no user data for now */
name|in
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
return|return
name|make_x25_call
argument_list|(
name|ds
argument_list|,
operator|(
expr|struct
name|dda_cb
operator|*
operator|)
name|tp
operator|->
name|t_addr
argument_list|,
name|in
argument_list|,
name|X25_PROTO_X29
argument_list|)
return|;
block|}
name|PRIVATE
name|void
name|xxpadmsg
parameter_list|(
name|s
parameter_list|,
name|tp
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|PADCHARUP
argument_list|(
operator|*
name|s
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
comment|/*  * This routine is used to respond to  * READ_PARAMS and SET_READ_PARAMS requests, and also  * to send out a SET_PARAMS request for incoming calls.  * The outgoing pad supports NO parameters.  */
name|send_x29_param_msg
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|,
name|type
argument_list|,
name|msg
argument_list|,
name|len
argument_list|)
specifier|register
expr|struct
name|dda_cb
operator|*
name|dc
expr_stmt|;
specifier|register
name|struct
name|dda_softc
modifier|*
name|ds
decl_stmt|;
name|x29_pad_pair
modifier|*
name|msg
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|short
name|i
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|oq
decl_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
comment|/* Allocate an mbuf to stuff the chars into */
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|DMESG
argument_list|(
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
argument_list|,
literal|106
argument_list|,
operator|(
name|DDALOG
argument_list|(
name|LOG_ERR
argument_list|)
literal|"dda%d:(x29) couldn't get mbuf for QBIT message\n"
operator|,
name|ds
operator|->
name|dda_if
operator|.
name|if_unit
name|DDAELOG
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_dat
index|[
name|MLEN
operator|-
literal|1
index|]
operator|=
name|QBIT
expr_stmt|;
comment|/* set Q-bit */
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|len
operator|/
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PAR_INDICATION
condition|)
block|{
comment|/* our pad supports NO parameters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|msg
index|[
name|i
index|]
operator|.
name|ref
operator||
literal|0x80
expr_stmt|;
comment|/* set invalid bit */
operator|*
name|p
operator|++
operator|=
literal|1
expr_stmt|;
comment|/* not implemented */
block|}
block|}
else|else
block|{
comment|/* BREAK_INDIC, SET_PAD to ack break */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|msg
index|[
name|i
index|]
operator|.
name|ref
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|msg
index|[
name|i
index|]
operator|.
name|val
expr_stmt|;
block|}
block|}
name|m
operator|->
name|m_len
operator|=
literal|1
operator|+
literal|2
operator|*
name|len
expr_stmt|;
name|oq
operator|=
operator|&
operator|(
name|dc
operator|->
name|dc_oq
operator|)
expr_stmt|;
comment|/* point to output queue */
if|if
condition|(
name|IF_QFULL
argument_list|(
name|oq
argument_list|)
condition|)
block|{
comment|/* if q full */
name|IF_DROP
argument_list|(
name|oq
argument_list|)
expr_stmt|;
comment|/* drop the data */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ds
operator|->
name|dda_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
comment|/* for netstat display */
block|}
else|else
block|{
name|IF_ENQUEUE
argument_list|(
name|oq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* otherwise queue it */
name|dda_start
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|)
expr_stmt|;
comment|/* and try to output */
block|}
block|}
name|PRIVATE
name|int
name|x29_break_reply_is_required
parameter_list|(
name|mcp
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|mcp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|mcp
operator|++
expr_stmt|;
comment|/* skip over break indication msg */
while|while
condition|(
name|len
operator|>
literal|1
condition|)
block|{
comment|/* while there are parameters left, */
if|if
condition|(
operator|(
operator|*
name|mcp
operator|==
literal|8
operator|)
operator|&&
operator|(
name|mcp
index|[
literal|1
index|]
operator|==
literal|1
operator|)
condition|)
comment|/* paramter 8 set to 1? */
return|return
literal|1
return|;
comment|/* yes */
name|mcp
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/*  * Ultrix 3.0 removed the old ttbreakc() kernel routine when moving to  * a posix compliant driver.  Here it is again, (for our local use only!!!)  *  */
if|#
directive|if
name|ACC_ULTRIX
operator|>=
literal|30
specifier|static
name|int
name|ttbreakc
argument_list|(
name|c
argument_list|,
name|tp
argument_list|)
decl|register
name|c
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
return|return
operator|(
name|c
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VEOL
index|]
operator|||
name|c
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VEOF
index|]
operator|||
name|c
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VEOL2
index|]
operator|||
name|c
operator|==
literal|'\r'
operator|&&
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|CRMOD
operator|)
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Revision History:   09-Jun-1988: Unknown (Brad?) 	Initial implementation. 15-Feb-1989: Paul Traina 	Fixed point bug in send_x29_prm_msg 08-Mar-1989: Steve Johnson 	Fixed bug in xx_flow logic 24-May-1989: Paul Traina 	Upgraded for Ultrix 3.0 28-May-1989: Paul Traina 	Added more driver intelligence to disable pad durring call pending 31-May-1989: Paul Traina 	Added flexible mapping for # of boards per unit 04-Jun-1989: Paul Traina 	Fixed driver to dequeue Q-bit X29 packets from the mbuf chain properly. 19-Jun-1989: Paul Traina 	Fixed previous fix-- will need to go over if-elseif logic more 	carefully to make sure we're doing the right thing.  It should be 	recoded. 	Modernized entire debug code suite, changed xxshow functionality to 	use the uprintf() kernel call to display data on user's terminal for 	the xxshow hack. 12-Jul-1989: Paul Traina 	Changed format of some debug messages.  Removed LOCAL_VOID in 	favor of PRIVATE routine to aid in debugging.  Simplified some 	chunky logic. 18-Jul-1989: Paul Traina 	Flipped search order for finding a free X29W lcn at RING time. 	Moved the dc_key.ttyline field out of the union and made it dc_line. 	This fixed the Dartmouth singleuser bug. 19-Jul-1989: Paul Traina 	Changed the packet decode logic in x29_data to immediately process 	packets with more data pending (i.e. the M-bit) right away, instead 	of queuing them up.  (Note: it still queues up Q-bit packets)  This 	may fix the Dartmouth mbuf problem with blasting uploads. 27-Jul-1989: Paul Traina 	Removed 8-bit strip in x29_dhandle. 01-Aug-1989: Paul Traina 	Added additional two parameters to make_x25_call for userdata/length 	for merge with new pad software. 02-Aug-1989: Paul Traina 	Reinserted 8-bit strip on data received from the net.  (uses 	PARITY_MASK define for easy change). 	Fixed forward declaration of ttbreakc(). 	Improved readability of xxshow output. 	Removed "super" pad code. 	Modified ps_state to be a real state variable. 03-Aug-1989: Paul Traina 	Reversed earlier change to xxselect which didn't pass major #. 	Modified xxshow output to not use %nd which isn't supported in BSD. 28-Aug-1989: Paul Traina 	Changed parameters of make_x25_call -- plug user data field directly. 14-Nov-1989: Paul Traina 	Added support for Ultrix 3.1 which uses HUPCL instead of HUPCLS 	because of that stupid termio interface (sigh). 16-Nov-1989: Paul Traina 	Changed parity mask to input_parity_mask, added output_parity_mask. */
end_comment

end_unit

