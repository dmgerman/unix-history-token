begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)if_dp.c	7.1 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"dp.h"
end_include

begin_if
if|#
directive|if
name|NDP
operator|>
literal|0
end_if

begin_comment
comment|/*  * DPV-11 device driver, X.25 version  *  * Derived from dmc-11 driver:  *  *	Bill Nesheim  *	Cornell University  *  *	Lou Salkind  *	New York University  */
end_comment

begin_comment
comment|/* #define DEBUG	/* for base table dump on fatal error */
end_comment

begin_include
include|#
directive|include
file|"machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_comment
comment|/* must precede tty.h */
end_comment

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/pdma.h"
end_include

begin_include
include|#
directive|include
file|"if_dpreg.h"
end_include

begin_comment
comment|/*  * Driver information for auto-configuration stuff.  */
end_comment

begin_decl_stmt
name|int
name|dpprobe
argument_list|()
decl_stmt|,
name|dpattach
argument_list|()
decl_stmt|,
name|dpinit
argument_list|()
decl_stmt|,
name|dpioctl
argument_list|()
decl_stmt|,
name|dprint
argument_list|()
decl_stmt|,
name|dpxint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dpoutput
argument_list|()
decl_stmt|,
name|dpreset
argument_list|()
decl_stmt|,
name|dptimeout
argument_list|()
decl_stmt|,
name|x25_ifoutput
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|dpinfo
index|[
name|NDP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|dpstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|dpdriver
init|=
block|{
name|dpprobe
block|,
literal|0
block|,
name|dpattach
block|,
literal|0
block|,
name|dpstd
block|,
literal|"dp"
block|,
name|dpinfo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pdma structures for fast interrupts.  */
end_comment

begin_decl_stmt
name|struct
name|pdma
name|dppdma
index|[
literal|2
operator|*
name|NDP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error reporting intervals */
end_comment

begin_define
define|#
directive|define
name|DPI_RPNBFS
value|50
end_define

begin_define
define|#
directive|define
name|DPI_RPDSC
value|1
end_define

begin_define
define|#
directive|define
name|DPI_RPTMO
value|10
end_define

begin_define
define|#
directive|define
name|DPI_RPDCK
value|10
end_define

begin_comment
comment|/*  * DP software status per interface.  *  * Each interface is referenced by a network interface structure,  * dp_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  */
end_comment

begin_struct
struct|struct
name|dp_softc
block|{
name|struct
name|ifnet
name|dp_if
decl_stmt|;
comment|/* network-visible interface */
name|short
name|dp_iused
decl_stmt|;
comment|/* input buffers given to DP */
name|short
name|dp_flags
decl_stmt|;
comment|/* flags */
name|short
name|dp_ostate
decl_stmt|;
comment|/* restarting, etc. */
name|short
name|dp_istate
decl_stmt|;
comment|/* not sure this is necessary */
define|#
directive|define
name|DPS_IDLE
value|0
define|#
directive|define
name|DPS_RESTART
value|1
define|#
directive|define
name|DPS_ACTIVE
value|2
define|#
directive|define
name|DPS_XEM
value|3
comment|/* transmitting CRC, etc. */
comment|/* flags */
define|#
directive|define
name|DPF_RUNNING
value|0x01
comment|/* device initialized */
define|#
directive|define
name|DPF_ONLINE
value|0x02
comment|/* device running (had a RDYO) */
define|#
directive|define
name|DPF_RESTART
value|0x04
comment|/* software restart in progress */
define|#
directive|define
name|DPF_FLUSH
value|0x08
comment|/* had a ROVR, flush ipkt when done */
name|int
name|dp_errors
index|[
literal|4
index|]
decl_stmt|;
comment|/* non-fatal error counters */
define|#
directive|define
name|dp_datck
value|dp_errors[0]
define|#
directive|define
name|dp_timeo
value|dp_errors[1]
define|#
directive|define
name|dp_nobuf
value|dp_errors[2]
define|#
directive|define
name|dp_disc
value|dp_errors[3]
name|char
name|dp_obuf
index|[
name|DP_MTU
operator|+
literal|8
index|]
decl_stmt|;
name|char
name|dp_rbuf
index|[
name|DP_MTU
operator|+
literal|8
index|]
decl_stmt|;
block|}
name|dp_softc
index|[
name|NDP
index|]
struct|;
end_struct

begin_macro
name|dpprobe
argument_list|(
argument|reg
argument_list|,
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
specifier|register
name|struct
name|dpdevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|dpdevice
operator|*
operator|)
name|reg
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|dprint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dpxint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|->
name|dpclr
operator|=
name|DP_CLR
expr_stmt|;
name|addr
operator|->
name|dpclr
operator|=
name|DP_XIE
operator||
name|DP_XE
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|addr
operator|->
name|dpclr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_expr_stmt
name|dpattach
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|dp_softc
modifier|*
name|dp
init|=
operator|&
name|dp_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|pdma
modifier|*
name|pdp
init|=
operator|&
name|dppdma
index|[
name|ui
operator|->
name|ui_unit
operator|*
literal|2
index|]
decl_stmt|;
name|dp
operator|->
name|dp_if
operator|.
name|if_unit
operator|=
name|ui
operator|->
name|ui_unit
expr_stmt|;
name|dp
operator|->
name|dp_if
operator|.
name|if_name
operator|=
literal|"dp"
expr_stmt|;
name|dp
operator|->
name|dp_if
operator|.
name|if_mtu
operator|=
name|DP_MTU
expr_stmt|;
name|dp
operator|->
name|dp_if
operator|.
name|if_init
operator|=
name|dpinit
expr_stmt|;
name|dp
operator|->
name|dp_if
operator|.
name|if_output
operator|=
name|x25_ifoutput
expr_stmt|;
name|dp
operator|->
name|dp_if
operator|.
name|if_start
operator|=
name|dpstart
expr_stmt|;
name|dp
operator|->
name|dp_if
operator|.
name|if_ioctl
operator|=
name|dpioctl
expr_stmt|;
name|dp
operator|->
name|dp_if
operator|.
name|if_reset
operator|=
name|dpreset
expr_stmt|;
name|dp
operator|->
name|dp_if
operator|.
name|if_watchdog
operator|=
name|dptimeout
expr_stmt|;
name|dp
operator|->
name|dp_if
operator|.
name|if_flags
operator|=
name|IFF_POINTOPOINT
expr_stmt|;
name|pdp
operator|->
name|p_addr
operator|=
operator|(
expr|struct
name|dzdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|pdp
operator|->
name|p_arg
operator|=
operator|(
name|int
operator|)
name|dp
expr_stmt|;
name|pdp
operator|->
name|p_fcn
operator|=
name|dpxint
expr_stmt|;
name|pdp
operator|->
name|p_mem
operator|=
name|pdp
operator|->
name|p_end
operator|=
name|dp
operator|->
name|dp_obuf
expr_stmt|;
name|pdp
operator|++
expr_stmt|;
name|pdp
operator|->
name|p_addr
operator|=
operator|(
expr|struct
name|dzdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|pdp
operator|->
name|p_arg
operator|=
operator|(
name|int
operator|)
name|dp
expr_stmt|;
name|pdp
operator|->
name|p_fcn
operator|=
name|dprint
expr_stmt|;
name|pdp
operator|->
name|p_mem
operator|=
name|pdp
operator|->
name|p_end
operator|=
name|dp
operator|->
name|dp_rbuf
expr_stmt|;
name|if_attach
argument_list|(
operator|&
name|dp
operator|->
name|dp_if
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset of interface after UNIBUS reset.  * If interface is on specified UBA, reset its state.  */
end_comment

begin_macro
name|dpreset
argument_list|(
argument|unit
argument_list|,
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|dp_softc
modifier|*
name|dp
init|=
operator|&
name|dp_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|dpdevice
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDP
operator|||
operator|(
name|ui
operator|=
name|dpinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_ubanum
operator|!=
name|uban
condition|)
return|return;
name|printf
argument_list|(
literal|" dp%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_flag
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|dp_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|addr
operator|=
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|addr
operator|->
name|dpclr
operator|=
name|DP_CLR
expr_stmt|;
name|addr
operator|->
name|dpsar
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|dprcsr
operator|=
literal|0
expr_stmt|;
name|dpinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialization of interface.  */
end_comment

begin_macro
name|dpinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dp_softc
modifier|*
name|dp
init|=
operator|&
name|dp_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|dpinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|dpdevice
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|dp
operator|->
name|dp_if
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|s
decl_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|dpdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
comment|/* 	 * Check to see that an address has been set. 	 */
for|for
control|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
break|break;
if|if
condition|(
name|ifa
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|dp
operator|->
name|dp_iused
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|dp_istate
operator|=
name|dp
operator|->
name|dp_ostate
operator|=
name|DPS_IDLE
expr_stmt|;
name|dppdma
index|[
literal|2
operator|*
name|unit
operator|+
literal|1
index|]
operator|.
name|p_end
operator|=
name|dppdma
index|[
literal|2
operator|*
name|unit
operator|+
literal|1
index|]
operator|.
name|p_mem
operator|=
operator|=
name|dp
operator|->
name|dp_rbuf
expr_stmt|;
comment|/* enable receive interrupt; CTS comming up will trigger it also */
name|addr
operator|->
name|dpsar
operator|=
name|DP_CHRM
operator||
literal|0x7E
expr_stmt|;
comment|/* 7E is the flag character */
name|addr
operator|->
name|dpclr
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|dprcsr
operator|=
name|DP_RIE
operator||
name|DP_DTR
operator||
name|DP_RE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start output on interface.  Get another datagram  * to send from the interface queue and map it to  * the interface before starting output.  *  */
end_comment

begin_macro
name|dpstart
argument_list|(
argument|ifp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|,
name|unit
init|=
name|ifp
operator|->
name|if_unit
decl_stmt|;
specifier|register
name|struct
name|dp_softc
modifier|*
name|dp
init|=
operator|&
name|dp_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|dpdevice
modifier|*
name|addr
init|=
name|dpinfo
index|[
name|unit
index|]
operator|.
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|cplim
decl_stmt|;
comment|/* 	 * If already doing output, go away and depend on transmit 	 * complete or error. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|dp
operator|->
name|dp_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator||
name|M_PKTHDR
operator|)
operator|==
literal|0
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|DP_MTU
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|dppdma
index|[
literal|2
operator|*
name|unit
index|]
operator|.
name|p_mem
operator|=
name|cp
operator|=
name|dp
operator|->
name|dp_obuf
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|MFREE
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|dp
operator|->
name|dp_obuf
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dppdma
index|[
literal|2
operator|*
name|unit
index|]
operator|.
name|p_end
operator|=
name|cp
expr_stmt|;
name|addr
operator|->
name|dpclr
operator|=
name|DP_XE
operator||
name|DP_XIE
expr_stmt|;
name|addr
operator|->
name|dptdsr
operator|=
name|DP_XSM
expr_stmt|;
name|dp
operator|->
name|dp_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|dp
operator|->
name|dp_ostate
operator|=
name|DPS_ACTIVE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Receive done or error interrupt  */
end_comment

begin_expr_stmt
name|dprint
argument_list|(
name|unit
argument_list|,
name|pdma
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|pdma
operator|*
name|pdma
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|dpdevice
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dpsoftc
modifier|*
name|dp
init|=
operator|&
name|dpsoftc
index|[
name|unit
index|]
decl_stmt|;
name|unsigned
name|short
name|dprdsr
init|=
name|addr
operator|->
name|dprdsr
decl_stmt|;
if|if
condition|(
name|dprdsr
operator|&
name|DP_ROVR
condition|)
block|{
name|dp
operator|->
name|dp_flags
operator||=
name|DPF_FLUSH
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dprdsr
operator|&
name|DP_RSM
condition|)
block|{
comment|/* Received Start of Message */
name|dp
operator|->
name|dp_ibuf
index|[
literal|0
index|]
operator|=
name|dprdsr
operator|&
name|DP_RBUF
expr_stmt|;
name|pdma
operator|->
name|p_mem
operator|=
name|dp
operator|->
name|dp_ibuf
operator|+
literal|1
expr_stmt|;
name|dpflags
operator|&=
operator|~
name|DPF_FLUSH
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dprdsr
operator|&
name|DP_REM
condition|)
block|{
comment|/* Received End of Message */
if|if
condition|(
name|dprdsr
operator|&
name|DP_REC
operator|||
name|dp
operator|->
name|dp_flags
operator|&
name|DPF_FLUSH
condition|)
block|{
name|dp
operator|->
name|dp_if
operator|.
name|if_errors
operator|++
expr_stmt|;
name|pdma
operator|->
name|p_mem
operator|=
name|dp
operator|->
name|dp_ibuf
expr_stmt|;
name|dp
operator|->
name|dp_flags
operator|&=
operator|~
name|DPF_FLUSH
expr_stmt|;
return|return;
block|}
name|dpinput
argument_list|(
name|dp
argument_list|,
name|pdma
operator|->
name|p_mem
operator|-
name|dp
operator|->
name|dp_ibuf
argument_list|,
name|dp
operator|->
name|dp_ibuf
argument_list|)
expr_stmt|;
return|return;
block|}
name|dp
operator|->
name|dp_flags
operator||=
name|DPF_FLUSH
expr_stmt|;
if|if
condition|(
name|pdma
operator|->
name|p_mem
operator|!=
name|pdma
operator|->
name|p_end
condition|)
name|log
argument_list|(
argument|dp%d: unexplained receiver interrupt\n
literal|"); }  /*  * Transmit complete or error interrupt  */ dpxint(unit, pdma, addr) register struct pdma *pdma; register struct dpdevice *addr; { 	register struct dpsoftc *dp =&dpsoftc[unit];  	if (addr->dptdsr& DP_XERR) { 		log("
argument|if_dp%d: data late\n
literal|", unit); 	restart: 		pdma->p_mem = dp->dp_obuf; 		addr->dptdsr = DP_XSM; 		return; 	} 	switch (dp->dp_ostate) {  	case DPS_ACTIVE: 		if (pdma->p_mem != pdma->p_end) { 			log("
argument|if_dp%d: misc error in dpxint\n
literal|"); 			goto restart; 		} 		addr->dptdsr = DP_XEM; 		dp->dp_ostate = DPS_XEM; 		break;  	case DPS_XEM: 		dp->dp_if.if_flags&= ~IFF_OACTIVE; 		if (dp->dp_if.if_snd.ifq_len) 			dpstart(&dp->dp_if); 		else { 			addr->dpclr = 0; 			dp->dp_ostate = DPS_IDLE; 		} 		break;  	default: 		log("
argument|if_dp%d: impossible state in dpxint\n
literal|"
end_block

unit|); 	} } /*  * Routine to copy from device buffer into mbufs.  *  * Warning: This makes the fairly safe assumption that  * mbufs have even lengths.  */ struct mbuf * dpget(rxbuf, totlen, off, ifp) 	caddr_t rxbuf; 	int totlen, off; 	struct ifnet *ifp; { 	register caddr_t cp; 	register struct mbuf *m; 	struct mbuf *top = 0, **mp =&top; 	int len; 	caddr_t packet_end;  	cp = rxbuf; 	packet_end = cp + totlen; 	if (off) { 		off += 2 * sizeof(u_short); 		totlen -= 2 *sizeof(u_short); 		cp = rxbuf + off; 	}  	MGETHDR(m, M_DONTWAIT, MT_DATA); 	if (m == 0) 		return (0); 	m->m_pkthdr.rcvif = ifp; 	m->m_pkthdr.len = totlen; 	m->m_len = MHLEN;  	while (totlen> 0) { 		if (top) { 			MGET(m, M_DONTWAIT, MT_DATA); 			if (m == 0) { 				m_freem(top); 				return (0); 			} 			m->m_len = MLEN; 		} 		len = min(totlen, (packet_end - cp)); 		if (len>= MINCLSIZE) { 			MCLGET(m, M_DONTWAIT); 			if (m->m_flags& M_EXT) 				m->m_len = len = min(len, MCLBYTES); 			else 				len = m->m_len; 		} else { 			/* 			 * Place initial small packet/header at end of mbuf. 			 */ 			if (len< m->m_len) { 				if (top == 0&& len + max_linkhdr<= m->m_len) 					m->m_data += max_linkhdr; 				m->m_len = len; 			} else 				len = m->m_len; 		} 		bcopy(cp, mtod(m, caddr_t), (u_int)len); 		*mp = m; 		mp =&m->m_next; 		totlen -= len; 		cp += len; 		if (cp == packet_end) 			cp = rxbuf; 	} 	return (top); }  dpinput(dp, len, buffer) register struct dpsoftc *dp; caddr_t buffer; { 	register struct ifnet *ifp =&dp->dp_if; 	register struct ifqueue *inq; 	register struct mbuf *m; 	extern struct ifqueue hdintrq;  	if(len<= 0 || ifp->if_addrlist == 0) 		return;  	m = dpget(buffer, len , 0, ifp); 	if (m == 0) 		return; 	ifp->if_ipackets++; 	 	/* Only AF_CCITT makes sense at this point */ 	inq =&hdintrq;  	if(IF_QFULL(inq)) { 		IF_DROP(inq); 		m_freem(m); 	} else { 		IF_ENQUEUE(inq, m); 		schednetisr(NETISR_HD); 	} }  /*  * Process an ioctl request.  */ dpioctl(ifp, cmd, data) 	register struct ifnet *ifp; 	int cmd; 	caddr_t data; { 	register struct ifaddr *ifa = (struct ifaddr *)data; 	int s = splimp(), error = 0;  	switch (cmd) {  	case SIOCSIFADDR: 		ifp->if_flags |= IFF_UP; 		switch (ifa->ifa_addr->sa_family) { #ifdef CCITT 		case AF_CCITT: 			error = hd_ctlinput (PRC_IFUP, (caddr_t)&ifa->ifa_addr); 			if (error == 0) 				dpinit(ifp->if_unit); 			break; #endif 		case SIOCSIFFLAGS: 			if ((ifp->if_flags& IFF_UP) == 0&& 			    (dp->dp_flags& DPF_RUNNING)) 				dpdown(ifp->if_unit); 			else if (ifp->if_flags& IFF_UP&& 			    (dp->dp_flags& DPF_RUNNING) == 0) 				dpinit(ifp->if_unit); 			break;  		default: 			dpinit(ifp->if_unit); 			break; 		} 		break;  	/* case SIOCSIFFLAGS: ... */  	default: 		error = EINVAL; 	} 	splx(s); 	return (error); } /*  * Reset a device and mark down.  * Flush output queue and drop queue limit.  */ dpdown(unit) 	int unit; { 	register struct dp_softc *dp =&dp_softc[unit]; 	register struct ifxmt *ifxp;  	dp->dp_flags&= ~(DP_RUNNING | DP_ONLINE); 	addr->dpclr = DP_CLR; 	addr->dpclr = 0;  	if_qflush(&dp->dp_if.if_snd); }  /*  * Watchdog timeout to see that transmitted packets don't  * lose interrupts.  The device has to be online (the first  * transmission may block until the other side comes up).  */ dptimeout(unit) 	int unit; { 	register struct dp_softc *dp; 	struct dpdevice *addr;  	dp =&dp_softc[unit]; 	if (dp->dp_flags& DP_ONLINE) { 		addr = (struct dpdevice *)(dpinfo[unit]->ui_addr); 		dpstart(unit); 	} } #endif
end_unit

