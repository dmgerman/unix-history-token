begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	@(#)tmscpboot.c	7.2 (Berkeley) %G%  *  * TK50 tape boot block for distribution tapes  * works on Q-bus tk50 drive on uVaxen  *  * Rick Lindsley  * richl@tektronix.tek.com  *  * reads a program from a tp directory on a tape and executes it  * program must be stripped of the header and is loaded ``bits as is''  * you can return to this loader via ``ret'' as you are called ``calls $0,ent''  */
end_comment

begin_expr_stmt
operator|.
name|set
name|RELOC
operator|,
literal|0x70000
comment|/* tp directory definitions */
operator|.
name|set
name|FILSIZ
operator|,
literal|38
operator|#
name|tp
name|direc
name|offset
end_expr_stmt

begin_for
for|for file size 	.set	BNUM
operator|,
literal|44
operator|#
name|tp
name|dir
name|offset
end_for

begin_for
for|for start block no. 	.set	ENTSIZ
operator|,
literal|64
operator|#
name|size
name|of
literal|1
name|TP
name|dir
name|entry
operator|,
name|bytes
operator|.
name|set
name|PTHSIZ
operator|,
literal|32
operator|#
name|size
name|of
name|TP
name|path
name|name
operator|,
name|bytes
operator|.
name|set
name|BLKSIZ
operator|,
literal|512
operator|#
name|tape
name|block
name|size
operator|,
name|bytes
operator|.
name|set
name|NUMDIR
operator|,
literal|24
operator|#
name|no
operator|.
name|of
name|dir
name|blocks
name|on
name|tape
operator|.
name|set
name|ENTBLK
operator|,
literal|8
operator|#
name|no
operator|.
name|of
name|dir
name|entries
name|per
name|tape
name|block
comment|/* processor registers and bits */
operator|.
name|set
name|RXCS
operator|,
literal|32
operator|.
name|set
name|RXDB
operator|,
literal|33
operator|.
name|set
name|TXCS
operator|,
literal|34
operator|.
name|set
name|TXDB
operator|,
literal|35
operator|.
name|set
name|RXCS_DONE
operator|,
literal|0x80
operator|.
name|set
name|TXCS_RDY
operator|,
literal|0x80
operator|.
name|set
name|TXCS_pr
operator|,
literal|7
comment|/* bit position of TXCS ready bit */
operator|.
name|set
name|RXCS_pd
operator|,
literal|7
comment|/* bit position of RXCS done bit */
comment|/* UBA registers */
operator|.
name|set
name|MAPSTART
operator|,
literal|0x20088000
operator|#
end_for

begin_for
for|for a uVax
operator|,
name|anyway
operator|.
name|set
name|UBAMEM
decl_stmt|,0x1ffc2000	#
name|again
decl_stmt|, for
name|a
name|uVax
operator|.
name|set
name|MRV
decl_stmt|,0x80000000		#
name|map
decl|register
name|valid
name|bit
comment|/* TMSCP UBA registers */
operator|.
name|set
name|TMSCP_CSR
decl_stmt|, 0774500	#
name|CSR
name|of
name|tk50
operator|.
name|set
name|TMSCPip
decl_stmt|,0		#
name|initialization
name|and
name|polling
operator|.
name|set
name|TMSCPsa
decl_stmt|,2		#
name|status
name|and
name|address
comment|/* handy values for tmscp communication area */
operator|.
name|set
name|TMSCP_OWN
decl_stmt|,0x80000000 	.
name|set
name|TMSCP_ERR
decl_stmt|,0x8000 	.
name|set
name|TMSCP_STEP4
decl_stmt|,0x4000 	.
name|set
name|TMSCP_STEP3
decl_stmt|,0x2000 	.
name|set
name|TMSCP_STEP2
decl_stmt|,0x1000 	.
name|set
name|TMSCP_STEP1
decl_stmt|,0x800 	.
name|set
name|TMSCP_IE
decl_stmt|,0x80 	.
name|set
name|TMSCP_GO
decl_stmt|,1
comment|/* handy offsets into tmscp communication area (from tmscpca) */
decl_stmt|.
name|set
name|cmdint
decl_stmt|,4 	.
name|set
name|rspint
decl_stmt|,6 	.
name|set
name|rspdsc
decl_stmt|,8 	.
name|set
name|cmddsc
decl_stmt|,12
comment|/* handy offsets into mscp packets (from %rCMD or %rRSP) */
decl_stmt|.
name|set
name|msglen
decl_stmt|,0 	.
name|set
name|vcid
decl_stmt|,3 	.
name|set
name|unit
decl_stmt|,8 	.
name|set
name|op
decl_stmt|,12 	.
name|set
name|status
decl_stmt|,14 	.
name|set
name|modifier
decl_stmt|,14 	.
name|set
name|bytecnt
decl_stmt|,16 	.
name|set
name|cntflgs
decl_stmt|,18 	.
name|set
name|buffer
decl_stmt|,20 	.
name|set
name|tmkcnt
decl_stmt|,20 	.
name|set
name|lbn
decl_stmt|,32 	.
name|set
name|dscptr
decl_stmt|,40
comment|/* TMSCP commands and modifiers */
decl_stmt|.
name|set
name|M_OP_STCON
decl_stmt|,4 	.
name|set
name|M_OP_ONLIN
decl_stmt|,9 	.
name|set
name|M_OP_READ
decl_stmt|,33 	.
name|set
name|M_OP_REPOS
decl_stmt|,37 	.
name|set
name|M_MD_REWND
decl_stmt|,2 	.
name|set
name|M_MD_IMMED
decl_stmt|,0x80 	.
name|set
name|M_MD_CLSEX
decl_stmt|,0x200 	.
name|set
name|M_ST_MASK
decl_stmt|,0x1f 	.
name|set
name|M_ST_TAPEM
decl_stmt|,14
comment|/* miscellaneous */
decl_stmt|.
name|set
name|IUR
decl_stmt|, 0x37 	.
name|set
name|SID
decl_stmt|, 0x3e 	.
name|set
name|VAX_630
decl_stmt|,8
comment|/* local stack variables */
decl_stmt|.
name|set
name|tmscpca
decl_stmt|,-240-
name|PTHSIZ
decl|-26	# struct
name|tmscpca
argument_list|(
name|see
name|tmscpreg
operator|.
name|h
argument_list|)
decl|.
name|set
name|rsp
decl_stmt|,-240-
name|PTHSIZ
decl|-10	#
name|tmscp
name|response
name|area
operator|.
name|set
name|cmd
decl_stmt|,-120-
name|PTHSIZ
decl|-10	#
name|tmscp
name|command
name|area
operator|.
name|set
name|name
decl_stmt|,-
name|PTHSIZ
decl|-10		#
name|operator
decl|-
name|typed
name|file
name|name
operator|.
name|set
name|dirread
decl_stmt|,-10		#
name|is
name|the
name|tape
name|directory
name|incore
name|already
decl|? 	.
name|set
name|mtapa
decl_stmt|,-8		#
name|cur
name|tape
name|addr
argument_list|(
name|last
name|blk
name|we
name|read
argument_list|)
decl|.
name|set
name|tapa
decl_stmt|,-4			#
name|desired
name|tape
name|addr
argument_list|(
name|inclusive
argument_list|)
comment|/* register usage */
decl|.
name|set
name|rCMD
decl_stmt|,
name|r7
operator|.
name|set
name|rRSP
decl_stmt|,
name|r8
operator|.
name|set
name|rUBADDR
decl_stmt|,
name|r9
operator|.
name|set
name|rMAPREGS
decl_stmt|,
name|r10
operator|.
name|set
name|rCSR
decl_stmt|,
name|r11
comment|/* ===== */
comment|/* initialization */
name|init
range|:
empty|#
if|#
directive|if
name|on
name|a
name|uVax
operator|,
name|we
name|were
name|loaded
name|by
name|VMB
name|from
name|tape
operator|.
name|We
name|also
name|have
empty|# only one unibus, at 0x1fffc2000 (see above). Elstwise, this
empty|# boot program will almost certainly need help.
empty|#
name|mfpr
name|$SID
decl_stmt|,
name|r0
name|cmpzv
name|$24
decl_stmt|,
name|$8
decl_stmt|,
name|r0
decl_stmt|,
name|$VAX_630
name|beql
decl|1f
name|halt
empty|#
empty|# We must have been loaded by VMB, and thus we are at a non-zero
empty|# location.  sp will contain the base address of the area at which
empty|# we were loaded. So we add sp to $end to get the true end-of-program
empty|# address.
empty|#
decl|1
range|:
name|movl
name|sp
decl_stmt|,
name|r6
decl|#
name|r6
decl|-
name|beginning
name|of
name|program
name|movl
name|$RELOC
decl_stmt|,
name|fp
decl|#
name|core
name|loc
name|to
name|which
name|to
name|move
name|this
name|program
name|addl3
name|$
decl|-512
decl_stmt|,
name|fp
decl_stmt|,
name|sp
decl|#
name|set
name|stack
name|pointer
decl_stmt|;
end_for

begin_expr_stmt
name|leave
name|room
end_expr_stmt

begin_for
for|for locals 	addl3	$-512
operator|,
name|fp
operator|,
name|r0
operator|#
name|zero
name|our
name|destination
name|mem
operator|..
name|we
name|start
name|here
name|addl3
name|$end
operator|,
name|fp
operator|,
name|r1
operator|#
name|and
name|end
name|here
name|clr
operator|:
name|clrl
argument_list|(
name|r0
argument_list|)
operator|+
name|cmpl
name|r0
operator|,
name|r1
name|jlss
name|clr
name|movc3
name|$end
operator|,
operator|(
name|r6
operator|)
operator|,
operator|(
name|fp
operator|)
operator|#
name|copy
name|to
name|relocated
name|position
name|addl3
name|$reginit
operator|,
name|$RELOC
operator|,
name|r0
name|jmp
argument_list|(
name|r0
argument_list|)
operator|#
name|and
name|go
name|there
name|reginit
operator|:
comment|/* initialize our registers. Should need to do this only once */
name|addl3
name|$UBAMEM
operator|,
name|$TMSCP_CSR
operator|,
operator|%
name|rCSR
operator|#
name|set
name|up
name|CSR
specifier|register
name|movl
name|$MAPSTART
operator|,
operator|%
name|rMAPREGS
operator|#
name|locate
name|map
name|registers
name|moval
name|tmscpca
argument_list|(
name|fp
argument_list|)
operator|,
operator|%
name|rUBADDR
operator|#
name|set
name|unibus
name|address
end_for

begin_for
for|for comm area 	extzv	$0
operator|,
name|$9
operator|,
operator|%
name|rUBADDR
operator|,
operator|%
name|rUBADDR
operator|#
name|format
operator|:
operator|(
name|MR
operator|#
operator|<<
literal|9
operator|)
operator||
operator|(
operator|&
name|comm
operator|&
literal|0x1ff
operator|)
name|ashl
name|$
operator|-
literal|9
operator|,
name|$RELOC
operator|-
literal|512
operator|,
name|r0
operator|#
name|setting
name|up
name|map
specifier|register
end_for

begin_for
for|for our stack 	bisl3	$MRV
operator|,
name|r0
operator|,
operator|(
operator|%
name|rMAPREGS
operator|)
operator|#
name|mark
name|our
name|stack
name|valid
argument_list|(
argument|MR #
literal|0
argument_list|)
name|moval
name|cmd
argument_list|(
name|fp
argument_list|)
operator|,
operator|%
name|rCMD
operator|#
name|location
name|of
name|cmd
name|mscp
name|packet
name|moval
name|rsp
argument_list|(
name|fp
argument_list|)
operator|,
operator|%
name|rRSP
operator|#
name|location
name|of
name|rsp
name|mscp
name|packet
name|bsbw
name|inittmscp
operator|#
name|init
name|the
name|unit
name|bsbw
name|onlin
operator|#
name|set
name|tape
name|online
name|bsbw
name|rew
operator|#
name|rewind
name|tape
name|start
operator|:
ifdef|#
directive|ifdef
name|DEBUG
name|movzbl
name|$11
operator|,
name|r0
operator|#
name|newline
name|bsbw
name|putc
name|movzbl
name|$13
operator|,
name|r0
operator|#
end_for

begin_return
return|return
name|bsbw
name|putc
endif|#
directive|endif
name|movzbl
name|$
literal|'=,r0			# prompt 	bsbw	putc 	bsbw	getname  	# desired TP filename is in name(fp).  Now read in entire tp directory 	# contents into low core, starting at loc 0. Because tk50'
name|s
name|are
name|slow
operator|,
empty|# and because we are going to go over 512 bytes anyway, and because
empty|# it requires so little effort, we'll keep track of whether the data
empty|# at location 0 is the tape directory.
name|tstw
name|dirread
argument_list|(
name|fp
argument_list|)
operator|#
end_return

begin_if
if|if directory needs to be read in
operator|,
do|do
name|so
name|bneq
literal|1f
name|bsbw
name|readdir
literal|1
operator|:
empty|#
empty|# all of directory is now in locore, @ 0.
empty|# search for filename; return to start if it isn't there.
empty|#
name|clrl
name|r0
operator|#
name|start
name|at
name|location
literal|0
name|nxtdir
operator|:
name|moval
name|name
argument_list|(
name|fp
argument_list|)
operator|,
name|r2
name|movl
name|r0
operator|,
name|r1
literal|1
operator|:
name|cmpb
argument_list|(
name|r1
argument_list|)
operator|,
operator|(
name|r2
operator|)
name|bneq
literal|2f
name|tstb
argument_list|(
argument|r1
argument_list|)
name|beql
name|found
name|incl
name|r1
name|incl
name|r2
name|brb
literal|1b
literal|2
operator|:
name|acbl
name|$NUMDIR
operator|*
name|BLKSIZ
operator|-
literal|1
operator|,
name|$ENTSIZ
operator|,
name|r0
operator|,
name|nxtdir
name|brw
name|start
operator|#
name|entry
name|not
name|in
name|directory
expr_stmt|;
do|start over
empty|# entry IS here; read it in from tape
do|found:	movzwl	BNUM(r0
end_if

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|tapa
argument_list|(
name|fp
argument_list|)
operator|#
name|start
name|block
name|no
operator|.
expr|,
literal|2
name|bytes
name|addl2
name|$2
operator|-
literal|1
operator|,
name|tapa
argument_list|(
name|fp
argument_list|)
operator|#
name|skip
name|over
name|this
name|program
argument_list|(
literal|2
argument|blocks
argument_list|)
empty|# minus 1 because we will read THROUGH
empty|# this block; so we want to stop just
empty|# before it
name|movzwl
name|FILSIZ
argument_list|(
name|r0
argument_list|)
operator|,
name|r4
operator|#
name|low
literal|2
name|bytes
name|file
name|size
name|insv
name|FILSIZ
operator|-
literal|1
operator|(
name|r0
operator|)
operator|,
name|$16
operator|,
name|$8
operator|,
name|r4
operator|#
name|file
name|size
operator|,
name|high
name|byte
name|cmpl
name|r4
operator|,
name|$RELOC
operator|-
literal|512
operator|#
name|check
end_expr_stmt

begin_if
if|if file fits below stack 	bgeq	start 			# file too large
empty|# Now advance to proper place on tape. tapa has our
empty|# desired address
if|clrw	dirread
condition|(
name|fp
condition|)
operator|#
name|we
name|are
name|about
name|to
name|obliterate
name|our
name|incore
name|copy
empty|# of the directory
literal|2
operator|:
name|clrl
name|r3
operator|#
name|rrec
name|expects
name|r3
name|to
name|point
name|to
name|a
name|buffer
operator|.
expr|0
name|will
end_if

begin_do
do|do
operator|...
name|bsbw
name|rrec
name|cmpl
name|mtapa
argument_list|(
name|fp
argument_list|)
operator|,
name|tapa
argument_list|(
argument|fp
argument_list|)
name|blss
literal|2b
empty|# tape now positioned correctly. Read in program. Number of bytes
empty|# to read is in r4. We must round up to an even BLKSIZ boundary.
empty|# Clear the area we are putting it at; unix expects zeroes in its
empty|# data and bss section.
name|addl2
name|$BLKSIZ
operator|-
literal|1
operator|,
name|r4
operator|#
name|round
name|up
name|bicl2
name|$BLKSIZ
operator|-
literal|1
operator|,
name|r4
operator|#
name|mask
name|out
name|movl
name|r4
operator|,
name|r5
operator|#
name|use
name|r5
expr_stmt|;
do|need to save r4 for later 1:	clrl	(r5
end_do

begin_decl_stmt
unit|)
name|sobgtr
name|r5
decl_stmt|,1b
empty|# now read in file.
name|clrl
name|r3
decl|#
name|read
name|into
name|page
decl|0
argument_list|(
name|incremented
name|by
name|rrec
argument_list|)
name|ashl
name|$
decl|-9
decl_stmt|,
name|r4
decl_stmt|,
name|r5
decl|#
name|r5
name|now
name|holds
decl|#
name|blks
name|to
name|read
name|addl2
name|r5
decl_stmt|,
name|tapa
argument_list|(
name|fp
argument_list|)
decl|#
name|compute
name|desired
name|tape
name|blk
decl|# 1
range|:
name|bsbw
name|rrec
name|cmpl
name|mtapa
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|tapa
argument_list|(
name|fp
argument_list|)
decl|#
name|got
name|it
name|yet
decl|?
name|blss
decl|1b
empty|# begin execution. Call as a function.
name|clrl
name|r5
name|calls
name|$0
decl_stmt|,
argument_list|(
name|r5
argument_list|)
empty|# now, since the called function has reset the tape drive for
empty|# us (!) we must reinit it again ourselves.
name|ashl
name|$
decl|-9
decl_stmt|,
name|$RELOC
decl|-512
decl_stmt|,
name|r0
decl|#
name|set
name|up
name|map
decl|register for
name|our
name|stack
name|bisl3
name|$MRV
decl_stmt|,
name|r0
decl_stmt|,
argument_list|(
operator|%
name|rMAPREGS
argument_list|)
decl_stmt|#
name|mark
name|our
name|stack
name|valid
argument_list|(
name|MR
operator|#
literal|0
argument_list|)
name|bsbw
name|inittmscp
decl|#
name|re
decl|-
name|init
name|drive
name|bsbw
name|onlin
decl|#
name|re
decl|-
name|online
name|it
name|brw
name|start
empty|# getname will set name(fp) and leave len(name(fp)) in r6
name|getname
range|:
name|moval
name|name
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|r1
decl|#
name|mov
name|to
decl|register for
name|ease
name|of
name|access
name|nxtc
range|:
name|bsbw
name|getc
name|cmpb
name|r0
decl_stmt|,
name|$012
decl|#
name|end
name|of
name|line
decl|?
name|beql
name|nullc
name|movb
name|r0
decl_stmt|,
argument_list|(
name|r1
argument_list|)
decl_stmt|+
name|brb
name|nxtc
name|nullc
range|:
name|moval
name|name
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|r0
name|subl3
name|r0
decl_stmt|,
name|r1
decl_stmt|,
name|r6
decl|#
name|length
name|of
name|path
name|name
name|jeql
name|start
decl|#
name|just
name|hit
decl|return
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|nothing
name|useful
name|here
name|clrb
argument_list|(
name|r1
argument_list|)
decl|+			#
name|add
name|null
name|at
name|end
name|incl
name|r6
decl|#
name|add
name|null
name|to
name|length
name|rsb
name|getc
range|:
name|mfpr
name|$RXCS
decl_stmt|,
name|r0
name|bbc
name|$RXCS_pd
decl_stmt|,
name|r0
decl_stmt|,
name|getc
comment|/* receiver ready ? */
name|mfpr
name|$RXDB
decl_stmt|,
name|r0
name|extzv
name|$0
decl_stmt|,
name|$7
decl_stmt|,
name|r0
decl_stmt|,
name|r0
name|cmpb
name|r0
decl_stmt|,
name|$015
name|bneq
name|putc
name|bsbw
name|putc
name|movb
name|$0
decl_stmt|,
name|r0
name|bsbw
name|putc
name|movb
name|$012
decl_stmt|,
name|r0
name|putc
range|:
name|mfpr
name|$TXCS
decl_stmt|,
name|r2
name|bbc
name|$TXCS_pr
decl_stmt|,
name|r2
decl_stmt|,
name|putc
comment|/* transmitter ready ? */
name|extzv
name|$0
decl_stmt|,
name|$7
decl_stmt|,
name|r0
decl_stmt|,
name|r0
name|mtpr
name|r0
decl_stmt|,
name|$TXDB
name|rsb
name|inittmscp
range|:
name|movw
name|$0
decl_stmt|,
name|TMSCPip
argument_list|(
operator|%
name|rCSR
argument_list|)
decl|#
name|start
name|step
decl|1 1
range|:
name|bitw
name|$TMSCP_STEP1
decl_stmt|,
name|TMSCPsa
argument_list|(
operator|%
name|rCSR
argument_list|)
name|beql
decl|1b
ifdef|#
directive|ifdef
name|DEBUG
name|movzbl
name|$
decl|'1,r0 	bsbw	putc #endif init2:	movw	$TMSCP_ERR,TMSCPsa(%rCSR)	# start step 2 2:	bitw	$TMSCP_STEP2,TMSCPsa(%rCSR) 	beql	2b #ifdef DEBUG 	movzbl	$'2
decl_stmt|,
name|r0
name|bsbw
name|putc
endif|#
directive|endif
name|init3
range|:
name|addl3
name|$8
decl_stmt|,%
name|rUBADDR
decl_stmt|,
name|r0
decl|#
name|start
name|step
decl|3
name|cvtlw
name|r0
decl_stmt|,
name|TMSCPsa
argument_list|(
operator|%
name|rCSR
argument_list|)
decl|3
range|:
name|bitw
name|$TMSCP_STEP3
decl_stmt|,
name|TMSCPsa
argument_list|(
operator|%
name|rCSR
argument_list|)
name|beql
decl|3b
ifdef|#
directive|ifdef
name|DEBUG
name|movzbl
name|$
decl|'3,r0 	bsbw	putc #endif init4:	addl3	$8,%rUBADDR,r0			# start step 4 	ashl	$-16,r0,r0 	cvtlw	r0,TMSCPsa(%rCSR) 4:	bitw	$TMSCP_STEP4,TMSCPsa(%rCSR) 	beql	4b #ifdef DEBUG 	movzbl	$'4
decl_stmt|,
name|r0
name|bsbw
name|putc
endif|#
directive|endif
name|setchar
range|:
name|movw
name|$TMSCP_GO
decl_stmt|,
name|TMSCPsa
argument_list|(
operator|%
name|rCSR
argument_list|)
name|moval
decl|140
argument_list|(
operator|%
name|rUBADDR
argument_list|)
decl_stmt|,
name|tmscpca
decl|+
name|cmddsc
argument_list|(
name|fp
argument_list|)
name|moval
name|tmscpca
decl|+
name|cmddsc
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|dscptr
argument_list|(
operator|%
name|rCMD
argument_list|)
name|movb
name|$1
decl_stmt|,
name|vcid
argument_list|(
operator|%
name|rCMD
argument_list|)
name|moval
decl|20
argument_list|(
operator|%
name|rUBADDR
argument_list|)
decl_stmt|,
name|tmscpca
decl|+
name|rspdsc
argument_list|(
name|fp
argument_list|)
name|moval
name|tmscpca
decl|+
name|rspdsc
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|dscptr
argument_list|(
operator|%
name|rRSP
argument_list|)
name|clrw
name|cntflgs
argument_list|(
operator|%
name|rCMD
argument_list|)
name|movb
name|$M_OP_STCON
decl_stmt|,
name|op
argument_list|(
operator|%
name|rCMD
argument_list|)
name|clrw
name|modifier
argument_list|(
operator|%
name|rCMD
argument_list|)
name|clrl
name|buffer
argument_list|(
operator|%
name|rCMD
argument_list|)
name|clrl
name|bytecnt
argument_list|(
operator|%
name|rCMD
argument_list|)
name|bsbw
name|tmscpcmd
ifdef|#
directive|ifdef
name|DEBUG
name|movzbl
name|$
decl|'S,r0 	bsbw	putc #endif 	rsb  tmscpcmd: 	movw	$116,msglen(%rCMD)		# 116 -- size of an mscp packet 	bisl2	$TMSCP_OWN,tmscpca+cmddsc(fp) 	movw	$116,msglen(%rRSP) 	bisl2	$TMSCP_OWN,tmscpca+rspdsc(fp) 	movw	TMSCPip(%rCSR),r0		# start polling wait:	cvtwl	TMSCPsa(%rCSR),r0 	bitl	$TMSCP_ERR,r0 	beql	1f 	movw	modifier(%rRSP),r1	# so we can read status easily 	halt				# some error or other 1:	tstl	tmscpca+4(fp) 	beql	2f 	clrw	tmscpca+4(fp) 2:	bitl	$TMSCP_OWN,tmscpca+rspdsc(fp) 	bneq	wait  	# cmd done  	clrw	tmscpca+rspint(fp) 	extzv	$0,$5,status(%rRSP),r0 	tstl	r0 	beql	ok			# no errors 	cmpl	$M_ST_TAPEM, r0 	beql	ok			# not an error, just a tape mark 	halt				# some unknown error ok:	rsb  rew:	movb	$M_OP_REPOS,op(%rCMD) 	movw	$M_MD_REWND|M_MD_IMMED,modifier(%rCMD) 	clrl	buffer(%rCMD) 	clrl	bytecnt(%rCMD) 	bsbw	tmscpcmd #ifdef DEBUG 	movzbl	$'
name|r
decl_stmt|,
name|r0
decl|#
name|to
name|indicate
name|r
decl_stmt|)ewind 	bsbw	putc
endif|#
directive|endif
decl_stmt|movl	$-1
operator|,
decl_stmt|mtapa(fp
end_decl_stmt

begin_expr_stmt
unit|)
operator|#
name|no
name|blocks
name|read
name|yet
name|rsb
name|onlin
operator|:
name|movb
name|$M_OP_ONLIN
operator|,
name|op
argument_list|(
argument|%rCMD
argument_list|)
name|clrw
name|modifier
argument_list|(
argument|%rCMD
argument_list|)
name|clrl
name|buffer
argument_list|(
argument|%rCMD
argument_list|)
name|clrl
name|bytecnt
argument_list|(
argument|%rCMD
argument_list|)
name|bsbw
name|tmscpcmd
ifdef|#
directive|ifdef
name|DEBUG
name|movzbl
name|$
literal|'O,r0			# to indicate O)nline 	bsbw	putc #endif 	rsb  	# Read the tp directory. Number of blocks to read is in tapa(fp), 	# and will be read into memory starting at location 0. readdir:bsbw	rew			# beginning of tape 	addl3	$2,$NUMDIR,tapa(fp)	# blocks to read (skip this 1k program) 	clrl	r3			# using mem starting at 0 as free space 	bsbw	rrec; bsbw rrec		# read and discard first two blocks -- 					# those are this program 	bsbw	rrec			# read and discard first tp block 	clrl	r3			# reset starting place 	incw	dirread(fp)		# show that directory is incore 1:	bsbw	rrec 	cmpl	mtapa(fp),tapa(fp)	# done yet? 	blss	1b 	rsb  	# read 1 block from mag tape into page indicated by r3, which will 	# automatically be incremented here. mtapa is also advanced.  rrec:	bisl3	$MRV,r3,4(%rMAPREGS)	# using map register #1 	movl	$BLKSIZ,bytecnt(%rCMD)	# how much to read 	ashl	$9,$1,buffer(%rCMD)	# indicating mr #1. We just happen to 					# be on a page boundary, so filling in 					# the low 9 bits is not necessary. 	movb	$M_OP_READ,op(%rCMD) 	clrw	modifier(%rCMD) 	bsbw	tmscpcmd #ifdef DEBUG 	movzbl	$'
name|R
operator|,
name|r0
operator|#
name|to
name|indicate
name|R
end_expr_stmt

begin_decl_stmt
unit|)
name|ead
name|a
name|record
name|bsbw
name|putc
endif|#
directive|endif
name|incl
name|mtapa
argument_list|(
name|fp
argument_list|)
name|incl
name|r3
name|rsb
name|end
range|:
end_decl_stmt

end_unit

