begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)mscp.c	7.3 (Berkeley) 7/9/88  */
end_comment

begin_comment
comment|/*  * MSCP generic driver routines  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"dkstat.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"disklabel.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_include
include|#
directive|include
file|"mscp.h"
end_include

begin_include
include|#
directive|include
file|"mscpvar.h"
end_include

begin_define
define|#
directive|define
name|PCMD
value|PSWP
end_define

begin_comment
comment|/* priority for command packet waits */
end_comment

begin_comment
comment|/*  * During transfers, mapping info is saved in the buffer's b_resid.  */
end_comment

begin_define
define|#
directive|define
name|b_info
value|b_resid
end_define

begin_comment
comment|/*  * Get a command packet.  Second argument is true iff we are  * to wait if necessary.  Return NULL if none are available and  * we cannot wait.  */
end_comment

begin_function
name|struct
name|mscp
modifier|*
name|mscp_getcp
parameter_list|(
name|mi
parameter_list|,
name|canwait
parameter_list|)
specifier|register
name|struct
name|mscp_info
modifier|*
name|mi
decl_stmt|;
name|int
name|canwait
decl_stmt|;
block|{
define|#
directive|define
name|mri
value|(&mi->mi_cmd)
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|s
init|=
name|spl5
argument_list|()
decl_stmt|;
name|again
label|:
comment|/* 	 * Ensure that we have some command credits, and 	 * that the next command packet is free. 	 */
if|if
condition|(
name|mi
operator|->
name|mi_credits
operator|<=
name|MSCP_MINCREDITS
condition|)
block|{
if|if
condition|(
operator|!
name|canwait
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mi
operator|->
name|mi_wantcredits
operator|=
literal|1
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|mi
operator|->
name|mi_wantcredits
argument_list|,
name|PCMD
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|i
operator|=
name|mri
operator|->
name|mri_next
expr_stmt|;
if|if
condition|(
name|mri
operator|->
name|mri_desc
index|[
name|i
index|]
operator|&
name|MSCP_OWN
condition|)
block|{
if|if
condition|(
operator|!
name|canwait
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mi
operator|->
name|mi_wantcmd
operator|=
literal|1
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|mi
operator|->
name|mi_wantcmd
argument_list|,
name|PCMD
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|mi
operator|->
name|mi_credits
operator|--
expr_stmt|;
name|mri
operator|->
name|mri_desc
index|[
name|i
index|]
operator|&=
operator|~
name|MSCP_INT
expr_stmt|;
name|mri
operator|->
name|mri_next
operator|=
operator|(
name|mri
operator|->
name|mri_next
operator|+
literal|1
operator|)
operator|%
name|mri
operator|->
name|mri_size
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mp
operator|=
operator|&
name|mri
operator|->
name|mri_ring
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Initialise some often-zero fields. 	 * ARE THE LAST TWO NECESSARY IN GENERAL?  IT SURE WOULD BE 	 * NICE IF DEC SOLD DOCUMENTATION FOR THEIR OWN CONTROLLERS. 	 */
name|mp
operator|->
name|mscp_msglen
operator|=
name|MSCP_MSGLEN
expr_stmt|;
name|mp
operator|->
name|mscp_flags
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_modifier
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_bytecount
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_buffer
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_mapbase
operator|=
literal|0
expr_stmt|;
comment|/*???*/
name|mp
operator|->
name|mscp_sccc
operator|.
name|sccc_errlgfl
operator|=
literal|0
expr_stmt|;
comment|/*???*/
name|mp
operator|->
name|mscp_sccc
operator|.
name|sccc_copyspd
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|mp
operator|)
return|;
undef|#
directive|undef
name|mri
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AVOID_EMULEX_BUG
end_ifdef

begin_decl_stmt
name|int
name|mscp_aeb_xor
init|=
literal|0x8000bb80
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Do a device go.  The driver calls this once it has allocated  * resources for the transfer.  Save the resource information in  * bp->b_ubinfo, and finish the MSCP packet.  *  * N.B.: If we were blocked for some time, the drive could have gone  * off line and might still be that way.  We should probably handle  * such a case by changing this command into an on line request and  * not dequeuing the transfer after all.  */
end_comment

begin_expr_stmt
name|mscp_go
argument_list|(
name|mi
argument_list|,
name|mp
argument_list|,
name|info
argument_list|)
specifier|register
expr|struct
name|mscp_info
operator|*
name|mi
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|info
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
comment|/* 	 * Now is also the time to move the transfer off the 	 * controller and drive queues, and shuffle the drive 	 * queue on the controller queue.  The idea is to try 	 * to keep as many drives busy as possible---to deal 	 * the controller's credits out to the drives in a `fair 	 * share' arrangement.  (To do this fully would be more 	 * trouble than it is worth, though.) 	 */
name|dp
operator|=
name|mi
operator|->
name|mi_tab
operator|->
name|b_actf
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
comment|/* transfer off drive queue */
name|mi
operator|->
name|mi_tab
operator|->
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
comment|/* drive off ctlr queue */
name|APPEND
argument_list|(
name|dp
argument_list|,
name|mi
operator|->
name|mi_tab
argument_list|,
name|b_forw
argument_list|)
expr_stmt|;
comment|/* then back again */
comment|/* 	 * Move the buffer to the I/O wait queue. 	 */
name|bp
operator|->
name|av_back
operator|=
name|mi
operator|->
name|mi_wtab
operator|.
name|av_back
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
operator|&
name|mi
operator|->
name|mi_wtab
expr_stmt|;
name|mi
operator|->
name|mi_wtab
operator|.
name|av_back
operator|->
name|av_forw
operator|=
name|bp
expr_stmt|;
name|mi
operator|->
name|mi_wtab
operator|.
name|av_back
operator|=
name|bp
expr_stmt|;
comment|/* 	 * Save the mapping info, finish the command packet, and give 	 * it to the device.  The device's dgo routine should then 	 * initiate polling. 	 */
name|bp
operator|->
name|b_info
operator|=
name|info
expr_stmt|;
ifdef|#
directive|ifdef
name|AVOID_EMULEX_BUG
comment|/* 	 * The Emulex SC41/MS will occasionally zero the lower half word 	 * of the command reference number.  The upper half word remains 	 * intact.  To keep running, we convert the buffer address into 	 * a small but nonzero integer that is unique over all pending 	 * transfers, and store that value in the upper half word.  To 	 * catch occurrances of the bug (so that we can gripe to Emulex), 	 * we also put a nonzero value in the lower word. 	 */
block|{
specifier|register
name|u_int
name|i
init|=
name|mi
operator|->
name|mi_nextbp
decl_stmt|;
do|do
block|{
comment|/* find a free value */
if|if
condition|(
name|mi
operator|->
name|mi_bp
index|[
name|i
index|]
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|AEB_MAX_BP
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|mi
operator|->
name|mi_nextbp
condition|)
do|;
name|panic
argument_list|(
literal|"mscp_go: AEB_MAX_BP too small"
argument_list|)
expr_stmt|;
name|found
label|:
name|mi
operator|->
name|mi_bp
index|[
name|i
operator|++
index|]
operator|=
name|bp
expr_stmt|;
name|mi
operator|->
name|mi_nextbp
operator|=
name|i
operator|%
name|AEB_MAX_BP
expr_stmt|;
name|mp
operator|->
name|mscp_cmdref
operator|=
operator|(
name|i
operator|<<
literal|16
operator|)
operator|^
name|mscp_aeb_xor
expr_stmt|;
block|}
else|#
directive|else
name|mp
operator|->
name|mscp_cmdref
operator|=
operator|(
name|long
operator|)
name|bp
expr_stmt|;
endif|#
directive|endif
operator|*
name|mp
operator|->
name|mscp_addr
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Handle a response ring transition.  */
end_comment

begin_expr_stmt
name|mscp_dorsp
argument_list|(
name|mi
argument_list|)
specifier|register
expr|struct
name|mscp_info
operator|*
name|mi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|nextrsp
decl_stmt|;
name|struct
name|mscp_driver
modifier|*
name|md
init|=
name|mi
operator|->
name|mi_md
decl_stmt|;
name|char
modifier|*
name|ctlrname
decl_stmt|,
modifier|*
name|drivename
decl_stmt|;
name|int
name|st
decl_stmt|,
name|error
decl_stmt|,
name|info
decl_stmt|;
name|ctlrname
operator|=
name|md
operator|->
name|md_mname
expr_stmt|;
name|drivename
operator|=
name|md
operator|->
name|md_dname
expr_stmt|;
name|nextrsp
operator|=
name|mi
operator|->
name|mi_rsp
operator|.
name|mri_next
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|mi
operator|->
name|mi_rsp
operator|.
name|mri_desc
index|[
name|nextrsp
index|]
operator|&
name|MSCP_OWN
condition|)
block|{
comment|/* 		 * No more responses.  Remember the next expected 		 * response index.  Check to see if we have some 		 * credits back, and wake up sleepers if so. 		 */
name|mi
operator|->
name|mi_rsp
operator|.
name|mri_next
operator|=
name|nextrsp
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|mi_wantcredits
operator|&&
name|mi
operator|->
name|mi_credits
operator|>
name|MSCP_MINCREDITS
condition|)
block|{
name|mi
operator|->
name|mi_wantcredits
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|mi
operator|->
name|mi_wantcredits
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Found a response.  Update credit information.  If there is 	 * nothing else to do, jump to `done' to get the next response. 	 */
name|mp
operator|=
operator|&
name|mi
operator|->
name|mi_rsp
operator|.
name|mri_ring
index|[
name|nextrsp
index|]
expr_stmt|;
name|mi
operator|->
name|mi_credits
operator|+=
name|MSCP_CREDITS
argument_list|(
name|mp
operator|->
name|mscp_msgtc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|MSCP_MSGTYPE
argument_list|(
name|mp
operator|->
name|mscp_msgtc
argument_list|)
condition|)
block|{
case|case
name|MSCPT_SEQ
case|:
break|break;
case|case
name|MSCPT_DATAGRAM
case|:
call|(
modifier|*
name|md
operator|->
name|md_dgram
call|)
argument_list|(
name|mi
argument_list|,
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|MSCPT_CREDITS
case|:
goto|goto
name|done
goto|;
case|case
name|MSCPT_MAINTENANCE
case|:
default|default:
name|printf
argument_list|(
literal|"%s%d: unit %d: unknown message type 0x%x ignored\n"
argument_list|,
name|ctlrname
argument_list|,
name|mi
operator|->
name|mi_ctlr
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|MSCP_MSGTYPE
argument_list|(
name|mp
operator|->
name|mscp_msgtc
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Controllers are allowed to interrupt as any drive, so we 	 * must check the command before checking for a drive. 	 */
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
operator|==
operator|(
name|M_OP_SETCTLRC
operator||
name|M_OP_END
operator|)
condition|)
block|{
call|(
modifier|*
name|md
operator|->
name|md_ctlrdone
call|)
argument_list|(
name|mi
argument_list|,
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Find the drive info.  If there is none, and this is an 	 * available attention response, try configuring a new drive. 	 */
if|if
condition|(
name|mp
operator|->
name|mscp_unit
operator|>
name|md
operator|->
name|md_ndpc
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: unit %d out of range\n"
argument_list|,
name|ctlrname
argument_list|,
name|mi
operator|->
name|mi_ctlr
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|ui
operator|=
name|mi
operator|->
name|mi_ip
index|[
name|mp
operator|->
name|mscp_unit
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|md
operator|->
name|md_unconf
call|)
argument_list|(
name|mi
argument_list|,
name|mp
argument_list|)
operator|!=
name|MSCP_DONE
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: unit %d not configured, "
argument_list|,
name|ctlrname
argument_list|,
name|mi
operator|->
name|mi_ctlr
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
operator|==
name|M_OP_AVAILATTN
condition|)
name|printf
argument_list|(
literal|"available attn"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"stray response op 0x%x status 0x%x"
argument_list|,
name|mp
operator|->
name|mscp_opcode
argument_list|,
name|mp
operator|->
name|mscp_status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ignored\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Handle individual responses. 	 */
name|st
operator|=
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mp
operator|->
name|mscp_opcode
condition|)
block|{
case|case
name|M_OP_END
case|:
comment|/* 		 * The controller presents a bogus END packet when 		 * a read/write command is given with an illegal 		 * block number.  This is contrary to the MSCP 		 * specification (ENDs are to be given only for 		 * invalid commands), but that is the way of it. 		 */
if|if
condition|(
name|st
operator|==
name|M_ST_INVALCMD
operator|&&
name|mp
operator|->
name|mscp_cmdref
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: bad lbn (%d)?\n"
argument_list|,
name|drivename
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_lbn
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|rwend
goto|;
block|}
goto|goto
name|unknown
goto|;
case|case
name|M_OP_ONLINE
operator||
name|M_OP_END
case|:
comment|/* 		 * Finished an ON LINE request.  Call the driver to 		 * find out whether it succeeded.  If so, mark it on 		 * line. 		 */
if|if
condition|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_ONLINE
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: duplicate ONLINE ignored\n"
argument_list|,
name|drivename
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
call|(
modifier|*
name|md
operator|->
name|md_online
call|)
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|)
operator|==
name|MSCP_DONE
condition|)
name|ui
operator|->
name|ui_flags
operator||=
name|UNIT_ONLINE
expr_stmt|;
break|break;
case|case
name|M_OP_GETUNITST
operator||
name|M_OP_END
case|:
comment|/* 		 * Got unit status.  Call the driver to find out 		 * whether it succeeded, and if so, mark it. 		 */
if|if
condition|(
call|(
modifier|*
name|md
operator|->
name|md_gotstatus
call|)
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|)
operator|==
name|MSCP_DONE
condition|)
name|ui
operator|->
name|ui_flags
operator||=
name|UNIT_HAVESTATUS
expr_stmt|;
break|break;
case|case
name|M_OP_AVAILATTN
case|:
comment|/* 		 * The drive went offline and we did not notice. 		 * Mark it off line now, to force an on line request 		 * next, so we can make sure it is still the same 		 * drive. 		 * 		 * IF THE UDA DRIVER HAS A COMMAND AWAITING UNIBUS 		 * RESOURCES, THAT COMMAND MAY GO OUT BEFORE THE ON 		 * LINE.  IS IT WORTH FIXING?? 		 */
name|ui
operator|->
name|ui_flags
operator|&=
operator|~
operator|(
name|UNIT_ONLINE
operator||
name|UNIT_HAVESTATUS
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
call|(
modifier|*
name|md
operator|->
name|md_offline
call|)
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|M_OP_READ
operator||
name|M_OP_END
case|:
case|case
name|M_OP_WRITE
operator||
name|M_OP_END
case|:
comment|/* 		 * A transfer finished.  Get the buffer, and release its 		 * map registers via ubadone().  If the command finished 		 * with an off line or available status, the drive went 		 * off line (the idiot controller does not tell us until 		 * it comes back *on* line, or until we try to use it). 		 */
if|if
condition|(
name|mp
operator|->
name|mscp_cmdref
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No buffer means there is a bug somewhere! 			 */
name|printf
argument_list|(
literal|"%s%d: io done, but no buffer?\n"
argument_list|,
name|drivename
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
name|mscp_hexdump
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
name|rwend
label|:
ifdef|#
directive|ifdef
name|AVOID_EMULEX_BUG
block|{
specifier|register
name|u_short
modifier|*
name|p
init|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|mp
operator|->
name|mscp_cmdref
decl_stmt|;
comment|/* 			 * Note any errors on the part of the controller. 			 * The lower word should be zero after exclusive 			 * or'ing with mscp_aeb_xor, and the upper should 			 * then be in the range [1..AEB_MAX_BP]. 			 */
name|mp
operator|->
name|mscp_cmdref
operator|^=
name|mscp_aeb_xor
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|>=
name|AEB_MAX_BP
condition|)
name|panic
argument_list|(
literal|"unrecoverable Emulex screwup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|mi
operator|->
name|mi_ok
operator|++
expr_stmt|;
else|else
block|{
comment|/* 				 * Calculate the expected response, 				 * assuming p[1] is correct.  The 				 * actual response is then the expected 				 * response xor p[0]. 				 */
name|int
name|sb
init|=
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
operator|^
name|mscp_aeb_xor
decl_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"\ Emulex SC41/MS screwup: %s%d, got %d correct, then changed 0x%x to 0x%x\n"
argument_list|,
name|ctlrname
argument_list|,
name|mi
operator|->
name|mi_ctlr
argument_list|,
name|mi
operator|->
name|mi_ok
argument_list|,
name|sb
argument_list|,
name|sb
operator|^
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_ok
operator|=
literal|0
expr_stmt|;
block|}
comment|/* convert index back to buffer, and mark free */
name|bp
operator|=
name|mi
operator|->
name|mi_bp
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|mi
operator|->
name|mi_bp
index|[
name|p
index|[
literal|1
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|bp
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|mp
operator|->
name|mscp_cmdref
expr_stmt|;
ifdef|#
directive|ifdef
name|MSCP_PARANOIA
block|{
specifier|register
name|struct
name|buf
modifier|*
name|q
init|=
name|mi
operator|->
name|mi_wtab
operator|.
name|av_forw
decl_stmt|;
comment|/* 			 * Ensure that this response corresponds to 			 * some outstanding request.  If not, ignore 			 * it entirely.  This will likely cause a 			 * Unibus reset soon, after which the controller 			 * just might behave. 			 */
while|while
condition|(
name|q
operator|!=
name|bp
operator|&&
name|q
operator|!=
operator|&
name|mi
operator|->
name|mi_wtab
condition|)
name|q
operator|=
name|q
operator|->
name|av_forw
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|bp
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: bad response packet ignored\n"
argument_list|,
name|ctlrname
argument_list|,
name|mi
operator|->
name|mi_ctlr
argument_list|)
expr_stmt|;
name|mscp_hexdump
argument_list|(
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
endif|#
directive|endif
endif|MSCP_PARANOIA
endif|#
directive|endif
endif|AVOID_EMULEX_BUG
comment|/* 		 * Mark any error-due-to-bad-LBN (via `goto rwend'). 		 * WHAT STATUS WILL THESE HAVE?  IT SURE WOULD BE NICE 		 * IF DEC SOLD DOCUMENTATION FOR THEIR OWN CONTROLLERS. 		 */
if|if
condition|(
name|error
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|==
name|M_ST_OFFLINE
operator|||
name|st
operator|==
name|M_ST_AVAILABLE
condition|)
block|{
name|ui
operator|->
name|ui_flags
operator|&=
operator|~
operator|(
name|UNIT_ONLINE
operator||
name|UNIT_HAVESTATUS
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
call|(
modifier|*
name|md
operator|->
name|md_offline
call|)
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		 * Unlink the transfer from the wait queue mi_wtab. 		 * If there are no more transfers on the drive queue 		 * for this drive, and it is a profiled disk, turn 		 * off its busy bit. 		 */
name|bp
operator|->
name|av_back
operator|->
name|av_forw
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|->
name|av_back
operator|=
name|bp
operator|->
name|av_back
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|ui_dk
operator|>=
literal|0
operator|&&
name|md
operator|->
name|md_utab
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|b_forw
operator|==
name|NULL
condition|)
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ui
operator|->
name|ui_dk
operator|)
expr_stmt|;
comment|/* 		 * If the transfer has something to do with bad 		 * block forwarding, let the driver handle the 		 * rest. 		 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BAD
operator|)
operator|!=
literal|0
operator|&&
name|md
operator|->
name|md_bb
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|md
operator|->
name|md_bb
call|)
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * If the transfer failed, give the driver a crack 		 * at fixing things up. 		 */
if|if
condition|(
name|st
operator|!=
name|M_ST_SUCCESS
condition|)
block|{
switch|switch
condition|(
call|(
modifier|*
name|md
operator|->
name|md_ioerr
call|)
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|)
condition|)
block|{
case|case
name|MSCP_DONE
case|:
comment|/* fixed */
break|break;
case|case
name|MSCP_RESTARTED
case|:
comment|/* still working on it */
goto|goto
name|out
goto|;
case|case
name|MSCP_FAILED
case|:
comment|/* no luck */
name|diskerr
argument_list|(
name|bp
argument_list|,
name|drivename
argument_list|,
literal|"hard error"
argument_list|,
name|LOG_PRINTF
argument_list|,
operator|-
literal|1
argument_list|,
name|md
operator|->
name|md_lab
condition|?
operator|&
name|md
operator|->
name|md_lab
index|[
name|ui
operator|->
name|ui_unit
index|]
else|:
name|md
operator|->
name|md_lab
argument_list|)
expr_stmt|;
name|mscp_printevent
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Set the residual count and mark the transfer as 		 * done.  If the I/O wait queue is now empty, release 		 * the shared BDP, if any. 		 */
name|info
operator|=
name|bp
operator|->
name|b_info
expr_stmt|;
comment|/* we are about to clobber it */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_bytecount
expr_stmt|;
call|(
modifier|*
name|md
operator|->
name|md_iodone
call|)
argument_list|(
name|mi
argument_list|,
name|bp
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|out
label|:
break|break;
case|case
name|M_OP_REPLACE
operator||
name|M_OP_END
case|:
comment|/* 		 * A replace operation finished.  Just let the driver 		 * handle it (if it does replaces). 		 */
if|if
condition|(
name|md
operator|->
name|md_replace
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s%d: bogus REPLACE end\n"
argument_list|,
name|drivename
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|md
operator|->
name|md_replace
call|)
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * If it is not one of the above, we cannot handle it. 		 * (And we should not have received it, for that matter.) 		 */
name|unknown
label|:
name|printf
argument_list|(
literal|"%s%d: unknown opcode 0x%x status 0x%x ignored\n"
argument_list|,
name|mi
operator|->
name|mi_md
operator|->
name|md_dname
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|mp
operator|->
name|mscp_opcode
argument_list|,
name|mp
operator|->
name|mscp_status
argument_list|)
expr_stmt|;
name|mscp_hexdump
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * If the drive needs to be put back in the controller queue, 	 * do that now.  (`bp' below ought to be `dp', but they are all 	 * struct buf *.)  Note that b_active was cleared in the driver; 	 * we presume that there is something to be done, hence reassert it. 	 */
if|if
condition|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_REQUEUE
condition|)
block|{
name|bp
operator|=
operator|&
name|md
operator|->
name|md_utab
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_active
condition|)
name|panic
argument_list|(
literal|"mscp_dorsp requeue"
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
name|bp
argument_list|,
name|mi
operator|->
name|mi_tab
argument_list|,
name|b_forw
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
name|ui
operator|->
name|ui_flags
operator|&=
operator|~
name|UNIT_REQUEUE
expr_stmt|;
block|}
name|done
label|:
comment|/* 	 * Give back the response packet, and take a look at the next. 	 */
name|mp
operator|->
name|mscp_msglen
operator|=
name|MSCP_MSGLEN
expr_stmt|;
name|mi
operator|->
name|mi_rsp
operator|.
name|mri_desc
index|[
name|nextrsp
index|]
operator||=
name|MSCP_OWN
expr_stmt|;
name|nextrsp
operator|=
operator|(
name|nextrsp
operator|+
literal|1
operator|)
operator|%
name|mi
operator|->
name|mi_rsp
operator|.
name|mri_size
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/*  * Dump the entire contents of an MSCP packet in hex.  Mainly useful  * for debugging....  */
end_comment

begin_expr_stmt
name|mscp_hexdump
argument_list|(
name|mp
argument_list|)
specifier|register
expr|struct
name|mscp
operator|*
name|mp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|long
modifier|*
name|p
init|=
operator|(
name|long
operator|*
operator|)
name|mp
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|mp
operator|->
name|mscp_msglen
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|256
condition|)
comment|/* sanity */
name|i
operator|=
literal|256
expr_stmt|;
name|i
operator|/=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* ASSUMES MULTIPLE OF sizeof(long) */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Requeue outstanding transfers, e.g., after bus reset.  * Also requeue any drives that have on line or unit status  * info pending.  */
end_comment

begin_macro
name|mscp_requeue
argument_list|(
argument|mi
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mscp_info
modifier|*
name|mi
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|mscp_driver
modifier|*
name|md
init|=
name|mi
operator|->
name|mi_md
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|struct
name|buf
modifier|*
name|nextbp
decl_stmt|;
comment|/* 	 * Clear the controller chain.  Mark everything un-busy; we 	 * will soon fix any that are in fact busy. 	 */
name|mi
operator|->
name|mi_tab
operator|->
name|b_actf
operator|=
name|NULL
expr_stmt|;
name|mi
operator|->
name|mi_tab
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
operator|,
name|dp
operator|=
name|md
operator|->
name|md_utab
init|;
name|unit
operator|<
name|md
operator|->
name|md_nunits
condition|;
name|unit
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|ui
operator|=
name|md
operator|->
name|md_dinfo
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|ui
operator|==
name|NULL
operator|||
operator|!
name|ui
operator|->
name|ui_alive
operator|||
name|ui
operator|->
name|ui_ctlr
operator|!=
name|mi
operator|->
name|mi_ctlr
condition|)
continue|continue;
comment|/* not ours */
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Scan the wait queue, linking buffers onto drive queues. 	 * Note that these must be put at the front of the drive queue, 	 * lest we reorder I/O operations. 	 */
for|for
control|(
name|bp
operator|=
name|mi
operator|->
name|mi_wtab
operator|.
name|av_back
init|;
name|bp
operator|!=
operator|&
name|mi
operator|->
name|mi_wtab
condition|;
name|bp
operator|=
name|nextbp
control|)
block|{
name|nextbp
operator|=
name|bp
operator|->
name|av_back
expr_stmt|;
name|dp
operator|=
operator|&
name|md
operator|->
name|md_utab
index|[
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|>>
name|md
operator|->
name|md_unitshift
index|]
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
operator|==
name|NULL
condition|)
name|dp
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
block|}
name|mi
operator|->
name|mi_wtab
operator|.
name|av_forw
operator|=
name|mi
operator|->
name|mi_wtab
operator|.
name|av_back
operator|=
operator|&
name|mi
operator|->
name|mi_wtab
expr_stmt|;
comment|/* 	 * Scan for drives waiting for on line or status responses, 	 * and for drives with pending transfers.  Put these on the 	 * controller queue, and mark the controller busy. 	 */
for|for
control|(
name|unit
operator|=
literal|0
operator|,
name|dp
operator|=
name|md
operator|->
name|md_utab
init|;
name|unit
operator|<
name|md
operator|->
name|md_nunits
condition|;
name|unit
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|ui
operator|=
name|md
operator|->
name|md_dinfo
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|ui
operator|==
name|NULL
operator|||
operator|!
name|ui
operator|->
name|ui_alive
operator|||
name|ui
operator|->
name|ui_ctlr
operator|!=
name|mi
operator|->
name|mi_ctlr
condition|)
continue|continue;
name|ui
operator|->
name|ui_flags
operator|&=
operator|~
operator|(
name|UNIT_HAVESTATUS
operator||
name|UNIT_ONLINE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_REQUEUE
operator|)
operator|==
literal|0
operator|&&
name|dp
operator|->
name|b_actf
operator|==
name|NULL
condition|)
continue|continue;
name|ui
operator|->
name|ui_flags
operator|&=
operator|~
name|UNIT_REQUEUE
expr_stmt|;
name|APPEND
argument_list|(
name|dp
argument_list|,
name|mi
operator|->
name|mi_tab
argument_list|,
name|b_forw
argument_list|)
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
name|mi
operator|->
name|mi_tab
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AVOID_EMULEX_BUG
comment|/* 	 * ... and clear the index-to-buffer table. 	 */
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|AEB_MAX_BP
condition|;
name|unit
operator|++
control|)
name|mi
operator|->
name|mi_bp
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * MSCP error reporting  */
end_comment

begin_comment
comment|/*  * Messages for the various subcodes.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|unknown_msg
index|[]
init|=
literal|"unknown subcode"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Subcodes for Success (0)  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|succ_msgs
index|[]
init|=
block|{
literal|"normal"
block|,
comment|/* 0 */
literal|"spin down ignored"
block|,
comment|/* 1 = Spin-Down Ignored */
literal|"still connected"
block|,
comment|/* 2 = Still Connected */
name|unknown_msg
block|,
literal|"dup. unit #"
block|,
comment|/* 4 = Duplicate Unit Number */
name|unknown_msg
block|,
name|unknown_msg
block|,
name|unknown_msg
block|,
literal|"already online"
block|,
comment|/* 8 = Already Online */
name|unknown_msg
block|,
name|unknown_msg
block|,
name|unknown_msg
block|,
name|unknown_msg
block|,
name|unknown_msg
block|,
name|unknown_msg
block|,
name|unknown_msg
block|,
literal|"still online"
block|,
comment|/* 16 = Still Online */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Subcodes for Invalid Command (1)  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|icmd_msgs
index|[]
init|=
block|{
literal|"invalid msg length"
block|,
comment|/* 0 = Invalid Message Length */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Subcodes for Command Aborted (2)  */
end_comment

begin_comment
comment|/* none known */
end_comment

begin_comment
comment|/*  * Subcodes for Unit Offline (3)  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|offl_msgs
index|[]
init|=
block|{
literal|"unknown drive"
block|,
comment|/* 0 = Unknown, or online to other ctlr */
literal|"not mounted"
block|,
comment|/* 1 = Unmounted, or RUN/STOP at STOP */
literal|"inoperative"
block|,
comment|/* 2 = Unit Inoperative */
name|unknown_msg
block|,
literal|"duplicate"
block|,
comment|/* 4 = Duplicate Unit Number */
name|unknown_msg
block|,
name|unknown_msg
block|,
name|unknown_msg
block|,
literal|"in diagnosis"
block|,
comment|/* 8 = Disabled by FS or diagnostic */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Subcodes for Unit Available (4)  */
end_comment

begin_comment
comment|/* none known */
end_comment

begin_comment
comment|/*  * Subcodes for Media Format Error (5)  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|media_fmt_msgs
index|[]
init|=
block|{
literal|"fct unread - edc"
block|,
comment|/* 0 = FCT unreadable */
literal|"invalid sector header"
block|,
comment|/* 1 = Invalid Sector Header */
literal|"not 512 sectors"
block|,
comment|/* 2 = Not 512 Byte Sectors */
literal|"not formatted"
block|,
comment|/* 3 = Not Formatted */
literal|"fct ecc"
block|,
comment|/* 4 = FCT ECC */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Subcodes for Write Protected (6)  * N.B.:  Code 6 subcodes are 7 bits higher than other subcodes  * (i.e., bits 12-15).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wrprot_msgs
index|[]
init|=
block|{
name|unknown_msg
block|,
literal|"software"
block|,
comment|/* 1 = Software Write Protect */
literal|"hardware"
block|,
comment|/* 2 = Hardware Write Protect */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Subcodes for Compare Error (7)  */
end_comment

begin_comment
comment|/* none known */
end_comment

begin_comment
comment|/*  * Subcodes for Data Error (8)  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|data_msgs
index|[]
init|=
block|{
literal|"forced error"
block|,
comment|/* 0 = Forced Error (software) */
name|unknown_msg
block|,
literal|"header compare"
block|,
comment|/* 2 = Header Compare Error */
literal|"sync timeout"
block|,
comment|/* 3 = Sync Timeout Error */
name|unknown_msg
block|,
name|unknown_msg
block|,
name|unknown_msg
block|,
literal|"uncorrectable ecc"
block|,
comment|/* 7 = Uncorrectable ECC */
literal|"1 symbol ecc"
block|,
comment|/* 8 = 1 bit ECC */
literal|"2 symbol ecc"
block|,
comment|/* 9 = 2 bit ECC */
literal|"3 symbol ecc"
block|,
comment|/* 10 = 3 bit ECC */
literal|"4 symbol ecc"
block|,
comment|/* 11 = 4 bit ECC */
literal|"5 symbol ecc"
block|,
comment|/* 12 = 5 bit ECC */
literal|"6 symbol ecc"
block|,
comment|/* 13 = 6 bit ECC */
literal|"7 symbol ecc"
block|,
comment|/* 14 = 7 bit ECC */
literal|"8 symbol ecc"
block|,
comment|/* 15 = 8 bit ECC */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Subcodes for Host Buffer Access Error (9)  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|host_buffer_msgs
index|[]
init|=
block|{
name|unknown_msg
block|,
literal|"odd xfer addr"
block|,
comment|/* 1 = Odd Transfer Address */
literal|"odd xfer count"
block|,
comment|/* 2 = Odd Transfer Count */
literal|"non-exist. memory"
block|,
comment|/* 3 = Non-Existent Memory */
literal|"memory parity"
block|,
comment|/* 4 = Memory Parity Error */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Subcodes for Controller Error (10)  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cntlr_msgs
index|[]
init|=
block|{
name|unknown_msg
block|,
literal|"serdes overrun"
block|,
comment|/* 1 = Serialiser/Deserialiser Overrun */
literal|"edc"
block|,
comment|/* 2 = Error Detection Code? */
literal|"inconsistant internal data struct"
block|,
comment|/* 3 = Internal Error */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Subcodes for Drive Error (11)  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|drive_msgs
index|[]
init|=
block|{
name|unknown_msg
block|,
literal|"sdi command timeout"
block|,
comment|/* 1 = SDI Command Timeout */
literal|"ctlr detected protocol"
block|,
comment|/* 2 = Controller Detected Protocol Error */
literal|"positioner"
block|,
comment|/* 3 = Positioner Error */
literal|"lost rd/wr ready"
block|,
comment|/* 4 = Lost R/W Ready Error */
literal|"drive clock dropout"
block|,
comment|/* 5 = Lost Drive Clock */
literal|"lost recvr ready"
block|,
comment|/* 6 = Lost Receiver Ready */
literal|"drive detected error"
block|,
comment|/* 7 = Drive Error */
literal|"ctlr detected pulse or parity"
block|,
comment|/* 8 = Pulse or Parity Error */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following table correlates message codes with the  * decoding strings.  */
end_comment

begin_struct
struct|struct
name|code_decode
block|{
name|char
modifier|*
name|cdc_msg
decl_stmt|;
name|int
name|cdc_nsubcodes
decl_stmt|;
name|char
modifier|*
modifier|*
name|cdc_submsgs
decl_stmt|;
block|}
name|code_decode
index|[]
init|=
block|{
define|#
directive|define
name|SC
parameter_list|(
name|m
parameter_list|)
value|sizeof (m) / sizeof (m[0]), m
literal|"success"
block|,
name|SC
argument_list|(
name|succ_msgs
argument_list|)
block|,
literal|"invalid command"
block|,
name|SC
argument_list|(
name|icmd_msgs
argument_list|)
block|,
literal|"command aborted"
block|,
literal|0
block|,
literal|0
block|,
literal|"unit offline"
block|,
name|SC
argument_list|(
name|offl_msgs
argument_list|)
block|,
literal|"unit available"
block|,
literal|0
block|,
literal|0
block|,
literal|"media format error"
block|,
name|SC
argument_list|(
name|media_fmt_msgs
argument_list|)
block|,
literal|"write protected"
block|,
name|SC
argument_list|(
name|wrprot_msgs
argument_list|)
block|,
literal|"compare error"
block|,
literal|0
block|,
literal|0
block|,
literal|"data error"
block|,
name|SC
argument_list|(
name|data_msgs
argument_list|)
block|,
literal|"host buffer access error"
block|,
name|SC
argument_list|(
name|host_buffer_msgs
argument_list|)
block|,
literal|"controller error"
block|,
name|SC
argument_list|(
name|cntlr_msgs
argument_list|)
block|,
literal|"drive error"
block|,
name|SC
argument_list|(
name|drive_msgs
argument_list|)
block|,
undef|#
directive|undef
name|SC
block|}
struct|;
end_struct

begin_comment
comment|/*  * Print the decoded error event from an MSCP error datagram.  */
end_comment

begin_macro
name|mscp_printevent
argument_list|(
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|event
init|=
name|mp
operator|->
name|mscp_event
decl_stmt|;
specifier|register
name|struct
name|code_decode
modifier|*
name|cdc
decl_stmt|;
name|int
name|c
decl_stmt|,
name|sc
decl_stmt|;
name|char
modifier|*
name|cm
decl_stmt|,
modifier|*
name|scm
decl_stmt|;
comment|/* 	 * The code is the lower six bits of the event number (aka 	 * status).  If that is 6 (write protect), the subcode is in 	 * bits 12-15; otherwise, it is in bits 5-11. 	 * I WONDER WHAT THE OTHER BITS ARE FOR.  IT SURE WOULD BE 	 * NICE IF DEC SOLD DOCUMENTATION FOR THEIR OWN CONTROLLERS. 	 */
name|c
operator|=
name|event
operator|&
name|M_ST_MASK
expr_stmt|;
name|sc
operator|=
operator|(
name|c
operator|!=
literal|6
condition|?
name|event
operator|>>
literal|5
else|:
name|event
operator|>>
literal|12
operator|)
operator|&
literal|0x7ff
expr_stmt|;
if|if
condition|(
name|c
operator|>=
sizeof|sizeof
name|code_decode
operator|/
sizeof|sizeof
name|code_decode
index|[
literal|0
index|]
condition|)
name|cm
operator|=
literal|"- unknown code"
operator|,
name|scm
operator|=
literal|"??"
expr_stmt|;
else|else
block|{
name|cdc
operator|=
operator|&
name|code_decode
index|[
name|c
index|]
expr_stmt|;
name|cm
operator|=
name|cdc
operator|->
name|cdc_msg
expr_stmt|;
if|if
condition|(
name|sc
operator|>=
name|cdc
operator|->
name|cdc_nsubcodes
condition|)
name|scm
operator|=
name|unknown_msg
expr_stmt|;
else|else
name|scm
operator|=
name|cdc
operator|->
name|cdc_submsgs
index|[
name|sc
index|]
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %s (%s) (code %d, subcode %d)\n"
argument_list|,
name|cm
argument_list|,
name|scm
argument_list|,
name|c
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print the code and logical block number for an error packet.  * THIS IS PROBABLY PECULIAR TO DISK DRIVES.  IT SURE WOULD BE  * NICE IF DEC SOLD DOCUMENTATION FOR THEIR OWN CONTROLLERS.  */
end_comment

begin_macro
name|mscp_decodeerror
argument_list|(
argument|name
argument_list|,
argument|ctlr
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * For bad blocks, mp->mscp_erd.erd_hdr identifies a code and 	 * the logical block number.  Code 0 is a regular block; code 6 	 * is a replacement block.  The remaining codes are currently 	 * undefined.  The code is in the upper four bits of the header 	 * (bits 0-27 are the lbn). 	 */
name|int
name|issoft
init|=
name|mp
operator|->
name|mscp_flags
operator|&
operator|(
name|M_LF_SUCC
operator||
name|M_LF_CONT
operator|)
decl_stmt|;
specifier|static
name|char
modifier|*
name|codemsg
index|[
literal|16
index|]
init|=
block|{
literal|"lbn"
block|,
literal|"code 1"
block|,
literal|"code 2"
block|,
literal|"code 3"
block|,
literal|"code 4"
block|,
literal|"code 5"
block|,
literal|"rbn"
block|,
literal|"code 7"
block|,
literal|"code 8"
block|,
literal|"code 9"
block|,
literal|"code 10"
block|,
literal|"code 11"
block|,
literal|"code 12"
block|,
literal|"code 13"
block|,
literal|"code 14"
block|,
literal|"code 15"
block|}
decl_stmt|;
define|#
directive|define
name|BADCODE
parameter_list|(
name|h
parameter_list|)
value|(codemsg[(unsigned)(h)>> 28])
define|#
directive|define
name|BADLBN
parameter_list|(
name|h
parameter_list|)
value|((h)& 0xfffffff)
name|printf
argument_list|(
literal|"%s%d: %s error datagram%s:"
argument_list|,
name|name
argument_list|,
name|ctlr
argument_list|,
name|issoft
condition|?
literal|"soft"
else|:
literal|"hard"
argument_list|,
name|mp
operator|->
name|mscp_flags
operator|&
name|M_LF_CONT
condition|?
literal|" (continuing)"
else|:
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mp
operator|->
name|mscp_format
operator|&
literal|0377
condition|)
block|{
case|case
name|M_FM_CTLRERR
case|:
comment|/* controller error */
break|break;
case|case
name|M_FM_BUSADDR
case|:
comment|/* host memory access error */
name|printf
argument_list|(
literal|" memory addr 0x%x:"
argument_list|,
name|mp
operator|->
name|mscp_erd
operator|.
name|erd_busaddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_FM_DISKTRN
case|:
name|printf
argument_list|(
literal|" unit %d: level %d retry %d, %s %d:"
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|mp
operator|->
name|mscp_erd
operator|.
name|erd_level
argument_list|,
name|mp
operator|->
name|mscp_erd
operator|.
name|erd_retry
argument_list|,
name|BADCODE
argument_list|(
name|mp
operator|->
name|mscp_erd
operator|.
name|erd_hdr
argument_list|)
argument_list|,
name|BADLBN
argument_list|(
name|mp
operator|->
name|mscp_erd
operator|.
name|erd_hdr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_FM_SDI
case|:
name|printf
argument_list|(
literal|" unit %d: %s %d:"
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|BADCODE
argument_list|(
name|mp
operator|->
name|mscp_erd
operator|.
name|erd_hdr
argument_list|)
argument_list|,
name|BADLBN
argument_list|(
name|mp
operator|->
name|mscp_erd
operator|.
name|erd_hdr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_FM_SMLDSK
case|:
name|printf
argument_list|(
literal|" unit %d: small disk error, cyl %d:"
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|mp
operator|->
name|mscp_erd
operator|.
name|erd_sdecyl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" unit %d: unknown error, format 0x%x:"
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|mp
operator|->
name|mscp_format
argument_list|)
expr_stmt|;
block|}
name|mscp_printevent
argument_list|(
name|mp
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|BADCODE
undef|#
directive|undef
name|BADLBN
block|}
end_block

end_unit

