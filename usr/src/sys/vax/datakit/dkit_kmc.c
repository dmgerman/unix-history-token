begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Datakit driver  * KMC assistance, with or without DR11C  *	@(#)dkit_kmc.c	1.3 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"dkitkmc.h"
end_include

begin_if
if|#
directive|if
name|NDKITKMC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"datakit.h"
end_include

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../vaxif/if_uba.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_include
include|#
directive|include
file|"dkit.h"
end_include

begin_include
include|#
directive|include
file|"dkkmc.h"
end_include

begin_include
include|#
directive|include
file|"dk.h"
end_include

begin_define
define|#
directive|define
name|KMXSMALL
value|0
end_define

begin_define
define|#
directive|define
name|KMXBIG
value|1
end_define

begin_define
define|#
directive|define
name|MONITOR
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|MONITOR
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|dummy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|DKP
init|=
operator|&
name|dummy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M_ON
parameter_list|(
name|a
parameter_list|)
value|*DKP |= (a)
end_define

begin_define
define|#
directive|define
name|M_OFF
parameter_list|(
name|a
parameter_list|)
value|*DKP&= ~(a)
end_define

begin_define
define|#
directive|define
name|M_TRACE
parameter_list|(
name|a
parameter_list|)
value|*DKP |= (a);*DKP&= ~(a)
end_define

begin_define
define|#
directive|define
name|Mxmit
value|01
end_define

begin_define
define|#
directive|define
name|Mrecv
value|02
end_define

begin_define
define|#
directive|define
name|Mkint
value|04
end_define

begin_define
define|#
directive|define
name|Mint
value|010
end_define

begin_define
define|#
directive|define
name|Mcmd
value|020
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_ON
parameter_list|(
name|a
parameter_list|)
end_define

begin_define
define|#
directive|define
name|M_OFF
parameter_list|(
name|a
parameter_list|)
end_define

begin_define
define|#
directive|define
name|M_TRACE
parameter_list|(
name|a
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|dk_nchan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dkchan
name|dkit
index|[
name|NDATAKIT
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DKNCMDB
value|20
end_define

begin_define
define|#
directive|define
name|DKNSTB
value|20
end_define

begin_decl_stmt
name|int
name|dkk_ncmd
init|=
name|DKNCMDB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dkkin
name|dkkcmdbuf
index|[
name|DKNCMDB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dkk_nstat
init|=
name|DKNSTB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dkkin
name|dkkstat
index|[
name|DKNSTB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dkkbuf
index|[
literal|16
operator|*
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dkubmbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kdevice
modifier|*
name|dkkaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * initial information to the KMC  */
end_comment

begin_struct
struct|struct
name|dkinit
block|{
name|caddr_t
name|cmdaddr
decl_stmt|;
comment|/* command buffer */
name|caddr_t
name|stataddr
decl_stmt|;
comment|/* status buffer  */
name|caddr_t
name|bufaddr
decl_stmt|;
comment|/* kmc workspace  */
name|caddr_t
name|csraddr
decl_stmt|;
comment|/* for KMC/DR DR register address */
block|}
name|dkkmcinit
struct|;
end_struct

begin_comment
comment|/*  * structure of data in first mbuf on chain (type DKM_HDR)  *  */
end_comment

begin_struct
struct|struct
name|mpacket
block|{
name|short
name|mp_len
decl_stmt|;
comment|/* Total length left */
name|char
name|mp_ctl
decl_stmt|;
comment|/* Control character */
name|int
name|mp_eob
decl_stmt|;
comment|/* Send end-of-block indicator */
name|int
function_decl|(
modifier|*
name|mp_endfcn
function_decl|)
parameter_list|()
function_decl|;
comment|/* End-action function */
name|caddr_t
name|mp_endparm
decl_stmt|;
comment|/* Parameter to above function */
block|}
struct|;
end_struct

begin_comment
comment|/*  * The circular buffer, cmdbuf, is used to pass command to kmc:  * while the circular buffer statbuf is used to report status.  * There are 8 control and status registers (csr) accessible to  * both cpu and kmc.  * Csr4-csr5 are used to indicate the head and tail respectively  * of the cmdbuf.  Likewise, csr6-csr7 for statbuf.  * At initialization time, the cpu and kmc would agree on the beginning  * address of both buffers and their sizes.  */
end_comment

begin_define
define|#
directive|define
name|csr0
value|dkkaddr->un.bsel.bsel0
end_define

begin_comment
comment|/* kmc state */
end_comment

begin_define
define|#
directive|define
name|csr1
value|dkkaddr->un.bsel.bsel1
end_define

begin_define
define|#
directive|define
name|csr2
value|dkkaddr->un.bsel.bsel2
end_define

begin_comment
comment|/* used at init time, to pass */
end_comment

begin_define
define|#
directive|define
name|csr3
value|dkkaddr->un.bsel.bsel3
end_define

begin_comment
comment|/* addresses to the kmc       */
end_comment

begin_define
define|#
directive|define
name|csr4
value|dkkaddr->un.bsel.bsel4
end_define

begin_comment
comment|/* head cmdbuf */
end_comment

begin_define
define|#
directive|define
name|csr5
value|dkkaddr->un.bsel.bsel5
end_define

begin_comment
comment|/* tail cmdbuf */
end_comment

begin_define
define|#
directive|define
name|csr6
value|dkkaddr->un.bsel.bsel6
end_define

begin_comment
comment|/* head statbuf */
end_comment

begin_define
define|#
directive|define
name|csr7
value|dkkaddr->un.bsel.bsel7
end_define

begin_comment
comment|/* tail statbuf */
end_comment

begin_comment
comment|/*  * kmc device registers  */
end_comment

begin_struct
struct|struct
name|kdevice
block|{
union|union
block|{
struct|struct
block|{
name|short
name|sel0
decl_stmt|,
name|sel2
decl_stmt|,
name|sel4
decl_stmt|,
name|sel6
decl_stmt|;
block|}
name|wsel
struct|;
struct|struct
block|{
name|char
name|bsel0
decl_stmt|,
name|bsel1
decl_stmt|,
name|bsel2
decl_stmt|,
name|bsel3
decl_stmt|;
name|char
name|bsel4
decl_stmt|,
name|bsel5
decl_stmt|,
name|bsel6
decl_stmt|,
name|bsel7
decl_stmt|;
block|}
name|bsel
struct|;
block|}
name|un
union|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * For the moment, only support one kmc (kmc0)  * More need be done for multiple kmc's  */
end_comment

begin_decl_stmt
name|int
name|dkdebug
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dkactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dkbindex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kseqchk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to check seq. #'s in statbuf */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dkpanic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of dk_close(0)'s in this run */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kseq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # kmc responses mod 0377 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pseq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dkkin
modifier|*
name|cmd4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dkkcmdbuf[csr4] pointer */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dkkin
modifier|*
name|stat7
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dkkstat[csr7] pointer */
end_comment

begin_decl_stmt
name|int
name|dkk_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_macro
name|dkkmc_attach
argument_list|(
argument|kui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|kui
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ui
operator|=
name|kui
expr_stmt|;
name|dkk_cnt
operator|=
name|kui
operator|->
name|ui_unit
expr_stmt|;
block|}
end_block

begin_macro
name|dk_init
argument_list|()
end_macro

begin_block
block|{
name|int
name|t
decl_stmt|,
name|kt
decl_stmt|;
extern|extern dkkint(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* 	 *  On the first open of the hardware interface 	 */
end_comment

begin_if
if|if
condition|(
operator|!
name|ui
condition|)
return|return
operator|-
name|ENXIO
return|;
end_if

begin_if
if|if
condition|(
name|kmcset
argument_list|(
operator|(
name|dkk_cnt
operator|)
operator|<<
literal|6
argument_list|,
literal|03
argument_list|,
name|dkkint
argument_list|)
condition|)
block|{
comment|/* debug */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkkmcinit bad: kmcset failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_if

begin_expr_stmt
name|dkkaddr
operator|=
operator|(
operator|(
expr|struct
name|kdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* if csr0 != 0, then error 	   else pass the address of struct init 	   in csr2~4 and set csr0 to 1	*/
end_comment

begin_if
if|if
condition|(
operator|(
name|csr0
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* debug */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkkmcinit: csr0 != 0\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
end_if

begin_comment
comment|/* Map UBA registers to point to our stuff */
end_comment

begin_expr_stmt
name|kt
operator|=
name|dk_ubainit
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|kt
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkkmcinit: no uba resources\n"
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
end_if

begin_comment
comment|/* Address of DR11-C (if any) */
end_comment

begin_expr_stmt
name|t
operator|=
name|ui
operator|->
name|ui_flags
operator|&
operator|~
literal|03
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dkkmcinit
operator|.
name|csraddr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|t
operator|<<
literal|16
operator|)
operator|+
literal|3
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* bits 17 + 18 must be 1 */
end_comment

begin_comment
comment|/* append new init info here, if it is needed */
end_comment

begin_expr_stmt
name|dkkaddr
operator|->
name|un
operator|.
name|wsel
operator|.
name|sel2
operator|=
call|(
name|short
call|)
argument_list|(
name|UBAI_ADDR
argument_list|(
name|kt
argument_list|)
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* bits 0-15 */
end_comment

begin_expr_stmt
name|dkkaddr
operator|->
name|un
operator|.
name|bsel
operator|.
name|bsel4
operator|=
call|(
name|char
call|)
argument_list|(
name|UBAI_ADDR
argument_list|(
name|kt
argument_list|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* bits 16-17 */
end_comment

begin_expr_stmt
name|csr0
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* tell KMC to read csr2 */
end_comment

begin_expr_stmt
name|kseq
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|cmd4
operator|=
operator|&
name|dkkcmdbuf
index|[
literal|0
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* driver's pointers into cmdbuf and statbuf */
end_comment

begin_expr_stmt
name|stat7
operator|=
operator|&
name|dkkstat
index|[
literal|0
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dkactive
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_expr_stmt
unit|}  int
name|dk_ubaed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_macro
name|dk_ubainit
argument_list|()
end_macro

begin_block
block|{
name|int
name|t
decl_stmt|;
specifier|static
name|int
name|kt
decl_stmt|;
if|if
condition|(
name|dk_ubaed
condition|)
block|{
if|if
condition|(
name|dkdebug
operator|<
name|dk_nchan
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dk_ubainit: reinit\n"
argument_list|)
expr_stmt|;
return|return
name|kt
return|;
block|}
name|dk_ubaed
operator|=
literal|1
expr_stmt|;
comment|/* Initialization buffer */
name|kt
operator|=
name|uballoc
argument_list|(
name|ui
operator|->
name|ui_ubanum
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dkkmcinit
argument_list|,
sizeof|sizeof
name|dkkmcinit
argument_list|,
name|UBA_CANTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Command input buffer */
name|t
operator|=
name|uballoc
argument_list|(
name|ui
operator|->
name|ui_ubanum
argument_list|,
operator|(
name|caddr_t
operator|)
name|dkkcmdbuf
argument_list|,
sizeof|sizeof
name|dkkcmdbuf
argument_list|,
name|UBA_CANTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|dkkmcinit
operator|.
name|cmdaddr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|UBAI_ADDR
argument_list|(
name|t
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|UBAI_ADDR
argument_list|(
name|t
argument_list|)
operator|>>
literal|16
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* must swap bytes for unibus */
comment|/* Status out buffer */
name|t
operator|=
name|uballoc
argument_list|(
name|ui
operator|->
name|ui_ubanum
argument_list|,
operator|(
name|caddr_t
operator|)
name|dkkstat
argument_list|,
sizeof|sizeof
name|dkkstat
argument_list|,
name|UBA_CANTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|dkkmcinit
operator|.
name|stataddr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|UBAI_ADDR
argument_list|(
name|t
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|UBAI_ADDR
argument_list|(
name|t
argument_list|)
operator|>>
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* KMC buffer */
name|dkubmbuf
operator|=
name|uballoc
argument_list|(
name|ui
operator|->
name|ui_ubanum
argument_list|,
operator|(
name|caddr_t
operator|)
name|dkkbuf
argument_list|,
sizeof|sizeof
name|dkkbuf
argument_list|,
name|UBA_CANTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dkubmbuf
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|dkkmcinit
operator|.
name|bufaddr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|UBAI_ADDR
argument_list|(
name|dkubmbuf
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|UBAI_ADDR
argument_list|(
name|dkubmbuf
argument_list|)
operator|>>
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dkdebug
operator|<
name|dk_nchan
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dk_ubainit: bufaddr %x mapped %x\n"
argument_list|,
operator|(
name|caddr_t
operator|)
name|dkkbuf
argument_list|,
name|dkubmbuf
argument_list|)
expr_stmt|;
return|return
name|kt
return|;
block|}
end_block

begin_expr_stmt
name|dk_open
argument_list|(
name|chan
argument_list|,
name|supfcn
argument_list|)
specifier|register
name|chan
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|supfcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
specifier|register
name|s
expr_stmt|;
extern|extern 	dkkint(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|int
name|commchan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|init
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|chan
operator|>=
name|dk_nchan
condition|)
return|return
operator|-
name|ENXIO
return|;
end_if

begin_if
if|if
condition|(
name|dkactive
operator|==
operator|-
literal|1
condition|)
comment|/* fail request if reset is in progress */
return|return
operator|(
operator|-
name|ENETRESET
operator|)
return|;
end_if

begin_expr_stmt
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Channel 0 (0-3 in ISN) is reserved for maintenance. 	 * An open on channel 0 is interpreted as a request 	 * for an unused channel.  Channel 1 (4 in ISN or RADIAN) 	 * is the common supervisory channel. 	 */
end_comment

begin_if
if|if
condition|(
name|chan
operator|==
literal|0
condition|)
block|{
name|chan
operator|=
name|commchan
operator|+
literal|1
expr_stmt|;
comment|/* Start above commchan */
while|while
condition|(
literal|1
condition|)
block|{
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_state
operator|==
literal|0
condition|)
break|break ;
name|chan
operator|++
expr_stmt|;
if|if
condition|(
name|chan
operator|>=
name|dk_nchan
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
name|EADDRNOTAVAIL
return|;
block|}
block|}
block|}
end_if

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dkactive
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|init
operator|=
name|dk_init
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
name|init
return|;
end_if

begin_comment
comment|/* 	 * On first use of a channel, we must 	 * allocate per-channel UBA resource for transmit. 	 * Some day, when we convert the receivers to use mbufs, 	 * we'll do the same for reads. 	 * Note that these resources can't easily be freed (I think). 	 */
end_comment

begin_if
if|if
condition|(
operator|!
name|dkp
operator|->
name|dk_uba
operator|.
name|ifu_uba
condition|)
block|{
name|dkp
operator|->
name|dk_uba
operator|.
name|ifu_flags
operator|=
name|UBA_CANTWAIT
expr_stmt|;
if|if
condition|(
name|if_ubaminit
argument_list|(
operator|&
name|dkp
operator|->
name|dk_uba
operator|.
name|ifu_info
argument_list|,
name|ui
operator|->
name|ui_ubanum
argument_list|,
literal|0
argument_list|,
name|btoc
argument_list|(
name|CLBYTES
argument_list|)
argument_list|,
operator|&
name|dkp
operator|->
name|dk_uba
operator|.
name|ifu_r
argument_list|,
literal|0
argument_list|,
operator|&
name|dkp
operator|->
name|dk_uba
operator|.
name|ifu_xmt
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkkmc: no ubamap for channel %d\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOBUFS
return|;
block|}
name|dkp
operator|->
name|dk_outq
operator|.
name|ifq_maxlen
operator|=
literal|20
expr_stmt|;
block|}
end_if

begin_comment
comment|/* 	 * Finish setting up dkp struct. 	 */
end_comment

begin_if
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|dkcmd
argument_list|(
name|KC_XINIT
argument_list|,
name|chan
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
literal|0
argument_list|,
name|KMXBIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flushall
argument_list|(
name|dkp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_state
operator||=
name|DK_OPEN
expr_stmt|;
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
operator|(
name|DK_LINGR
operator||
name|DK_RESET
operator|)
expr_stmt|;
name|dkactive
operator|++
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|dkp
operator|->
name|dk_supfcn
operator|=
name|supfcn
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|chan
return|;
end_return

begin_comment
unit|}
comment|/*  * Close a channel:  */
end_comment

begin_expr_stmt
unit|dk_close
operator|(
name|chan
operator|)
block|{
specifier|register
expr|struct
name|dkchan
operator|*
name|dkp
block|;
specifier|register
name|s
block|;
name|int
name|init
block|;
if|if
condition|(
name|dkkaddr
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
comment|/* if no init, can't close */
comment|/* ie: can't do dkmaint */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|chan
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|dkp
operator|=
operator|&
name|dkit
index|[
literal|1
index|]
init|;
name|dkp
operator|<
operator|&
name|dkit
index|[
name|dk_nchan
index|]
condition|;
name|dkp
operator|++
control|)
block|{
if|if
condition|(
name|dkp
operator|->
name|dk_state
operator|&
operator|(
name|DK_OPEN
operator||
name|DK_BUSY
operator||
name|DK_RCV
operator|)
condition|)
block|{
name|dkp
operator|->
name|dk_state
operator||=
name|DK_RESET
expr_stmt|;
name|flushall
argument_list|(
name|dkp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_state
operator|=
name|DK_RESET
expr_stmt|;
block|}
block|}
name|dkpanic
operator|++
expr_stmt|;
name|kseq
operator|=
literal|0
expr_stmt|;
name|pseq
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|dkubmbuf
condition|)
block|{
comment|/* only deallocate mem if still allocated */
name|ubarelse
argument_list|(
name|ui
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|dkubmbuf
argument_list|)
expr_stmt|;
name|dkubmbuf
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* wait for protocols to close channels */
name|dkactive
operator|=
operator|-
literal|1
expr_stmt|;
name|DELAY
argument_list|(
literal|4
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* do a dk_free for all channels */
for|for
control|(
name|dkp
operator|=
operator|&
name|dkit
index|[
literal|1
index|]
init|;
name|dkp
operator|<
operator|&
name|dkit
index|[
name|dk_nchan
index|]
condition|;
name|dkp
operator|++
control|)
block|{
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
name|DK_LINGR
expr_stmt|;
block|}
name|dkactive
operator|=
literal|0
expr_stmt|;
name|csr0
operator|=
literal|0
expr_stmt|;
comment|/* set kmc to idle mode */
if|if
condition|(
operator|(
name|init
operator|=
name|dk_init
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|init
return|;
block|}
block|}
else|else
block|{
name|flushall
argument_list|(
name|dkp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_state
operator|=
name|DK_LINGR
expr_stmt|;
comment|/* set while UNIXP protocol 						   closes up channel with DK */
block|}
end_if

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/*  *	Close phase 2 - mark available for reassignment  */
end_comment

begin_expr_stmt
unit|dk_free
operator|(
name|chan
operator|)
block|{
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dk_free %d\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|dkit
index|[
name|chan
index|]
operator|.
name|dk_state
operator|&=
operator|~
operator|(
name|DK_LINGR
operator||
name|DK_RESET
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  *	Reset a channel  *	 prevents further I/O until close  */
end_comment

begin_expr_stmt
unit|dk_reset
operator|(
name|chan
operator|)
block|{
specifier|register
expr|struct
name|dkchan
operator|*
name|dkp
block|;
specifier|register
name|s
block|;
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dk_reset %d\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dkp
operator|->
name|dk_state
operator||=
name|DK_RESET
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|flushall
argument_list|(
name|dkp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  *	Xmit a short control (interrupt) packet (max 2 bytes)  */
end_comment

begin_expr_stmt
unit|dk_xint
operator|(
name|chan
operator|,
name|intr
operator|)
block|{
specifier|register
name|s
block|;
name|s
operator|=
name|splimp
argument_list|()
block|;
name|dkcmd
argument_list|(
name|KC_SOI
argument_list|,
name|chan
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|intr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|;
name|splx
argument_list|(
name|s
argument_list|)
block|;
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_comment
comment|/*  * Adjust window size  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|dk_winsize
argument_list|(
argument|chan
argument_list|,
argument|win
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|diocxwin
modifier|*
name|win
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|EINVAL
return|;
comment|/* For now... */
block|}
end_block

begin_comment
comment|/*  * Xmit data on a channel  */
end_comment

begin_macro
name|dk_xmit
argument_list|(
argument|chan
argument_list|,
argument|m
argument_list|,
argument|eob
argument_list|,
argument|ctlchar
argument_list|,
argument|endfcn
argument_list|,
argument|endparm
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|endfcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|caddr_t
name|endparm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
name|short
name|s
decl_stmt|;
specifier|register
name|struct
name|mpacket
modifier|*
name|mbp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|int
name|len
decl_stmt|;
name|M_ON
argument_list|(
name|Mxmit
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_RESET
operator|)
operator|||
operator|(
name|mb
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|DKMT_HDR
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mb
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|mbp
operator|=
name|mtod
argument_list|(
name|mb
argument_list|,
expr|struct
name|mpacket
operator|*
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|mp_endfcn
operator|=
name|endfcn
expr_stmt|;
name|mbp
operator|->
name|mp_endparm
operator|=
name|endparm
expr_stmt|;
name|mbp
operator|->
name|mp_eob
operator|=
name|eob
expr_stmt|;
name|mbp
operator|->
name|mp_ctl
operator|=
name|ctlchar
expr_stmt|;
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|dkp
operator|->
name|dk_state
operator||=
name|DK_BUSY
expr_stmt|;
name|dkp
operator|->
name|dk_obuf
operator|=
name|mbp
expr_stmt|;
name|mb
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|if_wubaput
argument_list|(
operator|&
name|dkp
operator|->
name|dk_uba
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|dkcmd
argument_list|(
name|KC_SEND
argument_list|,
name|chan
argument_list|,
operator|(
name|caddr_t
operator|)
name|UBAI_ADDR
argument_list|(
name|dkp
operator|->
name|dk_uba
operator|.
name|ifu_w
operator|.
name|ifrw_info
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|,
name|eob
condition|?
name|SBOT
else|:
name|SBOTM
argument_list|,
name|ctlchar
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|M_OFF
argument_list|(
name|Mxmit
argument_list|)
expr_stmt|;
return|return
name|dkp
operator|->
name|dk_state
return|;
block|}
name|mb
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|dkp
operator|->
name|dk_outq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|dkp
operator|->
name|dk_outq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
operator|&
name|dkp
operator|->
name|dk_outq
argument_list|,
name|mb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|M_OFF
argument_list|(
name|Mxmit
argument_list|)
expr_stmt|;
return|return
name|dkp
operator|->
name|dk_state
return|;
block|}
end_block

begin_comment
comment|/*  * Receive into a block buffer  */
end_comment

begin_macro
name|dk_recv
argument_list|(
argument|chan
argument_list|,
argument|addr
argument_list|,
argument|len
argument_list|,
argument|mode
argument_list|,
argument|endfcn
argument_list|,
argument|endparm
argument_list|)
end_macro

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|endfcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|,
name|endparm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|M_ON
argument_list|(
name|Mrecv
argument_list|)
expr_stmt|;
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_state
operator|&
operator|(
name|DK_RCV
operator||
name|DK_RESET
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dkp
operator|->
name|dk_ubmbase
operator|=
name|uballoc
argument_list|(
name|ui
operator|->
name|ui_ubanum
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|UBA_CANTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_ubmbase
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dkp
operator|->
name|dk_state
operator||=
name|DK_RCV
expr_stmt|;
name|dkp
operator|->
name|dk_endfcn
operator|=
name|endfcn
expr_stmt|;
name|dkp
operator|->
name|dk_endparm
operator|=
name|endparm
expr_stmt|;
name|dkp
operator|->
name|dk_rlen
operator|=
name|len
expr_stmt|;
name|dkcmd
argument_list|(
name|KC_RCVB
argument_list|,
name|chan
argument_list|,
operator|(
name|caddr_t
operator|)
name|UBAI_ADDR
argument_list|(
name|dkp
operator|->
name|dk_ubmbase
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|,
name|mode
operator|&
literal|0377
argument_list|,
name|mode
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|M_OFF
argument_list|(
name|Mrecv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|dkp
operator|->
name|dk_state
return|;
block|}
end_block

begin_comment
comment|/* Abort pending receive */
end_comment

begin_macro
name|dk_rabort
argument_list|(
argument|chan
argument_list|,
argument|nendfcn
argument_list|,
argument|nendparm
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|nendfcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|caddr_t
name|nendparm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
specifier|register
name|s
expr_stmt|;
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_RCV
condition|)
block|{
comment|/* cancel outstanding receive */
name|dkcmd
argument_list|(
name|KC_RCVB
argument_list|,
name|chan
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_endfcn
operator|=
name|nendfcn
expr_stmt|;
name|dkp
operator|->
name|dk_endparm
operator|=
name|nendparm
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|dkp
operator|->
name|dk_state
return|;
block|}
end_block

begin_macro
name|dk_status
argument_list|(
argument|chan
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|chan
operator|>=
name|dk_nchan
condition|)
return|return
literal|0
return|;
return|return
name|dkit
index|[
name|chan
index|]
operator|.
name|dk_state
return|;
block|}
end_block

begin_comment
comment|/*  * Various control commands to KMC  */
end_comment

begin_macro
name|dk_cmd
argument_list|(
argument|chan
argument_list|,
argument|cmd
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
specifier|register
name|s
expr_stmt|;
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
operator|(
name|DKC_XINIT
operator||
name|DKC_FLUSH
operator|)
condition|)
block|{
comment|/*for either command do the same thing: 		 * reinit the transmitter and flush any pending output. 		 * NOTE: for the kmc, there is no response to XINIT 		 * and no send complete for flush 		 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|dkcmd
argument_list|(
name|KC_XINIT
argument_list|,
name|chan
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
literal|0
argument_list|,
name|KMXBIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flushall
argument_list|(
name|dkp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dkcmd
argument_list|(
name|KC_CMD
argument_list|,
name|chan
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|DKC_FLUSH
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cmd
operator|&=
operator|~
operator|(
name|DKC_XINIT
operator||
name|DKC_FLUSH
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
condition|)
name|dkcmd
argument_list|(
name|KC_CMD
argument_list|,
name|chan
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|cmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Note that flushall is often recursive when a tty driver  *	is involved.  */
end_comment

begin_expr_stmt
specifier|static
name|flushall
argument_list|(
name|dkp
argument_list|,
name|rwflag
argument_list|)
specifier|register
expr|struct
name|dkchan
operator|*
name|dkp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|s
expr_stmt|;
specifier|register
name|struct
name|mpacket
modifier|*
name|mbp
decl_stmt|;
name|int
function_decl|(
modifier|*
name|endfcn
function_decl|)
parameter_list|()
function_decl|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_RCV
operator|)
operator|&&
operator|(
name|rwflag
operator|>=
literal|0
operator|)
condition|)
block|{
name|dkcmd
argument_list|(
name|KC_RCVB
argument_list|,
name|dkp
operator|-
name|dkit
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
name|DK_RCV
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_ubmbase
condition|)
block|{
name|ubarelse
argument_list|(
name|ui
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|dkp
operator|->
name|dk_ubmbase
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_ubmbase
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|endfcn
operator|=
name|dkp
operator|->
name|dk_endfcn
condition|)
block|{
name|dkp
operator|->
name|dk_endfcn
operator|=
name|NULL
expr_stmt|;
call|(
modifier|*
name|endfcn
call|)
argument_list|(
name|dkp
operator|->
name|dk_endparm
argument_list|,
name|dkp
operator|-
name|dkit
argument_list|,
name|dkp
operator|->
name|dk_rlen
argument_list|,
name|DKR_ABORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* flush all writes current and pending */
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_BUSY
operator|)
operator|&&
operator|(
name|rwflag
operator|<=
literal|0
operator|)
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* flush current write */
if|if
condition|(
name|mbp
operator|=
name|dkp
operator|->
name|dk_obuf
condition|)
block|{
name|dkp
operator|->
name|dk_obuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|endfcn
operator|=
name|mbp
operator|->
name|mp_endfcn
condition|)
block|{
name|mbp
operator|->
name|mp_endfcn
operator|=
name|NULL
expr_stmt|;
call|(
name|endfcn
call|)
argument_list|(
name|mbp
operator|->
name|mp_endparm
argument_list|,
name|dkp
operator|-
name|dkit
argument_list|)
expr_stmt|;
block|}
name|m_free
argument_list|(
name|dtom
argument_list|(
name|mbp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* flush any pending writes which may be queued up */
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|dkp
operator|->
name|dk_outq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
break|break;
name|mbp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|mpacket
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|endfcn
operator|=
name|mbp
operator|->
name|mp_endfcn
condition|)
block|{
name|mbp
operator|->
name|mp_endfcn
operator|=
name|NULL
expr_stmt|;
call|(
name|endfcn
call|)
argument_list|(
name|mbp
operator|->
name|mp_endparm
argument_list|,
name|dkp
operator|-
name|dkit
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* mark channel as not busy */
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
name|DK_BUSY
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_OPEN
operator|)
operator|&&
operator|(
name|rwflag
operator|>=
literal|0
operator|)
condition|)
block|{
name|dkcmd
argument_list|(
name|KC_CLOSE
argument_list|,
name|dkp
operator|-
name|dkit
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_BUSY
condition|)
block|{
name|mbp
operator|=
name|dkp
operator|->
name|dk_obuf
expr_stmt|;
name|dkp
operator|->
name|dk_obuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|endfcn
operator|=
name|mbp
operator|->
name|mp_endfcn
condition|)
block|{
name|mbp
operator|->
name|mp_endfcn
operator|=
name|NULL
expr_stmt|;
call|(
name|endfcn
call|)
argument_list|(
name|mbp
operator|->
name|mp_endparm
argument_list|,
name|dkp
operator|-
name|dkit
argument_list|)
expr_stmt|;
block|}
name|m_free
argument_list|(
name|dtom
argument_list|(
name|mbp
argument_list|)
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
name|DK_BUSY
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|short
name|dup_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* counter for number of duplicate sends */
end_comment

begin_comment
comment|/*  * Routine to handle interrupts from the KMC  *  * This routine is called when  * the KMC generates an unsolicited interrupt (VEC4 == 1)  *  * These interrupts are used by the KMC to notify dkit_kmc.c  * of events such as output buffer completions  * csr6& csr7 point to dkkstat  */
end_comment

begin_macro
name|dkkint
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
specifier|register
name|struct
name|dkkin
modifier|*
name|sp
decl_stmt|;
specifier|register
name|chan
expr_stmt|;
name|struct
name|mpacket
modifier|*
name|mbp
decl_stmt|;
name|int
function_decl|(
modifier|*
name|endfcn
function_decl|)
parameter_list|()
function_decl|;
name|M_ON
argument_list|(
name|Mkint
argument_list|)
expr_stmt|;
name|chan
operator|=
name|csr0
expr_stmt|;
comment|/* temp for cc -O bug */
if|if
condition|(
operator|(
name|chan
operator|&
literal|01
operator|)
operator|==
literal|1
condition|)
comment|/* 1 or 3 -> ignore */
return|return;
name|sp
operator|=
name|stat7
expr_stmt|;
comment|/* next response to be processed */
while|while
condition|(
name|csr6
operator|!=
name|csr7
condition|)
block|{
if|if
condition|(
name|kseqchk
condition|)
if|if
condition|(
operator|(
operator|(
operator|(
name|sp
operator|->
name|k_chan
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator|!=
name|kseq
operator|)
operator|||
operator|(
operator|(
operator|(
name|sp
operator|->
name|k_type
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator|!=
name|kseq
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkkint: kseq %x chan %d type %x\n"
argument_list|,
name|kseq
argument_list|,
name|sp
operator|->
name|k_chan
argument_list|,
name|sp
operator|->
name|k_type
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
name|kseq
operator|=
operator|(
name|kseq
operator|+
literal|1
operator|)
operator|&
literal|0377
expr_stmt|;
name|sp
operator|->
name|k_addr
operator|=
name|pseq
expr_stmt|;
name|pseq
operator|++
expr_stmt|;
name|chan
operator|=
name|sp
operator|->
name|k_chan
operator|&
literal|0377
expr_stmt|;
comment|/* mask off seq. # */
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|" dkkint: head %d tail %d"
argument_list|,
name|csr6
argument_list|,
name|csr7
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|" type %x chan %d len %d mode %x ctl %x\n"
argument_list|,
name|sp
operator|->
name|k_type
operator|&
literal|0377
argument_list|,
name|sp
operator|->
name|k_chan
operator|&
literal|0377
argument_list|,
name|sp
operator|->
name|k_len
argument_list|,
name|sp
operator|->
name|k_mode
argument_list|,
name|sp
operator|->
name|k_ctl
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sp
operator|->
name|k_type
operator|&
literal|0377
condition|)
block|{
case|case
name|KS_CNTL
case|:
if|if
condition|(
name|dkp
operator|->
name|dk_supfcn
condition|)
call|(
modifier|*
name|dkp
operator|->
name|dk_supfcn
call|)
argument_list|(
name|chan
argument_list|,
name|sp
operator|->
name|k_ctl
argument_list|)
expr_stmt|;
break|break ;
case|case
name|KS_EOI
case|:
break|break ;
case|case
name|KS_SEND
case|:
name|mbp
operator|=
name|dkp
operator|->
name|dk_obuf
expr_stmt|;
if|if
condition|(
name|mbp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dkp
operator|->
name|dk_state
operator|&
operator|(
name|DK_RESET
operator||
name|DK_LINGR
operator|)
condition|)
break|break;
comment|/* flushall was already called */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkkint: xbufout chan %d state %x\n"
argument_list|,
name|chan
argument_list|,
name|dkp
operator|->
name|dk_state
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"head %d tail %d"
argument_list|,
name|csr6
argument_list|,
name|csr7
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|" type %x len %d mode %x ctl %x\n"
argument_list|,
name|sp
operator|->
name|k_type
operator|&
literal|0377
argument_list|,
name|sp
operator|->
name|k_len
argument_list|,
name|sp
operator|->
name|k_mode
argument_list|,
name|sp
operator|->
name|k_ctl
argument_list|)
expr_stmt|;
break|break ;
block|}
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
name|DK_BUSY
expr_stmt|;
name|dkp
operator|->
name|dk_obuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|endfcn
operator|=
name|mbp
operator|->
name|mp_endfcn
condition|)
block|{
name|mbp
operator|->
name|mp_endfcn
operator|=
name|NULL
expr_stmt|;
call|(
name|endfcn
call|)
argument_list|(
name|mbp
operator|->
name|mp_endparm
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
name|m_free
argument_list|(
name|dtom
argument_list|(
name|mbp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_uba
operator|.
name|ifu_xtofree
condition|)
block|{
name|m_freem
argument_list|(
name|dkp
operator|->
name|dk_uba
operator|.
name|ifu_xtofree
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_uba
operator|.
name|ifu_xtofree
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dkp
operator|->
name|dk_outq
operator|.
name|ifq_head
condition|)
name|dkstart
argument_list|(
name|dkp
argument_list|)
expr_stmt|;
break|break;
case|case
name|KS_RDB
case|:
if|if
condition|(
operator|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_RCV
operator|)
operator|==
literal|0
operator|)
operator|&&
name|dkp
operator|->
name|dk_endfcn
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkkint: rbufin chan %d state %x\n"
argument_list|,
name|chan
argument_list|,
name|dkp
operator|->
name|dk_state
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|" head %d tail %d\n"
argument_list|,
name|csr6
argument_list|,
name|csr7
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|" type %x len %d mode %x ctl %x\n"
argument_list|,
name|sp
operator|->
name|k_type
operator|&
literal|0377
argument_list|,
name|sp
operator|->
name|k_len
argument_list|,
name|sp
operator|->
name|k_mode
argument_list|,
name|sp
operator|->
name|k_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|k_ctl
condition|)
break|break ;
else|else
block|{
name|stat7
operator|=
name|sp
expr_stmt|;
comment|/* save it for dump */
name|csr0
operator|=
literal|3
expr_stmt|;
comment|/* stop KMC */
name|panic
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* KMC probably wrote 						into a mbuf we don't own */
block|}
block|}
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
name|DK_RCV
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_ubmbase
condition|)
block|{
name|ubarelse
argument_list|(
name|ui
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|dkp
operator|->
name|dk_ubmbase
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_ubmbase
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|endfcn
operator|=
name|dkp
operator|->
name|dk_endfcn
condition|)
block|{
name|dkp
operator|->
name|dk_endfcn
operator|=
name|NULL
expr_stmt|;
call|(
name|endfcn
call|)
argument_list|(
name|dkp
operator|->
name|dk_endparm
argument_list|,
name|chan
argument_list|,
name|sp
operator|->
name|k_len
argument_list|,
name|sp
operator|->
name|k_mode
argument_list|,
name|sp
operator|->
name|k_ctl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KS_ERR
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkkint: err : chan %d, code %x\nchead: %d, ctail: %d, rhead: %d, rtail: %d\n"
argument_list|,
name|chan
argument_list|,
name|sp
operator|->
name|k_len
argument_list|,
name|csr4
argument_list|,
name|csr5
argument_list|,
name|csr6
argument_list|,
name|csr7
argument_list|)
expr_stmt|;
comment|/* if error is duplicate send, only close that chan, */
comment|/* not the whole interface */
if|if
condition|(
name|sp
operator|->
name|k_len
operator|==
name|E_DUP
condition|)
block|{
name|dup_count
operator|++
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_OPEN
condition|)
block|{
name|dk_reset
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|reset
label|:
operator|(
name|void
operator|)
name|dk_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return ;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkkint: chan %d, type %x, len %d, ctl %x, mode %x\n"
argument_list|,
name|chan
argument_list|,
name|sp
operator|->
name|k_type
operator|&
literal|0377
argument_list|,
name|sp
operator|->
name|k_len
argument_list|,
name|sp
operator|->
name|k_ctl
argument_list|,
name|sp
operator|->
name|k_mode
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
comment|/* end switch */
if|if
condition|(
name|csr7
operator|==
name|dkk_nstat
operator|-
literal|1
condition|)
block|{
name|csr7
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
operator|&
name|dkkstat
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|csr7
operator|++
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
block|}
comment|/* end while */
name|stat7
operator|=
name|sp
expr_stmt|;
name|M_OFF
argument_list|(
name|Mkint
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start (Restart) transmission on the given line  */
end_comment

begin_expr_stmt
name|dkstart
argument_list|(
name|dkp
argument_list|)
specifier|register
expr|struct
name|dkchan
operator|*
name|dkp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mpacket
modifier|*
name|mbp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 	 * If it is currently active, just return 	 */
if|if
condition|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_BUSY
condition|)
return|return;
name|IF_DEQUEUE
argument_list|(
operator|&
name|dkp
operator|->
name|dk_outq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return;
name|mbp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|mpacket
operator|*
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_state
operator||=
name|DK_BUSY
expr_stmt|;
name|dkp
operator|->
name|dk_obuf
operator|=
name|mbp
expr_stmt|;
name|len
operator|=
name|if_wubaput
argument_list|(
operator|&
name|dkp
operator|->
name|dk_uba
argument_list|,
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|dkcmd
argument_list|(
name|KC_SEND
argument_list|,
name|dkp
operator|-
name|dkit
argument_list|,
operator|(
name|caddr_t
operator|)
name|UBAI_ADDR
argument_list|(
name|dkp
operator|->
name|dk_uba
operator|.
name|ifu_w
operator|.
name|ifrw_info
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|,
name|mbp
operator|->
name|mp_eob
condition|?
name|SBOT
else|:
name|SBOTM
argument_list|,
name|mbp
operator|->
name|mp_ctl
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Put command in dkkcmdbuf which is pointed by csr4~5  */
end_comment

begin_macro
name|dkcmd
argument_list|(
argument|type
argument_list|,
argument|chan
argument_list|,
argument|addr
argument_list|,
argument|len
argument_list|,
argument|mode
argument_list|,
argument|ctl
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|,
name|chan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dkkin
modifier|*
name|sp
decl_stmt|;
specifier|register
name|s
expr_stmt|;
specifier|register
name|next
expr_stmt|;
specifier|register
name|loop
expr_stmt|;
name|struct
name|timeval
name|tv1
decl_stmt|,
name|tv2
decl_stmt|;
name|M_ON
argument_list|(
name|Mcmd
argument_list|)
expr_stmt|;
name|s
operator|=
name|csr0
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
literal|3
operator|)
operator|!=
literal|2
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|next
operator|=
operator|(
name|csr4
operator|+
literal|1
operator|)
operator|%
name|dkk_ncmd
expr_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|csr5
operator|==
name|next
condition|)
block|{
comment|/* give it a chance to empty the buffer */
if|if
condition|(
name|loop
operator|++
operator|>
literal|10000000
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"KMC DIED, restart\n"
argument_list|)
expr_stmt|;
name|dk_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"KMC cmd overrun for %ld\n"
argument_list|,
name|loop
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|cmd4
expr_stmt|;
name|sp
operator|->
name|k_type
operator|=
name|type
operator||
operator|(
operator|(
name|pseq
operator|&
literal|0177
operator|)
operator|<<
literal|9
operator|)
expr_stmt|;
name|sp
operator|->
name|k_chan
operator|=
name|chan
operator||
operator|(
operator|(
name|kseq
operator|&
literal|0377
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|sp
operator|->
name|k_addr
operator|=
operator|(
operator|(
name|int
operator|)
name|addr
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|int
operator|)
name|addr
operator|>>
literal|16
operator|)
expr_stmt|;
name|sp
operator|->
name|k_len
operator|=
name|len
expr_stmt|;
name|sp
operator|->
name|k_mode
operator|=
name|mode
expr_stmt|;
name|sp
operator|->
name|k_ctl
operator|=
name|ctl
expr_stmt|;
name|pseq
operator|++
expr_stmt|;
name|csr4
operator|=
name|next
expr_stmt|;
name|cmd4
operator|=
operator|&
name|dkkcmdbuf
index|[
name|next
index|]
expr_stmt|;
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|" dkcmd: head %d, tail %d"
argument_list|,
name|csr4
argument_list|,
name|csr5
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|" type %x, chan %d, addr %x, len %d"
argument_list|,
name|type
argument_list|,
name|chan
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|" mode %x, ctl %x\n"
argument_list|,
name|mode
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|M_OFF
argument_list|(
name|Mcmd
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

