begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Datakit terminal driver  *	SCCSID[] = "@(#)dktty.c	1.8 Garage 84/05/14"  */
end_comment

begin_include
include|#
directive|include
file|"dktty.h"
end_include

begin_if
if|#
directive|if
name|NDKTTY
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"datakit.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"signal.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"dkit.h"
end_include

begin_include
include|#
directive|include
file|"dk.h"
end_include

begin_include
include|#
directive|include
file|"dkdev.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|dk_nchan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|dkdev
name|dkdev
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tty
name|dkt
index|[
name|NDATAKIT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|dktibuf
index|[
name|NDATAKIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input buffer pointers */
end_comment

begin_decl_stmt
name|int
name|dktpaused
index|[
name|NDATAKIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delays for no output mbuf */
end_comment

begin_decl_stmt
name|int
name|dktdelay
index|[]
init|=
block|{
comment|/* Time to wait on close before dropping line */
literal|4
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|8
block|,
comment|/* B0-B300 */
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|dktstart
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|dkt_tmr
index|[
literal|16
index|]
init|=
block|{
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|9
block|,
literal|6
block|,
literal|4
block|,
literal|2
block|,
literal|1
block|,
literal|15
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * DKT control messages  */
end_comment

begin_define
define|#
directive|define
name|D_BREAK
value|0110
end_define

begin_define
define|#
directive|define
name|D_DELAY
value|0100
end_define

begin_define
define|#
directive|define
name|DKTSPEED
value|B9600
end_define

begin_define
define|#
directive|define
name|DKTFLAGS
value|(EVENP|ODDP|ECHO)
end_define

begin_decl_stmt
specifier|extern
name|int
name|dkdebug
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEBUG
value|(dkdebug< 512)
end_define

begin_define
define|#
directive|define
name|devDEBUG
value|(minor(dev)>= dkdebug)
end_define

begin_define
define|#
directive|define
name|chanDEBUG
value|(chan>= dkdebug)
end_define

begin_define
define|#
directive|define
name|tpDEBUG
value|((tp - dkt)>= dkdebug)
end_define

begin_comment
comment|/*  * Open a DKT line.  */
end_comment

begin_macro
name|dktopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|dkdev
modifier|*
name|dv
decl_stmt|;
specifier|register
name|d
expr_stmt|;
name|int
name|chan
decl_stmt|;
name|d
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|dk_nchan
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkt_open(%d) error\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|tp
operator|=
operator|&
name|dkt
index|[
name|d
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|)
operator|&&
name|u
operator|.
name|u_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|!
name|dktibuf
index|[
name|d
index|]
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|mb
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|DKMT_ITTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
name|dktibuf
index|[
name|d
index|]
operator|=
name|mtod
argument_list|(
name|mb
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chan
operator|=
name|dk_open
argument_list|(
name|d
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
name|chan
return|;
block|}
name|tp
operator|->
name|t_oproc
operator|=
name|dktstart
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
operator|(
name|TS_WOPEN
operator||
name|TS_CARR_ON
operator|)
expr_stmt|;
name|dv
operator|=
operator|&
name|dkdev
index|[
name|d
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|DKTSPEED
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|=
name|DKTFLAGS
expr_stmt|;
block|}
if|if
condition|(
name|devDEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DKT_open(%x,%o)\n"
argument_list|,
name|dev
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
name|dktfcon
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|devDEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DKT_open(%x, %x) ok\n"
argument_list|,
name|dev
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|dv
operator|->
name|d_prot
operator||=
name|DpTTY
expr_stmt|;
return|return
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Close a DKT line.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|dktclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|dkdev
modifier|*
name|dv
decl_stmt|;
specifier|register
name|int
name|d
decl_stmt|,
name|s
decl_stmt|;
specifier|extern
name|int
name|dktcflush
argument_list|()
decl_stmt|,
name|dktrcv
argument_list|()
decl_stmt|,
name|wakeup
argument_list|()
decl_stmt|;
name|d
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|dkt
index|[
name|d
index|]
expr_stmt|;
name|dv
operator|=
operator|&
name|dkdev
index|[
name|d
index|]
expr_stmt|;
comment|/* 	 * If called from exit(), give output 30 seconds to drain. 	 * Otherwise let output drain first. 	 */
if|if
condition|(
name|u
operator|.
name|u_signal
index|[
name|SIGKILL
index|]
operator|==
name|SIG_IGN
condition|)
block|{
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|timeout
argument_list|(
name|dktcflush
argument_list|,
operator|(
name|caddr_t
operator|)
name|tp
argument_list|,
literal|30
operator|*
name|hz
argument_list|)
expr_stmt|;
name|ttywflush
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|dktcflush
argument_list|,
operator|(
name|caddr_t
operator|)
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CARR_ON
expr_stmt|;
if|if
condition|(
name|dv
operator|->
name|d_prot
operator|==
name|DpTTY
condition|)
comment|/* no other protocols open */
name|dk_reset
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
if|if
condition|(
name|devDEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DKT_clos(%x)\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|dv
operator|->
name|d_prot
operator|&=
operator|~
name|DpTTY
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CARR_ON
expr_stmt|;
comment|/* Wait for output to drain on far end */
if|if
condition|(
name|dktdelay
index|[
name|tp
operator|->
name|t_ispeed
index|]
operator|>
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
name|tp
argument_list|,
name|dktdelay
index|[
name|tp
operator|->
name|t_ispeed
index|]
operator|*
name|hz
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|tp
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dv
operator|->
name|d_prot
condition|)
block|{
operator|(
name|void
operator|)
name|dk_close
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dk_takedown
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|dv
operator|->
name|d_state
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|dk_rabort
argument_list|(
name|d
argument_list|,
name|dktrcv
argument_list|,
operator|(
name|caddr_t
operator|)
name|tp
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
name|dktibuf
index|[
name|d
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|dktibuf
index|[
name|d
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dktibuf
index|[
name|d
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|dktcflush
argument_list|(
argument|tp
argument_list|)
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|ttyflush
argument_list|(
name|tp
argument_list|,
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read from a DKT line.  */
end_comment

begin_macro
name|dktread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|devDEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dktread(%x) %d\n"
argument_list|,
name|dev
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|dkt
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|err
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
expr_stmt|;
if|if
condition|(
name|devDEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dktread done(%x) %d err=%d\n"
argument_list|,
name|dev
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|dktfcon
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_block

begin_comment
comment|/*  * Write on a DKT line  */
end_comment

begin_macro
name|dktwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|devDEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dktwrite(%x)\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|dkt
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Receive a packet  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|dktrcv
argument_list|(
name|tp
argument_list|,
name|chan
argument_list|,
name|resid
argument_list|,
name|rmode
argument_list|,
name|rctl
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|rmode
operator|&
name|DKR_ABORT
operator|)
operator|||
operator|(
name|dk_status
argument_list|(
name|chan
argument_list|)
operator|&
name|DK_RESET
operator|)
condition|)
block|{
name|dktshut
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return ;
block|}
comment|/* Process input data */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|cp
operator|=
name|dktibuf
index|[
name|tp
operator|-
name|dkt
index|]
expr_stmt|;
name|count
operator|=
name|MLEN
operator|-
name|resid
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
do|do
block|{
comment|/* Should really do parity checking... */
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|(
operator|*
name|cp
operator|++
operator|)
operator|&
literal|0377
operator|,
name|tp
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
operator|(
name|rctl
operator|&
literal|0377
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|chanDEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DKT_ctl 0%o on %d\n"
argument_list|,
name|c
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|D_BREAK
condition|)
block|{
comment|/* 				 * At framing error (break) generate 				 * a null (in raw mode, for getty), or a 				 * interrupt (in cooked/cbreak mode). 				 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
condition|)
name|c
operator|=
literal|0
expr_stmt|;
else|else
name|c
operator|=
name|tp
operator|->
name|t_intrc
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|,
name|tp
operator|)
expr_stmt|;
block|}
block|}
block|}
name|dktfcon
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Input flow control:  queue another receive unless to many chars waiting  */
end_comment

begin_expr_stmt
name|dktfcon
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|d
init|=
name|tp
operator|-
name|dkt
decl_stmt|;
specifier|register
name|x
expr_stmt|;
if|if
condition|(
operator|(
name|dk_status
argument_list|(
name|d
argument_list|)
operator|&
operator|(
name|DK_RCV
operator||
name|DK_OPEN
operator|)
operator|)
operator|!=
name|DK_OPEN
condition|)
return|return ;
if|if
condition|(
name|dktibuf
index|[
name|d
index|]
operator|==
name|NULL
condition|)
return|return;
name|x
operator|=
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|tp
operator|->
name|t_canq
operator|.
name|c_cc
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|TTYHOG
operator|/
literal|2
operator|&&
operator|(
name|tp
operator|->
name|t_delct
operator|>
literal|0
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|CBREAK
operator|)
operator|)
operator|)
condition|)
return|return;
operator|(
name|void
operator|)
name|dk_recv
argument_list|(
name|d
argument_list|,
name|dktibuf
index|[
name|d
index|]
argument_list|,
name|MLEN
argument_list|,
name|DKR_BLOCK
operator||
name|DKR_TIME
operator||
operator|(
name|dkt_tmr
index|[
name|tp
operator|->
name|t_ispeed
index|]
operator|<<
literal|8
operator|)
argument_list|,
name|dktrcv
argument_list|,
operator|(
name|caddr_t
operator|)
name|tp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * stty/gtty for DKT  */
end_comment

begin_macro
name|dktioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tp
operator|=
operator|&
name|dkt
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
name|error
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CARR_ON
expr_stmt|;
if|if
condition|(
name|devDEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DKT_ioctl carr off\n"
argument_list|)
expr_stmt|;
name|gsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|gsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
name|dktxpack
argument_list|(
name|tp
operator|-
name|dkt
argument_list|,
name|D_BREAK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCCBRK
case|:
return|return
literal|0
return|;
block|}
return|return
name|ENOTTY
return|;
block|}
end_block

begin_comment
comment|/*  * Start (restart) transmission on the given DKT line.  */
end_comment

begin_expr_stmt
name|dktstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|d
expr_stmt|;
name|char
name|delay
decl_stmt|;
extern|extern dktxdun(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|nch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern ttrstrt(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|d
operator|=
name|tp
operator|-
name|dkt
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_if
if|if
condition|(
name|dk_status
argument_list|(
name|d
argument_list|)
operator|&
name|DK_SPND
condition|)
name|dk_cmd
argument_list|(
name|d
argument_list|,
name|DKC_RSME
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_BUSY
operator||
name|TS_TTSTOP
operator||
name|TS_TIMEOUT
operator|)
condition|)
goto|goto
name|out
goto|;
end_if

begin_comment
comment|/* 	 * If the writer was sleeping on output overflow, 	 * wake the process when low tide is reached. 	 */
end_comment

begin_if
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|TTLOWAT
argument_list|(
name|tp
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_wsel
condition|)
block|{
name|selwakeup
argument_list|(
name|tp
operator|->
name|t_wsel
argument_list|,
name|tp
operator|->
name|t_state
operator|&
name|TS_WCOLL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_wsel
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_WCOLL
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* 	 * Now restart transmission unless the output queue is 	 * empty. 	 */
end_comment

begin_if
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
end_if

begin_expr_stmt
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|DKMT_OTTY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* No buffers; arrange to retry in .5 seconds */
name|dktpaused
index|[
name|d
index|]
operator|++
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_TIMEOUT
expr_stmt|;
name|timeout
argument_list|(
name|ttrstrt
argument_list|,
operator|(
name|caddr_t
operator|)
name|tp
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
end_if

begin_if
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator|)
condition|)
name|nch
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|nch
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0200
argument_list|)
expr_stmt|;
comment|/* 		 * If first thing on queue is a delay process it. 		 */
if|if
condition|(
name|nch
operator|==
literal|0
condition|)
block|{
name|nch
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|c
operator|=
name|MIN
argument_list|(
operator|(
name|nch
operator|&
literal|0xff
operator|)
operator|+
literal|6
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
name|delay
operator|=
name|D_DELAY
expr_stmt|;
if|if
condition|(
name|tpDEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DKT_delay %d\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
condition|)
block|{
name|delay
operator|++
expr_stmt|;
name|c
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dk_xmit
argument_list|(
name|d
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|delay
argument_list|,
name|dktxdun
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
end_if

begin_comment
comment|/* 	 * If characters to transmit, restart transmission. 	 */
end_comment

begin_if
if|if
condition|(
name|nch
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tp
operator|->
name|t_outq
operator|.
name|c_cf
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|nch
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|nch
expr_stmt|;
if|if
condition|(
name|dk_xmit
argument_list|(
name|d
argument_list|,
name|m
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|dktxdun
argument_list|,
operator|(
name|caddr_t
operator|)
name|nch
argument_list|)
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
end_if

begin_label
name|out
label|:
end_label

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  dktxpack
operator|(
name|chan
operator|,
name|cmd
operator|)
name|char
name|cmd
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|dk_xmit
argument_list|(
name|chan
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|cmd
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanDEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DKT_sent %o on %d\n"
argument_list|,
name|cmd
operator|&
literal|0377
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|dktstop
argument_list|(
name|tp
argument_list|,
name|rw
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|,
name|d
decl_stmt|;
name|d
operator|=
name|tp
operator|-
name|dkt
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
name|dk_cmd
argument_list|(
name|d
argument_list|,
name|DKC_SPND
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
name|dk_cmd
argument_list|(
name|d
argument_list|,
name|DKC_FLUSH
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dktshut
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|tpDEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dktshut %d\n"
argument_list|,
name|tp
operator|-
name|dkt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
block|{
if|if
condition|(
name|tpDEBUG
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DKT_sighup %d\n"
argument_list|,
name|tp
operator|->
name|t_pgrp
argument_list|)
expr_stmt|;
name|gsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|gsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CARR_ON
expr_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
argument_list|)
expr_stmt|;
name|dk_cmd
argument_list|(
operator|(
name|tp
operator|-
name|dkt
operator|)
argument_list|,
name|DKC_FLUSH
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dktxdun
argument_list|(
argument|cnt
argument_list|,
argument|chan
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|dkt
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_FLUSH
expr_stmt|;
else|else
name|ndflush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_line
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
else|else
name|dktstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

