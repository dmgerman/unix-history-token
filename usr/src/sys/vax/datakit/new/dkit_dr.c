begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Datakit driver  * DR11C version without KMC  *  * uses mbufs for transmission  *  *	SCCSID[] = "@(#)dkit_dr.c	1.5 Garage 84/04/11"  */
end_comment

begin_include
include|#
directive|include
file|"dkitdr.h"
end_include

begin_if
if|#
directive|if
name|NDKITDR
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"datakit.h"
end_include

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_include
include|#
directive|include
file|"dk.h"
end_include

begin_include
include|#
directive|include
file|"dkit.h"
end_include

begin_include
include|#
directive|include
file|"dkdr.h"
end_include

begin_define
define|#
directive|define
name|PKBHOG
value|64
end_define

begin_comment
comment|/* max temp buffers per channel	*/
end_comment

begin_define
define|#
directive|define
name|DKNPKB
value|(200+4*NDATAKIT)
end_define

begin_define
define|#
directive|define
name|DKNSTB
value|10
end_define

begin_decl_stmt
name|struct
name|dkchan
name|dkit
index|[
name|NDATAKIT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|dk_nchan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dkdr_npk
init|=
name|DKNPKB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dkpkbufr
name|dk_pkbuf
index|[
name|DKNPKB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dkdr_nstat
init|=
name|DKNSTB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dkstat
name|dkdr_stat
index|[
name|DKNSTB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dkattached
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is it really there? */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KALYPSO
end_ifdef

begin_define
define|#
directive|define
name|URPDEBUG
value|5000
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|URPDEBUG
value|500
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|URPDEBUG
end_ifdef

begin_decl_stmt
name|int
name|dkurpdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|URPTRACE
parameter_list|(
name|chan
parameter_list|,
name|chr
parameter_list|,
name|Dkp
parameter_list|)
value|if (dkurpdebug == (chan)) \ 	dkurptrace(chr, Dkp);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * structure of data in first mbuf on chain (type DKM_HDR)  *  */
end_comment

begin_struct
struct|struct
name|mpacket
block|{
name|short
name|mp_len
decl_stmt|;
comment|/* Total length left */
name|char
name|mp_ctl
decl_stmt|;
comment|/* Control character */
name|int
name|mp_eob
decl_stmt|;
comment|/* Send end-of-block indicator */
name|int
function_decl|(
modifier|*
name|mp_endfcn
function_decl|)
parameter_list|()
function_decl|;
comment|/* End-action function */
name|caddr_t
name|mp_endparm
decl_stmt|;
comment|/* Parameter to above function */
block|}
struct|;
end_struct

begin_comment
comment|/*  *	dr11-c bit definitions  */
end_comment

begin_define
define|#
directive|define
name|DKTENAB
value|0100
end_define

begin_comment
comment|/* transmit interrupt enable */
end_comment

begin_define
define|#
directive|define
name|DKRENAB
value|040
end_define

begin_comment
comment|/* receiver interrupt enable */
end_comment

begin_define
define|#
directive|define
name|ENABS
value|0140
end_define

begin_comment
comment|/* both enables */
end_comment

begin_define
define|#
directive|define
name|DKCOM
value|03
end_define

begin_comment
comment|/* dr11-c command bits */
end_comment

begin_define
define|#
directive|define
name|DKTDONE
value|0200
end_define

begin_comment
comment|/* transmit done bit */
end_comment

begin_define
define|#
directive|define
name|DKRDONE
value|0100000
end_define

begin_comment
comment|/* receiver done bit */
end_comment

begin_define
define|#
directive|define
name|DKMARK
value|01000
end_define

begin_comment
comment|/* start of packet bit */
end_comment

begin_define
define|#
directive|define
name|DKOVF
value|040000
end_define

begin_comment
comment|/* receiver overflow bit (in drin) */
end_comment

begin_define
define|#
directive|define
name|DKDATA
value|0400
end_define

begin_comment
comment|/* bit 9 ... indicates non-control */
end_comment

begin_define
define|#
directive|define
name|DKCHUNK
value|16
end_define

begin_comment
comment|/* packet size */
end_comment

begin_comment
comment|/*   * dr11c commands  */
end_comment

begin_define
define|#
directive|define
name|D_OSEQ
value|0
end_define

begin_define
define|#
directive|define
name|D_READ
value|1
end_define

begin_define
define|#
directive|define
name|D_WRITE
value|2
end_define

begin_define
define|#
directive|define
name|D_XPACK
value|3
end_define

begin_comment
comment|/*  *   error control protocol definitions  */
end_comment

begin_define
define|#
directive|define
name|SEQ
value|0010
end_define

begin_comment
comment|/* 8 sequence numbers to end trailers */
end_comment

begin_define
define|#
directive|define
name|ECHO
value|0020
end_define

begin_comment
comment|/* 8 echoes, data given to host */
end_comment

begin_define
define|#
directive|define
name|REJ
value|0030
end_define

begin_comment
comment|/* 8 rejections, transmission error */
end_comment

begin_define
define|#
directive|define
name|ACK
value|0040
end_define

begin_comment
comment|/* first of 8 acks, correct reception */
end_comment

begin_define
define|#
directive|define
name|BOT
value|0050
end_define

begin_comment
comment|/* normal beginning of trailer */
end_comment

begin_define
define|#
directive|define
name|BOTM
value|0051
end_define

begin_comment
comment|/* trailer with more data to follow */
end_comment

begin_define
define|#
directive|define
name|BOTS
value|0052
end_define

begin_comment
comment|/* seq update algorithm on this trailer */
end_comment

begin_define
define|#
directive|define
name|SOI
value|0053
end_define

begin_comment
comment|/* start of interrupt trailer */
end_comment

begin_define
define|#
directive|define
name|EOI
value|0054
end_define

begin_comment
comment|/* end of interrupt trailer */
end_comment

begin_define
define|#
directive|define
name|ENQ
value|0055
end_define

begin_comment
comment|/* xmitter request flow/error status */
end_comment

begin_define
define|#
directive|define
name|CHECK
value|0056
end_define

begin_comment
comment|/* xmitter request error status */
end_comment

begin_define
define|#
directive|define
name|INITREQ
value|0057
end_define

begin_comment
comment|/* request initialization */
end_comment

begin_define
define|#
directive|define
name|INIT0
value|0060
end_define

begin_comment
comment|/* disable trailer processing */
end_comment

begin_define
define|#
directive|define
name|INIT1
value|0061
end_define

begin_comment
comment|/* enable trailer processing */
end_comment

begin_define
define|#
directive|define
name|AINIT
value|0062
end_define

begin_comment
comment|/* response to INIT0/INIT1 */
end_comment

begin_define
define|#
directive|define
name|DKBMASK
value|03
end_define

begin_comment
comment|/* this xmitter has window size of 4,  */
end_comment

begin_comment
comment|/* #define	DKBLOCK		60	/* each message is 60 bytes            */
end_comment

begin_define
define|#
directive|define
name|DKBLOCK
value|28
end_define

begin_comment
comment|/* each message is 60 bytes            */
end_comment

begin_comment
comment|/*  *   some commonly used macros  */
end_comment

begin_decl_stmt
name|struct
name|dkpkbufr
modifier|*
name|dk_Sfree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|dkdr_npk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|dkpkbufr
name|dk_pkbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dknopkb
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter for 'no dkpkbufr' condition.	*/
end_comment

begin_decl_stmt
name|int
name|dkstray
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of stray interrupts since last timeout */
end_comment

begin_decl_stmt
name|int
name|dkdrlostint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lost receiver interrupts */
end_comment

begin_decl_stmt
name|int
name|dkdisabled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag to indicate that DK interface has been disabled 			due to stray interrupts, etc. */
end_comment

begin_define
define|#
directive|define
name|MAX_STRAY
value|10
end_define

begin_comment
comment|/* maximum number of stray interrupts 				before temporarily disabling DK interrupts */
end_comment

begin_comment
comment|/*  * dr11c device registers  */
end_comment

begin_struct
struct|struct
name|rdevice
block|{
name|short
name|dkcsr
decl_stmt|;
name|short
name|dko
decl_stmt|;
name|short
name|dki
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|dkdr_nstat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|dkstat
name|dkdr_stat
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Hstat
decl_stmt|,
name|Tstat
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DKADDR
value|((struct rdevice *) dkitdrdinfo[0]->ui_addr)
end_define

begin_comment
comment|/*  * Intermediate level command codes  */
end_comment

begin_define
define|#
directive|define
name|KS_SEND
value|20
end_define

begin_define
define|#
directive|define
name|KS_RDB
value|21
end_define

begin_define
define|#
directive|define
name|KS_EOI
value|22
end_define

begin_define
define|#
directive|define
name|KS_CNTL
value|23
end_define

begin_define
define|#
directive|define
name|KS_ERR
value|24
end_define

begin_decl_stmt
name|int
name|dkdebug
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dkactive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timeron
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dkitdrprobe
argument_list|()
decl_stmt|,
name|dkitdrattach
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|dkitdrdinfo
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|dkitdrstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|dkitdrdriver
init|=
block|{
name|dkitdrprobe
block|,
literal|0
block|,
name|dkitdrattach
block|,
literal|0
block|,
name|dkitdrstd
block|,
literal|"dkitdr"
block|,
name|dkitdrdinfo
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|dkitdrprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* value-result */
specifier|register
name|struct
name|rdevice
modifier|*
name|draddr
init|=
operator|(
expr|struct
name|rdevice
operator|*
operator|)
name|reg
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|dkdrrint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dkdrxint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|draddr
operator|->
name|dkcsr
operator|=
name|D_READ
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|draddr
operator|->
name|dkcsr
operator|&
name|DKRDONE
condition|)
name|c
operator|=
name|draddr
operator|->
name|dki
expr_stmt|;
else|else
break|break;
ifdef|#
directive|ifdef
name|lint
name|c
operator|=
name|c
expr_stmt|;
endif|#
directive|endif
name|draddr
operator|->
name|dkcsr
operator|=
name|D_WRITE
expr_stmt|;
name|draddr
operator|->
name|dko
operator|=
name|DKMARK
operator||
operator|(
name|dk_nchan
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* pack on 511 */
name|draddr
operator|->
name|dkcsr
operator|=
name|D_XPACK
operator|+
name|DKTENAB
expr_stmt|;
name|draddr
operator|->
name|dko
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|draddr
operator|->
name|dkcsr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|rdevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|dkitdrattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dkattached
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|NDKI
operator|>
literal|0
name|dkiattach
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
specifier|static
name|dk_init
argument_list|()
block|{
specifier|register
expr|struct
name|rdevice
operator|*
name|raddr
operator|=
name|DKADDR
block|;
specifier|register
name|s
block|;
comment|/* 	 *  At attach time for the hardware device 	 *  initialize and check things out to the 	 *  (grumble) limited extent that is possible. 	 */
name|s
operator|=
name|spl5
argument_list|()
block|;
name|Hstat
operator|=
name|Tstat
operator|=
literal|0
block|;
name|dkdisabled
operator|=
literal|0
block|;
name|dkstray
operator|=
literal|0
block|;
block|{
specifier|register
expr|struct
name|dkchan
operator|*
name|dkp
block|;
for|for
control|(
name|dkp
operator|=
operator|&
name|dkit
index|[
literal|0
index|]
init|;
name|dkp
operator|<
operator|&
name|dkit
index|[
name|dk_nchan
index|]
condition|;
name|dkp
operator|++
control|)
block|{
name|dkp
operator|->
name|dk_rlen
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_xlen
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_X
operator|=
name|XM_OFF
expr_stmt|;
name|dkp
operator|->
name|dk_rq
operator|=
name|NULL
expr_stmt|;
name|dkp
operator|->
name|dk_outq
operator|.
name|ifq_len
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_outq
operator|.
name|ifq_maxlen
operator|=
literal|20
expr_stmt|;
name|dkp
operator|->
name|dk_outq
operator|.
name|ifq_drops
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_outq
operator|.
name|ifq_head
operator|=
name|NULL
expr_stmt|;
name|dkp
operator|->
name|dk_outq
operator|.
name|ifq_tail
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|{
specifier|register
expr|struct
name|dkpkbufr
operator|*
name|pkb
block|;
for|for
control|(
name|pkb
operator|=
operator|&
name|dk_pkbuf
index|[
literal|1
index|]
init|;
name|pkb
operator|<
operator|&
name|dk_pkbuf
index|[
name|dkdr_npk
operator|-
literal|1
index|]
condition|;
name|pkb
operator|++
control|)
block|{
name|pkb
operator|->
name|Pnext
operator|=
name|pkb
operator|+
literal|1
expr_stmt|;
block|}
name|dk_pkbuf
index|[
name|dkdr_npk
operator|-
literal|1
index|]
operator|.
name|Pnext
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dk_Sfree
operator|=
operator|&
name|dk_pkbuf
index|[
literal|1
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dk_pkbuf
index|[
literal|0
index|]
operator|.
name|Pnext
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_decl_stmt
unit|} {
specifier|register
name|int
name|seq
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|raddr
operator|->
name|dkcsr
operator|=
name|D_OSEQ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dko
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* clears all FIFO's */
end_comment

begin_expr_stmt
name|seq
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|raddr
operator|->
name|dkcsr
operator|&
name|DKTDONE
condition|)
block|{
name|seq
operator|+=
operator|(
operator|(
operator|(
name|raddr
operator|->
name|dki
operator|)
operator|>>
literal|10
operator|)
operator|&
literal|017
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|seq
operator|>
literal|100
condition|)
block|{
name|dkreport
argument_list|(
name|KS_ERR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
block|}
end_while

begin_expr_stmt
name|raddr
operator|->
name|dkcsr
operator|=
name|D_READ
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|raddr
operator|->
name|dkcsr
operator|&
name|DKRDONE
condition|)
name|c
operator|=
name|raddr
operator|->
name|dki
expr_stmt|;
else|else
break|break;
end_for

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_expr_stmt
name|c
operator|=
name|c
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|} 	raddr
operator|->
name|dkcsr
operator|=
name|ENABS
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|timeron
condition|)
block|{
name|dk_timeout
argument_list|()
expr_stmt|;
name|timeron
operator|++
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dkactive
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
unit|dkitreset
operator|(
name|uban
operator|)
name|int
name|uban
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rdevice
modifier|*
name|raddr
decl_stmt|;
name|raddr
operator|=
name|DKADDR
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|ENABS
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|" dkit_dr%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dk_open
argument_list|(
name|chan
argument_list|,
name|supfcn
argument_list|)
specifier|register
name|chan
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|supfcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
specifier|register
name|s
expr_stmt|;
extern|extern 	dkkint(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|firsttime
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|init
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|int
name|commchan
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|chan
operator|>=
name|dk_nchan
operator|||
operator|!
name|dkattached
condition|)
return|return
operator|-
name|ENXIO
return|;
end_if

begin_if
if|if
condition|(
name|firsttime
condition|)
block|{
if|if
condition|(
operator|(
name|init
operator|=
name|dk_init
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
name|init
return|;
name|firsttime
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Channel 0 (0-3 in ISN) is reserved for maintenance. 	 * An open on channel 0 is interpreted as a request 	 * for an unused channel.  Channel 1 (4 in ISN or RADIAN) 	 * is the common supervisory channel. 	 */
end_comment

begin_if
if|if
condition|(
name|chan
operator|==
literal|0
condition|)
block|{
name|chan
operator|=
name|commchan
operator|+
literal|1
expr_stmt|;
comment|/* Start above commchan */
while|while
condition|(
literal|1
condition|)
block|{
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_state
operator|==
literal|0
condition|)
break|break ;
name|chan
operator|++
expr_stmt|;
if|if
condition|(
name|chan
operator|>=
name|dk_nchan
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
name|EADDRNOTAVAIL
return|;
block|}
block|}
block|}
end_if

begin_comment
comment|/* 	 * Finish setting up dkp struct. 	 */
end_comment

begin_if
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkopen %d: %x\n"
argument_list|,
name|chan
argument_list|,
name|supfcn
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_S
operator|=
literal|1
expr_stmt|;
name|dkp
operator|->
name|dk_R
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_X
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_A
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_rejcnt
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_srejcnt
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_ackrejcnt
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_enqcnt
operator|=
literal|0
expr_stmt|;
name|dksend
argument_list|(
name|chan
argument_list|,
name|INIT1
argument_list|)
expr_stmt|;
name|flushall
argument_list|(
name|dkp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
name|DK_LINGR
expr_stmt|;
name|dkp
operator|->
name|dk_state
operator||=
name|DK_OPEN
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|dkp
operator|->
name|dk_supfcn
operator|=
name|supfcn
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|chan
return|;
end_return

begin_comment
unit|}
comment|/*  * Close a channel:  */
end_comment

begin_expr_stmt
unit|dk_close
operator|(
name|chan
operator|)
block|{
specifier|register
expr|struct
name|dkchan
operator|*
name|dkp
block|;
specifier|register
name|s
block|;
name|s
operator|=
name|spl5
argument_list|()
block|;
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkclose %d\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|chan
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|dkattached
condition|)
return|return
operator|-
name|ENXIO
return|;
for|for
control|(
name|dkp
operator|=
operator|&
name|dkit
index|[
literal|1
index|]
init|;
name|dkp
operator|<
operator|&
name|dkit
index|[
name|dk_nchan
index|]
condition|;
name|dkp
operator|++
control|)
block|{
if|if
condition|(
name|dkp
operator|->
name|dk_state
operator|&
operator|(
name|DK_OPEN
operator||
name|DK_BUSY
operator||
name|DK_RCV
operator|)
condition|)
block|{
name|dkp
operator|->
name|dk_state
operator||=
name|DK_RESET
expr_stmt|;
name|flushall
argument_list|(
name|dkp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|dkactive
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|dk_init
argument_list|()
return|;
block|}
else|else
block|{
name|dkp
operator|->
name|dk_state
operator||=
name|DK_OPEN
expr_stmt|;
name|flushall
argument_list|(
name|dkp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_state
operator|=
name|DK_LINGR
expr_stmt|;
name|dkp
operator|->
name|dk_X
operator|=
name|XM_OFF
expr_stmt|;
name|dkp
operator|->
name|dk_trmode
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/*  *	Close phase 2 - mark available for reassignment  */
end_comment

begin_expr_stmt
unit|dk_free
operator|(
name|chan
operator|)
block|{
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkfree %d\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|dkit
index|[
name|chan
index|]
operator|.
name|dk_state
operator|&=
operator|~
name|DK_LINGR
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  *	Reset a channel  *	 prevents further I/O until close  */
end_comment

begin_expr_stmt
unit|dk_reset
operator|(
name|chan
operator|)
block|{
specifier|register
expr|struct
name|dkchan
operator|*
name|dkp
block|;
specifier|register
name|s
block|;
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkreset %d\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dkp
operator|->
name|dk_state
operator||=
name|DK_RESET
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|flushall
argument_list|(
name|dkp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  *	Xmit a short control (interrupt) packet  */
end_comment

begin_expr_stmt
unit|dk_xint
operator|(
name|chan
operator|,
name|intr
operator|)
block|{
specifier|register
expr|struct
name|rdevice
operator|*
name|raddr
block|;
specifier|register
name|s
block|;
specifier|register
expr|struct
name|dkchan
operator|*
name|dkp
block|;
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
block|;
if|if
condition|(
name|chan
operator|==
literal|0
operator|||
name|dkp
operator|->
name|dk_X
operator|<
name|XM_INIT
condition|)
return|return
operator|-
literal|1
return|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkxint %d: %o %o\n"
argument_list|,
name|chan
argument_list|,
operator|(
name|intr
operator|&
literal|0377
operator|)
argument_list|,
operator|(
operator|(
name|intr
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|raddr
operator|=
name|DKADDR
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dkcsr
operator|=
name|D_WRITE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dko
operator|=
name|chan
operator||
name|DKMARK
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dko
operator|=
name|SOI
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dko
operator|=
operator|(
name|intr
operator|&
literal|0377
operator|)
operator||
name|DKDATA
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dko
operator|=
operator|(
operator|(
name|intr
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator||
name|DKDATA
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dko
operator|=
name|EOI
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dkcsr
operator|=
name|D_XPACK
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dko
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dkdisabled
condition|)
name|raddr
operator|->
name|dko
operator|=
literal|0
expr_stmt|;
else|else
name|raddr
operator|->
name|dko
operator|=
name|ENABS
expr_stmt|;
end_if

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/*  * Adjust window size  */
end_comment

begin_expr_stmt
unit|dk_winsize
operator|(
name|chan
operator|,
name|win
operator|)
expr|struct
name|diocxwin
name|win
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|EINVAL
return|;
comment|/* For now... */
block|}
end_block

begin_comment
comment|/*  * Xmit data on a channel  *   NOTE * * * * *  *	Although it is never checked here, buffer addresses  *    in this version of the driver must be kernel addressable.  */
end_comment

begin_macro
name|dk_xmit
argument_list|(
argument|chan
argument_list|,
argument|m
argument_list|,
argument|eob
argument_list|,
argument|ctlchar
argument_list|,
argument|endfcn
argument_list|,
argument|endparm
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|endfcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|caddr_t
name|endparm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
specifier|register
name|struct
name|mpacket
modifier|*
name|mbp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_RESET
operator|)
operator|||
operator|(
name|mb
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|DKMT_HDR
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ctlchar
operator|==
literal|'\001'
condition|)
name|eob
operator|=
literal|0
expr_stmt|;
name|mb
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|mbp
operator|=
name|mtod
argument_list|(
name|mb
argument_list|,
expr|struct
name|mpacket
operator|*
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|mp_endfcn
operator|=
name|endfcn
expr_stmt|;
name|mbp
operator|->
name|mp_endparm
operator|=
name|endparm
expr_stmt|;
name|mbp
operator|->
name|mp_eob
operator|=
name|eob
expr_stmt|;
name|mb
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|mbp
operator|->
name|mp_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|DKMT_DATA
operator|&&
name|m
operator|->
name|m_type
operator|!=
name|DKMT_CTL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dk_xmit %d: got type %x\n"
argument_list|,
name|chan
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|mbp
operator|->
name|mp_len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ctlchar
operator|&
literal|0300
operator|)
operator|==
literal|0100
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
init|=
name|mb
decl_stmt|,
modifier|*
name|mc
decl_stmt|;
name|mc
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|DKMT_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|mtod
argument_list|(
name|mc
argument_list|,
name|char
operator|*
argument_list|)
operator|=
name|ctlchar
expr_stmt|;
name|mc
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
comment|/* Append it -- can't use m_cat because type field counts */
while|while
condition|(
name|n
operator|->
name|m_next
condition|)
name|n
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|mc
expr_stmt|;
name|mbp
operator|->
name|mp_len
operator|++
expr_stmt|;
name|ctlchar
operator|=
literal|0
expr_stmt|;
block|}
name|mbp
operator|->
name|mp_ctl
operator|=
name|ctlchar
expr_stmt|;
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|dkp
operator|->
name|dk_state
operator||=
name|DK_BUSY
expr_stmt|;
name|dkp
operator|->
name|dk_curout
operator|=
name|mb
expr_stmt|;
name|dkp
operator|->
name|dk_xlen
operator|=
name|mbp
operator|->
name|mp_len
expr_stmt|;
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"xmit %d: %x len %d\n"
argument_list|,
name|chan
argument_list|,
name|mb
operator|->
name|m_next
argument_list|,
name|mbp
operator|->
name|mp_len
argument_list|)
expr_stmt|;
name|dkxmit
argument_list|(
name|dkp
argument_list|,
name|chan
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|dkp
operator|->
name|dk_state
return|;
block|}
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|dkp
operator|->
name|dk_outq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|dkp
operator|->
name|dk_outq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
operator|&
name|dkp
operator|->
name|dk_outq
argument_list|,
name|mb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|dkp
operator|->
name|dk_state
return|;
block|}
end_block

begin_comment
comment|/*  * Receive into a block buffer  */
end_comment

begin_macro
name|dk_recv
argument_list|(
argument|chan
argument_list|,
argument|addr
argument_list|,
argument|len
argument_list|,
argument|mode
argument_list|,
argument|endfcn
argument_list|,
argument|endparm
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|endfcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|caddr_t
name|endparm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
specifier|register
name|s
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dk_recv: channel %d endfcn %x: invalid address specification\n"
argument_list|,
name|chan
argument_list|,
name|endfcn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_state
operator|&
operator|(
name|DK_RCV
operator||
name|DK_RESET
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dkp
operator|->
name|dk_state
operator||=
name|DK_RCV
expr_stmt|;
name|dkp
operator|->
name|dk_endfcn
operator|=
name|endfcn
expr_stmt|;
name|dkp
operator|->
name|dk_endparm
operator|=
name|endparm
expr_stmt|;
name|dkp
operator|->
name|dk_rmode
operator|=
name|mode
expr_stmt|;
name|dkp
operator|->
name|dk_rlen
operator|=
name|len
expr_stmt|;
name|dkp
operator|->
name|dk_raddr
operator|=
operator|(
name|caddr_t
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkrecv %d: %x len %d mode %o\n"
argument_list|,
name|chan
argument_list|,
operator|(
name|caddr_t
operator|)
name|addr
argument_list|,
name|len
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|dkrcv
argument_list|(
name|dkp
argument_list|,
name|chan
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|dkp
operator|->
name|dk_state
return|;
block|}
end_block

begin_macro
name|dk_rabort
argument_list|(
argument|chan
argument_list|,
argument|nendfcn
argument_list|,
argument|nendparm
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|nendfcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|caddr_t
name|nendparm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
specifier|register
name|s
expr_stmt|;
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_RCV
condition|)
block|{
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
name|DK_RCV
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_rlen
condition|)
block|{
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rcvabo %d: rlen %d\n"
argument_list|,
name|chan
argument_list|,
name|dkp
operator|->
name|dk_rlen
argument_list|)
expr_stmt|;
call|(
modifier|*
name|nendfcn
call|)
argument_list|(
name|nendparm
argument_list|,
name|chan
argument_list|,
name|dkp
operator|->
name|dk_rlen
argument_list|,
name|DKR_ABORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dkp
operator|->
name|dk_rlen
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|dkp
operator|->
name|dk_state
return|;
block|}
end_block

begin_macro
name|dk_status
argument_list|(
argument|chan
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|chan
operator|>=
name|dk_nchan
condition|)
return|return
literal|0
return|;
return|return
name|dkit
index|[
name|chan
index|]
operator|.
name|dk_state
return|;
block|}
end_block

begin_macro
name|dk_timeout
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|rdevice
modifier|*
name|raddr
decl_stmt|;
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
specifier|register
name|chan
expr_stmt|;
name|int
name|s
init|=
name|spl5
argument_list|()
decl_stmt|;
name|chan
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dkp
operator|=
operator|&
name|dkit
index|[
literal|0
index|]
init|;
name|dkp
operator|<
operator|&
name|dkit
index|[
name|dk_nchan
index|]
condition|;
name|dkp
operator|++
control|)
block|{
if|if
condition|(
name|dkp
operator|->
name|dk_X
operator|!=
name|XM_OFF
condition|)
block|{
if|if
condition|(
name|dkp
operator|->
name|dk_X
operator|==
literal|0
condition|)
name|dksend
argument_list|(
name|chan
argument_list|,
name|INIT1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dkp
operator|->
name|dk_S
operator|!=
operator|(
operator|(
name|dkp
operator|->
name|dk_R
operator|+
literal|1
operator|)
operator|&
literal|07
operator|)
condition|)
block|{
if|if
condition|(
name|dkp
operator|->
name|dk_X
operator|&
name|XM_ENQ
condition|)
block|{
name|dksend
argument_list|(
name|chan
argument_list|,
name|ENQ
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_X
operator|&=
operator|~
name|XM_REJ
expr_stmt|;
name|dkp
operator|->
name|dk_enqcnt
operator|++
expr_stmt|;
name|URPTRACE
argument_list|(
name|chan
argument_list|,
name|ENQ
argument_list|,
name|dkp
argument_list|)
expr_stmt|;
block|}
else|else
name|dkp
operator|->
name|dk_X
operator||=
name|XM_ENQ
expr_stmt|;
block|}
block|}
name|chan
operator|++
expr_stmt|;
block|}
name|dkstray
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dkdisabled
condition|)
block|{
if|if
condition|(
name|dkdisabled
operator|++
operator|>
literal|10
condition|)
block|{
comment|/* try re-enabling interrupts */
name|dkdisabled
operator|=
literal|0
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"re-enabling DK interface\n"
argument_list|)
expr_stmt|;
name|raddr
operator|=
name|DKADDR
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|ENABS
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Look for lost interrupts */
if|if
condition|(
name|raddr
operator|->
name|dkcsr
operator|<
literal|0
condition|)
block|{
name|dkdrlostint
operator|++
expr_stmt|;
name|dkdrxint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|timeout
argument_list|(
name|dk_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
literal|1
operator|*
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dk_cmd
argument_list|(
argument|chan
argument_list|,
argument|cmd
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
name|int
name|s
init|=
name|spl5
argument_list|()
decl_stmt|;
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkcmd %d: %o\n"
argument_list|,
name|chan
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
name|DKC_XINIT
condition|)
block|{
name|dkp
operator|->
name|dk_X
operator|=
name|dkp
operator|->
name|dk_R
operator|=
name|dkp
operator|->
name|dk_A
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_S
operator|=
literal|1
expr_stmt|;
name|dksend
argument_list|(
name|chan
argument_list|,
name|INIT1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|&
name|DKC_FLUSH
condition|)
block|{
name|flushall
argument_list|(
name|dkp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|&
name|DKC_SPND
condition|)
name|dkp
operator|->
name|dk_state
operator||=
name|DK_SPND
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
name|DKC_RSME
condition|)
block|{
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
name|DK_SPND
expr_stmt|;
name|dkxmit
argument_list|(
name|dkp
argument_list|,
name|chan
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|flushall
argument_list|(
name|dkp
argument_list|,
name|rwflag
argument_list|)
specifier|register
expr|struct
name|dkchan
operator|*
name|dkp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|s
expr_stmt|;
name|struct
name|mpacket
modifier|*
name|mbp
decl_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_RCV
operator|)
operator|&&
operator|(
name|rwflag
operator|>=
literal|0
operator|)
condition|)
block|{
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
name|DK_RCV
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_endfcn
condition|)
call|(
modifier|*
name|dkp
operator|->
name|dk_endfcn
call|)
argument_list|(
name|dkp
operator|->
name|dk_endparm
argument_list|,
name|dkp
operator|-
name|dkit
argument_list|,
name|dkp
operator|->
name|dk_rlen
argument_list|,
name|DKR_ABORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_rlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_BUSY
operator|)
operator|&&
operator|(
name|rwflag
operator|<=
literal|0
operator|)
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|dkp
operator|->
name|dk_xlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_curout
condition|)
block|{
name|mbp
operator|=
name|mtod
argument_list|(
name|dkp
operator|->
name|dk_curout
argument_list|,
expr|struct
name|mpacket
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbp
operator|->
name|mp_endfcn
condition|)
call|(
name|mbp
operator|->
name|mp_endfcn
call|)
argument_list|(
name|mbp
operator|->
name|mp_endparm
argument_list|,
name|dkp
operator|-
name|dkit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dkp
operator|->
name|dk_curout
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_curout
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|dkp
operator|->
name|dk_outq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
break|break;
name|mbp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|mpacket
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbp
operator|->
name|mp_endfcn
condition|)
call|(
name|mbp
operator|->
name|mp_endfcn
call|)
argument_list|(
name|mbp
operator|->
name|mp_endparm
argument_list|,
name|dkp
operator|-
name|dkit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
name|DK_BUSY
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_OPEN
operator|)
operator|&&
operator|(
name|rwflag
operator|>=
literal|0
operator|)
condition|)
block|{
specifier|register
name|struct
name|dkpkbufr
modifier|*
name|dbp
decl_stmt|;
name|dkp
operator|->
name|dk_rlen
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_xlen
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_C
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dbp
operator|=
name|dkp
operator|->
name|dk_rq
condition|)
block|{
name|dkp
operator|->
name|dk_rq
operator|=
name|dbp
operator|->
name|Pnext
expr_stmt|;
name|dbp
operator|->
name|Pnext
operator|=
name|dk_Sfree
expr_stmt|;
name|dk_Sfree
operator|=
name|dbp
expr_stmt|;
block|}
while|while
condition|(
name|dbp
operator|=
name|dkp
operator|->
name|dk_rb
condition|)
block|{
name|dkp
operator|->
name|dk_rb
operator|=
name|dbp
operator|->
name|Pnext
expr_stmt|;
name|dbp
operator|->
name|Pnext
operator|=
name|dk_Sfree
expr_stmt|;
name|dk_Sfree
operator|=
name|dbp
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Routine to handle completion status  */
end_comment

begin_expr_stmt
specifier|static
name|dkkint
argument_list|()
block|{
specifier|register
expr|struct
name|dkchan
operator|*
name|dkp
block|;
specifier|register
expr|struct
name|dkstat
operator|*
name|sp
block|;
specifier|register
name|chan
block|; struct
name|mbuf
operator|*
name|m
block|,
operator|*
name|om
block|; struct
name|mpacket
operator|*
name|mbp
block|;
specifier|static
name|char
operator|*
name|cmpltype
index|[]
operator|=
block|{
literal|"send"
block|,
literal|"rdb"
block|,
literal|"eoi"
block|,
literal|"cntl"
block|,
literal|"err"
block|}
block|;
while|while
condition|(
name|Tstat
operator|!=
name|Hstat
condition|)
block|{
name|sp
operator|=
operator|&
name|dkdr_stat
index|[
name|Hstat
index|]
expr_stmt|;
name|chan
operator|=
name|sp
operator|->
name|k_chan
expr_stmt|;
name|dkp
operator|=
operator|&
name|dkit
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|k_chan
operator|>
name|dkdebug
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|k_type
operator|>=
name|KS_SEND
operator|&&
name|sp
operator|->
name|k_type
operator|<=
name|KS_ERR
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkdone:  type %s chan %d info %o-%o\n"
argument_list|,
name|cmpltype
index|[
name|sp
operator|->
name|k_type
operator|-
name|KS_SEND
index|]
argument_list|,
name|sp
operator|->
name|k_chan
argument_list|,
name|sp
operator|->
name|k_info1
argument_list|,
name|sp
operator|->
name|k_info2
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkdone:  type %d chan %d info %o-%o\n"
argument_list|,
name|sp
operator|->
name|k_type
argument_list|,
name|sp
operator|->
name|k_chan
argument_list|,
name|sp
operator|->
name|k_info1
argument_list|,
name|sp
operator|->
name|k_info2
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|Hstat
operator|==
name|dkdr_nstat
operator|-
literal|1
condition|)
name|Hstat
operator|=
literal|0
expr_stmt|;
else|else
name|Hstat
operator|++
expr_stmt|;
end_if

begin_switch
switch|switch
condition|(
name|sp
operator|->
name|k_type
condition|)
block|{
case|case
name|KS_CNTL
case|:
if|if
condition|(
name|dkp
operator|->
name|dk_supfcn
condition|)
call|(
modifier|*
name|dkp
operator|->
name|dk_supfcn
call|)
argument_list|(
name|chan
argument_list|,
name|sp
operator|->
name|k_info1
argument_list|)
expr_stmt|;
break|break ;
case|case
name|KS_EOI
case|:
break|break ;
case|case
name|KS_SEND
case|:
name|om
operator|=
name|dkp
operator|->
name|dk_curout
expr_stmt|;
if|if
condition|(
name|om
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkk: xbufout\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|dkp
operator|->
name|dk_outq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
name|DK_BUSY
expr_stmt|;
name|dkp
operator|->
name|dk_curout
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|dkp
operator|->
name|dk_curout
operator|=
name|m
expr_stmt|;
name|mbp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|mpacket
operator|*
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_xlen
operator|=
name|mbp
operator|->
name|mp_len
expr_stmt|;
if|if
condition|(
name|chan
operator|>
name|dkdebug
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"xmiti %d: %x len %d\n"
argument_list|,
name|chan
argument_list|,
name|m
operator|->
name|m_next
argument_list|,
name|mbp
operator|->
name|mp_len
argument_list|)
expr_stmt|;
name|dkxmit
argument_list|(
name|dkp
argument_list|,
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mbp
operator|=
name|mtod
argument_list|(
name|om
argument_list|,
expr|struct
name|mpacket
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbp
operator|->
name|mp_endfcn
operator|!=
name|NULL
condition|)
call|(
name|mbp
operator|->
name|mp_endfcn
call|)
argument_list|(
name|mbp
operator|->
name|mp_endparm
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|om
argument_list|)
expr_stmt|;
break|break;
case|case
name|KS_RDB
case|:
name|dkp
operator|->
name|dk_state
operator|&=
operator|~
operator|(
name|DK_RCV
operator||
name|DK_RCVQ
operator|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|k_info2
operator|==
name|DKR_TIME
operator|&&
name|dkp
operator|->
name|dk_rlen
operator|==
literal|0
condition|)
break|break ;
comment|/* another coming later */
if|if
condition|(
name|dkp
operator|->
name|dk_rlen
condition|)
block|{
name|sp
operator|->
name|k_info1
operator|=
name|dkp
operator|->
name|dk_rlen
expr_stmt|;
name|dkp
operator|->
name|dk_rlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dkp
operator|->
name|dk_endfcn
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|dkp
operator|->
name|dk_endfcn
call|)
argument_list|(
name|dkp
operator|->
name|dk_endparm
argument_list|,
name|dkp
operator|-
name|dkit
argument_list|,
name|sp
operator|->
name|k_info1
argument_list|,
name|sp
operator|->
name|k_info2
operator|&
literal|0377
argument_list|,
operator|(
name|sp
operator|->
name|k_info2
operator|>>
literal|8
operator|)
operator|&
literal|0377
argument_list|)
expr_stmt|;
break|break;
case|case
name|KS_ERR
case|:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"err in dkit.c: chan - %d, code - %o\n"
argument_list|,
name|chan
argument_list|,
name|sp
operator|->
name|k_info1
argument_list|)
expr_stmt|;
break|break;
block|}
end_switch

begin_comment
comment|/* end switch */
end_comment

begin_comment
unit|}
comment|/* end while */
end_comment

begin_comment
unit|}
comment|/* static */
end_comment

begin_decl_stmt
name|int
name|dkxmitpanic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|dkxmit
argument_list|(
argument|dkp
argument_list|,
argument|stechan
argument_list|,
argument|intrpt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|rdevice
modifier|*
name|raddr
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|wtype
decl_stmt|;
name|short
name|pklen
decl_stmt|;
name|short
name|mlen
decl_stmt|,
name|unacked
decl_stmt|;
name|short
name|blklen
decl_stmt|;
name|unsigned
name|short
name|totlen
decl_stmt|;
name|struct
name|mpacket
modifier|*
name|mbp
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|short
name|scheck
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dkp
operator|->
name|dk_curout
operator|==
name|NULL
operator|||
name|stechan
operator|==
literal|0
condition|)
return|return ;
name|mbp
operator|=
name|mtod
argument_list|(
name|dkp
operator|->
name|dk_curout
argument_list|,
expr|struct
name|mpacket
operator|*
argument_list|)
expr_stmt|;
name|raddr
operator|=
name|DKADDR
expr_stmt|;
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_S
operator|&
name|DKBMASK
operator|)
operator|==
operator|(
name|dkp
operator|->
name|dk_R
operator|&
name|DKBMASK
operator|)
operator|||
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_SPND
operator|)
condition|)
goto|goto
name|ctlchk
goto|;
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_xlen
operator|||
operator|(
operator|(
name|mbp
operator|->
name|mp_ctl
operator|&
literal|0200
operator|)
operator|==
literal|0
operator|)
operator|)
operator|&&
name|dkp
operator|->
name|dk_X
operator|<
name|XM_INIT
condition|)
goto|goto
name|ctlchk
goto|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_S
operator|&
name|DKBMASK
operator|)
operator|==
operator|(
operator|(
name|dkp
operator|->
name|dk_R
operator|+
literal|1
operator|)
operator|&
name|DKBMASK
operator|)
condition|)
name|scheck
operator|=
literal|0
expr_stmt|;
else|else
name|scheck
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|unacked
operator|=
operator|(
operator|(
name|dkp
operator|->
name|dk_S
operator|-
name|dkp
operator|->
name|dk_A
operator|-
literal|1
operator|)
operator|&
literal|07
operator|)
operator|*
name|DKBLOCK
expr_stmt|;
name|mlen
operator|=
name|MIN
argument_list|(
name|unacked
argument_list|,
name|dkp
operator|->
name|dk_xlen
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|dkp
operator|->
name|dk_xlen
operator|-
name|mlen
expr_stmt|;
if|if
condition|(
name|totlen
operator|==
literal|0
condition|)
goto|goto
name|ctlchk
goto|;
comment|/* Skip over stuff sent but not acked */
for|for
control|(
name|m
operator|=
name|dkp
operator|->
name|dk_curout
operator|->
name|m_next
init|;
name|m
operator|&&
operator|(
name|mlen
operator|>
literal|0
operator|)
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
if|if
condition|(
name|mlen
operator|>
name|m
operator|->
name|m_len
condition|)
name|mlen
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
else|else
break|break;
while|while
condition|(
name|totlen
operator|&&
operator|(
operator|(
name|dkp
operator|->
name|dk_S
operator|^
name|dkp
operator|->
name|dk_R
operator|)
operator|&
name|DKBMASK
operator|)
condition|)
block|{
if|if
condition|(
name|dkxmitpanic
condition|)
name|panic
argument_list|(
literal|"dkxmit -- panic 1"
argument_list|)
expr_stmt|;
name|blklen
operator|=
name|MIN
argument_list|(
name|totlen
argument_list|,
name|DKBLOCK
argument_list|)
expr_stmt|;
name|pklen
operator|=
literal|0
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_WRITE
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
name|stechan
operator||
name|DKMARK
expr_stmt|;
while|while
condition|(
name|blklen
condition|)
block|{
if|if
condition|(
name|dkxmitpanic
condition|)
name|panic
argument_list|(
literal|"dkxmit -- panic 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"dkxmit mlen"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|mlen
expr_stmt|;
name|mlen
operator|=
name|MIN
argument_list|(
name|blklen
argument_list|,
name|m
operator|->
name|m_len
operator|-
name|mlen
argument_list|)
expr_stmt|;
name|blklen
operator|-=
name|mlen
expr_stmt|;
name|wtype
operator|=
operator|(
name|m
operator|->
name|m_type
operator|==
name|DKMT_CTL
condition|?
literal|0
else|:
name|DKDATA
operator|)
expr_stmt|;
while|while
condition|(
name|mlen
operator|--
condition|)
block|{
if|if
condition|(
name|dkxmitpanic
condition|)
name|panic
argument_list|(
literal|"dkxmit -- panic 3"
argument_list|)
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
operator|(
operator|*
name|ptr
operator|++
operator|&
literal|0377
operator|)
operator||
name|wtype
expr_stmt|;
name|pklen
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|pklen
operator|&
operator|(
name|DKCHUNK
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|raddr
operator|->
name|dkcsr
operator|=
name|D_XPACK
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
literal|0
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_WRITE
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
name|stechan
operator||
name|DKMARK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ptr
operator|==
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|)
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|mlen
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|mlen
operator|=
name|ptr
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
name|blklen
operator|=
name|MIN
argument_list|(
name|totlen
argument_list|,
name|DKBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pklen
operator|&
operator|(
name|DKCHUNK
operator|-
literal|1
operator|)
operator|)
operator|>
operator|(
name|DKCHUNK
operator|-
literal|4
operator|)
condition|)
block|{
name|raddr
operator|->
name|dkcsr
operator|=
name|D_XPACK
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
literal|0
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_WRITE
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
name|stechan
operator||
name|DKMARK
expr_stmt|;
block|}
if|if
condition|(
name|blklen
operator|==
name|totlen
operator|&&
name|mbp
operator|->
name|mp_eob
condition|)
name|raddr
operator|->
name|dko
operator|=
name|BOT
expr_stmt|;
else|else
name|raddr
operator|->
name|dko
operator|=
name|BOTM
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
operator|(
name|blklen
operator|&
literal|0377
operator|)
operator||
name|DKDATA
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
operator|(
operator|(
name|blklen
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator||
name|DKDATA
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
name|SEQ
operator|+
name|dkp
operator|->
name|dk_S
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_XPACK
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
literal|0
expr_stmt|;
name|URPTRACE
argument_list|(
name|stechan
argument_list|,
name|SEQ
operator|+
name|dkp
operator|->
name|dk_S
argument_list|,
name|dkp
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_S
operator|++
expr_stmt|;
name|dkp
operator|->
name|dk_S
operator|&=
literal|07
expr_stmt|;
name|totlen
operator|-=
name|blklen
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|totlen
operator|==
literal|0
operator|&&
name|dkp
operator|->
name|dk_xlen
operator|&&
name|scheck
condition|)
block|{
name|raddr
operator|->
name|dkcsr
operator|=
name|D_WRITE
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
name|stechan
operator||
name|DKMARK
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
name|CHECK
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_XPACK
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
literal|0
expr_stmt|;
name|URPTRACE
argument_list|(
name|stechan
argument_list|,
name|CHECK
argument_list|,
name|dkp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ctlchk
label|:
if|if
condition|(
name|mbp
operator|->
name|mp_ctl
operator|&
literal|0200
condition|)
block|{
name|raddr
operator|->
name|dkcsr
operator|=
name|D_WRITE
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
name|stechan
operator||
name|DKMARK
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
name|mbp
operator|->
name|mp_ctl
operator|&
literal|0377
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_XPACK
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
literal|0
expr_stmt|;
name|mbp
operator|->
name|mp_ctl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_xlen
operator|==
literal|0
condition|)
name|dkreport
argument_list|(
name|KS_SEND
argument_list|,
name|stechan
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|intrpt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dkdisabled
condition|)
name|raddr
operator|->
name|dkcsr
operator|=
literal|0
expr_stmt|;
else|else
name|raddr
operator|->
name|dkcsr
operator|=
name|ENABS
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|dkrcv
argument_list|(
argument|dkp
argument_list|,
argument|stechan
argument_list|,
argument|intrpt
argument_list|)
expr|struct
name|dkchan
operator|*
name|dkp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ptr1
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr2
decl_stmt|;
specifier|register
name|len
expr_stmt|;
name|short
name|final
decl_stmt|;
name|short
name|hibits
decl_stmt|;
name|struct
name|dkpkbufr
modifier|*
name|pkb
decl_stmt|;
name|short
name|tlen
decl_stmt|;
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_rlen
operator|==
literal|0
operator|)
operator|||
operator|(
name|dkp
operator|->
name|dk_rq
operator|==
name|NULL
operator|)
condition|)
return|return ;
name|final
operator|=
literal|0
expr_stmt|;
name|tlen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|final
operator|==
literal|0
operator|&&
operator|(
name|pkb
operator|=
name|dkp
operator|->
name|dk_rq
operator|)
condition|)
block|{
if|if
condition|(
name|dkp
operator|->
name|dk_rlen
operator|==
literal|0
condition|)
name|final
operator||=
name|DKR_FULL
expr_stmt|;
name|ptr1
operator|=
operator|&
name|pkb
operator|->
name|Pdata
index|[
literal|0
index|]
expr_stmt|;
name|ptr2
operator|=
name|dkp
operator|->
name|dk_raddr
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|pkb
operator|->
name|Plen
argument_list|,
name|dkp
operator|->
name|dk_rlen
argument_list|)
expr_stmt|;
name|hibits
operator|=
name|pkb
operator|->
name|Phibits
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
name|hibits
operator|<
literal|0
condition|)
break|break ;
name|hibits
operator|<<=
literal|1
expr_stmt|;
operator|*
name|ptr2
operator|++
operator|=
operator|*
name|ptr1
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|ptr2
operator|-
name|dkp
operator|->
name|dk_raddr
expr_stmt|;
name|tlen
operator|+=
name|len
expr_stmt|;
name|dkp
operator|->
name|dk_rlen
operator|-=
name|len
expr_stmt|;
name|dkp
operator|->
name|dk_raddr
operator|=
name|ptr2
expr_stmt|;
if|if
condition|(
operator|(
name|pkb
operator|->
name|Plen
operator|-=
name|len
operator|)
operator|&&
name|hibits
operator|<
literal|0
condition|)
block|{
name|final
operator||=
operator|(
operator|(
operator|*
name|ptr1
operator|++
operator|&
literal|0377
operator|)
operator|<<
literal|8
operator|)
operator||
name|DKR_CNTL
expr_stmt|;
name|hibits
operator|<<=
literal|1
expr_stmt|;
name|pkb
operator|->
name|Plen
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|=
name|pkb
operator|->
name|Plen
condition|)
block|{
name|ptr2
operator|=
operator|&
name|pkb
operator|->
name|Pdata
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|ptr2
operator|++
operator|=
operator|*
name|ptr1
operator|++
expr_stmt|;
name|pkb
operator|->
name|Phibits
operator|=
name|hibits
expr_stmt|;
block|}
while|while
condition|(
name|pkb
operator|&&
operator|(
name|pkb
operator|->
name|Plen
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pkb
operator|->
name|Pseq
operator|&
literal|0370
operator|)
operator|==
name|ACK
condition|)
block|{
name|pkb
operator|->
name|Pseq
operator|+=
name|ECHO
operator|-
name|ACK
expr_stmt|;
name|final
operator||=
name|dkp
operator|->
name|dk_rmode
operator|&
name|DKR_BLOCK
expr_stmt|;
block|}
if|if
condition|(
name|pkb
operator|->
name|Pseq
condition|)
block|{
name|dksend
argument_list|(
name|stechan
argument_list|,
name|pkb
operator|->
name|Pseq
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_C
operator|=
name|pkb
operator|->
name|Pseq
expr_stmt|;
block|}
name|dkp
operator|->
name|dk_rq
operator|=
name|pkb
operator|->
name|Pnext
expr_stmt|;
name|pkb
operator|->
name|Pnext
operator|=
name|dk_Sfree
expr_stmt|;
name|dk_Sfree
operator|=
name|pkb
expr_stmt|;
name|pkb
operator|=
name|dkp
operator|->
name|dk_rq
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tlen
operator|&&
operator|(
name|dkp
operator|->
name|dk_rmode
operator|&
name|DKR_TIME
operator|)
condition|)
name|final
operator||=
name|DKR_TIME
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_rlen
operator|==
literal|0
condition|)
name|final
operator||=
name|DKR_FULL
expr_stmt|;
if|if
condition|(
name|final
operator|&&
operator|(
name|final
operator|!=
name|DKR_TIME
operator|||
operator|(
operator|(
name|dkp
operator|->
name|dk_state
operator|&
name|DK_RCVQ
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|dkp
operator|->
name|dk_state
operator||=
name|DK_RCVQ
expr_stmt|;
name|len
operator|=
name|dkp
operator|->
name|dk_rlen
expr_stmt|;
if|if
condition|(
name|final
operator|!=
name|DKR_TIME
condition|)
name|dkp
operator|->
name|dk_rlen
operator|=
literal|0
expr_stmt|;
name|dkreport
argument_list|(
name|KS_RDB
argument_list|,
name|stechan
argument_list|,
name|len
argument_list|,
name|final
argument_list|,
operator|(
name|final
operator|==
name|DKR_TIME
operator|)
condition|?
literal|2
else|:
name|intrpt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|dksend
argument_list|(
argument|stechan
argument_list|,
argument|val
argument_list|)
block|{
specifier|register
expr|struct
name|rdevice
operator|*
name|raddr
block|;
specifier|register
name|savcsr
block|;
if|if
condition|(
name|stechan
operator|==
literal|0
condition|)
return|return;
name|raddr
operator|=
name|DKADDR
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|savcsr
operator|=
name|raddr
operator|->
name|dkcsr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dkcsr
operator|=
name|D_WRITE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dko
operator|=
name|stechan
operator||
name|DKMARK
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dko
operator|=
name|val
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dkcsr
operator|=
name|D_XPACK
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dko
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|raddr
operator|->
name|dkcsr
operator|=
name|savcsr
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
unit|dkdrrint
operator|(
name|dev
operator|)
comment|/* ?? */
comment|/* needed for UNIX OS */
block|{
specifier|register
expr|struct
name|rdevice
operator|*
name|raddr
block|;
specifier|register
name|c
block|;
specifier|register
name|cnt
block|;
ifdef|#
directive|ifdef
name|lint
name|c
operator|=
literal|0
block|;
name|cnt
operator|=
name|c
block|;
endif|#
directive|endif
name|cnt
operator|=
literal|0
block|;
name|raddr
operator|=
name|DKADDR
block|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_OSEQ
block|;
if|if
condition|(
operator|(
name|raddr
operator|->
name|dkcsr
operator|&
name|DKTDONE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dkstray
operator|++
operator|>=
name|MAX_STRAY
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DK err 1 (Cabling?)\n"
argument_list|)
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
literal|0
expr_stmt|;
name|dkdisabled
operator|=
literal|1
expr_stmt|;
return|return;
block|}
end_expr_stmt

begin_expr_stmt
unit|} 	while
operator|(
name|raddr
operator|->
name|dkcsr
operator|&
name|DKTDONE
operator|)
block|{
name|c
operator|=
name|raddr
operator|->
name|dki
block|;
if|if
condition|(
name|cnt
operator|++
operator|>
literal|65
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DK err 2 (Cabling?)\n"
argument_list|)
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
literal|0
expr_stmt|;
name|dkdisabled
operator|=
literal|1
expr_stmt|;
return|return;
block|}
end_expr_stmt

begin_expr_stmt
unit|} 	raddr
operator|->
name|dkcsr
operator|=
name|ENABS
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Hstat
operator|!=
name|Tstat
condition|)
name|dkkint
argument_list|()
expr_stmt|;
end_if

begin_comment
unit|}
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
unit|dkdrxint
operator|(
name|dev
operator|)
comment|/* ?? */
block|{
specifier|register
expr|struct
name|rdevice
operator|*
name|raddr
block|;
specifier|register
name|char
operator|*
name|ptr
block|; struct
name|dkchan
operator|*
name|dkp
block|;
specifier|register
name|c
block|;
name|short
name|badpacks
block|; struct
name|dkpkbufr
operator|*
name|pkb
block|;
name|short
name|stechan
block|;
name|short
name|len
block|,
name|xlen
block|;
name|unsigned
name|short
name|bitloc
block|;
name|badpacks
operator|=
literal|0
block|;
name|raddr
operator|=
name|DKADDR
block|;
name|pkb
operator|=
name|NULL
block|;
if|if
condition|(
name|raddr
operator|->
name|dkcsr
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|dkstray
operator|++
operator|>
name|MAX_STRAY
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DK err 3 (Cabling?)\n"
argument_list|)
expr_stmt|;
goto|goto
name|disable
goto|;
block|}
end_expr_stmt

begin_expr_stmt
unit|} 	while
operator|(
name|raddr
operator|->
name|dkcsr
operator|<
literal|0
operator|)
block|{
name|raddr
operator|->
name|dkcsr
operator|=
name|D_READ
block|;
name|c
operator|=
name|raddr
operator|->
name|dki
block|;
while|while
condition|(
name|raddr
operator|->
name|dkcsr
operator|<
literal|0
operator|&&
operator|(
name|c
operator|&
name|DKMARK
operator|)
condition|)
block|{
name|c
operator|&=
literal|0777
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|dk_nchan
condition|)
block|{
if|if
condition|(
operator|++
name|badpacks
operator|>
literal|20
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DK err 4 (Cabling?)\n"
argument_list|)
expr_stmt|;
name|dkreport
argument_list|(
name|KS_ERR
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|disable
goto|;
block|}
end_expr_stmt

begin_break
break|break ;
end_break

begin_comment
unit|}
comment|/* discard all chl 0 packets; 			 * the LDI version of the CPM-DR and CPM-422 			 * puts out packets on chl 0 occasionally. 			 */
end_comment

begin_expr_stmt
unit|if
operator|(
name|c
operator|==
literal|0
operator|)
end_expr_stmt

begin_break
break|break;
end_break

begin_expr_stmt
name|dkp
operator|=
operator|&
name|dkit
index|[
name|c
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|stechan
operator|=
name|c
expr_stmt|;
end_expr_stmt

begin_label
name|qpkb
label|:
end_label

begin_if
if|if
condition|(
name|pkb
operator|&&
name|pkb
operator|->
name|Plen
condition|)
block|{
name|dkrcvq
argument_list|(
name|stechan
argument_list|,
name|dkp
argument_list|,
name|pkb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pkb
operator|=
name|NULL
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|pkb
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pkb
operator|=
name|dk_Sfree
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dk_Sfree
operator|=
name|pkb
operator|->
name|Pnext
expr_stmt|;
name|pkb
operator|->
name|Pseq
operator|=
literal|0
expr_stmt|;
name|pkb
operator|->
name|Plen
operator|=
literal|0
expr_stmt|;
name|pkb
operator|->
name|Pnext
operator|=
name|NULL
expr_stmt|;
name|pkb
operator|->
name|Phibits
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 					** Oops, no more dkpkbufr's. 					** Let outer loop gobble up 					** the entire packet. 					** Report to the console 					** every 100th occurrence. 					*/
if|if
condition|(
name|dknopkb
operator|++
operator|>=
literal|100
condition|)
block|{
name|dknopkb
operator|=
literal|1
expr_stmt|;
name|dkreport
argument_list|(
name|KS_ERR
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break ;
block|}
block|}
end_if

begin_expr_stmt
name|raddr
operator|->
name|dkcsr
operator|=
name|D_READ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ptr
operator|=
operator|&
name|pkb
operator|->
name|Pdata
index|[
literal|0
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bitloc
operator|=
literal|0100000
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|raddr
operator|->
name|dkcsr
operator|<
literal|0
operator|&&
operator|(
operator|(
name|c
operator|=
name|raddr
operator|->
name|dki
operator|)
operator|&
name|DKMARK
operator|)
operator|==
literal|0
condition|)
switch|switch
condition|(
name|c
operator|=
name|c
operator|&
literal|0777
condition|)
block|{
case|case
name|NULL
case|:
break|break ;
case|case
name|AINIT
case|:
name|dkp
operator|->
name|dk_X
operator|=
name|XM_INIT
expr_stmt|;
name|dkp
operator|->
name|dk_R
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_S
operator|=
literal|1
expr_stmt|;
name|dkp
operator|->
name|dk_A
operator|=
literal|0
expr_stmt|;
name|dkxmit
argument_list|(
name|dkp
argument_list|,
name|stechan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_READ
expr_stmt|;
break|break ;
case|case
name|INIT0
case|:
name|dksend
argument_list|(
name|stechan
argument_list|,
name|AINIT
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_trmode
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_C
operator|=
name|dkp
operator|->
name|dk_rseq
operator|=
literal|0
expr_stmt|;
break|break ;
case|case
name|INIT1
case|:
name|dksend
argument_list|(
name|stechan
argument_list|,
name|AINIT
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_trmode
operator|=
literal|1
expr_stmt|;
name|dkp
operator|->
name|dk_C
operator|=
name|dkp
operator|->
name|dk_tail1
operator|=
name|dkp
operator|->
name|dk_tail2
operator|=
name|dkp
operator|->
name|dk_rseq
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pkb
condition|)
block|{
name|pkb
operator|->
name|Pnext
operator|=
name|dk_Sfree
expr_stmt|;
name|dk_Sfree
operator|=
name|pkb
expr_stmt|;
if|if
condition|(
name|pkb
operator|=
name|dkp
operator|->
name|dk_rq
condition|)
name|dkp
operator|->
name|dk_rq
operator|=
name|pkb
operator|->
name|Pnext
expr_stmt|;
if|if
condition|(
name|pkb
operator|==
name|NULL
condition|)
if|if
condition|(
name|pkb
operator|=
name|dkp
operator|->
name|dk_rb
condition|)
name|dkp
operator|->
name|dk_rb
operator|=
name|pkb
operator|->
name|Pnext
expr_stmt|;
block|}
goto|goto
name|qpkb
goto|;
case|case
name|INITREQ
case|:
name|dksend
argument_list|(
name|stechan
argument_list|,
name|INIT1
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_X
operator|=
literal|0
expr_stmt|;
break|break ;
case|case
name|ENQ
case|:
name|dksend
argument_list|(
name|stechan
argument_list|,
name|dkp
operator|->
name|dk_C
argument_list|)
expr_stmt|;
case|case
name|CHECK
case|:
name|dksend
argument_list|(
name|stechan
argument_list|,
name|ACK
operator|+
name|dkp
operator|->
name|dk_rseq
argument_list|)
expr_stmt|;
while|while
condition|(
name|pkb
condition|)
block|{
name|pkb
operator|->
name|Pnext
operator|=
name|dk_Sfree
expr_stmt|;
name|dk_Sfree
operator|=
name|pkb
expr_stmt|;
if|if
condition|(
name|pkb
operator|=
name|dkp
operator|->
name|dk_rb
condition|)
name|dkp
operator|->
name|dk_rb
operator|=
name|pkb
operator|->
name|Pnext
expr_stmt|;
block|}
name|dkp
operator|->
name|dk_rblen
operator|=
literal|0
expr_stmt|;
goto|goto
name|qpkb
goto|;
case|case
name|EOI
case|:
if|if
condition|(
name|dkp
operator|->
name|dk_tail1
operator|==
operator|(
operator|(
name|SOI
operator|<<
literal|8
operator|)
operator||
literal|2
operator|)
condition|)
name|dkreport
argument_list|(
name|KS_EOI
argument_list|,
name|stechan
argument_list|,
name|dkp
operator|->
name|dk_tail2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_tail1
operator|=
literal|0
expr_stmt|;
break|break ;
default|default:
if|if
condition|(
name|c
operator|&
name|DKDATA
condition|)
block|{
if|if
condition|(
name|dkp
operator|->
name|dk_tail1
condition|)
block|{
name|dkp
operator|->
name|dk_tail2
operator|=
operator|(
operator|(
name|dkp
operator|->
name|dk_tail2
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator||
operator|(
name|c
operator|<<
literal|8
operator|)
expr_stmt|;
name|dkp
operator|->
name|dk_tail1
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_tail1
operator|&
literal|0377
operator|)
operator|>
literal|3
condition|)
name|dkp
operator|->
name|dk_tail1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr
operator|++
operator|=
name|c
operator|&
literal|0377
expr_stmt|;
name|pkb
operator|->
name|Plen
operator|++
expr_stmt|;
name|bitloc
operator|>>=
literal|1
expr_stmt|;
block|}
break|break ;
block|}
if|if
condition|(
operator|(
operator|(
name|c
operator|&
literal|0770
operator|)
operator|==
name|ECHO
operator|)
operator|||
operator|(
operator|(
name|c
operator|&
literal|0770
operator|)
operator|==
name|REJ
operator|)
condition|)
block|{
name|URPTRACE
argument_list|(
name|stechan
argument_list|,
name|c
argument_list|,
name|dkp
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_R
operator|=
name|c
operator|&
literal|07
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dkp
operator|->
name|dk_S
operator|-
name|dkp
operator|->
name|dk_R
operator|-
literal|1
operator|)
operator|&
literal|07
operator|)
operator|<
operator|(
operator|(
name|dkp
operator|->
name|dk_S
operator|-
name|dkp
operator|->
name|dk_A
operator|-
literal|1
operator|)
operator|&
literal|07
operator|)
condition|)
block|{
name|gotack
label|:
name|dkp
operator|->
name|dk_X
operator|&=
operator|~
operator|(
name|XM_REJ
operator||
name|XM_ENQ
operator|)
expr_stmt|;
name|xlen
operator|=
name|dkp
operator|->
name|dk_xlen
expr_stmt|;
name|len
operator|=
operator|(
operator|(
name|c
operator|-
name|dkp
operator|->
name|dk_A
operator|)
operator|&
literal|07
operator|)
operator|*
name|DKBLOCK
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|xlen
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_xlen
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_curout
condition|)
name|m_adj
argument_list|(
name|dkp
operator|->
name|dk_curout
operator|->
name|m_next
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dkp
operator|->
name|dk_A
operator|=
name|c
operator|&
literal|07
expr_stmt|;
if|if
condition|(
name|len
operator|||
name|xlen
condition|)
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_xlen
operator|)
operator|==
literal|0
condition|)
name|dkreport
argument_list|(
name|KS_SEND
argument_list|,
name|stechan
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|dkxmit
argument_list|(
name|dkp
argument_list|,
name|stechan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_READ
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|0770
operator|)
operator|==
name|REJ
operator|&&
operator|(
operator|(
name|dkp
operator|->
name|dk_X
operator|&
name|XM_REJ
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|dkp
operator|->
name|dk_rejcnt
operator|++
expr_stmt|;
name|gotrej
label|:
name|dkp
operator|->
name|dk_S
operator|=
operator|(
name|c
operator|+
literal|1
operator|)
operator|&
literal|07
expr_stmt|;
name|dkxmit
argument_list|(
name|dkp
argument_list|,
name|stechan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_READ
expr_stmt|;
name|dkp
operator|->
name|dk_X
operator||=
name|XM_REJ
expr_stmt|;
block|}
break|break ;
block|}
if|if
condition|(
operator|(
name|c
operator|&
literal|0770
operator|)
operator|==
name|ACK
condition|)
block|{
name|URPTRACE
argument_list|(
name|stechan
argument_list|,
name|c
argument_list|,
name|dkp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_A
operator|!=
operator|(
name|c
operator|&
literal|07
operator|)
condition|)
goto|goto
name|gotack
goto|;
if|if
condition|(
operator|(
name|dkp
operator|->
name|dk_X
operator|&
name|XM_REJ
operator|)
operator|==
literal|0
condition|)
block|{
name|dkp
operator|->
name|dk_ackrejcnt
operator|++
expr_stmt|;
goto|goto
name|gotrej
goto|;
block|}
break|break ;
block|}
if|if
condition|(
operator|(
name|c
operator|&
literal|0774
operator|)
operator|==
name|BOT
condition|)
block|{
name|dkp
operator|->
name|dk_tail1
operator|=
name|c
operator|<<
literal|8
expr_stmt|;
break|break ;
block|}
if|if
condition|(
operator|(
name|c
operator|&
literal|0770
operator|)
operator|==
name|SEQ
condition|)
block|{
name|pkb
operator|->
name|Pseq
operator|=
name|c
operator|-
name|SEQ
operator|+
name|ECHO
expr_stmt|;
name|dkrcvq
argument_list|(
name|stechan
argument_list|,
name|dkp
argument_list|,
name|pkb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_trmode
condition|)
block|{
if|if
condition|(
name|dkp
operator|->
name|dk_rblen
operator|==
name|dkp
operator|->
name|dk_tail2
operator|&&
operator|(
name|dkp
operator|->
name|dk_tail1
operator|&
literal|0377
operator|)
operator|==
literal|2
operator|&&
operator|(
operator|(
name|dkp
operator|->
name|dk_tail1
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator|!=
name|SOI
operator|&&
operator|(
operator|(
name|dkp
operator|->
name|dk_rseq
operator|+
literal|1
operator|)
operator|&
literal|07
operator|)
operator|==
operator|(
name|c
operator|&
literal|07
operator|)
condition|)
block|{
name|dkp
operator|->
name|dk_rseq
operator|=
name|c
operator|&
literal|07
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dkp
operator|->
name|dk_tail1
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator|!=
name|BOTM
condition|)
name|pkb
operator|->
name|Pseq
operator|+=
name|ACK
operator|-
name|ECHO
expr_stmt|;
name|dkrcvq
argument_list|(
name|stechan
argument_list|,
name|dkp
argument_list|,
name|dkp
operator|->
name|dk_rb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|pkb
operator|=
name|dkp
operator|->
name|dk_rb
condition|)
block|{
name|dkp
operator|->
name|dk_rb
operator|=
name|pkb
operator|->
name|Pnext
expr_stmt|;
name|pkb
operator|->
name|Pnext
operator|=
name|dk_Sfree
expr_stmt|;
name|dk_Sfree
operator|=
name|pkb
expr_stmt|;
block|}
name|pkb
operator|=
name|dk_Sfree
expr_stmt|;
name|dk_Sfree
operator|=
name|pkb
operator|->
name|Pnext
expr_stmt|;
name|pkb
operator|->
name|Plen
operator|=
literal|0
expr_stmt|;
name|pkb
operator|->
name|Pnext
operator|=
name|NULL
expr_stmt|;
name|pkb
operator|->
name|Pseq
operator|=
name|REJ
operator|+
name|dkp
operator|->
name|dk_rseq
expr_stmt|;
name|dkp
operator|->
name|dk_srejcnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dkp
operator|->
name|dk_tail1
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator|==
name|BOTS
condition|)
block|{
name|dkp
operator|->
name|dk_rseq
operator|=
name|c
operator|&
literal|07
expr_stmt|;
name|pkb
operator|->
name|Pseq
operator|=
name|ECHO
operator|+
name|dkp
operator|->
name|dk_rseq
expr_stmt|;
block|}
name|dkrcvq
argument_list|(
name|stechan
argument_list|,
name|dkp
argument_list|,
name|pkb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|dkp
operator|->
name|dk_rb
operator|=
name|NULL
expr_stmt|;
name|dkp
operator|->
name|dk_rblen
operator|=
literal|0
expr_stmt|;
name|dkp
operator|->
name|dk_tail1
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* always keep seq no up to date */
name|dkp
operator|->
name|dk_rseq
operator|=
name|c
operator|&
literal|07
expr_stmt|;
name|pkb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|qpkb
goto|;
block|}
if|if
condition|(
name|c
operator|&
literal|0200
condition|)
block|{
name|dkreport
argument_list|(
name|KS_CNTL
argument_list|,
name|stechan
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_READ
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr
operator|++
operator|=
name|c
operator|&
literal|0377
expr_stmt|;
name|pkb
operator|->
name|Plen
operator|++
expr_stmt|;
name|pkb
operator|->
name|Phibits
operator||=
name|bitloc
expr_stmt|;
name|bitloc
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_while

begin_if
if|if
condition|(
name|pkb
operator|&&
name|pkb
operator|->
name|Plen
condition|)
block|{
name|dkrcvq
argument_list|(
name|stechan
argument_list|,
name|dkp
argument_list|,
name|pkb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pkb
operator|=
name|NULL
expr_stmt|;
block|}
end_if

begin_if
unit|} 	}
if|if
condition|(
name|pkb
condition|)
block|{
if|if
condition|(
name|pkb
operator|->
name|Plen
condition|)
name|dkrcvq
argument_list|(
name|stechan
argument_list|,
name|dkp
argument_list|,
name|pkb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|pkb
operator|->
name|Pnext
operator|=
name|dk_Sfree
expr_stmt|;
name|dk_Sfree
operator|=
name|pkb
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|raddr
operator|->
name|dkcsr
operator|=
name|ENABS
expr_stmt|;
end_expr_stmt

begin_return
return|return;
end_return

begin_label
name|disable
label|:
end_label

begin_if
if|if
condition|(
name|pkb
condition|)
block|{
name|pkb
operator|->
name|Pnext
operator|=
name|dk_Sfree
expr_stmt|;
name|dk_Sfree
operator|=
name|pkb
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|raddr
operator|->
name|dkcsr
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dkdisabled
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  dkrcvq
operator|(
name|stechan
operator|,
name|dkp
operator|,
name|npkb
operator|,
name|where
operator|)
specifier|register
expr|struct
name|dkchan
operator|*
name|dkp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|dkpkbufr
modifier|*
name|npkb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dkpkbufr
modifier|*
name|pkb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_trmode
operator|&&
name|where
operator|==
literal|0
condition|)
name|pkb
operator|=
operator|(
expr|struct
name|dkpkbufr
operator|*
operator|)
operator|&
name|dkp
operator|->
name|dk_rb
expr_stmt|;
else|else
name|pkb
operator|=
operator|(
expr|struct
name|dkpkbufr
operator|*
operator|)
operator|&
name|dkp
operator|->
name|dk_rq
expr_stmt|;
while|while
condition|(
name|pkb
operator|->
name|Pnext
condition|)
block|{
name|pkb
operator|=
name|pkb
operator|->
name|Pnext
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|PKBHOG
condition|)
block|{
comment|/* 		** This channel has too many buffers. 		** Do not queue any more. 		** Return the new buffer to the free list. 		*/
name|npkb
operator|->
name|Pnext
operator|=
name|dk_Sfree
expr_stmt|;
name|dk_Sfree
operator|=
name|npkb
expr_stmt|;
return|return ;
block|}
name|pkb
operator|->
name|Pnext
operator|=
name|npkb
expr_stmt|;
if|if
condition|(
name|dkp
operator|->
name|dk_trmode
operator|&&
name|where
operator|==
literal|0
condition|)
name|dkp
operator|->
name|dk_rblen
operator|+=
name|npkb
operator|->
name|Plen
expr_stmt|;
else|else
name|dkrcv
argument_list|(
name|dkp
argument_list|,
name|stechan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dkreport
argument_list|(
argument|type
argument_list|,
argument|chan
argument_list|,
argument|info1
argument_list|,
argument|info2
argument_list|,
argument|intrpt
argument_list|)
end_macro

begin_comment
comment|/*  intrpt parameter controlls whether the pdp-11 interrupt is called.  *  Value 0 says no (means dkxint queued already)  *  Value 1 says call it immediately (like from dr11c interrupt)  *  Value 2 says to queue a call as soon as processor priority lowers  *       (by sending a dummy packet on a channel and getting dkxint)  */
end_comment

begin_block
block|{
specifier|register
name|struct
name|dkstat
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
name|Tstat
operator|+
literal|1
operator|)
operator|%
name|dkdr_nstat
operator|==
name|Hstat
condition|)
block|{
comment|/* room in queue? */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dkit_dr: No room in status queue, Channel %d\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|=
operator|&
name|dkdr_stat
index|[
name|Tstat
index|]
expr_stmt|;
name|sp
operator|->
name|k_chan
operator|=
name|chan
expr_stmt|;
name|sp
operator|->
name|k_type
operator|=
name|type
expr_stmt|;
name|sp
operator|->
name|k_info1
operator|=
name|info1
expr_stmt|;
name|sp
operator|->
name|k_info2
operator|=
name|info2
expr_stmt|;
if|if
condition|(
name|Tstat
operator|==
name|dkdr_nstat
operator|-
literal|1
condition|)
name|Tstat
operator|=
literal|0
expr_stmt|;
else|else
name|Tstat
operator|++
expr_stmt|;
if|if
condition|(
name|intrpt
operator|==
literal|1
condition|)
block|{
name|dkkint
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intrpt
operator|==
literal|2
condition|)
block|{
specifier|register
name|struct
name|rdevice
modifier|*
name|raddr
decl_stmt|;
name|raddr
operator|=
name|DKADDR
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_WRITE
expr_stmt|;
comment|/* Chl (dk_nchan-1) is used instead of 511 because 		 * the LDI switch module will complain if we use 		 * a chl outside the range set up in its route tables. 		 */
name|raddr
operator|->
name|dko
operator|=
operator|(
name|dk_nchan
operator|-
literal|1
operator|)
operator||
name|DKMARK
expr_stmt|;
comment|/* 		 * A null is used here because it should always 		 * be ignored by the far end of the circuit. 		 */
name|raddr
operator|->
name|dko
operator|=
literal|0
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|D_XPACK
expr_stmt|;
name|raddr
operator|->
name|dko
operator|=
literal|0
expr_stmt|;
name|raddr
operator|->
name|dkcsr
operator|=
name|ENABS
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|URPDEBUG
end_ifdef

begin_struct
struct|struct
name|dkurps
block|{
name|char
name|dku_ctl
decl_stmt|;
name|char
name|dku_S
decl_stmt|;
name|char
name|dku_R
decl_stmt|;
name|char
name|dku_A
decl_stmt|;
block|}
name|dkurps
index|[
name|URPDEBUG
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|dkurpsize
init|=
name|URPDEBUG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dkurps
modifier|*
name|dkurpsp
init|=
name|dkurps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dkurpreset
decl_stmt|;
end_decl_stmt

begin_macro
name|dkurptrace
argument_list|(
argument|ctl
argument_list|,
argument|dkp
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|dkchan
modifier|*
name|dkp
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|lint
name|dkurpsize
operator|=
name|dkurpsize
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dkurpreset
condition|)
block|{
name|dkurpsp
operator|=
name|dkurps
expr_stmt|;
name|dkurpreset
operator|=
literal|0
expr_stmt|;
block|}
name|dkurpsp
operator|->
name|dku_ctl
operator|=
name|ctl
expr_stmt|;
name|dkurpsp
operator|->
name|dku_S
operator|=
name|dkp
operator|->
name|dk_S
expr_stmt|;
name|dkurpsp
operator|->
name|dku_R
operator|=
name|dkp
operator|->
name|dk_R
expr_stmt|;
name|dkurpsp
operator|->
name|dku_A
operator|=
name|dkp
operator|->
name|dk_A
expr_stmt|;
if|if
condition|(
operator|++
name|dkurpsp
operator|==
name|dkurps
operator|+
name|URPDEBUG
condition|)
name|dkurpsp
operator|=
name|dkurps
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|URPDEBUG
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

