begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)autoconf.c	7.4 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vax/nexus.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxmba/mbareg.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"savax.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VAX8200
end_ifdef

begin_include
include|#
directive|include
file|"../vax/bireg.h"
end_include

begin_comment
comment|/*  * These are found during configuration, rather than being compiled in  * statically.  */
end_comment

begin_decl_stmt
name|struct
name|uba_regs
modifier|*
name|ubaddr8200
index|[
name|MAXNUBA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|uioaddr8200
index|[
name|MAXNUBA
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|VAX8600
operator|||
name|VAX780
end_if

begin_define
define|#
directive|define
name|UTR
parameter_list|(
name|i
parameter_list|)
value|((struct uba_regs *)(NEX780+(i)))
end_define

begin_define
define|#
directive|define
name|UMA
parameter_list|(
name|i
parameter_list|)
value|((caddr_t)UMEM780(i)+UBAIOADDR)
end_define

begin_define
define|#
directive|define
name|MTR
parameter_list|(
name|i
parameter_list|)
value|((struct mba_regs *)(NEX780+(i)))
end_define

begin_define
define|#
directive|define
name|UTRB
parameter_list|(
name|i
parameter_list|)
value|((struct uba_regs *)(NEXB8600+(i)))
end_define

begin_define
define|#
directive|define
name|UMAB
parameter_list|(
name|i
parameter_list|)
value|((caddr_t)UMEMB8600(i)+UBAIOADDR)
end_define

begin_define
define|#
directive|define
name|MTRB
parameter_list|(
name|i
parameter_list|)
value|((struct mba_regs *)(NEXB8600+(i)))
end_define

begin_decl_stmt
name|struct
name|uba_regs
modifier|*
name|ubaddr780
index|[]
init|=
block|{
name|UTR
argument_list|(
literal|3
argument_list|)
block|,
name|UTR
argument_list|(
literal|4
argument_list|)
block|,
name|UTR
argument_list|(
literal|5
argument_list|)
block|,
name|UTR
argument_list|(
literal|6
argument_list|)
block|,
if|#
directive|if
name|VAX8600
name|UTRB
argument_list|(
literal|3
argument_list|)
block|,
name|UTRB
argument_list|(
literal|4
argument_list|)
block|,
name|UTRB
argument_list|(
literal|5
argument_list|)
block|,
name|UTRB
argument_list|(
literal|6
argument_list|)
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|uioaddr780
index|[]
init|=
block|{
name|UMA
argument_list|(
literal|0
argument_list|)
block|,
name|UMA
argument_list|(
literal|1
argument_list|)
block|,
name|UMA
argument_list|(
literal|2
argument_list|)
block|,
name|UMA
argument_list|(
literal|3
argument_list|)
block|,
if|#
directive|if
name|VAX8600
name|UMAB
argument_list|(
literal|0
argument_list|)
block|,
name|UMAB
argument_list|(
literal|1
argument_list|)
block|,
name|UMAB
argument_list|(
literal|2
argument_list|)
block|,
name|UMAB
argument_list|(
literal|3
argument_list|)
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mba_regs
modifier|*
name|mbaddr780
index|[]
init|=
block|{
name|MTR
argument_list|(
literal|8
argument_list|)
block|,
name|MTR
argument_list|(
literal|9
argument_list|)
block|,
name|MTR
argument_list|(
literal|10
argument_list|)
block|,
name|MTR
argument_list|(
literal|11
argument_list|)
block|,
if|#
directive|if
name|VAX8600
name|MTRB
argument_list|(
literal|8
argument_list|)
block|,
name|MTRB
argument_list|(
literal|9
argument_list|)
block|,
name|MTRB
argument_list|(
literal|10
argument_list|)
block|,
name|MTRB
argument_list|(
literal|11
argument_list|)
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|UTR
end_undef

begin_undef
undef|#
directive|undef
name|UMA
end_undef

begin_undef
undef|#
directive|undef
name|MTR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|VAX750
end_if

begin_define
define|#
directive|define
name|UTR
parameter_list|(
name|i
parameter_list|)
value|((struct uba_regs *)(NEX750+(i)))
end_define

begin_define
define|#
directive|define
name|UMA
parameter_list|(
name|i
parameter_list|)
value|((caddr_t)UMEM750(i)+UBAIOADDR)
end_define

begin_define
define|#
directive|define
name|MTR
parameter_list|(
name|i
parameter_list|)
value|((struct mba_regs *)(NEX750+(i)))
end_define

begin_decl_stmt
name|struct
name|uba_regs
modifier|*
name|ubaddr750
index|[]
init|=
block|{
name|UTR
argument_list|(
literal|8
argument_list|)
block|,
name|UTR
argument_list|(
literal|9
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|uioaddr750
index|[]
init|=
block|{
name|UMA
argument_list|(
literal|0
argument_list|)
block|,
name|UMA
argument_list|(
literal|1
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mba_regs
modifier|*
name|mbaddr750
index|[]
init|=
block|{
name|MTR
argument_list|(
literal|4
argument_list|)
block|,
name|MTR
argument_list|(
literal|5
argument_list|)
block|,
name|MTR
argument_list|(
literal|6
argument_list|)
block|,
name|MTR
argument_list|(
literal|7
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|UTR
end_undef

begin_undef
undef|#
directive|undef
name|UMA
end_undef

begin_undef
undef|#
directive|undef
name|MTR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|VAX730
end_if

begin_define
define|#
directive|define
name|UTR
parameter_list|(
name|i
parameter_list|)
value|((struct uba_regs *)(NEX730+(i)))
end_define

begin_define
define|#
directive|define
name|UMA
value|((caddr_t)UMEM730+UBAIOADDR)
end_define

begin_decl_stmt
name|struct
name|uba_regs
modifier|*
name|ubaddr730
index|[]
init|=
block|{
name|UTR
argument_list|(
literal|3
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|uioaddr730
index|[]
init|=
block|{
name|UMA
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|UTR
end_undef

begin_undef
undef|#
directive|undef
name|UMA
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|VAX630
end_if

begin_comment
comment|/*  * The map registers start at 20088000 on the ka630, so  * subtract a 2k offset to make things work.  *  * This could stand serious cleanup.  */
end_comment

begin_decl_stmt
name|struct
name|uba_regs
modifier|*
name|ubaddr630
index|[]
init|=
block|{
operator|(
expr|struct
name|uba_regs
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|QBAMAP630
operator|-
literal|0x800
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|uioaddr630
index|[]
init|=
block|{
operator|(
name|caddr_t
operator|)
name|QIOPAGE630
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|cpuspeed
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_macro
name|configure
argument_list|()
end_macro

begin_block
block|{
name|union
name|cpusid
name|cpusid
decl_stmt|;
specifier|register
name|int
name|nmba
decl_stmt|,
name|nuba
decl_stmt|,
name|i
decl_stmt|;
name|cpusid
operator|.
name|cpusid
operator|=
name|mfpr
argument_list|(
name|SID
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|cpusid
operator|.
name|cpuany
operator|.
name|cp_type
expr_stmt|;
switch|switch
condition|(
name|cpu
condition|)
block|{
if|#
directive|if
name|VAX8600
case|case
name|VAX_8600
case|:
name|nmba
operator|=
sizeof|sizeof
argument_list|(
name|mbaddr780
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mbaddr780
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|nuba
operator|=
sizeof|sizeof
argument_list|(
name|ubaddr780
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ubaddr780
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mbaddr
operator|=
name|mbaddr780
expr_stmt|;
name|ubaddr
operator|=
name|ubaddr780
expr_stmt|;
name|uioaddr
operator|=
name|uioaddr780
expr_stmt|;
name|cpuspeed
operator|=
literal|6
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX780
case|case
name|VAX_780
case|:
name|nmba
operator|=
literal|4
expr_stmt|;
name|nuba
operator|=
literal|4
expr_stmt|;
name|mbaddr
operator|=
name|mbaddr780
expr_stmt|;
name|ubaddr
operator|=
name|ubaddr780
expr_stmt|;
name|uioaddr
operator|=
name|uioaddr780
expr_stmt|;
name|cpuspeed
operator|=
literal|2
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX8200
case|case
name|VAX_8200
case|:
block|{
specifier|register
name|struct
name|bi_node
modifier|*
name|bi
decl_stmt|;
name|nmba
operator|=
literal|0
expr_stmt|;
name|nuba
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bi
operator|=
name|BI_BASE
argument_list|(
literal|0
argument_list|)
init|;
name|i
operator|<
name|NNODEBI
condition|;
name|i
operator|++
operator|,
name|bi
operator|++
control|)
block|{
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|bi
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|notdef
comment|/* clear bus errors */
name|bi
operator|->
name|biic
operator|.
name|bi_ber
operator|=
operator|~
operator|(
name|BIBER_MBZ
operator||
name|BIBER_NMR
operator||
name|BIBER_UPEN
operator|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|bi
operator|->
name|biic
operator|.
name|bi_dtype
condition|)
block|{
case|case
name|BIDT_DWBUA
case|:
if|if
condition|(
name|nuba
operator|>=
name|MAXNUBA
condition|)
comment|/* sorry */
break|break;
name|ubaddr8200
index|[
name|nuba
index|]
operator|=
operator|(
expr|struct
name|uba_regs
operator|*
operator|)
name|bi
expr_stmt|;
name|uioaddr8200
index|[
name|nuba
index|]
operator|=
operator|(
name|caddr_t
operator|)
name|UMEM8200
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|dwbua_regs
operator|*
operator|)
name|bi
operator|)
operator|->
name|bua_csr
operator||=
name|BUACSR_UPI
expr_stmt|;
name|nuba
operator|++
expr_stmt|;
break|break;
case|case
name|BIDT_KDB50
case|:
if|if
condition|(
name|nkdb
operator|<
name|MAXNKDB
condition|)
name|kdbaddr
index|[
name|nkdb
operator|++
index|]
operator|=
operator|(
name|caddr_t
operator|)
name|bi
expr_stmt|;
break|break;
block|}
block|}
name|ubaddr
operator|=
name|ubaddr8200
expr_stmt|;
name|uioaddr
operator|=
name|uioaddr8200
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX750
case|case
name|VAX_750
case|:
name|mbaddr
operator|=
name|mbaddr750
expr_stmt|;
name|ubaddr
operator|=
name|ubaddr750
expr_stmt|;
name|uioaddr
operator|=
name|uioaddr750
expr_stmt|;
name|nmba
operator|=
sizeof|sizeof
argument_list|(
name|mbaddr750
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mbaddr750
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|nuba
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX730
case|case
name|VAX_730
case|:
name|ubaddr
operator|=
name|ubaddr730
expr_stmt|;
name|uioaddr
operator|=
name|uioaddr730
expr_stmt|;
name|nmba
operator|=
literal|0
expr_stmt|;
name|nuba
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX630
case|case
name|VAX_630
case|:
name|ubaddr
operator|=
name|ubaddr630
expr_stmt|;
name|uioaddr
operator|=
name|uioaddr630
expr_stmt|;
name|nmba
operator|=
literal|0
expr_stmt|;
name|nuba
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
comment|/* 	 * Forward into the past... 	 */
comment|/* 	for (i = 0; i< nmba; i++) 		if (!badaddr(mbaddr[i], sizeof(long))) 			mbaddr[i]->mba_cr = MBCR_INIT; */
switch|switch
condition|(
name|cpu
condition|)
block|{
if|#
directive|if
name|VAX8600
operator|||
name|VAX780
case|case
name|VAX_8600
case|:
case|case
name|VAX_780
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nuba
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|badaddr
argument_list|(
name|ubaddr
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
condition|)
name|ubaddr
index|[
name|i
index|]
operator|->
name|uba_cr
operator|=
name|UBACR_ADINIT
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX750
operator|||
name|VAX730
case|case
name|VAX_750
case|:
case|case
name|VAX_730
case|:
name|mtpr
argument_list|(
name|IUR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX630
case|case
name|VAX_630
case|:
name|mtpr
argument_list|(
name|IUR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|QIOPAGE630
operator|+
name|QIPCR
operator|)
operator|=
name|Q_LMEAE
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
comment|/* give unibus devices a chance to recover... */
if|if
condition|(
name|nuba
operator|>
literal|0
condition|)
name|DELAY
argument_list|(
literal|2000000
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

