begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)qdcons.c	7.3 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  *	derived from: @(#)qdcons.c  4.1 (ULTRIX    11/23/87  */
end_comment

begin_comment
comment|/************************************************************************ * *	ULTRIX QDSS STANDALONE BOOT DEVICE DRIVER... *	device driver to boot system with QDSS as console * *************************************************************************/
end_comment

begin_comment
comment|/************************************************************************ *									* *			Copyright (c) 1985 by				* *		Digital Equipment Corporation, Maynard, MA		* *			All rights reserved.				* *									* *   This software is furnished under a license and may be used and	* *   copied  only  in accordance with the terms of such license and	* *   with the  inclusion  of  the  above  copyright  notice.   This	* *   software  or  any  other copies thereof may not be provided or	* *   otherwise made available to any other person.  No title to and	* *   ownership of the software is hereby transferred.			* *									* *   The information in this software is subject to change  without	* *   notice  and should not be construed as a commitment by Digital	* *   Equipment Corporation.						* *									* *   Digital assumes no responsibility for the use  or  reliability	* *   of its software on equipment which is not supplied by Digital.	* *									* ************************************************************************* * revision history: (should be moved into sccs comments) ************************************************************************* * * 09 oct 85  longo  added uVAXII console ROM cursor reset to bottom of *		    the screen.  Also spruced up qdputc()& scroll_up() * 02 oct 85  longo  changed references to ADDRESS to be ADDRESS_COMPLETE * 23 aug 85  longo  changed I/O page CSR address to be 0x1F00 * 20 aug 85  longo  created * ************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"../sys/types.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_define
define|#
directive|define
name|KERNEL
end_define

begin_include
include|#
directive|include
file|"../vaxuba/qdioctl.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/qevent.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/qduser.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/qdreg.h"
end_include

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_comment
comment|/*----------------------------------------------------------------------- * constants used to set VAX ROM's cursor to bottom the of the screen  */
end_comment

begin_define
define|#
directive|define
name|NVR_ADRS
value|0x200B8024
end_define

begin_define
define|#
directive|define
name|CURRENT_ROW
value|0x4C
end_define

begin_comment
comment|/* these are offsets to the ROM's scratch.. */
end_comment

begin_define
define|#
directive|define
name|ROW_MIN
value|0x4D
end_define

begin_comment
comment|/* ..RAM start adrs as picked up out of NVR */
end_comment

begin_define
define|#
directive|define
name|ROW_MAX
value|0x4E
end_define

begin_define
define|#
directive|define
name|CURRENT_COL
value|0x50
end_define

begin_define
define|#
directive|define
name|COL_MIN
value|0x51
end_define

begin_define
define|#
directive|define
name|COL_MAX
value|0x52
end_define

begin_comment
comment|/*---------------------------------------- * LK201 keyboard state tracking struct */
end_comment

begin_struct
struct|struct
name|q_keyboard
block|{
name|int
name|shift
decl_stmt|;
comment|/* state variables	*/
name|int
name|cntrl
decl_stmt|;
name|int
name|lock
decl_stmt|;
name|char
name|last
decl_stmt|;
comment|/* last character	*/
block|}
name|q_keyboard
struct|;
end_struct

begin_decl_stmt
name|int
name|qdputc
argument_list|()
decl_stmt|,
name|qdgetc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
type|(
modifier|*
name|v_putc
decl_stmt|)(
end_decl_stmt

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
call|(
modifier|*
name|v_getc
call|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*---------------------------- * general purpose defines  */
end_comment

begin_define
define|#
directive|define
name|BAD
value|-1
end_define

begin_define
define|#
directive|define
name|GOOD
value|0
end_define

begin_comment
comment|/*---------------------------------------------- * console cursor bitmap (block cursor type)  */
end_comment

begin_decl_stmt
name|short
name|cons_cursor
index|[
literal|32
index|]
init|=
block|{
comment|/* white block cursor */
comment|/* A */
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
comment|/* B */
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------- * constants used in font operations */
end_comment

begin_define
define|#
directive|define
name|CHARS
value|95
end_define

begin_comment
comment|/* # of chars in the font */
end_comment

begin_define
define|#
directive|define
name|CHAR_HEIGHT
value|15
end_define

begin_comment
comment|/* char height in pixels */
end_comment

begin_define
define|#
directive|define
name|CHAR_WIDTH
value|8
end_define

begin_comment
comment|/* char width in pixels*/
end_comment

begin_define
define|#
directive|define
name|FONT_WIDTH
value|(CHAR_WIDTH * CHARS)
end_define

begin_comment
comment|/* font width in pixels */
end_comment

begin_define
define|#
directive|define
name|ROWS
value|CHAR_HEIGHT
end_define

begin_define
define|#
directive|define
name|FONT_X
value|0
end_define

begin_comment
comment|/* font's off screen adrs */
end_comment

begin_define
define|#
directive|define
name|FONT_Y
value|(2047 - CHAR_HEIGHT)
end_define

begin_comment
comment|/* #define FONT_Y		200 */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|q_font
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference font object code */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|q_key
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference key xlation tables */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|q_shift_key
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|q_special
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*---------------------------- * console cursor structure */
end_comment

begin_struct
struct|struct
name|cons_cur
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
block|}
name|cursor
struct|;
end_struct

begin_comment
comment|/*------------------------------------------ * MicroVAX-II q-bus addressing constants */
end_comment

begin_define
define|#
directive|define
name|QMEMBASE
value|0x30000000
end_define

begin_define
define|#
directive|define
name|QDSSCSR
value|0x20001F00
end_define

begin_define
define|#
directive|define
name|CHUNK
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|QMEMSIZE
value|(1024 * 1024 * 4)
end_define

begin_define
define|#
directive|define
name|QDBASE
value|(QMEMBASE + QMEMSIZE - CHUNK)
end_define

begin_comment
comment|/*------------------------------------------------------------------ * QDSS register address offsets from start of QDSS address space */
end_comment

begin_define
define|#
directive|define
name|QDSIZE
value|(52 * 1024)
end_define

begin_comment
comment|/* size of entire QDSS foot print */
end_comment

begin_define
define|#
directive|define
name|TMPSIZE
value|(16 * 1024)
end_define

begin_comment
comment|/* template RAM is 8k SHORT WORDS */
end_comment

begin_define
define|#
directive|define
name|TMPSTART
value|0x8000
end_define

begin_comment
comment|/* offset of template RAM from base adrs */
end_comment

begin_define
define|#
directive|define
name|REGSIZE
value|(5 * 512)
end_define

begin_comment
comment|/* regs touch 2.5k (5 pages) of addr space */
end_comment

begin_define
define|#
directive|define
name|REGSTART
value|0xC000
end_define

begin_comment
comment|/* offset of reg pages from base adrs */
end_comment

begin_define
define|#
directive|define
name|ADDER
value|(REGSTART+0x000)
end_define

begin_define
define|#
directive|define
name|DGA
value|(REGSTART+0x200)
end_define

begin_define
define|#
directive|define
name|DUART
value|(REGSTART+0x400)
end_define

begin_define
define|#
directive|define
name|MEMCSR
value|(REGSTART+0x800)
end_define

begin_define
define|#
directive|define
name|CLRSIZE
value|(3 * 512)
end_define

begin_comment
comment|/* color map size */
end_comment

begin_define
define|#
directive|define
name|CLRSTART
value|(REGSTART+0xA00)
end_define

begin_comment
comment|/* color map start offset from base */
end_comment

begin_comment
comment|/*  0x0C00 really */
end_comment

begin_define
define|#
directive|define
name|RED
value|(CLRSTART+0x000)
end_define

begin_define
define|#
directive|define
name|BLUE
value|(CLRSTART+0x200)
end_define

begin_define
define|#
directive|define
name|GREEN
value|(CLRSTART+0x400)
end_define

begin_comment
comment|/*--------------------------------------- * QDSS register address map structure */
end_comment

begin_decl_stmt
name|struct
name|qdmap
name|qdmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ ************************************************************************* ************************************************************************* * *	EXTERNALLY CALLED ROUTINES START HERE: * ************************************************************************* ************************************************************************* ************************************************************************/
end_comment

begin_comment
comment|/************************************************************************ * *	qd_init()... init the QDSS into a physical memory system * ************************************************************************/
end_comment

begin_macro
name|qd_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|ROM_console
decl_stmt|;
specifier|register
name|short
modifier|*
name|NVR
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|caddr_t
name|qdaddr
decl_stmt|;
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
specifier|extern
name|int
name|cpu
decl_stmt|;
name|qdaddr
operator|=
operator|(
name|caddr_t
operator|)
name|QDSSCSR
expr_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
name|qdaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
operator|(
name|short
operator|*
operator|)
name|qdaddr
operator|=
call|(
name|short
call|)
argument_list|(
name|QDBASE
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/*---------------------------------------------------------------------- * load qdmap struct with the physical addresses of the QDSS elements */
name|qdmap
operator|.
name|template
operator|=
operator|(
name|caddr_t
operator|)
name|QDBASE
operator|+
name|TMPSTART
expr_stmt|;
name|qdmap
operator|.
name|adder
operator|=
operator|(
name|caddr_t
operator|)
name|QDBASE
operator|+
name|ADDER
expr_stmt|;
name|qdmap
operator|.
name|dga
operator|=
operator|(
name|caddr_t
operator|)
name|QDBASE
operator|+
name|DGA
expr_stmt|;
name|qdmap
operator|.
name|duart
operator|=
operator|(
name|caddr_t
operator|)
name|QDBASE
operator|+
name|DUART
expr_stmt|;
name|qdmap
operator|.
name|memcsr
operator|=
operator|(
name|caddr_t
operator|)
name|QDBASE
operator|+
name|MEMCSR
expr_stmt|;
name|qdmap
operator|.
name|red
operator|=
operator|(
name|caddr_t
operator|)
name|QDBASE
operator|+
name|RED
expr_stmt|;
name|qdmap
operator|.
name|blue
operator|=
operator|(
name|caddr_t
operator|)
name|QDBASE
operator|+
name|BLUE
expr_stmt|;
name|qdmap
operator|.
name|green
operator|=
operator|(
name|caddr_t
operator|)
name|QDBASE
operator|+
name|GREEN
expr_stmt|;
comment|/*-------------------------- * no interrupts allowed! */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|csr
operator|=
name|HALT
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|CURS_ENB
expr_stmt|;
comment|/*---------------------------- * init the default values  */
name|q_keyboard
operator|.
name|shift
operator|=
literal|0
expr_stmt|;
comment|/* init keyboard state tracking */
name|q_keyboard
operator|.
name|lock
operator|=
literal|0
expr_stmt|;
name|q_keyboard
operator|.
name|cntrl
operator|=
literal|0
expr_stmt|;
name|q_keyboard
operator|.
name|last
operator|=
literal|0
expr_stmt|;
name|cursor
operator|.
name|x
operator|=
literal|0
expr_stmt|;
comment|/* init cursor to top left */
name|cursor
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|set_defaults
argument_list|()
expr_stmt|;
comment|/* setup the default device */
name|ldfont
argument_list|()
expr_stmt|;
comment|/* PtoB the font into off-screen */
comment|/*-------------------------------------------------------------------- * tell the VAX ROM that the cursor is at the bottom of the screen  */
if|if
condition|(
name|cpu
operator|==
name|VAX_630
condition|)
block|{
name|NVR
operator|=
operator|(
name|short
operator|*
operator|)
name|NVR_ADRS
expr_stmt|;
name|i
operator|=
operator|*
name|NVR
operator|++
operator|&
literal|0xFF
expr_stmt|;
name|i
operator||=
operator|(
operator|*
name|NVR
operator|++
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
expr_stmt|;
name|i
operator||=
operator|(
operator|*
name|NVR
operator|++
operator|&
literal|0xFF
operator|)
operator|<<
literal|16
expr_stmt|;
name|i
operator||=
operator|(
operator|*
name|NVR
operator|++
operator|&
literal|0xFF
operator|)
operator|<<
literal|24
expr_stmt|;
name|ROM_console
operator|=
operator|(
name|char
operator|*
operator|)
name|i
expr_stmt|;
name|ROM_console
index|[
name|CURRENT_COL
index|]
operator|=
name|ROM_console
index|[
name|COL_MIN
index|]
expr_stmt|;
name|ROM_console
index|[
name|CURRENT_ROW
index|]
operator|=
name|ROM_console
index|[
name|ROW_MAX
index|]
expr_stmt|;
block|}
comment|/*---------------------------------------------------------- * smash system virtual console service routine addresses */
name|printf
argument_list|(
literal|"switching console to QDSS display...\n"
argument_list|)
expr_stmt|;
name|v_getc
operator|=
name|qdgetc
expr_stmt|;
name|v_putc
operator|=
name|qdputc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qd_init */
end_comment

begin_comment
comment|/*******************************************************************  * *	qdputc()... output a character to the QDSS screen * ******************************************************************** * *	calling convention: * *		qdputc(chr); *		char chr; 		;character to be displayed * ********/
end_comment

begin_macro
name|qdputc
argument_list|(
argument|chr
argument_list|)
end_macro

begin_decl_stmt
name|char
name|chr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|short
name|x
decl_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
operator|.
name|adder
expr_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
operator|.
name|dga
expr_stmt|;
comment|/*--------------------------- * non display character?  */
name|chr
operator|&=
literal|0x7F
expr_stmt|;
switch|switch
condition|(
name|chr
condition|)
block|{
case|case
literal|'\r'
case|:
comment|/* return char */
name|cursor
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
operator|.
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\t'
case|:
comment|/* tab char */
for|for
control|(
name|i
operator|=
literal|8
operator|-
operator|(
operator|(
name|cursor
operator|.
name|x
operator|>>
literal|3
operator|)
operator|&
literal|0x07
operator|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|qdputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\n'
case|:
comment|/* line feed char */
if|if
condition|(
operator|(
name|cursor
operator|.
name|y
operator|+=
name|CHAR_HEIGHT
operator|)
operator|>
operator|(
literal|863
operator|-
name|CHAR_HEIGHT
operator|)
condition|)
block|{
name|cursor
operator|.
name|y
operator|-=
name|CHAR_HEIGHT
expr_stmt|;
name|scroll_up
argument_list|(
name|adder
argument_list|)
expr_stmt|;
block|}
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|cursor
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\b'
case|:
comment|/* backspace char */
if|if
condition|(
name|cursor
operator|.
name|x
operator|>
literal|0
condition|)
block|{
name|cursor
operator|.
name|x
operator|-=
name|CHAR_WIDTH
expr_stmt|;
name|qdputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|x
operator|-=
name|CHAR_WIDTH
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
default|default:
if|if
condition|(
name|chr
operator|<
literal|' '
operator|||
name|chr
operator|>
literal|'~'
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/*------------------------------------------ * setup VIPER operand control registers  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* select plane #0 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FE
argument_list|)
expr_stmt|;
comment|/* select other planes */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_SOURCE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/* select all planes */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*---------------------------------------- * load DESTINATION origin and vectors  */
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|NORMAL
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|RASTEROP_COMPLETE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
name|cursor
operator|.
name|x
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
name|CHAR_WIDTH
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
name|cursor
operator|.
name|y
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/*----------------------------------- * load SOURCE origin and vectors  */
name|adder
operator|->
name|source_1_x
operator|=
name|FONT_X
operator|+
operator|(
operator|(
name|chr
operator|-
literal|' '
operator|)
operator|*
name|CHAR_WIDTH
operator|)
expr_stmt|;
name|adder
operator|->
name|source_1_y
operator|=
name|FONT_Y
expr_stmt|;
name|adder
operator|->
name|source_1_dx
operator|=
name|CHAR_WIDTH
expr_stmt|;
name|adder
operator|->
name|source_1_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R1
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|RASTEROP
operator||
name|OCRB
operator||
literal|0
operator||
name|S1E
operator||
name|DTE
expr_stmt|;
comment|/*------------------------------------- * update console cursor coordinates */
name|cursor
operator|.
name|x
operator|+=
name|CHAR_WIDTH
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
operator|.
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
operator|.
name|x
operator|>
operator|(
literal|1024
operator|-
name|CHAR_WIDTH
operator|)
condition|)
block|{
name|qdputc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|qdputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* qdputc */
end_comment

begin_comment
comment|/*******************************************************************  * *	qdgetc()... get a character from the LK201 * *******************************************************************/
end_comment

begin_macro
name|qdgetc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|short
name|key
decl_stmt|;
specifier|register
name|char
name|chr
decl_stmt|;
specifier|register
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
operator|.
name|duart
expr_stmt|;
comment|/*-------------------------------------- 	* Get a character from the keyboard. */
name|LOOP
label|:
while|while
condition|(
operator|!
operator|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|RCV_RDY
operator|)
condition|)
empty_stmt|;
name|key
operator|=
name|duart
operator|->
name|dataA
expr_stmt|;
name|key
operator|&=
literal|0xFF
expr_stmt|;
comment|/*-------------------------------------- 	* Check for various keyboard errors  */
if|if
condition|(
name|key
operator|==
name|LK_POWER_ERROR
operator|||
name|key
operator|==
name|LK_KDOWN_ERROR
operator|||
name|key
operator|==
name|LK_INPUT_ERROR
operator|||
name|key
operator|==
name|LK_OUTPUT_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"Keyboard error, code = %x\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|key
operator|<
name|LK_LOWEST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*--------------------------------- 	* See if its a state change key */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|LOCK
case|:
name|q_keyboard
operator|.
name|lock
operator|^=
literal|0xffff
expr_stmt|;
comment|/* toggle */
if|if
condition|(
name|q_keyboard
operator|.
name|lock
condition|)
name|led_control
argument_list|(
name|LK_LED_ENABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
else|else
name|led_control
argument_list|(
name|LK_LED_DISABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|SHIFT
case|:
name|q_keyboard
operator|.
name|shift
operator|^=
literal|0xFFFF
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|CNTRL
case|:
name|q_keyboard
operator|.
name|cntrl
operator|^=
literal|0xFFFF
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|ALLUP
case|:
name|q_keyboard
operator|.
name|cntrl
operator|=
literal|0
expr_stmt|;
name|q_keyboard
operator|.
name|shift
operator|=
literal|0
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|REPEAT
case|:
name|chr
operator|=
name|q_keyboard
operator|.
name|last
expr_stmt|;
break|break;
comment|/*------------------------------------------------------- 	    * Test for cntrl characters. If set, see if the character 	    * is elligible to become a control character. */
default|default:
if|if
condition|(
name|q_keyboard
operator|.
name|cntrl
condition|)
block|{
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|chr
operator|>=
literal|' '
operator|&&
name|chr
operator|<=
literal|'~'
condition|)
name|chr
operator|&=
literal|0x1F
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q_keyboard
operator|.
name|lock
operator|||
name|q_keyboard
operator|.
name|shift
condition|)
name|chr
operator|=
name|q_shift_key
index|[
name|key
index|]
expr_stmt|;
else|else
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chr
operator|<
literal|' '
operator|&&
name|chr
operator|>
literal|'~'
condition|)
comment|/* if input is non-displayable */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ..then pitch it! */
name|q_keyboard
operator|.
name|last
operator|=
name|chr
expr_stmt|;
comment|/*----------------------------------- 	* Check for special function keys */
if|if
condition|(
name|chr
operator|&
literal|0x80
condition|)
comment|/* pitch the function keys */
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|chr
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdgetc */
end_comment

begin_comment
comment|/************************************************************************ ************************************************************************* ************************************************************************* * *	INTERNALLY USED ROUTINES START HERE: * ************************************************************************* ************************************************************************* ************************************************************************/
end_comment

begin_comment
comment|/******************************************************************** * *	ldcursor()... load the mouse cursor's template RAM bitmap * ********************************************************************/
end_comment

begin_macro
name|ldcursor
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
specifier|register
name|short
modifier|*
name|temp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|cursor
decl_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
operator|.
name|dga
expr_stmt|;
name|temp
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
operator|.
name|template
expr_stmt|;
name|temp
operator|+=
operator|(
literal|8
operator|*
literal|1024
operator|)
operator|-
literal|32
expr_stmt|;
comment|/* cursor is 32 WORDS from the end */
comment|/* ..of the 8k WORD template space */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
operator|*
name|temp
operator|++
operator|=
name|cons_cursor
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ldcursor */
end_comment

begin_comment
comment|/********************************************************************** * *	ldfont()... put the console font in the QDSS off-screen memory * **********************************************************************/
end_comment

begin_macro
name|ldfont
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* scratch variables */
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|short
name|packed
decl_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
operator|.
name|adder
expr_stmt|;
comment|/*------------------------------------------ * setup VIPER operand control registers  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC2_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_SOURCE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|DST_INDEX_ENABLE
operator||
name|NORMAL
expr_stmt|;
comment|/*-------------------------- * load destination data  */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|RASTEROP_COMPLETE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
name|FONT_X
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
name|FONT_Y
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
name|FONT_WIDTH
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/*--------------------------------------- * setup for processor to bitmap xfer  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|PBT
operator||
name|OCRB
operator||
literal|2
operator||
name|DTE
operator||
literal|2
expr_stmt|;
comment|/*----------------------------------------------- * iteratively do the processor to bitmap xfer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ROWS
condition|;
operator|++
name|i
control|)
block|{
comment|/* PTOB a scan line */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|i
init|;
name|j
operator|<
literal|48
condition|;
operator|++
name|j
control|)
block|{
comment|/* PTOB one scan of a char cell */
name|packed
operator|=
name|q_font
index|[
name|k
index|]
expr_stmt|;
name|k
operator|+=
name|ROWS
expr_stmt|;
name|packed
operator||=
operator|(
operator|(
name|short
operator|)
name|q_font
index|[
name|k
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|k
operator|+=
name|ROWS
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|TX_READY
argument_list|)
expr_stmt|;
name|adder
operator|->
name|id_data
operator|=
name|packed
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* ldfont */
end_comment

begin_comment
comment|/********************************************************************* * *	led_control()... twiddle LK-201 LED's * ********************************************************************** * *	led_control(cmd, led_mask); *	int cmd;	LED enable/disable command *	int led_mask;	which LED(s) to twiddle * *************/
end_comment

begin_macro
name|led_control
argument_list|(
argument|cmd
argument_list|,
argument|led_mask
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|led_mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
specifier|register
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
operator|.
name|duart
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmd
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|led_mask
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_comment
comment|/* led_control */
end_comment

begin_comment
comment|/*******************************************************************  * *	scroll_up()... move the screen up one character height * ******************************************************************** * *	calling convention: * *		scroll_up(adder); *		struct adder *adder;    ;address of adder * ********/
end_comment

begin_expr_stmt
name|scroll_up
argument_list|(
name|adder
argument_list|)
specifier|register
expr|struct
name|adder
operator|*
name|adder
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*------------------------------------------ * setup VIPER operand control registers  */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|ADDRESS_COMPLETE
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/* select all planes */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
comment|/*---------------------------------------- * load DESTINATION origin and vectors  */
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|NORMAL
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
literal|864
operator|-
name|CHAR_HEIGHT
expr_stmt|;
comment|/*----------------------------------- * load SOURCE origin and vectors  */
name|adder
operator|->
name|source_1_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_1_dx
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|source_1_y
operator|=
literal|0
operator|+
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|source_1_dy
operator|=
literal|864
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R1
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|RASTEROP
operator||
name|OCRB
operator||
literal|0
operator||
name|S1E
operator||
name|DTE
expr_stmt|;
comment|/*-------------------------------------------- * do a rectangle clear of last screen line */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SOURCE
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
operator|(
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
operator|)
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
comment|/* set up the width of	*/
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/* rectangle */
name|adder
operator|->
name|rasterop_mode
operator|=
operator|(
name|NORMAL
operator||
name|DST_WRITE_ENABLE
operator|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|RASTEROP_COMPLETE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
literal|864
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
literal|1024
expr_stmt|;
comment|/* set up the height	*/
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
comment|/* of rectangle		*/
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R2
argument_list|,
operator|(
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
operator|)
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
operator|(
name|RASTEROP
operator||
name|OCRB
operator||
name|LF_R2
operator||
name|DTE
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* scroll_up */
end_comment

begin_comment
comment|/********************************************************************** * *	set_defaults()... init the QDSS device and driver defaults * **********************************************************************/
end_comment

begin_macro
name|set_defaults
argument_list|()
end_macro

begin_block
block|{
name|setup_input
argument_list|()
expr_stmt|;
comment|/* init the DUART */
name|setup_dragon
argument_list|()
expr_stmt|;
comment|/* init the ADDER/VIPER stuff */
name|ldcursor
argument_list|()
expr_stmt|;
comment|/* load default cursor map */
block|}
end_block

begin_comment
comment|/* set_defaults */
end_comment

begin_comment
comment|/********************************************************************* * *	setup_dragon()... init the ADDER, VIPER, bitmaps,& color map * *********************************************************************/
end_comment

begin_macro
name|setup_dragon
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|short
modifier|*
name|memcsr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* general purpose variables */
name|int
name|status
decl_stmt|;
name|short
name|top
decl_stmt|;
comment|/* clipping/scrolling boundaries */
name|short
name|bottom
decl_stmt|;
name|short
name|right
decl_stmt|;
name|short
name|left
decl_stmt|;
name|short
modifier|*
name|red
decl_stmt|;
comment|/* color map pointers */
name|short
modifier|*
name|green
decl_stmt|;
name|short
modifier|*
name|blue
decl_stmt|;
comment|/*------------------ * init for setup */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
operator|.
name|adder
expr_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
operator|.
name|dga
expr_stmt|;
name|memcsr
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
operator|.
name|memcsr
expr_stmt|;
operator|*
name|memcsr
operator|=
name|SYNC_ON
expr_stmt|;
comment|/* blank screen and turn off LED's */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/*---------------------- * set monitor timing */
name|adder
operator|->
name|x_scan_count_0
operator|=
literal|0x2800
expr_stmt|;
name|adder
operator|->
name|x_scan_count_1
operator|=
literal|0x1020
expr_stmt|;
name|adder
operator|->
name|x_scan_count_2
operator|=
literal|0x003A
expr_stmt|;
name|adder
operator|->
name|x_scan_count_3
operator|=
literal|0x38F0
expr_stmt|;
name|adder
operator|->
name|x_scan_count_4
operator|=
literal|0x6128
expr_stmt|;
name|adder
operator|->
name|x_scan_count_5
operator|=
literal|0x093A
expr_stmt|;
name|adder
operator|->
name|x_scan_count_6
operator|=
literal|0x313C
expr_stmt|;
name|adder
operator|->
name|sync_phase_adj
operator|=
literal|0x0100
expr_stmt|;
name|adder
operator|->
name|x_scan_conf
operator|=
literal|0x00C8
expr_stmt|;
comment|/*--------------------------------------------------------- * got a bug in secound pass ADDER! lets take care of it */
comment|/* normally, just use the code in the following bug fix code, but to  	* make repeated demos look pretty, load the registers as if there was 	* no bug and then test to see if we are getting sync */
name|adder
operator|->
name|y_scan_count_0
operator|=
literal|0x135F
expr_stmt|;
name|adder
operator|->
name|y_scan_count_1
operator|=
literal|0x3363
expr_stmt|;
name|adder
operator|->
name|y_scan_count_2
operator|=
literal|0x2366
expr_stmt|;
name|adder
operator|->
name|y_scan_count_3
operator|=
literal|0x0388
expr_stmt|;
comment|/* if no sync, do the bug fix code */
if|if
condition|(
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
operator|==
name|BAD
condition|)
block|{
comment|/* first load all Y scan registers with very short frame and 	    * wait for scroll service.  This guarantees at least one SYNC  	    * to fix the pass 2 Adder initialization bug (synchronizes 	    * XCINCH with DMSEEDH) */
name|adder
operator|->
name|y_scan_count_0
operator|=
literal|0x01
expr_stmt|;
name|adder
operator|->
name|y_scan_count_1
operator|=
literal|0x01
expr_stmt|;
name|adder
operator|->
name|y_scan_count_2
operator|=
literal|0x01
expr_stmt|;
name|adder
operator|->
name|y_scan_count_3
operator|=
literal|0x01
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* delay at least 1 full frame time */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* now load the REAL sync values (in reverse order just to 	    *  be safe.  */
name|adder
operator|->
name|y_scan_count_3
operator|=
literal|0x0388
expr_stmt|;
name|adder
operator|->
name|y_scan_count_2
operator|=
literal|0x2366
expr_stmt|;
name|adder
operator|->
name|y_scan_count_1
operator|=
literal|0x3363
expr_stmt|;
name|adder
operator|->
name|y_scan_count_0
operator|=
literal|0x135F
expr_stmt|;
block|}
comment|/*---------------------------- * zero the index registers */
name|adder
operator|->
name|x_index_pending
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_index_pending
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|x_index_new
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_index_new
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|x_index_old
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_index_old
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|pause
operator|=
literal|0
expr_stmt|;
comment|/*---------------------------------------- * set rasterop mode to normal pen down */
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|DST_INDEX_ENABLE
operator||
name|NORMAL
expr_stmt|;
comment|/*-------------------------------------------------- * set the rasterop registers to a default values */
name|adder
operator|->
name|source_1_dx
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|source_1_dy
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|source_1_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_1_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
comment|/*------------------------ * scale factor = unity */
name|adder
operator|->
name|fast_scale
operator|=
name|UNITY
expr_stmt|;
name|adder
operator|->
name|slow_scale
operator|=
name|UNITY
expr_stmt|;
comment|/*------------------------------- * set the source 2 parameters */
name|adder
operator|->
name|source_2_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_2_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_2_size
operator|=
literal|0x0022
expr_stmt|;
comment|/*----------------------------------------------- * initialize plane addresses for eight vipers */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0002
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0002
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0010
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0020
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0040
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0006
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0080
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0007
argument_list|)
expr_stmt|;
comment|/* initialize the external registers. */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_SCROLL_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/* initialize resolution mode */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MEMORY_BUS_WIDTH
argument_list|,
literal|0x000C
argument_list|)
expr_stmt|;
comment|/* bus width = 16 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|RESOLUTION_MODE
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* one bit/pixel */
comment|/* initialize viper registers */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SCROLL_CONSTANT
argument_list|,
name|SCROLL_ENABLE
operator||
name|VIPER_LEFT
operator||
name|VIPER_UP
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SCROLL_FILL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/*---------------------------------------------------- * set clipping and scrolling limits to full screen */
for|for
control|(
name|i
operator|=
literal|1000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|ADDRESS_COMPLETE
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"timeout trying to setup clipping\n"
argument_list|)
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|bottom
operator|=
literal|2048
expr_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
name|right
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|x_clip_min
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|x_clip_max
operator|=
name|right
expr_stmt|;
name|adder
operator|->
name|y_clip_min
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|y_clip_max
operator|=
name|bottom
expr_stmt|;
name|adder
operator|->
name|scroll_x_min
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|scroll_x_max
operator|=
name|right
expr_stmt|;
name|adder
operator|->
name|scroll_y_min
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|scroll_y_max
operator|=
name|bottom
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* wait at LEAST 1 full frame */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|x_index_pending
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|y_index_pending
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|x_index_new
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|y_index_new
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|x_index_old
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|y_index_old
operator|=
name|top
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|ADDRESS_COMPLETE
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"timeout waiting for ADDRESS_COMPLETE bit\n"
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LEFT_SCROLL_MASK
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|RIGHT_SCROLL_MASK
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/*------------------------------------------------------------ * set source and the mask register to all ones (ie: white) */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SOURCE
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*-------------------------------------------------------------- * initialize Operand Control Register banks for fill command */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_A
argument_list|,
name|EXT_NONE
operator||
name|INT_M1_M2
operator||
name|NO_ID
operator||
name|WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC2_OCR_A
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_A
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|NO_ID
operator||
name|WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC2_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_M1_M2
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
comment|/*------------------------------------------------------------------ * init Logic Unit Function registers, (these are just common values, * and may be changed as required).  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R1
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R2
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
operator||
name|INV_M1_M2
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R3
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_D_OR_S
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R4
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_D_XOR_S
argument_list|)
expr_stmt|;
comment|/*---------------------------------------- * load the color map for black& white */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|VSYNC
operator|)
condition|;
operator|++
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"timeout waiting for VSYNC bit\n"
argument_list|)
expr_stmt|;
name|red
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
operator|.
name|red
expr_stmt|;
name|green
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
operator|.
name|green
expr_stmt|;
name|blue
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
operator|.
name|blue
expr_stmt|;
operator|*
name|red
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* black */
operator|*
name|green
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|blue
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|red
operator|--
operator|=
literal|0xFF
expr_stmt|;
comment|/* white */
operator|*
name|green
operator|--
operator|=
literal|0xFF
expr_stmt|;
operator|*
name|blue
operator|--
operator|=
literal|0xFF
expr_stmt|;
comment|/*---------------------------------- 	* set color map for mouse cursor */
name|red
operator|+=
literal|254
expr_stmt|;
name|green
operator|+=
literal|254
expr_stmt|;
name|blue
operator|+=
literal|254
expr_stmt|;
operator|*
name|red
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* black */
operator|*
name|green
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|blue
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|red
operator|=
literal|0xFF
expr_stmt|;
comment|/* white */
operator|*
name|green
operator|=
literal|0xFF
expr_stmt|;
operator|*
name|blue
operator|=
literal|0xFF
expr_stmt|;
comment|/*--------------------------------------------------------------------------- * clear the bitmap a piece at a time.  Since the fast scroll clear only clears * the current displayed portion of the bitmap put a temporary value in the y * limit register so we can access whole bitmap  */
name|adder
operator|->
name|x_limit
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|y_limit
operator|=
literal|2048
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|0
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* wait at LEAST 1 full frame */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|SCROLL_ERASE
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|864
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|SCROLL_ERASE
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|1728
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|SCROLL_ERASE
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|0
expr_stmt|;
comment|/* back to normal */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|x_limit
operator|=
name|MAX_SCREEN_X
expr_stmt|;
name|adder
operator|->
name|y_limit
operator|=
name|MAX_SCREEN_Y
operator|+
name|FONT_HEIGHT
expr_stmt|;
operator|*
name|memcsr
operator|=
name|SYNC_ON
operator||
name|UNBLANK
expr_stmt|;
comment|/* turn off leds and turn on video */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* setup_dragon */
end_comment

begin_comment
comment|/****************************************************************** * *	setup_input()... init the DUART and set defaults in input *			 devices * ******************************************************************/
end_comment

begin_macro
name|setup_input
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
comment|/* DUART register structure pointer */
specifier|register
name|int
name|bits
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* scratch variables */
name|short
name|status
decl_stmt|;
comment|/*--------------- * init stuff */
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
operator|.
name|duart
expr_stmt|;
comment|/*--------------------------------------------- * setup the DUART for kbd& pointing device */
name|duart
operator|->
name|cmdA
operator|=
name|RESET_M
expr_stmt|;
comment|/* reset mode reg ptr for kbd */
name|duart
operator|->
name|modeA
operator|=
literal|0x13
expr_stmt|;
comment|/* 8 bits, no parity, rcv IE, */
comment|/* no RTS control,char error mode */
name|duart
operator|->
name|modeA
operator|=
literal|0x07
expr_stmt|;
comment|/* 1 stop bit,CTS does not IE XMT */
comment|/* no RTS control,no echo or loop */
name|duart
operator|->
name|auxctl
operator|=
literal|0x00
expr_stmt|;
comment|/* baud rate set 1 */
name|duart
operator|->
name|clkselA
operator|=
literal|0x99
expr_stmt|;
comment|/* 4800 baud for kbd */
comment|/* reset everything for keyboard */
for|for
control|(
name|bits
operator|=
name|RESET_M
init|;
name|bits
operator|<
name|START_BREAK
condition|;
name|bits
operator|+=
literal|0x10
control|)
name|duart
operator|->
name|cmdA
operator|=
name|bits
expr_stmt|;
name|duart
operator|->
name|cmdA
operator|=
name|EN_RCV
operator||
name|EN_XMT
expr_stmt|;
comment|/* enbl xmt& rcv for kbd */
comment|/*-------------------------- * init keyboard defaults */
comment|/* 	for (i = 500; i> 0; --i) {     	    if ((status = duart->statusA)& XMT_RDY) {         	duart->dataA = LK_DEFAULTS; 		break;     	    } 	}  	for (j = 0; j< 3; ++j) { 	    for (i = 50000; i> 0; --i) {     	        if ((status = duart->statusA)& RCV_RDY) { 		    status = duart->dataA; 		    break;  	        } 	    } 	}  	if (i == 0) 	    printf("LK-201 init error\n"); */
comment|/*-------- * exit */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* setup_input */
end_comment

begin_comment
comment|/********************************************************************** * *	wait_status()... delay for at least one display frame time * *********************************************************************** * *	calling convention: * *		wait_status(adder, mask); *		struct *adder adder; *		int mask; * *	return: BAD means that we timed out without ever seeing the *	              vertical sync status bit *		GOOD otherwise * **************/
end_comment

begin_expr_stmt
name|wait_status
argument_list|(
name|adder
argument_list|,
name|mask
argument_list|)
specifier|register
expr|struct
name|adder
operator|*
name|adder
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|10000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|mask
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"timeout polling for 0x%x in adder->status\n"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|BAD
operator|)
return|;
block|}
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_comment
comment|/* wait_status */
end_comment

begin_comment
comment|/********************************************************************** * *	write_ID()... write out onto the ID bus * *********************************************************************** * *	calling convention: * *		struct *adder adder;	;pntr to ADDER structure *		short adrs;		;VIPER address *		short data;		;data to be written *		write_ID(adder); * *	return: BAD means that we timed out waiting for status bits *		      VIPER-access-specific status bits *		GOOD otherwise * **************/
end_comment

begin_expr_stmt
name|write_ID
argument_list|(
name|adder
argument_list|,
name|adrs
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|adder
operator|*
name|adder
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|short
name|adrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|short
name|status
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|100000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|ADDRESS_COMPLETE
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|ERR
goto|;
for|for
control|(
name|i
operator|=
literal|100000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|TX_READY
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|adder
operator|->
name|id_data
operator|=
name|data
expr_stmt|;
name|adder
operator|->
name|command
operator|=
name|ID_LOAD
operator||
name|adrs
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
name|ERR
label|:
name|printf
argument_list|(
literal|"timeout trying to write to VIPER\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BAD
operator|)
return|;
block|}
end_block

begin_comment
comment|/* write_ID */
end_comment

end_unit

