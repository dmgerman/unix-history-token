begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 Jan-Simon Pendry  * Copyright (c) 1994  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry.  *  * %sccs.include.redist.c%  *  *	@(#)union_subr.c	1.2 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|"union.h"
end_include

begin_comment
comment|/*<miscfs/union/union.h>*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|union_node
modifier|*
name|unhead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unvplock
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|union_init
parameter_list|()
block|{
name|unhead
operator|=
literal|0
expr_stmt|;
name|unvplock
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * allocate a union_node/vnode pair.  the vnode is  * referenced and locked.  *  * all union_nodes are maintained on a singly-linked  * list.  new nodes are only allocated when they cannot  * be found on this list.  entries on the list are  * removed when the vfs reclaim entry is called.  *  * a single lock is kept for the entire list.  this is  * needed because the getnewvnode() function can block  * waiting for a vnode to become free, in which case there  * may be more than one process trying to get the same  * vnode.  this lock is only taken if we are going to  * call getnewvnode, since the kernel itself is single-threaded.  *  * if an entry is found on the list, then call vget() to  * take a reference.  this is done because there may be  * zero references to it and so it needs to removed from  * the vnode free list.  */
end_comment

begin_function
name|int
name|union_allocvp
parameter_list|(
name|vpp
parameter_list|,
name|mp
parameter_list|,
name|dvp
parameter_list|,
name|cnp
parameter_list|,
name|uppervp
parameter_list|,
name|lowervp
parameter_list|)
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
comment|/* may be null */
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
comment|/* may be null */
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|;
comment|/* may be null */
name|struct
name|vnode
modifier|*
name|lowervp
decl_stmt|;
comment|/* may be null */
block|{
name|int
name|error
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|struct
name|union_node
modifier|*
modifier|*
name|pp
decl_stmt|;
name|loop
label|:
for|for
control|(
name|un
operator|=
name|unhead
init|;
name|un
operator|!=
literal|0
condition|;
name|un
operator|=
name|un
operator|->
name|un_next
control|)
block|{
if|if
condition|(
operator|(
name|un
operator|->
name|un_lowervp
operator|==
name|lowervp
operator|||
name|un
operator|->
name|un_lowervp
operator|==
literal|0
operator|)
operator|&&
operator|(
name|un
operator|->
name|un_uppervp
operator|==
name|uppervp
operator|||
name|un
operator|->
name|un_uppervp
operator|==
literal|0
operator|)
operator|&&
operator|(
name|UNIONTOV
argument_list|(
name|un
argument_list|)
operator|->
name|v_mount
operator|==
name|mp
operator|)
condition|)
block|{
if|if
condition|(
name|vget
argument_list|(
name|un
operator|->
name|un_vnode
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|loop
goto|;
name|un
operator|->
name|un_lowervp
operator|=
name|lowervp
expr_stmt|;
name|un
operator|->
name|un_uppervp
operator|=
name|uppervp
expr_stmt|;
operator|*
name|vpp
operator|=
name|un
operator|->
name|un_vnode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * otherwise lock the vp list while we call getnewvnode 	 * since that can block. 	 */
if|if
condition|(
name|unvplock
operator|&
name|UN_LOCKED
condition|)
block|{
name|unvplock
operator||=
name|UN_WANT
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|unvplock
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|unvplock
operator||=
name|UN_LOCKED
expr_stmt|;
name|error
operator|=
name|getnewvnode
argument_list|(
name|VT_UNION
argument_list|,
name|mp
argument_list|,
name|union_vnodeop_p
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|MALLOC
argument_list|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_data
argument_list|,
name|void
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|union_node
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|un
operator|=
name|VTOUNION
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_next
operator|=
literal|0
expr_stmt|;
name|un
operator|->
name|un_dirvp
operator|=
name|dvp
expr_stmt|;
name|un
operator|->
name|un_uppervp
operator|=
name|uppervp
expr_stmt|;
name|un
operator|->
name|un_lowervp
operator|=
name|lowervp
expr_stmt|;
name|un
operator|->
name|un_vnode
operator|=
operator|*
name|vpp
expr_stmt|;
name|un
operator|->
name|un_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cnp
condition|)
block|{
name|un
operator|->
name|un_path
operator|=
name|malloc
argument_list|(
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|un
operator|->
name|un_path
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_path
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|un
operator|->
name|un_path
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|un
operator|->
name|un_pid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* add to union vnode list */
for|for
control|(
name|pp
operator|=
operator|&
name|unhead
init|;
operator|*
name|pp
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|un_next
control|)
continue|continue;
operator|*
name|pp
operator|=
name|un
expr_stmt|;
name|out
label|:
name|unvplock
operator|&=
operator|~
name|UN_LOCKED
expr_stmt|;
if|if
condition|(
name|unvplock
operator|&
name|UN_WANT
condition|)
block|{
name|unvplock
operator|&=
operator|~
name|UN_WANT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|unvplock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|un
condition|)
name|VOP_LOCK
argument_list|(
name|UNIONTOV
argument_list|(
name|un
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_freevp
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
modifier|*
name|unpp
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|vp
argument_list|)
decl_stmt|;
for|for
control|(
name|unpp
operator|=
operator|&
name|unhead
init|;
operator|*
name|unpp
operator|!=
literal|0
condition|;
name|unpp
operator|=
operator|&
operator|(
operator|*
name|unpp
operator|)
operator|->
name|un_next
control|)
block|{
if|if
condition|(
operator|*
name|unpp
operator|==
name|un
condition|)
block|{
operator|*
name|unpp
operator|=
name|un
operator|->
name|un_next
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|un
operator|->
name|un_path
condition|)
name|FREE
argument_list|(
name|un
operator|->
name|un_path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|vp
operator|->
name|v_data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

