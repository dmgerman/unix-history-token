begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California  * All rights reserved.  *  * This code is derived from the null layer of  * John Heidemann from the UCLA Ficus project and  * Jan-Simon Pendry's loopback file system.  *  * %sccs.include.redist.c%  *  *	@(#)umap_vnops.c	1.1 (Berkeley) %G%  *  * Ancestors:  *	@(#)lofs_vnops.c	1.2 (Berkeley) 6/18/92  *	$Id: lofs_vnops.c,v 1.11 1992/05/30 10:05:43 jsp Exp jsp $  *	...and...  *	@(#)umap_vnodeops.c 1.20 92/07/07 UCLA Ficus project  */
end_comment

begin_comment
comment|/*  * Umap Layer  *  * The umap layer duplicates a portion of the file system  * name space under a new name.  In this respect, it is  * similar to the loopback file system.  It differs from  * the loopback fs in two respects:  it is implemented using  * a bypass operation, and it's "umap-node"s stack above  * all lower-layer vnodes, not just over directory vnodes.  *  * The umap layer is the minimum file system layer,  * simply bypassing all possible operations to the lower layer  * for processing there.  All but vop_getattr, _inactive, _reclaim,  * and _print are bypassed.  *  * Vop_getattr is not bypassed so that we can change the fsid being  * returned.  Vop_{inactive,reclaim} are bypassed so that  * they can handle freeing umap-layer specific data.  * Vop_print is not bypassed for debugging.  *  *  * INVOKING OPERATIONS ON LOWER LAYERS  *  * NEEDSWORK: Describe methods to invoke operations on the lower layer  * (bypass vs. VOP).  *  *  * CREATING NEW FILESYSTEM LAYERS  *  * One of the easiest ways to construct new file system layers is to make  * a copy of the umap layer, rename all files and variables, and  * then begin modifing the copy.  Sed can be used to easily rename  * all variables.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<umapfs/umap.h>
end_include

begin_decl_stmt
name|int
name|umap_bug_bypass
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for debugging: enables bypass printf'ing */
end_comment

begin_comment
comment|/*  * This is the 10-Apr-92 bypass routine.  *    This version has been optimized for speed, throwing away some  * safety checks.  It should still always work, but it's not as  * robust to programmer errors.  *    Define SAFETY to include some error checking code.  *  * In general, we map all vnodes going down and unmap them on the way back.  * As an exception to this, vnodes can be marked "unmapped" by setting  * the Nth bit in operation's vdesc_flags.  *  * Also, some BSD vnode operations have the side effect of vrele'ing  * their arguments.  With stacking, the reference counts are held  * by the upper node, not the lower one, so we must handle these  * side-effects here.  This is not of concern in Sun-derived systems  * since there are no such side-effects.  *  * This makes the following assumptions:  * - only one returned vpp  * - no INOUT vpp's (Sun's vop_open has one of these)  * - the vnode operation vector of the first vnode should be used  *   to determine what implementation of the op should be invoked  * - all mapped vnodes are of our vnode-type (NEEDSWORK:  *   problems on rmdir'ing mount points and renaming?)  */
end_comment

begin_function
name|int
name|umap_bypass
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_generic_args
modifier|*
name|ap
decl_stmt|;
block|{
specifier|extern
name|int
function_decl|(
modifier|*
modifier|*
name|umap_vnodeop_p
function_decl|)
parameter_list|()
function_decl|;
comment|/* not extern, really "forward" */
name|int
modifier|*
name|mapdata
decl_stmt|,
name|nentries
decl_stmt|;
name|int
modifier|*
name|gmapdata
decl_stmt|,
name|gnentries
decl_stmt|;
name|struct
name|ucred
modifier|*
modifier|*
name|credpp
decl_stmt|,
modifier|*
name|credp
decl_stmt|,
modifier|*
name|savecredp
decl_stmt|,
modifier|*
name|saveucredp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
modifier|*
name|this_vp_p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|old_vps
index|[
name|VDESC_MAX_VPS
index|]
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vps_p
index|[
name|VDESC_MAX_VPS
index|]
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
modifier|*
name|vppp
decl_stmt|;
name|struct
name|vnodeop_desc
modifier|*
name|descp
init|=
name|ap
operator|->
name|a_desc
decl_stmt|;
name|int
name|reles
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|umap_bug_bypass
condition|)
name|printf
argument_list|(
literal|"umap_bypass: %s\n"
argument_list|,
name|descp
operator|->
name|vdesc_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SAFETY
comment|/* 	 * We require at least one vp. 	 */
if|if
condition|(
name|descp
operator|->
name|vdesc_vp_offsets
operator|==
name|UMAP
operator|||
name|descp
operator|->
name|vdesc_vp_offsets
index|[
literal|0
index|]
operator|==
name|VDESC_NO_OFFSET
condition|)
name|panic
argument_list|(
literal|"umap_bypass: no vp's in map.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Map the vnodes going in. 	 * Later, we'll invoke the operation based on 	 * the first mapped vnode's operation vector. 	 */
name|reles
operator|=
name|descp
operator|->
name|vdesc_flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VDESC_MAX_VPS
condition|;
name|reles
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|descp
operator|->
name|vdesc_vp_offsets
index|[
name|i
index|]
operator|==
name|VDESC_NO_OFFSET
condition|)
break|break;
comment|/* bail out at end of list */
name|vps_p
index|[
name|i
index|]
operator|=
name|this_vp_p
operator|=
name|VOPARG_OFFSETTO
argument_list|(
expr|struct
name|vnode
operator|*
operator|*
argument_list|,
name|descp
operator|->
name|vdesc_vp_offsets
index|[
name|i
index|]
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|vp1
operator|=
operator|*
name|vps_p
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 		 * We're not guaranteed that any but the first vnode 		 * are of our type.  Check for and don't map any 		 * that aren't. 		 */
if|if
condition|(
operator|(
operator|*
name|this_vp_p
operator|)
operator|->
name|v_op
operator|!=
name|umap_vnodeop_p
condition|)
block|{
name|old_vps
index|[
name|i
index|]
operator|=
name|UMAP
expr_stmt|;
block|}
else|else
block|{
name|old_vps
index|[
name|i
index|]
operator|=
operator|*
name|this_vp_p
expr_stmt|;
operator|*
operator|(
name|vps_p
index|[
name|i
index|]
operator|)
operator|=
name|UMAPVPTOLOWERVP
argument_list|(
operator|*
name|this_vp_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|reles
operator|&
literal|1
condition|)
name|VREF
argument_list|(
operator|*
name|this_vp_p
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* Doctor the credentials.  (That's the purpose of this layer.) */
if|if
condition|(
name|descp
operator|->
name|vdesc_cred_offset
operator|!=
name|VDESC_NO_OFFSET
condition|)
block|{
name|credpp
operator|=
name|VOPARG_OFFSETTO
argument_list|(
expr|struct
name|ucred
operator|*
operator|*
argument_list|,
name|descp
operator|->
name|vdesc_cred_offset
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/* Save old values */
name|savecredp
operator|=
operator|(
operator|*
name|credpp
operator|)
expr_stmt|;
name|saveucredp
operator|=
name|u
operator|.
name|u_cred
expr_stmt|;
operator|(
operator|*
name|credpp
operator|)
operator|=
name|u
operator|.
name|u_cred
operator|=
name|crdup
argument_list|(
name|savecredp
argument_list|)
expr_stmt|;
name|credp
operator|=
operator|*
name|credpp
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|credp
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_bypass: user was %d, group %d\n"
argument_list|,
name|credp
operator|->
name|cr_uid
argument_list|,
name|credp
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
name|nentries
operator|=
name|MOUNTTOUMAPMOUNT
argument_list|(
name|vp1
operator|->
name|v_vfsp
argument_list|)
operator|->
name|info_nentries
expr_stmt|;
name|mapdata
operator|=
operator|&
operator|(
name|MOUNTTOUMAPMOUNT
argument_list|(
name|vp1
operator|->
name|v_vfsp
argument_list|)
operator|->
name|info_mapdata
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|gnentries
operator|=
name|MOUNTTOUMAPMOUNT
argument_list|(
name|vp1
operator|->
name|v_vfsp
argument_list|)
operator|->
name|info_gnentries
expr_stmt|;
name|gmapdata
operator|=
operator|&
operator|(
name|MOUNTTOUMAPMOUNT
argument_list|(
name|vp1
operator|->
name|v_vfsp
argument_list|)
operator|->
name|info_gmapdata
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|credp
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"nentries = %d, gnentries = %d\n"
argument_list|,
name|nentries
argument_list|,
name|gnentries
argument_list|)
expr_stmt|;
comment|/* Map all ids in the credential structure. */
name|umap_mapids
argument_list|(
name|credp
argument_list|,
name|mapdata
argument_list|,
name|nentries
argument_list|,
name|gmapdata
argument_list|,
name|gnentries
argument_list|)
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|credp
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_bypass: user now %d, group %d\n"
argument_list|,
name|credp
operator|->
name|cr_uid
argument_list|,
name|credp
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Call the operation on the lower layer 	 * with the modified argument structure. 	 */
name|error
operator|=
name|VCALL
argument_list|(
operator|*
operator|(
name|vps_p
index|[
literal|0
index|]
operator|)
argument_list|,
name|descp
operator|->
name|vdesc_offset
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/* 	 * Maintain the illusion of call-by-value 	 * by restoring vnodes in the argument structure 	 * to their original value. 	 */
name|reles
operator|=
name|descp
operator|->
name|vdesc_flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VDESC_MAX_VPS
condition|;
name|reles
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|descp
operator|->
name|vdesc_vp_offsets
index|[
name|i
index|]
operator|==
name|VDESC_NO_OFFSET
condition|)
break|break;
comment|/* bail out at end of list */
if|if
condition|(
name|old_vps
index|[
name|i
index|]
condition|)
block|{
operator|*
operator|(
name|vps_p
index|[
name|i
index|]
operator|)
operator|=
name|old_vps
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|reles
operator|&
literal|1
condition|)
name|vrele
argument_list|(
operator|*
operator|(
name|vps_p
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* 	 * Map the possible out-going vpp 	 * (Assumes that the lower layer always returns 	 * a VREF'ed vpp unless it gets an error.) 	 */
if|if
condition|(
name|descp
operator|->
name|vdesc_vpp_offset
operator|!=
name|VDESC_NO_OFFSET
operator|&&
operator|!
operator|(
name|descp
operator|->
name|vdesc_flags
operator|&
name|VDESC_NOMAP_VPP
operator|)
operator|&&
operator|!
name|error
condition|)
block|{
comment|/* 		 * XXX - even though symlink has a vpp arg, 		 * it doesn't return a VREF'ed vpp in that 		 * field.  The vpp arg should become a vp 		 * arg. 		 */
if|if
condition|(
name|descp
operator|==
name|VDESC
argument_list|(
name|vop_symlink
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|UMAPFS_DIAGNOSTIC
name|printf
argument_list|(
literal|"umap_bypass (symlink), lowervp->usecount = %d\n"
argument_list|,
operator|(
operator|*
operator|*
name|vppp
operator|)
operator|->
name|v_usecount
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
empty_stmt|;
name|vppp
operator|=
name|VOPARG_OFFSETTO
argument_list|(
expr|struct
name|vnode
operator|*
operator|*
operator|*
argument_list|,
name|descp
operator|->
name|vdesc_vpp_offset
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
name|umap_node_create
argument_list|(
name|old_vps
index|[
literal|0
index|]
operator|->
name|v_mount
argument_list|,
operator|*
operator|*
name|vppp
argument_list|,
operator|*
name|vppp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/*  	 * Free duplicate cred structure and restore old one. 	 */
if|if
condition|(
name|descp
operator|->
name|vdesc_cred_offset
operator|!=
name|VDESC_NO_OFFSET
condition|)
block|{
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|credp
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_bypass: returning-user was %d\n"
argument_list|,
name|credp
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|credp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|credpp
operator|)
operator|=
name|savecredp
expr_stmt|;
name|u
operator|.
name|u_cred
operator|=
name|saveucredp
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
operator|&&
operator|(
operator|*
name|credpp
operator|)
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_bypass: returning-user now %d\n\n"
argument_list|,
operator|(
operator|*
name|credpp
operator|)
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  We handle getattr to change the fsid.  */
end_comment

begin_function
name|int
name|umap_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
modifier|*
name|ap
decl_stmt|;
block|{
name|short
name|uid
decl_stmt|,
name|gid
decl_stmt|;
name|int
name|error
decl_stmt|,
name|tmpid
decl_stmt|,
modifier|*
name|mapdata
decl_stmt|,
name|nentries
decl_stmt|,
modifier|*
name|gmapdata
decl_stmt|,
name|gnentries
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|umap_bypass
argument_list|(
name|ap
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* Requires that arguments be restored. */
name|ap
operator|->
name|a_vap
operator|->
name|va_fsid
operator|=
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
comment|/* umap needs to map the uid and gid returned by a stat 		into the proper values for this site.  This involves 		finding the returned uid in the mapping information, 		translating it into the uid on the other end, 		and filling in the proper field in the vattr 		structure pointed to by ap->a_vap.  The group 		is easier, since currently all groups will be 		translate to the NULLGROUP. */
comment|/* Find entry in map */
name|uid
operator|=
name|ap
operator|->
name|a_vap
operator|->
name|va_uid
expr_stmt|;
name|gid
operator|=
name|ap
operator|->
name|a_vap
operator|->
name|va_gid
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
condition|)
name|printf
argument_list|(
literal|"umap_getattr: mapped uid = %d, mapped gid = %d\n"
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|vp1p
operator|=
name|VOPARG_OFFSETTO
argument_list|(
expr|struct
name|vnode
operator|*
operator|*
argument_list|,
name|descp
operator|->
name|vdesc_vp_offsets
index|[
literal|0
index|]
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|nentries
operator|=
name|MOUNTTOUMAPMOUNT
argument_list|(
operator|(
operator|*
name|vp1p
operator|)
operator|->
name|v_vfsp
argument_list|)
operator|->
name|info_nentries
expr_stmt|;
name|mapdata
operator|=
operator|&
operator|(
name|MOUNTTOUMAPMOUNT
argument_list|(
operator|(
operator|*
name|vp1p
operator|)
operator|->
name|v_vfsp
argument_list|)
operator|->
name|info_mapdata
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|gnentries
operator|=
name|MOUNTTOUMAPMOUNT
argument_list|(
operator|(
operator|*
name|vp1p
operator|)
operator|->
name|v_vfsp
argument_list|)
operator|->
name|info_gnentries
expr_stmt|;
name|gmapdata
operator|=
operator|&
operator|(
name|MOUNTTOUMAPMOUNT
argument_list|(
operator|(
operator|*
name|vp1p
operator|)
operator|->
name|v_vfsp
argument_list|)
operator|->
name|info_gmapdata
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* Reverse map the uid for the vnode.  Since it's a reverse 		map, we can't use umap_mapids() to do it. */
name|tmpid
operator|=
name|umap_reverse_findid
argument_list|(
name|uid
argument_list|,
name|mapdata
argument_list|,
name|nentries
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpid
operator|!=
operator|-
literal|1
condition|)
block|{
name|ap
operator|->
name|a_vap
operator|->
name|va_uid
operator|=
operator|(
name|uid_t
operator|)
name|tmpid
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
condition|)
name|printf
argument_list|(
literal|"umap_getattr: original uid = %d\n"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
block|}
else|else
name|ap
operator|->
name|a_vap
operator|->
name|va_uid
operator|=
operator|(
name|uid_t
operator|)
name|NOBODY
expr_stmt|;
comment|/* Reverse map the gid for the vnode. */
name|tmpid
operator|=
name|umap_reverse_findid
argument_list|(
name|gid
argument_list|,
name|gmapdata
argument_list|,
name|gnentries
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpid
operator|!=
operator|-
literal|1
condition|)
block|{
name|ap
operator|->
name|a_vap
operator|->
name|va_gid
operator|=
operator|(
name|gid_t
operator|)
name|tmpid
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
condition|)
name|printf
argument_list|(
literal|"umap_getattr: original gid = %d\n"
argument_list|,
name|gid
argument_list|)
expr_stmt|;
block|}
else|else
name|ap
operator|->
name|a_vap
operator|->
name|va_gid
operator|=
operator|(
name|gid_t
operator|)
name|NULLGROUP
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|umap_inactive
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_inactive_args
modifier|*
name|ap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|UMAPFS_DIAGNOSTIC
name|printf
argument_list|(
literal|"umap_inactive(ap->a_vp = %x->%x)\n"
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|,
name|UMAPVPTOLOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Do nothing (and _don't_ bypass). 	 * Wait to vrele lowervp until reclaim, 	 * so that until then our umap_node is in the 	 * cache and reusable. 	 * 	 * NEEDSWORK: Someday, consider inactive'ing 	 * the lowervp and then trying to reactivate it 	 * like they do in the name lookup cache code. 	 * That's too much work for now. 	 */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|umap_reclaim
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_reclaim_args
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|targetvp
decl_stmt|;
comment|/* 	 * Note: at this point, ap->a_vp->v_op == dead_vnodeop_p. 	 */
ifdef|#
directive|ifdef
name|UMAPFS_DIAGNOSTIC
name|printf
argument_list|(
literal|"umap_reclaim(ap->a_vp = %x->%x)\n"
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|,
name|UMAPVPTOLOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|remque
argument_list|(
name|VTOUMAP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NEEDSWORK: What? */
name|vrele
argument_list|(
name|UMAPVPTOLOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* release lower layer */
name|FREE
argument_list|(
name|ap
operator|->
name|a_vp
operator|->
name|v_data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_vp
operator|->
name|v_data
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|umap_bmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bmap_args
modifier|*
name|ap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|UMAPFS_DIAGNOSTIC
name|printf
argument_list|(
literal|"umap_bmap(ap->a_vp = %x->%x)\n"
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|,
name|UMAPVPTOLOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|VOP_BMAP
argument_list|(
name|UMAPVPTOLOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_bn
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_bnp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|umap_strategy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_strategy_args
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|savedvp
decl_stmt|;
ifdef|#
directive|ifdef
name|UMAPFS_DIAGNOSTIC
name|printf
argument_list|(
literal|"umap_strategy(vp = %x->%x)\n"
argument_list|,
name|ap
operator|->
name|a_bp
operator|->
name|b_vp
argument_list|,
name|UMAPVPTOLOWERVP
argument_list|(
name|ap
operator|->
name|a_bp
operator|->
name|b_vp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|savedvp
operator|=
name|ap
operator|->
name|a_bp
operator|->
name|b_vp
expr_stmt|;
name|error
operator|=
name|VOP_STRATEGY
argument_list|(
name|ap
operator|->
name|a_bp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_bp
operator|->
name|b_vp
operator|=
name|savedvp
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|umap_print
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_print_args
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|printf
argument_list|(
literal|"\ttag VT_UMAPFS, vp=%x, lowervp=%x\n"
argument_list|,
name|vp
argument_list|,
name|UMAPVPTOLOWERVP
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Global vfs data structures  */
end_comment

begin_comment
comment|/*  * NEEDSWORK: strategy,bmap are hand coded currently.  They should  * go away with a merged buffer/block cache.  *  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
modifier|*
name|umap_vnodeop_p
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|vnodeopv_entry_desc
name|umap_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
name|umap_bypass
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
name|umap_getattr
block|}
block|,
block|{
operator|&
name|vop_inactive_desc
block|,
name|umap_inactive
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
name|umap_reclaim
block|}
block|,
block|{
operator|&
name|vop_print_desc
block|,
name|umap_print
block|}
block|,
block|{
operator|&
name|vop_bmap_desc
block|,
name|umap_bmap
block|}
block|,
block|{
operator|&
name|vop_strategy_desc
block|,
name|umap_strategy
block|}
block|,
block|{
operator|(
expr|struct
name|vnodeop_desc
operator|*
operator|)
name|UMAP
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|UMAP
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnodeopv_desc
name|umap_vnodeop_opv_desc
init|=
block|{
operator|&
name|umap_vnodeop_p
block|,
name|umap_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

end_unit

