begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)lfs_syscalls.c	8.6 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufs_extern.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs_extern.h>
end_include

begin_define
define|#
directive|define
name|BUMP_FIP
parameter_list|(
name|SP
parameter_list|)
define|\
value|(SP)->fip = (FINFO *) (&(SP)->fip->fi_blocks[(SP)->fip->fi_nblocks])
end_define

begin_define
define|#
directive|define
name|INC_FINFO
parameter_list|(
name|SP
parameter_list|)
value|++((SEGSUM *)((SP)->segsum))->ss_nfinfo
end_define

begin_define
define|#
directive|define
name|DEC_FINFO
parameter_list|(
name|SP
parameter_list|)
value|--((SEGSUM *)((SP)->segsum))->ss_nfinfo
end_define

begin_comment
comment|/*  * Before committing to add something to a segment summary, make sure there  * is enough room.  S is the bytes added to the summary.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_SEG
parameter_list|(
name|s
parameter_list|)
define|\
value|if (sp->sum_bytes_left< (s)) {		\ 	(void) lfs_writeseg(fs, sp);	\ }
end_define

begin_decl_stmt
name|struct
name|buf
modifier|*
name|lfs_fakebuf
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
name|int
operator|,
name|size_t
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * lfs_markv:  *  * This will mark inodes and blocks dirty, so they are written into the log.  * It will block until all the blocks have been written.  The segment create  * time passed in the block_info and inode_info structures is used to decide  * if the data is valid for each block (in case some process dirtied a block  * or inode that is being cleaned between the determination that a block is  * live and the lfs_markv call).  *  *  0 on success  * -1/errno is return on error.  */
end_comment

begin_struct
struct|struct
name|lfs_markv_args
block|{
name|fsid_t
modifier|*
name|fsidp
decl_stmt|;
comment|/* file system */
name|BLOCK_INFO
modifier|*
name|blkiov
decl_stmt|;
comment|/* block array */
name|int
name|blkcnt
decl_stmt|;
comment|/* count of block array entries */
block|}
struct|;
end_struct

begin_function
name|int
name|lfs_markv
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|lfs_markv_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|BLOCK_INFO
modifier|*
name|blkp
decl_stmt|;
name|IFILE
modifier|*
name|ifp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|mount
modifier|*
name|mntp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|fsid_t
name|fsid
decl_stmt|;
name|void
modifier|*
name|start
decl_stmt|;
name|ino_t
name|lastino
decl_stmt|;
name|daddr_t
name|b_daddr
decl_stmt|,
name|v_daddr
decl_stmt|;
name|u_long
name|bsize
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|fsidp
argument_list|,
operator|&
name|fsid
argument_list|,
sizeof|sizeof
argument_list|(
name|fsid_t
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|mntp
operator|=
name|getvfs
argument_list|(
operator|&
name|fsid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cnt
operator|=
name|uap
operator|->
name|blkcnt
expr_stmt|;
name|start
operator|=
name|malloc
argument_list|(
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|blkiov
argument_list|,
name|start
argument_list|,
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|)
condition|)
goto|goto
name|err1
goto|;
comment|/* Mark blocks/inodes dirty.  */
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|mntp
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
name|bsize
operator|=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|lfs_seglock
argument_list|(
name|fs
argument_list|,
name|SEGM_SYNC
operator||
name|SEGM_CLEAN
argument_list|)
expr_stmt|;
name|sp
operator|=
name|fs
operator|->
name|lfs_sp
expr_stmt|;
for|for
control|(
name|v_daddr
operator|=
name|LFS_UNUSED_DADDR
operator|,
name|lastino
operator|=
name|LFS_UNUSED_INUM
operator|,
name|blkp
operator|=
name|start
init|;
name|cnt
operator|--
condition|;
operator|++
name|blkp
control|)
block|{
comment|/* 		 * Get the IFILE entry (only once) and see if the file still 		 * exists. 		 */
if|if
condition|(
name|lastino
operator|!=
name|blkp
operator|->
name|bi_inode
condition|)
block|{
if|if
condition|(
name|lastino
operator|!=
name|LFS_UNUSED_INUM
condition|)
block|{
comment|/* Finish up last file */
if|if
condition|(
name|sp
operator|->
name|fip
operator|->
name|fi_nblocks
operator|==
literal|0
condition|)
block|{
name|DEC_FINFO
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|+=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lfs_updatemeta
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|BUMP_FIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|lfs_writeinode
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|lfs_vunref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
comment|/* Start a new file */
name|CHECK_SEG
argument_list|(
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|INC_FINFO
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|start_lbp
operator|=
operator|&
name|sp
operator|->
name|fip
operator|->
name|fi_blocks
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|vp
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|fip
operator|->
name|fi_version
operator|=
name|blkp
operator|->
name|bi_version
expr_stmt|;
name|sp
operator|->
name|fip
operator|->
name|fi_nblocks
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|fip
operator|->
name|fi_ino
operator|=
name|blkp
operator|->
name|bi_inode
expr_stmt|;
name|lastino
operator|=
name|blkp
operator|->
name|bi_inode
expr_stmt|;
if|if
condition|(
name|blkp
operator|->
name|bi_inode
operator|==
name|LFS_IFILE_INUM
condition|)
name|v_daddr
operator|=
name|fs
operator|->
name|lfs_idaddr
expr_stmt|;
else|else
block|{
name|LFS_IENTRY
argument_list|(
name|ifp
argument_list|,
name|fs
argument_list|,
name|blkp
operator|->
name|bi_inode
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|v_daddr
operator|=
name|ifp
operator|->
name|if_daddr
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v_daddr
operator|==
name|LFS_UNUSED_DADDR
condition|)
continue|continue;
comment|/* Get the vnode/inode. */
if|if
condition|(
name|lfs_fastvget
argument_list|(
name|mntp
argument_list|,
name|blkp
operator|->
name|bi_inode
argument_list|,
name|v_daddr
argument_list|,
operator|&
name|vp
argument_list|,
name|blkp
operator|->
name|bi_lbn
operator|==
name|LFS_UNUSED_LBN
condition|?
name|blkp
operator|->
name|bi_bp
else|:
name|NULL
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"lfs_markv: VFS_VGET failed (%d)\n"
argument_list|,
name|blkp
operator|->
name|bi_inode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lastino
operator|=
name|LFS_UNUSED_INUM
expr_stmt|;
name|v_daddr
operator|=
name|LFS_UNUSED_DADDR
expr_stmt|;
continue|continue;
block|}
name|sp
operator|->
name|vp
operator|=
name|vp
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v_daddr
operator|==
name|LFS_UNUSED_DADDR
condition|)
continue|continue;
comment|/* If this BLOCK_INFO didn't contain a block, keep going. */
if|if
condition|(
name|blkp
operator|->
name|bi_lbn
operator|==
name|LFS_UNUSED_LBN
condition|)
continue|continue;
if|if
condition|(
name|VOP_BMAP
argument_list|(
name|vp
argument_list|,
name|blkp
operator|->
name|bi_lbn
argument_list|,
name|NULL
argument_list|,
operator|&
name|b_daddr
argument_list|,
name|NULL
argument_list|)
operator|||
name|b_daddr
operator|!=
name|blkp
operator|->
name|bi_daddr
condition|)
continue|continue;
comment|/* 		 * If we got to here, then we are keeping the block.  If it 		 * is an indirect block, we want to actually put it in the 		 * buffer cache so that it can be updated in the finish_meta 		 * section.  If it's not, we need to allocate a fake buffer 		 * so that writeseg can perform the copyin and write the buffer. 		 */
if|if
condition|(
name|blkp
operator|->
name|bi_lbn
operator|>=
literal|0
condition|)
comment|/* Data Block */
name|bp
operator|=
name|lfs_fakebuf
argument_list|(
name|vp
argument_list|,
name|blkp
operator|->
name|bi_lbn
argument_list|,
name|bsize
argument_list|,
name|blkp
operator|->
name|bi_bp
argument_list|)
expr_stmt|;
else|else
block|{
name|bp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
name|blkp
operator|->
name|bi_lbn
argument_list|,
name|bsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DELWRI
operator||
name|B_DONE
operator||
name|B_CACHE
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|blkp
operator|->
name|bi_bp
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|bsize
argument_list|)
operator|)
condition|)
goto|goto
name|err2
goto|;
if|if
condition|(
name|error
operator|=
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
condition|)
goto|goto
name|err2
goto|;
block|}
while|while
condition|(
name|lfs_gatherblock
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|)
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|vp
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|fip
operator|->
name|fi_nblocks
operator|==
literal|0
condition|)
block|{
name|DEC_FINFO
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|+=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
block|}
else|else
name|lfs_updatemeta
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|lfs_writeinode
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|lfs_vunref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|lfs_segunlock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|start
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
comment|/*  * XXX  * If we come in to error 2, we might have indirect blocks that were  * updated and now have bad block pointers.  I don't know what to do  * about this.  */
name|err2
label|:
name|lfs_vunref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* Free up fakebuffers */
for|for
control|(
name|bpp
operator|=
operator|--
name|sp
operator|->
name|cbpp
init|;
name|bpp
operator|>=
name|sp
operator|->
name|bpp
condition|;
operator|--
name|bpp
control|)
if|if
condition|(
operator|(
operator|*
name|bpp
operator|)
operator|->
name|b_flags
operator|&
name|B_CALL
condition|)
block|{
name|brelvp
argument_list|(
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|bpp
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
block|}
else|else
name|brelse
argument_list|(
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|lfs_segunlock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|err1
label|:
name|free
argument_list|(
name|start
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lfs_bmapv:  *  * This will fill in the current disk address for arrays of blocks.  *  *  0 on success  * -1/errno is return on error.  */
end_comment

begin_struct
struct|struct
name|lfs_bmapv_args
block|{
name|fsid_t
modifier|*
name|fsidp
decl_stmt|;
comment|/* file system */
name|BLOCK_INFO
modifier|*
name|blkiov
decl_stmt|;
comment|/* block array */
name|int
name|blkcnt
decl_stmt|;
comment|/* count of block array entries */
block|}
struct|;
end_struct

begin_function
name|int
name|lfs_bmapv
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|lfs_bmapv_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
name|BLOCK_INFO
modifier|*
name|blkp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mntp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|fsid_t
name|fsid
decl_stmt|;
name|void
modifier|*
name|start
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|error
decl_stmt|,
name|step
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|fsidp
argument_list|,
operator|&
name|fsid
argument_list|,
sizeof|sizeof
argument_list|(
name|fsid_t
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|mntp
operator|=
name|getvfs
argument_list|(
operator|&
name|fsid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cnt
operator|=
name|uap
operator|->
name|blkcnt
expr_stmt|;
name|start
operator|=
name|blkp
operator|=
name|malloc
argument_list|(
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|blkiov
argument_list|,
name|blkp
argument_list|,
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|blkp
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|step
operator|=
name|cnt
init|;
name|step
operator|--
condition|;
operator|++
name|blkp
control|)
block|{
if|if
condition|(
name|blkp
operator|->
name|bi_lbn
operator|==
name|LFS_UNUSED_LBN
condition|)
continue|continue;
comment|/* Could be a deadlock ? */
if|if
condition|(
name|VFS_VGET
argument_list|(
name|mntp
argument_list|,
name|blkp
operator|->
name|bi_inode
argument_list|,
operator|&
name|vp
argument_list|)
condition|)
name|daddr
operator|=
name|LFS_UNUSED_DADDR
expr_stmt|;
else|else
block|{
if|if
condition|(
name|VOP_BMAP
argument_list|(
name|vp
argument_list|,
name|blkp
operator|->
name|bi_lbn
argument_list|,
name|NULL
argument_list|,
operator|&
name|daddr
argument_list|,
name|NULL
argument_list|)
condition|)
name|daddr
operator|=
name|LFS_UNUSED_DADDR
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|blkp
operator|->
name|bi_daddr
operator|=
name|daddr
expr_stmt|;
block|}
name|copyout
argument_list|(
name|start
argument_list|,
name|uap
operator|->
name|blkiov
argument_list|,
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|start
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lfs_segclean:  *  * Mark the segment clean.  *  *  0 on success  * -1/errno is return on error.  */
end_comment

begin_struct
struct|struct
name|lfs_segclean_args
block|{
name|fsid_t
modifier|*
name|fsidp
decl_stmt|;
comment|/* file system */
name|u_long
name|segment
decl_stmt|;
comment|/* segment number */
block|}
struct|;
end_struct

begin_function
name|int
name|lfs_segclean
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|lfs_segclean_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
name|CLEANERINFO
modifier|*
name|cip
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mntp
decl_stmt|;
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|fsid_t
name|fsid
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|fsidp
argument_list|,
operator|&
name|fsid
argument_list|,
sizeof|sizeof
argument_list|(
name|fsid_t
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|mntp
operator|=
name|getvfs
argument_list|(
operator|&
name|fsid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|mntp
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
if|if
condition|(
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_curseg
argument_list|)
operator|==
name|uap
operator|->
name|segment
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|uap
operator|->
name|segment
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sup
operator|->
name|su_flags
operator|&
name|SEGUSE_ACTIVE
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|fs
operator|->
name|lfs_avail
operator|+=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_ssize
argument_list|)
operator|-
literal|1
expr_stmt|;
name|fs
operator|->
name|lfs_bfree
operator|+=
operator|(
name|sup
operator|->
name|su_nsums
operator|*
name|LFS_SUMMARY_SIZE
operator|/
name|DEV_BSIZE
operator|)
operator|+
name|sup
operator|->
name|su_ninos
operator|*
name|btodb
argument_list|(
name|fs
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|sup
operator|->
name|su_flags
operator|&=
operator|~
name|SEGUSE_DIRTY
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LFS_CLEANERINFO
argument_list|(
name|cip
argument_list|,
name|fs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|++
name|cip
operator|->
name|clean
expr_stmt|;
operator|--
name|cip
operator|->
name|dirty
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|fs
operator|->
name|lfs_avail
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lfs_segwait:  *  * This will block until a segment in file system fsid is written.  A timeout  * in milliseconds may be specified which will awake the cleaner automatically.  * An fsid of -1 means any file system, and a timeout of 0 means forever.  *  *  0 on success  *  1 on timeout  * -1/errno is return on error.  */
end_comment

begin_struct
struct|struct
name|lfs_segwait_args
block|{
name|fsid_t
modifier|*
name|fsidp
decl_stmt|;
comment|/* file system */
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
comment|/* timeout */
block|}
struct|;
end_struct

begin_function
name|int
name|lfs_segwait
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|lfs_segwait_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
specifier|extern
name|int
name|lfs_allclean_wakeup
decl_stmt|;
name|struct
name|mount
modifier|*
name|mntp
decl_stmt|;
name|struct
name|timeval
name|atv
decl_stmt|;
name|fsid_t
name|fsid
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|u_long
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|WHEN_QUADS_WORK
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|fsidp
argument_list|,
operator|&
name|fsid
argument_list|,
sizeof|sizeof
argument_list|(
name|fsid_t
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|fsid
operator|==
operator|(
name|fsid_t
operator|)
operator|-
literal|1
condition|)
name|addr
operator|=
operator|&
name|lfs_allclean_wakeup
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|mntp
operator|=
name|getvfs
argument_list|(
operator|&
name|fsid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|addr
operator|=
operator|&
name|VFSTOUFS
argument_list|(
name|mntp
argument_list|)
operator|->
name|um_lfs
operator|->
name|lfs_nextseg
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|fsidp
argument_list|,
operator|&
name|fsid
argument_list|,
sizeof|sizeof
argument_list|(
name|fsid_t
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|mntp
operator|=
name|getvfs
argument_list|(
operator|&
name|fsid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|addr
operator|=
operator|&
name|lfs_allclean_wakeup
expr_stmt|;
else|else
name|addr
operator|=
operator|&
name|VFSTOUFS
argument_list|(
name|mntp
argument_list|)
operator|->
name|um_lfs
operator|->
name|lfs_nextseg
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|uap
operator|->
name|tv
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|tv
argument_list|,
operator|&
name|atv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|atv
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
operator|&
name|time
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|hzto
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|timeout
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|addr
argument_list|,
name|PCATCH
operator||
name|PUSER
argument_list|,
literal|"segment"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
name|ERESTART
condition|?
name|EINTR
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * VFS_VGET call specialized for the cleaner.  The cleaner already knows the  * daddr from the ifile, so don't look it up again.  If the cleaner is  * processing IINFO structures, it may have the ondisk inode already, so  * don't go retrieving it again.  */
end_comment

begin_function
name|int
name|lfs_fastvget
parameter_list|(
name|mp
parameter_list|,
name|ino
parameter_list|,
name|daddr
parameter_list|,
name|vpp
parameter_list|,
name|dinp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|dinode
modifier|*
name|dinp
decl_stmt|;
block|{
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|dev
operator|=
name|ump
operator|->
name|um_dev
expr_stmt|;
comment|/* 	 * This is playing fast and loose.  Someone may have the inode 	 * locked, in which case they are going to be distinctly unhappy 	 * if we trash something. 	 */
if|if
condition|(
operator|(
operator|*
name|vpp
operator|=
name|ufs_ihashlookup
argument_list|(
name|dev
argument_list|,
name|ino
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|lfs_vref
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_flag
operator|&
name|VXLOCK
condition|)
name|printf
argument_list|(
literal|"Cleaned vnode VXLOCKED\n"
argument_list|)
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_flag
operator|&
name|IN_LOCKED
condition|)
name|printf
argument_list|(
literal|"cleaned vnode locked\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ip
operator|->
name|i_flag
operator|&
name|IN_MODIFIED
operator|)
condition|)
block|{
operator|++
name|ump
operator|->
name|um_lfs
operator|->
name|lfs_uinodes
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_MODIFIED
expr_stmt|;
block|}
name|ip
operator|->
name|i_flag
operator||=
name|IN_MODIFIED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Allocate new vnode/inode. */
if|if
condition|(
name|error
operator|=
name|lfs_vcreate
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
operator|&
name|vp
argument_list|)
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Put it onto its hash chain and lock it so that other requests for 	 * this inode will block if they arrive while we are sleeping waiting 	 * for old data structures to be purged or for the contents of the 	 * disk portion of this inode to be read. 	 */
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ufs_ihashins
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * This may not need to be here, logically it should go down with 	 * the i_devvp initialization. 	 * Ask Kirk. 	 */
name|ip
operator|->
name|i_lfs
operator|=
name|ump
operator|->
name|um_lfs
expr_stmt|;
comment|/* Read in the disk contents for the inode, copy into the inode. */
if|if
condition|(
name|dinp
condition|)
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|dinp
argument_list|,
operator|&
name|ip
operator|->
name|i_din
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
else|else
block|{
if|if
condition|(
name|error
operator|=
name|bread
argument_list|(
name|ump
operator|->
name|um_devvp
argument_list|,
name|daddr
argument_list|,
operator|(
name|int
operator|)
name|ump
operator|->
name|um_lfs
operator|->
name|lfs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
condition|)
block|{
comment|/* 			 * The inode does not contain anything useful, so it 			 * would be misleading to leave it on its hash chain. 			 * Iput() will return it to the free list. 			 */
name|ufs_ihashrem
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* Unlock and discard unneeded inode. */
name|lfs_vunref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ip
operator|->
name|i_din
operator|=
operator|*
name|lfs_ifind
argument_list|(
name|ump
operator|->
name|um_lfs
argument_list|,
name|ino
argument_list|,
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* Inode was just read from user space or disk, make sure it's locked */
name|ip
operator|->
name|i_flag
operator||=
name|IN_LOCKED
expr_stmt|;
comment|/* 	 * Initialize the vnode from the inode, check for aliases.  In all 	 * cases re-init ip, the underlying vnode/inode may have changed. 	 */
if|if
condition|(
name|error
operator|=
name|ufs_vinit
argument_list|(
name|mp
argument_list|,
name|lfs_specop_p
argument_list|,
name|LFS_FIFOOPS
argument_list|,
operator|&
name|vp
argument_list|)
condition|)
block|{
name|lfs_vunref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Finish inode initialization now that aliasing has been resolved. 	 */
name|ip
operator|->
name|i_devvp
operator|=
name|ump
operator|->
name|um_devvp
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_MODIFIED
expr_stmt|;
operator|++
name|ump
operator|->
name|um_lfs
operator|->
name|lfs_uinodes
expr_stmt|;
name|VREF
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|buf
modifier|*
name|lfs_fakebuf
parameter_list|(
name|vp
parameter_list|,
name|lbn
parameter_list|,
name|size
parameter_list|,
name|uaddr
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|lbn
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|caddr_t
name|uaddr
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|lfs_newbuf
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_saveaddr
operator|=
name|uaddr
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|size
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|size
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

end_unit

