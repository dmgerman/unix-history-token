begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)lfs_syscalls.c	7.9 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs_extern.h>
end_include

begin_comment
comment|/*  * lfs_markv:  *  * This will mark inodes and blocks dirty, so they are written into the log.  * It will block until all the blocks have been written.  The segment create  * time passed in the block_info and inode_info structures is used to decide  * if the data is valid for each block (in case some process dirtied a block  * or inode that is being cleaned between the determination that a block is  * live and the lfs_markv call).  *  *  0 on success  * -1/errno is return on error.  */
end_comment

begin_decl_stmt
name|int
name|lfs_markv
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
decl|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|fsid_t
name|fsid
decl_stmt|;
comment|/* file system */
name|BLOCK_INFO
modifier|*
name|blkiov
decl_stmt|;
comment|/* block array */
name|int
name|blkcnt
decl_stmt|;
comment|/* count of block array entries */
name|INODE_INFO
modifier|*
name|inoiov
decl_stmt|;
comment|/* inode array */
name|int
name|inocnt
decl_stmt|;
comment|/* count of inode array entries */
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BLOCK_INFO
modifier|*
name|blkp
decl_stmt|;
name|IFILE
modifier|*
name|ifp
decl_stmt|;
name|INODE_INFO
modifier|*
name|inop
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|mount
modifier|*
name|mntp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|void
modifier|*
name|start
decl_stmt|;
name|ino_t
name|lastino
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
name|u_long
name|bsize
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_markv\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|mntp
operator|=
name|getvfs
argument_list|(
operator|&
name|uap
operator|->
name|fsid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cnt
operator|=
name|uap
operator|->
name|blkcnt
expr_stmt|;
name|start
operator|=
name|malloc
argument_list|(
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|blkiov
argument_list|,
name|start
argument_list|,
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|start
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Mark blocks/inodes dirty.  Note that errors are mostly ignored.  If 	 * we can't get the info, the block is probably not all that useful, 	 * and hopefully subsequent calls from the cleaner will fix everything. 	 */
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|mntp
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
name|bsize
operator|=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
for|for
control|(
name|lastino
operator|=
name|LFS_UNUSED_INUM
operator|,
name|blkp
operator|=
name|start
init|;
name|cnt
operator|--
condition|;
operator|++
name|blkp
control|)
block|{
comment|/* 		 * Get the IFILE entry (only once) and see if the file still 		 * exists. 		 */
if|if
condition|(
name|lastino
operator|!=
name|blkp
operator|->
name|bi_inode
condition|)
block|{
name|lastino
operator|=
name|blkp
operator|->
name|bi_inode
expr_stmt|;
name|LFS_IENTRY
argument_list|(
name|ifp
argument_list|,
name|fs
argument_list|,
name|blkp
operator|->
name|bi_inode
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|daddr
operator|=
name|ifp
operator|->
name|if_daddr
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|daddr
operator|==
name|LFS_UNUSED_DADDR
condition|)
continue|continue;
block|}
comment|/* 		 * Get the vnode/inode.  If the inode modification time is 		 * earlier than the segment in which the block was found then 		 * they have to be valid, skip other checks. 		 */
if|if
condition|(
name|lfs_vget
argument_list|(
name|mntp
argument_list|,
name|blkp
operator|->
name|bi_inode
argument_list|,
operator|&
name|vp
argument_list|)
condition|)
continue|continue;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 		 * If modify time later than segment create time, see if the 		 * block has been replaced. 		 */
if|if
condition|(
name|ip
operator|->
name|i_mtime
operator|>
name|blkp
operator|->
name|bi_segcreate
operator|&&
operator|(
name|lfs_bmap
argument_list|(
name|vp
argument_list|,
name|blkp
operator|->
name|bi_lbn
argument_list|,
name|NULL
argument_list|,
operator|&
name|daddr
argument_list|)
operator|||
name|daddr
operator|!=
name|blkp
operator|->
name|bi_daddr
operator|)
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the block (from core or the cleaner) and write it. */
name|bp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
name|blkp
operator|->
name|bi_lbn
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|&&
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|blkp
operator|->
name|bi_bp
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bsize
argument_list|)
operator|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|start
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|lfs_bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|start
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|uap
operator|->
name|inocnt
expr_stmt|;
name|start
operator|=
name|malloc
argument_list|(
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|INODE_INFO
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|inoiov
argument_list|,
name|start
argument_list|,
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|INODE_INFO
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|start
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|inop
operator|=
name|start
init|;
name|cnt
operator|--
condition|;
operator|++
name|inop
control|)
block|{
name|LFS_IENTRY
argument_list|(
name|ifp
argument_list|,
name|fs
argument_list|,
name|inop
operator|->
name|ii_inode
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|daddr
operator|=
name|ifp
operator|->
name|if_daddr
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|daddr
operator|!=
name|inop
operator|->
name|ii_daddr
condition|)
continue|continue;
comment|/* 		 * XXX 		 * This is grossly inefficient since the cleaner just handed 		 * us a copy of the inode and we're going to have to seek 		 * to get our own.  The fix requires creating a version of 		 * lfs_vget that takes the copy and uses it instead of reading 		 * from disk, if it's not already in the cache. 		 */
if|if
condition|(
operator|!
name|lfs_vget
argument_list|(
name|mntp
argument_list|,
name|inop
operator|->
name|ii_inode
argument_list|,
operator|&
name|vp
argument_list|)
condition|)
block|{
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_flag
operator||=
name|IMOD
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|start
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|lfs_segwrite
argument_list|(
name|mntp
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * lfs_bmapv:  *  * This will fill in the current disk address for arrays of blocks.  *  *  0 on success  * -1/errno is return on error.  */
end_comment

begin_decl_stmt
name|int
name|lfs_bmapv
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
decl|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|fsid_t
name|fsid
decl_stmt|;
comment|/* file system */
name|BLOCK_INFO
modifier|*
name|blkiov
decl_stmt|;
comment|/* block array */
name|int
name|blkcnt
decl_stmt|;
comment|/* count of block array entries */
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BLOCK_INFO
modifier|*
name|blkp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mntp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|void
modifier|*
name|start
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|error
decl_stmt|,
name|step
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_bmapv\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|mntp
operator|=
name|getvfs
argument_list|(
operator|&
name|uap
operator|->
name|fsid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cnt
operator|=
name|uap
operator|->
name|blkcnt
expr_stmt|;
name|start
operator|=
name|blkp
operator|=
name|malloc
argument_list|(
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|blkiov
argument_list|,
name|blkp
argument_list|,
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|blkp
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|step
operator|=
name|cnt
init|;
name|step
operator|--
condition|;
operator|++
name|blkp
control|)
block|{
if|if
condition|(
name|lfs_vget
argument_list|(
name|mntp
argument_list|,
name|blkp
operator|->
name|bi_inode
argument_list|,
operator|&
name|vp
argument_list|)
condition|)
name|daddr
operator|=
name|LFS_UNUSED_DADDR
expr_stmt|;
else|else
block|{
if|if
condition|(
name|lfs_bmap
argument_list|(
name|vp
argument_list|,
name|blkp
operator|->
name|bi_lbn
argument_list|,
name|NULL
argument_list|,
operator|&
name|daddr
argument_list|)
condition|)
name|daddr
operator|=
name|LFS_UNUSED_DADDR
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|blkp
operator|->
name|bi_daddr
operator|=
name|daddr
expr_stmt|;
block|}
name|copyout
argument_list|(
name|start
argument_list|,
name|uap
operator|->
name|blkiov
argument_list|,
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|start
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * lfs_segclean:  *  * Mark the segment clean.  *  *  0 on success  * -1/errno is return on error.  */
end_comment

begin_decl_stmt
name|int
name|lfs_segclean
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
decl|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|fsid_t
name|fsid
decl_stmt|;
comment|/* file system */
name|u_long
name|segment
decl_stmt|;
comment|/* segment number */
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CLEANERINFO
modifier|*
name|cip
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mntp
decl_stmt|;
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_segclean\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|mntp
operator|=
name|getvfs
argument_list|(
operator|&
name|uap
operator|->
name|fsid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|mntp
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|uap
operator|->
name|segment
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sup
operator|->
name|su_flags
operator|&=
operator|~
name|SEGUSE_DIRTY
expr_stmt|;
name|sup
operator|->
name|su_nbytes
operator|=
literal|0
expr_stmt|;
name|LFS_UBWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LFS_CLEANERINFO
argument_list|(
name|cip
argument_list|,
name|fs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|++
name|cip
operator|->
name|clean
expr_stmt|;
operator|--
name|cip
operator|->
name|dirty
expr_stmt|;
name|LFS_UBWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * lfs_segwait:  *  * This will block until a segment in file system fsid is written.  A timeout  * in milliseconds may be specified which will awake the cleaner automatically.  * An fsid of -1 means any file system, and a timeout of 0 means forever.  *  *  0 on success  *  1 on timeout  * -1/errno is return on error.  */
end_comment

begin_decl_stmt
name|int
name|lfs_segwait
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
decl|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|fsid_t
name|fsid
decl_stmt|;
comment|/* file system */
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
comment|/* timeout */
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|lfs_allclean_wakeup
decl_stmt|;
name|struct
name|mount
modifier|*
name|mntp
decl_stmt|;
name|struct
name|timeval
name|atv
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|u_long
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_segwait\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|WHEN_QUADS_WORK
if|if
condition|(
name|uap
operator|->
name|fsid
operator|==
operator|(
name|fsid_t
operator|)
operator|-
literal|1
condition|)
name|addr
operator|=
operator|&
name|lfs_allclean_wakeup
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|mntp
operator|=
name|getvfs
argument_list|(
operator|&
name|uap
operator|->
name|fsid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|addr
operator|=
operator|&
name|VFSTOUFS
argument_list|(
name|mntp
argument_list|)
operator|->
name|um_lfs
operator|->
name|lfs_nextseg
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|mntp
operator|=
name|getvfs
argument_list|(
operator|&
name|uap
operator|->
name|fsid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|addr
operator|=
operator|&
name|lfs_allclean_wakeup
expr_stmt|;
else|else
name|addr
operator|=
operator|&
name|VFSTOUFS
argument_list|(
name|mntp
argument_list|)
operator|->
name|um_lfs
operator|->
name|lfs_nextseg
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|uap
operator|->
name|tv
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|tv
argument_list|,
operator|&
name|atv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|atv
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|hzto
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
block|}
else|else
name|timeout
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|addr
argument_list|,
name|PCATCH
operator||
name|PUSER
argument_list|,
literal|"segment"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
name|ERESTART
condition|?
name|EINTR
else|:
literal|0
operator|)
return|;
block|}
end_block

end_unit

