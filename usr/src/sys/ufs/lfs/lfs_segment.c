begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)lfs_segment.c	7.9 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/specdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/fifo.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs_extern.h>
end_include

begin_comment
comment|/* In-memory description of a segment about to be written. */
end_comment

begin_struct
struct|struct
name|segment
block|{
name|struct
name|buf
modifier|*
modifier|*
name|bpp
decl_stmt|;
comment|/* pointer to buffer array */
name|struct
name|buf
modifier|*
modifier|*
name|cbpp
decl_stmt|;
comment|/* pointer to next available bp */
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|;
comment|/* buffer pointer to inode page */
name|struct
name|finfo
modifier|*
name|fip
decl_stmt|;
comment|/* current fileinfo pointer */
name|void
modifier|*
name|segsum
decl_stmt|;
comment|/* segment summary info */
name|u_long
name|ninodes
decl_stmt|;
comment|/* number of inodes in this segment */
name|u_long
name|seg_bytes_left
decl_stmt|;
comment|/* bytes left in segment */
name|u_long
name|sum_bytes_left
decl_stmt|;
comment|/* bytes left in summary block */
name|u_long
name|seg_number
decl_stmt|;
comment|/* number of this segment */
define|#
directive|define
name|SEGM_CKP
value|0x01
comment|/* doing a checkpoint */
name|u_long
name|seg_flags
decl_stmt|;
comment|/* run-time flags for this segment */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Determine if it's OK to start a partial in this segment, or if we need  * to go on to a new segment.  */
end_comment

begin_define
define|#
directive|define
name|LFS_PARTIAL_FITS
parameter_list|(
name|fs
parameter_list|)
define|\
value|((fs)->lfs_dbpseg - ((fs)->lfs_offset - (fs)->lfs_curseg)> \ 	1<< (fs)->lfs_fsbtodb)
end_define

begin_decl_stmt
name|int
name|lfs_callback
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lfs_gather
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|segment
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|,
name|int
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lfs_initseg
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|segment
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lfs_iset
name|__P
argument_list|(
operator|(
expr|struct
name|inode
operator|*
operator|,
name|daddr_t
operator|,
name|time_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lfs_match_data
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lfs_match_dindir
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lfs_match_indir
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lfs_match_tindir
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|lfs_newbuf
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|segment
operator|*
operator|,
name|daddr_t
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lfs_newseg
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lfs_shellsort
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|*
operator|,
name|daddr_t
operator|*
operator|,
specifier|register
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lfs_updatemeta
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|segment
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|,
name|daddr_t
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lfs_writefile
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|segment
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lfs_writeinode
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|segment
operator|*
operator|,
expr|struct
name|inode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lfs_writeseg
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|segment
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lfs_writesuper
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|segment
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lfs_allclean_wakeup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cleaner wakeup address. */
end_comment

begin_function
name|int
name|lfs_segwrite
parameter_list|(
name|mp
parameter_list|,
name|do_ckp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|do_ckp
decl_stmt|;
comment|/* Do a checkpoint. */
block|{
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Ifile and meta data blocks are not marked busy, so segment writes 	 * must be single threaded.  Currently, there are two paths into this 	 * code, sync() and getnewbuf().  They both mark the file system busy, 	 * so lfs_segwrite is safe.  I think. 	 */
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_segwrite\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If doing a checkpoint, we keep a cumulative count of the outstanding 	 * I/O operations.  If the disk drive catches up with us it could go to 	 * zero before we finish, so we artificially increment it by one until 	 * we've scheduled all of the writes we intend to do. 	 */
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
if|if
condition|(
name|do_ckp
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|fs
operator|->
name|lfs_iocount
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate a segment structure and enough space to hold pointers to 	 * the maximum possible number of buffers which can be described in a 	 * single summary block. 	 */
name|sp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|segment
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|bpp
operator|=
name|malloc
argument_list|(
operator|(
operator|(
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|buf
operator|*
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_flags
operator|=
name|do_ckp
condition|?
name|SEGM_CKP
else|:
literal|0
expr_stmt|;
name|lfs_initseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|loop
label|:
for|for
control|(
name|vp
operator|=
name|mp
operator|->
name|mnt_mounth
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|v_mountf
control|)
block|{
comment|/* 		 * If the vnode that we are about to sync is no longer 		 * associated with this mount point, start over. 		 */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
goto|goto
name|loop
goto|;
if|if
condition|(
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Write the inode/file if dirty and it's not the 		 * the IFILE. 		 */
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_flag
operator|&
operator|(
name|IMOD
operator||
name|IACC
operator||
name|IUPD
operator||
name|ICHG
operator|)
operator|==
literal|0
operator|&&
name|vp
operator|->
name|v_dirtyblkhd
operator|==
name|NULL
operator|||
name|ip
operator|->
name|i_number
operator|==
name|LFS_IFILE_INUM
condition|)
continue|continue;
comment|/* 		 * XXX 		 * This is wrong, I think -- we should just wait until we 		 * get the vnode and go on.  Probably going to reschedule 		 * all of the writes we already scheduled... 		 */
if|if
condition|(
name|vget
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"lfs_segment: failed to get vnode (tell Keith)!\n"
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_dirtyblkhd
operator|!=
name|NULL
condition|)
name|lfs_writefile
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|lfs_writeinode
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flags
operator|&=
operator|~
operator|(
name|IMOD
operator||
name|IACC
operator||
name|IUPD
operator||
name|ICHG
operator|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_ckp
condition|)
block|{
name|vp
operator|=
name|fs
operator|->
name|lfs_ivnode
expr_stmt|;
while|while
condition|(
name|vget
argument_list|(
name|vp
argument_list|)
condition|)
empty_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_dirtyblkhd
operator|!=
name|NULL
condition|)
name|lfs_writefile
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|lfs_writeinode
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flags
operator|&=
operator|~
operator|(
name|IMOD
operator||
name|IACC
operator||
name|IUPD
operator||
name|ICHG
operator|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * If the I/O count is non-zero, sleep until it reaches zero.  At the 	 * moment, the user's process hangs around so we can sleep. 	 */
if|if
condition|(
name|do_ckp
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|--
name|fs
operator|->
name|lfs_iocount
operator|&&
operator|(
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|fs
operator|->
name|lfs_iocount
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|,
literal|"lfs sync"
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lfs_writesuper
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sp
operator|->
name|bpp
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
comment|/* Wake up any cleaning processes waiting on this file system. */
name|wakeup
argument_list|(
operator|&
name|fs
operator|->
name|lfs_nextseg
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|lfs_allclean_wakeup
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write the dirty blocks associated with a vnode.  */
end_comment

begin_function
name|void
name|lfs_writefile
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|vp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|finfo
modifier|*
name|fip
decl_stmt|;
name|IFILE
modifier|*
name|ifp
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_writefile\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
operator|||
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|finfo
argument_list|)
condition|)
block|{
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|lfs_initseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|finfo
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|fip
operator|->
name|fi_nblocks
operator|=
literal|0
expr_stmt|;
name|fip
operator|->
name|fi_ino
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_number
expr_stmt|;
name|LFS_IENTRY
argument_list|(
name|ifp
argument_list|,
name|fs
argument_list|,
name|fip
operator|->
name|fi_ino
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|fip
operator|->
name|fi_version
operator|=
name|ifp
operator|->
name|if_version
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * It may not be necessary to write the meta-data blocks at this point, 	 * as the roll-forward recovery code should be able to reconstruct the 	 * list. 	 */
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|lfs_match_data
argument_list|)
expr_stmt|;
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|lfs_match_indir
argument_list|)
expr_stmt|;
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|lfs_match_dindir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRIPLE
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|lfs_match_tindir
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
ifdef|#
directive|ifdef
name|META
name|printf
argument_list|(
literal|"lfs_writefile: adding %d blocks\n"
argument_list|,
name|fip
operator|->
name|fi_nblocks
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fip
operator|->
name|fi_nblocks
operator|!=
literal|0
condition|)
block|{
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
expr_stmt|;
name|sp
operator|->
name|fip
operator|=
operator|(
expr|struct
name|finfo
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|fip
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|finfo
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|*
operator|(
name|fip
operator|->
name|fi_nblocks
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lfs_writeinode
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ibp
decl_stmt|;
name|IFILE
modifier|*
name|ifp
decl_stmt|;
name|daddr_t
name|next_addr
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|int
name|ndx
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_writeinode\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate a new inode block if necessary. */
if|if
condition|(
name|sp
operator|->
name|ibp
operator|==
name|NULL
condition|)
block|{
comment|/* Allocate a new segment if necessary. */
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
operator|||
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
condition|)
block|{
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|lfs_initseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* Get next inode block. */
name|next_addr
operator|=
name|fs
operator|->
name|lfs_offset
expr_stmt|;
name|fs
operator|->
name|lfs_offset
operator|+=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ibp
operator|=
operator|*
name|sp
operator|->
name|cbpp
operator|++
operator|=
name|lfs_newbuf
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|next_addr
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
comment|/* Set remaining space counter. */
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|ndx
operator|=
name|LFS_SUMMARY_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|-
name|sp
operator|->
name|ninodes
operator|/
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|(
operator|(
name|daddr_t
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
index|[
name|ndx
index|]
operator|=
name|next_addr
expr_stmt|;
block|}
comment|/* Update the inode times and copy the inode onto the inode page. */
name|ITIMES
argument_list|(
name|ip
argument_list|,
operator|&
name|time
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|bp
operator|=
name|sp
operator|->
name|ibp
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_dino
index|[
name|sp
operator|->
name|ninodes
operator|%
name|INOPB
argument_list|(
name|fs
argument_list|)
index|]
operator|=
name|ip
operator|->
name|i_din
expr_stmt|;
comment|/* Increment inode count in segment summary block. */
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_ninos
expr_stmt|;
comment|/* If this page is full, set flag to allocate a new page. */
if|if
condition|(
operator|++
name|sp
operator|->
name|ninodes
operator|%
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|==
literal|0
condition|)
name|sp
operator|->
name|ibp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If updating the ifile, update the super-block.  Update the disk 	 * address and access times for this inode in the ifile. 	 */
name|ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
if|if
condition|(
name|ino
operator|==
name|LFS_IFILE_INUM
condition|)
name|fs
operator|->
name|lfs_idaddr
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|LFS_IENTRY
argument_list|(
name|ifp
argument_list|,
name|fs
argument_list|,
name|ino
argument_list|,
name|ibp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_daddr
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|LFS_UBWRITE
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|lfs_gather
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|vp
parameter_list|,
name|match
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*match
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buf
modifier|*
modifier|*
name|bpp
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
name|struct
name|finfo
modifier|*
name|fip
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|daddr_t
modifier|*
name|lbp
decl_stmt|,
modifier|*
name|start_lbp
decl_stmt|;
name|u_long
name|version
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_gather\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|sp
operator|->
name|cbpp
expr_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|start_lbp
operator|=
name|lbp
operator|=
operator|&
name|fip
operator|->
name|fi_blocks
index|[
name|fip
operator|->
name|fi_nblocks
index|]
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|vp
operator|->
name|v_dirtyblkhd
init|;
name|bp
condition|;
name|bp
operator|=
name|nbp
control|)
block|{
name|nbp
operator|=
name|bp
operator|->
name|b_blockf
expr_stmt|;
comment|/* 		 * XXX 		 * Should probably sleep on any BUSY buffer if 		 * doing an fsync? 		 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
condition|)
name|panic
argument_list|(
literal|"lfs_gather: bp not B_DELWRI"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCKED
operator|)
condition|)
name|panic
argument_list|(
literal|"lfs_gather: bp not B_LOCKED"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|match
argument_list|(
name|fs
argument_list|,
name|bp
argument_list|)
condition|)
continue|continue;
comment|/* Insert into the buffer list, update the FINFO block. */
operator|*
name|sp
operator|->
name|cbpp
operator|++
operator|=
name|bp
expr_stmt|;
operator|++
name|fip
operator|->
name|fi_nblocks
expr_stmt|;
operator|*
name|lbp
operator|++
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
comment|/* 		 * If full, finish this segment.  We may be doing I/O, so 		 * release and reacquire the splbio(). 		 */
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|||
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lfs_updatemeta
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|start_lbp
argument_list|,
name|bpp
argument_list|,
name|lbp
operator|-
name|start_lbp
argument_list|)
expr_stmt|;
comment|/* Add the current file to the segment summary. */
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
expr_stmt|;
name|version
operator|=
name|fip
operator|->
name|fi_version
expr_stmt|;
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|lfs_initseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|fip
operator|->
name|fi_version
operator|=
name|version
expr_stmt|;
name|fip
operator|->
name|fi_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|start_lbp
operator|=
name|lbp
operator|=
name|fip
operator|->
name|fi_blocks
expr_stmt|;
name|bpp
operator|=
name|sp
operator|->
name|cbpp
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lfs_updatemeta
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|start_lbp
argument_list|,
name|bpp
argument_list|,
name|lbp
operator|-
name|start_lbp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Update the metadata that points to the blocks listed in the FINFO  * array.  */
end_comment

begin_function
name|void
name|lfs_updatemeta
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|vp
parameter_list|,
name|lbp
parameter_list|,
name|bpp
parameter_list|,
name|nblocks
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|daddr_t
modifier|*
name|lbp
decl_stmt|;
name|struct
name|buf
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|int
name|nblocks
decl_stmt|;
block|{
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|INDIR
name|a
index|[
name|NIADDR
index|]
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|,
name|lbn
decl_stmt|,
name|off
decl_stmt|;
name|int
name|db_per_fsb
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|num
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_updatemeta\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nblocks
operator|==
literal|0
condition|)
return|return;
comment|/* Sort the blocks. */
name|lfs_shellsort
argument_list|(
name|bpp
argument_list|,
name|lbp
argument_list|,
name|nblocks
argument_list|)
expr_stmt|;
comment|/* 	 * Assign disk addresses, and update references to the logical 	 * block and the segment usage information. 	 */
name|db_per_fsb
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nblocks
init|;
name|i
operator|--
condition|;
operator|++
name|bpp
control|)
block|{
name|lbn
operator|=
operator|*
name|lbp
operator|++
expr_stmt|;
operator|(
operator|*
name|bpp
operator|)
operator|->
name|b_blkno
operator|=
name|off
operator|=
name|fs
operator|->
name|lfs_offset
expr_stmt|;
name|fs
operator|->
name|lfs_offset
operator|+=
name|db_per_fsb
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|lfs_bmaparray
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
operator|&
name|daddr
argument_list|,
name|a
argument_list|,
operator|&
name|num
argument_list|)
condition|)
name|panic
argument_list|(
literal|"lfs_updatemeta: lfs_bmaparray %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
case|case
literal|0
case|:
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
operator|=
name|off
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ip
operator|->
name|i_ib
index|[
name|a
index|[
literal|0
index|]
operator|.
name|in_off
index|]
operator|=
name|off
expr_stmt|;
break|break;
default|default:
name|ap
operator|=
operator|&
name|a
index|[
name|num
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|in_lbn
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"lfs_updatemeta: bread bno %d"
argument_list|,
name|ap
operator|->
name|in_lbn
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_daddr
index|[
name|ap
operator|->
name|in_off
index|]
operator|=
name|off
expr_stmt|;
name|lfs_bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* Update segment usage information. */
if|if
condition|(
name|daddr
operator|!=
name|UNASSIGNED
condition|)
block|{
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|datosn
argument_list|(
name|fs
argument_list|,
name|daddr
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sup
operator|->
name|su_lastmod
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sup
operator|->
name|su_nbytes
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
name|panic
argument_list|(
literal|"lfs: negative bytes (segment %d)\n"
argument_list|,
name|datosn
argument_list|(
name|fs
argument_list|,
name|daddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sup
operator|->
name|su_nbytes
operator|-=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
name|LFS_UBWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Start a new segment.  */
end_comment

begin_function
name|void
name|lfs_initseg
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
block|{
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|,
modifier|*
name|lbnp
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_initseg\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Advance to the next segment. */
if|if
condition|(
operator|!
name|LFS_PARTIAL_FITS
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|lfs_newseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|fs
operator|->
name|lfs_offset
operator|=
name|fs
operator|->
name|lfs_curseg
expr_stmt|;
name|sp
operator|->
name|seg_number
operator|=
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_curseg
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|=
name|fs
operator|->
name|lfs_dbpseg
operator|*
name|DEV_BSIZE
expr_stmt|;
comment|/* 		 * If the segment contains a superblock, update the offset 		 * and summary address to skip over it. 		 */
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|sp
operator|->
name|seg_number
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sup
operator|->
name|su_flags
operator|&
name|SEGUSE_SUPERBLOCK
condition|)
block|{
name|fs
operator|->
name|lfs_offset
operator|+=
name|LFS_SBPAD
operator|/
name|DEV_BSIZE
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|LFS_SBPAD
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|seg_number
operator|=
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_curseg
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|=
operator|(
name|fs
operator|->
name|lfs_dbpseg
operator|-
operator|(
name|fs
operator|->
name|lfs_offset
operator|-
name|fs
operator|->
name|lfs_curseg
operator|)
operator|)
operator|*
name|DEV_BSIZE
expr_stmt|;
block|}
name|sp
operator|->
name|ibp
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|ninodes
operator|=
literal|0
expr_stmt|;
comment|/* Get a new buffer for SEGSUM and enter it into the buffer list. */
name|sp
operator|->
name|cbpp
operator|=
name|sp
operator|->
name|bpp
expr_stmt|;
operator|*
name|sp
operator|->
name|cbpp
operator|=
name|lfs_newbuf
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|fs
operator|->
name|lfs_offset
argument_list|,
name|LFS_SUMMARY_SIZE
argument_list|)
expr_stmt|;
name|sp
operator|->
name|segsum
operator|=
operator|(
operator|*
name|sp
operator|->
name|cbpp
operator|)
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
operator|++
name|sp
operator|->
name|cbpp
expr_stmt|;
name|fs
operator|->
name|lfs_offset
operator|+=
name|LFS_SUMMARY_SIZE
operator|/
name|DEV_BSIZE
expr_stmt|;
comment|/* Set point to SEGSUM, initialize it. */
name|ssp
operator|=
name|sp
operator|->
name|segsum
expr_stmt|;
name|ssp
operator|->
name|ss_next
operator|=
name|fs
operator|->
name|lfs_nextseg
expr_stmt|;
name|ssp
operator|->
name|ss_nfinfo
operator|=
name|ssp
operator|->
name|ss_ninos
operator|=
literal|0
expr_stmt|;
comment|/* Set pointer to first FINFO, initialize it. */
name|sp
operator|->
name|fip
operator|=
operator|(
expr|struct
name|finfo
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|+
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
operator|)
expr_stmt|;
name|sp
operator|->
name|fip
operator|->
name|fi_nblocks
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|=
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the next segment to write.  */
end_comment

begin_function
name|void
name|lfs_newseg
parameter_list|(
name|fs
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
block|{
name|CLEANERINFO
modifier|*
name|cip
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|curseg
decl_stmt|,
name|isdirty
decl_stmt|,
name|sn
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_newseg\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Turn off the active bit for the current segment, turn on the 	 * active and dirty bits for the next segment, update the cleaner 	 * info.  Set the current segment to the next segment, get a new 	 * next segment. 	 */
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_curseg
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sup
operator|->
name|su_flags
operator|&=
operator|~
name|SEGUSE_ACTIVE
expr_stmt|;
name|LFS_UBWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_nextseg
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sup
operator|->
name|su_flags
operator||=
name|SEGUSE_ACTIVE
operator||
name|SEGUSE_DIRTY
expr_stmt|;
name|LFS_UBWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LFS_CLEANERINFO
argument_list|(
name|cip
argument_list|,
name|fs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|--
name|cip
operator|->
name|clean
expr_stmt|;
operator|++
name|cip
operator|->
name|dirty
expr_stmt|;
name|LFS_UBWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|lfs_lastseg
operator|=
name|fs
operator|->
name|lfs_curseg
expr_stmt|;
name|fs
operator|->
name|lfs_curseg
operator|=
name|fs
operator|->
name|lfs_nextseg
expr_stmt|;
for|for
control|(
name|sn
operator|=
name|curseg
operator|=
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_curseg
argument_list|)
init|;
condition|;
control|)
block|{
name|sn
operator|=
operator|(
name|sn
operator|+
literal|1
operator|)
operator|%
name|fs
operator|->
name|lfs_nseg
expr_stmt|;
if|if
condition|(
name|sn
operator|==
name|curseg
condition|)
name|panic
argument_list|(
literal|"lfs_nextseg: no clean segments"
argument_list|)
expr_stmt|;
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|sn
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|isdirty
operator|=
name|sup
operator|->
name|su_flags
operator|&
name|SEGUSE_DIRTY
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdirty
condition|)
break|break;
block|}
name|fs
operator|->
name|lfs_nextseg
operator|=
name|sntoda
argument_list|(
name|fs
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lfs_writeseg
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
modifier|*
name|bpp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
name|dev_t
name|i_dev
decl_stmt|;
name|u_long
modifier|*
name|datap
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|void
modifier|*
name|pmeta
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|,
name|nblocks
decl_stmt|,
name|s
decl_stmt|,
argument_list|(
operator|*
name|strategy
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_writeseg\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|nblocks
operator|=
name|sp
operator|->
name|cbpp
operator|-
name|sp
operator|->
name|bpp
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Update the segment usage information. */
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|sp
operator|->
name|seg_number
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sup
operator|->
name|su_nbytes
operator|+=
name|nblocks
operator|-
literal|1
operator|<<
name|fs
operator|->
name|lfs_bshift
expr_stmt|;
name|sup
operator|->
name|su_lastmod
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|LFS_UBWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Compute checksum across data and then across summary; the first 	 * block (the summary block) is skipped.  Set the create time here 	 * so that it's guaranteed to be later than the inode mod times. 	 * 	 * XXX 	 * Fix this to do it inline, instead of malloc/copy. 	 */
name|datap
operator|=
name|dp
operator|=
name|malloc
argument_list|(
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|bpp
operator|=
name|sp
operator|->
name|bpp
operator|,
name|i
operator|=
name|nblocks
operator|-
literal|1
init|;
name|i
operator|--
condition|;
control|)
operator|*
name|dp
operator|++
operator|=
operator|(
operator|*
operator|++
name|bpp
operator|)
operator|->
name|b_un
operator|.
name|b_words
index|[
literal|0
index|]
expr_stmt|;
name|ssp
operator|=
operator|(
name|SEGSUM
operator|*
operator|)
name|sp
operator|->
name|segsum
expr_stmt|;
name|ssp
operator|->
name|ss_create
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|ssp
operator|->
name|ss_datasum
operator|=
name|cksum
argument_list|(
name|datap
argument_list|,
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|ssp
operator|->
name|ss_sumsum
operator|=
name|cksum
argument_list|(
operator|&
name|ssp
operator|->
name|ss_datasum
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|ssp
operator|->
name|ss_sumsum
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|datap
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
comment|/* 	 * When we gathered the blocks for I/O we did not mark them busy or 	 * remove them from the freelist.  As we do this, turn off the B_LOCKED 	 * bit so the future brelse will put them on the LRU list, and add the 	 * B_CALL flags if we're doing a checkpoint so we can count I/O's.  LFS 	 * requires that the super blocks (on checkpoint) be written after all 	 * the segment data. 	 */
name|i_dev
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_dev
expr_stmt|;
name|strategy
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_devvp
operator|->
name|v_op
operator|->
name|vop_strategy
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|seg_flags
operator|&
name|SEGM_CKP
condition|)
block|{
name|fs
operator|->
name|lfs_iocount
operator|+=
name|nblocks
expr_stmt|;
name|flags
operator|=
name|B_ASYNC
operator||
name|B_BUSY
operator||
name|B_CALL
expr_stmt|;
block|}
else|else
name|flags
operator|=
name|B_ASYNC
operator||
name|B_BUSY
expr_stmt|;
for|for
control|(
name|bpp
operator|=
name|sp
operator|->
name|bpp
operator|,
name|i
operator|=
name|nblocks
init|;
name|i
operator|--
condition|;
control|)
block|{
name|bp
operator|=
operator|*
name|bpp
operator|++
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|flags
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_READ
operator||
name|B_DELWRI
operator||
name|B_LOCKED
operator|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|i_dev
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|lfs_callback
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_NOCACHE
operator|)
condition|)
block|{
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|bpp
operator|=
name|sp
operator|->
name|bpp
operator|,
name|i
operator|=
name|nblocks
init|;
name|i
operator|--
condition|;
control|)
call|(
name|strategy
call|)
argument_list|(
operator|*
name|bpp
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lfs_writesuper
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|dev_t
name|i_dev
decl_stmt|;
name|int
argument_list|(
argument|*strategy
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_writesuper\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i_dev
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_dev
expr_stmt|;
name|strategy
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_devvp
operator|->
name|v_op
operator|->
name|vop_strategy
expr_stmt|;
comment|/* Checksum the superblock and copy it into a buffer. */
name|fs
operator|->
name|lfs_cksum
operator|=
name|cksum
argument_list|(
name|fs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lfs
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|fs
operator|->
name|lfs_cksum
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|lfs_newbuf
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|fs
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
argument_list|,
name|LFS_SBPAD
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|->
name|b_un
operator|.
name|b_lfs
operator|=
operator|*
name|fs
expr_stmt|;
comment|/* Write the first superblock (wait). */
name|bp
operator|->
name|b_dev
operator|=
name|i_dev
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_READ
operator||
name|B_DELWRI
operator|)
expr_stmt|;
call|(
name|strategy
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Write the second superblock (don't wait). */
name|bp
operator|->
name|b_blkno
operator|=
name|bp
operator|->
name|b_lblkno
operator|=
name|fs
operator|->
name|lfs_sboffs
index|[
literal|1
index|]
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ASYNC
operator||
name|B_BUSY
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_READ
operator||
name|B_DELWRI
operator|)
expr_stmt|;
call|(
name|strategy
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Logical block number match routines used when traversing the dirty block  * chain.  */
end_comment

begin_function
name|int
name|lfs_match_data
parameter_list|(
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
return|return
operator|(
name|bp
operator|->
name|b_lblkno
operator|>=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lfs_match_indir
parameter_list|(
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|lbn
decl_stmt|;
name|lbn
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
return|return
operator|(
name|lbn
operator|<
literal|0
operator|&&
operator|(
operator|-
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lfs_match_dindir
parameter_list|(
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|lbn
decl_stmt|;
name|lbn
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
return|return
operator|(
name|lbn
operator|<
literal|0
operator|&&
operator|(
operator|-
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lfs_match_tindir
parameter_list|(
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|lbn
decl_stmt|;
name|lbn
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
return|return
operator|(
name|lbn
operator|<
literal|0
operator|&&
operator|(
operator|-
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|==
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new buffer header.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|lfs_newbuf
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|daddr
parameter_list|,
name|size
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|struct
name|segment
modifier|*
name|sp
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_newbuf\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|=
name|getnewbuf
argument_list|()
expr_stmt|;
name|bremhash
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bgetvp
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_lblkno
operator|=
name|daddr
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|daddr
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_NOCACHE
expr_stmt|;
name|binshash
argument_list|(
name|bp
argument_list|,
operator|&
name|bfreelist
index|[
name|BQ_AGE
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_function
name|int
comment|/* XXX should be void */
name|lfs_callback
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|fs
operator|->
name|lfs_iocount
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"lfs_callback: zero iocount\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|fs
operator|->
name|lfs_iocount
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|&
name|fs
operator|->
name|lfs_iocount
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shellsort (diminishing increment sort) from Data Structures and  * Algorithms, Aho, Hopcraft and Ullman, 1983 Edition, page 290;  * see also Knuth Vol. 3, page 84.  The increments are selected from  * formula (8), page 95.  Roughly O(N^3/2).  */
end_comment

begin_comment
comment|/*  * This is our own private copy of shellsort because we want to sort  * two parallel arrays (the array of buffer pointers and the array of  * logical block numbers) simultaneously.  Note that we cast the array  * of logical block numbers to a unsigned in this routine so that the  * negative block numbers (meta data blocks) sort AFTER the data blocks.  */
end_comment

begin_function
name|void
name|lfs_shellsort
parameter_list|(
name|bp_array
parameter_list|,
name|lb_array
parameter_list|,
name|nmemb
parameter_list|)
name|struct
name|buf
modifier|*
modifier|*
name|bp_array
decl_stmt|;
name|daddr_t
modifier|*
name|lb_array
decl_stmt|;
specifier|register
name|int
name|nmemb
decl_stmt|;
block|{
specifier|static
name|int
name|__rsshell_increments
index|[]
init|=
block|{
literal|4
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
specifier|register
name|int
name|incr
decl_stmt|,
modifier|*
name|incrp
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp_temp
decl_stmt|;
name|u_long
name|lb_temp
decl_stmt|;
for|for
control|(
name|incrp
operator|=
name|__rsshell_increments
init|;
name|incr
operator|=
operator|*
name|incrp
operator|++
condition|;
control|)
for|for
control|(
name|t1
operator|=
name|incr
init|;
name|t1
operator|<
name|nmemb
condition|;
operator|++
name|t1
control|)
for|for
control|(
name|t2
operator|=
name|t1
operator|-
name|incr
init|;
name|t2
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|lb_array
index|[
name|t2
index|]
operator|>
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
condition|)
block|{
name|lb_temp
operator|=
name|lb_array
index|[
name|t2
index|]
expr_stmt|;
name|lb_array
index|[
name|t2
index|]
operator|=
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
expr_stmt|;
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
operator|=
name|lb_temp
expr_stmt|;
name|bp_temp
operator|=
name|bp_array
index|[
name|t2
index|]
expr_stmt|;
name|bp_array
index|[
name|t2
index|]
operator|=
name|bp_array
index|[
name|t2
operator|+
name|incr
index|]
expr_stmt|;
name|bp_array
index|[
name|t2
operator|+
name|incr
index|]
operator|=
name|bp_temp
expr_stmt|;
name|t2
operator|-=
name|incr
expr_stmt|;
block|}
else|else
break|break;
block|}
end_function

end_unit

