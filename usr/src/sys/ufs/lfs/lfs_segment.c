begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)lfs_segment.c	5.4 (Berkeley) %G%  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LOGFS
end_ifdef

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"namei.h"
end_include

begin_include
include|#
directive|include
file|"resourcevar.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"specdev.h"
end_include

begin_include
include|#
directive|include
file|"fifo.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"../ufs/lockf.h"
end_include

begin_include
include|#
directive|include
file|"../ufs/quota.h"
end_include

begin_include
include|#
directive|include
file|"../ufs/inode.h"
end_include

begin_include
include|#
directive|include
file|"../ufs/dir.h"
end_include

begin_include
include|#
directive|include
file|"../ufs/ufsmount.h"
end_include

begin_include
include|#
directive|include
file|"lfs.h"
end_include

begin_include
include|#
directive|include
file|"lfs_extern.h"
end_include

begin_comment
comment|/*  * Add a check so that if the segment is empty, you don't write it.  *  * Change lfs_ialloc to allocate a new page of inodes if you have to.  *  * Need to keep vnode v_numoutput up to date for pending writes?  Could  * actually fire off the datablock writes before you finish.  This would give  * them a chance to get started earlier.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lfs_biocallback
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_endsum
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|SEGMENT
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SEGMENT
modifier|*
name|lfs_gather
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|SEGMENT
operator|*
operator|,
name|VNODE
operator|*
operator|,
name|int
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BUF
modifier|*
name|lfs_newbuf
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|daddr_t
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SEGMENT
modifier|*
name|lfs_newseg
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SEGMENT
modifier|*
name|lfs_newsum
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|SEGMENT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|daddr_t
name|lfs_nextseg
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_updatemeta
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|SEGMENT
operator|*
operator|,
name|INODE
operator|*
operator|,
name|daddr_t
operator|*
operator|,
name|BUF
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SEGMENT
modifier|*
name|lfs_writeckp
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|SEGMENT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SEGMENT
modifier|*
name|lfs_writefile
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|SEGMENT
operator|*
operator|,
name|VNODE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SEGMENT
modifier|*
name|lfs_writeinode
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|SEGMENT
operator|*
operator|,
name|INODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_writeseg
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|SEGMENT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_writesum
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_writesuper
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|match_data
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|match_dindir
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|match_indir
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|daddr_t
name|next
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|SEGMENT
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|shellsort
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|*
operator|,
name|daddr_t
operator|*
operator|,
specifier|register
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX -- when we add fragments in here, we will need to allocate a larger  * buffer pointer array (sp->bpp).  */
end_comment

begin_function
name|int
name|lfs_segwrite
parameter_list|(
name|mp
parameter_list|,
name|do_ckp
parameter_list|)
name|MOUNT
modifier|*
name|mp
decl_stmt|;
name|int
name|do_ckp
decl_stmt|;
comment|/* do a checkpoint too */
block|{
name|INODE
modifier|*
name|ip
decl_stmt|;
name|LFS
modifier|*
name|fs
decl_stmt|;
name|VNODE
modifier|*
name|vp
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|fs
operator|->
name|lfs_seglist
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"lfs_segwrite: seglist not NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * LFS requires that the summary blocks be written after the rest of 	 * the segment, and that the super blocks (on checkpoint) be written 	 * last of all.  We keep a cumulative count of the outstanding blocks 	 * from all of the segments, and write these blocks when this count 	 * goes to zero.  If the disk drive catches up with us it could go 	 * to zero before we finish, so we artificially increment it by one 	 * until we've scheduled all of the writes we intend to do.  At the 	 * moment, the user's process hangs around so we can sleep; this should 	 * probably be redone using a kernel thread. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|fs
operator|->
name|lfs_iocount
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sp
operator|=
name|lfs_newseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|loop
label|:
for|for
control|(
name|vp
operator|=
name|mp
operator|->
name|mnt_mounth
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|v_mountf
control|)
block|{
comment|/* 		 * If the vnode that we are about to sync is no longer 		 * associated with this mount point, start over. 		 */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
goto|goto
name|loop
goto|;
if|if
condition|(
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
condition|)
continue|continue;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_number
operator|==
name|LFS_IFILE_INUM
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_flag
operator|&
operator|(
name|IMOD
operator||
name|IACC
operator||
name|IUPD
operator||
name|ICHG
operator|)
operator|)
operator|==
literal|0
operator|&&
name|vp
operator|->
name|v_dirtyblkhd
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|vget
argument_list|(
name|vp
argument_list|)
condition|)
goto|goto
name|loop
goto|;
name|sp
operator|=
name|lfs_writefile
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|do_ckp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_ckp
condition|)
name|sp
operator|=
name|lfs_writeckp
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|--
name|fs
operator|->
name|lfs_iocount
condition|)
name|sleep
argument_list|(
operator|&
name|fs
operator|->
name|lfs_iocount
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lfs_writesum
argument_list|(
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_ckp
condition|)
name|lfs_writesuper
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"After writesuper returning\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
comment|/* XXX should be void */
name|lfs_biocallback
parameter_list|(
name|bp
parameter_list|)
name|BUF
modifier|*
name|bp
decl_stmt|;
block|{
name|LFS
modifier|*
name|fs
decl_stmt|;
comment|/* 	 * XXX 	 * Reset the flags (probably wrong).  If the contents of the buffer 	 * are valid, move back onto the clean list. 	 */
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_DELWRI
operator|)
expr_stmt|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_NOCACHE
condition|)
name|bp
operator|->
name|b_vp
operator|=
name|NULL
expr_stmt|;
else|else
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"callback: buffer: %x iocount %d\n"
argument_list|,
name|bp
argument_list|,
name|fs
operator|->
name|lfs_iocount
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|lfs_iocount
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"lfs_biocallback: zero iocount\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|fs
operator|->
name|lfs_iocount
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|&
name|fs
operator|->
name|lfs_iocount
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish up a summary block. */
end_comment

begin_function
specifier|static
name|void
name|lfs_endsum
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|calc_next
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|int
name|calc_next
decl_stmt|;
block|{
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
name|int
name|nsums_per_blk
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|sbp
operator|==
name|NULL
condition|)
return|return;
name|ssp
operator|=
name|sp
operator|->
name|segsum
expr_stmt|;
comment|/* 	 * Compute the address of the next summary block if calc_next is set, 	 * otherwise end the chain.  If the summary block is full, close it 	 * by setting sp->sbp to NULL, so lfs_newsum will allocate a new one. 	 * Calculate the checksum last. 	 */
name|nsums_per_blk
operator|=
name|fs
operator|->
name|lfs_bsize
operator|/
name|LFS_SUMMARY_SIZE
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|nsums
operator|%
name|nsums_per_blk
operator|==
literal|0
condition|)
block|{
name|ssp
operator|->
name|ss_nextsum
operator|=
name|calc_next
condition|?
name|next
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|NULL
argument_list|)
operator|+
operator|(
name|nsums_per_blk
operator|-
literal|1
operator|)
operator|*
name|LFS_SUMMARY_SIZE
operator|/
name|DEV_BSIZE
else|:
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|sbp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|ssp
operator|->
name|ss_nextsum
operator|=
name|calc_next
condition|?
name|sp
operator|->
name|sum_addr
operator|-
name|LFS_SUMMARY_SIZE
operator|/
name|DEV_BSIZE
else|:
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|ssp
operator|->
name|ss_cksum
operator|=
name|cksum
argument_list|(
operator|&
name|ssp
operator|->
name|ss_cksum
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|ssp
operator|->
name|ss_cksum
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|SEGMENT
modifier|*
name|lfs_gather
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|vp
parameter_list|,
name|match
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|VNODE
modifier|*
name|vp
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*match
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BUF
modifier|*
modifier|*
name|bpp
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
name|FINFO
modifier|*
name|fip
decl_stmt|;
name|INODE
modifier|*
name|ip
decl_stmt|;
name|daddr_t
modifier|*
name|lbp
decl_stmt|,
modifier|*
name|start_lbp
decl_stmt|;
name|u_long
name|version
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|sp
operator|->
name|cbpp
expr_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|start_lbp
operator|=
name|lbp
operator|=
operator|&
name|fip
operator|->
name|fi_blocks
index|[
name|fip
operator|->
name|fi_nblocks
index|]
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|vp
operator|->
name|v_dirtyblkhd
init|;
name|bp
condition|;
name|bp
operator|=
name|nbp
control|)
block|{
name|nbp
operator|=
name|bp
operator|->
name|b_blockf
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"lfs_gather: not dirty"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|match
argument_list|(
name|bp
argument_list|)
condition|)
continue|continue;
comment|/* Remove the buffer from the free lists, prepare it for I/O. */
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_CALL
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|lfs_biocallback
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_dev
expr_stmt|;
comment|/* Insert into the buffer list, update the FINFO block. */
operator|*
name|sp
operator|->
name|cbpp
operator|++
operator|=
name|bp
expr_stmt|;
operator|++
name|fip
operator|->
name|fi_nblocks
expr_stmt|;
operator|*
name|lbp
operator|++
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
comment|/* 		 * Allocate a new summary block (and, possibly, a new segment) 		 * if necessary.  In this case we sort the blocks we've done 		 * so far and assign disk addresses so we can start the new 		 * block correctly.  We may be doing I/O, so we need to release 		 * the splbio() before anything else. 		 */
if|if
condition|(
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|||
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lfs_updatemeta
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|ip
argument_list|,
name|start_lbp
argument_list|,
name|bpp
argument_list|,
name|lbp
operator|-
name|start_lbp
argument_list|)
expr_stmt|;
comment|/* Add the current file to the segment summary. */
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
expr_stmt|;
name|version
operator|=
name|fip
operator|->
name|fi_version
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
block|{
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|lfs_newseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
condition|)
name|sp
operator|=
name|lfs_newsum
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* A new FINFO either way. */
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|fip
operator|->
name|fi_version
operator|=
name|version
expr_stmt|;
name|fip
operator|->
name|fi_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|start_lbp
operator|=
name|lbp
operator|=
name|fip
operator|->
name|fi_blocks
expr_stmt|;
name|bpp
operator|=
name|sp
operator|->
name|cbpp
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lfs_updatemeta
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|ip
argument_list|,
name|start_lbp
argument_list|,
name|bpp
argument_list|,
name|lbp
operator|-
name|start_lbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Allocate a new buffer header.  */
end_comment

begin_function
specifier|static
name|BUF
modifier|*
name|lfs_newbuf
parameter_list|(
name|fs
parameter_list|,
name|daddr
parameter_list|,
name|size
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|BUF
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|getnewbuf
argument_list|()
expr_stmt|;
name|bremhash
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|fs
operator|->
name|lfs_ivnode
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|bp
operator|->
name|b_lblkno
operator|=
name|daddr
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_DELWRI
operator||
name|B_NOCACHE
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|lfs_biocallback
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_dev
expr_stmt|;
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a new segment.  */
end_comment

begin_function
specifier|static
name|SEGMENT
modifier|*
name|lfs_newseg
parameter_list|(
name|fs
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
block|{
name|FINFO
modifier|*
name|fip
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|,
modifier|*
name|lbnp
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_newseg: new segment %x\n"
argument_list|,
name|fs
operator|->
name|lfs_nextseg
argument_list|)
expr_stmt|;
name|sp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SEGMENT
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|nextp
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|cbpp
operator|=
name|sp
operator|->
name|bpp
operator|=
name|malloc
argument_list|(
name|fs
operator|->
name|lfs_ssize
operator|*
sizeof|sizeof
argument_list|(
name|BUF
operator|*
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ibp
operator|=
name|sp
operator|->
name|sbp
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|=
operator|(
name|fs
operator|->
name|lfs_segmask
operator|+
literal|1
operator|)
expr_stmt|;
name|sp
operator|->
name|saddr
operator|=
name|fs
operator|->
name|lfs_nextseg
expr_stmt|;
name|sp
operator|->
name|sum_addr
operator|=
name|sp
operator|->
name|saddr
operator|+
name|sp
operator|->
name|seg_bytes_left
operator|/
name|DEV_BSIZE
expr_stmt|;
name|sp
operator|->
name|ninodes
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|nsums
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|seg_number
operator|=
operator|(
name|sp
operator|->
name|saddr
operator|-
name|fs
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
operator|)
operator|/
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_ssize
argument_list|)
expr_stmt|;
comment|/* Advance to the next segment. */
name|fs
operator|->
name|lfs_nextseg
operator|=
name|lfs_nextseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* Initialize the summary block. */
name|sp
operator|=
name|lfs_newsum
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * If su_nbytes non-zero after the segment was cleaned, the segment 	 * contains a super-block.  Add segment summary information to not 	 * allocate over it. 	 */
name|sup
operator|=
name|fs
operator|->
name|lfs_segtab
operator|+
name|sp
operator|->
name|seg_number
expr_stmt|;
if|if
condition|(
name|sup
operator|->
name|su_nbytes
operator|!=
literal|0
condition|)
block|{
name|ssp
operator|=
operator|(
name|SEGSUM
operator|*
operator|)
name|sp
operator|->
name|segsum
expr_stmt|;
operator|++
name|ssp
operator|->
name|ss_nfinfo
expr_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|fip
operator|->
name|fi_nblocks
operator|=
name|LFS_SBPAD
operator|>>
name|fs
operator|->
name|lfs_bshift
expr_stmt|;
name|fip
operator|->
name|fi_version
operator|=
literal|1
expr_stmt|;
name|fip
operator|->
name|fi_ino
operator|=
name|LFS_UNUSED_INUM
expr_stmt|;
name|lbnp
operator|=
name|fip
operator|->
name|fi_blocks
expr_stmt|;
for|for
control|(
name|lbn
operator|=
literal|0
init|;
name|lbn
operator|<
name|fip
operator|->
name|fi_nblocks
condition|;
operator|++
name|lbn
control|)
operator|*
name|lbnp
operator|++
operator|=
name|lbn
expr_stmt|;
name|sp
operator|->
name|saddr
operator|+=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fip
operator|->
name|fi_nblocks
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|sup
operator|->
name|su_nbytes
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|+
operator|(
name|fip
operator|->
name|fi_nblocks
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|sp
operator|->
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
name|lbnp
expr_stmt|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|SEGMENT
modifier|*
name|lfs_newsum
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
block|{
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
name|int
name|nblocks
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_newsum\n"
argument_list|)
expr_stmt|;
name|lfs_endsum
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Allocate a new buffer if necessary. */
if|if
condition|(
name|sp
operator|->
name|sbp
operator|==
name|NULL
condition|)
block|{
comment|/* Allocate a new segment if necessary. */
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
block|{
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|lfs_newseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
comment|/* Get the next summary block. */
name|sp
operator|->
name|sum_addr
operator|=
name|next
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
operator|&
name|nblocks
argument_list|)
expr_stmt|;
comment|/* 		 * Get a new buffer and enter into the buffer list from 		 * the top of the list. 		 */
name|sp
operator|->
name|sbp
operator|=
name|sp
operator|->
name|bpp
index|[
name|fs
operator|->
name|lfs_ssize
operator|-
operator|(
name|nblocks
operator|+
literal|1
operator|)
index|]
operator|=
name|lfs_newbuf
argument_list|(
name|fs
argument_list|,
name|sp
operator|->
name|sum_addr
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
comment|/* 		 * Do a callback for all but the very last summary block in 		 * the segment, for which we wait. 		 */
if|if
condition|(
name|sp
operator|->
name|nsums
operator|!=
literal|0
condition|)
name|sp
operator|->
name|sbp
operator|->
name|b_flags
operator||=
name|B_CALL
expr_stmt|;
comment|/* 		 * Fill in the block from the end.  The summary block is filled 		 * in from the end to the beginning so that the last summary 		 * is the last thing written, verifying the entire block.  This 		 * should go away when fragments are available. 		 */
name|sp
operator|->
name|segsum
operator|=
name|sp
operator|->
name|sbp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|fs
operator|->
name|lfs_bsize
operator|-
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|sp
operator|->
name|sum_addr
operator|+=
operator|(
name|fs
operator|->
name|lfs_bsize
operator|-
name|LFS_SUMMARY_SIZE
operator|)
operator|/
name|DEV_BSIZE
expr_stmt|;
name|printf
argument_list|(
literal|"alloc summary: bp %x, lblkno %x, bp index %d\n"
argument_list|,
name|sp
operator|->
name|sbp
argument_list|,
name|sp
operator|->
name|sbp
operator|->
name|b_lblkno
argument_list|,
name|fs
operator|->
name|lfs_ssize
operator|-
name|nblocks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|segsum
operator|-=
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|sp
operator|->
name|sum_addr
operator|-=
name|LFS_SUMMARY_SIZE
operator|/
name|DEV_BSIZE
expr_stmt|;
block|}
operator|++
name|sp
operator|->
name|nsums
expr_stmt|;
comment|/* Set point to SEGSUM, initialize it. */
name|ssp
operator|=
name|sp
operator|->
name|segsum
expr_stmt|;
name|ssp
operator|->
name|ss_next
operator|=
name|fs
operator|->
name|lfs_nextseg
expr_stmt|;
name|ssp
operator|->
name|ss_prev
operator|=
name|fs
operator|->
name|lfs_lastseg
expr_stmt|;
name|ssp
operator|->
name|ss_nextsum
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|ssp
operator|->
name|ss_create
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|ssp
operator|->
name|ss_nfinfo
operator|=
name|ssp
operator|->
name|ss_ninos
operator|=
literal|0
expr_stmt|;
comment|/* Set pointer to first FINFO, initialize it. */
name|sp
operator|->
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|+
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
operator|)
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|=
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|seginc
parameter_list|(
name|fs
parameter_list|,
name|sn
parameter_list|)
comment|/* increment segment number */
define|\
value|(((sn) + 1) % (fs)->lfs_nseg)
end_define

begin_comment
comment|/*  * Return the next segment to write.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|lfs_nextseg
parameter_list|(
name|fs
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
block|{
name|int
name|segnum
decl_stmt|,
name|sn
decl_stmt|;
name|segnum
operator|=
name|sn
operator|=
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_nextseg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sn
operator|=
name|seginc
argument_list|(
name|fs
argument_list|,
name|sn
argument_list|)
operator|)
operator|!=
name|segnum
operator|&&
name|fs
operator|->
name|lfs_segtab
index|[
name|sn
index|]
operator|.
name|su_flags
operator|&
name|SEGUSE_DIRTY
condition|)
empty_stmt|;
if|if
condition|(
name|sn
operator|==
name|segnum
condition|)
name|panic
argument_list|(
literal|"lfs_nextseg: file system full"
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|sntoda
argument_list|(
name|fs
argument_list|,
name|sn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the metadata that points to the blocks listed in the FINFO  * array.  */
end_comment

begin_function
specifier|static
name|void
name|lfs_updatemeta
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|ip
parameter_list|,
name|lbp
parameter_list|,
name|bpp
parameter_list|,
name|nblocks
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|INODE
modifier|*
name|ip
decl_stmt|;
name|daddr_t
modifier|*
name|lbp
decl_stmt|;
name|BUF
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|int
name|nblocks
decl_stmt|;
block|{
name|SEGUSE
modifier|*
name|segup
decl_stmt|;
name|BUF
modifier|*
modifier|*
name|lbpp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|,
name|iblkno
decl_stmt|;
name|int
name|db_per_fsb
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|long
name|lbn
decl_stmt|;
if|if
condition|(
name|nblocks
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"lfs_updatemeta of %d blocks\n"
argument_list|,
name|nblocks
argument_list|)
expr_stmt|;
comment|/* Sort the blocks and add disk addresses */
name|shellsort
argument_list|(
name|bpp
argument_list|,
name|lbp
argument_list|,
name|nblocks
argument_list|)
expr_stmt|;
name|db_per_fsb
operator|=
literal|1
operator|<<
name|fs
operator|->
name|lfs_fsbtodb
expr_stmt|;
for|for
control|(
name|lbpp
operator|=
name|bpp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
condition|;
operator|++
name|i
operator|,
operator|++
name|lbpp
control|)
block|{
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
operator|=
name|sp
operator|->
name|saddr
expr_stmt|;
name|sp
operator|->
name|saddr
operator|+=
name|db_per_fsb
expr_stmt|;
block|}
for|for
control|(
name|lbpp
operator|=
name|bpp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
condition|;
operator|++
name|i
operator|,
operator|++
name|lbpp
control|)
block|{
name|lbn
operator|=
name|lbp
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"lfs_updatemeta: block %d\n"
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|lfs_bmap
argument_list|(
name|ip
argument_list|,
name|lbn
argument_list|,
operator|&
name|daddr
argument_list|)
condition|)
name|panic
argument_list|(
literal|"lfs_updatemeta: lfs_bmap"
argument_list|)
expr_stmt|;
comment|/* Update in-core copy of old segment usage information. */
if|if
condition|(
name|daddr
operator|!=
name|UNASSIGNED
condition|)
block|{
name|segup
operator|=
name|fs
operator|->
name|lfs_segtab
operator|+
name|datosn
argument_list|(
name|fs
argument_list|,
name|daddr
argument_list|)
expr_stmt|;
name|segup
operator|->
name|su_lastmod
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|segup
operator|->
name|su_nbytes
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
block|{
name|printf
argument_list|(
literal|"lfs: negative bytes (segment %d)\n"
argument_list|,
name|segup
operator|-
name|fs
operator|->
name|lfs_segtab
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"lfs: negative bytes in segment\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|segup
operator|->
name|su_nbytes
operator|-=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
block|}
comment|/* 		 * Now change whomever points to lbn.  We could start with the 		 * smallest (most negative) block number in these if clauses, 		 * but we assume that indirect blocks are least common, and 		 * handle them separately.  The test for< 0 is correct and 		 * minimizes the path in the common case. 		 */
define|#
directive|define
name|BREAD
parameter_list|(
name|bno
parameter_list|)
define|\
value|if (error = bread(ITOV(ip), (bno), fs->lfs_bsize, NOCRED,&bp)) \ 		panic("lfs_updatemeta: bread");
if|if
condition|(
name|lbn
operator|<
literal|0
condition|)
if|if
condition|(
name|lbn
operator|<
operator|-
name|NIADDR
condition|)
block|{
name|printf
argument_list|(
literal|"meta: update indirect block %d\n"
argument_list|,
name|D_INDIR
argument_list|)
expr_stmt|;
name|BREAD
argument_list|(
name|D_INDIR
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_daddr
index|[
operator|-
name|lbn
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
index|]
operator|=
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
expr_stmt|;
name|lfs_bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|i_ib
index|[
operator|-
name|lbn
operator|-
literal|1
index|]
operator|=
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
block|{
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
operator|=
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lbn
operator|-=
name|NDADDR
operator|)
operator|<
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"meta: update indirect block %d\n"
argument_list|,
name|S_INDIR
argument_list|)
expr_stmt|;
name|BREAD
argument_list|(
name|S_INDIR
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_daddr
index|[
name|lbn
index|]
operator|=
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
expr_stmt|;
name|lfs_bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lbn
operator|=
operator|(
name|lbn
operator|-
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|)
operator|/
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|)
operator|<
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|iblkno
operator|=
operator|-
operator|(
name|lbn
operator|+
name|NIADDR
operator|+
literal|1
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"meta: update indirect block %d\n"
argument_list|,
name|iblkno
argument_list|)
expr_stmt|;
name|BREAD
argument_list|(
name|iblkno
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_daddr
index|[
name|lbn
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
index|]
operator|=
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
expr_stmt|;
name|lfs_bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"lfs_updatemeta: logical block number too large"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|SEGMENT
modifier|*
name|lfs_writeckp
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
block|{
name|BUF
modifier|*
name|bp
decl_stmt|;
name|FINFO
modifier|*
name|fip
decl_stmt|;
name|INODE
modifier|*
name|ip
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|void
modifier|*
name|xp
decl_stmt|;
name|daddr_t
modifier|*
name|lbp
decl_stmt|;
name|int
name|bytes_needed
decl_stmt|,
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_writeckp\n"
argument_list|)
expr_stmt|;
comment|/* 	 * This will write the dirty ifile blocks, but not the segusage 	 * table nor the ifile inode. 	 */
name|sp
operator|=
name|lfs_writefile
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|fs
operator|->
name|lfs_ivnode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If the segment usage table and the ifile inode won't fit in this 	 * segment, put them in the next one. 	 */
name|bytes_needed
operator|=
name|fs
operator|->
name|lfs_segtabsz
operator|<<
name|fs
operator|->
name|lfs_bshift
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|ninodes
operator|%
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|==
literal|0
condition|)
name|bytes_needed
operator|+=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|bytes_needed
condition|)
block|{
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|lfs_newseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|sum_bytes_left
operator|<
name|fs
operator|->
name|lfs_segtabsz
operator|*
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
condition|)
block|{
name|sp
operator|=
name|lfs_newsum
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|bytes_needed
condition|)
name|panic
argument_list|(
literal|"lfs_writeckp: unable to write checkpoint"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Update the segment usage information and the ifile inode 	 * and write it out. 	 */
name|sup
operator|=
name|fs
operator|->
name|lfs_segtab
operator|+
name|sp
operator|->
name|seg_number
expr_stmt|;
name|sup
operator|->
name|su_nbytes
operator|=
operator|(
name|fs
operator|->
name|lfs_segmask
operator|+
literal|1
operator|)
operator|-
name|sp
operator|->
name|seg_bytes_left
operator|+
name|bytes_needed
expr_stmt|;
name|sup
operator|->
name|su_lastmod
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|sup
operator|->
name|su_flags
operator|=
name|SEGUSE_DIRTY
expr_stmt|;
comment|/* 	 * Get buffers for the segusage table and write it out.  Don't 	 * bother updating the FINFO pointer, it's not used after this. 	 */
name|ip
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
expr_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|lbp
operator|=
operator|&
name|fip
operator|->
name|fi_blocks
index|[
name|fip
operator|->
name|fi_nblocks
index|]
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|fs
operator|->
name|lfs_segtab
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|lfs_segtabsz
condition|;
name|xp
operator|+=
name|fs
operator|->
name|lfs_bsize
operator|,
operator|++
name|i
operator|,
operator|++
name|lbp
control|)
block|{
operator|*
name|sp
operator|->
name|cbpp
operator|++
operator|=
name|bp
operator|=
name|lfs_newbuf
argument_list|(
name|fs
argument_list|,
name|sp
operator|->
name|saddr
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_CALL
expr_stmt|;
name|bcopy
argument_list|(
name|xp
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_db
index|[
name|i
index|]
operator|=
name|sp
operator|->
name|saddr
expr_stmt|;
name|sp
operator|->
name|saddr
operator|+=
operator|(
literal|1
operator|<<
name|fs
operator|->
name|lfs_fsbtodb
operator|)
expr_stmt|;
operator|*
name|lbp
operator|=
name|i
expr_stmt|;
operator|++
name|fip
operator|->
name|fi_nblocks
expr_stmt|;
block|}
return|return
operator|(
name|lfs_writeinode
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write the dirty blocks associated with a vnode.  */
end_comment

begin_function
specifier|static
name|SEGMENT
modifier|*
name|lfs_writefile
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|vp
parameter_list|,
name|do_ckp
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|VNODE
modifier|*
name|vp
decl_stmt|;
name|int
name|do_ckp
decl_stmt|;
block|{
name|FINFO
modifier|*
name|fip
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|inum
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_number
expr_stmt|;
name|printf
argument_list|(
literal|"lfs_writefile: node %d\n"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_dirtyblkhd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
block|{
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|lfs_newseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
condition|)
name|sp
operator|=
name|lfs_newsum
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|fip
operator|->
name|fi_nblocks
operator|=
literal|0
expr_stmt|;
name|fip
operator|->
name|fi_version
operator|=
name|inum
operator|==
name|LFS_IFILE_INUM
condition|?
literal|1
else|:
name|lfs_getversion
argument_list|(
name|fs
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|fip
operator|->
name|fi_ino
operator|=
name|inum
expr_stmt|;
name|sp
operator|=
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|match_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_ckp
condition|)
block|{
name|sp
operator|=
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|match_indir
argument_list|)
expr_stmt|;
name|sp
operator|=
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|match_dindir
argument_list|)
expr_stmt|;
block|}
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|printf
argument_list|(
literal|"lfs_writefile: adding %d blocks\n"
argument_list|,
name|fip
operator|->
name|fi_nblocks
argument_list|)
expr_stmt|;
comment|/* 		 * If this is the ifile, always update the file count as we'll 		 * be adding the segment usage information even if we didn't 		 * write any blocks.  Also, don't update the FINFO pointer for 		 * the ifile as the segment usage information hasn't yet been 		 * added. 		 */
if|if
condition|(
name|inum
operator|==
name|LFS_IFILE_INUM
condition|)
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
expr_stmt|;
elseif|else
if|if
condition|(
name|fip
operator|->
name|fi_nblocks
operator|!=
literal|0
condition|)
block|{
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
expr_stmt|;
name|sp
operator|->
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|fip
operator|+
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|*
operator|(
name|fip
operator|->
name|fi_nblocks
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|/* If this isn't the ifile, update the inode. */
if|if
condition|(
name|inum
operator|!=
name|LFS_IFILE_INUM
condition|)
name|sp
operator|=
name|lfs_writeinode
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|SEGMENT
modifier|*
name|lfs_writeinode
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|ip
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|INODE
modifier|*
name|ip
decl_stmt|;
block|{
name|BUF
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|next_addr
decl_stmt|;
name|int
name|nblocks
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_writeinode\n"
argument_list|)
expr_stmt|;
comment|/* Allocate a new inode block if necessary. */
if|if
condition|(
name|sp
operator|->
name|ibp
operator|==
name|NULL
condition|)
block|{
comment|/* Allocate a new segment if necessary. */
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
block|{
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|lfs_newseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
comment|/* Get next inode block. */
name|next_addr
operator|=
name|next
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
operator|&
name|nblocks
argument_list|)
expr_stmt|;
comment|/* 		 * Get a new buffer and enter into the buffer list from 		 * the top of the list. 		 */
name|sp
operator|->
name|ibp
operator|=
name|sp
operator|->
name|bpp
index|[
name|fs
operator|->
name|lfs_ssize
operator|-
operator|(
name|nblocks
operator|+
literal|1
operator|)
index|]
operator|=
name|lfs_newbuf
argument_list|(
name|fs
argument_list|,
name|next_addr
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ibp
operator|->
name|b_flags
operator||=
name|B_CALL
expr_stmt|;
comment|/* Set remaining space counter. */
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
name|printf
argument_list|(
literal|"alloc inode: bp %x, lblkno %x, bp index %d\n"
argument_list|,
name|sp
operator|->
name|sbp
argument_list|,
name|sp
operator|->
name|sbp
operator|->
name|b_lblkno
argument_list|,
name|fs
operator|->
name|lfs_ssize
operator|-
name|nblocks
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the new inode onto the inode page. */
name|bp
operator|=
name|sp
operator|->
name|ibp
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ip
operator|->
name|i_din
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_dino
operator|+
operator|(
name|sp
operator|->
name|ninodes
operator|%
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|DINODE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Increment inode count in segment summary block. */
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_ninos
expr_stmt|;
comment|/* If this page is full, set flag to allocate a new page. */
if|if
condition|(
operator|++
name|sp
operator|->
name|ninodes
operator|%
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|==
literal|0
condition|)
name|sp
operator|->
name|ibp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If updating the ifile, update the super-block; otherwise, update 	 * the ifile itself.  In either case, turn of inode update flags. 	 */
if|if
condition|(
name|ip
operator|->
name|i_number
operator|==
name|LFS_IFILE_INUM
condition|)
name|fs
operator|->
name|lfs_idaddr
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
else|else
name|lfs_iset
argument_list|(
name|ip
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|ip
operator|->
name|i_atime
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flags
operator|&=
operator|~
operator|(
name|IMOD
operator||
name|IACC
operator||
name|IUPD
operator||
name|ICHG
operator|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_writeseg
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
block|{
name|BUF
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nblocks
decl_stmt|,
name|s
decl_stmt|,
argument_list|(
operator|*
name|strategy
argument_list|)
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
name|void
modifier|*
name|pmeta
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_writeseg\n"
argument_list|)
expr_stmt|;
comment|/* Update superblock segment address. */
name|fs
operator|->
name|lfs_lastseg
operator|=
name|sntoda
argument_list|(
name|fs
argument_list|,
name|sp
operator|->
name|seg_number
argument_list|)
expr_stmt|;
comment|/* Finish up any summary block. */
name|lfs_endsum
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Copy inode and summary block buffer pointers down so they are 	 * contiguous with the page buffer pointers. 	 */
operator|(
name|void
operator|)
name|next
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
operator|&
name|nblocks
argument_list|)
expr_stmt|;
name|pmeta
operator|=
operator|(
name|sp
operator|->
name|bpp
operator|+
name|fs
operator|->
name|lfs_ssize
operator|)
operator|-
name|nblocks
expr_stmt|;
if|if
condition|(
name|pmeta
operator|!=
name|sp
operator|->
name|cbpp
condition|)
name|bcopy
argument_list|(
name|pmeta
argument_list|,
name|sp
operator|->
name|cbpp
argument_list|,
sizeof|sizeof
argument_list|(
name|BUF
operator|*
argument_list|)
operator|*
name|nblocks
argument_list|)
expr_stmt|;
name|sp
operator|->
name|cbpp
operator|+=
name|nblocks
expr_stmt|;
name|nblocks
operator|=
name|sp
operator|->
name|cbpp
operator|-
name|sp
operator|->
name|bpp
expr_stmt|;
name|sup
operator|=
name|fs
operator|->
name|lfs_segtab
operator|+
name|sp
operator|->
name|seg_number
expr_stmt|;
name|sup
operator|->
name|su_nbytes
operator|=
name|nblocks
operator|<<
name|fs
operator|->
name|lfs_bshift
expr_stmt|;
name|sup
operator|->
name|su_lastmod
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|sup
operator|->
name|su_flags
operator|=
name|SEGUSE_DIRTY
expr_stmt|;
comment|/* 	 * Since we need to guarantee that the summary block gets written last, 	 * we issue the writes in two sets.  The first n-1 buffers first, and 	 * then, after they've completed, the summary buffer.  Only when that 	 * final write completes is the segment valid. 	 */
operator|--
name|nblocks
expr_stmt|;
comment|/* Don't count last summary block. */
name|sp
operator|->
name|nextp
operator|=
name|fs
operator|->
name|lfs_seglist
expr_stmt|;
name|fs
operator|->
name|lfs_seglist
operator|=
name|sp
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|fs
operator|->
name|lfs_iocount
operator|+=
name|nblocks
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|strategy
operator|=
name|VFSTOUFS
argument_list|(
name|fs
operator|->
name|lfs_ivnode
operator|->
name|v_mount
argument_list|)
operator|->
name|um_devvp
operator|->
name|v_op
operator|->
name|vop_strategy
expr_stmt|;
for|for
control|(
name|bpp
operator|=
name|sp
operator|->
name|bpp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
condition|;
operator|++
name|i
operator|,
operator|++
name|bpp
control|)
call|(
name|strategy
call|)
argument_list|(
operator|*
name|bpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_writesum
parameter_list|(
name|fs
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
block|{
name|BUF
modifier|*
name|bp
decl_stmt|;
name|SEGMENT
modifier|*
name|next_sp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|int
argument_list|(
argument|*strategy
argument_list|)
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lfs_writesum\n"
argument_list|)
expr_stmt|;
name|strategy
operator|=
name|VFSTOUFS
argument_list|(
name|fs
operator|->
name|lfs_ivnode
operator|->
name|v_mount
argument_list|)
operator|->
name|um_devvp
operator|->
name|v_op
operator|->
name|vop_strategy
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|fs
operator|->
name|lfs_seglist
init|;
name|sp
condition|;
name|sp
operator|=
name|next_sp
control|)
block|{
name|bp
operator|=
operator|*
operator|(
name|sp
operator|->
name|cbpp
operator|-
literal|1
operator|)
expr_stmt|;
call|(
name|strategy
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|next_sp
operator|=
name|sp
operator|->
name|nextp
expr_stmt|;
name|free
argument_list|(
name|sp
operator|->
name|bpp
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
block|}
comment|/* Segment list is done. */
name|fs
operator|->
name|lfs_seglist
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_writesuper
parameter_list|(
name|fs
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
block|{
name|BUF
modifier|*
name|bp
decl_stmt|;
name|int
argument_list|(
argument|*strategy
argument_list|)
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lfs_writesuper\n"
argument_list|)
expr_stmt|;
comment|/* Checksum the superblock and copy it into a buffer. */
name|fs
operator|->
name|lfs_cksum
operator|=
name|cksum
argument_list|(
name|fs
argument_list|,
sizeof|sizeof
argument_list|(
name|LFS
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|fs
operator|->
name|lfs_cksum
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|lfs_newbuf
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
argument_list|,
name|LFS_SBPAD
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fs
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_lfs
argument_list|,
sizeof|sizeof
argument_list|(
name|LFS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the first superblock. */
name|strategy
operator|=
name|VFSTOUFS
argument_list|(
name|fs
operator|->
name|lfs_ivnode
operator|->
name|v_mount
argument_list|)
operator|->
name|um_devvp
operator|->
name|v_op
operator|->
name|vop_strategy
expr_stmt|;
call|(
name|strategy
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Write the second superblock. */
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_DONE
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|bp
operator|->
name|b_lblkno
operator|=
name|fs
operator|->
name|lfs_sboffs
index|[
literal|1
index|]
expr_stmt|;
call|(
name|strategy
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|NULL
expr_stmt|;
comment|/* No associated vnode. */
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lfs_writesuper is returning\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Logical block number match routines used when traversing the dirty block  * chain.  */
end_comment

begin_function
name|int
name|match_data
parameter_list|(
name|bp
parameter_list|)
name|BUF
modifier|*
name|bp
decl_stmt|;
block|{
return|return
operator|(
name|bp
operator|->
name|b_lblkno
operator|>=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|match_dindir
parameter_list|(
name|bp
parameter_list|)
name|BUF
modifier|*
name|bp
decl_stmt|;
block|{
return|return
operator|(
name|bp
operator|->
name|b_lblkno
operator|==
name|D_INDIR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These are single indirect blocks.  There are three types:  *  * the one in the inode (lblkno == S_INDIR, or -1).  * the ones that hang off of the double indirect in the inode (D_INDIR);  *    these all have addresses in the range -2NINDIR to -(3NINDIR-1).  * the ones that hang off of the double indirect that hangs off of the  *    triple indirect.  These all have addresses< -(NINDIR^2).  *  * Since we currently don't support triple indirect blocks, this gets  * simpler, and we just look for block numbers less than -NIADDR.  */
end_comment

begin_function
name|int
name|match_indir
parameter_list|(
name|bp
parameter_list|)
name|BUF
modifier|*
name|bp
decl_stmt|;
block|{
return|return
operator|(
name|bp
operator|->
name|b_lblkno
operator|==
name|S_INDIR
operator|||
name|bp
operator|->
name|b_lblkno
operator|<
operator|-
name|NIADDR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the next inode/summary block. */
end_comment

begin_function
specifier|static
name|daddr_t
name|next
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|nbp
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|int
modifier|*
name|nbp
decl_stmt|;
block|{
name|int
name|nblocks
decl_stmt|,
name|nino_blocks
decl_stmt|,
name|nseg_blocks
decl_stmt|,
name|sums_per_block
decl_stmt|;
comment|/* Fs blocks allocated to summary blocks. */
name|sums_per_block
operator|=
name|fs
operator|->
name|lfs_bsize
operator|/
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|nseg_blocks
operator|=
operator|(
name|sp
operator|->
name|nsums
operator|+
name|sums_per_block
operator|-
literal|1
operator|)
operator|/
name|sums_per_block
expr_stmt|;
comment|/* Fs blocks allocated to inodes. */
name|nino_blocks
operator|=
operator|(
name|sp
operator|->
name|ninodes
operator|+
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|INOPB
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* Total number of fs blocks allocated. */
name|nblocks
operator|=
name|nseg_blocks
operator|+
name|nino_blocks
expr_stmt|;
if|if
condition|(
name|nbp
condition|)
operator|*
name|nbp
operator|=
name|nblocks
expr_stmt|;
comment|/* 	 * The disk address of the new inode/summary block is the address of 	 * the start of the segment after this one minus the number of blocks 	 * that we've already used. 	 */
return|return
operator|(
name|sntoda
argument_list|(
name|fs
argument_list|,
name|sp
operator|->
name|seg_number
operator|+
literal|1
argument_list|)
operator|-
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|nblocks
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shellsort (diminishing increment sort) from Data Structures and  * Algorithms, Aho, Hopcraft and Ullman, 1983 Edition, page 290;  * see also Knuth Vol. 3, page 84.  The increments are selected from  * formula (8), page 95.  Roughly O(N^3/2).  */
end_comment

begin_comment
comment|/*  * This is our own private copy of shellsort because we want to sort  * two parallel arrays (the array of buffer pointers and the array of  * logical block numbers) simultaneously.  Note that we cast the array  * of logical block numbers to a unsigned in this routine so that the  * negative block numbers (meta data blocks) sort AFTER the data blocks.  */
end_comment

begin_function
specifier|static
name|void
name|shellsort
parameter_list|(
name|bp_array
parameter_list|,
name|lb_array
parameter_list|,
name|nmemb
parameter_list|)
name|BUF
modifier|*
modifier|*
name|bp_array
decl_stmt|;
name|daddr_t
modifier|*
name|lb_array
decl_stmt|;
specifier|register
name|int
name|nmemb
decl_stmt|;
block|{
specifier|static
name|int
name|__rsshell_increments
index|[]
init|=
block|{
literal|4
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
specifier|register
name|int
name|incr
decl_stmt|,
modifier|*
name|incrp
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|BUF
modifier|*
name|bp_temp
decl_stmt|;
name|u_long
name|lb_temp
decl_stmt|;
for|for
control|(
name|incrp
operator|=
name|__rsshell_increments
init|;
name|incr
operator|=
operator|*
name|incrp
operator|++
condition|;
control|)
for|for
control|(
name|t1
operator|=
name|incr
init|;
name|t1
operator|<
name|nmemb
condition|;
operator|++
name|t1
control|)
for|for
control|(
name|t2
operator|=
name|t1
operator|-
name|incr
init|;
name|t2
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|lb_array
index|[
name|t2
index|]
operator|>
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
condition|)
block|{
name|lb_temp
operator|=
name|lb_array
index|[
name|t2
index|]
expr_stmt|;
name|lb_array
index|[
name|t2
index|]
operator|=
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
expr_stmt|;
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
operator|=
name|lb_temp
expr_stmt|;
name|bp_temp
operator|=
name|bp_array
index|[
name|t2
index|]
expr_stmt|;
name|bp_array
index|[
name|t2
index|]
operator|=
name|bp_array
index|[
name|t2
operator|+
name|incr
index|]
expr_stmt|;
name|bp_array
index|[
name|t2
operator|+
name|incr
index|]
operator|=
name|bp_temp
expr_stmt|;
name|t2
operator|-=
name|incr
expr_stmt|;
block|}
else|else
break|break;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LOGFS */
end_comment

end_unit

