begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)lfs_segment.c	7.3 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/specdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/fifo.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs_extern.h>
end_include

begin_comment
comment|/* In-memory description of a segment about to be written. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|segment
name|SEGMENT
typedef|;
end_typedef

begin_struct
struct|struct
name|segment
block|{
name|BUF
modifier|*
modifier|*
name|bpp
decl_stmt|;
comment|/* pointer to buffer array */
name|BUF
modifier|*
modifier|*
name|cbpp
decl_stmt|;
comment|/* pointer to next available bp */
name|BUF
modifier|*
name|ibp
decl_stmt|;
comment|/* buffer pointer to inode page */
name|void
modifier|*
name|segsum
decl_stmt|;
comment|/* segment summary info */
name|u_long
name|ninodes
decl_stmt|;
comment|/* number of inodes in this segment */
name|u_long
name|seg_bytes_left
decl_stmt|;
comment|/* bytes left in segment */
name|u_long
name|sum_bytes_left
decl_stmt|;
comment|/* bytes left in summary block */
name|u_long
name|seg_number
decl_stmt|;
comment|/* number of this segment */
define|#
directive|define
name|SEGM_CKP
value|0x01
comment|/* doing a checkpoint */
name|u_long
name|seg_flags
decl_stmt|;
comment|/* run-time flags for this segment */
name|FINFO
modifier|*
name|fip
decl_stmt|;
comment|/* current fileinfo pointer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Determine if it's OK to start a partial in this segment, or if we need  * to go on to a new segment.  */
end_comment

begin_define
define|#
directive|define
name|LFS_PARTIAL_FITS
parameter_list|(
name|fs
parameter_list|)
define|\
value|((fs)->lfs_dbpseg - ((fs)->lfs_offset - (fs)->lfs_curseg)> \ 	1<< (fs)->lfs_fsbtodb)
end_define

begin_define
define|#
directive|define
name|datosn
parameter_list|(
name|fs
parameter_list|,
name|daddr
parameter_list|)
comment|/* disk address to segment number */
define|\
value|(((daddr) - (fs)->lfs_sboffs[0]) / fsbtodb((fs), (fs)->lfs_ssize))
end_define

begin_define
define|#
directive|define
name|sntoda
parameter_list|(
name|fs
parameter_list|,
name|sn
parameter_list|)
comment|/* segment number to disk address */
define|\
value|((daddr_t)((sn) * ((fs)->lfs_ssize<< (fs)->lfs_fsbtodb) + \ 	    (fs)->lfs_sboffs[0]))
end_define

begin_decl_stmt
specifier|static
name|int
name|lfs_callback
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_gather
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|SEGMENT
operator|*
operator|,
name|VNODE
operator|*
operator|,
name|int
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|BUF
operator|*
operator|)
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BUF
modifier|*
name|lfs_newbuf
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|SEGMENT
operator|*
operator|,
name|daddr_t
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_newseg
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|SEGMENT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|daddr_t
name|lfs_nextseg
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_updatemeta
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|SEGMENT
operator|*
operator|,
name|VNODE
operator|*
operator|,
name|daddr_t
operator|*
operator|,
name|BUF
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_writefile
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|SEGMENT
operator|*
operator|,
name|VNODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_writeinode
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|SEGMENT
operator|*
operator|,
name|INODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_writeseg
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|SEGMENT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_writesuper
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|SEGMENT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|match_data
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|match_dindir
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|match_indir
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|match_tindir
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|shellsort
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|*
operator|,
name|daddr_t
operator|*
operator|,
specifier|register
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lfs_allclean_wakeup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cleaner wakeup address. */
end_comment

begin_function
name|int
name|lfs_segwrite
parameter_list|(
name|mp
parameter_list|,
name|do_ckp
parameter_list|)
name|MOUNT
modifier|*
name|mp
decl_stmt|;
name|int
name|do_ckp
decl_stmt|;
comment|/* Do a checkpoint. */
block|{
name|INODE
modifier|*
name|ip
decl_stmt|;
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|VNODE
modifier|*
name|vp
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_segwrite\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
comment|/* 	 * If doing a checkpoint, we keep a cumulative count of the outstanding 	 * I/O operations.  If the disk drive catches up with us it could go to 	 * zero before we finish, so we artificially increment it by one until 	 * we've scheduled all of the writes we intend to do. 	 */
if|if
condition|(
name|do_ckp
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|fs
operator|->
name|lfs_iocount
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate a segment structure and enough space to hold pointers to 	 * the maximum possible number of buffers which can be described in a 	 * single summary block. 	 */
name|sp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SEGMENT
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|bpp
operator|=
name|malloc
argument_list|(
operator|(
operator|(
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|BUF
operator|*
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_flags
operator|=
name|do_ckp
condition|?
name|SEGM_CKP
else|:
literal|0
expr_stmt|;
name|lfs_newseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|loop
label|:
for|for
control|(
name|vp
operator|=
name|mp
operator|->
name|mnt_mounth
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|v_mountf
control|)
block|{
comment|/* 		 * If the vnode that we are about to sync is no longer 		 * associated with this mount point, start over. 		 */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
goto|goto
name|loop
goto|;
if|if
condition|(
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
condition|)
continue|continue;
comment|/* If nothing dirty, or it's the IFILE, skip it. */
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_flag
operator|&
operator|(
name|IMOD
operator||
name|IACC
operator||
name|IUPD
operator||
name|ICHG
operator|)
operator|==
literal|0
operator|&&
name|vp
operator|->
name|v_dirtyblkhd
operator|==
name|NULL
operator|||
name|ip
operator|->
name|i_number
operator|==
name|LFS_IFILE_INUM
condition|)
continue|continue;
if|if
condition|(
name|vget
argument_list|(
name|vp
argument_list|)
condition|)
goto|goto
name|loop
goto|;
name|lfs_writefile
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_ckp
condition|)
block|{
name|lfs_writefile
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|fs
operator|->
name|lfs_ivnode
argument_list|)
expr_stmt|;
name|lfs_writeinode
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * If the I/O count is non-zero, sleep until it reaches zero.  At the 	 * moment, the user's process hangs around so we can sleep. 	 */
if|if
condition|(
name|do_ckp
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|--
name|fs
operator|->
name|lfs_iocount
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|&
name|fs
operator|->
name|lfs_iocount
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|,
literal|"sync"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lfs_writesuper
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
name|sp
operator|->
name|bpp
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|sp
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
comment|/* Wake up any cleaning processes waiting on this file system. */
name|wakeup
argument_list|(
operator|&
name|fs
operator|->
name|lfs_nextseg
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|lfs_allclean_wakeup
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write the dirty blocks associated with a vnode.  */
end_comment

begin_function
specifier|static
name|void
name|lfs_writefile
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|vp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|VNODE
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|FINFO
modifier|*
name|fip
decl_stmt|;
name|IFILE
modifier|*
name|ifp
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_writefile\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|inum
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_number
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_dirtyblkhd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
operator|||
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
condition|)
block|{
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|lfs_newseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|fip
operator|->
name|fi_nblocks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inum
operator|==
name|LFS_IFILE_INUM
condition|)
name|fip
operator|->
name|fi_version
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|LFS_IENTRY
argument_list|(
name|ifp
argument_list|,
name|fs
argument_list|,
name|inum
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|fip
operator|->
name|fi_version
operator|=
name|ifp
operator|->
name|if_version
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|fip
operator|->
name|fi_ino
operator|=
name|inum
expr_stmt|;
comment|/* 		 * It may not be necessary to write the meta-data blocks 		 * at this point, as the roll-forward recovery code should 		 * be able to reconstruct the list. 		 */
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|match_data
argument_list|)
expr_stmt|;
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|match_indir
argument_list|)
expr_stmt|;
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|match_dindir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRIPLE
name|lfs_gather
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|match_tindir
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
ifdef|#
directive|ifdef
name|META
name|printf
argument_list|(
literal|"lfs_writefile: adding %d blocks\n"
argument_list|,
name|fip
operator|->
name|fi_nblocks
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fip
operator|->
name|fi_nblocks
operator|!=
literal|0
condition|)
block|{
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
expr_stmt|;
name|sp
operator|->
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|fip
operator|+
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|*
operator|(
name|fip
operator|->
name|fi_nblocks
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|/* If this isn't the ifile, update the inode. */
if|if
condition|(
name|inum
operator|!=
name|LFS_IFILE_INUM
condition|)
name|lfs_writeinode
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|lfs_gather
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|vp
parameter_list|,
name|match
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|VNODE
modifier|*
name|vp
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*match
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
expr|struct
name|lfs
operator|*
operator|,
name|BUF
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BUF
modifier|*
modifier|*
name|bpp
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
name|FINFO
modifier|*
name|fip
decl_stmt|;
name|INODE
modifier|*
name|ip
decl_stmt|;
name|daddr_t
modifier|*
name|lbp
decl_stmt|,
modifier|*
name|start_lbp
decl_stmt|;
name|u_long
name|version
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_gather\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|sp
operator|->
name|cbpp
expr_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|start_lbp
operator|=
name|lbp
operator|=
operator|&
name|fip
operator|->
name|fi_blocks
index|[
name|fip
operator|->
name|fi_nblocks
index|]
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|vp
operator|->
name|v_dirtyblkhd
init|;
name|bp
condition|;
name|bp
operator|=
name|nbp
control|)
block|{
name|nbp
operator|=
name|bp
operator|->
name|b_blockf
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
condition|)
name|panic
argument_list|(
literal|"lfs_gather: buffer not B_DELWRI"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCKED
operator|)
condition|)
name|panic
argument_list|(
literal|"lfs_gather: buffer not B_LOCKED"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|match
argument_list|(
name|fs
argument_list|,
name|bp
argument_list|)
condition|)
continue|continue;
comment|/* Insert into the buffer list, update the FINFO block. */
operator|*
name|sp
operator|->
name|cbpp
operator|++
operator|=
name|bp
expr_stmt|;
operator|++
name|fip
operator|->
name|fi_nblocks
expr_stmt|;
operator|*
name|lbp
operator|++
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
comment|/* 		 * If full, finish this segment.  We may be doing I/O, so 		 * release and reacquire the splbio(). 		 */
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|||
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lfs_updatemeta
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|start_lbp
argument_list|,
name|bpp
argument_list|,
name|lbp
operator|-
name|start_lbp
argument_list|)
expr_stmt|;
comment|/* Add the current file to the segment summary. */
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
expr_stmt|;
name|version
operator|=
name|fip
operator|->
name|fi_version
expr_stmt|;
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|lfs_newseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|fip
operator|->
name|fi_version
operator|=
name|version
expr_stmt|;
name|fip
operator|->
name|fi_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|start_lbp
operator|=
name|lbp
operator|=
name|fip
operator|->
name|fi_blocks
expr_stmt|;
name|bpp
operator|=
name|sp
operator|->
name|cbpp
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lfs_updatemeta
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|vp
argument_list|,
name|start_lbp
argument_list|,
name|bpp
argument_list|,
name|lbp
operator|-
name|start_lbp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start a new segment.  */
end_comment

begin_function
specifier|static
name|void
name|lfs_newseg
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
block|{
name|FINFO
modifier|*
name|fip
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|,
modifier|*
name|lbnp
decl_stmt|;
name|int
name|nblocks
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_newseg\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Advance to the next segment. */
if|if
condition|(
operator|!
name|LFS_PARTIAL_FITS
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"allocating a new segment\n"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|lfs_curseg
operator|=
name|fs
operator|->
name|lfs_offset
operator|=
name|fs
operator|->
name|lfs_nextseg
expr_stmt|;
name|fs
operator|->
name|lfs_nextseg
operator|=
name|lfs_nextseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_number
operator|=
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_curseg
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|=
name|fs
operator|->
name|lfs_dbpseg
operator|*
name|DEV_BSIZE
expr_stmt|;
comment|/* 		 * If su_nbytes is non-zero after the segment was cleaned, 		 * the segment contains a super-block.  Update offset and 		 * summary address to skip over the superblock. 		 */
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|sp
operator|->
name|seg_number
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sup
operator|->
name|su_nbytes
operator|!=
literal|0
condition|)
block|{
name|fs
operator|->
name|lfs_offset
operator|+=
name|LFS_SBPAD
operator|/
name|DEV_BSIZE
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|LFS_SBPAD
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"done allocating new seg\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"using old segment\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_number
operator|=
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_curseg
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|=
operator|(
name|fs
operator|->
name|lfs_dbpseg
operator|-
operator|(
name|fs
operator|->
name|lfs_offset
operator|-
name|fs
operator|->
name|lfs_curseg
operator|)
operator|)
operator|*
name|DEV_BSIZE
expr_stmt|;
block|}
name|sp
operator|->
name|ibp
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|ninodes
operator|=
literal|0
expr_stmt|;
comment|/* Get a new buffer for SEGSUM and enter it into the buffer list. */
name|sp
operator|->
name|cbpp
operator|=
name|sp
operator|->
name|bpp
expr_stmt|;
operator|*
name|sp
operator|->
name|cbpp
operator|=
name|lfs_newbuf
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|fs
operator|->
name|lfs_offset
argument_list|,
name|LFS_SUMMARY_SIZE
argument_list|)
expr_stmt|;
name|sp
operator|->
name|segsum
operator|=
operator|(
operator|*
name|sp
operator|->
name|cbpp
operator|)
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
operator|++
name|sp
operator|->
name|cbpp
expr_stmt|;
name|fs
operator|->
name|lfs_offset
operator|+=
name|LFS_SUMMARY_SIZE
operator|/
name|DEV_BSIZE
expr_stmt|;
comment|/* Set point to SEGSUM, initialize it. */
name|ssp
operator|=
name|sp
operator|->
name|segsum
expr_stmt|;
name|ssp
operator|->
name|ss_next
operator|=
name|fs
operator|->
name|lfs_nextseg
expr_stmt|;
name|ssp
operator|->
name|ss_create
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|ssp
operator|->
name|ss_nfinfo
operator|=
name|ssp
operator|->
name|ss_ninos
operator|=
literal|0
expr_stmt|;
comment|/* Set pointer to first FINFO, initialize it. */
name|sp
operator|->
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|+
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
operator|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|=
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|seginc
parameter_list|(
name|fs
parameter_list|,
name|sn
parameter_list|)
comment|/* increment segment number */
define|\
value|(((sn) + 1) % (fs)->lfs_nseg)
end_define

begin_comment
comment|/*  * Return the next segment to write.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|lfs_nextseg
parameter_list|(
name|fs
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
block|{
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|cont
decl_stmt|,
name|segnum
decl_stmt|,
name|sn
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_nextseg\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|segnum
operator|=
name|sn
operator|=
name|datosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_nextseg
argument_list|)
expr_stmt|;
do|do
block|{
name|cont
operator|=
operator|(
name|sn
operator|=
name|seginc
argument_list|(
name|fs
argument_list|,
name|sn
argument_list|)
operator|)
operator|!=
name|segnum
expr_stmt|;
if|if
condition|(
name|cont
condition|)
block|{
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|sn
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|cont
operator|=
name|sup
operator|->
name|su_flags
operator|&
name|SEGUSE_DIRTY
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cont
condition|)
do|;
if|if
condition|(
name|sn
operator|==
name|segnum
condition|)
name|panic
argument_list|(
literal|"lfs_nextseg: file system full"
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|sntoda
argument_list|(
name|fs
argument_list|,
name|sn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the metadata that points to the blocks listed in the FINFO  * array.  */
end_comment

begin_function
specifier|static
name|void
name|lfs_updatemeta
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|vp
parameter_list|,
name|lbp
parameter_list|,
name|bpp
parameter_list|,
name|nblocks
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|VNODE
modifier|*
name|vp
decl_stmt|;
name|daddr_t
modifier|*
name|lbp
decl_stmt|;
name|BUF
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|int
name|nblocks
decl_stmt|;
block|{
name|SEGUSE
modifier|*
name|segup
decl_stmt|;
name|BUF
modifier|*
modifier|*
name|lbpp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|INDIR
name|a
index|[
name|NIADDR
index|]
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|INODE
modifier|*
name|ip
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|,
name|iblkno
decl_stmt|;
name|int
name|db_per_fsb
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|num
decl_stmt|;
name|long
name|lbn
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_updatemeta\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nblocks
operator|==
literal|0
condition|)
return|return;
comment|/* Sort the blocks and add disk addresses */
name|shellsort
argument_list|(
name|bpp
argument_list|,
name|lbp
argument_list|,
name|nblocks
argument_list|)
expr_stmt|;
name|db_per_fsb
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|lbpp
operator|=
name|bpp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
condition|;
operator|++
name|i
operator|,
operator|++
name|lbpp
control|)
block|{
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
operator|=
name|fs
operator|->
name|lfs_offset
expr_stmt|;
name|fs
operator|->
name|lfs_offset
operator|+=
name|db_per_fsb
expr_stmt|;
block|}
for|for
control|(
name|lbpp
operator|=
name|bpp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
condition|;
operator|++
name|i
operator|,
operator|++
name|lbpp
control|)
block|{
name|lbn
operator|=
name|lbp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|lfs_bmaparray
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
operator|&
name|daddr
argument_list|,
name|a
argument_list|,
operator|&
name|num
argument_list|)
condition|)
name|panic
argument_list|(
literal|"lfs_updatemeta: lfs_bmaparray"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|META
name|printf
argument_list|(
literal|"daddr: %d num: %d\n"
argument_list|,
name|daddr
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|!=
literal|0
condition|)
block|{
name|int
name|x
decl_stmt|;
name|printf
argument_list|(
literal|"Array from bmaparray:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num
condition|;
name|x
operator|++
control|)
name|printf
argument_list|(
literal|"\tlbn %d off %d\n"
argument_list|,
name|a
index|[
name|x
index|]
operator|.
name|in_lbn
argument_list|,
name|a
index|[
name|x
index|]
operator|.
name|in_off
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Update segment usage information. */
if|if
condition|(
name|daddr
operator|!=
name|UNASSIGNED
condition|)
block|{
name|LFS_SEGENTRY
argument_list|(
name|segup
argument_list|,
name|fs
argument_list|,
name|datosn
argument_list|(
name|fs
argument_list|,
name|daddr
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|segup
operator|->
name|su_lastmod
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|segup
operator|->
name|su_nbytes
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
name|panic
argument_list|(
literal|"lfs: negative bytes (segment %d)\n"
argument_list|,
name|datosn
argument_list|(
name|fs
argument_list|,
name|daddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|segup
operator|->
name|su_nbytes
operator|-=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
name|lfs_bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* Now change whomever points to lbn. */
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
case|case
literal|0
case|:
ifdef|#
directive|ifdef
name|META
name|printf
argument_list|(
literal|"update inode for direct block %d\n"
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ip
operator|->
name|i_db
index|[
name|lbn
index|]
operator|=
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ip
operator|->
name|i_ib
index|[
name|a
index|[
literal|0
index|]
operator|.
name|in_off
index|]
operator|=
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
expr_stmt|;
break|break;
default|default:
name|ap
operator|=
operator|&
name|a
index|[
name|num
operator|-
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|META
name|printf
argument_list|(
literal|"update indirect block %d offset %d\n"
argument_list|,
name|ap
operator|->
name|in_lbn
argument_list|,
name|ap
operator|->
name|in_off
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bread
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|in_lbn
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"lfs_updatemeta: bread bno %d"
argument_list|,
name|ap
operator|->
name|in_lbn
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_daddr
index|[
name|ap
operator|->
name|in_off
index|]
operator|=
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
expr_stmt|;
name|lfs_bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_writeinode
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|INODE
modifier|*
name|ip
decl_stmt|;
block|{
name|BUF
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|next_addr
decl_stmt|;
name|int
name|nblocks
decl_stmt|,
name|ndx
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_writeinode\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate a new inode block if necessary. */
if|if
condition|(
name|sp
operator|->
name|ibp
operator|==
name|NULL
condition|)
block|{
comment|/* Allocate a new segment if necessary. */
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
operator|||
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
condition|)
block|{
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|lfs_newseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* Get next inode block. */
name|next_addr
operator|=
name|fs
operator|->
name|lfs_offset
expr_stmt|;
name|fs
operator|->
name|lfs_offset
operator|+=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ibp
operator|=
operator|*
name|sp
operator|->
name|cbpp
operator|++
operator|=
name|lfs_newbuf
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|next_addr
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
comment|/* Set remaining space counter. */
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|fs
operator|->
name|lfs_bsize
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|ndx
operator|=
name|LFS_SUMMARY_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|-
name|sp
operator|->
name|ninodes
operator|/
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|(
operator|(
name|daddr_t
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
index|[
name|ndx
index|]
operator|=
name|next_addr
expr_stmt|;
block|}
comment|/* Copy the new inode onto the inode page. 	 * XXX 	 * Do struct assignment. 	 */
name|bp
operator|=
name|sp
operator|->
name|ibp
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ip
operator|->
name|i_din
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_dino
operator|+
operator|(
name|sp
operator|->
name|ninodes
operator|%
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|DINODE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Increment inode count in segment summary block. */
operator|++
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_ninos
expr_stmt|;
comment|/* If this page is full, set flag to allocate a new page. */
if|if
condition|(
operator|++
name|sp
operator|->
name|ninodes
operator|%
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|==
literal|0
condition|)
name|sp
operator|->
name|ibp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If updating the ifile, update the super-block; otherwise, update 	 * the ifile itself.  In either case, turn off inode update flags. 	 */
if|if
condition|(
name|ip
operator|->
name|i_number
operator|==
name|LFS_IFILE_INUM
condition|)
name|fs
operator|->
name|lfs_idaddr
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
else|else
name|lfs_iset
argument_list|(
name|ip
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|ip
operator|->
name|i_atime
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flags
operator|&=
operator|~
operator|(
name|IMOD
operator||
name|IACC
operator||
name|IUPD
operator||
name|ICHG
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_writeseg
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
block|{
name|BUF
modifier|*
modifier|*
name|bpp
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|SEGSUM
modifier|*
name|segp
decl_stmt|;
name|dev_t
name|i_dev
decl_stmt|;
name|u_long
modifier|*
name|datap
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|void
modifier|*
name|pmeta
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|,
name|nblocks
decl_stmt|,
name|s
decl_stmt|,
argument_list|(
operator|*
name|strategy
argument_list|)
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_writeseg\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"nblocks %d sum bytes %d seg bytes %d\n"
argument_list|,
name|sp
operator|->
name|cbpp
operator|-
name|sp
operator|->
name|bpp
argument_list|,
name|sp
operator|->
name|sum_bytes_left
argument_list|,
name|sp
operator|->
name|seg_bytes_left
argument_list|)
expr_stmt|;
comment|/* Update superblock segment address. */
name|fs
operator|->
name|lfs_lastseg
operator|=
name|sntoda
argument_list|(
name|fs
argument_list|,
name|sp
operator|->
name|seg_number
argument_list|)
expr_stmt|;
name|nblocks
operator|=
name|sp
operator|->
name|cbpp
operator|-
name|sp
operator|->
name|bpp
expr_stmt|;
name|LFS_SEGENTRY
argument_list|(
name|sup
argument_list|,
name|fs
argument_list|,
name|sp
operator|->
name|seg_number
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sup
operator|->
name|su_nbytes
operator|+=
name|LFS_SUMMARY_SIZE
operator|+
operator|(
name|nblocks
operator|-
literal|1
operator|<<
name|fs
operator|->
name|lfs_bshift
operator|)
expr_stmt|;
name|sup
operator|->
name|su_lastmod
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|sup
operator|->
name|su_flags
operator|=
name|SEGUSE_DIRTY
expr_stmt|;
name|lfs_bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Compute checksum across data and then across summary. 	 * 	 * XXX 	 * Fix this to do it inline, instead of malloc/copy. 	 */
name|printf
argument_list|(
literal|"malloc...\n"
argument_list|)
expr_stmt|;
name|datap
operator|=
name|dp
operator|=
name|malloc
argument_list|(
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|bpp
operator|=
name|sp
operator|->
name|bpp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
operator|-
literal|1
condition|;
operator|++
name|i
operator|,
operator|++
name|bpp
control|)
operator|*
name|dp
operator|++
operator|=
operator|(
operator|*
name|bpp
operator|)
operator|->
name|b_un
operator|.
name|b_words
index|[
literal|0
index|]
expr_stmt|;
name|segp
operator|=
operator|(
name|SEGSUM
operator|*
operator|)
name|sp
operator|->
name|segsum
expr_stmt|;
name|segp
operator|->
name|ss_datasum
operator|=
name|cksum
argument_list|(
name|datap
argument_list|,
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|segp
operator|->
name|ss_sumsum
operator|=
name|cksum
argument_list|(
operator|&
name|segp
operator|->
name|ss_datasum
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|segp
operator|->
name|ss_sumsum
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|datap
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"malloc done\n"
argument_list|)
expr_stmt|;
comment|/* 	 * When we gathered the blocks for I/O we did not mark them busy or 	 * remove them from the freelist.  As we do this, turn off the B_LOCKED 	 * bit so the future brelse will put them on the LRU list, and add the 	 * B_CALL flags if we're doing a checkpoint so we can count I/O's.  LFS 	 * requires that the super blocks (on checkpoint) be written after all 	 * the segment data. 	 */
name|i_dev
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_dev
expr_stmt|;
name|strategy
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_devvp
operator|->
name|v_op
operator|->
name|vop_strategy
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|seg_flags
operator|&
name|SEGM_CKP
condition|)
block|{
name|fs
operator|->
name|lfs_iocount
operator|+=
name|nblocks
expr_stmt|;
name|flags
operator|=
name|B_BUSY
operator||
name|B_CALL
expr_stmt|;
block|}
else|else
name|flags
operator|=
name|B_BUSY
expr_stmt|;
name|printf
argument_list|(
literal|"Nblocks: %d\n"
argument_list|,
name|nblocks
argument_list|)
expr_stmt|;
for|for
control|(
name|bpp
operator|=
name|sp
operator|->
name|bpp
operator|,
name|i
operator|=
name|nblocks
init|;
name|i
operator|--
condition|;
control|)
block|{
name|bp
operator|=
operator|*
name|bpp
operator|++
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|flags
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_READ
operator||
name|B_DELWRI
operator||
name|B_LOCKED
operator|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|i_dev
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|lfs_callback
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|printf
argument_list|(
literal|"bp: %x flags: %x blkno %d lblkno %d\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_NOCACHE
operator|)
condition|)
block|{
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|bpp
operator|=
name|sp
operator|->
name|bpp
operator|,
name|i
operator|=
name|nblocks
init|;
name|i
operator|--
condition|;
control|)
call|(
name|strategy
call|)
argument_list|(
operator|*
name|bpp
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_writesuper
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
block|{
name|BUF
modifier|*
name|bp
decl_stmt|;
name|dev_t
name|i_dev
decl_stmt|;
name|int
argument_list|(
argument|*strategy
argument_list|)
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_writesuper\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"lfs_writesuper\n"
argument_list|)
expr_stmt|;
name|i_dev
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_dev
expr_stmt|;
name|strategy
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_devvp
operator|->
name|v_op
operator|->
name|vop_strategy
expr_stmt|;
comment|/* Checksum the superblock and copy it into a buffer. */
name|fs
operator|->
name|lfs_cksum
operator|=
name|cksum
argument_list|(
name|fs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lfs
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|fs
operator|->
name|lfs_cksum
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|lfs_newbuf
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
name|fs
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
argument_list|,
name|LFS_SBPAD
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|->
name|b_un
operator|.
name|b_lfs
operator|=
operator|*
name|fs
expr_stmt|;
comment|/* Write the first superblock (wait). */
name|bp
operator|->
name|b_dev
operator|=
name|i_dev
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_READ
operator||
name|B_DELWRI
operator|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
expr_stmt|;
call|(
name|strategy
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lfs_writesuper: first write returned\n"
argument_list|)
expr_stmt|;
comment|/* Write the second superblock (don't wait). */
name|bp
operator|->
name|b_blkno
operator|=
name|bp
operator|->
name|b_lblkno
operator|=
name|fs
operator|->
name|lfs_sboffs
index|[
literal|1
index|]
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_READ
operator||
name|B_DELWRI
operator|)
expr_stmt|;
call|(
name|strategy
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Logical block number match routines used when traversing the dirty block  * chain.  */
end_comment

begin_function
specifier|static
name|int
name|match_data
parameter_list|(
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|BUF
modifier|*
name|bp
decl_stmt|;
block|{
return|return
operator|(
name|bp
operator|->
name|b_lblkno
operator|>=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|match_indir
parameter_list|(
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|BUF
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|lbn
decl_stmt|;
name|lbn
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
return|return
operator|(
name|lbn
operator|<
literal|0
operator|&&
operator|(
operator|-
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|match_dindir
parameter_list|(
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|BUF
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|lbn
decl_stmt|;
name|lbn
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
return|return
operator|(
name|lbn
operator|<
literal|0
operator|&&
operator|(
operator|-
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|match_tindir
parameter_list|(
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|BUF
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|lbn
decl_stmt|;
name|lbn
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
return|return
operator|(
name|lbn
operator|<
literal|0
operator|&&
operator|(
operator|-
name|lbn
operator|-
name|NDADDR
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|==
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new buffer header.  */
end_comment

begin_function
specifier|static
name|BUF
modifier|*
name|lfs_newbuf
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|daddr
parameter_list|,
name|size
parameter_list|)
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|BUF
modifier|*
name|bp
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_newbuf\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|=
name|getnewbuf
argument_list|()
expr_stmt|;
name|bremhash
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bgetvp
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_lblkno
operator|=
name|daddr
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|daddr
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_NOCACHE
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The buffer cache callback routine.    */
end_comment

begin_function
specifier|static
name|int
comment|/* XXX should be void */
name|lfs_callback
parameter_list|(
name|bp
parameter_list|)
name|BUF
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|lfs
modifier|*
name|fs
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_callback\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|fs
operator|->
name|lfs_iocount
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"lfs_callback: zero iocount\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|fs
operator|->
name|lfs_iocount
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"io: wakeup call\n"
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|fs
operator|->
name|lfs_iocount
argument_list|)
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shellsort (diminishing increment sort) from Data Structures and  * Algorithms, Aho, Hopcraft and Ullman, 1983 Edition, page 290;  * see also Knuth Vol. 3, page 84.  The increments are selected from  * formula (8), page 95.  Roughly O(N^3/2).  */
end_comment

begin_comment
comment|/*  * This is our own private copy of shellsort because we want to sort  * two parallel arrays (the array of buffer pointers and the array of  * logical block numbers) simultaneously.  Note that we cast the array  * of logical block numbers to a unsigned in this routine so that the  * negative block numbers (meta data blocks) sort AFTER the data blocks.  */
end_comment

begin_function
specifier|static
name|void
name|shellsort
parameter_list|(
name|bp_array
parameter_list|,
name|lb_array
parameter_list|,
name|nmemb
parameter_list|)
name|BUF
modifier|*
modifier|*
name|bp_array
decl_stmt|;
name|daddr_t
modifier|*
name|lb_array
decl_stmt|;
specifier|register
name|int
name|nmemb
decl_stmt|;
block|{
specifier|static
name|int
name|__rsshell_increments
index|[]
init|=
block|{
literal|4
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
specifier|register
name|int
name|incr
decl_stmt|,
modifier|*
name|incrp
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|BUF
modifier|*
name|bp_temp
decl_stmt|;
name|u_long
name|lb_temp
decl_stmt|;
for|for
control|(
name|incrp
operator|=
name|__rsshell_increments
init|;
name|incr
operator|=
operator|*
name|incrp
operator|++
condition|;
control|)
for|for
control|(
name|t1
operator|=
name|incr
init|;
name|t1
operator|<
name|nmemb
condition|;
operator|++
name|t1
control|)
for|for
control|(
name|t2
operator|=
name|t1
operator|-
name|incr
init|;
name|t2
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|lb_array
index|[
name|t2
index|]
operator|>
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
condition|)
block|{
name|lb_temp
operator|=
name|lb_array
index|[
name|t2
index|]
expr_stmt|;
name|lb_array
index|[
name|t2
index|]
operator|=
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
expr_stmt|;
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
operator|=
name|lb_temp
expr_stmt|;
name|bp_temp
operator|=
name|bp_array
index|[
name|t2
index|]
expr_stmt|;
name|bp_array
index|[
name|t2
index|]
operator|=
name|bp_array
index|[
name|t2
operator|+
name|incr
index|]
expr_stmt|;
name|bp_array
index|[
name|t2
operator|+
name|incr
index|]
operator|=
name|bp_temp
expr_stmt|;
name|t2
operator|-=
name|incr
expr_stmt|;
block|}
else|else
break|break;
block|}
end_function

end_unit

