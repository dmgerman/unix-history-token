begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)lfs_segment.c	5.1 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"namei.h"
end_include

begin_include
include|#
directive|include
file|"resourcevar.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"specdev.h"
end_include

begin_include
include|#
directive|include
file|"fifo.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"../ufs/lockf.h"
end_include

begin_include
include|#
directive|include
file|"../ufs/quota.h"
end_include

begin_include
include|#
directive|include
file|"../ufs/inode.h"
end_include

begin_include
include|#
directive|include
file|"../ufs/dir.h"
end_include

begin_include
include|#
directive|include
file|"../ufs/ufsmount.h"
end_include

begin_include
include|#
directive|include
file|"lfs.h"
end_include

begin_include
include|#
directive|include
file|"lfs_extern.h"
end_include

begin_comment
comment|/* Need to write the inodes out. The indirect buffers need to be marked dirty What about sync?  How do you wait on the last I/O? Need to keep vnode v_numoutput up to date for pending writes. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lfs_biocallback
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_endsum
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|SEGMENT
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BUF
modifier|*
name|lfs_newbuf
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|daddr_t
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SEGMENT
modifier|*
name|lfs_newseg
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_newsum
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|SEGMENT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|daddr_t
name|lfs_nextseg
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lfs_updatemeta
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|INODE
operator|*
operator|,
name|FINFO
operator|*
operator|,
name|BUF
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SEGMENT
modifier|*
name|lfs_writefile
name|__P
argument_list|(
operator|(
name|SEGMENT
operator|*
operator|,
name|LFS
operator|*
operator|,
name|VNODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_writemeta
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lfs_writeseg
name|__P
argument_list|(
operator|(
name|LFS
operator|*
operator|,
name|SEGMENT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|shellsort
name|__P
argument_list|(
operator|(
name|BUF
operator|*
operator|*
operator|,
name|u_long
operator|*
operator|,
specifier|register
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX -- when we add fragments in here, we will need to allocate a larger  * buffer pointer array (sp->bpp).  */
end_comment

begin_function
name|int
name|lfs_segwrite
parameter_list|(
name|mp
parameter_list|)
name|MOUNT
modifier|*
name|mp
decl_stmt|;
block|{
name|FINFO
modifier|*
name|fip
decl_stmt|;
comment|/* current file info structure */
name|INODE
modifier|*
name|ip
decl_stmt|;
name|LFS
modifier|*
name|fs
decl_stmt|;
name|VNODE
modifier|*
name|vp
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_segwrite: %s %s\n"
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_lfs
expr_stmt|;
name|sp
operator|=
name|lfs_newseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|loop
label|:
for|for
control|(
name|vp
operator|=
name|mp
operator|->
name|mnt_mounth
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|v_mountf
control|)
block|{
comment|/* 		 * If the vnode that we are about to sync is no longer 		 * associated with this mount point, start over. 		 */
name|printf
argument_list|(
literal|"lfs_segwrite: processing inum %d\n"
argument_list|,
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
goto|goto
name|loop
goto|;
if|if
condition|(
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
condition|)
continue|continue;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_number
operator|==
name|LFS_IFILE_INUM
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_flag
operator|&
operator|(
name|IMOD
operator||
name|IACC
operator||
name|IUPD
operator||
name|ICHG
operator|)
operator|)
operator|==
literal|0
operator|&&
name|vp
operator|->
name|v_dirtyblkhd
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|vget
argument_list|(
name|vp
argument_list|)
condition|)
goto|goto
name|loop
goto|;
name|sp
operator|=
name|lfs_writefile
argument_list|(
name|sp
argument_list|,
name|fs
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* Need to take care of inode now */
name|printf
argument_list|(
literal|"lfs_segwrite: need to add dinode %d to seg\n"
argument_list|,
name|ip
operator|->
name|i_din
operator|.
name|di_inum
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Force stale file system control information to be flushed. 	 */
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/*	vflushbuf(ump->um_devvp, waitfor == MNT_WAIT ? B_SYNC : 0); */
name|printf
argument_list|(
literal|"lfs_segwrite: returning from segwrite\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lfs_biocallback
parameter_list|(
name|bp
parameter_list|)
name|BUF
modifier|*
name|bp
decl_stmt|;
block|{
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|,
modifier|*
name|next_sp
decl_stmt|;
name|UFSMOUNT
modifier|*
name|ump
decl_stmt|;
name|VNODE
modifier|*
name|devvp
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_lfs
expr_stmt|;
name|devvp
operator|=
name|ump
operator|->
name|um_devvp
expr_stmt|;
comment|/* XXX splbio(); */
name|printf
argument_list|(
literal|"lfs_biocallback: iocount: %d\n"
argument_list|,
name|fs
operator|->
name|lfs_iocount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|fs
operator|->
name|lfs_iocount
condition|)
block|{
comment|/* Fire off summary writes */
for|for
control|(
name|sp
operator|=
name|fs
operator|->
name|lfs_seglist
init|;
name|sp
condition|;
name|sp
operator|=
name|next_sp
control|)
block|{
name|next_sp
operator|=
name|sp
operator|->
name|nextp
expr_stmt|;
operator|(
operator|*
operator|(
name|devvp
operator|->
name|v_op
operator|->
name|vop_strategy
operator|)
operator|)
operator|(
operator|*
operator|(
name|sp
operator|->
name|cbpp
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"free: segsum %x bpp %x sp %x\n"
argument_list|,
name|sp
operator|->
name|segsum
argument_list|,
name|sp
operator|->
name|bpp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
operator|->
name|segsum
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
operator|->
name|bpp
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
argument_list|,
name|M_SEGMENT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_endsum
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|,
name|calc_next
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|int
name|calc_next
decl_stmt|;
comment|/* if 1, calculate next, else -1 */
block|{
name|BUF
modifier|*
name|bp
decl_stmt|;
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
name|daddr_t
name|next_addr
decl_stmt|;
name|int
name|npages
decl_stmt|,
name|nseg_pages
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_endsum\n"
argument_list|)
expr_stmt|;
name|ssp
operator|=
name|sp
operator|->
name|segsum
expr_stmt|;
if|if
condition|(
operator|!
name|calc_next
condition|)
name|ssp
operator|->
name|ss_nextsum
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|nseg_pages
operator|=
name|sp
operator|->
name|sum_num
operator|/
operator|(
name|fs
operator|->
name|lfs_bsize
operator|/
name|LFS_SUMMARY_SIZE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|sum_num
operator|%
operator|(
name|fs
operator|->
name|lfs_bsize
operator|/
name|LFS_SUMMARY_SIZE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * May need to change the nextsum field on the previous 		 * summary header in which case we need to recompute the 		 * checksum as well. 		 */
name|npages
operator|=
name|nseg_pages
operator|+
operator|(
name|sp
operator|->
name|ninodes
operator|+
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|INOPB
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|next_addr
operator|=
name|fs
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
operator|+
operator|(
name|sp
operator|->
name|seg_number
operator|+
literal|1
operator|)
operator|*
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_ssize
argument_list|)
operator|-
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|npages
argument_list|)
operator|-
name|LFS_SUMMARY_SIZE
operator|/
name|DEV_BSIZE
expr_stmt|;
if|if
condition|(
name|calc_next
condition|)
name|ssp
operator|->
name|ss_nextsum
operator|=
name|next_addr
expr_stmt|;
name|ssp
operator|->
name|ss_cksum
operator|=
name|cksum
argument_list|(
operator|&
name|ssp
operator|->
name|ss_cksum
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|ssp
operator|->
name|ss_cksum
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|lfs_newbuf
argument_list|(
name|fs
argument_list|,
name|sp
operator|->
name|sum_addr
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sp
operator|->
name|segsum
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_words
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
expr_stmt|;
if|if
condition|(
name|nseg_pages
operator|!=
literal|1
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_CALL
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|lfs_biocallback
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|bpp
index|[
name|fs
operator|->
name|lfs_ssize
operator|-
name|npages
index|]
operator|=
name|bp
expr_stmt|;
name|sp
operator|->
name|segsum
operator|=
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|+
name|fs
operator|->
name|lfs_bsize
operator|-
name|LFS_SUMMARY_SIZE
operator|)
expr_stmt|;
name|sp
operator|->
name|sum_addr
operator|=
name|next_addr
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|sum_addr
operator|-=
name|LFS_SUMMARY_SIZE
operator|/
name|DEV_BSIZE
expr_stmt|;
name|ssp
operator|->
name|ss_nextsum
operator|=
name|sp
operator|->
name|sum_addr
expr_stmt|;
comment|/* Calculate cksum on previous segment summary */
name|ssp
operator|->
name|ss_cksum
operator|=
name|cksum
argument_list|(
operator|&
name|ssp
operator|->
name|ss_cksum
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|ssp
operator|->
name|ss_cksum
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|segsum
operator|-=
name|LFS_SUMMARY_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|BUF
modifier|*
name|lfs_newbuf
parameter_list|(
name|fs
parameter_list|,
name|daddr
parameter_list|,
name|size
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|BUF
modifier|*
name|bp
decl_stmt|;
name|VNODE
modifier|*
name|devvp
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_newbuf\n"
argument_list|)
expr_stmt|;
name|bp
operator|=
name|getnewbuf
argument_list|()
expr_stmt|;
name|bremhash
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * Need a devvp, but this isn't a particularly clean way to get one. 	 */
name|devvp
operator|=
name|VTOI
argument_list|(
name|fs
operator|->
name|lfs_ivnode
argument_list|)
operator|->
name|i_devvp
expr_stmt|;
name|bgetvp
argument_list|(
name|devvp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_lblkno
operator|=
name|daddr
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|daddr
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|binshash
argument_list|(
name|bp
argument_list|,
name|BUFHASH
argument_list|(
name|devvp
argument_list|,
name|daddr
argument_list|)
argument_list|)
expr_stmt|;
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a new segment  */
end_comment

begin_function
specifier|static
name|SEGMENT
modifier|*
name|lfs_newseg
parameter_list|(
name|fs
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
block|{
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_newseg\n"
argument_list|)
expr_stmt|;
comment|/* Get buffer space to write out a segment */
name|sp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SEGMENT
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|cbpp
operator|=
name|sp
operator|->
name|bpp
operator|=
name|malloc
argument_list|(
name|fs
operator|->
name|lfs_ssize
operator|*
sizeof|sizeof
argument_list|(
name|BUF
operator|*
argument_list|)
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|nextp
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|=
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|=
operator|(
name|fs
operator|->
name|lfs_segmask
operator|+
literal|1
operator|)
operator|-
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|sp
operator|->
name|saddr
operator|=
name|fs
operator|->
name|lfs_nextseg
expr_stmt|;
name|sp
operator|->
name|sum_addr
operator|=
name|sp
operator|->
name|saddr
operator|+
name|sp
operator|->
name|seg_bytes_left
operator|/
name|DEV_BSIZE
expr_stmt|;
name|sp
operator|->
name|ninodes
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|sum_num
operator|=
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|seg_number
operator|=
operator|(
name|sp
operator|->
name|saddr
operator|-
name|fs
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
operator|)
operator|/
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_ssize
argument_list|)
expr_stmt|;
comment|/* initialize segment summary info */
name|lfs_newsum
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sup
operator|=
name|fs
operator|->
name|lfs_segtab
operator|+
name|sp
operator|->
name|seg_number
expr_stmt|;
if|if
condition|(
name|sup
operator|->
name|su_nbytes
operator|!=
literal|0
condition|)
block|{
comment|/* This is a segment containing a super block */
name|FINFO
modifier|*
name|fip
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|,
modifier|*
name|lbnp
decl_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|fip
operator|->
name|fi_nblocks
operator|=
name|LFS_SBPAD
operator|>>
name|fs
operator|->
name|lfs_bshift
expr_stmt|;
name|fip
operator|->
name|fi_version
operator|=
literal|1
expr_stmt|;
name|fip
operator|->
name|fi_ino
operator|=
name|LFS_UNUSED_INUM
expr_stmt|;
name|sp
operator|->
name|saddr
operator|+=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fip
operator|->
name|fi_nblocks
argument_list|)
expr_stmt|;
name|lbnp
operator|=
name|fip
operator|->
name|fi_blocks
expr_stmt|;
for|for
control|(
name|lbn
operator|=
literal|0
init|;
name|lbn
operator|<
name|fip
operator|->
name|fi_nblocks
condition|;
name|lbn
operator|++
control|)
operator|*
name|lbnp
operator|++
operator|=
name|lbn
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|sup
operator|->
name|su_nbytes
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|+
operator|(
name|fip
operator|->
name|fi_nblocks
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|sp
operator|->
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
name|lbnp
expr_stmt|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_newsum
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
block|{
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
name|void
modifier|*
name|sum
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_newsum\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sum_num
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sum_num
operator|==
literal|0
condition|)
block|{
name|sum
operator|=
name|malloc
argument_list|(
name|fs
operator|->
name|lfs_bsize
argument_list|,
name|M_SEGMENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|segsum
operator|=
name|sum
operator|+
name|fs
operator|->
name|lfs_bsize
operator|-
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|ssp
operator|=
name|sp
operator|->
name|segsum
expr_stmt|;
name|ssp
operator|->
name|ss_next
operator|=
name|fs
operator|->
name|lfs_nextseg
operator|=
name|lfs_nextseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|ssp
operator|->
name|ss_prev
operator|=
name|fs
operator|->
name|lfs_lastseg
expr_stmt|;
block|}
else|else
block|{
name|lfs_endsum
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ssp
operator|=
name|sp
operator|->
name|segsum
expr_stmt|;
name|ssp
operator|->
name|ss_next
operator|=
name|ssp
operator|->
name|ss_next
expr_stmt|;
name|ssp
operator|->
name|ss_prev
operator|=
name|ssp
operator|->
name|ss_prev
expr_stmt|;
block|}
comment|/* Initialize segment summary info. */
name|sp
operator|->
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|+
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
operator|)
expr_stmt|;
name|ssp
operator|->
name|ss_nextsum
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|ssp
operator|->
name|ss_create
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|ssp
operator|->
name|ss_nfinfo
operator|=
literal|0
expr_stmt|;
name|ssp
operator|->
name|ss_ninos
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|LFS_SUMMARY_SIZE
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|seginc
parameter_list|(
name|fs
parameter_list|,
name|sn
parameter_list|)
value|((sn + 1) % fs->lfs_nseg)
end_define

begin_function
specifier|static
name|daddr_t
name|lfs_nextseg
parameter_list|(
name|fs
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
block|{
name|int
name|segnum
decl_stmt|,
name|sn
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_nextseg\n"
argument_list|)
expr_stmt|;
name|segnum
operator|=
name|satosn
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_nextseg
argument_list|)
expr_stmt|;
for|for
control|(
name|sn
operator|=
name|seginc
argument_list|(
name|fs
argument_list|,
name|sn
argument_list|)
init|;
name|sn
operator|!=
name|segnum
condition|;
name|sn
operator|=
name|seginc
argument_list|(
name|fs
argument_list|,
name|sn
argument_list|)
control|)
block|{
name|sup
operator|=
operator|&
name|fs
operator|->
name|lfs_segtab
index|[
name|sn
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sup
operator|->
name|su_flags
operator|&
name|SEGUSE_DIRTY
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|sn
operator|==
name|segnum
condition|)
name|panic
argument_list|(
literal|"lfs_nextseg: file system full"
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|sntosa
argument_list|(
name|fs
argument_list|,
name|sn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the metadata that points to the blocks listed in the FIP  * array.  */
end_comment

begin_expr_stmt
specifier|static
name|lfs_updatemeta
argument_list|(
argument|fs
argument_list|,
argument|ip
argument_list|,
argument|fip
argument_list|,
argument|bpp
argument_list|)
name|LFS
operator|*
name|fs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|INODE
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FINFO
modifier|*
name|fip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BUF
modifier|*
modifier|*
name|bpp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SEGUSE
modifier|*
name|segup
decl_stmt|;
name|BUF
modifier|*
modifier|*
name|lbpp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|da
decl_stmt|,
name|iblkno
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|oldsegnum
decl_stmt|;
name|long
name|lbn
decl_stmt|,
modifier|*
name|lbp
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_updatemeta\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|lbpp
operator|=
name|bpp
operator|,
name|lbp
operator|=
name|fip
operator|->
name|fi_blocks
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fip
operator|->
name|fi_nblocks
condition|;
name|i
operator|++
operator|,
name|lbp
operator|++
operator|,
name|bp
operator|++
control|)
block|{
name|lbn
operator|=
operator|*
name|lbp
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|lfs_bmap
argument_list|(
name|ip
argument_list|,
name|lbn
argument_list|,
operator|&
name|da
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|da
condition|)
block|{
name|oldsegnum
operator|=
operator|(
name|da
operator|-
name|fs
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
operator|)
operator|/
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|lfs_ssize
argument_list|)
expr_stmt|;
name|segup
operator|=
name|fs
operator|->
name|lfs_segtab
operator|+
name|oldsegnum
expr_stmt|;
name|segup
operator|->
name|su_lastmod
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|(
name|segup
operator|->
name|su_nbytes
operator|-=
name|fs
operator|->
name|lfs_bsize
operator|)
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"lfs_updatemeta: negative bytes %s %d\n"
argument_list|,
literal|"in segment"
argument_list|,
name|oldsegnum
argument_list|)
expr_stmt|;
block|}
comment|/* Now change whoever points to lbn */
if|if
condition|(
name|lbn
operator|<
name|NDADDR
condition|)
name|ip
operator|->
name|i_din
operator|.
name|di_db
index|[
name|lbn
index|]
operator|=
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lbn
operator|-=
name|NDADDR
operator|)
operator|<
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"lfs_updatemeta: changing indirect block %d\n"
argument_list|,
name|S_INDIR
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
name|S_INDIR
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bp
operator|->
name|b_un
operator|.
name|b_daddr
index|[
name|lbn
index|]
operator|=
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lbn
operator|=
operator|(
name|lbn
operator|-
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|)
operator|/
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|)
operator|<
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|iblkno
operator|=
operator|-
operator|(
name|lbn
operator|+
name|NIADDR
operator|+
literal|1
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"lfs_updatemeta: changing indirect block %d\n"
argument_list|,
name|iblkno
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
name|iblkno
argument_list|,
name|fs
operator|->
name|lfs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bp
operator|->
name|b_un
operator|.
name|b_daddr
index|[
name|lbn
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
index|]
operator|=
operator|(
operator|*
name|lbpp
operator|)
operator|->
name|b_blkno
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EFBIG
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Returns 0 if the entire file fit into the current segment and  * summary region, 1 if not.  * XXX -- I think we need to figure out what to do if we write  * the segment and find more dirty blocks when we're done.  */
end_comment

begin_function
specifier|static
name|SEGMENT
modifier|*
name|lfs_writefile
parameter_list|(
name|sp
parameter_list|,
name|fs
parameter_list|,
name|vp
parameter_list|)
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
name|LFS
modifier|*
name|fs
decl_stmt|;
name|VNODE
modifier|*
name|vp
decl_stmt|;
block|{
specifier|register
name|BUF
modifier|*
name|bp
decl_stmt|;
name|BUF
modifier|*
modifier|*
name|bpp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
name|FINFO
modifier|*
name|fip
decl_stmt|;
name|INODE
modifier|*
name|ip
decl_stmt|;
name|int
name|db_per_fsb
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|int
name|ret_val
decl_stmt|,
name|s
decl_stmt|;
name|long
modifier|*
name|lbp
decl_stmt|;
comment|/* initialize the FINFO structure */
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lfs_writefile: node %d\n"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|loop
label|:
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|fip
operator|->
name|fi_nblocks
operator|=
literal|0
expr_stmt|;
name|fip
operator|->
name|fi_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|fip
operator|->
name|fi_version
operator|=
name|lfs_getversion
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|lbp
operator|=
name|fip
operator|->
name|fi_blocks
expr_stmt|;
name|bpp
operator|=
name|sp
operator|->
name|cbpp
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|vp
operator|->
name|v_dirtyblkhd
init|;
name|bp
condition|;
name|bp
operator|=
name|nbp
control|)
block|{
name|nbp
operator|=
name|bp
operator|->
name|b_blockf
expr_stmt|;
name|printf
argument_list|(
literal|"lfs_writefile: disk block num %d flags %x\n"
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"lfs_write: not dirty"
argument_list|)
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
operator|(
name|B_BUSY
operator||
name|B_CALL
operator|)
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|lfs_biocallback
expr_stmt|;
comment|/* UFS does the bawrites and bwrites here; we don't */
operator|*
name|lbp
operator|++
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
comment|/* UPDATE META HERE */
operator|*
name|sp
operator|->
name|cbpp
operator|++
operator|=
name|bp
expr_stmt|;
name|fip
operator|->
name|fi_nblocks
operator|++
expr_stmt|;
name|sp
operator|->
name|sum_bytes_left
operator|-=
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|sp
operator|->
name|seg_bytes_left
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|||
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
block|{
comment|/* 			 * We are about to allocate a new summary block 			 * and possibly a new segment.  So, we need to 			 * sort the blocks we've done so far, and assign 			 * the disk addresses, so we can start a new block 			 * correctly.  We may be doing I/O so we need to 			 * release the s lock before doing anything. 			 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|lfs_updatemeta
argument_list|(
name|fs
argument_list|,
name|ip
argument_list|,
name|fip
argument_list|,
name|bpp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"lfs_writefile: error from lfs_updatemeta\n"
argument_list|)
expr_stmt|;
comment|/* Put this file in the segment summary */
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|seg_bytes_left
operator|<
name|fs
operator|->
name|lfs_bsize
condition|)
block|{
name|lfs_writeseg
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|lfs_newseg
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|sum_bytes_left
operator|<
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
condition|)
name|lfs_newsum
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|fip
operator|=
name|sp
operator|->
name|fip
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|db_per_fsb
operator|=
literal|1
operator|<<
name|fs
operator|->
name|lfs_fsbtodb
expr_stmt|;
name|shellsort
argument_list|(
name|bpp
argument_list|,
operator|(
name|u_long
operator|*
operator|)
name|fip
operator|->
name|fi_blocks
argument_list|,
name|fip
operator|->
name|fi_nblocks
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
operator|*
name|bpp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fip
operator|->
name|fi_nblocks
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
block|{
name|bp
operator|->
name|b_blkno
operator|=
name|sp
operator|->
name|saddr
expr_stmt|;
name|sp
operator|->
name|saddr
operator|+=
name|db_per_fsb
expr_stmt|;
comment|/*  		 * Update the meta data now for this file.  If we've filled 		 * a segment, then we'll have to wait until the next segment 		 * to write out the updated metadata. 		 */
name|lfs_writemeta
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"lfs_writefile: adding %d blocks to segment\n"
argument_list|,
name|fip
operator|->
name|fi_nblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|fip
operator|->
name|fi_nblocks
condition|)
block|{
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
operator|(
name|sp
operator|->
name|segsum
operator|)
operator|)
operator|->
name|ss_nfinfo
operator|++
expr_stmt|;
name|sp
operator|->
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
name|fip
operator|+
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
operator|(
name|fip
operator|->
name|fi_nblocks
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_writemeta
parameter_list|()
block|{
name|printf
argument_list|(
literal|"lfs_writemeta (STUB)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lfs_writeseg
parameter_list|(
name|fs
parameter_list|,
name|sp
parameter_list|)
name|LFS
modifier|*
name|fs
decl_stmt|;
name|SEGMENT
modifier|*
name|sp
decl_stmt|;
block|{
name|BUF
modifier|*
modifier|*
name|bpp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|VNODE
modifier|*
name|devvp
decl_stmt|;
name|int
name|nblocks
decl_stmt|,
name|nbuffers
decl_stmt|,
name|ninode_blocks
decl_stmt|,
name|nsegsums
decl_stmt|,
name|nsum_pb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|metaoff
decl_stmt|,
name|nmeta
decl_stmt|;
name|printf
argument_list|(
literal|"lfs_writeseg\n"
argument_list|)
expr_stmt|;
name|ssp
operator|=
name|sp
operator|->
name|segsum
expr_stmt|;
name|nsum_pb
operator|=
name|fs
operator|->
name|lfs_bsize
operator|/
name|LFS_SUMMARY_SIZE
expr_stmt|;
comment|/* 	 * This is a hack because we're currently allocating summary segments 	 * in full blocks.  It will go away when we do fragments, when we'll 	 * allocate fragment sized summary blocks. 	 */
do|do
block|{
name|sp
operator|->
name|sum_num
operator|++
expr_stmt|;
name|lfs_endsum
argument_list|(
name|fs
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|->
name|sum_num
operator|%
name|nsum_pb
condition|)
do|;
name|nbuffers
operator|=
name|sp
operator|->
name|cbpp
operator|-
name|sp
operator|->
name|bpp
expr_stmt|;
name|nsegsums
operator|=
operator|(
name|sp
operator|->
name|sum_num
operator|+
name|nsum_pb
operator|-
literal|1
operator|)
operator|/
name|nsum_pb
expr_stmt|;
name|ninode_blocks
operator|=
operator|(
name|sp
operator|->
name|ninodes
operator|+
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|INOPB
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* Do checksum for last segment summary */
name|ssp
operator|->
name|ss_cksum
operator|=
name|cksum
argument_list|(
operator|&
name|ssp
operator|->
name|ss_cksum
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|ssp
operator|->
name|ss_cksum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finish off any inodes */
comment|/* 	 * Copy inode and summary block buffer pointers down so they are 	 * contiguous with the page buffer pointers 	 */
name|nmeta
operator|=
literal|1
operator|+
name|ninode_blocks
operator|+
name|nsegsums
expr_stmt|;
name|metaoff
operator|=
name|fs
operator|->
name|lfs_ssize
operator|-
name|nmeta
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|bpp
operator|+
name|metaoff
operator|!=
name|sp
operator|->
name|cbpp
condition|)
name|bcopy
argument_list|(
name|sp
operator|->
name|bpp
operator|+
name|metaoff
argument_list|,
name|sp
operator|->
name|cbpp
argument_list|,
sizeof|sizeof
argument_list|(
name|BUF
operator|*
argument_list|)
operator|*
name|nmeta
argument_list|)
expr_stmt|;
name|nblocks
operator|=
name|nbuffers
operator|+
name|ninode_blocks
operator|+
name|nsegsums
expr_stmt|;
name|sup
operator|=
name|fs
operator|->
name|lfs_segtab
operator|+
name|sp
operator|->
name|seg_number
expr_stmt|;
name|sup
operator|->
name|su_nbytes
operator|=
name|nblocks
operator|<<
name|fs
operator|->
name|lfs_bshift
expr_stmt|;
name|sup
operator|->
name|su_lastmod
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|sup
operator|->
name|su_flags
operator|=
name|SEGUSE_DIRTY
expr_stmt|;
comment|/* 	 * Since we need to guarantee that our last buffer gets written last, 	 * we issue the writes in two sets.  The first n-1 buffers first, and 	 * then, after they've completed, the last 1 buffer.  Only when that 	 * final write completes is the segment actually written. 	 */
name|devvp
operator|=
name|VFSTOUFS
argument_list|(
name|fs
operator|->
name|lfs_ivnode
operator|->
name|v_mount
argument_list|)
operator|->
name|um_devvp
expr_stmt|;
comment|/* MIS -- THIS COULD BE BAD IF WE GOT INTERRUPTED IN THE MIDDLE OF THIS */
name|fs
operator|->
name|lfs_iocount
operator|+=
name|nblocks
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|nextp
operator|=
name|fs
operator|->
name|lfs_seglist
expr_stmt|;
name|fs
operator|->
name|lfs_seglist
operator|=
name|sp
expr_stmt|;
for|for
control|(
name|bpp
operator|=
name|sp
operator|->
name|bpp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|nblocks
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
operator|*
name|bpp
expr_stmt|;
name|printf
argument_list|(
literal|"lfs_writeseg: buffer: ino %d lbn %d flags %lx\n"
argument_list|,
name|VTOI
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
operator|->
name|i_number
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|devvp
operator|->
name|v_op
operator|->
name|vop_strategy
operator|)
operator|)
operator|(
operator|*
name|bpp
operator|++
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Shellsort (diminishing increment sort) from Data Structures and  * Algorithms, Aho, Hopcraft and Ullman, 1983 Edition, page 290;  * see also Knuth Vol. 3, page 84.  The increments are selected from  * formula (8), page 95.  Roughly O(N^3/2).  */
end_comment

begin_comment
comment|/*  * This is our own private copy of shellsort because we want to sort  * two parallel arrays (the array of buffer pointers and the array of  * logical block numbers) simultaneously.  Note that we cast the array  * of logical block numbers to a unsigned in this routine so that the  * negative block numbers (meta data blocks) sort AFTER the data blocks.  */
end_comment

begin_function
specifier|static
name|void
name|shellsort
parameter_list|(
name|bp_array
parameter_list|,
name|lb_array
parameter_list|,
name|nmemb
parameter_list|)
name|BUF
modifier|*
modifier|*
name|bp_array
decl_stmt|;
name|u_long
modifier|*
name|lb_array
decl_stmt|;
specifier|register
name|int
name|nmemb
decl_stmt|;
block|{
specifier|static
name|int
name|__rsshell_increments
index|[]
init|=
block|{
literal|4
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
specifier|register
name|int
name|incr
decl_stmt|,
modifier|*
name|incrp
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|BUF
modifier|*
name|bp_temp
decl_stmt|;
name|u_long
name|lb_temp
decl_stmt|;
for|for
control|(
name|incrp
operator|=
name|__rsshell_increments
init|;
name|incr
operator|=
operator|*
name|incrp
operator|++
condition|;
control|)
for|for
control|(
name|t1
operator|=
name|incr
init|;
name|t1
operator|<
name|nmemb
condition|;
operator|++
name|t1
control|)
for|for
control|(
name|t2
operator|=
name|t1
operator|-
name|incr
init|;
name|t2
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|lb_array
index|[
name|t2
index|]
operator|>
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
condition|)
block|{
name|lb_temp
operator|=
name|lb_array
index|[
name|t2
index|]
expr_stmt|;
name|lb_array
index|[
name|t2
index|]
operator|=
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
expr_stmt|;
name|lb_array
index|[
name|t2
operator|+
name|incr
index|]
operator|=
name|lb_temp
expr_stmt|;
name|bp_temp
operator|=
name|bp_array
index|[
name|t2
index|]
expr_stmt|;
name|bp_array
index|[
name|t2
index|]
operator|=
name|bp_array
index|[
name|t2
operator|+
name|incr
index|]
expr_stmt|;
name|bp_array
index|[
name|t2
operator|+
name|incr
index|]
operator|=
name|bp_temp
expr_stmt|;
name|t2
operator|-=
name|incr
expr_stmt|;
block|}
else|else
break|break;
block|}
end_function

end_unit

