begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)vfs_lookup.c	7.5 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"inode.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_function_decl
name|struct
name|buf
modifier|*
name|blkatoff
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|dirchk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Structures associated with name cacheing.  */
end_comment

begin_define
define|#
directive|define
name|NCHHASH
value|32
end_define

begin_comment
comment|/* size of hash table */
end_comment

begin_if
if|#
directive|if
operator|(
operator|(
name|NCHHASH
operator|)
operator|&
operator|(
operator|(
name|NCHHASH
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
end_if

begin_define
define|#
directive|define
name|NHASH
parameter_list|(
name|h
parameter_list|,
name|i
parameter_list|,
name|d
parameter_list|)
value|((unsigned)((h) + (i) + 13 * (int)(d)) % (NCHHASH))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NHASH
parameter_list|(
name|h
parameter_list|,
name|i
parameter_list|,
name|d
parameter_list|)
value|((unsigned)((h) + (i) + 13 * (int)(d))& ((NCHHASH)-1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_union
union|union
name|nchash
block|{
name|union
name|nchash
modifier|*
name|nch_head
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|namecache
modifier|*
name|nch_chain
index|[
literal|2
index|]
decl_stmt|;
block|}
name|nchash
index|[
name|NCHHASH
index|]
union|;
end_union

begin_define
define|#
directive|define
name|nch_forw
value|nch_chain[0]
end_define

begin_define
define|#
directive|define
name|nch_back
value|nch_chain[1]
end_define

begin_decl_stmt
name|struct
name|namecache
modifier|*
name|nchhead
decl_stmt|,
modifier|*
modifier|*
name|nchtail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LRU chain pointers */
end_comment

begin_decl_stmt
name|struct
name|nchstats
name|nchstats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cache effectiveness statistics */
end_comment

begin_comment
comment|/*  * Convert a pathname into a pointer to a locked inode.  * This is a very central and rather complicated routine.  * If the file system is not maintained in a strict tree hierarchy,  * this can result in a deadlock situation (see comments in code below).  *  * The flag argument is LOOKUP, CREATE, or DELETE depending on whether  * the name is to be looked up, created, or deleted. When CREATE or  * DELETE is specified, information usable in creating or deleteing a  * directory entry is also calculated. If flag has LOCKPARENT or'ed  * into it and the target of the pathname exists, namei returns both  * the target and its parent directory locked. When creating and  * LOCKPARENT is specified, the target may not be ".".  When deleting  * and LOCKPARENT is specified, the target may be ".", but the caller  * must check to insure it does an irele and iput instead of two iputs.  *  * The FOLLOW flag is set when symbolic links are to be followed  * when they occur at the end of the name translation process.  * Symbolic links are always followed for all other pathname  * components other than the last.  *  * The segflg defines whether the name is to be copied from user  * space or kernel space.  *  * Name caching works as follows:  *  * Names found by directory scans are retained in a cache  * for future reference.  It is managed LRU, so frequently  * used names will hang around.  Cache is indexed by hash value  * obtained from (ino,dev,name) where ino& dev refer to the  * directory containing name.  *  * For simplicity (and economy of storage), names longer than  * a maximum length of NCHNAMLEN are not cached; they occur  * infrequently in any case, and are almost never of interest.  *  * Upon reaching the last segment of a path, if the reference  * is for DELETE, or NOCACHE is set (rewrite), and the  * name is located in the cache, it will be dropped.  *  * Overall outline of namei:  *  *	copy in name  *	get starting directory  * dirloop:  *	check accessibility of directory  * dirloop2:  *	copy next component of name to ndp->ni_dent  *	handle degenerate case where name is null string  *	look for name in cache, if found, then if at end of path  *	  and deleting or creating, drop it, else to haveino  *	search for name in directory, to found or notfound  * notfound:  *	if creating, return locked directory, leaving info on avail. slots  *	else return error  * found:  *	if at end of path and deleting, return information to allow delete  *	if at end of path and rewriting (CREATE and LOCKPARENT), lock target  *	  inode and return info to allow rewrite  *	if .. and on mounted filesys, look in mount table for parent  *	if not at end, add name to cache; if at end and neither creating  *	  nor deleting, add name to cache  * haveino:  *	if symbolic link, massage name in buffer and continue at dirloop  *	if more components of name, do next level at dirloop  *	return the answer as locked inode  *  * NOTE: (LOOKUP | LOCKPARENT) currently returns the parent inode,  *	 but unlocked.  */
end_comment

begin_function
name|struct
name|inode
modifier|*
name|namei
parameter_list|(
name|ndp
parameter_list|)
specifier|register
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* pointer into pathname argument */
comment|/* these variables refer to things which must be freed or unlocked */
specifier|register
name|struct
name|inode
modifier|*
name|dp
init|=
literal|0
decl_stmt|;
comment|/* the directory we are searching */
specifier|register
name|struct
name|namecache
modifier|*
name|ncp
decl_stmt|;
comment|/* cache slot for entry */
specifier|register
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
comment|/* file system that directory is in */
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
literal|0
decl_stmt|;
comment|/* a buffer of directory entries */
specifier|register
name|struct
name|direct
modifier|*
name|ep
decl_stmt|;
comment|/* the current directory entry */
name|int
name|entryoffsetinblock
decl_stmt|;
comment|/* offset of ep in bp's buffer */
specifier|register
name|caddr_t
name|nbp
decl_stmt|;
comment|/* buffer storing path name argument */
comment|/* these variables hold information about the search for a slot */
enum|enum
block|{
name|NONE
block|,
name|COMPACT
block|,
name|FOUND
block|}
name|slotstatus
enum|;
name|int
name|slotoffset
init|=
operator|-
literal|1
decl_stmt|;
comment|/* offset of area with free space */
name|int
name|slotsize
decl_stmt|;
comment|/* size of area at slotoffset */
name|int
name|slotfreespace
decl_stmt|;
comment|/* amount of space free in slot */
name|int
name|slotneeded
decl_stmt|;
comment|/* size of the entry we're seeking */
comment|/* */
name|int
name|numdirpasses
decl_stmt|;
comment|/* strategy for directory search */
name|int
name|endsearch
decl_stmt|;
comment|/* offset to end directory search */
name|int
name|prevoff
decl_stmt|;
comment|/* ndp->ni_offset of previous entry */
name|int
name|nlink
init|=
literal|0
decl_stmt|;
comment|/* number of symbolic links taken */
name|struct
name|inode
modifier|*
name|pdp
decl_stmt|;
comment|/* saved dp during symlink work */
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|int
name|lockparent
decl_stmt|;
name|int
name|docache
decl_stmt|;
comment|/* == 0 do not cache last component */
name|int
name|makeentry
decl_stmt|;
comment|/* != 0 if name to be added to cache */
name|unsigned
name|hash
decl_stmt|;
comment|/* value of name hash for entry */
name|union
name|nchash
modifier|*
name|nhp
decl_stmt|;
comment|/* cache chain head for entry */
name|int
name|isdotdot
decl_stmt|;
comment|/* != 0 if current name is ".." */
name|int
name|flag
decl_stmt|;
comment|/* op ie, LOOKUP, CREATE, or DELETE */
name|off_t
name|enduseful
decl_stmt|;
comment|/* pointer past last used dir slot */
name|lockparent
operator|=
name|ndp
operator|->
name|ni_nameiop
operator|&
name|LOCKPARENT
expr_stmt|;
name|docache
operator|=
operator|(
name|ndp
operator|->
name|ni_nameiop
operator|&
name|NOCACHE
operator|)
operator|^
name|NOCACHE
expr_stmt|;
name|flag
operator|=
name|ndp
operator|->
name|ni_nameiop
operator|&
operator|~
operator|(
name|LOCKPARENT
operator||
name|NOCACHE
operator||
name|FOLLOW
operator|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|DELETE
operator|||
name|lockparent
condition|)
name|docache
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get a buffer for the name to be translated, and copy the 	 * name into the buffer. 	 */
name|MALLOC
argument_list|(
name|nbp
argument_list|,
name|caddr_t
argument_list|,
name|MAXPATHLEN
argument_list|,
name|M_NAMEI
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_segflg
operator|==
name|UIO_SYSSPACE
condition|)
name|error
operator|=
name|copystr
argument_list|(
name|ndp
operator|->
name|ni_dirp
argument_list|,
name|nbp
argument_list|,
name|MAXPATHLEN
argument_list|,
operator|(
name|u_int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|copyinstr
argument_list|(
name|ndp
operator|->
name|ni_dirp
argument_list|,
name|nbp
argument_list|,
name|MAXPATHLEN
argument_list|,
operator|(
name|u_int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|error
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Get starting directory. 	 */
name|cp
operator|=
name|nbp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|u
operator|.
name|u_rdir
operator|)
operator|==
name|NULL
condition|)
name|dp
operator|=
name|rootdir
expr_stmt|;
block|}
else|else
name|dp
operator|=
name|u
operator|.
name|u_cdir
expr_stmt|;
name|fs
operator|=
name|dp
operator|->
name|i_fs
expr_stmt|;
name|ILOCK
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_count
operator|++
expr_stmt|;
name|ndp
operator|->
name|ni_pdir
operator|=
operator|(
expr|struct
name|inode
operator|*
operator|)
literal|0xc0000000
expr_stmt|;
comment|/* illegal */
name|ndp
operator|->
name|ni_endoff
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We come to dirloop to search a new directory. 	 * The directory must be locked so that it can be 	 * iput, and fs must be already set to dp->i_fs. 	 */
name|dirloop
label|:
comment|/* 	 * Check accessiblity of directory. 	 */
if|if
condition|(
operator|(
name|dp
operator|->
name|i_mode
operator|&
name|IFMT
operator|)
operator|!=
name|IFDIR
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|access
argument_list|(
name|dp
argument_list|,
name|IEXEC
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|dirloop2
label|:
comment|/* 	 * Copy next component of name to ndp->ni_dent. 	 */
name|hash
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cp
operator|!=
literal|0
operator|&&
operator|*
name|cp
operator|!=
literal|'/'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|MAXNAMLEN
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ENAMETOOLONG
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|*
name|cp
operator|&
literal|0200
condition|)
if|if
condition|(
operator|(
operator|*
name|cp
operator|&
literal|0377
operator|)
operator|==
operator|(
literal|'/'
operator||
literal|0200
operator|)
operator|||
name|flag
operator|!=
name|DELETE
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|cp
expr_stmt|;
name|hash
operator|+=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
operator|*
name|i
expr_stmt|;
block|}
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
operator|=
name|i
expr_stmt|;
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|isdotdot
operator|=
operator|(
name|i
operator|==
literal|2
operator|&&
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
expr_stmt|;
name|makeentry
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|&&
name|docache
operator|==
literal|0
condition|)
name|makeentry
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check for degenerate name (e.g. / or "") 	 * which is a way of talking about a directory, 	 * e.g. like "/." or ".". 	 */
if|if
condition|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|flag
operator|!=
name|LOOKUP
operator|||
name|lockparent
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EISDIR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|FREE
argument_list|(
name|nbp
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
comment|/* 	 * Special handling for ".." allowing chdir out of mounted 	 * file system: indirect .. in root inode to reevaluate 	 * in directory file system was mounted on. 	 */
if|if
condition|(
name|isdotdot
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dp
operator|==
name|u
operator|.
name|u_rdir
operator|||
name|dp
operator|==
name|rootdir
condition|)
block|{
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
operator|=
name|dp
operator|->
name|i_number
expr_stmt|;
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|i_count
operator|++
expr_stmt|;
goto|goto
name|haveino
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|i_number
operator|!=
name|ROOTINO
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NMOUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mount
index|[
name|i
index|]
operator|.
name|m_fs
operator|!=
name|NULL
operator|&&
name|mount
index|[
name|i
index|]
operator|.
name|m_dev
operator|==
name|dp
operator|->
name|i_dev
condition|)
block|{
name|iput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|mount
index|[
name|i
index|]
operator|.
name|m_inodp
expr_stmt|;
name|ILOCK
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_count
operator|++
expr_stmt|;
name|fs
operator|=
name|dp
operator|->
name|i_fs
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* 	 * We now have a segment name to search for, and a directory to search. 	 * 	 * Before tediously performing a linear scan of the directory, 	 * check the name cache to see if the directory/name pair 	 * we are looking for is known already.  We don't do this 	 * if the segment name is long, simply so the cache can avoid 	 * holding long names (which would either waste space, or 	 * add greatly to the complexity). 	 */
if|if
condition|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
operator|>
name|NCHNAMLEN
condition|)
block|{
name|nchstats
operator|.
name|ncs_long
operator|++
expr_stmt|;
name|makeentry
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nhp
operator|=
operator|&
name|nchash
index|[
name|NHASH
argument_list|(
name|hash
argument_list|,
name|dp
operator|->
name|i_number
argument_list|,
name|dp
operator|->
name|i_dev
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|ncp
operator|=
name|nhp
operator|->
name|nch_forw
init|;
name|ncp
operator|!=
operator|(
expr|struct
name|namecache
operator|*
operator|)
name|nhp
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|nc_forw
control|)
block|{
if|if
condition|(
name|ncp
operator|->
name|nc_ino
operator|==
name|dp
operator|->
name|i_number
operator|&&
name|ncp
operator|->
name|nc_dev
operator|==
name|dp
operator|->
name|i_dev
operator|&&
name|ncp
operator|->
name|nc_nlen
operator|==
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
operator|&&
operator|!
name|bcmp
argument_list|(
name|ncp
operator|->
name|nc_name
argument_list|,
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
operator|(
name|unsigned
operator|)
name|ncp
operator|->
name|nc_nlen
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ncp
operator|==
operator|(
expr|struct
name|namecache
operator|*
operator|)
name|nhp
condition|)
block|{
name|nchstats
operator|.
name|ncs_miss
operator|++
expr_stmt|;
name|ncp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ncp
operator|->
name|nc_id
operator|!=
name|ncp
operator|->
name|nc_ip
operator|->
name|i_id
condition|)
name|nchstats
operator|.
name|ncs_falsehits
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|makeentry
condition|)
name|nchstats
operator|.
name|ncs_badhits
operator|++
expr_stmt|;
else|else
block|{
comment|/* 				 * move this slot to end of LRU 				 * chain, if not already there 				 */
if|if
condition|(
name|ncp
operator|->
name|nc_nxt
condition|)
block|{
comment|/* remove from LRU chain */
operator|*
name|ncp
operator|->
name|nc_prev
operator|=
name|ncp
operator|->
name|nc_nxt
expr_stmt|;
name|ncp
operator|->
name|nc_nxt
operator|->
name|nc_prev
operator|=
name|ncp
operator|->
name|nc_prev
expr_stmt|;
comment|/* and replace at end of it */
name|ncp
operator|->
name|nc_nxt
operator|=
name|NULL
expr_stmt|;
name|ncp
operator|->
name|nc_prev
operator|=
name|nchtail
expr_stmt|;
operator|*
name|nchtail
operator|=
name|ncp
expr_stmt|;
name|nchtail
operator|=
operator|&
name|ncp
operator|->
name|nc_nxt
expr_stmt|;
block|}
comment|/* 				 * Get the next inode in the path. 				 * See comment above other `IUNLOCK' code for 				 * an explaination of the locking protocol. 				 */
name|pdp
operator|=
name|dp
expr_stmt|;
if|if
condition|(
operator|!
name|isdotdot
operator|||
name|dp
operator|!=
name|u
operator|.
name|u_rdir
condition|)
name|dp
operator|=
name|ncp
operator|->
name|nc_ip
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"namei: null cache ino"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdp
operator|==
name|dp
condition|)
name|dp
operator|->
name|i_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|isdotdot
condition|)
block|{
name|IUNLOCK
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
name|igrab
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|igrab
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|IUNLOCK
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Verify that the inode that we got 				 * did not change while we were waiting 				 * for it to be locked. 				 */
if|if
condition|(
name|ncp
operator|->
name|nc_id
operator|!=
name|ncp
operator|->
name|nc_ip
operator|->
name|i_id
condition|)
block|{
name|iput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ILOCK
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|pdp
expr_stmt|;
name|nchstats
operator|.
name|ncs_falsehits
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
operator|=
name|dp
operator|->
name|i_number
expr_stmt|;
comment|/* ni_dent.d_reclen is garbage ... */
name|nchstats
operator|.
name|ncs_goodhits
operator|++
expr_stmt|;
goto|goto
name|haveino
goto|;
block|}
block|}
comment|/* 			 * Last component and we are renaming or deleting, 			 * the cache entry is invalid, or otherwise don't 			 * want cache entry to exist. 			 */
comment|/* remove from LRU chain */
operator|*
name|ncp
operator|->
name|nc_prev
operator|=
name|ncp
operator|->
name|nc_nxt
expr_stmt|;
if|if
condition|(
name|ncp
operator|->
name|nc_nxt
condition|)
name|ncp
operator|->
name|nc_nxt
operator|->
name|nc_prev
operator|=
name|ncp
operator|->
name|nc_prev
expr_stmt|;
else|else
name|nchtail
operator|=
name|ncp
operator|->
name|nc_prev
expr_stmt|;
name|remque
argument_list|(
name|ncp
argument_list|)
expr_stmt|;
comment|/* remove from hash chain */
comment|/* insert at head of LRU list (first to grab) */
name|ncp
operator|->
name|nc_nxt
operator|=
name|nchhead
expr_stmt|;
name|ncp
operator|->
name|nc_prev
operator|=
operator|&
name|nchhead
expr_stmt|;
name|nchhead
operator|->
name|nc_prev
operator|=
operator|&
name|ncp
operator|->
name|nc_nxt
expr_stmt|;
name|nchhead
operator|=
name|ncp
expr_stmt|;
comment|/* and make a dummy hash chain */
name|ncp
operator|->
name|nc_forw
operator|=
name|ncp
expr_stmt|;
name|ncp
operator|->
name|nc_back
operator|=
name|ncp
expr_stmt|;
name|ncp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Suppress search for slots unless creating 	 * file and at end of pathname, in which case 	 * we watch for a place to put the new file in 	 * case it doesn't already exist. 	 */
name|slotstatus
operator|=
name|FOUND
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|CREATE
operator|&&
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|slotstatus
operator|=
name|NONE
expr_stmt|;
name|slotfreespace
operator|=
literal|0
expr_stmt|;
name|slotneeded
operator|=
name|DIRSIZ
argument_list|(
operator|&
name|ndp
operator|->
name|ni_dent
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this is the same directory that this process 	 * previously searched, pick up where we last left off. 	 * We cache only lookups as these are the most common 	 * and have the greatest payoff. Caching CREATE has little 	 * benefit as it usually must search the entire directory 	 * to determine that the entry does not exist. Caching the 	 * location of the last DELETE has not reduced profiling time 	 * and hence has been removed in the interest of simplicity. 	 */
if|if
condition|(
name|flag
operator|!=
name|LOOKUP
operator|||
name|dp
operator|->
name|i_number
operator|!=
name|u
operator|.
name|u_ncache
operator|.
name|nc_inumber
operator|||
name|dp
operator|->
name|i_dev
operator|!=
name|u
operator|.
name|u_ncache
operator|.
name|nc_dev
condition|)
block|{
name|ndp
operator|->
name|ni_offset
operator|=
literal|0
expr_stmt|;
name|numdirpasses
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|u
operator|.
name|u_ncache
operator|.
name|nc_prevoffset
operator|>
name|dp
operator|->
name|i_size
condition|)
name|u
operator|.
name|u_ncache
operator|.
name|nc_prevoffset
operator|=
literal|0
expr_stmt|;
name|ndp
operator|->
name|ni_offset
operator|=
name|u
operator|.
name|u_ncache
operator|.
name|nc_prevoffset
expr_stmt|;
name|entryoffsetinblock
operator|=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|ndp
operator|->
name|ni_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|entryoffsetinblock
operator|!=
literal|0
condition|)
block|{
name|bp
operator|=
name|blkatoff
argument_list|(
name|dp
argument_list|,
name|ndp
operator|->
name|ni_offset
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
name|numdirpasses
operator|=
literal|2
expr_stmt|;
name|nchstats
operator|.
name|ncs_2passes
operator|++
expr_stmt|;
block|}
name|endsearch
operator|=
name|roundup
argument_list|(
name|dp
operator|->
name|i_size
argument_list|,
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
name|enduseful
operator|=
literal|0
expr_stmt|;
name|searchloop
label|:
while|while
condition|(
name|ndp
operator|->
name|ni_offset
operator|<
name|endsearch
condition|)
block|{
comment|/* 		 * If offset is on a block boundary, 		 * read the next directory block. 		 * Release previous if it exists. 		 */
if|if
condition|(
name|blkoff
argument_list|(
name|fs
argument_list|,
name|ndp
operator|->
name|ni_offset
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|blkatoff
argument_list|(
name|dp
argument_list|,
name|ndp
operator|->
name|ni_offset
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|entryoffsetinblock
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * If still looking for a slot, and at a DIRBLKSIZE 		 * boundary, have to start looking for free space again. 		 */
if|if
condition|(
name|slotstatus
operator|==
name|NONE
operator|&&
operator|(
name|entryoffsetinblock
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|slotoffset
operator|=
operator|-
literal|1
expr_stmt|;
name|slotfreespace
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Get pointer to next entry. 		 * Full validation checks are slow, so we only check 		 * enough to insure forward progress through the 		 * directory. Complete checks can be run by patching 		 * "dirchk" to be true. 		 */
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|entryoffsetinblock
operator|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|d_reclen
operator|==
literal|0
operator|||
name|dirchk
operator|&&
name|dirbadentry
argument_list|(
name|ep
argument_list|,
name|entryoffsetinblock
argument_list|)
condition|)
block|{
name|dirbad
argument_list|(
name|dp
argument_list|,
name|ndp
operator|->
name|ni_offset
argument_list|,
literal|"mangled entry"
argument_list|)
expr_stmt|;
name|i
operator|=
name|DIRBLKSIZ
operator|-
operator|(
name|entryoffsetinblock
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|ndp
operator|->
name|ni_offset
operator|+=
name|i
expr_stmt|;
name|entryoffsetinblock
operator|+=
name|i
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If an appropriate sized slot has not yet been found, 		 * check to see if one is available. Also accumulate space 		 * in the current block so that we can determine if 		 * compaction is viable. 		 */
if|if
condition|(
name|slotstatus
operator|!=
name|FOUND
condition|)
block|{
name|int
name|size
init|=
name|ep
operator|->
name|d_reclen
decl_stmt|;
if|if
condition|(
name|ep
operator|->
name|d_ino
operator|!=
literal|0
condition|)
name|size
operator|-=
name|DIRSIZ
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|>=
name|slotneeded
condition|)
block|{
name|slotstatus
operator|=
name|FOUND
expr_stmt|;
name|slotoffset
operator|=
name|ndp
operator|->
name|ni_offset
expr_stmt|;
name|slotsize
operator|=
name|ep
operator|->
name|d_reclen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slotstatus
operator|==
name|NONE
condition|)
block|{
name|slotfreespace
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|slotoffset
operator|==
operator|-
literal|1
condition|)
name|slotoffset
operator|=
name|ndp
operator|->
name|ni_offset
expr_stmt|;
if|if
condition|(
name|slotfreespace
operator|>=
name|slotneeded
condition|)
block|{
name|slotstatus
operator|=
name|COMPACT
expr_stmt|;
name|slotsize
operator|=
name|ndp
operator|->
name|ni_offset
operator|+
name|ep
operator|->
name|d_reclen
operator|-
name|slotoffset
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 		 * Check for a name match. 		 */
if|if
condition|(
name|ep
operator|->
name|d_ino
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|d_namlen
operator|==
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
operator|&&
operator|!
name|bcmp
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|ep
operator|->
name|d_name
argument_list|,
operator|(
name|unsigned
operator|)
name|ep
operator|->
name|d_namlen
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
name|prevoff
operator|=
name|ndp
operator|->
name|ni_offset
expr_stmt|;
name|ndp
operator|->
name|ni_offset
operator|+=
name|ep
operator|->
name|d_reclen
expr_stmt|;
name|entryoffsetinblock
operator|+=
name|ep
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|d_ino
condition|)
name|enduseful
operator|=
name|ndp
operator|->
name|ni_offset
expr_stmt|;
block|}
comment|/* notfound: */
comment|/* 	 * If we started in the middle of the directory and failed 	 * to find our target, we must check the beginning as well. 	 */
if|if
condition|(
name|numdirpasses
operator|==
literal|2
condition|)
block|{
name|numdirpasses
operator|--
expr_stmt|;
name|ndp
operator|->
name|ni_offset
operator|=
literal|0
expr_stmt|;
name|endsearch
operator|=
name|u
operator|.
name|u_ncache
operator|.
name|nc_prevoffset
expr_stmt|;
goto|goto
name|searchloop
goto|;
block|}
comment|/* 	 * If creating, and at end of pathname and current 	 * directory has not been removed, then can consider 	 * allowing file to be created. 	 */
if|if
condition|(
name|flag
operator|==
name|CREATE
operator|&&
operator|*
name|cp
operator|==
literal|0
operator|&&
name|dp
operator|->
name|i_nlink
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Access for write is interpreted as allowing 		 * creation of files in the directory. 		 */
if|if
condition|(
name|access
argument_list|(
name|dp
argument_list|,
name|IWRITE
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* 		 * Return an indication of where the new directory 		 * entry should be put.  If we didn't find a slot, 		 * then set ndp->ni_count to 0 indicating that the new 		 * slot belongs at the end of the directory. If we found 		 * a slot, then the new entry can be put in the range 		 * [ndp->ni_offset .. ndp->ni_offset + ndp->ni_count) 		 */
if|if
condition|(
name|slotstatus
operator|==
name|NONE
condition|)
block|{
name|ndp
operator|->
name|ni_offset
operator|=
name|roundup
argument_list|(
name|dp
operator|->
name|i_size
argument_list|,
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_count
operator|=
literal|0
expr_stmt|;
name|enduseful
operator|=
name|ndp
operator|->
name|ni_offset
expr_stmt|;
block|}
else|else
block|{
name|ndp
operator|->
name|ni_offset
operator|=
name|slotoffset
expr_stmt|;
name|ndp
operator|->
name|ni_count
operator|=
name|slotsize
expr_stmt|;
if|if
condition|(
name|enduseful
operator|<
name|slotoffset
operator|+
name|slotsize
condition|)
name|enduseful
operator|=
name|slotoffset
operator|+
name|slotsize
expr_stmt|;
block|}
name|ndp
operator|->
name|ni_endoff
operator|=
name|roundup
argument_list|(
name|enduseful
argument_list|,
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_flag
operator||=
name|IUPD
operator||
name|ICHG
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|nbp
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
comment|/* 		 * We return with the directory locked, so that 		 * the parameters we set up above will still be 		 * valid if we actually decide to do a direnter(). 		 * We return NULL to indicate that the entry doesn't 		 * currently exist, leaving a pointer to the (locked) 		 * directory inode in ndp->ni_pdir. 		 */
name|ndp
operator|->
name|ni_pdir
operator|=
name|dp
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|u
operator|.
name|u_error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|bad
goto|;
name|found
label|:
if|if
condition|(
name|numdirpasses
operator|==
literal|2
condition|)
name|nchstats
operator|.
name|ncs_pass2
operator|++
expr_stmt|;
comment|/* 	 * Check that directory length properly reflects presence 	 * of this entry. 	 */
if|if
condition|(
name|entryoffsetinblock
operator|+
name|DIRSIZ
argument_list|(
name|ep
argument_list|)
operator|>
name|dp
operator|->
name|i_size
condition|)
block|{
name|dirbad
argument_list|(
name|dp
argument_list|,
name|ndp
operator|->
name|ni_offset
argument_list|,
literal|"i_size too small"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_size
operator|=
name|entryoffsetinblock
operator|+
name|DIRSIZ
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_flag
operator||=
name|IUPD
operator||
name|ICHG
expr_stmt|;
block|}
comment|/* 	 * Found component in pathname. 	 * If the final component of path name, save information 	 * in the cache as to where the entry was found. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|&&
name|flag
operator|==
name|LOOKUP
condition|)
block|{
name|u
operator|.
name|u_ncache
operator|.
name|nc_prevoffset
operator|=
name|ndp
operator|->
name|ni_offset
operator|&
operator|~
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
expr_stmt|;
name|u
operator|.
name|u_ncache
operator|.
name|nc_inumber
operator|=
name|dp
operator|->
name|i_number
expr_stmt|;
name|u
operator|.
name|u_ncache
operator|.
name|nc_dev
operator|=
name|dp
operator|->
name|i_dev
expr_stmt|;
block|}
comment|/* 	 * Save directory entry's inode number and reclen in ndp->ni_dent, 	 * and release directory buffer. 	 */
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
operator|=
name|ep
operator|->
name|d_ino
expr_stmt|;
name|ndp
operator|->
name|ni_dent
operator|.
name|d_reclen
operator|=
name|ep
operator|->
name|d_reclen
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If deleting, and at end of pathname, return 	 * parameters which can be used to remove file. 	 * If the lockparent flag isn't set, we return only 	 * the directory (in ndp->ni_pdir), otherwise we go 	 * on and lock the inode, being careful with ".". 	 */
if|if
condition|(
name|flag
operator|==
name|DELETE
operator|&&
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Write access to directory required to delete files. 		 */
if|if
condition|(
name|access
argument_list|(
name|dp
argument_list|,
name|IWRITE
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|ndp
operator|->
name|ni_pdir
operator|=
name|dp
expr_stmt|;
comment|/* for dirremove() */
comment|/* 		 * Return pointer to current entry in ndp->ni_offset, 		 * and distance past previous entry (if there 		 * is a previous entry in this block) in ndp->ni_count. 		 * Save directory inode pointer in ndp->ni_pdir for dirremove(). 		 */
if|if
condition|(
operator|(
name|ndp
operator|->
name|ni_offset
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|ndp
operator|->
name|ni_count
operator|=
literal|0
expr_stmt|;
else|else
name|ndp
operator|->
name|ni_count
operator|=
name|ndp
operator|->
name|ni_offset
operator|-
name|prevoff
expr_stmt|;
if|if
condition|(
name|lockparent
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|i_number
operator|==
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
condition|)
name|dp
operator|->
name|i_count
operator|++
expr_stmt|;
else|else
block|{
name|dp
operator|=
name|iget
argument_list|(
name|dp
operator|->
name|i_dev
argument_list|,
name|fs
argument_list|,
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
name|iput
argument_list|(
name|ndp
operator|->
name|ni_pdir
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 				 * If directory is "sticky", then user must own 				 * the directory, or the file in it, else he 				 * may not delete it (unless he's root). This 				 * implements append-only directories. 				 */
if|if
condition|(
operator|(
name|ndp
operator|->
name|ni_pdir
operator|->
name|i_mode
operator|&
name|ISVTX
operator|)
operator|&&
name|u
operator|.
name|u_uid
operator|!=
literal|0
operator|&&
name|u
operator|.
name|u_uid
operator|!=
name|ndp
operator|->
name|ni_pdir
operator|->
name|i_uid
operator|&&
name|dp
operator|->
name|i_uid
operator|!=
name|u
operator|.
name|u_uid
condition|)
block|{
name|iput
argument_list|(
name|ndp
operator|->
name|ni_pdir
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
block|}
name|FREE
argument_list|(
name|nbp
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
comment|/* 	 * If rewriting (rename), return the inode and the 	 * information required to rewrite the present directory 	 * Must get inode of directory entry to verify it's a 	 * regular file, or empty directory.   	 */
if|if
condition|(
operator|(
name|flag
operator|==
name|CREATE
operator|&&
name|lockparent
operator|)
operator|&&
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|dp
argument_list|,
name|IWRITE
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|ndp
operator|->
name|ni_pdir
operator|=
name|dp
expr_stmt|;
comment|/* for dirrewrite() */
comment|/* 		 * Careful about locking second inode.  		 * This can only occur if the target is ".".  		 */
if|if
condition|(
name|dp
operator|->
name|i_number
operator|==
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EISDIR
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad
goto|;
block|}
name|dp
operator|=
name|iget
argument_list|(
name|dp
operator|->
name|i_dev
argument_list|,
name|fs
argument_list|,
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
name|iput
argument_list|(
name|ndp
operator|->
name|ni_pdir
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|FREE
argument_list|(
name|nbp
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
comment|/* 	 * Check for symbolic link, which may require us to massage the 	 * name before we continue translation.  We do not `iput' the 	 * directory because we may need it again if the symbolic link 	 * is relative to the current directory.  Instead we save it 	 * unlocked as "pdp".  We must get the target inode before unlocking 	 * the directory to insure that the inode will not be removed 	 * before we get it.  We prevent deadlock by always fetching 	 * inodes from the root, moving down the directory tree. Thus 	 * when following backward pointers ".." we must unlock the 	 * parent directory before getting the requested directory. 	 * There is a potential race condition here if both the current 	 * and parent directories are removed before the `iget' for the 	 * inode associated with ".." returns.  We hope that this occurs 	 * infrequently since we cannot avoid this race condition without 	 * implementing a sophisticated deadlock detection algorithm. 	 * Note also that this simple deadlock detection scheme will not 	 * work if the file system has any hard links other than ".." 	 * that point backwards in the directory structure. 	 */
name|pdp
operator|=
name|dp
expr_stmt|;
if|if
condition|(
name|isdotdot
condition|)
block|{
name|IUNLOCK
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
comment|/* race to get the inode */
name|dp
operator|=
name|iget
argument_list|(
name|dp
operator|->
name|i_dev
argument_list|,
name|fs
argument_list|,
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
goto|goto
name|bad2
goto|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|i_number
operator|==
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
condition|)
block|{
name|dp
operator|->
name|i_count
operator|++
expr_stmt|;
comment|/* we want ourself, ie "." */
block|}
else|else
block|{
name|dp
operator|=
name|iget
argument_list|(
name|dp
operator|->
name|i_dev
argument_list|,
name|fs
argument_list|,
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
argument_list|)
expr_stmt|;
name|IUNLOCK
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
goto|goto
name|bad2
goto|;
block|}
comment|/* 	 * Insert name into cache if appropriate. 	 */
if|if
condition|(
name|makeentry
condition|)
block|{
if|if
condition|(
name|ncp
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"namei: duplicating cache"
argument_list|)
expr_stmt|;
comment|/* 		 * Free the cache slot at head of lru chain. 		 */
if|if
condition|(
name|ncp
operator|=
name|nchhead
condition|)
block|{
comment|/* remove from lru chain */
operator|*
name|ncp
operator|->
name|nc_prev
operator|=
name|ncp
operator|->
name|nc_nxt
expr_stmt|;
if|if
condition|(
name|ncp
operator|->
name|nc_nxt
condition|)
name|ncp
operator|->
name|nc_nxt
operator|->
name|nc_prev
operator|=
name|ncp
operator|->
name|nc_prev
expr_stmt|;
else|else
name|nchtail
operator|=
name|ncp
operator|->
name|nc_prev
expr_stmt|;
name|remque
argument_list|(
name|ncp
argument_list|)
expr_stmt|;
comment|/* remove from old hash chain */
comment|/* grab the inode we just found */
name|ncp
operator|->
name|nc_ip
operator|=
name|dp
expr_stmt|;
comment|/* fill in cache info */
name|ncp
operator|->
name|nc_ino
operator|=
name|pdp
operator|->
name|i_number
expr_stmt|;
comment|/* parents inum */
name|ncp
operator|->
name|nc_dev
operator|=
name|pdp
operator|->
name|i_dev
expr_stmt|;
comment|/*& device */
name|ncp
operator|->
name|nc_idev
operator|=
name|dp
operator|->
name|i_dev
expr_stmt|;
comment|/* our device */
name|ncp
operator|->
name|nc_id
operator|=
name|dp
operator|->
name|i_id
expr_stmt|;
comment|/* identifier */
name|ncp
operator|->
name|nc_nlen
operator|=
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
expr_stmt|;
name|bcopy
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|ncp
operator|->
name|nc_name
argument_list|,
operator|(
name|unsigned
operator|)
name|ncp
operator|->
name|nc_nlen
argument_list|)
expr_stmt|;
comment|/* link at end of lru chain */
name|ncp
operator|->
name|nc_nxt
operator|=
name|NULL
expr_stmt|;
name|ncp
operator|->
name|nc_prev
operator|=
name|nchtail
expr_stmt|;
operator|*
name|nchtail
operator|=
name|ncp
expr_stmt|;
name|nchtail
operator|=
operator|&
name|ncp
operator|->
name|nc_nxt
expr_stmt|;
comment|/* and insert on hash chain */
name|insque
argument_list|(
name|ncp
argument_list|,
name|nhp
argument_list|)
expr_stmt|;
block|}
block|}
name|haveino
label|:
name|fs
operator|=
name|dp
operator|->
name|i_fs
expr_stmt|;
comment|/* 	 * Check for symbolic link 	 */
if|if
condition|(
operator|(
name|dp
operator|->
name|i_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFLNK
operator|&&
operator|(
operator|(
name|ndp
operator|->
name|ni_nameiop
operator|&
name|FOLLOW
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|u_int
name|pathlen
init|=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|i_size
operator|+
name|pathlen
operator|>=
name|MAXPATHLEN
operator|-
literal|1
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ENAMETOOLONG
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
operator|++
name|nlink
operator|>
name|MAXSYMLINKS
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ELOOP
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|ovbcopy
argument_list|(
name|cp
argument_list|,
name|nbp
operator|+
name|dp
operator|->
name|i_size
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|rdwri
argument_list|(
name|UIO_READ
argument_list|,
name|dp
argument_list|,
name|nbp
argument_list|,
operator|(
name|int
operator|)
name|dp
operator|->
name|i_size
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
goto|goto
name|bad2
goto|;
name|cp
operator|=
name|nbp
expr_stmt|;
name|iput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
name|irele
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|u
operator|.
name|u_rdir
operator|)
operator|==
name|NULL
condition|)
name|dp
operator|=
name|rootdir
expr_stmt|;
name|ILOCK
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|=
name|pdp
expr_stmt|;
name|ILOCK
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
name|fs
operator|=
name|dp
operator|->
name|i_fs
expr_stmt|;
goto|goto
name|dirloop
goto|;
block|}
comment|/* 	 * Not a symbolic link.  If more pathname, 	 * continue at next component, else return. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|cp
operator|++
expr_stmt|;
name|irele
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
goto|goto
name|dirloop
goto|;
block|}
name|FREE
argument_list|(
name|nbp
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockparent
condition|)
name|ndp
operator|->
name|ni_pdir
operator|=
name|pdp
expr_stmt|;
else|else
name|irele
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
name|bad2
label|:
name|irele
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
condition|)
name|iput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|nbp
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|dirbad
argument_list|(
argument|ip
argument_list|,
argument|offset
argument_list|,
argument|how
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|how
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%s: bad dir ino %d at offset %d: %s\n"
argument_list|,
name|ip
operator|->
name|i_fs
operator|->
name|fs_fsmnt
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|offset
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do consistency checking on a directory entry:  *	record length must be multiple of 4  *	entry must fit in rest of its DIRBLKSIZ block  *	record must be large enough to contain entry  *	name is not longer than MAXNAMLEN  *	name must be as long as advertised, and null terminated  */
end_comment

begin_expr_stmt
name|dirbadentry
argument_list|(
name|ep
argument_list|,
name|entryoffsetinblock
argument_list|)
specifier|register
expr|struct
name|direct
operator|*
name|ep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|entryoffsetinblock
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|d_reclen
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|ep
operator|->
name|d_reclen
operator|>
name|DIRBLKSIZ
operator|-
operator|(
name|entryoffsetinblock
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|||
name|ep
operator|->
name|d_reclen
operator|<
name|DIRSIZ
argument_list|(
name|ep
argument_list|)
operator|||
name|ep
operator|->
name|d_namlen
operator|>
name|MAXNAMLEN
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|d_namlen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|d_name
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|ep
operator|->
name|d_name
index|[
name|i
index|]
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Write a directory entry after a call to namei, using the parameters  * which it left in the u. area.  The argument ip is the inode which  * the new directory entry will refer to.  The u. area field ndp->ni_pdir is  * a pointer to the directory to be written, which was left locked by  * namei.  Remaining parameters (ndp->ni_offset, ndp->ni_count) indicate  * how the space for the new entry is to be gotten.  */
end_comment

begin_macro
name|direnter
argument_list|(
argument|ip
argument_list|,
argument|ndp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|direct
modifier|*
name|ep
decl_stmt|,
modifier|*
name|nep
decl_stmt|;
specifier|register
name|struct
name|inode
modifier|*
name|dp
init|=
name|ndp
operator|->
name|ni_pdir
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|loc
decl_stmt|,
name|spacefree
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|u_int
name|dsize
decl_stmt|;
name|int
name|newentrysize
decl_stmt|;
name|char
modifier|*
name|dirbuf
decl_stmt|;
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|newentrysize
operator|=
name|DIRSIZ
argument_list|(
operator|&
name|ndp
operator|->
name|ni_dent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If ndp->ni_count is 0, then namei could find no space in the 		 * directory. In this case ndp->ni_offset will be on a directory 		 * block boundary and we will write the new entry into a fresh 		 * block. 		 */
if|if
condition|(
name|ndp
operator|->
name|ni_offset
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
condition|)
name|panic
argument_list|(
literal|"wdir: newblk"
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_dent
operator|.
name|d_reclen
operator|=
name|DIRBLKSIZ
expr_stmt|;
name|error
operator|=
name|rdwri
argument_list|(
name|UIO_WRITE
argument_list|,
name|dp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ndp
operator|->
name|ni_dent
argument_list|,
name|newentrysize
argument_list|,
name|ndp
operator|->
name|ni_offset
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DIRBLKSIZ
operator|>
name|dp
operator|->
name|i_fs
operator|->
name|fs_fsize
condition|)
name|panic
argument_list|(
literal|"wdir: blksize"
argument_list|)
expr_stmt|;
comment|/* XXX - should grow w/bmap() */
else|else
name|dp
operator|->
name|i_size
operator|=
name|roundup
argument_list|(
name|dp
operator|->
name|i_size
argument_list|,
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If ndp->ni_count is non-zero, then namei found space for the new 	 * entry in the range ndp->ni_offset to ndp->ni_offset + ndp->ni_count. 	 * in the directory.  To use this space, we may have to compact 	 * the entries located there, by copying them together towards 	 * the beginning of the block, leaving the free space in 	 * one usable chunk at the end. 	 */
comment|/* 	 * Increase size of directory if entry eats into new space. 	 * This should never push the size past a new multiple of 	 * DIRBLKSIZE. 	 * 	 * N.B. - THIS IS AN ARTIFACT OF 4.2 AND SHOULD NEVER HAPPEN. 	 */
if|if
condition|(
name|ndp
operator|->
name|ni_offset
operator|+
name|ndp
operator|->
name|ni_count
operator|>
name|dp
operator|->
name|i_size
condition|)
name|dp
operator|->
name|i_size
operator|=
name|ndp
operator|->
name|ni_offset
operator|+
name|ndp
operator|->
name|ni_count
expr_stmt|;
comment|/* 	 * Get the block containing the space for the new directory 	 * entry.  Should return error by result instead of u.u_error. 	 */
name|bp
operator|=
name|blkatoff
argument_list|(
name|dp
argument_list|,
name|ndp
operator|->
name|ni_offset
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|dirbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
block|{
name|iput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|u
operator|.
name|u_error
operator|)
return|;
block|}
comment|/* 	 * Find space for the new entry.  In the simple case, the 	 * entry at offset base will have the space.  If it does 	 * not, then namei arranged that compacting the region 	 * ndp->ni_offset to ndp->ni_offset+ndp->ni_count would yield the space. 	 */
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|dirbuf
expr_stmt|;
name|dsize
operator|=
name|DIRSIZ
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|spacefree
operator|=
name|ep
operator|->
name|d_reclen
operator|-
name|dsize
expr_stmt|;
for|for
control|(
name|loc
operator|=
name|ep
operator|->
name|d_reclen
init|;
name|loc
operator|<
name|ndp
operator|->
name|ni_count
condition|;
control|)
block|{
name|nep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|dirbuf
operator|+
name|loc
operator|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|d_ino
condition|)
block|{
comment|/* trim the existing slot */
name|ep
operator|->
name|d_reclen
operator|=
name|dsize
expr_stmt|;
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ep
operator|+
name|dsize
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* overwrite; nothing there; header is ours */
name|spacefree
operator|+=
name|dsize
expr_stmt|;
block|}
name|dsize
operator|=
name|DIRSIZ
argument_list|(
name|nep
argument_list|)
expr_stmt|;
name|spacefree
operator|+=
name|nep
operator|->
name|d_reclen
operator|-
name|dsize
expr_stmt|;
name|loc
operator|+=
name|nep
operator|->
name|d_reclen
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|nep
argument_list|,
operator|(
name|caddr_t
operator|)
name|ep
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update the pointer fields in the previous entry (if any), 	 * copy in the new entry, and write out the block. 	 */
if|if
condition|(
name|ep
operator|->
name|d_ino
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spacefree
operator|+
name|dsize
operator|<
name|newentrysize
condition|)
name|panic
argument_list|(
literal|"wdir: compact1"
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_dent
operator|.
name|d_reclen
operator|=
name|spacefree
operator|+
name|dsize
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|spacefree
operator|<
name|newentrysize
condition|)
name|panic
argument_list|(
literal|"wdir: compact2"
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_dent
operator|.
name|d_reclen
operator|=
name|spacefree
expr_stmt|;
name|ep
operator|->
name|d_reclen
operator|=
name|dsize
expr_stmt|;
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ep
operator|+
name|dsize
operator|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ndp
operator|->
name|ni_dent
argument_list|,
operator|(
name|caddr_t
operator|)
name|ep
argument_list|,
operator|(
name|u_int
operator|)
name|newentrysize
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_flag
operator||=
name|IUPD
operator||
name|ICHG
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_endoff
operator|&&
name|ndp
operator|->
name|ni_endoff
operator|<
name|dp
operator|->
name|i_size
condition|)
name|itrunc
argument_list|(
name|dp
argument_list|,
operator|(
name|u_long
operator|)
name|ndp
operator|->
name|ni_endoff
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Remove a directory entry after a call to namei, using the  * parameters which it left in the u. area.  The u. entry  * ni_offset contains the offset into the directory of the  * entry to be eliminated.  The ni_count field contains the  * size of the previous record in the directory.  If this  * is 0, the first entry is being deleted, so we need only  * zero the inode number to mark the entry as free.  If the  * entry isn't the first in the directory, we must reclaim  * the space of the now empty record by adding the record size  * to the size of the previous entry.  */
end_comment

begin_expr_stmt
name|dirremove
argument_list|(
name|ndp
argument_list|)
specifier|register
expr|struct
name|nameidata
operator|*
name|ndp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|inode
modifier|*
name|dp
init|=
name|ndp
operator|->
name|ni_pdir
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|direct
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * First entry in block: set d_ino to zero. 		 */
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|rdwri
argument_list|(
name|UIO_WRITE
argument_list|,
name|dp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ndp
operator|->
name|ni_dent
argument_list|,
operator|(
name|int
operator|)
name|DIRSIZ
argument_list|(
operator|&
name|ndp
operator|->
name|ni_dent
argument_list|)
argument_list|,
name|ndp
operator|->
name|ni_offset
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Collapse new free space into previous entry. 		 */
name|bp
operator|=
name|blkatoff
argument_list|(
name|dp
argument_list|,
name|ndp
operator|->
name|ni_offset
operator|-
name|ndp
operator|->
name|ni_count
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ep
operator|->
name|d_reclen
operator|+=
name|ndp
operator|->
name|ni_dent
operator|.
name|d_reclen
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_flag
operator||=
name|IUPD
operator||
name|ICHG
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Rewrite an existing directory entry to point at the inode  * supplied.  The parameters describing the directory entry are  * set up by a call to namei.  */
end_comment

begin_macro
name|dirrewrite
argument_list|(
argument|dp
argument_list|,
argument|ip
argument_list|,
argument|ndp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inode
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ndp
operator|->
name|ni_dent
operator|.
name|d_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|rdwri
argument_list|(
name|UIO_WRITE
argument_list|,
name|dp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ndp
operator|->
name|ni_dent
argument_list|,
operator|(
name|int
operator|)
name|DIRSIZ
argument_list|(
operator|&
name|ndp
operator|->
name|ni_dent
argument_list|)
argument_list|,
name|ndp
operator|->
name|ni_offset
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return buffer with contents of block "offset"  * from the beginning of directory "ip".  If "res"  * is non-zero, fill it in with a pointer to the  * remaining space in the directory.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|blkatoff
parameter_list|(
name|ip
parameter_list|,
name|offset
parameter_list|,
name|res
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|char
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
specifier|register
name|struct
name|fs
modifier|*
name|fs
init|=
name|ip
operator|->
name|i_fs
decl_stmt|;
name|daddr_t
name|lbn
init|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|int
name|bsize
init|=
name|blksize
argument_list|(
name|fs
argument_list|,
name|ip
argument_list|,
name|lbn
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|bn
operator|=
name|bmap
argument_list|(
name|ip
argument_list|,
name|lbn
argument_list|,
name|B_READ
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|bn
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|dirbad
argument_list|(
name|ip
argument_list|,
name|offset
argument_list|,
literal|"hole in dir"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SECSIZE
name|bp
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_dev
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|bn
argument_list|)
argument_list|,
name|bsize
argument_list|,
name|fs
operator|->
name|fs_dbsize
argument_list|)
expr_stmt|;
else|#
directive|else
else|SECSIZE
name|bp
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_dev
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|bn
argument_list|)
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SECSIZE
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|res
condition|)
operator|*
name|res
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|blkoff
argument_list|(
name|fs
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a directory is empty or not.  * Inode supplied must be locked.  *  * Using a struct dirtemplate here is not precisely  * what we want, but better than using a struct direct.  *  * NB: does not handle corrupted directories.  */
end_comment

begin_expr_stmt
name|dirempty
argument_list|(
name|ip
argument_list|,
name|parentino
argument_list|)
specifier|register
expr|struct
name|inode
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ino_t
name|parentino
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|off_t
name|off
decl_stmt|;
name|struct
name|dirtemplate
name|dbuf
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dp
init|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|&
name|dbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|count
decl_stmt|;
define|#
directive|define
name|MINDIRSIZ
value|(sizeof (struct dirtemplate) / 2)
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|ip
operator|->
name|i_size
condition|;
name|off
operator|+=
name|dp
operator|->
name|d_reclen
control|)
block|{
name|error
operator|=
name|rdwri
argument_list|(
name|UIO_READ
argument_list|,
name|ip
argument_list|,
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
name|MINDIRSIZ
argument_list|,
name|off
argument_list|,
literal|1
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
comment|/* 		 * Since we read MINDIRSIZ, residual must 		 * be 0 unless we're at end of file. 		 */
if|if
condition|(
name|error
operator|||
name|count
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* avoid infinite loops */
if|if
condition|(
name|dp
operator|->
name|d_reclen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* skip empty entries */
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
comment|/* accept only "." and ".." */
if|if
condition|(
name|dp
operator|->
name|d_namlen
operator|>
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * At this point d_namlen must be 1 or 2. 		 * 1 implies ".", 2 implies ".." if second 		 * char is also "." 		 */
if|if
condition|(
name|dp
operator|->
name|d_namlen
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_ino
operator|==
name|parentino
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Check if source directory is in the path of the target directory.  * Target is supplied locked, source is unlocked.  * The target is always iput() before returning.  */
end_comment

begin_macro
name|checkpath
argument_list|(
argument|source
argument_list|,
argument|target
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inode
modifier|*
name|source
decl_stmt|,
modifier|*
name|target
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|dirtemplate
name|dirbuf
decl_stmt|;
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ip
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_number
operator|==
name|source
operator|->
name|i_number
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ip
operator|->
name|i_number
operator|==
name|ROOTINO
condition|)
goto|goto
name|out
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|i_mode
operator|&
name|IFMT
operator|)
operator|!=
name|IFDIR
condition|)
block|{
name|error
operator|=
name|ENOTDIR
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|rdwri
argument_list|(
name|UIO_READ
argument_list|,
name|ip
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirtemplate
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|dirbuf
operator|.
name|dotdot_namlen
operator|!=
literal|2
operator|||
name|dirbuf
operator|.
name|dotdot_name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|dirbuf
operator|.
name|dotdot_name
index|[
literal|1
index|]
operator|!=
literal|'.'
condition|)
block|{
name|error
operator|=
name|ENOTDIR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dirbuf
operator|.
name|dotdot_ino
operator|==
name|source
operator|->
name|i_number
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dirbuf
operator|.
name|dotdot_ino
operator|==
name|ROOTINO
condition|)
break|break;
name|iput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|=
name|iget
argument_list|(
name|ip
operator|->
name|i_dev
argument_list|,
name|ip
operator|->
name|i_fs
argument_list|,
name|dirbuf
operator|.
name|dotdot_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|u
operator|.
name|u_error
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
if|if
condition|(
name|error
operator|==
name|ENOTDIR
condition|)
name|printf
argument_list|(
literal|"checkpath: .. not a directory\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|iput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Name cache initialization, from main() when we are booting  */
end_comment

begin_macro
name|nchinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|union
name|nchash
modifier|*
name|nchp
decl_stmt|;
specifier|register
name|struct
name|namecache
modifier|*
name|ncp
decl_stmt|;
name|nchhead
operator|=
literal|0
expr_stmt|;
name|nchtail
operator|=
operator|&
name|nchhead
expr_stmt|;
for|for
control|(
name|ncp
operator|=
name|namecache
init|;
name|ncp
operator|<
operator|&
name|namecache
index|[
name|nchsize
index|]
condition|;
name|ncp
operator|++
control|)
block|{
name|ncp
operator|->
name|nc_forw
operator|=
name|ncp
expr_stmt|;
comment|/* hash chain */
name|ncp
operator|->
name|nc_back
operator|=
name|ncp
expr_stmt|;
name|ncp
operator|->
name|nc_nxt
operator|=
name|NULL
expr_stmt|;
comment|/* lru chain */
operator|*
name|nchtail
operator|=
name|ncp
expr_stmt|;
name|ncp
operator|->
name|nc_prev
operator|=
name|nchtail
expr_stmt|;
name|nchtail
operator|=
operator|&
name|ncp
operator|->
name|nc_nxt
expr_stmt|;
comment|/* all else is zero already */
block|}
for|for
control|(
name|nchp
operator|=
name|nchash
init|;
name|nchp
operator|<
operator|&
name|nchash
index|[
name|NCHHASH
index|]
condition|;
name|nchp
operator|++
control|)
block|{
name|nchp
operator|->
name|nch_head
index|[
literal|0
index|]
operator|=
name|nchp
expr_stmt|;
name|nchp
operator|->
name|nch_head
index|[
literal|1
index|]
operator|=
name|nchp
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Cache flush, called when filesys is umounted to  * remove entries that would now be invalid  *  * The line "nxtcp = nchhead" near the end is to avoid potential problems  * if the cache lru chain is modified while we are dumping the  * inode.  This makes the algorithm O(n^2), but do you think I care?  */
end_comment

begin_expr_stmt
name|nchinval
argument_list|(
name|dev
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|namecache
modifier|*
name|ncp
decl_stmt|,
modifier|*
name|nxtcp
decl_stmt|;
for|for
control|(
name|ncp
operator|=
name|nchhead
init|;
name|ncp
condition|;
name|ncp
operator|=
name|nxtcp
control|)
block|{
name|nxtcp
operator|=
name|ncp
operator|->
name|nc_nxt
expr_stmt|;
if|if
condition|(
name|ncp
operator|->
name|nc_ip
operator|==
name|NULL
operator|||
operator|(
name|ncp
operator|->
name|nc_idev
operator|!=
name|dev
operator|&&
name|ncp
operator|->
name|nc_dev
operator|!=
name|dev
operator|)
condition|)
continue|continue;
comment|/* free the resources we had */
name|ncp
operator|->
name|nc_idev
operator|=
name|NODEV
expr_stmt|;
name|ncp
operator|->
name|nc_dev
operator|=
name|NODEV
expr_stmt|;
name|ncp
operator|->
name|nc_id
operator|=
name|NULL
expr_stmt|;
name|ncp
operator|->
name|nc_ino
operator|=
literal|0
expr_stmt|;
name|ncp
operator|->
name|nc_ip
operator|=
name|NULL
expr_stmt|;
name|remque
argument_list|(
name|ncp
argument_list|)
expr_stmt|;
comment|/* remove entry from its hash chain */
name|ncp
operator|->
name|nc_forw
operator|=
name|ncp
expr_stmt|;
comment|/* and make a dummy one */
name|ncp
operator|->
name|nc_back
operator|=
name|ncp
expr_stmt|;
comment|/* delete this entry from LRU chain */
operator|*
name|ncp
operator|->
name|nc_prev
operator|=
name|nxtcp
expr_stmt|;
if|if
condition|(
name|nxtcp
condition|)
name|nxtcp
operator|->
name|nc_prev
operator|=
name|ncp
operator|->
name|nc_prev
expr_stmt|;
else|else
name|nchtail
operator|=
name|ncp
operator|->
name|nc_prev
expr_stmt|;
comment|/* cause rescan of list, it may have altered */
name|nxtcp
operator|=
name|nchhead
expr_stmt|;
comment|/* put the now-free entry at head of LRU */
name|ncp
operator|->
name|nc_nxt
operator|=
name|nxtcp
expr_stmt|;
name|ncp
operator|->
name|nc_prev
operator|=
operator|&
name|nchhead
expr_stmt|;
name|nxtcp
operator|->
name|nc_prev
operator|=
operator|&
name|ncp
operator|->
name|nc_nxt
expr_stmt|;
name|nchhead
operator|=
name|ncp
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Name cache invalidation of all entries.  */
end_comment

begin_macro
name|cacheinvalall
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|namecache
modifier|*
name|ncp
decl_stmt|;
for|for
control|(
name|ncp
operator|=
name|namecache
init|;
name|ncp
operator|<
operator|&
name|namecache
index|[
name|nchsize
index|]
condition|;
name|ncp
operator|++
control|)
name|ncp
operator|->
name|nc_id
operator|=
literal|0
expr_stmt|;
block|}
end_block

end_unit

