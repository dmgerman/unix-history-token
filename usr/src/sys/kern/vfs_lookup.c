begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	vfs_lookup.c	4.33	82/12/21	*/
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/fs.h"
end_include

begin_include
include|#
directive|include
file|"../h/mount.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/conf.h"
end_include

begin_include
include|#
directive|include
file|"../h/uio.h"
end_include

begin_include
include|#
directive|include
file|"../h/nami.h"
end_include

begin_function_decl
name|struct
name|buf
modifier|*
name|blkatoff
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|dirchk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Convert a pathname into a pointer to a locked inode,  * with side effects usable in creating and removing files.  * This is a very central and rather complicated routine.  *  * The func argument gives the routine which returns successive  * characters of the name to be translated.   *  * The flag argument is (LOOKUP, CREATE, DELETE) depending on whether  * the name is to be (looked up, created, deleted).  If flag has  * LOCKPARENT or'ed into it and the target of the pathname exists,  * namei returns both the target and its parent directory locked.   * If the file system is not maintained in a strict tree hierarchy,  * this can result in a deadlock situation.  When creating and  * LOCKPARENT is specified, the target may not be ".".  When deleting  * and LOCKPARENT is specified, the target may be ".", but the caller  * must check to insure it does an irele and iput instead of two iputs.  *  * The follow argument is 1 when symbolic links are to be followed  * when they occur at the end of the name translation process.  *  * Overall outline:  *  *	copy in name  *	get starting directory  * dirloop:  *	check accessibility of directory  * dirloop2:  *	copy next component of name to u.u_dent  *	handle degenerate case where name is null string  *	search for name in directory, to found or notfound  * notfound:  *	if creating, return locked directory, leaving info on avail. slots  *	else return error  * found:  *	if at end of path and deleting, return information to allow delete  *	if at end of path and rewriting (create and LOCKPARENT), lock targe  *	  inode and return info to allow rewrite  *	if .. and on mounted filesys, look in mount table for parent  *	if symbolic link, massage name in buffer and continue at dirloop  *	if more components of name, do next level at dirloop  *	return the answer as locked inode  *  * NOTE: (LOOKUP | LOCKPARENT) currently returns the parent inode,  *	 but unlocked.  */
end_comment

begin_decl_stmt
name|struct
name|inode
modifier|*
name|namei
argument_list|(
name|func
argument_list|,
name|flag
argument_list|,
name|follow
argument_list|)
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|,
name|flag
decl_stmt|,
name|follow
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* pointer into pathname argument */
comment|/* these variables refer to things which must be freed or unlocked */
specifier|register
name|struct
name|inode
modifier|*
name|dp
init|=
literal|0
decl_stmt|;
comment|/* the directory we are searching */
specifier|register
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
comment|/* file system that directory is in */
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
literal|0
decl_stmt|;
comment|/* a buffer of directory entries */
specifier|register
name|struct
name|direct
modifier|*
name|ep
decl_stmt|;
comment|/* the current directory entry */
name|int
name|entryoffsetinblock
decl_stmt|;
comment|/* offset of ep in bp's buffer */
specifier|register
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
comment|/* buffer storing path name argument */
comment|/* these variables hold information about the search for a slot */
enum|enum
block|{
name|NONE
block|,
name|COMPACT
block|,
name|FOUND
block|}
name|slotstatus
enum|;
name|int
name|slotoffset
init|=
operator|-
literal|1
decl_stmt|;
comment|/* offset of area with free space */
name|int
name|slotsize
decl_stmt|;
comment|/* size of area at slotoffset */
name|int
name|slotfreespace
decl_stmt|;
comment|/* amount of space free in slot */
name|int
name|slotneeded
decl_stmt|;
comment|/* size of the entry we're seeking */
comment|/* */
name|int
name|dirsize
decl_stmt|;
name|int
name|prevoff
decl_stmt|;
comment|/* u.u_offset of previous entry */
name|int
name|nlink
init|=
literal|0
decl_stmt|;
comment|/* number of symbolic links taken */
name|struct
name|inode
modifier|*
name|pdp
decl_stmt|;
comment|/* saved dp during symlink work */
name|int
name|i
decl_stmt|;
name|int
name|lockparent
decl_stmt|;
name|lockparent
operator|=
name|flag
operator|&
name|LOCKPARENT
expr_stmt|;
name|flag
operator|&=
operator|~
name|LOCKPARENT
expr_stmt|;
comment|/* 	 * Get a buffer for the name to be translated, and copy the 	 * name into the buffer. 	 */
name|nbp
operator|=
name|geteblk
argument_list|(
name|MAXPATHLEN
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|nbp
operator|->
name|b_un
operator|.
name|b_addr
init|;
operator|*
name|cp
operator|=
call|(
modifier|*
name|func
call|)
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|&
literal|0377
operator|)
operator|==
operator|(
literal|'/'
operator||
literal|0200
operator|)
operator|||
operator|(
operator|*
name|cp
operator|&
literal|0200
operator|)
operator|&&
name|flag
operator|!=
literal|2
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|>=
name|nbp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|MAXPATHLEN
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Get starting directory. 	 */
name|cp
operator|=
name|nbp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|u
operator|.
name|u_rdir
operator|)
operator|==
name|NULL
condition|)
name|dp
operator|=
name|rootdir
expr_stmt|;
block|}
else|else
name|dp
operator|=
name|u
operator|.
name|u_cdir
expr_stmt|;
name|fs
operator|=
name|dp
operator|->
name|i_fs
expr_stmt|;
name|ilock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_count
operator|++
expr_stmt|;
name|u
operator|.
name|u_pdir
operator|=
operator|(
expr|struct
name|inode
operator|*
operator|)
literal|0xc0000000
expr_stmt|;
comment|/* illegal */
comment|/* 	 * We come to dirloop to search a new directory. 	 * The directory must be locked so that it can be 	 * iput, and fs must be already set to dp->i_fs. 	 */
name|dirloop
label|:
comment|/* 	 * Check accessiblity of directory. 	 */
if|if
condition|(
operator|(
name|dp
operator|->
name|i_mode
operator|&
name|IFMT
operator|)
operator|!=
name|IFDIR
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|access
argument_list|(
name|dp
argument_list|,
name|IEXEC
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|dirloop2
label|:
comment|/* 	 * Copy next component of name to u.u_dent. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cp
operator|!=
literal|0
operator|&&
operator|*
name|cp
operator|!=
literal|'/'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|MAXNAMLEN
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|u
operator|.
name|u_dent
operator|.
name|d_name
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|cp
expr_stmt|;
block|}
name|u
operator|.
name|u_dent
operator|.
name|d_namlen
operator|=
name|i
expr_stmt|;
name|u
operator|.
name|u_dent
operator|.
name|d_name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check for degenerate name (e.g. / or "") 	 * which is a way of talking about a directory, 	 * e.g. like "/." or ".". 	 */
if|if
condition|(
name|u
operator|.
name|u_dent
operator|.
name|d_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flag
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
comment|/* 	 * Suppress search for slots unless creating 	 * file and at end of pathname, in which case 	 * we watch for a place to put the new file in 	 * case it doesn't already exist. 	 */
name|slotstatus
operator|=
name|FOUND
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|CREATE
operator|&&
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|slotstatus
operator|=
name|NONE
expr_stmt|;
name|slotfreespace
operator|=
literal|0
expr_stmt|;
name|slotneeded
operator|=
name|DIRSIZ
argument_list|(
operator|&
name|u
operator|.
name|u_dent
argument_list|)
expr_stmt|;
block|}
name|dirsize
operator|=
name|roundup
argument_list|(
name|dp
operator|->
name|i_size
argument_list|,
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|u
operator|.
name|u_offset
operator|<
name|dirsize
condition|)
block|{
comment|/* 		 * If offset is on a block boundary, 		 * read the next directory block. 		 * Release previous if it exists. 		 */
if|if
condition|(
name|blkoff
argument_list|(
name|fs
argument_list|,
name|u
operator|.
name|u_offset
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|blkatoff
argument_list|(
name|dp
argument_list|,
name|u
operator|.
name|u_offset
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|entryoffsetinblock
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * If still looking for a slot, and at a DIRBLKSIZE 		 * boundary, have to start looking for free space 		 * again. 		 */
if|if
condition|(
name|slotstatus
operator|==
name|NONE
operator|&&
operator|(
name|entryoffsetinblock
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|slotoffset
operator|=
operator|-
literal|1
expr_stmt|;
name|slotfreespace
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Get pointer to next entry, and do consistency checking: 		 *	record length must be multiple of 4 		 *	record length must not be zero 		 *	entry must fit in rest of this DIRBLKSIZ block 		 *	record must be large enough to contain name 		 * When dirchk is set we also check: 		 *	name is not longer than MAXNAMLEN 		 *	name must be as long as advertised, and null terminated 		 * Checking last two conditions is done only when dirchk is 		 * set, to save time. 		 */
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|entryoffsetinblock
operator|)
expr_stmt|;
name|i
operator|=
name|DIRBLKSIZ
operator|-
operator|(
name|entryoffsetinblock
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|d_reclen
operator|&
literal|0x3
operator|)
operator|||
name|ep
operator|->
name|d_reclen
operator|==
literal|0
operator|||
name|ep
operator|->
name|d_reclen
operator|>
name|i
operator|||
name|DIRSIZ
argument_list|(
name|ep
argument_list|)
operator|>
name|ep
operator|->
name|d_reclen
operator|||
name|dirchk
operator|&&
operator|(
name|ep
operator|->
name|d_namlen
operator|>
name|MAXNAMLEN
operator|||
name|dirbadname
argument_list|(
name|ep
argument_list|)
operator|)
condition|)
block|{
name|dirbad
argument_list|(
name|dp
argument_list|,
literal|"mangled entry"
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_offset
operator|+=
name|i
expr_stmt|;
name|entryoffsetinblock
operator|+=
name|i
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If an appropriate sized slot has not yet been found, 		 * check to see if one is available. Also accumulate space 		 * in the current block so that we can determine if 		 * compaction is viable. 		 */
if|if
condition|(
name|slotstatus
operator|!=
name|FOUND
condition|)
block|{
name|int
name|size
init|=
name|ep
operator|->
name|d_reclen
decl_stmt|;
if|if
condition|(
name|ep
operator|->
name|d_ino
operator|!=
literal|0
condition|)
name|size
operator|-=
name|DIRSIZ
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|>=
name|slotneeded
condition|)
block|{
name|slotstatus
operator|=
name|FOUND
expr_stmt|;
name|slotoffset
operator|=
name|u
operator|.
name|u_offset
expr_stmt|;
name|slotsize
operator|=
name|ep
operator|->
name|d_reclen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slotstatus
operator|==
name|NONE
condition|)
block|{
name|slotfreespace
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|slotoffset
operator|==
operator|-
literal|1
condition|)
name|slotoffset
operator|=
name|u
operator|.
name|u_offset
expr_stmt|;
if|if
condition|(
name|slotfreespace
operator|>=
name|slotneeded
condition|)
block|{
name|slotstatus
operator|=
name|COMPACT
expr_stmt|;
name|slotsize
operator|=
name|u
operator|.
name|u_offset
operator|+
name|ep
operator|->
name|d_reclen
operator|-
name|slotoffset
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 		 * Check for a name match. 		 */
if|if
condition|(
name|ep
operator|->
name|d_ino
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|d_namlen
operator|==
name|u
operator|.
name|u_dent
operator|.
name|d_namlen
operator|&&
operator|!
name|bcmp
argument_list|(
name|u
operator|.
name|u_dent
operator|.
name|d_name
argument_list|,
name|ep
operator|->
name|d_name
argument_list|,
name|ep
operator|->
name|d_namlen
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
name|prevoff
operator|=
name|u
operator|.
name|u_offset
expr_stmt|;
name|u
operator|.
name|u_offset
operator|+=
name|ep
operator|->
name|d_reclen
expr_stmt|;
name|entryoffsetinblock
operator|+=
name|ep
operator|->
name|d_reclen
expr_stmt|;
block|}
comment|/* notfound: */
comment|/* 	 * If creating, and at end of pathname and current 	 * directory has not been removed, then can consider 	 * allowing file to be created. 	 */
if|if
condition|(
name|flag
operator|==
name|CREATE
operator|&&
operator|*
name|cp
operator|==
literal|0
operator|&&
name|dp
operator|->
name|i_nlink
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Access for write is interpreted as allowing 		 * creation of files in the directory. 		 */
if|if
condition|(
name|access
argument_list|(
name|dp
argument_list|,
name|IWRITE
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* 		 * Return an indication of where the new directory 		 * entry should be put.  If we didn't find a slot, 		 * then set u.u_count to 0 indicating that the 		 * new slot belongs at the end of the directory. 		 * If we found a slot, then the new entry can be 		 * put in the range [u.u_offset..u.u_offset+u.u_count) 		 */
if|if
condition|(
name|slotstatus
operator|==
name|NONE
condition|)
name|u
operator|.
name|u_count
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|u
operator|.
name|u_offset
operator|=
name|slotoffset
expr_stmt|;
name|u
operator|.
name|u_count
operator|=
name|slotsize
expr_stmt|;
block|}
name|dp
operator|->
name|i_flag
operator||=
name|IUPD
operator||
name|ICHG
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
comment|/* 		 * We return with the directory locked, so that 		 * the parameters we set up above will still be 		 * valid if we actually decide to do a direnter(). 		 * We return NULL to indicate that the entry doesn't 		 * currently exist, leaving a pointer to the (locked) 		 * directory inode in u.u_pdir. 		 */
name|u
operator|.
name|u_pdir
operator|=
name|dp
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|u
operator|.
name|u_error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|bad
goto|;
name|found
label|:
comment|/* 	 * Check that directory length properly reflects presence 	 * of this entry. 	 */
if|if
condition|(
name|entryoffsetinblock
operator|+
name|DIRSIZ
argument_list|(
name|ep
argument_list|)
operator|>
name|dp
operator|->
name|i_size
condition|)
block|{
name|dirbad
argument_list|(
name|dp
argument_list|,
literal|"i_size too small"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_size
operator|=
name|entryoffsetinblock
operator|+
name|DIRSIZ
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_flag
operator||=
name|IUPD
operator||
name|ICHG
expr_stmt|;
block|}
comment|/* 	 * Found component in pathname; save directory 	 * entry in u.u_dent, and release directory buffer. 	 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ep
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|u
operator|.
name|u_dent
argument_list|,
operator|(
name|u_int
operator|)
name|DIRSIZ
argument_list|(
name|ep
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If deleting, and at end of pathname, return 	 * parameters which can be used to remove file. 	 * If the lockparent flag isn't set, we return only 	 * the directory (in u.u_pdir), otherwise we go 	 * on and lock the inode, being careful with ".". 	 */
if|if
condition|(
name|flag
operator|==
name|DELETE
operator|&&
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Write access to directory required to delete files. 		 */
if|if
condition|(
name|access
argument_list|(
name|dp
argument_list|,
name|IWRITE
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|u
operator|.
name|u_pdir
operator|=
name|dp
expr_stmt|;
comment|/* for dirremove() */
comment|/* 		 * Return pointer to current entry in u.u_offset, 		 * and distance past previous entry (if there 		 * is a previous entry in this block) in u.u_count. 		 * Save directory inode pointer in u.u_pdir for dirremove(). 		 */
if|if
condition|(
operator|(
name|u
operator|.
name|u_offset
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|u
operator|.
name|u_count
operator|=
literal|0
expr_stmt|;
else|else
name|u
operator|.
name|u_count
operator|=
name|u
operator|.
name|u_offset
operator|-
name|prevoff
expr_stmt|;
if|if
condition|(
name|lockparent
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|i_number
operator|==
name|u
operator|.
name|u_dent
operator|.
name|d_ino
condition|)
name|dp
operator|->
name|i_count
operator|++
expr_stmt|;
else|else
block|{
name|dp
operator|=
name|iget
argument_list|(
name|dp
operator|->
name|i_dev
argument_list|,
name|fs
argument_list|,
name|u
operator|.
name|u_dent
operator|.
name|d_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
name|iput
argument_list|(
name|u
operator|.
name|u_pdir
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
block|}
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
comment|/* 	 * Special handling for ".." allowing chdir out of mounted 	 * file system: indirect .. in root inode to reevaluate 	 * in directory file system was mounted on. 	 */
if|if
condition|(
name|u
operator|.
name|u_dent
operator|.
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|u
operator|.
name|u_dent
operator|.
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|u
operator|.
name|u_dent
operator|.
name|d_name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|dp
operator|==
name|u
operator|.
name|u_rdir
condition|)
name|u
operator|.
name|u_dent
operator|.
name|d_ino
operator|=
name|dp
operator|->
name|i_number
expr_stmt|;
elseif|else
if|if
condition|(
name|u
operator|.
name|u_dent
operator|.
name|d_ino
operator|==
name|ROOTINO
operator|&&
name|dp
operator|->
name|i_number
operator|==
name|ROOTINO
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NMOUNT
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mount
index|[
name|i
index|]
operator|.
name|m_bufp
operator|!=
name|NULL
operator|&&
name|mount
index|[
name|i
index|]
operator|.
name|m_dev
operator|==
name|dp
operator|->
name|i_dev
condition|)
block|{
name|iput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|mount
index|[
name|i
index|]
operator|.
name|m_inodp
expr_stmt|;
name|ilock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_count
operator|++
expr_stmt|;
name|fs
operator|=
name|dp
operator|->
name|i_fs
expr_stmt|;
name|cp
operator|-=
literal|2
expr_stmt|;
comment|/* back over .. */
goto|goto
name|dirloop2
goto|;
block|}
block|}
block|}
comment|/* 	 * If rewriting (rename), return the inode and the 	 * information required to rewrite the present directory 	 * Must get inode of directory entry to verify it's a 	 * regular file, or empty directory.   	 */
if|if
condition|(
operator|(
name|flag
operator|==
name|CREATE
operator|&&
name|lockparent
operator|)
operator|&&
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|dp
argument_list|,
name|IWRITE
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|u
operator|.
name|u_pdir
operator|=
name|dp
expr_stmt|;
comment|/* for dirrewrite() */
comment|/* 		 * Careful about locking second inode.  		 * This can only occur if the target is ".".  		 */
if|if
condition|(
name|dp
operator|->
name|i_number
operator|==
name|u
operator|.
name|u_dent
operator|.
name|d_ino
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EISDIR
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad
goto|;
block|}
name|dp
operator|=
name|iget
argument_list|(
name|dp
operator|->
name|i_dev
argument_list|,
name|fs
argument_list|,
name|u
operator|.
name|u_dent
operator|.
name|d_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
name|iput
argument_list|(
name|u
operator|.
name|u_pdir
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
comment|/* 	 * Check for symbolic link, which may require us 	 * to massage the name before we continue translation. 	 * To avoid deadlock have to unlock the current directory, 	 * but don't iput it because we may need it again (if 	 * the symbolic link is relative to .).  Instead save 	 * it (unlocked) as pdp. 	 */
name|pdp
operator|=
name|dp
expr_stmt|;
name|iunlock
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|iget
argument_list|(
name|dp
operator|->
name|i_dev
argument_list|,
name|fs
argument_list|,
name|u
operator|.
name|u_dent
operator|.
name|d_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
goto|goto
name|bad2
goto|;
name|fs
operator|=
name|dp
operator|->
name|i_fs
expr_stmt|;
comment|/* 	 * Check for symbolic link 	 */
if|if
condition|(
operator|(
name|dp
operator|->
name|i_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFLNK
operator|&&
operator|(
name|follow
operator|||
operator|*
name|cp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|u_int
name|pathlen
init|=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|i_size
operator|+
name|pathlen
operator|>=
name|MAXPATHLEN
operator|-
literal|1
operator|||
operator|++
name|nlink
operator|>
name|MAXSYMLINKS
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ELOOP
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|ovbcopy
argument_list|(
name|cp
argument_list|,
name|nbp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|dp
operator|->
name|i_size
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|rdwri
argument_list|(
name|UIO_READ
argument_list|,
name|dp
argument_list|,
name|nbp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
operator|(
name|int
operator|)
name|dp
operator|->
name|i_size
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
goto|goto
name|bad2
goto|;
name|cp
operator|=
name|nbp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|iput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
name|irele
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|u
operator|.
name|u_rdir
operator|)
operator|==
name|NULL
condition|)
name|dp
operator|=
name|rootdir
expr_stmt|;
name|ilock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|=
name|pdp
expr_stmt|;
name|ilock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
name|fs
operator|=
name|dp
operator|->
name|i_fs
expr_stmt|;
goto|goto
name|dirloop
goto|;
block|}
comment|/* 	 * Not a symbolic link.  If more pathname, 	 * continue at next component, else return. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|cp
operator|++
expr_stmt|;
name|irele
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
goto|goto
name|dirloop
goto|;
block|}
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockparent
condition|)
name|u
operator|.
name|u_pdir
operator|=
name|pdp
expr_stmt|;
else|else
name|irele
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
name|bad2
label|:
name|irele
argument_list|(
name|pdp
argument_list|)
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
condition|)
name|iput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_macro
name|dirbad
argument_list|(
argument|ip
argument_list|,
argument|how
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|how
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%s: bad dir ino %d at offset %d: %s\n"
argument_list|,
name|ip
operator|->
name|i_fs
operator|->
name|fs_fsmnt
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|u
operator|.
name|u_offset
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dirbadname
argument_list|(
name|ep
argument_list|)
specifier|register
expr|struct
name|direct
operator|*
name|ep
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|d_namlen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|d_name
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|ep
operator|->
name|d_name
index|[
name|i
index|]
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Write a directory entry after a call to namei, using the parameters  * which it left in the u. area.  The argument ip is the inode which  * the new directory entry will refer to.  The u. area field u.u_pdir is  * a pointer to the directory to be written, which was left locked by  * namei.  Remaining parameters (u.u_offset, u.u_count) indicate  * how the space for the new entry is to be gotten.  */
end_comment

begin_macro
name|direnter
argument_list|(
argument|ip
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|direct
modifier|*
name|ep
decl_stmt|,
modifier|*
name|nep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|loc
decl_stmt|,
name|freespace
decl_stmt|;
name|u_int
name|dsize
decl_stmt|;
name|int
name|newentrysize
decl_stmt|;
name|char
modifier|*
name|dirbuf
decl_stmt|;
name|u
operator|.
name|u_dent
operator|.
name|d_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|u
operator|.
name|u_segflg
operator|=
literal|1
expr_stmt|;
name|newentrysize
operator|=
name|DIRSIZ
argument_list|(
operator|&
name|u
operator|.
name|u_dent
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If u.u_count is 0, then namei could find no space in the 		 * directory.  In this case u.u_offset will be on a directory 		 * block boundary and we will write the new entry into a fresh 		 * block. 		 */
if|if
condition|(
name|u
operator|.
name|u_offset
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
condition|)
name|panic
argument_list|(
literal|"wdir: newblk"
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_dent
operator|.
name|d_reclen
operator|=
name|DIRBLKSIZ
expr_stmt|;
operator|(
name|void
operator|)
name|rdwri
argument_list|(
name|UIO_WRITE
argument_list|,
name|u
operator|.
name|u_pdir
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|u
operator|.
name|u_dent
argument_list|,
name|newentrysize
argument_list|,
name|u
operator|.
name|u_offset
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|u
operator|.
name|u_pdir
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If u.u_count is non-zero, then namei found space for the 	 * new entry in the range u.u_offset to u.u_offset+u.u_count. 	 * in the directory.  To use this space, we may have to compact 	 * the entries located there, by copying them together towards 	 * the beginning of the block, leaving the free space in 	 * one usable chunk at the end. 	 */
comment|/* 	 * Increase size of directory if entry eats into new space. 	 * This should never push the size past a new multiple of 	 * DIRBLKSIZE. 	 */
if|if
condition|(
name|u
operator|.
name|u_offset
operator|+
name|u
operator|.
name|u_count
operator|>
name|u
operator|.
name|u_pdir
operator|->
name|i_size
condition|)
name|u
operator|.
name|u_pdir
operator|->
name|i_size
operator|=
name|u
operator|.
name|u_offset
operator|+
name|u
operator|.
name|u_count
expr_stmt|;
comment|/* 	 * Get the block containing the space for the new directory 	 * entry. 	 */
name|bp
operator|=
name|blkatoff
argument_list|(
name|u
operator|.
name|u_pdir
argument_list|,
name|u
operator|.
name|u_offset
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|dirbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
block|{
name|iput
argument_list|(
name|u
operator|.
name|u_pdir
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Find space for the new entry.  In the simple case, the 	 * entry at offset base will have the space.  If it does 	 * not, then namei arranged that compacting the region 	 * u.u_offset to u.u_offset+u.u_count would yield the space. 	 */
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|dirbuf
expr_stmt|;
name|dsize
operator|=
name|DIRSIZ
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|freespace
operator|=
name|ep
operator|->
name|d_reclen
operator|-
name|dsize
expr_stmt|;
for|for
control|(
name|loc
operator|=
name|ep
operator|->
name|d_reclen
init|;
name|loc
operator|<
name|u
operator|.
name|u_count
condition|;
control|)
block|{
name|nep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|dirbuf
operator|+
name|loc
operator|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|d_ino
condition|)
block|{
comment|/* trim the existing slot */
name|ep
operator|->
name|d_reclen
operator|=
name|dsize
expr_stmt|;
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ep
operator|+
name|dsize
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* overwrite; nothing there; header is ours */
name|freespace
operator|+=
name|dsize
expr_stmt|;
block|}
name|dsize
operator|=
name|DIRSIZ
argument_list|(
name|nep
argument_list|)
expr_stmt|;
name|freespace
operator|+=
name|nep
operator|->
name|d_reclen
operator|-
name|dsize
expr_stmt|;
name|loc
operator|+=
name|nep
operator|->
name|d_reclen
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|nep
argument_list|,
operator|(
name|caddr_t
operator|)
name|ep
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update the pointer fields in the previous entry (if any), 	 * copy in the new entry, and write out the block. 	 */
if|if
condition|(
name|ep
operator|->
name|d_ino
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|freespace
operator|+
name|dsize
operator|<
name|newentrysize
condition|)
name|panic
argument_list|(
literal|"wdir: compact1"
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_dent
operator|.
name|d_reclen
operator|=
name|freespace
operator|+
name|dsize
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|freespace
operator|<
name|newentrysize
condition|)
name|panic
argument_list|(
literal|"wdir: compact2"
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_dent
operator|.
name|d_reclen
operator|=
name|freespace
expr_stmt|;
name|ep
operator|->
name|d_reclen
operator|=
name|dsize
expr_stmt|;
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ep
operator|+
name|dsize
operator|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|u
operator|.
name|u_dent
argument_list|,
operator|(
name|caddr_t
operator|)
name|ep
argument_list|,
operator|(
name|u_int
operator|)
name|newentrysize
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_pdir
operator|->
name|i_flag
operator||=
name|IUPD
operator||
name|ICHG
expr_stmt|;
name|iput
argument_list|(
name|u
operator|.
name|u_pdir
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Remove a directory entry after a call to namei, using the  * parameters which it left in the u. area.  The u. entry  * u_offset contains the offset into the directory of the  * entry to be eliminated.  The u_count field contains the  * size of the previous record in the directory.  If this  * is 0, the first entry is being deleted, so we need only  * zero the inode number to mark the entry as free.  If the  * entry isn't the first in the directory, we must reclaim  * the space of the now empty record by adding the record size  * to the size of the previous entry.  */
end_comment

begin_macro
name|dirremove
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|inode
modifier|*
name|dp
init|=
name|u
operator|.
name|u_pdir
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|direct
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|u
operator|.
name|u_count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * First entry in block: set d_ino to zero. 		 */
name|u
operator|.
name|u_dent
operator|.
name|d_ino
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|rdwri
argument_list|(
name|UIO_WRITE
argument_list|,
name|dp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|u
operator|.
name|u_dent
argument_list|,
operator|(
name|int
operator|)
name|DIRSIZ
argument_list|(
operator|&
name|u
operator|.
name|u_dent
argument_list|)
argument_list|,
name|u
operator|.
name|u_offset
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Collapse new free space into previous entry. 		 */
name|bp
operator|=
name|blkatoff
argument_list|(
name|dp
argument_list|,
call|(
name|int
call|)
argument_list|(
name|u
operator|.
name|u_offset
operator|-
name|u
operator|.
name|u_count
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ep
operator|->
name|d_reclen
operator|+=
name|u
operator|.
name|u_dent
operator|.
name|d_reclen
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_flag
operator||=
name|IUPD
operator||
name|ICHG
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Rewrite an existing directory entry to point at the inode  * supplied.  The parameters describing the directory entry are  * set up by a call to namei.  */
end_comment

begin_macro
name|dirrewrite
argument_list|(
argument|dp
argument_list|,
argument|ip
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inode
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u
operator|.
name|u_dent
operator|.
name|d_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|rdwri
argument_list|(
name|UIO_WRITE
argument_list|,
name|dp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|u
operator|.
name|u_dent
argument_list|,
operator|(
name|int
operator|)
name|DIRSIZ
argument_list|(
operator|&
name|u
operator|.
name|u_dent
argument_list|)
argument_list|,
name|u
operator|.
name|u_offset
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return buffer with contents of block "offset"  * from the beginning of directory "ip".  If "res"  * is non-zero, fill it in with a pointer to the  * remaining space in the directory.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|blkatoff
parameter_list|(
name|ip
parameter_list|,
name|offset
parameter_list|,
name|res
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|char
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
specifier|register
name|struct
name|fs
modifier|*
name|fs
init|=
name|ip
operator|->
name|i_fs
decl_stmt|;
name|daddr_t
name|lbn
init|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|int
name|base
init|=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|int
name|bsize
init|=
name|blksize
argument_list|(
name|fs
argument_list|,
name|ip
argument_list|,
name|lbn
argument_list|)
decl_stmt|;
name|daddr_t
name|bn
init|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|bmap
argument_list|(
name|ip
argument_list|,
name|lbn
argument_list|,
name|B_WRITE
argument_list|,
name|base
argument_list|,
name|bsize
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bp
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_dev
argument_list|,
name|bn
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|res
condition|)
operator|*
name|res
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|base
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a directory is empty or not.  * Inode supplied must be locked.  */
end_comment

begin_expr_stmt
name|dirempty
argument_list|(
name|ip
argument_list|)
specifier|register
expr|struct
name|inode
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|off_t
name|off
decl_stmt|;
name|struct
name|direct
name|dbuf
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dp
init|=
operator|&
name|dbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|count
decl_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|ip
operator|->
name|i_size
condition|;
name|off
operator|+=
name|dp
operator|->
name|d_reclen
control|)
block|{
name|error
operator|=
name|rdwri
argument_list|(
name|UIO_READ
argument_list|,
name|ip
argument_list|,
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
argument_list|,
name|off
argument_list|,
literal|1
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
operator|-
name|count
expr_stmt|;
define|#
directive|define
name|MINDIRSIZ
value|(sizeof (struct direct) - (MAXNAMLEN + 1))
if|if
condition|(
name|error
operator|||
name|count
operator|<
name|MINDIRSIZ
operator|||
name|count
operator|<
name|DIRSIZ
argument_list|(
name|dp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dp
operator|->
name|d_namlen
operator|==
literal|1
operator|||
operator|(
name|dp
operator|->
name|d_namlen
operator|==
literal|2
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

