begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	kern_descrip.c	5.9	82/09/08	*/
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/proc.h"
end_include

begin_include
include|#
directive|include
file|"../h/conf.h"
end_include

begin_include
include|#
directive|include
file|"../h/file.h"
end_include

begin_include
include|#
directive|include
file|"../h/inline.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/mount.h"
end_include

begin_include
include|#
directive|include
file|"../h/descrip.h"
end_include

begin_comment
comment|/*  * Descriptor management.  */
end_comment

begin_comment
comment|/*  * TODO:  *	getf should be renamed  *	ufalloc side effects are gross  */
end_comment

begin_comment
comment|/*  * System calls on descriptors.  */
end_comment

begin_macro
name|getdtablesize
argument_list|()
end_macro

begin_block
block|{
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
name|NOFILE
expr_stmt|;
block|}
end_block

begin_macro
name|getdprop
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|d
decl_stmt|;
name|struct
name|dtype
modifier|*
name|dtypeb
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|dtype
name|adtype
decl_stmt|;
name|fp
operator|=
name|getf
argument_list|(
name|uap
operator|->
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
return|return;
name|adtype
operator|.
name|dt_type
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|adtype
operator|.
name|dt_protocol
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|adtype
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|dtypeb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dtype
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_macro
name|getdopt
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_macro
name|setdopt
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_macro
name|dup
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|i
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|i
operator|&
operator|~
literal|077
condition|)
block|{
name|uap
operator|->
name|i
operator|&=
literal|077
expr_stmt|;
name|dup2
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* XXX */
name|fp
operator|=
name|getf
argument_list|(
name|uap
operator|->
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
return|return;
name|j
operator|=
name|ufalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
return|return;
name|dupit
argument_list|(
name|j
argument_list|,
name|fp
argument_list|,
name|u
operator|.
name|u_pofile
index|[
name|uap
operator|->
name|i
index|]
operator|&
operator|(
name|RDLOCK
operator||
name|WRLOCK
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dup2
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|getf
argument_list|(
name|uap
operator|->
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|uap
operator|->
name|j
operator|<
literal|0
operator|||
name|uap
operator|->
name|j
operator|>=
name|NOFILE
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EBADF
expr_stmt|;
return|return;
block|}
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
name|uap
operator|->
name|j
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|i
operator|==
name|uap
operator|->
name|j
condition|)
return|return;
if|if
condition|(
name|u
operator|.
name|u_ofile
index|[
name|uap
operator|->
name|j
index|]
condition|)
block|{
name|closef
argument_list|(
name|u
operator|.
name|u_ofile
index|[
name|uap
operator|->
name|j
index|]
argument_list|,
literal|0
argument_list|,
name|u
operator|.
name|u_pofile
index|[
name|uap
operator|->
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
return|return;
comment|/* u.u_ofile[uap->j] = 0; */
comment|/* u.u_pofile[uap->j] = 0; */
block|}
name|dupit
argument_list|(
name|uap
operator|->
name|j
argument_list|,
name|fp
argument_list|,
name|u
operator|.
name|u_pofile
index|[
name|uap
operator|->
name|i
index|]
operator|&
operator|(
name|RDLOCK
operator||
name|WRLOCK
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dupit
argument_list|(
argument|fd
argument_list|,
argument|fp
argument_list|,
argument|lockflags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|lockflags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u
operator|.
name|u_ofile
index|[
name|fd
index|]
operator|=
name|fp
expr_stmt|;
name|u
operator|.
name|u_pofile
index|[
name|fd
index|]
operator|=
name|lockflags
expr_stmt|;
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
if|if
condition|(
name|lockflags
operator|&
name|RDLOCK
condition|)
name|fp
operator|->
name|f_inode
operator|->
name|i_rdlockc
operator|++
expr_stmt|;
if|if
condition|(
name|lockflags
operator|&
name|WRLOCK
condition|)
name|fp
operator|->
name|f_inode
operator|->
name|i_wrlockc
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|close
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|i
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|getf
argument_list|(
name|uap
operator|->
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
return|return;
name|closef
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|u
operator|.
name|u_pofile
index|[
name|uap
operator|->
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* WHAT IF u.u_error ? */
name|u
operator|.
name|u_ofile
index|[
name|uap
operator|->
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|u
operator|.
name|u_pofile
index|[
name|uap
operator|->
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|wrap
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|d
decl_stmt|;
name|struct
name|dtype
modifier|*
name|dtypeb
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|dtype
name|adtype
decl_stmt|;
name|fp
operator|=
name|getf
argument_list|(
name|uap
operator|->
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|dtypeb
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|adtype
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dtype
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
comment|/* DO WRAP */
block|}
end_block

begin_function_decl
name|int
name|unselect
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|nselcoll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Select system call.  */
end_comment

begin_macro
name|select
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|uap
block|{
name|long
modifier|*
name|ibits
decl_stmt|;
name|long
modifier|*
name|obits
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|uap
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|int
name|ibits
index|[
literal|3
index|]
decl_stmt|,
name|obits
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|timeval
name|atv
decl_stmt|;
name|int
name|s
decl_stmt|,
name|tsel
decl_stmt|,
name|ncoll
decl_stmt|,
name|rem
decl_stmt|;
name|label_t
name|lqsave
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|tv
condition|)
block|{
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tv
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|atv
argument_list|,
sizeof|sizeof
argument_list|(
name|atv
argument_list|)
argument_list|)
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|atv
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|ibits
argument_list|,
operator|(
name|caddr_t
operator|)
name|ibits
argument_list|,
sizeof|sizeof
argument_list|(
name|ibits
argument_list|)
argument_list|)
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
name|retry
label|:
name|ncoll
operator|=
name|nselcoll
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator||=
name|SSEL
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
name|selscan
argument_list|(
name|ibits
argument_list|,
name|obits
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
return|return;
if|if
condition|(
name|u
operator|.
name|u_r
operator|.
name|r_val1
condition|)
goto|goto
name|done
goto|;
name|s
operator|=
name|spl6
argument_list|()
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|tv
operator|&&
name|timercmp
argument_list|(
operator|&
name|atv
argument_list|,
operator|&
name|time
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&
name|SSEL
operator|)
operator|==
literal|0
operator|||
name|nselcoll
operator|!=
name|ncoll
condition|)
block|{
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&=
operator|~
name|SSEL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&=
operator|~
name|SSEL
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|tv
condition|)
block|{
name|lqsave
operator|=
name|u
operator|.
name|u_qsave
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
operator|&
name|u
operator|.
name|u_qsave
argument_list|)
condition|)
block|{
name|untimeout
argument_list|(
name|unselect
argument_list|,
name|u
operator|.
name|u_procp
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|EINTR
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|timeout
argument_list|(
name|unselect
argument_list|,
name|u
operator|.
name|u_procp
argument_list|,
name|hzto
argument_list|(
operator|&
name|atv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|selwait
argument_list|,
name|PZERO
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|tv
condition|)
block|{
name|u
operator|.
name|u_qsave
operator|=
name|lqsave
expr_stmt|;
name|untimeout
argument_list|(
name|unselect
argument_list|,
name|u
operator|.
name|u_procp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
name|done
label|:
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|obits
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|obits
argument_list|,
sizeof|sizeof
argument_list|(
name|obits
argument_list|)
argument_list|)
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|unselect
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|s
init|=
name|spl6
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|p_stat
condition|)
block|{
case|case
name|SSLEEP
case|:
name|setrun
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSTOP
case|:
name|unsleep
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|selscan
argument_list|(
argument|ibits
argument_list|,
argument|obits
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|ibits
decl_stmt|,
modifier|*
name|obits
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|which
decl_stmt|,
name|bits
decl_stmt|,
name|i
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|able
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|which
operator|=
literal|0
init|;
name|which
operator|<
literal|3
condition|;
name|which
operator|++
control|)
block|{
name|bits
operator|=
name|ibits
index|[
name|which
index|]
expr_stmt|;
name|obits
index|[
name|which
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
name|flag
operator|=
name|FREAD
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|flag
operator|=
name|FWRITE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|flag
operator|=
literal|0
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|i
operator|=
name|ffs
argument_list|(
name|bits
argument_list|)
condition|)
block|{
name|bits
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|fp
operator|=
name|u
operator|.
name|u_ofile
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_SOCKET
condition|)
name|able
operator|=
name|soselect
argument_list|(
name|fp
operator|->
name|f_socket
argument_list|,
name|flag
argument_list|)
expr_stmt|;
else|else
block|{
name|ip
operator|=
name|fp
operator|->
name|f_inode
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|i_mode
operator|&
name|IFMT
condition|)
block|{
case|case
name|IFCHR
case|:
name|able
operator|=
operator|(
operator|*
name|cdevsw
index|[
name|major
argument_list|(
name|ip
operator|->
name|i_rdev
argument_list|)
index|]
operator|.
name|d_select
operator|)
operator|(
name|ip
operator|->
name|i_rdev
operator|,
name|flag
operator|)
expr_stmt|;
break|break;
case|case
name|IFBLK
case|:
case|case
name|IFREG
case|:
case|case
name|IFDIR
case|:
name|able
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|able
condition|)
block|{
name|obits
index|[
name|which
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|seltrue
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|selwakeup
argument_list|(
name|p
argument_list|,
name|coll
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|coll
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|coll
condition|)
block|{
name|nselcoll
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|selwait
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_wchan
operator|==
operator|(
name|caddr_t
operator|)
operator|&
name|selwait
condition|)
name|setrun
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|s
operator|=
name|spl6
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SSEL
condition|)
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|SSEL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|revoke
argument_list|()
end_macro

begin_block
block|{
comment|/* XXX */
block|}
end_block

begin_comment
comment|/*  * Allocate a user file descriptor.  */
end_comment

begin_macro
name|ufalloc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOFILE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|u
operator|.
name|u_ofile
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
name|i
expr_stmt|;
name|u
operator|.
name|u_pofile
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|u
operator|.
name|u_error
operator|=
name|EMFILE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|struct
name|file
modifier|*
name|lastf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate a user file descriptor  * and a file structure.  * Initialize the descriptor  * to point at the file structure.  */
end_comment

begin_function
name|struct
name|file
modifier|*
name|falloc
parameter_list|()
block|{
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|i
operator|=
name|ufalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|lastf
operator|==
literal|0
condition|)
name|lastf
operator|=
name|file
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|lastf
init|;
name|fp
operator|<
name|fileNFILE
condition|;
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
literal|0
condition|)
goto|goto
name|slot
goto|;
for|for
control|(
name|fp
operator|=
name|file
init|;
name|fp
operator|<
name|lastf
condition|;
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
literal|0
condition|)
goto|goto
name|slot
goto|;
name|tablefull
argument_list|(
literal|"file"
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|ENFILE
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
name|slot
label|:
name|u
operator|.
name|u_ofile
index|[
name|i
index|]
operator|=
name|fp
expr_stmt|;
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
name|fp
operator|->
name|f_offset
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|f_inode
operator|=
literal|0
expr_stmt|;
name|lastf
operator|=
name|fp
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a user supplied file descriptor into a pointer  * to a file structure.  Only task is to check range of the descriptor.  * Critical paths should use the GETF macro, defined in inline.h.  */
end_comment

begin_function
name|struct
name|file
modifier|*
name|getf
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|f
operator|>=
name|NOFILE
operator|||
operator|(
name|fp
operator|=
name|u
operator|.
name|u_ofile
index|[
name|f
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal form of close.  * Decrement reference count on  * file structure.  * Also make sure the pipe protocol  * does not constipate.  *  * Decrement reference count on the inode following  * removal to the referencing file structure.  * Call device handler on last close.  * Nouser indicates that the user isn't available to present  * errors to.  *  * Handling locking at this level is RIDICULOUS.  */
end_comment

begin_expr_stmt
name|closef
argument_list|(
name|fp
argument_list|,
name|nouser
argument_list|,
name|flags
argument_list|)
specifier|register
expr|struct
name|file
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|nouser
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
specifier|register
name|int
function_decl|(
modifier|*
name|cfunc
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|fp
operator|->
name|f_count
operator|>
literal|1
condition|)
block|{
name|fp
operator|->
name|f_count
operator|--
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_SOCKET
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|soclose
argument_list|(
name|fp
operator|->
name|f_socket
argument_list|,
name|nouser
argument_list|)
expr_stmt|;
if|if
condition|(
name|nouser
operator|==
literal|0
operator|&&
name|u
operator|.
name|u_error
condition|)
return|return;
name|fp
operator|->
name|f_socket
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|f_count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|flag
operator|=
name|fp
operator|->
name|f_flag
expr_stmt|;
name|ip
operator|=
name|fp
operator|->
name|f_inode
expr_stmt|;
name|dev
operator|=
operator|(
name|dev_t
operator|)
name|ip
operator|->
name|i_rdev
expr_stmt|;
name|mode
operator|=
name|ip
operator|->
name|i_mode
operator|&
name|IFMT
expr_stmt|;
name|flags
operator|&=
name|RDLOCK
operator||
name|WRLOCK
expr_stmt|;
comment|/* conservative */
if|if
condition|(
name|flags
condition|)
name|funlocki
argument_list|(
name|ip
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ilock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|IFCHR
case|:
name|cfunc
operator|=
name|cdevsw
index|[
name|major
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|d_close
expr_stmt|;
break|break;
case|case
name|IFBLK
case|:
comment|/* 		 * We don't want to really close the device if it is mounted 		 */
for|for
control|(
name|mp
operator|=
name|mount
init|;
name|mp
operator|<
operator|&
name|mount
index|[
name|NMOUNT
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_bufp
operator|!=
name|NULL
operator|&&
name|mp
operator|->
name|m_dev
operator|==
name|dev
condition|)
return|return;
name|cfunc
operator|=
name|bdevsw
index|[
name|major
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|d_close
expr_stmt|;
break|break;
default|default:
return|return;
block|}
for|for
control|(
name|fp
operator|=
name|file
init|;
name|fp
operator|<
name|fileNFILE
condition|;
name|fp
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_SOCKET
condition|)
comment|/* XXX */
continue|continue;
if|if
condition|(
name|fp
operator|->
name|f_count
operator|&&
operator|(
name|ip
operator|=
name|fp
operator|->
name|f_inode
operator|)
operator|&&
name|ip
operator|->
name|i_rdev
operator|==
name|dev
operator|&&
operator|(
name|ip
operator|->
name|i_mode
operator|&
name|IFMT
operator|)
operator|==
name|mode
condition|)
return|return;
block|}
if|if
condition|(
name|mode
operator|==
name|IFBLK
condition|)
block|{
comment|/* 		 * On last close of a block device (that isn't mounted) 		 * we must invalidate any in core blocks 		 */
name|bflush
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|binval
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|cfunc
call|)
argument_list|(
name|dev
argument_list|,
name|flag
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|opause
argument_list|()
end_macro

begin_block
block|{
for|for
control|(
init|;
condition|;
control|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|u
argument_list|,
name|PSLEP
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

