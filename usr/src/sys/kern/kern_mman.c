begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1989 Regents of the University of California.  * All rights reserved.  *  * Redistribution is only permitted until one year after the first shipment  * of 4.4BSD by the Regents.  Otherwise, redistribution and use in source and  * binary forms are permitted provided that: (1) source distributions retain  * this entire copyright notice and comment, and (2) distributions including  * binaries display the following acknowledgement:  This product includes  * software developed by the University of California, Berkeley and its  * contributors'' in the documentation or other materials provided with the  * distribution and in all advertising materials mentioning features or use  * of this software.  Neither the name of the University nor the names of  * its contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)kern_mman.c	7.18 (Berkeley) 6/30/90  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"specdev.h"
end_include

begin_include
include|#
directive|include
file|"seg.h"
end_include

begin_include
include|#
directive|include
file|"acct.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"text.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"vadvise.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"trace.h"
end_include

begin_include
include|#
directive|include
file|"mman.h"
end_include

begin_include
include|#
directive|include
file|"mapmem.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"machine/reg.h"
end_include

begin_include
include|#
directive|include
file|"machine/psl.h"
end_include

begin_include
include|#
directive|include
file|"machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"machine/mtpr.h"
end_include

begin_comment
comment|/*  * The MMAP code here is temporary; it provides support  * only for mmaping devices such as frame buffers.  * All to be different next time...  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAPMEM
end_ifndef

begin_undef
undef|#
directive|undef
name|MMAP
end_undef

begin_comment
comment|/* XXX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MMAP
end_ifdef

begin_decl_stmt
name|struct
name|mapmemops
name|mmapops
init|=
block|{
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|sbrk
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|int
name|incr
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Not yet implemented */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|sstk
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|int
name|incr
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Not yet implemented */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|getpagesize
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|retval
operator|=
name|NBPG
operator|*
name|CLSIZE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|smmap
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_struct
specifier|register
struct|struct
name|args
block|{
name|caddr_t
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|prot
decl_stmt|;
name|int
name|share
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|MMAP
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
else|#
directive|else
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|struct
name|pte
modifier|*
name|dpte
decl_stmt|;
specifier|register
name|int
name|off
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fv
decl_stmt|,
name|lv
decl_stmt|,
name|pm
decl_stmt|,
argument_list|(
operator|*
name|mapfun
argument_list|)
argument_list|()
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|getvnode
argument_list|(
name|u
operator|.
name|u_ofile
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VCHR
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dev
operator|=
name|vp
operator|->
name|v_rdev
expr_stmt|;
name|mapfun
operator|=
name|cdevsw
index|[
name|major
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|d_mmap
expr_stmt|;
if|if
condition|(
name|mapfun
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|uap
operator|->
name|addr
operator|&
name|CLOFSET
operator|)
operator|||
operator|(
name|uap
operator|->
name|pos
operator|&
name|CLOFSET
operator|)
operator|||
name|uap
operator|->
name|len
operator|<=
literal|0
operator|||
operator|(
name|uap
operator|->
name|len
operator|&
name|CLOFSET
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|uap
operator|->
name|prot
operator|&
name|PROT_WRITE
operator|)
operator|&&
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|uap
operator|->
name|prot
operator|&
name|PROT_READ
operator|)
operator|&&
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|share
operator|!=
name|MAP_SHARED
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|uap
operator|->
name|len
condition|;
name|off
operator|+=
name|NBPG
control|)
if|if
condition|(
call|(
modifier|*
name|mapfun
call|)
argument_list|(
name|dev
argument_list|,
name|uap
operator|->
name|pos
operator|+
name|off
argument_list|,
name|uap
operator|->
name|prot
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Needs translation */
comment|/* 	 * Allocate a descriptor for this region and expand page 	 * table to accomodate. 	 */
if|if
condition|(
name|uap
operator|->
name|prot
operator|&
name|PROT_WRITE
condition|)
block|{
name|pm
operator|=
name|PG_UW
operator||
name|PG_FOD
operator||
name|PG_V
expr_stmt|;
name|off
operator|=
name|MM_RW
expr_stmt|;
block|}
else|else
block|{
name|pm
operator|=
name|PG_URKR
operator||
name|PG_FOD
operator||
name|PG_V
expr_stmt|;
name|off
operator|=
name|MM_RO
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
name|pm
operator||=
name|PG_CI
expr_stmt|;
name|off
operator||=
name|MM_CI
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|mmalloc
argument_list|(
name|p
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|uap
operator|->
name|addr
argument_list|,
name|uap
operator|->
name|len
argument_list|,
name|off
argument_list|,
operator|&
name|mmapops
argument_list|,
operator|&
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Now map it in. 	 * Can't use mmmapin() because of args to map function. 	 */
name|fv
operator|=
name|btop
argument_list|(
name|uap
operator|->
name|addr
argument_list|)
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|p
argument_list|,
name|fv
argument_list|)
expr_stmt|;
name|dpte
operator|=
name|dptopte
argument_list|(
name|p
argument_list|,
name|u
operator|.
name|u_dsize
argument_list|)
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|uap
operator|->
name|len
condition|;
name|off
operator|+=
name|NBPG
control|)
block|{
if|if
condition|(
operator|(
name|off
operator|&
name|CLOFSET
operator|)
operator|==
literal|0
operator|&&
name|pte
operator|<
name|dpte
condition|)
name|p
operator|->
name|p_rssize
operator|-=
name|vmemfree
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
name|pm
expr_stmt|;
name|pte
operator|->
name|pg_pfnum
operator|=
call|(
modifier|*
name|mapfun
call|)
argument_list|(
name|dev
argument_list|,
name|uap
operator|->
name|pos
operator|+
name|off
argument_list|,
name|uap
operator|->
name|prot
argument_list|)
expr_stmt|;
name|pte
operator|++
expr_stmt|;
block|}
name|newptes
argument_list|(
name|vtopte
argument_list|(
name|p
argument_list|,
name|fv
argument_list|)
argument_list|,
name|fv
argument_list|,
name|btoc
argument_list|(
name|uap
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_pofile
index|[
name|uap
operator|->
name|fd
index|]
operator||=
name|UF_MAPPED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* MMAP */
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|msync
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Not yet implemented */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|munmap
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_struct
specifier|register
struct|struct
name|args
block|{
name|caddr_t
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|MMAP
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
else|#
directive|else
specifier|register
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
name|caddr_t
name|eaddr
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|uap
operator|->
name|addr
operator|&
name|CLOFSET
operator|)
operator|||
name|uap
operator|->
name|len
operator|<=
literal|0
operator|||
operator|(
name|uap
operator|->
name|len
operator|&
name|CLOFSET
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Locate region mapping this range. If found, unmap it. 	 */
name|eaddr
operator|=
name|uap
operator|->
name|addr
operator|+
name|uap
operator|->
name|len
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|u
operator|.
name|u_mmap
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|mm_next
control|)
if|if
condition|(
name|mp
operator|->
name|mm_ops
operator|==
operator|&
name|mmapops
operator|&&
name|uap
operator|->
name|addr
operator|>=
name|mp
operator|->
name|mm_uva
operator|&&
name|eaddr
operator|<
name|mp
operator|->
name|mm_uva
operator|+
name|mp
operator|->
name|mm_size
condition|)
break|break;
if|if
condition|(
name|mp
operator|==
name|MMNIL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fd
operator|=
name|mp
operator|->
name|mm_id
expr_stmt|;
name|mmmapout
argument_list|(
name|p
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|mmfree
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * If no other range has this descriptor mapped, mark it as unmapped. 	 */
for|for
control|(
name|mp
operator|=
name|u
operator|.
name|u_mmap
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|mm_next
control|)
if|if
condition|(
name|mp
operator|->
name|mm_id
operator|==
name|fd
condition|)
break|break;
if|if
condition|(
name|mp
operator|==
name|MMNIL
condition|)
name|u
operator|.
name|u_pofile
index|[
name|fd
index|]
operator|&=
operator|~
name|UF_MAPPED
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
comment|/* MMAP */
block|}
end_block

begin_macro
name|munmapfd
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MMAP
name|struct
name|proc
modifier|*
name|p
init|=
name|u
operator|.
name|u_procp
decl_stmt|;
comment|/* XXX */
specifier|register
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|,
modifier|*
modifier|*
name|mpp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SVFORK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mpp
operator|=
operator|&
name|u
operator|.
name|u_mmap
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|*
name|mpp
init|;
name|mp
condition|;
name|mp
operator|=
operator|*
name|mpp
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|mm_ops
operator|==
operator|&
name|mmapops
operator|&&
name|mp
operator|->
name|mm_id
operator|==
name|fd
condition|)
block|{
name|mmmapout
argument_list|(
name|p
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|mmfree
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|mpp
operator|=
operator|&
name|mp
operator|->
name|mm_next
expr_stmt|;
block|}
endif|#
directive|endif
name|u
operator|.
name|u_pofile
index|[
name|fd
index|]
operator|&=
operator|~
name|UF_MAPPED
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|mprotect
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|prot
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Not yet implemented */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|madvise
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|behav
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Not yet implemented */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|mincore
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|vec
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Not yet implemented */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

begin_comment
comment|/* BEGIN DEFUNCT */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|obreak
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|char
modifier|*
name|nsiz
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|segsz_t
name|n
decl_stmt|,
name|d
decl_stmt|,
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * set n to new data size 	 */
name|n
operator|=
name|btoc
argument_list|(
name|uap
operator|->
name|nsiz
argument_list|)
operator|-
name|dptov
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
comment|/* 	 * since we can't pass a -ve argument for the difference to chksize, 	 * if d is negative, make ds equal to the final value and clear d. 	 * keep the real difference in n for later use in expand. 	 */
name|ds
operator|=
name|u
operator|.
name|u_dsize
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|d
operator|=
name|clrnd
argument_list|(
name|n
operator|-
name|u
operator|.
name|u_dsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ds
operator|+=
name|d
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ctob
argument_list|(
name|ds
operator|+
name|d
argument_list|)
operator|>
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_cur
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|chksize
argument_list|(
operator|(
name|u_int
operator|)
name|u
operator|.
name|u_tsize
argument_list|,
operator|(
name|u_int
operator|)
name|ds
argument_list|,
operator|(
name|u_int
operator|)
name|d
argument_list|,
operator|(
name|u_int
operator|)
name|u
operator|.
name|u_ssize
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|MAPMEM
comment|/* 	 * If change would conflict with any mapped memory segment 	 * return ENOMEM. 	 */
if|if
condition|(
name|u
operator|.
name|u_mmap
operator|&&
name|n
operator|!=
literal|0
condition|)
block|{
name|caddr_t
name|low
decl_stmt|,
name|high
decl_stmt|;
name|low
operator|=
operator|(
name|caddr_t
operator|)
name|ctob
argument_list|(
name|dptov
argument_list|(
name|p
argument_list|,
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|high
operator|=
name|low
operator|+
name|ctob
argument_list|(
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
operator|-
name|n
else|:
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmclash
argument_list|(
name|u
operator|.
name|u_mmap
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
operator|=
name|swpexpand
argument_list|(
name|ds
operator|+
name|d
argument_list|,
name|u
operator|.
name|u_ssize
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|p_mmsize
operator|&&
operator|(
name|p
operator|->
name|p_mmsize
operator|-=
name|n
operator|)
operator|<
literal|0
condition|)
name|p
operator|->
name|p_mmsize
operator|=
literal|0
expr_stmt|;
name|expand
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Macros for clearing a page's reference bits.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REFBIT
end_ifdef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_define
define|#
directive|define
name|uncache
parameter_list|(
name|pte
parameter_list|)
end_define

begin_comment
comment|/* XXX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CLRREF
parameter_list|(
name|pte
parameter_list|,
name|c
parameter_list|,
name|p
parameter_list|,
name|i
parameter_list|)
value|{ \ 	if (!isatpte(p, pte)) \ 		uncache(pte); \ 	if (pte->pg_u) { \ 		c =&cmap[pgtocm(pte->pg_pfnum)]; \ 		if (c->c_lock) \ 			continue; \ 		pte->pg_u = 0; \ 		if (anycl(pte, pg_m)) \ 			pte->pg_m = 1; \ 		distcl(pte); \ 		if (isatpte(p, pte)) \ 			distpte(p->p_textp, i, pte); \ 	} \ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CLRREF
parameter_list|(
name|pte
parameter_list|,
name|c
parameter_list|,
name|p
parameter_list|,
name|i
parameter_list|)
value|{ \ 	c =&cmap[pgtocm(pte->pg_pfnum)]; \ 	if (c->c_lock) \ 		continue; \ 	pte->pg_v = 0; \ 	if (anycl(pte, pg_m)) \ 		pte->pg_m = 1; \ 	distcl(pte); \ 	if (isatpte(p, pte)) \ 		distpte(p->p_textp, i, pte); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|ovadvise
argument_list|(
name|rp
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|rp
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|args
block|{
name|int
name|anom
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|oanom
init|=
name|rp
operator|->
name|p_flag
operator|&
name|SUANOM
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
specifier|register
name|unsigned
name|i
decl_stmt|;
name|trace
argument_list|(
name|TR_VADVISE
argument_list|,
name|uap
operator|->
name|anom
argument_list|,
name|rp
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|rp
operator|->
name|p_flag
operator|&=
operator|~
operator|(
name|SSEQL
operator||
name|SUANOM
operator|)
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|anom
condition|)
block|{
case|case
name|VA_ANOM
case|:
name|rp
operator|->
name|p_flag
operator||=
name|SUANOM
expr_stmt|;
break|break;
case|case
name|VA_SEQL
case|:
name|rp
operator|->
name|p_flag
operator||=
name|SSEQL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|oanom
operator|&&
operator|(
name|rp
operator|->
name|p_flag
operator|&
name|SUANOM
operator|)
operator|==
literal|0
operator|)
operator|||
name|uap
operator|->
name|anom
operator|==
name|VA_FLUSH
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rp
operator|->
name|p_dsize
condition|;
name|i
operator|+=
name|CLSIZE
control|)
block|{
name|pte
operator|=
name|dptopte
argument_list|(
name|rp
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAPMEM
comment|/* don't do mmap pages */
if|if
condition|(
name|pte
operator|->
name|pg_v
operator|&&
operator|!
name|pte
operator|->
name|pg_fod
condition|)
else|#
directive|else
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
endif|#
directive|endif
name|CLRREF
argument_list|(
name|pte
argument_list|,
name|c
argument_list|,
name|rp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uap
operator|->
name|anom
operator|==
name|VA_FLUSH
condition|)
block|{
comment|/* invalidate all pages */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rp
operator|->
name|p_ssize
condition|;
name|i
operator|+=
name|CLSIZE
control|)
block|{
name|pte
operator|=
name|sptopte
argument_list|(
name|rp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
name|CLRREF
argument_list|(
name|pte
argument_list|,
name|c
argument_list|,
name|rp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rp
operator|->
name|p_tsize
condition|;
name|i
operator|+=
name|CLSIZE
control|)
block|{
name|pte
operator|=
name|tptopte
argument_list|(
name|rp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
name|CLRREF
argument_list|(
name|pte
argument_list|,
name|c
argument_list|,
name|rp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
name|TBIAU
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|i386
argument_list|)
name|tlbflush
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* END DEFUNCT */
end_comment

begin_comment
comment|/*  * Grow the stack to include the SP; true return if successful.  * Clients do not care about the cause of the error.  */
end_comment

begin_macro
name|grow
argument_list|(
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|si
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|sp
operator|>=
name|USRSTACK
operator|-
name|ctob
argument_list|(
name|u
operator|.
name|u_ssize
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|si
operator|=
name|clrnd
argument_list|(
name|btoc
argument_list|(
operator|(
name|USRSTACK
operator|-
name|sp
operator|)
argument_list|)
operator|-
name|u
operator|.
name|u_ssize
operator|+
name|SINCR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctob
argument_list|(
name|si
argument_list|)
operator|>
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_STACK
index|]
operator|.
name|rlim_cur
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|chksize
argument_list|(
operator|(
name|u_int
operator|)
name|u
operator|.
name|u_tsize
argument_list|,
operator|(
name|u_int
operator|)
name|u
operator|.
name|u_dsize
argument_list|,
operator|(
name|u_int
operator|)
literal|0
argument_list|,
operator|(
name|u_int
operator|)
name|u
operator|.
name|u_ssize
operator|+
name|si
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|swpexpand
argument_list|(
name|u
operator|.
name|u_dsize
argument_list|,
name|u
operator|.
name|u_ssize
operator|+
name|si
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|expand
argument_list|(
name|si
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|MAPMEM
end_ifdef

begin_comment
comment|/*  * Called from vpassvm() after full context has been passed from fup to tup.  * Always called in the context of the parent.  NOTE: routines should NOT  * destroy regions.  */
end_comment

begin_macro
name|mmvfork
argument_list|(
argument|fup
argument_list|,
argument|tup
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|user
modifier|*
name|fup
decl_stmt|,
modifier|*
name|tup
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|;
name|tup
operator|->
name|u_mmap
operator|=
name|fup
operator|->
name|u_mmap
expr_stmt|;
name|fup
operator|->
name|u_mmap
operator|=
operator|(
expr|struct
name|mapmem
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|tup
operator|->
name|u_mmap
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|mm_next
control|)
if|if
condition|(
name|mp
operator|->
name|mm_ops
operator|->
name|mm_vfork
condition|)
call|(
modifier|*
name|mp
operator|->
name|mm_ops
operator|->
name|mm_vfork
call|)
argument_list|(
name|mp
argument_list|,
name|fup
argument_list|,
name|tup
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Called from procdup() for both parent and child.  If in parent  * we need to duplicate mapped memory regions.  In both parent and  * child, we call object specific routine.  */
end_comment

begin_macro
name|mmfork
argument_list|(
argument|pup
argument_list|,
argument|cup
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|user
modifier|*
name|pup
decl_stmt|,
modifier|*
name|cup
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|,
modifier|*
modifier|*
name|mpp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pup
condition|)
block|{
name|mmdup
argument_list|(
name|pup
argument_list|,
name|cup
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|pup
operator|->
name|u_mmap
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|mm_next
control|)
if|if
condition|(
name|mp
operator|->
name|mm_ops
operator|->
name|mm_fork
condition|)
call|(
modifier|*
name|mp
operator|->
name|mm_ops
operator|->
name|mm_fork
call|)
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpp
operator|=
operator|&
name|u
operator|.
name|u_mmap
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|*
name|mpp
init|;
name|mp
condition|;
name|mp
operator|=
operator|*
name|mpp
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|mm_ops
operator|->
name|mm_fork
condition|)
call|(
modifier|*
name|mp
operator|->
name|mm_ops
operator|->
name|mm_fork
call|)
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mpp
operator|==
name|mp
condition|)
name|mpp
operator|=
operator|&
name|mp
operator|->
name|mm_next
expr_stmt|;
block|}
name|error
operator|=
name|mmexpand
argument_list|(
name|u
operator|.
name|u_procp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Its not clear that having a seperate exec routine is useful since  * exec frees the address space immediately afterwards.  We probably  * need a post-exec hook to reestablish any mappings that persist  * across execs.  */
end_comment

begin_macro
name|mmexec
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|,
modifier|*
modifier|*
name|mpp
decl_stmt|;
name|int
name|error1
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|mpp
operator|=
operator|&
name|u
operator|.
name|u_mmap
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|*
name|mpp
init|;
name|mp
condition|;
name|mp
operator|=
operator|*
name|mpp
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|mm_ops
operator|->
name|mm_exec
condition|)
name|error
operator|=
call|(
modifier|*
name|mp
operator|->
name|mm_ops
operator|->
name|mm_exec
call|)
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mpp
operator|==
name|mp
condition|)
block|{
operator|*
name|mpp
operator|=
name|mp
operator|->
name|mm_next
expr_stmt|;
name|MMFREE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error1
operator|=
name|mmexpand
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|error1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|p_mmsize
condition|)
name|panic
argument_list|(
literal|"mmexec"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Called from exit just before releasing address space.  * We always reclaim resources regardless of what the object routine does.  */
end_comment

begin_macro
name|mmexit
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|,
modifier|*
modifier|*
name|mpp
decl_stmt|;
name|int
name|error1
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|mpp
operator|=
operator|&
name|u
operator|.
name|u_mmap
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|*
name|mpp
init|;
name|mp
condition|;
name|mp
operator|=
operator|*
name|mpp
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|mm_ops
operator|->
name|mm_exit
condition|)
name|error
operator|=
call|(
modifier|*
name|mp
operator|->
name|mm_ops
operator|->
name|mm_exit
call|)
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mpp
operator|==
name|mp
condition|)
block|{
operator|*
name|mpp
operator|=
name|mp
operator|->
name|mm_next
expr_stmt|;
name|MMFREE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error1
operator|=
name|mmexpand
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|error1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|p_mmsize
condition|)
name|panic
argument_list|(
literal|"mmexit"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Called from core just before dumping process image to core file.  * Used to unmap regions which cannot be dumped; e.g. a region mapping  * hardware registers which are write-only or must be accessed as bytes.  */
end_comment

begin_macro
name|mmcore
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|,
modifier|*
modifier|*
name|mpp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|error1
decl_stmt|,
name|changed
init|=
literal|0
decl_stmt|;
name|mpp
operator|=
operator|&
name|u
operator|.
name|u_mmap
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|*
name|mpp
init|;
name|mp
condition|;
name|mp
operator|=
operator|*
name|mpp
control|)
block|{
if|if
condition|(
operator|(
name|mp
operator|->
name|mm_prot
operator|&
name|MM_NOCORE
operator|)
operator|==
literal|0
condition|)
block|{
name|mpp
operator|=
operator|&
name|mp
operator|->
name|mm_next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mp
operator|->
name|mm_ops
operator|->
name|mm_exit
condition|)
name|error
operator|=
call|(
modifier|*
name|mp
operator|->
name|mm_ops
operator|->
name|mm_exit
call|)
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mpp
operator|==
name|mp
condition|)
block|{
operator|*
name|mpp
operator|=
name|mp
operator|->
name|mm_next
expr_stmt|;
name|MMFREE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|changed
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
operator|(
name|error1
operator|=
name|mmexpand
argument_list|(
name|p
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error1
operator|)
return|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Duplicate mapped memory regions in a forked process.  * XXX child may wind up short a few regions if not enough resources.  */
end_comment

begin_macro
name|mmdup
argument_list|(
argument|pu
argument_list|,
argument|cu
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|user
modifier|*
name|pu
decl_stmt|,
modifier|*
name|cu
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mapmem
modifier|*
name|pmp
decl_stmt|,
modifier|*
name|cmp
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|ppte
decl_stmt|,
modifier|*
name|cpte
decl_stmt|;
specifier|register
name|segsz_t
name|count
decl_stmt|;
comment|/* 	 * First duplicate the mmap chain 	 */
name|MMALLOC
argument_list|(
name|cu
operator|->
name|u_mmap
argument_list|)
expr_stmt|;
name|pmp
operator|=
name|pu
operator|->
name|u_mmap
expr_stmt|;
name|cmp
operator|=
name|cu
operator|->
name|u_mmap
expr_stmt|;
while|while
condition|(
name|pmp
operator|&&
name|cmp
condition|)
block|{
operator|*
name|cmp
operator|=
operator|*
name|pmp
expr_stmt|;
if|if
condition|(
name|pmp
operator|->
name|mm_next
condition|)
name|MMALLOC
argument_list|(
name|cmp
operator|->
name|mm_next
argument_list|)
expr_stmt|;
name|pmp
operator|=
name|pmp
operator|->
name|mm_next
expr_stmt|;
name|cmp
operator|=
name|cmp
operator|->
name|mm_next
expr_stmt|;
block|}
comment|/* 	 * Now duplicate user address space that vmdup() won't do 	 * i.e. mapped regions outside of data segment. 	 */
name|ppte
operator|=
name|dptopte
argument_list|(
name|pu
operator|->
name|u_procp
argument_list|,
name|pu
operator|->
name|u_procp
operator|->
name|p_dsize
argument_list|)
expr_stmt|;
name|cpte
operator|=
name|dptopte
argument_list|(
name|cu
operator|->
name|u_procp
argument_list|,
name|cu
operator|->
name|u_procp
operator|->
name|p_dsize
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
name|pu
operator|->
name|u_procp
operator|->
name|p_mmsize
init|;
name|count
condition|;
name|count
operator|--
control|)
block|{
if|if
condition|(
name|ppte
operator|->
name|pg_fod
operator|&&
name|ppte
operator|->
name|pg_v
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|cpte
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|ppte
expr_stmt|;
name|ppte
operator|++
operator|,
name|cpte
operator|++
expr_stmt|;
block|}
name|cu
operator|->
name|u_procp
operator|->
name|p_flag
operator||=
name|SPTECHG
expr_stmt|;
block|}
end_block

begin_macro
name|mmalloc
argument_list|(
argument|p
argument_list|,
argument|id
argument_list|,
argument|uvap
argument_list|,
argument|size
argument_list|,
argument|prot
argument_list|,
argument|ops
argument_list|,
argument|mpp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|uvap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|segsz_t
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mapmemops
modifier|*
name|ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mapmem
modifier|*
modifier|*
name|mpp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|;
specifier|register
name|u_int
name|uva
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Validate size first 	 */
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
operator|(
name|size
operator|&
name|CLOFSET
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * A uva of zero means to map at our discretion. 	 * Our strategy is to place the segment at the max of: 	 *	- the current data + mapped memory size 	 *	- the default data size limit 	 *	  (if it will fit within the MAXDSIZ limit) 	 * If this is the first mapped memory region beyond the data 	 * segment we round to a MMSEG boundary to allow for data 	 * segment growth. 	 */
name|uva
operator|=
operator|(
name|u_int
operator|)
operator|*
name|uvap
expr_stmt|;
if|if
condition|(
name|uva
operator|==
literal|0
condition|)
block|{
specifier|register
name|u_int
name|uva2
decl_stmt|;
name|uva
operator|=
name|ctob
argument_list|(
name|dptov
argument_list|(
name|p
argument_list|,
name|u
operator|.
name|u_dsize
operator|+
name|p
operator|->
name|p_mmsize
argument_list|)
argument_list|)
expr_stmt|;
name|uva2
operator|=
name|ctob
argument_list|(
name|dptov
argument_list|(
name|p
argument_list|,
name|btoc
argument_list|(
name|DFLDSIZ
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|uva2
operator|=
operator|(
operator|(
name|uva2
operator|+
operator|(
name|MMSEG
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|MMSEG
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|uva
operator|<
name|uva2
operator|&&
name|uva2
operator|+
name|size
operator|<
name|ctob
argument_list|(
name|dptov
argument_list|(
name|p
argument_list|,
name|btoc
argument_list|(
name|MAXDSIZ
argument_list|)
argument_list|)
argument_list|)
condition|)
name|uva
operator|=
name|uva2
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|p_mmsize
operator|==
literal|0
condition|)
name|uva
operator|=
operator|(
operator|(
name|uva
operator|+
operator|(
name|MMSEG
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|MMSEG
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
comment|/* 	 * Impose necessary constraints on address. 	 */
if|if
condition|(
operator|(
name|uva
operator|&
name|CLOFSET
operator|)
operator|||
name|uva
operator|<
name|ctob
argument_list|(
name|dptov
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|uva
operator|+
name|size
operator|>=
name|ctob
argument_list|(
name|sptov
argument_list|(
name|p
argument_list|,
name|u
operator|.
name|u_ssize
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mmclash
argument_list|(
name|u
operator|.
name|u_mmap
argument_list|,
operator|(
name|caddr_t
operator|)
name|uva
argument_list|,
operator|(
name|caddr_t
operator|)
name|uva
operator|+
name|size
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Finally, allocate and initialize descriptor and expand 	 * user address space as necessary. 	 */
name|MMALLOC
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|MMNIL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mp
operator|->
name|mm_next
operator|=
name|u
operator|.
name|u_mmap
expr_stmt|;
name|mp
operator|->
name|mm_id
operator|=
name|id
expr_stmt|;
name|mp
operator|->
name|mm_uva
operator|=
operator|(
name|caddr_t
operator|)
name|uva
expr_stmt|;
name|mp
operator|->
name|mm_size
operator|=
name|size
expr_stmt|;
name|mp
operator|->
name|mm_prot
operator|=
name|prot
expr_stmt|;
name|mp
operator|->
name|mm_ops
operator|=
name|ops
expr_stmt|;
name|u
operator|.
name|u_mmap
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|mmexpand
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|u
operator|.
name|u_mmap
operator|=
name|mp
operator|->
name|mm_next
expr_stmt|;
name|MMFREE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|uvap
operator|=
operator|(
name|caddr_t
operator|)
name|uva
expr_stmt|;
operator|*
name|mpp
operator|=
name|mp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|mmfree
argument_list|(
argument|p
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mapmem
modifier|*
name|cmp
decl_stmt|,
modifier|*
modifier|*
name|mpp
decl_stmt|;
comment|/* 	 * Remove region from chain 	 */
name|mpp
operator|=
operator|&
name|u
operator|.
name|u_mmap
expr_stmt|;
for|for
control|(
name|cmp
operator|=
operator|*
name|mpp
init|;
name|cmp
condition|;
name|cmp
operator|=
operator|*
name|mpp
control|)
block|{
if|if
condition|(
name|cmp
operator|==
name|mp
condition|)
break|break;
name|mpp
operator|=
operator|&
name|cmp
operator|->
name|mm_next
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|==
name|MMNIL
condition|)
name|panic
argument_list|(
literal|"mmfree"
argument_list|)
expr_stmt|;
operator|*
name|mpp
operator|=
name|mp
operator|->
name|mm_next
expr_stmt|;
name|MMFREE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|mmexpand
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mmmapin
argument_list|(
name|p
argument_list|,
name|mp
argument_list|,
name|mapfunc
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|mapfunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|off
decl_stmt|;
name|struct
name|pte
modifier|*
name|dpte
decl_stmt|;
name|int
name|pm
decl_stmt|,
name|fv
decl_stmt|,
name|lv
decl_stmt|;
comment|/* 	 * Verify that range can be mapped 	 */
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|mp
operator|->
name|mm_size
condition|;
name|off
operator|+=
name|NBPG
control|)
if|if
condition|(
call|(
modifier|*
name|mapfunc
call|)
argument_list|(
name|mp
argument_list|,
name|off
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Now verify that region is in range 	 */
name|fv
operator|=
name|btop
argument_list|(
name|mp
operator|->
name|mm_uva
argument_list|)
expr_stmt|;
name|lv
operator|=
name|btop
argument_list|(
name|mp
operator|->
name|mm_uva
operator|+
name|mp
operator|->
name|mm_size
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fv
operator|<
name|dptov
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|||
name|lv
operator|>=
name|dptov
argument_list|(
name|p
argument_list|,
name|u
operator|.
name|u_dsize
operator|+
name|p
operator|->
name|p_mmsize
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Finally, do the mapping. 	 */
if|if
condition|(
name|mp
operator|->
name|mm_prot
operator|&
name|MM_RO
condition|)
name|pm
operator|=
name|PG_URKR
operator||
name|PG_FOD
operator||
name|PG_V
expr_stmt|;
else|else
name|pm
operator|=
name|PG_UW
operator||
name|PG_FOD
operator||
name|PG_V
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
if|if
condition|(
name|mp
operator|->
name|mm_prot
operator|&
name|MM_CI
condition|)
name|pm
operator||=
name|PG_CI
expr_stmt|;
endif|#
directive|endif
name|pte
operator|=
name|vtopte
argument_list|(
name|p
argument_list|,
name|fv
argument_list|)
expr_stmt|;
name|dpte
operator|=
name|dptopte
argument_list|(
name|p
argument_list|,
name|u
operator|.
name|u_dsize
argument_list|)
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|mp
operator|->
name|mm_size
condition|;
name|off
operator|+=
name|NBPG
control|)
block|{
if|if
condition|(
operator|(
name|off
operator|&
name|CLOFSET
operator|)
operator|==
literal|0
operator|&&
name|pte
operator|<
name|dpte
condition|)
name|p
operator|->
name|p_rssize
operator|-=
name|vmemfree
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
name|pm
expr_stmt|;
name|pte
operator|->
name|pg_pfnum
operator|=
call|(
modifier|*
name|mapfunc
call|)
argument_list|(
name|mp
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|pte
operator|++
expr_stmt|;
block|}
name|newptes
argument_list|(
name|vtopte
argument_list|(
name|p
argument_list|,
name|fv
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
name|fv
argument_list|,
operator|(
name|int
operator|)
name|btoc
argument_list|(
name|mp
operator|->
name|mm_size
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mmmapout
argument_list|(
name|p
argument_list|,
name|mp
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|off
decl_stmt|;
name|struct
name|pte
modifier|*
name|dpte
decl_stmt|;
name|int
name|fv
decl_stmt|,
name|lv
decl_stmt|;
name|fv
operator|=
name|btop
argument_list|(
name|mp
operator|->
name|mm_uva
argument_list|)
expr_stmt|;
name|lv
operator|=
name|btop
argument_list|(
name|mp
operator|->
name|mm_uva
operator|+
name|mp
operator|->
name|mm_size
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fv
operator|<
name|dptov
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|||
name|lv
operator|>=
name|dptov
argument_list|(
name|p
argument_list|,
name|u
operator|.
name|u_dsize
operator|+
name|p
operator|->
name|p_mmsize
argument_list|)
condition|)
name|panic
argument_list|(
literal|"mmmapout"
argument_list|)
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|p
argument_list|,
name|fv
argument_list|)
expr_stmt|;
name|dpte
operator|=
name|dptopte
argument_list|(
name|p
argument_list|,
name|u
operator|.
name|u_dsize
argument_list|)
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|mp
operator|->
name|mm_size
condition|;
name|off
operator|+=
name|NBPG
control|)
block|{
if|if
condition|(
name|pte
operator|<
name|dpte
condition|)
block|{
if|if
condition|(
operator|(
name|off
operator|&
name|CLOFSET
operator|)
operator|==
literal|0
condition|)
name|p
operator|->
name|p_rssize
operator|-=
name|vmemfree
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
operator|(
name|PG_UW
operator||
name|PG_FOD
operator|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
name|pte
operator|)
operator|->
name|pg_fileno
operator|=
name|PG_FZERO
expr_stmt|;
block|}
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
literal|0
expr_stmt|;
name|pte
operator|++
expr_stmt|;
block|}
name|newptes
argument_list|(
name|vtopte
argument_list|(
name|p
argument_list|,
name|fv
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
name|fv
argument_list|,
operator|(
name|int
operator|)
name|btoc
argument_list|(
name|mp
operator|->
name|mm_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mmexpand
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|szpt
decl_stmt|,
name|change
decl_stmt|;
name|caddr_t
name|high
decl_stmt|;
name|segsz_t
name|nsize
decl_stmt|,
name|oms
decl_stmt|;
name|oms
operator|=
name|p
operator|->
name|p_mmsize
expr_stmt|;
comment|/* 	 * Get new mmsize based on existing regions and use 	 * that to calculate change in page table size. 	 */
if|if
condition|(
name|u
operator|.
name|u_mmap
condition|)
block|{
name|mmrange
argument_list|(
name|u
operator|.
name|u_mmap
argument_list|,
operator|(
name|caddr_t
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|high
argument_list|)
expr_stmt|;
name|nsize
operator|=
name|btop
argument_list|(
name|high
argument_list|)
operator|-
name|dptov
argument_list|(
name|p
argument_list|,
name|u
operator|.
name|u_dsize
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nsize
operator|<
literal|0
condition|)
name|nsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nsize
operator|=
literal|0
expr_stmt|;
name|change
operator|=
name|nsize
operator|-
name|oms
expr_stmt|;
if|if
condition|(
name|change
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Ensure data + mapped memory fits within maximum data limit. 	 * This is possibly a little restrictive, but it helps keep 	 * page table sizes down. 	 */
if|if
condition|(
name|change
operator|>
literal|0
operator|&&
operator|(
name|ctob
argument_list|(
name|oms
operator|+
name|change
argument_list|)
operator|>
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_max
operator|||
name|ctob
argument_list|(
name|u
operator|.
name|u_dsize
operator|+
name|oms
operator|+
name|change
argument_list|)
operator|>
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_max
operator|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Expand page table if necessary. 	 * Note that ptexpand takes care of flushing the translation buffer. 	 */
name|p
operator|->
name|p_mmsize
operator|+=
name|change
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
operator|||
name|defined
argument_list|(
name|i386
argument_list|)
name|szpt
operator|=
name|ptsize
argument_list|(
name|p
argument_list|)
operator|-
name|u
operator|.
name|u_pcb
operator|.
name|pcb_szpt
expr_stmt|;
if|if
condition|(
name|szpt
operator|>
literal|0
condition|)
name|ptexpand
argument_list|(
name|szpt
argument_list|,
name|u
operator|.
name|u_dsize
argument_list|,
name|oms
argument_list|,
name|u
operator|.
name|u_ssize
argument_list|)
expr_stmt|;
name|setp0lr
argument_list|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0lr
operator|+
name|change
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
name|szpt
operator|=
operator|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1br
operator|+
operator|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1lr
operator|&
operator|~
name|PME_CLR
operator|)
operator|)
operator|-
operator|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0br
operator|+
operator|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0lr
operator|&
operator|~
name|AST_CLR
operator|)
operator|)
expr_stmt|;
else|#
directive|else
name|szpt
operator|=
operator|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p2br
operator|+
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p2lr
operator|)
operator|-
operator|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0br
operator|+
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0lr
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|change
operator|>
name|szpt
condition|)
name|ptexpand
argument_list|(
name|clrnd
argument_list|(
name|ctopt
argument_list|(
name|change
operator|-
name|szpt
argument_list|)
argument_list|)
argument_list|,
name|u
operator|.
name|u_dsize
argument_list|,
name|oms
argument_list|,
name|u
operator|.
name|u_ssize
argument_list|)
expr_stmt|;
comment|/* 	 * Clear new ptes. 	 * We need to do this because there may be bogus (yet technically 	 * valid) ptes above the old p0lr value.  This can happen if the 	 * data segment has shrunk in the past leaving such ptes behind. 	 * There is no need to invalidate such ptes at that time since the 	 * length register will prevent their use.  We are safe on the HPs 	 * because we do invalidate old ptes in setp0lr() when shrinking. 	 */
if|if
condition|(
name|change
operator|>
literal|0
condition|)
block|{
name|struct
name|pte
modifier|*
name|bpte
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
name|bpte
operator|=
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0br
operator|+
operator|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0lr
operator|&
operator|~
name|AST_CLR
operator|)
expr_stmt|;
else|#
directive|else
name|bpte
operator|=
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0br
operator|+
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0lr
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|bpte
argument_list|,
name|change
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* avoid side-effects of setp0lr */
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
name|change
operator|+=
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0lr
operator|&
operator|~
name|AST_CLR
expr_stmt|;
else|#
directive|else
name|change
operator|+=
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0lr
expr_stmt|;
endif|#
directive|endif
name|setp0lr
argument_list|(
name|change
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mmrange
argument_list|(
name|mp
argument_list|,
name|lap
argument_list|,
name|hap
argument_list|)
specifier|register
expr|struct
name|mapmem
operator|*
name|mp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|lap
decl_stmt|,
modifier|*
name|hap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|caddr_t
name|low
decl_stmt|,
name|high
decl_stmt|,
name|top
decl_stmt|;
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mp
condition|)
block|{
if|if
condition|(
name|low
operator|==
literal|0
operator|||
name|mp
operator|->
name|mm_uva
operator|<
name|low
condition|)
name|low
operator|=
name|mp
operator|->
name|mm_uva
expr_stmt|;
name|top
operator|=
name|mp
operator|->
name|mm_uva
operator|+
name|mp
operator|->
name|mm_size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|high
operator|==
literal|0
operator|||
name|top
operator|>
name|high
condition|)
name|high
operator|=
name|top
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|mm_next
expr_stmt|;
block|}
if|if
condition|(
name|lap
condition|)
operator|*
name|lap
operator|=
name|low
expr_stmt|;
if|if
condition|(
name|hap
condition|)
operator|*
name|hap
operator|=
name|high
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|mmclash
argument_list|(
name|mp
argument_list|,
name|la
argument_list|,
name|ha
argument_list|)
specifier|register
expr|struct
name|mapmem
operator|*
name|mp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|la
decl_stmt|,
name|ha
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|mp
condition|)
block|{
if|if
condition|(
name|ha
operator|>
name|mp
operator|->
name|mm_uva
operator|&&
name|la
operator|<
name|mp
operator|->
name|mm_uva
operator|+
name|mp
operator|->
name|mm_size
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|mp
operator|=
name|mp
operator|->
name|mm_next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAPMEM */
end_comment

end_unit

