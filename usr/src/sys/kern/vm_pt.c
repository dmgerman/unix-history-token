begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1989 Regents of the University of California.  * All rights reserved.  *  * Redistribution is only permitted until one year after the first shipment  * of 4.4BSD by the Regents.  Otherwise, redistribution and use in source and  * binary forms are permitted provided that: (1) source distributions retain  * this entire copyright notice and comment, and (2) distributions including  * binaries display the following acknowledgement:  This product includes  * software developed by the University of California, Berkeley and its  * contributors'' in the documentation or other materials provided with the  * distribution and in all advertising materials mentioning features or use  * of this software.  Neither the name of the University nor the names of  * its contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)vm_pt.c	7.14 (Berkeley) 6/30/90  */
end_comment

begin_include
include|#
directive|include
file|"machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"machine/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"text.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_comment
comment|/*  * Get page tables for process p.  Allocator  * for memory is argument; process must be locked  * from swapping if vmemall is used; if memall is  * used, call will return w/o waiting for memory.  * In any case an error return results if no user  * page table space is available.  */
end_comment

begin_expr_stmt
name|vgetpt
argument_list|(
name|p
argument_list|,
name|pmemall
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|pmemall
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|long
name|a
decl_stmt|;
specifier|register
name|int
name|szpt
init|=
name|p
operator|->
name|p_szpt
decl_stmt|;
if|if
condition|(
name|szpt
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"vgetpt"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
operator|||
name|defined
argument_list|(
name|i386
argument_list|)
comment|/* 	 * Allocate a single page segment/paage directory table as well 	 * as page tables. 	 */
name|szpt
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate space in the kernel map for this process. 	 * Then allocate page table pages, and initialize the 	 * process' p0br and addr pointer to be the kernel 	 * virtual addresses of the base of the page tables and 	 * the pte for the process pcb (at the base of the u.). 	 */
name|a
operator|=
name|rmalloc
argument_list|(
name|kernelmap
argument_list|,
operator|(
name|long
operator|)
name|szpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
call|(
modifier|*
name|pmemall
call|)
argument_list|(
operator|&
name|Usrptmap
index|[
name|a
index|]
argument_list|,
name|szpt
argument_list|,
name|p
argument_list|,
name|CSYS
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rmfree
argument_list|(
name|kernelmap
argument_list|,
operator|(
name|long
operator|)
name|szpt
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|->
name|p_p0br
operator|=
name|kmxtob
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_addr
operator|=
name|uaddr
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Now validate the system page table entries for the 	 * user page table pages, flushing old translations 	 * for these kernel virtual addresses.  Clear the new 	 * page table pages for clean post-mortems. 	 */
name|vmaccess
argument_list|(
operator|&
name|Usrptmap
index|[
name|a
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_p0br
argument_list|,
name|szpt
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_p0br
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|szpt
operator|*
name|NBPG
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
comment|/* cache inhibit page tables pages so HW set bits are always valid */
for|for
control|(
name|szpt
operator|=
name|a
operator|+
name|szpt
operator|-
literal|1
init|;
name|szpt
operator|>=
name|a
condition|;
operator|--
name|szpt
control|)
name|Usrptmap
index|[
name|szpt
index|]
operator|.
name|pg_ci
operator|=
literal|1
expr_stmt|;
name|initsegt
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|i386
argument_list|)
name|initpdt
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Initialize text portion of page table.  */
end_comment

begin_macro
name|vinitpt
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|pte
name|proto
decl_stmt|;
name|xp
operator|=
name|p
operator|->
name|p_textp
expr_stmt|;
if|if
condition|(
name|xp
operator|==
literal|0
condition|)
return|return;
name|pte
operator|=
name|tptopte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If there is another instance of same text in core 	 * then just copy page tables from other process. 	 */
if|if
condition|(
name|q
operator|=
name|xp
operator|->
name|x_caddr
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tptopte
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|pte
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
operator|*
name|xp
operator|->
name|x_size
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|xp
operator|->
name|x_flag
operator|&
name|XLOAD
operator|||
operator|(
name|xp
operator|->
name|x_flag
operator|&
name|XPAGV
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Initialize text page tables, zfod if we are loading 		 * the text now; unless the process is demand loaded, 		 * this will suffice as the text will henceforth either be 		 * read from a file or demand paged in. 		 */
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|proto
operator|=
name|PG_URKR
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|x_flag
operator|&
name|XLOAD
condition|)
block|{
name|proto
operator|.
name|pg_fod
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
operator|&
name|proto
operator|)
operator|->
name|pg_fileno
operator|=
name|PG_FZERO
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xp
operator|->
name|x_size
condition|;
name|i
operator|++
control|)
operator|*
name|pte
operator|++
operator|=
name|proto
expr_stmt|;
if|if
condition|(
operator|(
name|xp
operator|->
name|x_flag
operator|&
name|XPAGV
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Text is demand loaded.  If process is not loaded (i.e. being 	 * swapped in) then retrieve page tables from swap area.  Otherwise 	 * this is the first time and we must initialize the page tables 	 * from the blocks in the file system. 	 */
if|if
condition|(
name|xp
operator|->
name|x_flag
operator|&
name|XLOAD
condition|)
name|vinifod
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|fpte
operator|*
operator|)
name|tptopte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PG_FTEXT
argument_list|,
name|xp
operator|->
name|x_vptr
argument_list|,
operator|(
name|daddr_t
operator|)
literal|1
argument_list|,
name|xp
operator|->
name|x_size
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|swap
argument_list|(
name|p
argument_list|,
name|xp
operator|->
name|x_ptdaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|tptopte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|xp
operator|->
name|x_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|)
argument_list|,
name|B_READ
argument_list|,
name|B_PAGET
argument_list|,
name|swapdev_vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * In the case where we are overlaying ourself with new page 	 * table entries, old user-space translations should be flushed. 	 */
if|if
condition|(
name|p
operator|==
name|u
operator|.
name|u_procp
condition|)
name|newptes
argument_list|(
name|tptopte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tptov
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|xp
operator|->
name|x_size
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|p_flag
operator||=
name|SPTECHG
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Update the page tables of all processes linked  * to a particular text segment, by distributing  * dpte to the the text page at virtual frame v.  *  * Note that invalidation in the translation buffer for  * the current process is the responsibility of the caller.  */
end_comment

begin_macro
name|distpte
argument_list|(
argument|xp
argument_list|,
argument|tp
argument_list|,
argument|dpte
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|pte
modifier|*
name|dpte
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|p
operator|=
name|xp
operator|->
name|x_caddr
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|p_xlink
control|)
block|{
name|pte
operator|=
name|tptopte
argument_list|(
name|p
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|SPTECHG
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|dpte
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLSIZE
condition|;
name|i
operator|++
control|)
name|pte
index|[
name|i
index|]
operator|=
name|dpte
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Release page tables of process p.  */
end_comment

begin_expr_stmt
name|vrelpt
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|a
decl_stmt|;
specifier|register
name|int
name|szpt
init|=
name|p
operator|->
name|p_szpt
decl_stmt|;
if|if
condition|(
name|szpt
operator|==
literal|0
condition|)
return|return;
name|a
operator|=
name|btokmx
argument_list|(
name|p
operator|->
name|p_p0br
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
name|flushustp
argument_list|(
name|initustp
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't forget the segment table */
name|szpt
operator|++
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|i386
argument_list|)
comment|/* don't forget the page directory table */
name|szpt
operator|++
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|vmemfree
argument_list|(
operator|&
name|Usrptmap
index|[
name|a
index|]
argument_list|,
name|szpt
argument_list|)
expr_stmt|;
name|rmfree
argument_list|(
name|kernelmap
argument_list|,
operator|(
name|long
operator|)
name|szpt
argument_list|,
operator|(
name|long
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|Xu
parameter_list|(
name|a
parameter_list|)
value|t = up->u_pcb.a; up->u_pcb.a = uq ->u_pcb.a; uq->u_pcb.a = t;
end_define

begin_define
define|#
directive|define
name|Xup
parameter_list|(
name|a
parameter_list|)
value|tp = up->u_pcb.a; up->u_pcb.a = uq ->u_pcb.a; uq->u_pcb.a = tp;
end_define

begin_define
define|#
directive|define
name|Xp
parameter_list|(
name|a
parameter_list|)
value|t = p->a; p->a = q->a; q->a = t;
end_define

begin_define
define|#
directive|define
name|Xpp
parameter_list|(
name|a
parameter_list|)
value|tp = p->a; p->a = q->a; q->a = tp;
end_define

begin_comment
comment|/*  * Pass the page tables of process p to process q.  * Used during vfork().  P and q are not symmetric;  * p is the giver and q the receiver; after calling vpasspt  * p will be ``cleaned out''.  Thus before vfork() we call vpasspt  * with the child as q and give it our resources; after vfork() we  * call vpasspt with the child as p to steal our resources back.  * We are cognizant of whether we are p or q because we have to  * be careful to keep our u. area and restore the other u. area from  * umap after we temporarily put our u. area in both p and q's page tables.  */
end_comment

begin_expr_stmt
name|vpasspt
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|up
argument_list|,
name|uq
argument_list|,
name|umap
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|user
modifier|*
name|up
decl_stmt|,
modifier|*
name|uq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pte
modifier|*
name|umap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|t
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|pte
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* conservative, and slightly paranoid */
name|Xu
argument_list|(
name|pcb_szpt
argument_list|)
expr_stmt|;
name|Xu
argument_list|(
name|pcb_p0lr
argument_list|)
expr_stmt|;
name|Xu
argument_list|(
name|pcb_p1lr
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
name|Xu
argument_list|(
name|pcb_p2lr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Xup
argument_list|(
name|pcb_p0br
argument_list|)
expr_stmt|;
name|Xup
argument_list|(
name|pcb_p1br
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
name|Xup
argument_list|(
name|pcb_p2br
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
name|Xu
argument_list|(
name|pcb_ustp
argument_list|)
expr_stmt|;
name|Xu
argument_list|(
name|pcb_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|i386
argument_list|)
name|Xu
argument_list|(
name|pcb_cr3
argument_list|)
expr_stmt|;
name|Xu
argument_list|(
name|pcb_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The u. area is contained in the process' p1 region. 	 * Thus we map the current u. area into the process virtual space 	 * of both sets of page tables we will deal with so that it 	 * will stay with us as we rearrange memory management. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|up
operator|==
operator|&
name|u
condition|)
name|q
operator|->
name|p_addr
index|[
name|i
index|]
operator|=
name|p
operator|->
name|p_addr
index|[
name|i
index|]
expr_stmt|;
else|else
name|p
operator|->
name|p_addr
index|[
name|i
index|]
operator|=
name|q
operator|->
name|p_addr
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now have u. double mapped, and have flushed 	 * any stale translations to new u. area. 	 * Switch the page tables. 	 */
name|Xpp
argument_list|(
name|p_p0br
argument_list|)
expr_stmt|;
name|Xp
argument_list|(
name|p_szpt
argument_list|)
expr_stmt|;
name|Xpp
argument_list|(
name|p_addr
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
name|mtpr
argument_list|(
name|P0BR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0br
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
name|mtpr
argument_list|(
name|P0LR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0lr
operator|&
operator|~
name|AST_CLR
argument_list|)
expr_stmt|;
else|#
directive|else
name|mtpr
argument_list|(
name|P0LR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0lr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtpr
argument_list|(
name|P1BR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1br
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|P1LR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1lr
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
name|mtpr
argument_list|(
name|P2BR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p2br
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|P2LR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p2lr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
name|loadustp
argument_list|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_ustp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|i386
argument_list|)
name|load_cr3
argument_list|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_cr3
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now running on the ``other'' set of page tables. 	 * Flush translation to insure that we get correct u. 	 * Resurrect the u. for the other process in the other 	 * (our old) set of page tables.  Thus the other u. has moved 	 * from its old (our current) set of page tables to our old 	 * (its current) set of page tables, while we have kept our 	 * u. by mapping it into the other page table and then keeping 	 * the other page table. 	 */
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pf
decl_stmt|;
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
name|up
operator|==
operator|&
name|u
condition|)
block|{
name|pf
operator|=
name|umap
index|[
name|i
index|]
operator|.
name|pg_pfnum
expr_stmt|;
name|pte
operator|=
operator|&
name|q
operator|->
name|p_addr
index|[
name|i
index|]
expr_stmt|;
name|pte
operator|->
name|pg_pfnum
operator|=
name|pf
expr_stmt|;
block|}
else|else
block|{
name|pf
operator|=
name|umap
index|[
name|i
index|]
operator|.
name|pg_pfnum
expr_stmt|;
name|pte
operator|=
operator|&
name|p
operator|->
name|p_addr
index|[
name|i
index|]
expr_stmt|;
name|pte
operator|->
name|pg_pfnum
operator|=
name|pf
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
name|TBIA
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|i386
argument_list|)
name|tlbflush
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Compute number of pages to be allocated to the u. area  * and data and stack area page tables, which are stored on the  * disk immediately after the u. area.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|vusize
argument_list|(
name|p
argument_list|,
name|utl
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|user
modifier|*
name|utl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|tsz
init|=
name|p
operator|->
name|p_tsize
operator|/
name|NPTEPG
decl_stmt|;
comment|/* 	 * We do not need page table space on the disk for page 	 * table pages wholly containing text.  This is well 	 * understood in the code in vmswap.c. 	 */
return|return
operator|(
name|clrnd
argument_list|(
name|UPAGES
operator|+
name|ptsize
argument_list|(
name|p
argument_list|)
operator|-
name|tsz
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get u area for process p.  If a old u area is given,  * then copy the new area from the old, else  * swap in as specified in the proc structure.  *  * Since argument map/newu is potentially shared  * when an old u. is provided we have to be careful not  * to block after beginning to use them in this case.  * (This is not true when called from swapin() with no old u.)  */
end_comment

begin_expr_stmt
name|vgetu
argument_list|(
name|p
argument_list|,
name|palloc
argument_list|,
name|map
argument_list|,
name|newu
argument_list|,
name|oldu
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|palloc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|register
name|struct
name|pte
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|user
modifier|*
name|newu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|user
modifier|*
name|oldu
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|palloc
call|)
argument_list|(
name|p
operator|->
name|p_addr
argument_list|,
name|clrnd
argument_list|(
name|UPAGES
argument_list|)
argument_list|,
name|p
argument_list|,
name|CSYS
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * New u. pages are to be accessible in map/newu as well 	 * as in process p's virtual memory. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|map
index|[
name|i
index|]
operator|=
name|p
operator|->
name|p_addr
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|p
operator|->
name|p_addr
operator|+
name|i
operator|)
operator||=
name|PG_URKW
operator||
name|PG_V
expr_stmt|;
block|}
name|setredzone
argument_list|(
name|p
operator|->
name|p_addr
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|vmaccess
argument_list|(
name|map
argument_list|,
operator|(
name|caddr_t
operator|)
name|newu
argument_list|,
name|UPAGES
argument_list|)
expr_stmt|;
comment|/* 	 * New u.'s come from forking or inswap. 	 */
if|if
condition|(
name|oldu
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|oldu
argument_list|,
operator|(
name|caddr_t
operator|)
name|newu
argument_list|,
operator|(
name|unsigned
operator|)
name|UPAGES
operator|*
name|NBPG
argument_list|)
expr_stmt|;
name|newu
operator|->
name|u_procp
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|hp300
argument_list|)
operator|||
name|defined
argument_list|(
name|i386
argument_list|)
operator|(
name|void
operator|)
name|swap
argument_list|(
argument|p
argument_list|,
argument|p->p_swaddr
argument_list|,
argument|(caddr_t)
literal|0
argument_list|,
argument|ctob(UPAGES)
argument_list|,
else|#
directive|else
argument|(void) swap(p, p->p_swaddr, (caddr_t)&u, ctob(UPAGES),
endif|#
directive|endif
argument|B_READ, B_UAREA, swapdev_vp,
literal|0
argument|); 		if (
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
argument|newu->u_pcb.pcb_ssp != -
literal|1
argument||| newu->u_pcb.pcb_esp != -
literal|1
argument|||
endif|#
directive|endif
argument|newu->u_tsize != p->p_tsize || newu->u_dsize != p->p_dsize || 		    newu->u_ssize != p->p_ssize || newu->u_procp != p) 			panic(
literal|"vgetu"
argument|); 	}
comment|/* 	 * Initialize the pcb copies of the p0 and p1 region bases and 	 * software page table size from the information in the proc structure. 	 */
argument|newu->u_pcb.pcb_p0br = p->p_p0br;
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
argument|newu->u_pcb.pcb_p1br = initp1br(p->p_p0br + p->p_szpt * NPTEPG);
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
argument|newu->u_pcb.pcb_p2br = initp2br(p->p_p0br + p->p_szpt * NPTEPG);
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
argument|newu->u_pcb.pcb_p1br = initp1br(p->p_p0br + p->p_szpt * NPTEPG); 	newu->u_pcb.pcb_ustp = initustp(p);
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|i386
argument_list|)
argument|newu->u_pcb.pcb_p1br = initp1br(p->p_p0br + p->p_szpt * NPTEPG); 	newu->u_pcb.pcb_cr3 = initpdt(p);
endif|#
directive|endif
argument|newu->u_pcb.pcb_szpt = p->p_szpt; 	return (
literal|1
argument|); }
comment|/*  * Release swap space for a u. area.  */
argument|vrelswu(p, utl) 	struct proc *p; 	struct user *utl; {  	rmfree(swapmap, (long)ctod(vusize(p, utl)), p->p_swaddr);
comment|/* p->p_swaddr = 0; */
comment|/* leave for post-mortems */
argument|}
comment|/*  * Get swap space for a u. area.  */
argument|vgetswu(p, utl) 	struct proc *p; 	struct user *utl; {  	p->p_swaddr = rmalloc(swapmap, (long)ctod(vusize(p, utl))); 	return (p->p_swaddr); }
comment|/*  * Release u. area, swapping it out if desired.  */
argument|vrelu(p, swapu) 	register struct proc *p; { 	register int i; 	struct pte uu[UPAGES];  	if (swapu)
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|hp300
argument_list|)
operator|||
name|defined
argument_list|(
name|i386
argument_list|)
argument|(void) swap(p, p->p_swaddr, (caddr_t)
literal|0
argument|, ctob(UPAGES),
else|#
directive|else
argument|(void) swap(p, p->p_swaddr, (caddr_t)&u, ctob(UPAGES),
endif|#
directive|endif
argument|B_WRITE, B_UAREA, swapdev_vp,
literal|0
argument|); 	for (i =
literal|0
argument|; i< UPAGES; i++) 		uu[i] = p->p_addr[i];
comment|/* 	 * If freeing the user structure and kernel stack 	 * for the current process, have to run a bit longer 	 * using the pages which have already been freed... 	 * block memory allocation from the network by raising ipl. 	 */
argument|if (p == u.u_procp) 		(void) splimp();
comment|/* XXX */
argument|(void) vmemfree(uu, clrnd(UPAGES)); }
ifdef|#
directive|ifdef
name|DIAGNOSTIC
argument|int	ptforceswap;
endif|#
directive|endif
comment|/*  * Expand a page table, assigning new kernel virtual  * space and copying the page table entries over both  * in the system map and as necessary in the user page table space.  * IMPORTANT NOTE:  *  * On the HPs, excess PTEs will *always* be zero.  This is critical  * since we don't have length registers.  We guarentee this for  * expansion here by zeroing new PT pages, and for shrinking in  * setptlr() which zeroes excess PTEs.  *  * On the VAX and TAHOE, the state of excess PTEs is less important  * as the length registers dictate the actual bounds.  As a result  * the state of these PTEs is random.  New pages are zeroed unless  * they come about due to a PT expansion swap in which case they  * have garbage.  Page table splitting (either here or as part of  * an expansion swap) can lead to duplicate PTEs.  When shrinking,  * expand() sets excess PTEs to PG_UW (not zero).  */
argument|ptexpand(change, ods, omms, oss) 	register int change; 	segsz_t ods, omms, oss; { 	register struct pte *p1, *p2; 	register int i;
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|hp300
argument_list|)
operator|||
name|defined
argument_list|(
name|i386
argument_list|)
argument|register int spages, ss = P1PAGES - u.u_pcb.pcb_p1lr;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
argument|register int spages, ss = P2PAGES - u.u_pcb.pcb_p2lr;
endif|#
directive|endif
argument|register int kold = btokmx(u.u_pcb.pcb_p0br); 	int knew, tdpages; 	int szpt = u.u_pcb.pcb_szpt; 	caddr_t a; 	int s;  	if (change<=
literal|0
argument||| change % CLSIZE) 		panic(
literal|"ptexpand"
argument|);
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
operator|||
name|defined
argument_list|(
name|i386
argument_list|)
comment|/* 	 * ++ to account for segment/page directory table.  We reallocate 	 * a segment table PTE so that it is virtually contiguous with 	 * the page tables. 	 * This way we can locate it relative to p_p0br (see initustp()). 	 * Reallocation also reduces fragmentation of Usrptmap. 	 */
argument|szpt++;
endif|#
directive|endif
comment|/* 	 * Change is the number of new page table pages needed. 	 * Kold is the old index in the kernelmap of the page tables. 	 * Allocate a new kernel map segment of size szpt+change for 	 * the page tables, and the new page table pages in the 	 * middle of this new region. 	 */
argument|top:
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
operator|||
name|defined
argument_list|(
name|i386
argument_list|)
comment|/* 	 * Consider segment/page directory table as part of stack ptes 	 * Note we use ctopt() since we don't pack page tables 	 */
argument|spages = ctopt(ss) +
literal|1
argument|;
else|#
directive|else
argument|spages = ss/NPTEPG;
endif|#
directive|endif
argument|tdpages = szpt - spages;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
argument|if (ptforceswap) 		goto bad;
endif|#
directive|endif
argument|if ((knew=rmalloc(kernelmap, (long)(szpt+change))) ==
literal|0
argument|) 		goto bad; 	if (memall(&Usrptmap[knew+tdpages], change, u.u_procp, CSYS) ==
literal|0
argument|) { 		rmfree(kernelmap, (long)(szpt+change), (long)knew); 		goto bad; 	}
comment|/* 	 * Spages pages of u.+stack page tables go over unchanged. 	 * Tdpages of text+data page table may contain a few stack 	 * pages which need to go in one of the newly allocated pages; 	 * this is a rough cut. 	 * 	 * NOTE: The last statement is not true on HPs, text/data and 	 * stack are seperate page tables.  We really cannot "pack" page 	 * tables since we have no length register, and packing would 	 * result in some pages being accessible at two different addrs. 	 */
argument|kmcopy(knew, kold, tdpages); 	kmcopy(knew+tdpages+change, kold+tdpages, spages);
comment|/* 	 * Validate and clear the newly allocated page table pages in the 	 * center of the new region of the kernelmap. 	 */
argument|i = knew + tdpages; 	p1 =&Usrptmap[i]; 	a = (caddr_t) kmxtob(i); 	p2 = p1 + change; 	while (p1< p2) {
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
comment|/* mapin is overkill */
argument|*(u_int *)p1 |= PG_V|PG_KW|PG_CI;
else|#
directive|else
argument|mapin(p1, (u_int) a, p1->pg_pfnum, (int)(PG_V|PG_KW));
endif|#
directive|endif
argument|bzero(a, NBPG); 		a += NBPG; 		p1++; 	}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|hp300
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|i386
argument_list|)
comment|/* 	 * Move the stack and u. pte's which are before the newly 	 * allocated pages into the last of the newly allocated pages. 	 * They are taken from the end of the current p1 region, 	 * and moved to the end of the new p1 region. 	 */
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
argument|p1 = u.u_pcb.pcb_p1br + u.u_pcb.pcb_p1lr; 	p2 = initp1br(kmxtob(knew+szpt+change)) + u.u_pcb.pcb_p1lr;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
argument|p1 = u.u_pcb.pcb_p2br + u.u_pcb.pcb_p2lr; 	p2 = initp2br(kmxtob(knew+szpt+change)) + u.u_pcb.pcb_p2lr;
endif|#
directive|endif
argument|bcopy((caddr_t) p1, (caddr_t) p2, 	    (unsigned)((caddr_t)kmxtob(kold + tdpages) - (caddr_t)p1));
endif|#
directive|endif
comment|/* 	 * Now switch to the new page tables. 	 */
argument|s = splhigh();
comment|/* conservative */
argument|u.u_procp->p_p0br = kmxtob(knew); 	setp0br(u.u_procp->p_p0br);
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
argument|u.u_pcb.pcb_p1br = initp1br(kmxtob(knew+szpt+change)); 	setp1br(u.u_pcb.pcb_p1br);
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
argument|u.u_pcb.pcb_p1br = kmxtob(knew); 	setp1br(u.u_pcb.pcb_p1br); 	u.u_pcb.pcb_p2br = initp2br(kmxtob(knew+szpt+change)); 	setp2br(u.u_pcb.pcb_p2br);
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
operator|||
name|defined
argument_list|(
name|i386
argument_list|)
argument|u.u_pcb.pcb_p1br = initp1br(kmxtob(knew+szpt-
literal|1
argument|+change)); 	setp1br(u.u_pcb.pcb_p1br);
endif|#
directive|endif
argument|u.u_pcb.pcb_szpt += change; 	u.u_procp->p_szpt += change; 	u.u_procp->p_addr = uaddr(u.u_procp);
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
argument|mtpr(TBIA,
literal|0
argument|);
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
argument|u.u_pcb.pcb_ustp = initustp(u.u_procp); 	initsegt(u.u_procp); 	TBIA();
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|i386
argument_list|)
argument|u.u_pcb.pcb_cr3 = initpdt(u.u_procp); 	tlbflush();
endif|#
directive|endif
argument|splx(s);
comment|/* 	 * Finally, free old kernelmap. 	 */
argument|if (szpt) 		rmfree(kernelmap, (long)szpt, (long)kold); 	return;  bad:
comment|/* 	 * Swap out the process so that the unavailable  	 * resource will be allocated upon swapin. 	 * 	 * When resume is executed for the process,  	 * here is where it will resume. 	 */
argument|resume(pcbb(u.u_procp)); 	if (savectx(&u.u_ssave)) {
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
operator|||
name|defined
argument_list|(
name|i386
argument_list|)
comment|/* 		 * New page table pages will contain garbage since 		 * the page table was expanded on disk without the 		 * new pages being zeroed. 		 */
argument|bzero((caddr_t)u.u_procp->p_p0br+tdpages*NBPG, change*NBPG);
endif|#
directive|endif
argument|return; 	} 	if (swapout(u.u_procp, ods, omms, oss) ==
literal|0
argument|) {
comment|/* 		 * No space to swap... it is inconvenient to try 		 * to exit, so just wait a bit and hope something 		 * turns up.  Could deadlock here. 		 * 		 * SOMEDAY REFLECT ERROR BACK THROUGH expand TO CALLERS 		 * (grow, sbreak) SO CAN'T DEADLOCK HERE. 		 */
argument|sleep((caddr_t)&lbolt, PRIBIO); 		goto top; 	}
comment|/* 	 * Set SSWAP bit, so that when process is swapped back in 	 * swapin will set u.u_pcb.pcb_sswap to u_sswap and force a 	 * return from the savectx() above. 	 */
argument|u.u_procp->p_flag |= SSWAP; 	swtch();
comment|/* NOTREACHED */
argument|}  kmcopy(to, from, count) 	int to; 	int from; 	register int count; { 	register struct pte *tp =&Usrptmap[to]; 	register struct pte *fp =&Usrptmap[from]; 	u_int a;  	a = (u_int) kmxtob(to); 	while (count !=
literal|0
argument|) {
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
argument|mapin(tp, a, fp->pg_pfnum, 		    (int)(*((int *)fp)& (PG_V|PG_PROT|PG_CI)));
else|#
directive|else
argument|mapin(tp, a, fp->pg_pfnum, 		    (int)(*((int *)fp)& (PG_V|PG_PROT)));
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
argument|mtpr(P1DC, a);
endif|#
directive|endif
argument|tp++; 		fp++; 		a += NBPG; 		count--; 	} }
end_block

end_unit

