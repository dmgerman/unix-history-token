begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department. Originally from University of Wisconsin.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: uipc_shm.c 1.9 89/08/14$  *  *	@(#)sysv_shm.c	7.8 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * System V shared memory routines.  * TEMPORARY, until mmap is in place;  * needed now for HP-UX compatibility and X server (yech!).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVSHM
end_ifdef

begin_include
include|#
directive|include
file|"machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"syscontext.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"shm.h"
end_include

begin_include
include|#
directive|include
file|"mapmem.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXCOMPAT
end_ifdef

begin_include
include|#
directive|include
file|"../hpux/hpux.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|shmat
argument_list|()
decl_stmt|,
name|shmctl
argument_list|()
decl_stmt|,
name|shmdt
argument_list|()
decl_stmt|,
name|shmget
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|shmcalls
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|shmat
operator|,
function_decl|shmctl
operator|,
function_decl|shmdt
operator|,
function_decl|shmget
end_function_decl

begin_decl_stmt
unit|};
name|int
name|shmtot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|shmfork
argument_list|()
decl_stmt|,
name|shmexit
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mapmemops
name|shmops
init|=
block|{
name|shmfork
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
block|,
name|shmexit
block|,
name|shmexit
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|shminit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|shminfo
operator|.
name|shmmni
operator|>
name|SHMMMNI
condition|)
name|shminfo
operator|.
name|shmmni
operator|=
name|SHMMMNI
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
block|{
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Entry point for all SHM calls  */
end_comment

begin_macro
name|shmsys
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|u_int
name|which
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|uap
operator|->
name|which
operator|>=
sizeof|sizeof
argument_list|(
name|shmcalls
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|shmcalls
index|[
literal|0
index|]
argument_list|)
condition|)
name|RETURN
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
call|(
modifier|*
name|shmcalls
index|[
name|uap
operator|->
name|which
index|]
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|uap
index|[
literal|1
index|]
argument_list|,
name|retval
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get a shared memory segment  */
end_comment

begin_macro
name|shmget
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
specifier|register
struct|struct
name|args
block|{
name|key_t
name|key
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|shmflg
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
specifier|register
name|struct
name|ucred
modifier|*
name|cred
init|=
name|u
operator|.
name|u_cred
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|,
name|size
decl_stmt|,
name|rval
init|=
literal|0
decl_stmt|;
name|caddr_t
name|kva
decl_stmt|;
comment|/* look up the specified shm_id */
if|if
condition|(
name|uap
operator|->
name|key
operator|!=
name|IPC_PRIVATE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|SHM_ALLOC
operator|)
operator|&&
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|key
operator|==
name|uap
operator|->
name|key
condition|)
block|{
name|rval
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
else|else
name|i
operator|=
name|shminfo
operator|.
name|shmmni
expr_stmt|;
comment|/* create a new shared segment if necessary */
if|if
condition|(
name|i
operator|==
name|shminfo
operator|.
name|shmmni
condition|)
block|{
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|IPC_CREAT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|size
operator|<
name|shminfo
operator|.
name|shmmin
operator|||
name|uap
operator|->
name|size
operator|>
name|shminfo
operator|.
name|shmmax
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|SHM_ALLOC
operator|)
operator|==
literal|0
condition|)
block|{
name|rval
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|shminfo
operator|.
name|shmmni
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|size
operator|=
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|uap
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmtot
operator|+
name|size
operator|>
name|shminfo
operator|.
name|shmall
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|rval
index|]
expr_stmt|;
comment|/* 		 * We need to do a couple of things to ensure consistency 		 * in case we sleep in malloc().  We mark segment as 		 * allocated so that other shmgets() will not allocate it. 		 * We mark it as "destroyed" to insure that shmvalid() is 		 * false making most operations fail (XXX).  We set the key, 		 * so that other shmget()s will fail. 		 */
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
name|SHM_ALLOC
operator||
name|SHM_DEST
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|key
operator|=
name|uap
operator|->
name|key
expr_stmt|;
name|kva
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
operator|(
name|u_long
operator|)
name|ctob
argument_list|(
name|size
argument_list|)
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|kva
operator|==
name|NULL
condition|)
block|{
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|claligned
argument_list|(
name|kva
argument_list|)
condition|)
name|panic
argument_list|(
literal|"shmget: non-aligned memory"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|kva
argument_list|,
operator|(
name|u_int
operator|)
name|ctob
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|shmtot
operator|+=
name|size
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|cuid
operator|=
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|cgid
operator|=
name|shp
operator|->
name|shm_perm
operator|.
name|gid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
name|SHM_ALLOC
operator||
operator|(
name|uap
operator|->
name|shmflg
operator|&
literal|0777
operator|)
expr_stmt|;
name|shp
operator|->
name|shm_handle
operator|=
operator|(
name|void
operator|*
operator|)
name|kvtopte
argument_list|(
name|kva
argument_list|)
expr_stmt|;
name|shp
operator|->
name|shm_segsz
operator|=
name|uap
operator|->
name|size
expr_stmt|;
name|shp
operator|->
name|shm_cpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|shp
operator|->
name|shm_lpid
operator|=
name|shp
operator|->
name|shm_nattch
operator|=
literal|0
expr_stmt|;
name|shp
operator|->
name|shm_atime
operator|=
name|shp
operator|->
name|shm_dtime
operator|=
literal|0
expr_stmt|;
name|shp
operator|->
name|shm_ctime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
block|}
else|else
block|{
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|rval
index|]
expr_stmt|;
comment|/* XXX: probably not the right thing to do */
if|if
condition|(
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHM_DEST
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|ipcaccess
argument_list|(
operator|&
name|shp
operator|->
name|shm_perm
argument_list|,
name|uap
operator|->
name|shmflg
operator|&
literal|0777
argument_list|,
name|cred
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|size
operator|&&
name|uap
operator|->
name|size
operator|>
name|shp
operator|->
name|shm_segsz
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|IPC_CREAT
operator|)
operator|&&
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|IPC_EXCL
operator|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
operator|*
name|retval
operator|=
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|*
name|SHMMMNI
operator|+
name|rval
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Shared memory control  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|shmctl
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
specifier|register
struct|struct
name|args
block|{
name|int
name|shmid
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
specifier|register
name|struct
name|ucred
modifier|*
name|cred
init|=
name|u
operator|.
name|u_cred
decl_stmt|;
name|struct
name|shmid_ds
name|sbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|shmvalid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|uap
operator|->
name|shmid
operator|%
name|SHMMMNI
index|]
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|IPC_STAT
case|:
if|if
condition|(
name|error
operator|=
name|ipcaccess
argument_list|(
operator|&
name|shp
operator|->
name|shm_perm
argument_list|,
name|IPC_R
argument_list|,
name|cred
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|shp
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|shp
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|IPC_SET
case|:
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|cuid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|buf
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbuf
argument_list|,
sizeof|sizeof
name|sbuf
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|=
name|sbuf
operator|.
name|shm_perm
operator|.
name|uid
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|gid
operator|=
name|sbuf
operator|.
name|shm_perm
operator|.
name|gid
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
operator|(
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|&
operator|~
literal|0777
operator|)
operator||
operator|(
name|sbuf
operator|.
name|shm_perm
operator|.
name|mode
operator|&
literal|0777
operator|)
expr_stmt|;
name|shp
operator|->
name|shm_ctime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
break|break;
case|case
name|IPC_RMID
case|:
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|cuid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* set ctime? */
name|shp
operator|->
name|shm_perm
operator|.
name|key
operator|=
name|IPC_PRIVATE
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator||=
name|SHM_DEST
expr_stmt|;
if|if
condition|(
name|shp
operator|->
name|shm_nattch
operator|<=
literal|0
condition|)
name|shmfree
argument_list|(
name|shp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HPUXCOMPAT
case|case
name|SHM_LOCK
case|:
case|case
name|SHM_UNLOCK
case|:
comment|/* don't really do anything, but make them think we did */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|cuid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Attach to shared memory segment.  */
end_comment

begin_macro
name|shmat
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
specifier|register
struct|struct
name|args
block|{
name|int
name|shmid
decl_stmt|;
name|caddr_t
name|shmaddr
decl_stmt|;
name|int
name|shmflg
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|;
name|caddr_t
name|uva
decl_stmt|;
name|int
name|error
decl_stmt|,
name|prot
decl_stmt|,
name|shmmapin
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|shmvalid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|uap
operator|->
name|shmid
operator|%
name|SHMMMNI
index|]
expr_stmt|;
if|if
condition|(
name|shp
operator|->
name|shm_handle
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"shmat NULL handle"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|ipcaccess
argument_list|(
operator|&
name|shp
operator|->
name|shm_perm
argument_list|,
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RDONLY
operator|)
condition|?
name|IPC_R
else|:
name|IPC_R
operator||
name|IPC_W
argument_list|,
name|u
operator|.
name|u_cred
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|uva
operator|=
name|uap
operator|->
name|shmaddr
expr_stmt|;
if|if
condition|(
name|uva
operator|&&
operator|(
operator|(
name|int
operator|)
name|uva
operator|&
operator|(
name|SHMLBA
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RND
condition|)
name|uva
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|uva
operator|&
operator|~
operator|(
name|SHMLBA
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Make sure user doesn't use more than their fair share 	 */
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|u
operator|.
name|u_mmap
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|mm_next
control|)
if|if
condition|(
name|mp
operator|->
name|mm_ops
operator|==
operator|&
name|shmops
condition|)
name|size
operator|++
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|shminfo
operator|.
name|shmseg
condition|)
return|return
operator|(
name|EMFILE
operator|)
return|;
comment|/* 	 * Allocate a mapped memory region descriptor and 	 * attempt to expand the user page table to allow for region 	 */
name|prot
operator|=
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RDONLY
operator|)
condition|?
name|MM_RO
else|:
name|MM_RW
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
name|prot
operator||=
name|MM_CI
expr_stmt|;
endif|#
directive|endif
name|size
operator|=
name|ctob
argument_list|(
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|shp
operator|->
name|shm_segsz
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|mmalloc
argument_list|(
name|p
argument_list|,
name|uap
operator|->
name|shmid
argument_list|,
operator|&
name|uva
argument_list|,
operator|(
name|segsz_t
operator|)
name|size
argument_list|,
name|prot
argument_list|,
operator|&
name|shmops
argument_list|,
operator|&
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|mmmapin
argument_list|(
name|p
argument_list|,
name|mp
argument_list|,
name|shmmapin
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|mmfree
argument_list|(
name|p
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Fill in the remaining fields 	 */
name|shp
operator|->
name|shm_lpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|shp
operator|->
name|shm_atime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|shp
operator|->
name|shm_nattch
operator|++
expr_stmt|;
operator|*
name|retval
operator|=
operator|(
name|int
operator|)
name|uva
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Detach from shared memory segment.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|shmdt
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|args
block|{
name|caddr_t
name|shmaddr
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|u
operator|.
name|u_mmap
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|mm_next
control|)
if|if
condition|(
name|mp
operator|->
name|mm_ops
operator|==
operator|&
name|shmops
operator|&&
name|mp
operator|->
name|mm_uva
operator|==
name|uap
operator|->
name|shmaddr
condition|)
break|break;
if|if
condition|(
name|mp
operator|==
name|MMNIL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|shmsegs
index|[
name|mp
operator|->
name|mm_id
operator|%
name|SHMMMNI
index|]
operator|.
name|shm_lpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
return|return
operator|(
name|shmufree
argument_list|(
name|p
argument_list|,
name|mp
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|shmmapin
argument_list|(
argument|mp
argument_list|,
argument|off
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|mp
operator|->
name|mm_id
operator|%
name|SHMMMNI
index|]
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|ctob
argument_list|(
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|shp
operator|->
name|shm_segsz
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|(
operator|(
expr|struct
name|pte
operator|*
operator|)
name|shp
operator|->
name|shm_handle
operator|)
index|[
name|btop
argument_list|(
name|off
argument_list|)
index|]
operator|.
name|pg_pfnum
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Increment attach count on fork  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|shmfork
argument_list|(
name|mp
argument_list|,
name|ischild
argument_list|)
specifier|register
expr|struct
name|mapmem
operator|*
name|mp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|ischild
condition|)
name|shmsegs
index|[
name|mp
operator|->
name|mm_id
operator|%
name|SHMMMNI
index|]
operator|.
name|shm_nattch
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Detach from shared memory segment on exit (or exec)  */
end_comment

begin_macro
name|shmexit
argument_list|(
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|u
operator|.
name|u_procp
decl_stmt|;
comment|/* XXX */
return|return
operator|(
name|shmufree
argument_list|(
name|p
argument_list|,
name|mp
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|shmvalid
argument_list|(
name|id
argument_list|)
specifier|register
name|int
name|id
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|||
operator|(
name|id
operator|%
name|SHMMMNI
operator|)
operator|>=
name|shminfo
operator|.
name|shmmni
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|id
operator|%
name|SHMMMNI
index|]
expr_stmt|;
if|if
condition|(
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|==
operator|(
name|id
operator|/
name|SHMMMNI
operator|)
operator|&&
operator|(
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|&
operator|(
name|SHM_ALLOC
operator||
name|SHM_DEST
operator|)
operator|)
operator|==
name|SHM_ALLOC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Free user resources associated with a shared memory segment  */
end_comment

begin_macro
name|shmufree
argument_list|(
argument|p
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mapmem
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|mp
operator|->
name|mm_id
operator|%
name|SHMMMNI
index|]
expr_stmt|;
name|mmmapout
argument_list|(
name|p
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|mmfree
argument_list|(
name|p
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|shp
operator|->
name|shm_dtime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|--
name|shp
operator|->
name|shm_nattch
operator|<=
literal|0
operator|&&
operator|(
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHM_DEST
operator|)
condition|)
name|shmfree
argument_list|(
name|shp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Deallocate resources associated with a shared memory segment  */
end_comment

begin_expr_stmt
name|shmfree
argument_list|(
name|shp
argument_list|)
specifier|register
expr|struct
name|shmid_ds
operator|*
name|shp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|caddr_t
name|kva
decl_stmt|;
if|if
condition|(
name|shp
operator|->
name|shm_handle
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"shmfree"
argument_list|)
expr_stmt|;
name|kva
operator|=
operator|(
name|caddr_t
operator|)
name|ptetokv
argument_list|(
name|shp
operator|->
name|shm_handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kva
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|shp
operator|->
name|shm_handle
operator|=
name|NULL
expr_stmt|;
name|shmtot
operator|-=
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|shp
operator|->
name|shm_segsz
argument_list|)
argument_list|)
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Increment the sequence number to ensure that outstanding 	 * shmids for this segment will be invalid in the event that 	 * the segment is reallocated.  Note that shmids must be 	 * positive as decreed by SVID. 	 */
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|++
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|*
name|SHMMMNI
argument_list|)
operator|<
literal|0
condition|)
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * XXX This routine would be common to all sysV style IPC  *     (if the others were implemented).  */
end_comment

begin_expr_stmt
name|ipcaccess
argument_list|(
name|ipc
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|)
specifier|register
expr|struct
name|ipc_perm
operator|*
name|ipc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|m
decl_stmt|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Access check is based on only one of owner, group, public. 	 * If not owner, then check group. 	 * If not a member of the group, then check public access. 	 */
name|mode
operator|&=
literal|0700
expr_stmt|;
name|m
operator|=
name|ipc
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|ipc
operator|->
name|uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|ipc
operator|->
name|cuid
condition|)
block|{
name|m
operator|<<=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|ipc
operator|->
name|gid
argument_list|,
name|cred
argument_list|)
operator|&&
operator|!
name|groupmember
argument_list|(
name|ipc
operator|->
name|cgid
argument_list|,
name|cred
argument_list|)
condition|)
name|m
operator|<<=
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mode
operator|&
name|m
operator|)
operator|==
name|mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSVSHM */
end_comment

end_unit

