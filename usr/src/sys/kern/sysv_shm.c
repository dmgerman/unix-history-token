begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department. Originally from University of Wisconsin.  *  * %sccs.include.proprietary.c%  *  * from: Utah $Hdr: uipc_shm.c 1.11 92/04/23$  *  *	@(#)sysv_shm.c	8.5 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * System V shared memory routines.  * TEMPORARY, until mmap is in place;  * needed now for HP-UX compatibility and X server (yech!).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVSHM
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_inherit.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_decl_stmt
name|int
name|shmat
argument_list|()
decl_stmt|,
name|shmctl
argument_list|()
decl_stmt|,
name|shmdt
argument_list|()
decl_stmt|,
name|shmget
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|shmcalls
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|shmat
operator|,
function_decl|shmctl
operator|,
function_decl|shmdt
operator|,
function_decl|shmget
end_function_decl

begin_decl_stmt
unit|};
name|int
name|shmtot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per process internal structure for managing segments.  * Each process using shm will have an array of ``shmseg'' of these.  */
end_comment

begin_struct
struct|struct
name|shmdesc
block|{
name|vm_offset_t
name|shmd_uva
decl_stmt|;
name|int
name|shmd_id
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Per segment internal structure (shm_handle).  */
end_comment

begin_struct
struct|struct
name|shmhandle
block|{
name|vm_offset_t
name|shmh_kva
decl_stmt|;
name|caddr_t
name|shmh_id
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|vm_map_t
name|shm_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address space for shared memory segments */
end_comment

begin_macro
name|shminit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|whocares1
decl_stmt|,
name|whocares2
decl_stmt|;
name|shm_map
operator|=
name|kmem_suballoc
argument_list|(
name|kernel_map
argument_list|,
operator|&
name|whocares1
argument_list|,
operator|&
name|whocares2
argument_list|,
name|shminfo
operator|.
name|shmall
operator|*
name|NBPG
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|shminfo
operator|.
name|shmmni
operator|>
name|SHMMMNI
condition|)
name|shminfo
operator|.
name|shmmni
operator|=
name|SHMMMNI
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
block|{
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Entry point for all SHM calls  */
end_comment

begin_struct
struct|struct
name|shmsys_args
block|{
name|u_int
name|which
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|shmsys
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|shmsys_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|uap
operator|->
name|which
operator|>=
sizeof|sizeof
argument_list|(
name|shmcalls
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|shmcalls
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
call|(
modifier|*
name|shmcalls
index|[
name|uap
operator|->
name|which
index|]
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|uap
index|[
literal|1
index|]
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get a shared memory segment  */
end_comment

begin_struct
struct|struct
name|shmget_args
block|{
name|key_t
name|key
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|shmflg
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|shmget
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|shmget_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
specifier|register
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|,
name|size
decl_stmt|,
name|rval
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|shmhandle
modifier|*
name|shmh
decl_stmt|;
comment|/* look up the specified shm_id */
if|if
condition|(
name|uap
operator|->
name|key
operator|!=
name|IPC_PRIVATE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|SHM_ALLOC
operator|)
operator|&&
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|key
operator|==
name|uap
operator|->
name|key
condition|)
block|{
name|rval
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
else|else
name|i
operator|=
name|shminfo
operator|.
name|shmmni
expr_stmt|;
comment|/* create a new shared segment if necessary */
if|if
condition|(
name|i
operator|==
name|shminfo
operator|.
name|shmmni
condition|)
block|{
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|IPC_CREAT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|size
operator|<
name|shminfo
operator|.
name|shmmin
operator|||
name|uap
operator|->
name|size
operator|>
name|shminfo
operator|.
name|shmmax
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|SHM_ALLOC
operator|)
operator|==
literal|0
condition|)
block|{
name|rval
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|shminfo
operator|.
name|shmmni
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|size
operator|=
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|uap
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmtot
operator|+
name|size
operator|>
name|shminfo
operator|.
name|shmall
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|rval
index|]
expr_stmt|;
comment|/* 		 * We need to do a couple of things to ensure consistency 		 * in case we sleep in malloc().  We mark segment as 		 * allocated so that other shmgets() will not allocate it. 		 * We mark it as "destroyed" to insure that shmvalid() is 		 * false making most operations fail (XXX).  We set the key, 		 * so that other shmget()s will fail. 		 */
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
name|SHM_ALLOC
operator||
name|SHM_DEST
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|key
operator|=
name|uap
operator|->
name|key
expr_stmt|;
name|shmh
operator|=
operator|(
expr|struct
name|shmhandle
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|shmhandle
argument_list|)
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|shmh
operator|->
name|shmh_kva
operator|=
literal|0
expr_stmt|;
name|shmh
operator|->
name|shmh_id
operator|=
call|(
name|caddr_t
call|)
argument_list|(
literal|0xc0000000
operator||
name|rval
argument_list|)
expr_stmt|;
comment|/* XXX */
name|error
operator|=
name|vm_mmap
argument_list|(
name|shm_map
argument_list|,
operator|&
name|shmh
operator|->
name|shmh_kva
argument_list|,
name|ctob
argument_list|(
name|size
argument_list|)
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_ANON
argument_list|,
name|shmh
operator|->
name|shmh_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|shmh
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|shp
operator|->
name|shm_handle
operator|=
operator|(
name|void
operator|*
operator|)
name|shmh
expr_stmt|;
name|shmtot
operator|+=
name|size
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|cuid
operator|=
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|cgid
operator|=
name|shp
operator|->
name|shm_perm
operator|.
name|gid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
name|SHM_ALLOC
operator||
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|ACCESSPERMS
operator|)
expr_stmt|;
name|shp
operator|->
name|shm_segsz
operator|=
name|uap
operator|->
name|size
expr_stmt|;
name|shp
operator|->
name|shm_cpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|shp
operator|->
name|shm_lpid
operator|=
name|shp
operator|->
name|shm_nattch
operator|=
literal|0
expr_stmt|;
name|shp
operator|->
name|shm_atime
operator|=
name|shp
operator|->
name|shm_dtime
operator|=
literal|0
expr_stmt|;
name|shp
operator|->
name|shm_ctime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
block|}
else|else
block|{
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|rval
index|]
expr_stmt|;
comment|/* XXX: probably not the right thing to do */
if|if
condition|(
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHM_DEST
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|ipcaccess
argument_list|(
operator|&
name|shp
operator|->
name|shm_perm
argument_list|,
name|uap
operator|->
name|shmflg
operator|&
name|ACCESSPERMS
argument_list|,
name|cred
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|size
operator|&&
name|uap
operator|->
name|size
operator|>
name|shp
operator|->
name|shm_segsz
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|IPC_CREAT
operator|)
operator|&&
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|IPC_EXCL
operator|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
operator|*
name|retval
operator|=
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|*
name|SHMMMNI
operator|+
name|rval
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Shared memory control  */
end_comment

begin_struct
struct|struct
name|shmctl_args
block|{
name|int
name|shmid
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|shmctl
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|shmctl_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
specifier|register
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|struct
name|shmid_ds
name|sbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|shmvalid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|uap
operator|->
name|shmid
operator|%
name|SHMMMNI
index|]
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|IPC_STAT
case|:
if|if
condition|(
name|error
operator|=
name|ipcaccess
argument_list|(
operator|&
name|shp
operator|->
name|shm_perm
argument_list|,
name|IPC_R
argument_list|,
name|cred
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|shp
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|shp
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|IPC_SET
case|:
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|cuid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|buf
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbuf
argument_list|,
sizeof|sizeof
name|sbuf
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|=
name|sbuf
operator|.
name|shm_perm
operator|.
name|uid
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|gid
operator|=
name|sbuf
operator|.
name|shm_perm
operator|.
name|gid
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
operator|(
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|&
operator|~
name|ACCESSPERMS
operator|)
operator||
operator|(
name|sbuf
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|ACCESSPERMS
operator|)
expr_stmt|;
name|shp
operator|->
name|shm_ctime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
break|break;
case|case
name|IPC_RMID
case|:
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|cuid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* set ctime? */
name|shp
operator|->
name|shm_perm
operator|.
name|key
operator|=
name|IPC_PRIVATE
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator||=
name|SHM_DEST
expr_stmt|;
if|if
condition|(
name|shp
operator|->
name|shm_nattch
operator|<=
literal|0
condition|)
name|shmfree
argument_list|(
name|shp
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Attach to shared memory segment.  */
end_comment

begin_struct
struct|struct
name|shmat_args
block|{
name|int
name|shmid
decl_stmt|;
name|caddr_t
name|shmaddr
decl_stmt|;
name|int
name|shmflg
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|shmat
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|shmat_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|caddr_t
name|uva
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|struct
name|shmdesc
modifier|*
name|shmd
decl_stmt|;
comment|/* 	 * Allocate descriptors now (before validity check) 	 * in case malloc() blocks. 	 */
name|shmd
operator|=
operator|(
expr|struct
name|shmdesc
operator|*
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
expr_stmt|;
name|size
operator|=
name|shminfo
operator|.
name|shmseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|shmdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmd
operator|==
name|NULL
condition|)
block|{
name|shmd
operator|=
operator|(
expr|struct
name|shmdesc
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|shmd
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
operator|=
operator|(
name|caddr_t
operator|)
name|shmd
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|=
name|shmvalid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|uap
operator|->
name|shmid
operator|%
name|SHMMMNI
index|]
expr_stmt|;
if|if
condition|(
name|shp
operator|->
name|shm_handle
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"shmat NULL handle"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|ipcaccess
argument_list|(
operator|&
name|shp
operator|->
name|shm_perm
argument_list|,
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RDONLY
operator|)
condition|?
name|IPC_R
else|:
name|IPC_R
operator||
name|IPC_W
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|uva
operator|=
name|uap
operator|->
name|shmaddr
expr_stmt|;
if|if
condition|(
name|uva
operator|&&
operator|(
operator|(
name|int
operator|)
name|uva
operator|&
operator|(
name|SHMLBA
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RND
condition|)
name|uva
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|uva
operator|&
operator|~
operator|(
name|SHMLBA
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Make sure user doesn't use more than their fair share 	 */
for|for
control|(
name|size
operator|=
literal|0
init|;
name|size
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|size
operator|++
control|)
block|{
if|if
condition|(
name|shmd
operator|->
name|shmd_uva
operator|==
literal|0
condition|)
break|break;
name|shmd
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>=
name|shminfo
operator|.
name|shmseg
condition|)
return|return
operator|(
name|EMFILE
operator|)
return|;
name|size
operator|=
name|ctob
argument_list|(
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|shp
operator|->
name|shm_segsz
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|prot
operator|=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RDONLY
operator|)
operator|==
literal|0
condition|)
name|prot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
name|flags
operator|=
name|MAP_ANON
operator||
name|MAP_SHARED
expr_stmt|;
if|if
condition|(
name|uva
condition|)
name|flags
operator||=
name|MAP_FIXED
expr_stmt|;
else|else
name|uva
operator|=
operator|(
name|caddr_t
operator|)
literal|0x1000000
expr_stmt|;
comment|/* XXX */
name|error
operator|=
name|vm_mmap
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|uva
argument_list|,
operator|(
name|vm_size_t
operator|)
name|size
argument_list|,
name|prot
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|flags
argument_list|,
operator|(
operator|(
expr|struct
name|shmhandle
operator|*
operator|)
name|shp
operator|->
name|shm_handle
operator|)
operator|->
name|shmh_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shmd
operator|->
name|shmd_uva
operator|=
operator|(
name|vm_offset_t
operator|)
name|uva
expr_stmt|;
name|shmd
operator|->
name|shmd_id
operator|=
name|uap
operator|->
name|shmid
expr_stmt|;
comment|/* 	 * Fill in the remaining fields 	 */
name|shp
operator|->
name|shm_lpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|shp
operator|->
name|shm_atime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|shp
operator|->
name|shm_nattch
operator|++
expr_stmt|;
operator|*
name|retval
operator|=
operator|(
name|int
operator|)
name|uva
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Detach from shared memory segment.  */
end_comment

begin_struct
struct|struct
name|shmdt_args
block|{
name|caddr_t
name|shmaddr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|shmdt
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|shmdt_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmdesc
modifier|*
name|shmd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|shmd
operator|=
operator|(
expr|struct
name|shmdesc
operator|*
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
operator|,
name|shmd
operator|++
control|)
if|if
condition|(
name|shmd
operator|->
name|shmd_uva
operator|&&
name|shmd
operator|->
name|shmd_uva
operator|==
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|shmaddr
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|shminfo
operator|.
name|shmseg
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|shmufree
argument_list|(
name|p
argument_list|,
name|shmd
argument_list|)
expr_stmt|;
name|shmsegs
index|[
name|shmd
operator|->
name|shmd_id
operator|%
name|SHMMMNI
index|]
operator|.
name|shm_lpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|shmfork
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|isvfork
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|isvfork
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmdesc
modifier|*
name|shmd
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
comment|/* 	 * Copy parents descriptive information 	 */
name|size
operator|=
name|shminfo
operator|.
name|shmseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|shmdesc
argument_list|)
expr_stmt|;
name|shmd
operator|=
operator|(
expr|struct
name|shmdesc
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|p1
operator|->
name|p_vmspace
operator|->
name|vm_shm
argument_list|,
operator|(
name|caddr_t
operator|)
name|shmd
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p2
operator|->
name|p_vmspace
operator|->
name|vm_shm
operator|=
operator|(
name|caddr_t
operator|)
name|shmd
expr_stmt|;
comment|/* 	 * Increment reference counts 	 */
for|for
control|(
name|size
operator|=
literal|0
init|;
name|size
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|size
operator|++
operator|,
name|shmd
operator|++
control|)
if|if
condition|(
name|shmd
operator|->
name|shmd_uva
condition|)
name|shmsegs
index|[
name|shmd
operator|->
name|shmd_id
operator|%
name|SHMMMNI
index|]
operator|.
name|shm_nattch
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|shmexit
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmdesc
modifier|*
name|shmd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|shmd
operator|=
operator|(
expr|struct
name|shmdesc
operator|*
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
operator|,
name|shmd
operator|++
control|)
if|if
condition|(
name|shmd
operator|->
name|shmd_uva
condition|)
name|shmufree
argument_list|(
name|p
argument_list|,
name|shmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|shmvalid
argument_list|(
name|id
argument_list|)
specifier|register
name|int
name|id
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|||
operator|(
name|id
operator|%
name|SHMMMNI
operator|)
operator|>=
name|shminfo
operator|.
name|shmmni
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|id
operator|%
name|SHMMMNI
index|]
expr_stmt|;
if|if
condition|(
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|==
operator|(
name|id
operator|/
name|SHMMMNI
operator|)
operator|&&
operator|(
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|&
operator|(
name|SHM_ALLOC
operator||
name|SHM_DEST
operator|)
operator|)
operator|==
name|SHM_ALLOC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Free user resources associated with a shared memory segment  */
end_comment

begin_macro
name|shmufree
argument_list|(
argument|p
argument_list|,
argument|shmd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|shmdesc
modifier|*
name|shmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|shmd
operator|->
name|shmd_id
operator|%
name|SHMMMNI
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|vm_deallocate
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|shmd
operator|->
name|shmd_uva
argument_list|,
name|ctob
argument_list|(
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|shp
operator|->
name|shm_segsz
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|shmd
operator|->
name|shmd_id
operator|=
literal|0
expr_stmt|;
name|shmd
operator|->
name|shmd_uva
operator|=
literal|0
expr_stmt|;
name|shp
operator|->
name|shm_dtime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|--
name|shp
operator|->
name|shm_nattch
operator|<=
literal|0
operator|&&
operator|(
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHM_DEST
operator|)
condition|)
name|shmfree
argument_list|(
name|shp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Deallocate resources associated with a shared memory segment  */
end_comment

begin_expr_stmt
name|shmfree
argument_list|(
name|shp
argument_list|)
specifier|register
expr|struct
name|shmid_ds
operator|*
name|shp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|shp
operator|->
name|shm_handle
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"shmfree"
argument_list|)
expr_stmt|;
comment|/* 	 * Lose our lingering object reference by deallocating space 	 * in kernel.  Pager will also be deallocated as a side-effect. 	 */
name|vm_deallocate
argument_list|(
name|shm_map
argument_list|,
operator|(
operator|(
expr|struct
name|shmhandle
operator|*
operator|)
name|shp
operator|->
name|shm_handle
operator|)
operator|->
name|shmh_kva
argument_list|,
name|ctob
argument_list|(
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|shp
operator|->
name|shm_segsz
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|shp
operator|->
name|shm_handle
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|shp
operator|->
name|shm_handle
operator|=
name|NULL
expr_stmt|;
name|shmtot
operator|-=
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|shp
operator|->
name|shm_segsz
argument_list|)
argument_list|)
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Increment the sequence number to ensure that outstanding 	 * shmids for this segment will be invalid in the event that 	 * the segment is reallocated.  Note that shmids must be 	 * positive as decreed by SVID. 	 */
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|++
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|*
name|SHMMMNI
argument_list|)
operator|<
literal|0
condition|)
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * XXX This routine would be common to all sysV style IPC  *     (if the others were implemented).  */
end_comment

begin_expr_stmt
name|ipcaccess
argument_list|(
name|ipc
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|)
specifier|register
expr|struct
name|ipc_perm
operator|*
name|ipc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|m
decl_stmt|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Access check is based on only one of owner, group, public. 	 * If not owner, then check group. 	 * If not a member of the group, then check public access. 	 */
name|mode
operator|&=
literal|0700
expr_stmt|;
name|m
operator|=
name|ipc
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|ipc
operator|->
name|uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|ipc
operator|->
name|cuid
condition|)
block|{
name|m
operator|<<=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|ipc
operator|->
name|gid
argument_list|,
name|cred
argument_list|)
operator|&&
operator|!
name|groupmember
argument_list|(
name|ipc
operator|->
name|cgid
argument_list|,
name|cred
argument_list|)
condition|)
name|m
operator|<<=
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mode
operator|&
name|m
operator|)
operator|==
name|mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSVSHM */
end_comment

end_unit

