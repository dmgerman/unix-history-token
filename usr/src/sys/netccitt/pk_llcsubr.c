begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (C) Dirk Husemann, Computer Science Department IV,   * 		 University of Erlangen-Nuremberg, Germany, 1990, 1991, 1992  * Copyright (c) 1992   Regents of the University of California.  * All rights reserved.  *   * This code is derived from software contributed to Berkeley by  * Dirk Husemann and the Computer Science Department (IV) of  * the University of Erlangen-Nuremberg, Germany.  *  * %sccs.include.redist.c%  *  *	@(#)pk_llcsubr.c	7.1 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/dll.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/x25.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk_var.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/llc_var.h>
end_include

begin_comment
comment|/*  * Routing support for X.25  *  * We distinguish between two cases:  * RTF_HOST:  * 	rt_key(rt)	X.25 address of host  *	rt_gateway	SNPA (MAC+DLSAP) address of host  *	rt_llinfo	pkcb for rt_key(rt)  *  * RTF_GATEWAY  *	rt_key(rt)	X.25 address of host or suitably masked network  *	rt_gateway	X.25 address of next X.25 gateway (switch)  *	rt_llinfo	rtentry for rt_gateway address  *			ought to be of type RTF_HOST  *  *  * Mapping of X.121 to pkcbs:  *  * HDLC uses the DTE-DCE model of X.25, therefore we need a many-to-one  * relationship, i.e.:  *	  * 	{X.121_a, X.121_b, X.121_c, ..., X.121_i} -> pkcb_0  *  * LLC2 utilizes the DTE-DTE model of X.25, resulting effectively in a  * one-to-one relationship, i.e.:  *  *	{X.121_j} 	->	pkcb_1a  *	{X.121_k}	->	pkcb_1b  *	...  *	{X.121_q}	->	pkcb_1q  *   * It might make sense to allow a many-to-one relation for LLC2 also,  *   *	{X.121_r, X.121_s, X.121_t, X.121_u} -> pkcb_2a  *  * This would make addresses X.121_[r-u] essentially aliases of one  * address ({X.121_[r-u]} would constitute a representative set).  *  * Each one-to-one relation must obviously be entered individually with  * a route add command, whereas a many-to-one relationship can be   * either entered individually or generated by using a netmask.  *   * To facilitate dealings the many-to-one case for LLC2 can only be  * established via a netmask.  *  */
end_comment

begin_define
define|#
directive|define
name|XTRACTPKP
parameter_list|(
name|rt
parameter_list|)
value|((rt)->rt_flags& RTF_GATEWAY ? \ 			 ((rt)->rt_llinfo ? \ 			  (struct pkcb *) ((struct rtentry *)((rt)->rt_llinfo))->rt_llinfo : \ 			  (struct pkcb *) NULL) : \ 			 (struct pkcb *)((rt)->rt_llinfo))
end_define

begin_define
define|#
directive|define
name|equal
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|)
value|(bcmp((caddr_t)(a1), \ 			       (caddr_t)(a2), \ 			       (a1)->sa_len) == 0)
end_define

begin_define
define|#
directive|define
name|XIFA
parameter_list|(
name|rt
parameter_list|)
value|((struct x25_ifaddr *)((rt)->rt_ifa))
end_define

begin_function
name|int
name|cons_rtrequest
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|)
block|{
specifier|register
name|struct
name|pkcb
modifier|*
name|pkp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
name|one_to_one
decl_stmt|;
name|struct
name|pkcb
modifier|*
name|pk_newlink
parameter_list|()
function_decl|;
name|struct
name|rtentry
modifier|*
name|npaidb_enter
parameter_list|()
function_decl|;
name|pkp
operator|=
name|XTRACTPKP
argument_list|(
name|rt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RTM_RESOLVE
case|:
case|case
name|RTM_ADD
case|:
if|if
condition|(
name|pkp
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_llinfo
condition|)
name|RTFREE
argument_list|(
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
operator|(
name|caddr_t
operator|)
name|rtalloc1
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Assumptions:	(1) ifnet structure is filled in 		 *		(2) at least the pkcb created via  		 *		    x25config (ifconfig?) has been  		 *		    set up already. 		 *		(3) HDLC interfaces have an if_type of  		 *		    IFT_X25{,DDN}, LLC2 interfaces  		 *		    anything else (any better way to  		 *		    do this?) 		 * 		 */
if|if
condition|(
operator|!
name|rt
operator|->
name|rt_ifa
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/*	 		 * We differentiate between dealing with a many-to-one 		 * (HDLC: DTE-DCE) and a one-to-one (LLC2: DTE-DTE)  		 * relationship (by looking at the if type). 		 * 		 * Only in case of the many-to-one relationship (HDLC) 		 * we set the ia->ia_pkcb pointer to the pkcb allocated 		 * via pk_newlink() as we will use just that one pkcb for 		 * future route additions (the rtentry->rt_llinfo pointer 		 * points to the pkcb allocated for that route). 		 * 		 * In case of the one-to-one relationship (LLC2) we  		 * create a new pkcb (via pk_newlink()) for each new rtentry. 		 *  		 * NOTE: Only in case of HDLC does ia->ia_pkcb point 		 * to a pkcb, in the LLC2 case it doesn't (as we don't  		 * need it here)! 		 */
name|one_to_one
operator|=
name|ISISO8802
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pkp
operator|=
name|XIFA
argument_list|(
name|rt
argument_list|)
operator|->
name|ia_pkcb
operator|)
operator|&&
operator|!
name|one_to_one
condition|)
name|XIFA
argument_list|(
name|rt
argument_list|)
operator|->
name|ia_pkcb
operator|=
name|pkp
operator|=
name|pk_newlink
argument_list|(
name|XIFA
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|one_to_one
operator|&&
operator|!
name|equal
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
name|rt
operator|->
name|rt_ifa
operator|->
name|ifa_addr
argument_list|)
condition|)
block|{
name|pkp
operator|=
name|pk_newlink
argument_list|(
name|XIFA
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * We also need another route entry for mapping 			 * MAC+LSAP->X.25 address 			 */
name|pkp
operator|->
name|pk_llrt
operator|=
name|npaidb_enter
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pkp
condition|)
block|{
if|if
condition|(
operator|!
name|pkp
operator|->
name|pk_rt
condition|)
name|pkp
operator|->
name|pk_rt
operator|=
name|rt
expr_stmt|;
name|pkp
operator|->
name|pk_refcount
operator|++
expr_stmt|;
block|}
name|rt
operator|->
name|rt_llinfo
operator|=
operator|(
name|caddr_t
operator|)
name|pkp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RTM_DELETE
case|:
block|{
comment|/* 		 * The pkp might be empty if we are dealing 		 * with an interface route entry for LLC2, in this  		 * case we don't need to do anything ... 		 */
if|if
condition|(
name|pkp
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_llinfo
condition|)
name|RTFREE
argument_list|(
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pkp
operator|->
name|pk_llrt
condition|)
name|npaidb_destroy
argument_list|(
name|pkp
operator|->
name|pk_llrt
argument_list|)
expr_stmt|;
name|pk_dellink
argument_list|(
name|pkp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Glue between X.25 and LLC2  */
end_comment

begin_function
name|int
name|x25_llcglue
parameter_list|(
name|int
name|prc
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|)
block|{
specifier|register
name|struct
name|sockaddr_x25
modifier|*
name|sx25
init|=
operator|(
expr|struct
name|sockaddr_x25
operator|*
operator|)
name|addr
decl_stmt|;
specifier|register
name|struct
name|x25_ifaddr
modifier|*
name|x25ifa
decl_stmt|;
name|struct
name|dll_ctlinfo
name|ctlinfo
decl_stmt|;
if|if
condition|(
operator|(
name|x25ifa
operator|=
operator|(
expr|struct
name|x25_ifaddr
operator|*
operator|)
name|ifa_ifwithaddr
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ctlinfo
operator|.
name|dlcti_cfg
operator|=
operator|(
expr|struct
name|dllconfig
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_x25
operator|*
operator|)
operator|(
operator|&
name|x25ifa
operator|->
name|ia_xc
operator|)
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|ctlinfo
operator|.
name|dlcti_lsap
operator|=
name|LLC_X25_LSAP
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|llc_ctlinput
argument_list|(
name|prc
argument_list|,
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ctlinfo
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

