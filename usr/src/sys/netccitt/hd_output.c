begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) University of British Columbia, 1984  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Laboratory for Computation Vision and the Computer Science Department  * of the University of British Columbia.  *  * %sccs.include.redist.c%  *  *	@(#)hd_output.c	7.5 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"hdlc.h"
end_include

begin_include
include|#
directive|include
file|"hd_var.h"
end_include

begin_include
include|#
directive|include
file|"x25.h"
end_include

begin_comment
comment|/*  *      HDLC OUTPUT INTERFACE  *  *      This routine is called when the X.25 packet layer output routine  *      has a information frame (iframe)  to write.   It is  also called   *      by the input and control routines of the HDLC layer.  */
end_comment

begin_expr_stmt
name|hd_output
argument_list|(
name|hdp
argument_list|,
name|m0
argument_list|)
specifier|register
expr|struct
name|hdcb
operator|*
name|hdp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|x25config
modifier|*
name|xcp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"hd_output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"hd_output 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdp
operator|->
name|hd_state
operator|!=
name|ABM
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make room for the hdlc header either by prepending 	 * another mbuf, or by adjusting the offset and length 	 * of the first mbuf in the mbuf chain. 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|HDHEADERLN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|hd_append
argument_list|(
operator|&
name|hdp
operator|->
name|hd_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|hd_start
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hd_start
argument_list|(
name|hdp
argument_list|)
specifier|register
expr|struct
name|hdcb
operator|*
name|hdp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/*  	 * The iframe is only transmitted if all these conditions are FALSE. 	 * The iframe remains queued (hdp->hd_txq) however and will be 	 * transmitted as soon as these conditions are cleared. 	 */
while|while
condition|(
operator|!
operator|(
name|hdp
operator|->
name|hd_condition
operator|&
operator|(
name|TIMER_RECOVERY_CONDITION
operator||
name|REMOTE_RNR_CONDITION
operator||
name|REJ_CONDITION
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|hdp
operator|->
name|hd_vs
operator|==
operator|(
name|hdp
operator|->
name|hd_lastrxnr
operator|+
name|hdp
operator|->
name|hd_xcp
operator|->
name|xc_lwsize
operator|)
operator|%
name|MODULUS
condition|)
block|{
comment|/* We have now exceeded the  maximum  number  of  			   outstanding iframes. Therefore,  we must wait  			   until  at least  one is acknowledged if this  			   condition  is not  turned off before we are 			   requested to write another iframe. */
name|hdp
operator|->
name|hd_window_condition
operator|++
expr_stmt|;
break|break;
block|}
comment|/* hd_remove top iframe from transmit queue. */
if|if
condition|(
operator|(
name|m
operator|=
name|hd_remove
argument_list|(
operator|&
name|hdp
operator|->
name|hd_txq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|hd_send_iframe
argument_list|(
name|hdp
argument_list|,
name|m
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*   *  This procedure is passed a buffer descriptor for an iframe. It builds  *  the rest of the control part of the frame and then writes it out.  It  *  also  starts the  acknowledgement  timer and keeps  the iframe in the  *  Retransmit queue (Retxq) just in case  we have to do this again.  *  *  Note: This routine is also called from hd_input.c when retransmission  *       of old frames is required.  */
end_comment

begin_expr_stmt
name|hd_send_iframe
argument_list|(
name|hdp
argument_list|,
name|buf
argument_list|,
name|poll_bit
argument_list|)
specifier|register
expr|struct
name|hdcb
operator|*
name|hdp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|poll_bit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|Hdlc_iframe
modifier|*
name|iframe
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|KILL_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hd_send_iframe: zero arg\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HDLCDEBUG
name|hd_status
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hd_dumptrace
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hdp
operator|->
name|hd_vs
operator|=
operator|(
name|hdp
operator|->
name|hd_vs
operator|+
literal|7
operator|)
operator|%
name|MODULUS
expr_stmt|;
return|return;
block|}
name|iframe
operator|=
name|mtod
argument_list|(
name|buf
argument_list|,
expr|struct
name|Hdlc_iframe
operator|*
argument_list|)
expr_stmt|;
name|iframe
operator|->
name|hdlc_0
operator|=
literal|0
expr_stmt|;
name|iframe
operator|->
name|nr
operator|=
name|hdp
operator|->
name|hd_vr
expr_stmt|;
name|iframe
operator|->
name|pf
operator|=
name|poll_bit
expr_stmt|;
name|iframe
operator|->
name|ns
operator|=
name|hdp
operator|->
name|hd_vs
expr_stmt|;
name|iframe
operator|->
name|address
operator|=
name|ADDRESS_B
expr_stmt|;
name|hdp
operator|->
name|hd_lasttxnr
operator|=
name|hdp
operator|->
name|hd_vr
expr_stmt|;
name|hdp
operator|->
name|hd_rrtimer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdp
operator|->
name|hd_vs
operator|==
name|hdp
operator|->
name|hd_retxqi
condition|)
block|{
comment|/* Check for retransmissions. */
comment|/* Put iframe only once in the Retransmission queue. */
name|hdp
operator|->
name|hd_retxq
index|[
name|hdp
operator|->
name|hd_retxqi
index|]
operator|=
name|buf
expr_stmt|;
name|hdp
operator|->
name|hd_retxqi
operator|=
operator|(
name|hdp
operator|->
name|hd_retxqi
operator|+
literal|1
operator|)
operator|%
name|MODULUS
expr_stmt|;
name|hdp
operator|->
name|hd_iframes_out
operator|++
expr_stmt|;
block|}
name|hdp
operator|->
name|hd_vs
operator|=
operator|(
name|hdp
operator|->
name|hd_vs
operator|+
literal|1
operator|)
operator|%
name|MODULUS
expr_stmt|;
name|hd_trace
argument_list|(
name|hdp
argument_list|,
name|TX
argument_list|,
operator|(
expr|struct
name|Hdlc_frame
operator|*
operator|)
name|iframe
argument_list|)
expr_stmt|;
comment|/* Write buffer on device. */
name|m
operator|=
name|hdp
operator|->
name|hd_dontcopy
condition|?
name|buf
else|:
name|m_copy
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hdlc: out of mbufs\n"
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
modifier|*
name|hdp
operator|->
name|hd_output
call|)
argument_list|(
name|hdp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hd_ifoutput
argument_list|(
name|hdp
argument_list|,
name|m
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * Queue message on interface, and start output if interface 	 * not yet active. 	 */
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|hdp
operator|->
name|hd_ifp
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* printf("%s%d: HDLC says OK to send but queue full, may hang\n", 			ifp->if_name, ifp->if_unit);*/
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|ifp
operator|->
name|if_start
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   *  This routine gets control when the timer expires because we have not  *  received an acknowledgement for a iframe.  */
end_comment

begin_expr_stmt
name|hd_resend_iframe
argument_list|(
name|hdp
argument_list|)
specifier|register
expr|struct
name|hdcb
operator|*
name|hdp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|hdp
operator|->
name|hd_retxcnt
operator|++
operator|<
name|hd_n2
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|hdp
operator|->
name|hd_condition
operator|&
name|TIMER_RECOVERY_CONDITION
operator|)
condition|)
block|{
name|hdp
operator|->
name|hd_xx
operator|=
name|hdp
operator|->
name|hd_vs
expr_stmt|;
name|hdp
operator|->
name|hd_condition
operator||=
name|TIMER_RECOVERY_CONDITION
expr_stmt|;
block|}
name|hdp
operator|->
name|hd_vs
operator|=
name|hdp
operator|->
name|hd_lastrxnr
expr_stmt|;
name|hd_send_iframe
argument_list|(
name|hdp
argument_list|,
name|hdp
operator|->
name|hd_retxq
index|[
name|hdp
operator|->
name|hd_vs
index|]
argument_list|,
name|POLLON
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* At this point we have not received a RR even after N2 		   retries - attempt to reset link. */
name|hd_initvars
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|SABM
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|WAIT_UA
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hd_message
argument_list|(
name|hdp
argument_list|,
literal|"Timer recovery failed: link down"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pk_ctlinput
argument_list|(
name|PRC_LINKDOWN
argument_list|,
name|hdp
operator|->
name|hd_xcp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

