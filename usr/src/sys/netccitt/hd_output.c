begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) University of British Columbia, 1984  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Laboratory for Computation Vision and the Computer Science Department  * of the University of British Columbia.  *  * %sccs.include.redist.c%  *  *	@(#)hd_output.c	7.2 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/domain.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/time.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../netccitt/hdlc.h"
end_include

begin_include
include|#
directive|include
file|"../netccitt/hd_var.h"
end_include

begin_include
include|#
directive|include
file|"../netccitt/x25.h"
end_include

begin_comment
comment|/*  *      HDLC OUTPUT INTERFACE  *  *      This routine is called when the X.25 packet layer output routine  *      has a information frame (iframe)  to write.   It is  also called   *      by the input and control routines of the HDLC layer.  */
end_comment

begin_macro
name|hd_output
argument_list|(
argument|m
argument_list|,
argument|xcp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|x25config
modifier|*
name|xcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
specifier|static
name|struct
name|x25config
modifier|*
name|lastxcp
decl_stmt|;
specifier|static
name|struct
name|hdcb
modifier|*
name|lasthdp
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"hd_output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xcp
operator|==
name|lastxcp
condition|)
name|hdp
operator|=
name|lasthdp
expr_stmt|;
else|else
block|{
for|for
control|(
name|hdp
operator|=
name|hdcbhead
init|;
condition|;
name|hdp
operator|=
name|hdp
operator|->
name|hd_next
control|)
block|{
if|if
condition|(
name|hdp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hd_output: can't find hdcb for %X\n"
argument_list|,
name|xcp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hdp
operator|->
name|hd_xcp
operator|==
name|xcp
condition|)
break|break;
block|}
name|lastxcp
operator|=
name|xcp
expr_stmt|;
name|lasthdp
operator|=
name|hdp
expr_stmt|;
block|}
if|if
condition|(
name|hdp
operator|->
name|hd_state
operator|!=
name|ABM
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make room for the hdlc header either by prepending 	 * another mbuf, or by adjusting the offset and length 	 * of the first mbuf in the mbuf chain. 	 */
if|if
condition|(
name|m
operator|->
name|m_off
operator|<
name|MMINOFF
operator|+
name|HDHEADERLN
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|m0
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m0
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
name|HDHEADERLN
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_off
operator|-=
name|HDHEADERLN
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|HDHEADERLN
expr_stmt|;
block|}
name|hd_append
argument_list|(
operator|&
name|hdp
operator|->
name|hd_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|hd_start
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hd_start
argument_list|(
name|hdp
argument_list|)
specifier|register
expr|struct
name|hdcb
operator|*
name|hdp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/*  	 * The iframe is only transmitted if all these conditions are FALSE. 	 * The iframe remains queued (hdp->hd_txq) however and will be 	 * transmitted as soon as these conditions are cleared. 	 */
while|while
condition|(
operator|!
operator|(
name|hdp
operator|->
name|hd_condition
operator|&
operator|(
name|TIMER_RECOVERY_CONDITION
operator||
name|REMOTE_RNR_CONDITION
operator||
name|REJ_CONDITION
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|hdp
operator|->
name|hd_vs
operator|==
operator|(
name|hdp
operator|->
name|hd_lastrxnr
operator|+
name|hdp
operator|->
name|hd_xcp
operator|->
name|xc_lwsize
operator|)
operator|%
name|MODULUS
condition|)
block|{
comment|/* We have now exceeded the  maximum  number  of  			   outstanding iframes. Therefore,  we must wait  			   until  at least  one is acknowledged if this  			   condition  is not  turned off before we are 			   requested to write another iframe. */
name|hdp
operator|->
name|hd_window_condition
operator|++
expr_stmt|;
break|break;
block|}
comment|/* hd_remove top iframe from transmit queue. */
if|if
condition|(
operator|(
name|m
operator|=
name|hd_remove
argument_list|(
operator|&
name|hdp
operator|->
name|hd_txq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|hd_send_iframe
argument_list|(
name|hdp
argument_list|,
name|m
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*   *  This procedure is passed a buffer descriptor for an iframe. It builds  *  the rest of the control part of the frame and then writes it out.  It  *  also  starts the  acknowledgement  timer and keeps  the iframe in the  *  Retransmit queue (Retxq) just in case  we have to do this again.  *  *  Note: This routine is also called from hd_input.c when retransmission  *       of old frames is required.  */
end_comment

begin_expr_stmt
name|hd_send_iframe
argument_list|(
name|hdp
argument_list|,
name|buf
argument_list|,
name|poll_bit
argument_list|)
specifier|register
expr|struct
name|hdcb
operator|*
name|hdp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|poll_bit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|Hdlc_iframe
modifier|*
name|iframe
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|hdp
operator|->
name|hd_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|KILL_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hd_send_iframe: zero arg\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HDLCDEBUG
name|hd_status
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hd_dumptrace
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hdp
operator|->
name|hd_vs
operator|=
operator|(
name|hdp
operator|->
name|hd_vs
operator|+
literal|7
operator|)
operator|%
name|MODULUS
expr_stmt|;
return|return;
block|}
name|iframe
operator|=
name|mtod
argument_list|(
name|buf
argument_list|,
expr|struct
name|Hdlc_iframe
operator|*
argument_list|)
expr_stmt|;
name|iframe
operator|->
name|hdlc_0
operator|=
literal|0
expr_stmt|;
name|iframe
operator|->
name|nr
operator|=
name|hdp
operator|->
name|hd_vr
expr_stmt|;
name|iframe
operator|->
name|pf
operator|=
name|poll_bit
expr_stmt|;
name|iframe
operator|->
name|ns
operator|=
name|hdp
operator|->
name|hd_vs
expr_stmt|;
name|iframe
operator|->
name|address
operator|=
name|ADDRESS_B
expr_stmt|;
name|hdp
operator|->
name|hd_lasttxnr
operator|=
name|hdp
operator|->
name|hd_vr
expr_stmt|;
name|hdp
operator|->
name|hd_rrtimer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdp
operator|->
name|hd_vs
operator|==
name|hdp
operator|->
name|hd_retxqi
condition|)
block|{
comment|/* Check for retransmissions. */
comment|/* Put iframe only once in the Retransmission queue. */
name|hdp
operator|->
name|hd_retxq
index|[
name|hdp
operator|->
name|hd_retxqi
index|]
operator|=
name|buf
expr_stmt|;
name|hdp
operator|->
name|hd_retxqi
operator|=
operator|(
name|hdp
operator|->
name|hd_retxqi
operator|+
literal|1
operator|)
operator|%
name|MODULUS
expr_stmt|;
name|hdp
operator|->
name|hd_iframes_out
operator|++
expr_stmt|;
block|}
name|hdp
operator|->
name|hd_vs
operator|=
operator|(
name|hdp
operator|->
name|hd_vs
operator|+
literal|1
operator|)
operator|%
name|MODULUS
expr_stmt|;
name|hd_trace
argument_list|(
name|hdp
argument_list|,
name|TX
argument_list|,
operator|(
expr|struct
name|Hdlc_frame
operator|*
operator|)
name|iframe
argument_list|)
expr_stmt|;
comment|/* Write buffer on device. */
name|m
operator|=
name|hdp
operator|->
name|hd_dontcopy
condition|?
name|buf
else|:
name|m_copy
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hdlc: out of mbufs\n"
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|hdp
operator|->
name|hd_xcp
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   *  This routine gets control when the timer expires because we have not  *  received an acknowledgement for a iframe.  */
end_comment

begin_expr_stmt
name|hd_resend_iframe
argument_list|(
name|hdp
argument_list|)
specifier|register
expr|struct
name|hdcb
operator|*
name|hdp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|hdp
operator|->
name|hd_retxcnt
operator|++
operator|<
name|hd_n2
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|hdp
operator|->
name|hd_condition
operator|&
name|TIMER_RECOVERY_CONDITION
operator|)
condition|)
block|{
name|hdp
operator|->
name|hd_xx
operator|=
name|hdp
operator|->
name|hd_vs
expr_stmt|;
name|hdp
operator|->
name|hd_condition
operator||=
name|TIMER_RECOVERY_CONDITION
expr_stmt|;
block|}
name|hdp
operator|->
name|hd_vs
operator|=
name|hdp
operator|->
name|hd_lastrxnr
expr_stmt|;
name|hd_send_iframe
argument_list|(
name|hdp
argument_list|,
name|hdp
operator|->
name|hd_retxq
index|[
name|hdp
operator|->
name|hd_vs
index|]
argument_list|,
name|POLLON
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* At this point we have not received a RR even after N2 		   retries - attempt to reset link. */
name|hd_initvars
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|SABM
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|WAIT_UA
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hd_message
argument_list|(
name|hdp
argument_list|,
literal|"Timer recovery failed: link down"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pk_ctlinput
argument_list|(
name|PRC_LINKDOWN
argument_list|,
name|hdp
operator|->
name|hd_xcp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

