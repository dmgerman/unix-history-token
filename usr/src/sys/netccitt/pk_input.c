begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) University of British Columbia, 1984 */
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../netccitt/x25.h"
end_include

begin_include
include|#
directive|include
file|"../netccitt/pk.h"
end_include

begin_include
include|#
directive|include
file|"../netccitt/pk_var.h"
end_include

begin_function
name|struct
name|pkcb
modifier|*
name|pk_newlink
parameter_list|(
name|xcp
parameter_list|)
name|struct
name|x25config
modifier|*
name|xcp
decl_stmt|;
block|{
specifier|register
name|struct
name|pkcb
modifier|*
name|pkp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|pklcd
modifier|*
name|lcp
decl_stmt|;
specifier|register
name|struct
name|protosw
modifier|*
name|pp
decl_stmt|;
specifier|register
name|unsigned
name|size
decl_stmt|;
if|if
condition|(
name|xcp
operator|->
name|xc_ntnlen
operator|<=
literal|0
operator|||
name|xcp
operator|->
name|xc_ntnlen
operator|>
sizeof|sizeof
argument_list|(
name|xcp
operator|->
name|xc_ntn
argument_list|)
operator|*
literal|2
condition|)
return|return
operator|(
operator|(
expr|struct
name|pkcb
operator|*
operator|)
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|BSD4_3
name|pp
operator|=
name|pffindproto
argument_list|(
name|AF_CCITT
argument_list|,
operator|(
name|int
operator|)
name|xcp
operator|->
name|xc_lproto
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|pp
operator|=
name|pffindproto
argument_list|(
name|AF_CCITT
argument_list|,
operator|(
name|int
operator|)
name|xcp
operator|->
name|xc_lproto
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pp
operator|==
literal|0
operator|||
name|pp
operator|->
name|pr_output
operator|==
literal|0
condition|)
block|{
name|pk_message
argument_list|(
literal|0
argument_list|,
name|xcp
argument_list|,
literal|"link level protosw error"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|pkcb
operator|*
operator|)
literal|0
operator|)
return|;
block|}
comment|/* 	 * Allocate a network control block structure 	 */
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pkcb
argument_list|)
operator|+
name|xcp
operator|->
name|xc_maxlcn
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pklcd
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|xcp
operator|->
name|xc_maxlcn
operator|<
literal|1
operator|||
name|size
operator|>
name|mclbytes
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|xcp
operator|->
name|xc_maxlcn
operator|<
literal|1
operator|||
name|size
operator|>
name|CLBYTES
condition|)
block|{
endif|#
directive|endif
name|pk_message
argument_list|(
literal|0
argument_list|,
name|xcp
argument_list|,
literal|"invalid maxlcn"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|pkcb
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_PCB
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
expr|struct
name|pkcb
operator|*
operator|)
literal|0
operator|)
return|;
if|if
condition|(
name|size
operator|>
name|MLEN
condition|)
block|{
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|mclget
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|pkcb
operator|*
operator|)
literal|0
operator|)
return|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD4_3
name|MCLGET
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|CLBYTES
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|pkcb
operator|*
operator|)
literal|0
operator|)
return|;
block|}
else|#
directive|else
specifier|register
name|struct
name|mbuf
modifier|*
name|p
decl_stmt|;
name|MCLGET
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|pkcb
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|m
operator|->
name|m_off
operator|=
operator|(
name|int
operator|)
name|p
operator|-
operator|(
name|int
operator|)
name|m
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
name|pkp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pkcb
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|pkp
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a logical channel descriptor for lcn 0 	 */
name|m
operator|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_PCB
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|pkcb
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|lcp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pklcd
operator|*
argument_list|)
expr_stmt|;
name|lcp
operator|->
name|lcd_state
operator|=
name|READY
expr_stmt|;
name|lcp
operator|->
name|lcd_pkp
operator|=
name|pkp
expr_stmt|;
name|pkp
operator|->
name|pk_chan
index|[
literal|0
index|]
operator|=
name|lcp
expr_stmt|;
name|pkp
operator|->
name|pk_output
operator|=
name|pp
operator|->
name|pr_output
expr_stmt|;
name|pkp
operator|->
name|pk_xcp
operator|=
name|xcp
expr_stmt|;
name|pkp
operator|->
name|pk_state
operator|=
name|DTE_WAITING
expr_stmt|;
name|pkp
operator|->
name|pk_maxlcn
operator|=
name|xcp
operator|->
name|xc_maxlcn
expr_stmt|;
name|pkp
operator|->
name|pk_next
operator|=
name|pkcbhead
expr_stmt|;
name|pkcbhead
operator|=
name|pkp
expr_stmt|;
comment|/* 	 * set defaults 	 */
if|if
condition|(
name|xcp
operator|->
name|xc_pwsize
operator|==
literal|0
condition|)
name|xcp
operator|->
name|xc_pwsize
operator|=
name|DEFAULT_WINDOW_SIZE
expr_stmt|;
if|if
condition|(
name|xcp
operator|->
name|xc_psize
operator|==
literal|0
condition|)
name|xcp
operator|->
name|xc_psize
operator|=
name|X25_PS128
expr_stmt|;
return|return
operator|(
name|pkp
operator|)
return|;
block|}
comment|/*   *  This procedure is called by the link level whenever the link  *  becomes operational, is reset, or when the link goes down.   */
name|pk_ctlinput
argument_list|(
argument|code
argument_list|,
argument|xcp
argument_list|)
name|struct
name|x25config
modifier|*
name|xcp
decl_stmt|;
block|{
specifier|register
name|struct
name|pkcb
modifier|*
name|pkp
decl_stmt|;
for|for
control|(
name|pkp
operator|=
name|pkcbhead
init|;
name|pkp
condition|;
name|pkp
operator|=
name|pkp
operator|->
name|pk_next
control|)
if|if
condition|(
name|pkp
operator|->
name|pk_xcp
operator|==
name|xcp
condition|)
break|break;
if|if
condition|(
name|pkp
operator|==
literal|0
operator|&&
operator|(
name|pkp
operator|=
name|pk_newlink
argument_list|(
name|xcp
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PRC_LINKUP
case|:
if|if
condition|(
name|pkp
operator|->
name|pk_state
operator|==
name|DTE_WAITING
condition|)
name|pk_restart
argument_list|(
name|pkp
argument_list|,
name|X25_RESTART_NETWORK_CONGESTION
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_LINKDOWN
case|:
name|pk_restart
argument_list|(
name|pkp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Clear all active circuits */
name|pkp
operator|->
name|pk_state
operator|=
name|DTE_WAITING
expr_stmt|;
break|break;
case|case
name|PRC_LINKRESET
case|:
name|pk_restart
argument_list|(
name|pkp
argument_list|,
name|X25_RESTART_NETWORK_CONGESTION
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*   *  X.25 PACKET INPUT  *  *  This procedure is called by a link level procedure whenever  *  an information frame is received. It decodes the packet and  *  demultiplexes based on the logical channel number.  *  */
name|pk_input
argument_list|(
name|m
argument_list|,
name|xcp
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
name|struct
name|x25config
modifier|*
name|xcp
decl_stmt|;
block|{
specifier|register
name|struct
name|x25_packet
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|pklcd
modifier|*
name|lcp
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|pkcb
modifier|*
name|pkp
decl_stmt|;
name|int
name|ptype
decl_stmt|,
name|lcn
decl_stmt|,
name|lcdstate
init|=
name|LISTEN
decl_stmt|;
specifier|static
name|struct
name|x25config
modifier|*
name|lastxcp
decl_stmt|;
specifier|static
name|struct
name|pkcb
modifier|*
name|lastpkp
decl_stmt|;
if|if
condition|(
name|xcp
operator|==
name|lastxcp
condition|)
name|pkp
operator|=
name|lastpkp
expr_stmt|;
else|else
block|{
for|for
control|(
name|pkp
operator|=
name|pkcbhead
init|;
condition|;
name|pkp
operator|=
name|pkp
operator|->
name|pk_next
control|)
block|{
if|if
condition|(
name|pkp
operator|==
literal|0
condition|)
block|{
name|pk_message
argument_list|(
literal|0
argument_list|,
name|xcp
argument_list|,
literal|"pk_input: unknown network"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pkp
operator|->
name|pk_xcp
operator|==
name|xcp
condition|)
break|break;
block|}
name|lastxcp
operator|=
name|xcp
expr_stmt|;
name|lastpkp
operator|=
name|pkp
expr_stmt|;
block|}
name|xp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|x25_packet
operator|*
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|pk_decode
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|lcn
operator|=
name|xp
operator|->
name|logical_channel_number
expr_stmt|;
name|lcp
operator|=
name|pkp
operator|->
name|pk_chan
index|[
name|lcn
index|]
expr_stmt|;
comment|/*  	 *  If the DTE is in Restart  state, then it will ignore data,  	 *  interrupt, call setup and clearing, flow control and reset  	 *  packets. 	 */
if|if
condition|(
name|lcn
operator|<
literal|0
operator|||
name|lcn
operator|>
name|pkp
operator|->
name|pk_maxlcn
condition|)
block|{
name|pk_message
argument_list|(
name|lcn
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"illegal lcn"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|pk_trace
argument_list|(
name|pkp
operator|->
name|pk_xcp
argument_list|,
name|xp
argument_list|,
literal|"P-In"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkp
operator|->
name|pk_state
operator|!=
name|DTE_READY
operator|&&
name|ptype
operator|!=
name|RESTART
operator|&&
name|ptype
operator|!=
name|RESTART_CONF
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lcp
condition|)
block|{
name|so
operator|=
name|lcp
operator|->
name|lcd_so
expr_stmt|;
name|lcdstate
operator|=
name|lcp
operator|->
name|lcd_state
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ptype
operator|==
name|CLEAR
condition|)
block|{
comment|/* idle line probe (Datapac specific) */
comment|/* send response on lcd 0's output queue */
name|lcp
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
name|lcn
argument_list|,
name|X25_CLEAR_CONFIRM
argument_list|)
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ptype
operator|!=
name|CALL
condition|)
name|ptype
operator|=
name|INVALID_PACKET
expr_stmt|;
block|}
if|if
condition|(
name|lcn
operator|==
literal|0
operator|&&
name|ptype
operator|!=
name|RESTART
operator|&&
name|ptype
operator|!=
name|RESTART_CONF
condition|)
block|{
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"illegal ptype (%s) on lcn 0"
argument_list|,
name|pk_name
index|[
name|ptype
operator|/
name|MAXSTATES
index|]
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ptype
operator|+
name|lcdstate
condition|)
block|{
comment|/*  	 *  Incoming Call packet received.  	 */
case|case
name|CALL
operator|+
name|LISTEN
case|:
name|incoming_call
argument_list|(
name|pkp
argument_list|,
name|xp
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 	 *  Call collision: Just throw this "incoming call" away since  	 *  the DCE will ignore it anyway.  	 */
case|case
name|CALL
operator|+
name|SENT_CALL
case|:
name|pk_message
argument_list|(
operator|(
name|int
operator|)
name|xp
operator|->
name|logical_channel_number
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"incoming call collision"
argument_list|)
expr_stmt|;
break|break;
comment|/*  	 *  Call confirmation packet received. This usually means our 	 *  previous connect request is now complete. 	 */
case|case
name|CALL_ACCEPTED
operator|+
name|SENT_CALL
case|:
name|call_accepted
argument_list|(
name|lcp
argument_list|,
name|xp
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
break|break;
comment|/*  	 *  This condition can only happen if the previous state was 	 *  SENT_CALL. Just ignore the packet, eventually a clear  	 *  confirmation should arrive. 	 */
case|case
name|CALL_ACCEPTED
operator|+
name|SENT_CLEAR
case|:
break|break;
comment|/*  	 *  Clear packet received. This requires a complete tear down 	 *  of the virtual circuit.  Free buffers and control blocks. 	 *  and send a clear confirmation. 	 */
case|case
name|CLEAR
operator|+
name|READY
case|:
case|case
name|CLEAR
operator|+
name|RECEIVED_CALL
case|:
case|case
name|CLEAR
operator|+
name|SENT_CALL
case|:
case|case
name|CLEAR
operator|+
name|DATA_TRANSFER
case|:
name|lcp
operator|->
name|lcd_state
operator|=
name|RECEIVED_CLEAR
expr_stmt|;
name|lcp
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
name|lcp
operator|->
name|lcd_lcn
argument_list|,
name|X25_CLEAR_CONFIRM
argument_list|)
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
name|pk_clearcause
argument_list|(
name|pkp
argument_list|,
name|xp
argument_list|)
expr_stmt|;
name|pk_close
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
break|break;
comment|/*  	 *  Clear collision: Treat this clear packet as a confirmation. 	 */
case|case
name|CLEAR
operator|+
name|SENT_CLEAR
case|:
name|pk_close
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
break|break;
comment|/*  	 *  Clear confirmation received. This usually means the virtual 	 *  circuit is now completely removed. 	 */
case|case
name|CLEAR_CONF
operator|+
name|SENT_CLEAR
case|:
name|pk_close
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
break|break;
comment|/*  	 *  A clear confirmation on an unassigned logical channel - just 	 *  ignore it. Note: All other packets on an unassigned channel 	 *  results in a clear. 	 */
case|case
name|CLEAR_CONF
operator|+
name|READY
case|:
break|break;
comment|/*  	 *  Data packet received. Pass on to next level. Move the Q and M 	 *  bits into the data portion for the next level. 	 */
case|case
name|DATA
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
condition|)
block|{
name|ptype
operator|=
name|DELETE_PACKET
expr_stmt|;
break|break;
block|}
comment|/*  		 *  Process the P(S) flow control information in this Data packet.  		 *  Check that the packets arrive in the correct sequence and that  		 *  they are within the "lcd_input_window". Input window rotation is  		 *  initiated by the receive interface. 		 */
if|if
condition|(
name|PS
argument_list|(
name|xp
argument_list|)
operator|!=
operator|(
operator|(
name|lcp
operator|->
name|lcd_rsn
operator|+
literal|1
operator|)
operator|%
name|MODULUS
operator|)
operator|||
name|PS
argument_list|(
name|xp
argument_list|)
operator|==
operator|(
operator|(
name|lcp
operator|->
name|lcd_input_window
operator|+
name|lcp
operator|->
name|lcd_windowsize
operator|)
operator|%
name|MODULUS
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pk_procerror
argument_list|(
name|RESET
argument_list|,
name|lcp
argument_list|,
literal|"p(s) flow control error"
argument_list|)
expr_stmt|;
break|break;
block|}
name|lcp
operator|->
name|lcd_rsn
operator|=
name|PS
argument_list|(
name|xp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pk_ack
argument_list|(
name|lcp
argument_list|,
name|PR
argument_list|(
name|xp
argument_list|)
argument_list|)
operator|!=
name|PACKET_OK
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|->
name|m_off
operator|+=
name|PKHEADERLN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|PKHEADERLN
expr_stmt|;
if|if
condition|(
name|lcp
operator|->
name|lcd_flags
operator|&
name|X25_MQBIT
condition|)
block|{
name|octet
modifier|*
name|t
decl_stmt|;
name|m
operator|->
name|m_off
operator|-=
literal|1
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
literal|1
expr_stmt|;
name|t
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|octet
operator|*
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|q_bit
condition|)
operator|*
name|t
operator||=
literal|0x80
expr_stmt|;
if|if
condition|(
name|MBIT
argument_list|(
name|xp
argument_list|)
condition|)
operator|*
name|t
operator||=
literal|0x40
expr_stmt|;
block|}
comment|/* 		 * Discard Q-BIT packets if the application 		 * doesn't want to be informed of M and Q bit status 		 */
if|if
condition|(
name|xp
operator|->
name|q_bit
operator|&&
operator|(
name|lcp
operator|->
name|lcd_flags
operator|&
name|X25_MQBIT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|lcp
operator|->
name|lcd_rxcnt
operator|++
expr_stmt|;
comment|/* 			 * NB.  This is dangerous: sending a RR here can 			 * cause sequence number errors if a previous data 			 * packet has not yet been passed up to the application 			 * (RR's are normally generated via PRU_RCVD). 			 */
name|lcp
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
name|lcp
operator|->
name|lcd_lcn
argument_list|,
name|X25_RR
argument_list|)
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BSD4_3
name|sbappendrecord
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|sbappend
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*  	 *  Interrupt packet received. 	 */
case|case
name|INTERRUPT
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
condition|)
break|break;
name|lcp
operator|->
name|lcd_intrdata
operator|=
name|xp
operator|->
name|packet_data
expr_stmt|;
name|sohasoutofband
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|lcp
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
name|lcp
operator|->
name|lcd_lcn
argument_list|,
name|X25_INTERRUPT_CONFIRM
argument_list|)
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
break|break;
comment|/*  	 *  Interrupt confirmation packet received. 	 */
case|case
name|INTERRUPT_CONF
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
condition|)
break|break;
if|if
condition|(
name|lcp
operator|->
name|lcd_intrconf_pending
operator|==
name|TRUE
condition|)
name|lcp
operator|->
name|lcd_intrconf_pending
operator|=
name|FALSE
expr_stmt|;
else|else
name|pk_procerror
argument_list|(
name|RESET
argument_list|,
name|lcp
argument_list|,
literal|"unexpected packet"
argument_list|)
expr_stmt|;
break|break;
comment|/*  	 *  Receiver ready received. Rotate the output window and output 	 *  any data packets waiting transmission. 	 */
case|case
name|RR
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
condition|)
break|break;
if|if
condition|(
name|pk_ack
argument_list|(
name|lcp
argument_list|,
name|PR
argument_list|(
name|xp
argument_list|)
argument_list|)
operator|!=
name|PACKET_OK
condition|)
break|break;
if|if
condition|(
name|lcp
operator|->
name|lcd_rnr_condition
operator|==
name|TRUE
condition|)
name|lcp
operator|->
name|lcd_rnr_condition
operator|=
name|FALSE
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
break|break;
comment|/*  	 *  Receiver Not Ready received. Packets up to the P(R) can be 	 *  be sent. Condition is cleared with a RR. 	 */
case|case
name|RNR
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
condition|)
break|break;
if|if
condition|(
name|pk_ack
argument_list|(
name|lcp
argument_list|,
name|PR
argument_list|(
name|xp
argument_list|)
argument_list|)
operator|!=
name|PACKET_OK
condition|)
break|break;
name|lcp
operator|->
name|lcd_rnr_condition
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/*  	 *  Reset packet received. Set state to FLOW_OPEN.  The Input and 	 *  Output window edges ar set to zero. Both the send and receive 	 *  numbers are reset. A confirmation is returned. 	 */
case|case
name|RESET
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
condition|)
comment|/* Reset collision. Just ignore packet. */
break|break;
name|pk_resetcause
argument_list|(
name|pkp
argument_list|,
name|xp
argument_list|)
expr_stmt|;
name|sbflush
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|sbflush
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|so
operator|->
name|so_timeo
argument_list|)
expr_stmt|;
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|lcp
operator|->
name|lcd_window_condition
operator|=
name|lcp
operator|->
name|lcd_rnr_condition
operator|=
name|lcp
operator|->
name|lcd_intrconf_pending
operator|=
name|FALSE
expr_stmt|;
name|lcp
operator|->
name|lcd_output_window
operator|=
name|lcp
operator|->
name|lcd_input_window
operator|=
name|lcp
operator|->
name|lcd_last_transmitted_pr
operator|=
literal|0
expr_stmt|;
name|lcp
operator|->
name|lcd_ssn
operator|=
literal|0
expr_stmt|;
name|lcp
operator|->
name|lcd_rsn
operator|=
name|MODULUS
operator|-
literal|1
expr_stmt|;
name|lcp
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
name|lcp
operator|->
name|lcd_lcn
argument_list|,
name|X25_RESET_CONFIRM
argument_list|)
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
break|break;
comment|/*  	 *  Reset confirmation received. 	 */
case|case
name|RESET_CONF
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
condition|)
block|{
name|lcp
operator|->
name|lcd_reset_condition
operator|=
name|FALSE
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
block|}
else|else
name|pk_procerror
argument_list|(
name|RESET
argument_list|,
name|lcp
argument_list|,
literal|"unexpected packet"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA
operator|+
name|SENT_CLEAR
case|:
name|ptype
operator|=
name|DELETE_PACKET
expr_stmt|;
case|case
name|RR
operator|+
name|SENT_CLEAR
case|:
case|case
name|RNR
operator|+
name|SENT_CLEAR
case|:
case|case
name|INTERRUPT
operator|+
name|SENT_CLEAR
case|:
case|case
name|INTERRUPT_CONF
operator|+
name|SENT_CLEAR
case|:
case|case
name|RESET
operator|+
name|SENT_CLEAR
case|:
case|case
name|RESET_CONF
operator|+
name|SENT_CLEAR
case|:
comment|/* Just ignore packet if we have sent a CLEAR already. 		   */
break|break;
comment|/*  	 *  Restart sets all the permanent virtual circuits to the "Data 	 *  Transfer" stae and  all the switched virtual circuits to the 	 *  "Ready" state. 	 */
case|case
name|RESTART
operator|+
name|READY
case|:
switch|switch
condition|(
name|pkp
operator|->
name|pk_state
condition|)
block|{
case|case
name|DTE_SENT_RESTART
case|:
comment|/* Restart collision. */
name|pkp
operator|->
name|pk_state
operator|=
name|DTE_READY
expr_stmt|;
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"Packet level operational"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pk_restart
argument_list|(
name|pkp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pk_restartcause
argument_list|(
name|pkp
argument_list|,
name|xp
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|pk_chan
index|[
literal|0
index|]
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
literal|0
argument_list|,
name|X25_RESTART_CONFIRM
argument_list|)
expr_stmt|;
name|pk_output
argument_list|(
name|pkp
operator|->
name|pk_chan
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*  	 *  Restart confirmation received. All logical channels are set 	 *  to READY.  	 */
case|case
name|RESTART_CONF
operator|+
name|READY
case|:
switch|switch
condition|(
name|pkp
operator|->
name|pk_state
condition|)
block|{
case|case
name|DTE_SENT_RESTART
case|:
name|pkp
operator|->
name|pk_state
operator|=
name|DTE_READY
expr_stmt|;
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"Packet level operational"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Restart local procedure error. */
name|pk_restart
argument_list|(
name|pkp
argument_list|,
name|X25_RESTART_LOCAL_PROCEDURE_ERROR
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|pk_state
operator|=
name|DTE_SENT_RESTART
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|lcp
condition|)
block|{
name|pk_procerror
argument_list|(
name|CLEAR
argument_list|,
name|lcp
argument_list|,
literal|"unknown packet error"
argument_list|)
expr_stmt|;
name|pk_message
argument_list|(
name|lcn
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"\"%s\" unexpected in \"%s\" state"
argument_list|,
name|pk_name
index|[
name|ptype
operator|/
name|MAXSTATES
index|]
argument_list|,
name|pk_state
index|[
name|lcdstate
index|]
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Packets arrived on an unassigned channel.  			*/
name|pk_message
argument_list|(
operator|(
name|int
operator|)
name|xp
operator|->
name|logical_channel_number
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"packet arrived on unassigned lcn"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ptype
operator|!=
name|DATA
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/*   * This routine handles incoming call packets. It matches the protocol  * field on the Call User Data field (usually the first four bytes) with   * sockets awaiting connections.  */
specifier|static
name|incoming_call
argument_list|(
argument|pkp
argument_list|,
argument|xp
argument_list|,
argument|len
argument_list|)
expr|struct
name|pkcb
operator|*
name|pkp
expr_stmt|;
name|struct
name|x25_packet
modifier|*
name|xp
decl_stmt|;
block|{
specifier|register
name|struct
name|pklcd
modifier|*
name|lcp
decl_stmt|,
modifier|*
name|l
decl_stmt|;
specifier|register
name|struct
name|sockaddr_x25
modifier|*
name|sa
decl_stmt|;
specifier|register
name|struct
name|x25_calladdr
modifier|*
name|a
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|errstr
init|=
literal|"server unavailable"
decl_stmt|;
name|octet
modifier|*
name|u
decl_stmt|;
name|int
name|lcn
init|=
name|xp
operator|->
name|logical_channel_number
decl_stmt|;
comment|/* First, copy the data from the incoming call packet to a X25_socket 	   descriptor. */
name|a
operator|=
operator|(
expr|struct
name|x25_calladdr
operator|*
operator|)
operator|&
name|xp
operator|->
name|packet_data
expr_stmt|;
name|l1
operator|=
name|a
operator|->
name|calling_addrlen
expr_stmt|;
name|l2
operator|=
name|a
operator|->
name|called_addrlen
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|sa
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr_x25
operator|*
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
name|octet
operator|*
operator|)
operator|(
name|a
operator|->
name|address_field
operator|+
name|l2
operator|/
literal|2
operator|)
expr_stmt|;
name|e
operator|=
name|sa
operator|->
name|x25_addr
expr_stmt|;
if|if
condition|(
name|l2
operator|&
literal|0x01
condition|)
block|{
operator|*
name|e
operator|++
operator|=
operator|*
name|u
operator|++
operator|&
literal|0x0f
expr_stmt|;
name|l1
operator|--
expr_stmt|;
block|}
name|from_bcd
argument_list|(
name|e
argument_list|,
operator|&
name|u
argument_list|,
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1
operator|&
literal|0x01
condition|)
name|u
operator|++
expr_stmt|;
name|parse_facilities
argument_list|(
name|u
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|u
operator|+=
operator|*
name|u
operator|+
literal|1
expr_stmt|;
name|sa
operator|->
name|x25_udlen
operator|=
name|min
argument_list|(
literal|16
argument_list|,
operator|(
operator|(
name|octet
operator|*
operator|)
name|xp
operator|)
operator|+
name|len
operator|-
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|x25_udlen
operator|<
literal|0
condition|)
name|sa
operator|->
name|x25_udlen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|u
argument_list|,
name|sa
operator|->
name|x25_udata
argument_list|,
operator|(
name|unsigned
operator|)
name|sa
operator|->
name|x25_udlen
argument_list|)
expr_stmt|;
comment|/* 	 * Now, loop through the  listen sockets looking for a match on the 	 * PID. That is  the first  four octets  of the user data field.  This 	 * is the closest thing to a port number for X.25 packets. What it 	 * does provide is away of  multiplexing  services at the user level.  	 */
for|for
control|(
name|l
operator|=
name|pk_listenhead
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|lcd_listen
control|)
block|{
name|struct
name|sockaddr_x25
modifier|*
name|sxp
init|=
name|l
operator|->
name|lcd_ceaddr
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sxp
operator|->
name|x25_udata
argument_list|,
name|sa
operator|->
name|x25_udata
argument_list|,
name|sxp
operator|->
name|x25_udlen
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sxp
operator|->
name|x25_net
operator|&&
name|sxp
operator|->
name|x25_net
operator|!=
name|pkp
operator|->
name|pk_xcp
operator|->
name|xc_net
condition|)
continue|continue;
comment|/* 		 * don't accept incoming collect calls unless 		 * the server sets the reverse charging option. 		 */
if|if
condition|(
operator|(
name|sxp
operator|->
name|x25_opts
operator|.
name|op_flags
operator|&
operator|(
name|X25_OLDSOCKADDR
operator||
name|X25_REVERSE_CHARGE
operator|)
operator|)
operator|==
literal|0
operator|&&
name|sa
operator|->
name|x25_opts
operator|.
name|op_flags
operator|&
name|X25_REVERSE_CHARGE
condition|)
block|{
name|errstr
operator|=
literal|"incoming collect call refused"
expr_stmt|;
break|break;
block|}
name|so
operator|=
name|sonewconn
argument_list|(
name|l
operator|->
name|lcd_so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Insufficient space or too many unaccepted 			 * connections.  Just throw the call away. 			 */
name|errstr
operator|=
literal|"server malfunction"
expr_stmt|;
break|break;
block|}
name|lcp
operator|=
operator|(
expr|struct
name|pklcd
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|lcp
operator|->
name|lcd_lcn
operator|=
name|lcn
expr_stmt|;
name|lcp
operator|->
name|lcd_state
operator|=
name|RECEIVED_CALL
expr_stmt|;
name|lcp
operator|->
name|lcd_craddr
operator|=
name|sa
expr_stmt|;
name|sa
operator|->
name|x25_opts
operator|.
name|op_flags
operator||=
name|sxp
operator|->
name|x25_opts
operator|.
name|op_flags
operator|&
operator|~
name|X25_REVERSE_CHARGE
expr_stmt|;
name|pk_assoc
argument_list|(
name|pkp
argument_list|,
name|lcp
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|lcp
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
name|lcp
operator|->
name|lcd_lcn
argument_list|,
name|X25_CALL_ACCEPTED
argument_list|)
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the call fails for whatever reason, we still need to build a 	 * skeleton LCD in order to be able to properly  receive the CLEAR 	 * CONFIRMATION. 	 */
ifdef|#
directive|ifdef
name|WATERLOO
comment|/* be explicit */
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
name|sa
operator|->
name|x25_udata
argument_list|,
literal|"ean"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|pk_message
argument_list|(
name|lcn
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"host=%s ean%c: %s"
argument_list|,
name|sa
operator|->
name|x25_addr
argument_list|,
name|sa
operator|->
name|x25_udata
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
name|sa
operator|->
name|x25_udata
argument_list|,
literal|"\1\0\0\0"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|pk_message
argument_list|(
name|lcn
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"host=%s x29d: %s"
argument_list|,
name|sa
operator|->
name|x25_addr
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|pk_message
argument_list|(
name|lcn
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"host=%s pid=%x %x %x %x: %s"
argument_list|,
name|sa
operator|->
name|x25_addr
argument_list|,
name|sa
operator|->
name|x25_udata
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|,
name|sa
operator|->
name|x25_udata
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|sa
operator|->
name|x25_udata
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|,
name|sa
operator|->
name|x25_udata
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|lcp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pklcd
operator|*
argument_list|)
expr_stmt|;
name|lcp
operator|->
name|lcd_lcn
operator|=
name|lcn
expr_stmt|;
name|lcp
operator|->
name|lcd_state
operator|=
name|RECEIVED_CALL
expr_stmt|;
name|pk_assoc
argument_list|(
name|pkp
argument_list|,
name|lcp
argument_list|,
name|sa
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
name|pk_clear
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
block|}
specifier|static
name|call_accepted
argument_list|(
argument|lcp
argument_list|,
argument|xp
argument_list|,
argument|len
argument_list|)
expr|struct
name|pklcd
operator|*
name|lcp
expr_stmt|;
name|struct
name|x25_packet
modifier|*
name|xp
decl_stmt|;
block|{
specifier|register
name|struct
name|x25_calladdr
modifier|*
name|ap
decl_stmt|;
specifier|register
name|octet
modifier|*
name|fcp
decl_stmt|;
name|lcp
operator|->
name|lcd_state
operator|=
name|DATA_TRANSFER
expr_stmt|;
name|soisconnected
argument_list|(
name|lcp
operator|->
name|lcd_so
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|3
condition|)
block|{
name|ap
operator|=
operator|(
expr|struct
name|x25_calladdr
operator|*
operator|)
operator|&
name|xp
operator|->
name|packet_data
expr_stmt|;
name|fcp
operator|=
operator|(
name|octet
operator|*
operator|)
name|ap
operator|->
name|address_field
operator|+
operator|(
name|ap
operator|->
name|calling_addrlen
operator|+
name|ap
operator|->
name|called_addrlen
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|fcp
operator|+
operator|*
name|fcp
operator|<=
operator|(
operator|(
name|octet
operator|*
operator|)
name|xp
operator|)
operator|+
name|len
condition|)
name|parse_facilities
argument_list|(
name|fcp
argument_list|,
name|lcp
operator|->
name|lcd_ceaddr
argument_list|)
expr_stmt|;
block|}
name|pk_assoc
argument_list|(
name|lcp
operator|->
name|lcd_pkp
argument_list|,
name|lcp
argument_list|,
name|lcp
operator|->
name|lcd_ceaddr
argument_list|)
expr_stmt|;
block|}
specifier|static
name|parse_facilities
argument_list|(
name|fcp
argument_list|,
name|sa
argument_list|)
specifier|register
name|octet
operator|*
name|fcp
expr_stmt|;
specifier|register
name|struct
name|sockaddr_x25
modifier|*
name|sa
decl_stmt|;
block|{
specifier|register
name|octet
modifier|*
name|maxfcp
decl_stmt|;
name|maxfcp
operator|=
name|fcp
operator|+
operator|*
name|fcp
expr_stmt|;
name|fcp
operator|++
expr_stmt|;
while|while
condition|(
name|fcp
operator|<
name|maxfcp
condition|)
block|{
comment|/* 		 * Ignore national DCE or DTE facilities 		 */
if|if
condition|(
operator|*
name|fcp
operator|==
literal|0
operator|||
operator|*
name|fcp
operator|==
literal|0xff
condition|)
break|break;
switch|switch
condition|(
operator|*
name|fcp
condition|)
block|{
case|case
name|FACILITIES_WINDOWSIZE
case|:
name|sa
operator|->
name|x25_opts
operator|.
name|op_wsize
operator|=
name|fcp
index|[
literal|1
index|]
expr_stmt|;
name|fcp
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|FACILITIES_PACKETSIZE
case|:
name|sa
operator|->
name|x25_opts
operator|.
name|op_psize
operator|=
name|fcp
index|[
literal|1
index|]
expr_stmt|;
name|fcp
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|FACILITIES_THROUGHPUT
case|:
name|sa
operator|->
name|x25_opts
operator|.
name|op_speed
operator|=
name|fcp
index|[
literal|1
index|]
expr_stmt|;
name|fcp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|FACILITIES_REVERSE_CHARGE
case|:
if|if
condition|(
name|fcp
index|[
literal|1
index|]
operator|&
literal|01
condition|)
name|sa
operator|->
name|x25_opts
operator|.
name|op_flags
operator||=
name|X25_REVERSE_CHARGE
expr_stmt|;
comment|/* 			 * Datapac specific: for a X.25(1976) DTE, bit 2 			 * indicates a "hi priority" (eg. international) call. 			 */
if|if
condition|(
name|fcp
index|[
literal|1
index|]
operator|&
literal|02
operator|&&
name|sa
operator|->
name|x25_opts
operator|.
name|op_psize
operator|==
literal|0
condition|)
name|sa
operator|->
name|x25_opts
operator|.
name|op_psize
operator|=
name|X25_PS128
expr_stmt|;
name|fcp
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
comment|/*printf("unknown facility %x, class=%d\n", *fcp, (*fcp& 0xc0)>> 6);*/
switch|switch
condition|(
operator|(
operator|*
name|fcp
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
condition|)
block|{
case|case
literal|0
case|:
comment|/* class A */
name|fcp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fcp
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fcp
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fcp
operator|++
expr_stmt|;
name|fcp
operator|+=
operator|*
name|fcp
expr_stmt|;
block|}
block|}
block|}
block|}
name|from_bcd
argument_list|(
name|a
argument_list|,
name|x
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|a
expr_stmt|;
specifier|register
name|octet
modifier|*
modifier|*
name|x
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|posn
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|posn
operator|++
operator|&
literal|0x01
condition|)
operator|*
name|a
operator|=
operator|*
operator|(
operator|*
name|x
operator|)
operator|++
operator|&
literal|0x0f
expr_stmt|;
else|else
operator|*
name|a
operator|=
operator|(
operator|*
operator|*
name|x
operator|>>
literal|4
operator|)
operator|&
literal|0x0F
expr_stmt|;
operator|*
name|a
operator|++
operator||=
literal|0x30
expr_stmt|;
block|}
block|}
end_function

end_unit

