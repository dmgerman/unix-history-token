begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This file is derived from a number of files, as denoted below,  * to create an Excelan driver compatible with the 4.3BSD-tahoe release.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Excelan Inc.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)if_ex.c	7.2 (Berkeley) 4/22/89  */
end_comment

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_if
if|#
directive|if
name|NEX
operator|>
literal|0
end_if

begin_comment
comment|/*  * Excelan EXOS 202(VME)& 203(QBUS) Link Level Ethernet Interface Drivers  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"vmparam.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/if_ether.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|"../netns/ns.h"
end_include

begin_include
include|#
directive|include
file|"../netns/ns_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../tahoe/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/pte.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"if_exreg.h"
end_include

begin_comment
comment|/*  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)if_vba.h	1.1 (Berkeley) 3/9/89  */
end_comment

begin_struct
struct|struct
name|ifvba
block|{
name|struct
name|mbuf
modifier|*
name|iff_mbuf
decl_stmt|;
comment|/* associated mbuf to free */
name|caddr_t
name|iff_buffer
decl_stmt|;
comment|/* contiguous memory for data, kernel address */
name|u_long
name|iff_physaddr
decl_stmt|;
comment|/* contiguous memory for data, phys address */
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_function_decl
name|struct
name|mbuf
modifier|*
name|if_vbaget
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NH2X
value|32
end_define

begin_comment
comment|/* Host to eXcelan request buffers */
end_comment

begin_define
define|#
directive|define
name|NX2H
value|16
end_define

begin_comment
comment|/* eXcelan to Host reply buffers */
end_comment

begin_define
define|#
directive|define
name|NREC
value|16
end_define

begin_comment
comment|/* Number of RECeive buffers */
end_comment

begin_define
define|#
directive|define
name|NTRB
value|4
end_define

begin_comment
comment|/* Number of TRansmit Buffers */
end_comment

begin_define
define|#
directive|define
name|NVBI
value|(NREC + NTRB)
end_define

begin_define
define|#
directive|define
name|EXWATCHINTVL
value|10
end_define

begin_comment
comment|/* call exwatch every x secs */
end_comment

begin_decl_stmt
name|int
name|exprobe
argument_list|()
decl_stmt|,
name|exslave
argument_list|()
decl_stmt|,
name|exattach
argument_list|()
decl_stmt|,
name|exintr
argument_list|()
decl_stmt|,
name|exstart
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|exinfo
index|[
name|NEX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|exstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|exdriver
init|=
block|{
name|exprobe
block|,
literal|0
block|,
name|exattach
block|,
name|exstart
block|,
name|exstd
block|,
literal|"ex"
block|,
name|exinfo
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exinit
argument_list|()
decl_stmt|,
name|exoutput
argument_list|()
decl_stmt|,
name|exioctl
argument_list|()
decl_stmt|,
name|exreset
argument_list|()
decl_stmt|,
name|exwatch
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|ex_msg
modifier|*
name|exgetcbuf
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|ex_ncall
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* counts calls to exprobe */
end_comment

begin_decl_stmt
name|u_long
name|busoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Ethernet software status per interface.  *  * Each interface is referenced by a network interface structure, xs_if, which   * the routing code uses to locate the interface.  This structure contains the   * output queue for the interface, its address, ... NOTE: To configure multiple  * controllers, the sizeof this structure must be a multiple of 16 (xs_h2xhdr).  */
end_comment

begin_struct
struct|struct
name|ex_softc
block|{
name|struct
name|arpcom
name|xs_ac
decl_stmt|;
comment|/* Ethernet common part */
define|#
directive|define
name|xs_if
value|xs_ac.ac_if
comment|/* network-visible interface */
define|#
directive|define
name|xs_addr
value|xs_ac.ac_enaddr
comment|/* hardware Ethernet address */
name|int
name|xs_flags
decl_stmt|;
comment|/* private flags */
define|#
directive|define
name|EX_XPENDING
value|1
comment|/* xmit rqst pending on EXOS */
define|#
directive|define
name|EX_STATPENDING
value|(1<<1)
comment|/* stats rqst pending on EXOS */
define|#
directive|define
name|EX_RUNNING
value|(1<<2)
comment|/* board is running */
define|#
directive|define
name|EX_SETADDR
value|(1<<3)
comment|/* physaddr has been changed */
name|int
name|xs_cvec
decl_stmt|;
comment|/* probe stores cvec here */
name|short
name|xs_enetunit
decl_stmt|;
comment|/* unit number for enet filtering */
name|short
name|xs_enetinit
decl_stmt|;
comment|/* enet inetrface is initialized */
name|struct
name|ex_msg
modifier|*
name|xs_h2xnext
decl_stmt|;
comment|/* host pointer to request queue */
name|struct
name|ex_msg
modifier|*
name|xs_x2hnext
decl_stmt|;
comment|/* host pointer to reply queue */
name|u_long
name|xs_qbaddr
decl_stmt|;
comment|/* map info for structs below */
struct|struct
name|ex_shm
block|{
comment|/* the following structures are always mapped in */
name|u_short
name|sm_h2xhdr
decl_stmt|;
comment|/* EXOS's request queue header */
name|u_short
name|sm_x2hhdr
decl_stmt|;
comment|/* EXOS's reply queue header */
name|struct
name|ex_msg
name|sm_h2xent
index|[
name|NH2X
index|]
decl_stmt|;
comment|/* request msg buffers */
name|struct
name|ex_msg
name|sm_x2hent
index|[
name|NX2H
index|]
decl_stmt|;
comment|/* reply msg buffers */
name|struct
name|ex_conf
name|sm_cm
decl_stmt|;
comment|/* configuration message */
name|struct
name|ex_stat
name|sm_xsa
decl_stmt|;
comment|/* EXOS writes stats here */
comment|/* end mapped area */
block|}
modifier|*
name|xs_shm
struct|;
comment|/* host pointer to shared area */
define|#
directive|define
name|xs_h2xhdr
value|xs_shm->sm_h2xhdr
define|#
directive|define
name|xs_x2hhdr
value|xs_shm->sm_x2hhdr
define|#
directive|define
name|xs_h2xent
value|xs_shm->sm_h2xent
define|#
directive|define
name|xs_x2hent
value|xs_shm->sm_x2hent
define|#
directive|define
name|xs_cm
value|xs_shm->sm_cm
define|#
directive|define
name|xs_xsa
value|xs_shm->sm_xsa
define|#
directive|define
name|BUSADDR
parameter_list|(
name|x
parameter_list|)
value|(0x3D000000 | (((u_long)kvtophys(x))&0xFFFFFF))
define|#
directive|define
name|P_BUSADDR
parameter_list|(
name|x
parameter_list|)
value|(0x3D000000 | (((u_long)kvtophys(x))&0xFFFFF0))
define|#
directive|define
name|INCORE_BASE
parameter_list|(
name|p
parameter_list|)
value|(((u_long)(p)->xs_shm)& 0xFFFFFFF0)
comment|/* we will arrange that the shared memory begins on a 16 byte boundary */
define|#
directive|define
name|RVAL_OFF
parameter_list|(
name|n
parameter_list|)
value|(((char *)&(((struct ex_shm *)0)->n))-(char *)0)
define|#
directive|define
name|LVAL_OFF
parameter_list|(
name|n
parameter_list|)
value|(((char *)(((struct ex_shm *)0)->n))-(char *)0)
define|#
directive|define
name|H2XHDR_OFFSET
value|RVAL_OFF(sm_h2xhdr)
define|#
directive|define
name|X2HHDR_OFFSET
value|RVAL_OFF(sm_x2hhdr)
define|#
directive|define
name|H2XENT_OFFSET
value|LVAL_OFF(sm_h2xent)
define|#
directive|define
name|X2HENT_OFFSET
value|LVAL_OFF(sm_x2hent)
define|#
directive|define
name|CM_OFFSET
value|RVAL_OFF(sm_cm)
define|#
directive|define
name|SA_OFFSET
value|RVAL_OFF(sm_xsa)
name|struct
name|ifvba
name|xs_vbinfo
index|[
name|NVBI
index|]
decl_stmt|;
comment|/* Bus Resources (low core) */
name|struct
name|ifvba
modifier|*
name|xs_pkblist
decl_stmt|;
comment|/* free list of above */
define|#
directive|define
name|GetPkBuf
parameter_list|(
name|b
parameter_list|,
name|v
parameter_list|)
value|((v = (b)->mb_pkb = xs->xs_pkblist),\ 		      (xs->xs_pkblist = (struct ifvba *)(v)->iff_mbuf))
define|#
directive|define
name|FreePkBuf
parameter_list|(
name|v
parameter_list|)
value|(((v)->iff_mbuf = (struct mbuf *)xs->xs_pkblist),\ 							(xs->xs_pkblist = v))
name|char
name|xs_nrec
decl_stmt|;
comment|/* number of pending receive buffers */
name|char
name|xs_ntrb
decl_stmt|;
comment|/* number of pending transmit buffers */
block|}
name|ex_softc
index|[
name|NEX
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|ex_padcheck
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ex_softc
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|exprobe
argument_list|(
argument|reg
argument_list|,
argument|vi
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|br
operator|,
name|cvec
expr_stmt|;
comment|/* r12, r11 value-result */
specifier|register
name|struct
name|exdevice
modifier|*
name|exaddr
init|=
operator|(
expr|struct
name|exdevice
operator|*
operator|)
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|exaddr
argument_list|,
literal|2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Reset EXOS and run self-test (should complete within 2 seconds). 	 */
name|movow
argument_list|(
operator|&
name|exaddr
operator|->
name|ex_porta
argument_list|,
name|EX_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000000
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|uncache
argument_list|(
operator|&
operator|(
name|exaddr
operator|->
name|ex_portb
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exaddr
operator|->
name|ex_portb
operator|&
name|EX_TESTOK
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|exaddr
operator|->
name|ex_portb
operator|&
name|EX_TESTOK
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|br
operator|=
literal|0x15
expr_stmt|;
name|cvec
operator|=
operator|--
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
expr_stmt|;
name|ex_softc
index|[
name|vi
operator|->
name|ui_unit
index|]
operator|.
name|xs_cvec
operator|=
name|cvec
expr_stmt|;
name|ex_ncall
operator|++
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|exdevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interface exists: make available by filling in network interface record.    * System will initialize the interface when it is ready to accept packets.    * A NET_ADDRS command is done to get the ethernet address.  */
end_comment

begin_expr_stmt
name|exattach
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ex_softc
modifier|*
name|xs
init|=
operator|&
name|ex_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|xs
operator|->
name|xs_if
decl_stmt|;
specifier|register
name|struct
name|exdevice
modifier|*
name|exaddr
init|=
operator|(
expr|struct
name|exdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|ex_msg
modifier|*
name|bp
decl_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|ui
operator|->
name|ui_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ex"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|exinit
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|exioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|exoutput
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|exreset
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
expr_stmt|;
comment|/* 	 * Note: extra memory gets returned by if_vbareserve() 	 * first, so, being page alligned, it is also 16-byte alligned. 	 */
if|if
condition|(
name|if_vbareserve
argument_list|(
name|xs
operator|->
name|xs_vbinfo
argument_list|,
name|NVBI
argument_list|,
name|EXMAXRBUF
argument_list|,
operator|(
name|caddr_t
operator|*
operator|)
operator|&
name|xs
operator|->
name|xs_shm
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xs
operator|->
name|xs_shm
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Temporarily map queues in order to configure EXOS 	 */
name|xs
operator|->
name|xs_qbaddr
operator|=
name|INCORE_BASE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|exconfig
argument_list|(
name|ui
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* without interrupts */
if|if
condition|(
name|xs
operator|->
name|xs_cm
operator|.
name|cm_cc
condition|)
return|return;
comment|/* bad conf */
comment|/* 	 * Get Ethernet address. 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|exgetcbuf
argument_list|(
name|xs
argument_list|,
name|LLNET_ADDRS
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|ex_msg
operator|*
operator|)
literal|0
condition|)
name|panic
argument_list|(
literal|"exattach"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|mb_na
operator|.
name|na_mask
operator|=
name|READ_OBJ
expr_stmt|;
name|bp
operator|->
name|mb_na
operator|.
name|na_slot
operator|=
name|PHYSSLOT
expr_stmt|;
name|bp
operator|->
name|mb_status
operator||=
name|MH_EXOS
expr_stmt|;
name|movow
argument_list|(
operator|&
name|exaddr
operator|->
name|ex_portb
argument_list|,
name|EX_NTRUPT
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xs
operator|->
name|xs_x2hnext
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|->
name|mb_status
operator|&
name|MH_OWNER
operator|)
operator|==
name|MH_EXOS
condition|)
empty_stmt|;
comment|/* poll for reply */
name|printf
argument_list|(
literal|"ex%d: HW %c.%c NX %c.%c, hardware address %s\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|xs
operator|->
name|xs_cm
operator|.
name|cm_vc
index|[
literal|2
index|]
argument_list|,
name|xs
operator|->
name|xs_cm
operator|.
name|cm_vc
index|[
literal|3
index|]
argument_list|,
name|xs
operator|->
name|xs_cm
operator|.
name|cm_vc
index|[
literal|0
index|]
argument_list|,
name|xs
operator|->
name|xs_cm
operator|.
name|cm_vc
index|[
literal|1
index|]
argument_list|,
name|ether_sprintf
argument_list|(
name|bp
operator|->
name|mb_na
operator|.
name|na_addrs
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
operator|->
name|mb_na
operator|.
name|na_addrs
argument_list|,
operator|(
name|caddr_t
operator|)
name|xs
operator|->
name|xs_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|xs
operator|->
name|xs_addr
argument_list|)
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset of interface after BUS reset.  * If interface is on specified vba, reset its state.  */
end_comment

begin_macro
name|exreset
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vba_device
modifier|*
name|ui
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NEX
operator|||
operator|(
name|ui
operator|=
name|exinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|" ex%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ex_softc
index|[
name|unit
index|]
operator|.
name|xs_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ex_softc
index|[
name|unit
index|]
operator|.
name|xs_flags
operator|&=
operator|~
name|EX_RUNNING
expr_stmt|;
name|exinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialization of interface; clear recorded pending operations, and   * reinitialize BUS usage. Called at boot time, and at ifconfig time via   * exioctl, with interrupts disabled.  */
end_comment

begin_macro
name|exinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ex_softc
modifier|*
name|xs
init|=
operator|&
name|ex_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|ui
init|=
name|exinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|exdevice
modifier|*
name|exaddr
init|=
operator|(
expr|struct
name|exdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|xs
operator|->
name|xs_if
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
specifier|register
name|struct
name|ex_msg
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* not yet, if address still unknown */
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
if|if
condition|(
name|xs
operator|->
name|xs_flags
operator|&
name|EX_RUNNING
condition|)
return|return;
name|xs
operator|->
name|xs_qbaddr
operator|=
name|INCORE_BASE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|exconfig
argument_list|(
name|ui
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* with vectored interrupts*/
comment|/* 	 * Put EXOS on the Ethernet, using NET_MODE command 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|exgetcbuf
argument_list|(
name|xs
argument_list|,
name|LLNET_MODE
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|ex_msg
operator|*
operator|)
literal|0
condition|)
name|panic
argument_list|(
literal|"exinit"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|mb_nm
operator|.
name|nm_mask
operator|=
name|WRITE_OBJ
expr_stmt|;
name|bp
operator|->
name|mb_nm
operator|.
name|nm_optn
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|mb_nm
operator|.
name|nm_mode
operator|=
name|MODE_PERF
expr_stmt|;
name|bp
operator|->
name|mb_status
operator||=
name|MH_EXOS
expr_stmt|;
name|movow
argument_list|(
operator|&
name|exaddr
operator|->
name|ex_portb
argument_list|,
name|EX_NTRUPT
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xs
operator|->
name|xs_x2hnext
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|->
name|mb_status
operator|&
name|MH_OWNER
operator|)
operator|==
name|MH_EXOS
condition|)
comment|/* poll for reply */
empty_stmt|;
name|bp
operator|->
name|mb_length
operator|=
name|MBDATALEN
expr_stmt|;
name|bp
operator|->
name|mb_status
operator||=
name|MH_EXOS
expr_stmt|;
comment|/* free up buffer */
name|movow
argument_list|(
operator|&
name|exaddr
operator|->
name|ex_portb
argument_list|,
name|EX_NTRUPT
argument_list|)
expr_stmt|;
name|xs
operator|->
name|xs_x2hnext
operator|=
name|xs
operator|->
name|xs_x2hnext
operator|->
name|mb_next
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|exwatch
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
name|EXWATCHINTVL
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* are interrupts disabled here, anyway? */
name|exhangrcv
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|xs_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|xs
operator|->
name|xs_flags
operator||=
name|EX_RUNNING
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|xs_flags
operator|&
name|EX_SETADDR
condition|)
name|ex_setaddr
argument_list|(
operator|(
name|u_char
operator|*
operator|)
literal|0
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|exstart
argument_list|(
operator|&
name|ex_softc
index|[
name|unit
index|]
operator|.
name|xs_if
argument_list|)
expr_stmt|;
comment|/* start transmits */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* are interrupts disabled here, anyway? */
block|}
end_block

begin_comment
comment|/*  * Reset, test, and configure EXOS.  It is called by exinit, and exattach.  * Returns 0 if successful, 1 if self-test failed.  */
end_comment

begin_macro
name|exconfig
argument_list|(
argument|ui
argument_list|,
argument|itype
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|itype
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|ui
operator|->
name|ui_unit
decl_stmt|;
specifier|register
name|struct
name|ex_softc
modifier|*
name|xs
init|=
operator|&
name|ex_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|exdevice
modifier|*
name|exaddr
init|=
operator|(
expr|struct
name|exdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|ex_conf
modifier|*
name|cm
init|=
operator|&
name|xs
operator|->
name|xs_cm
decl_stmt|;
specifier|register
name|struct
name|ex_msg
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|ifvba
modifier|*
name|pkb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_long
name|shiftreg
decl_stmt|;
specifier|static
name|u_char
name|cmaddr
index|[
literal|8
index|]
init|=
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|xs
operator|->
name|xs_flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Reset EXOS, wait for self-test to complete 	 */
name|movow
argument_list|(
operator|&
name|exaddr
operator|->
name|ex_porta
argument_list|,
name|EX_RESET
argument_list|)
expr_stmt|;
do|do
block|{
name|uncache
argument_list|(
operator|&
name|exaddr
operator|->
name|ex_portb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|exaddr
operator|->
name|ex_portb
operator|&
name|EX_TESTOK
operator|)
operator|==
literal|0
condition|)
do|;
comment|/* 	 * Set up configuration message. 	 */
name|cm
operator|->
name|cm_1rsrv
operator|=
literal|1
expr_stmt|;
name|cm
operator|->
name|cm_cc
operator|=
literal|0xFF
expr_stmt|;
name|cm
operator|->
name|cm_opmode
operator|=
literal|0
expr_stmt|;
comment|/* link-level controller mode */
name|cm
operator|->
name|cm_dfo
operator|=
literal|0x0101
expr_stmt|;
comment|/* enable host data order conversion */
name|cm
operator|->
name|cm_dcn1
operator|=
literal|1
expr_stmt|;
name|cm
operator|->
name|cm_2rsrv
index|[
literal|0
index|]
operator|=
name|cm
operator|->
name|cm_2rsrv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_ham
operator|=
literal|3
expr_stmt|;
comment|/* absolute address mode */
name|cm
operator|->
name|cm_3rsrv
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_mapsiz
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_byteptrn
index|[
literal|0
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* EXOS deduces data order of host */
name|cm
operator|->
name|cm_byteptrn
index|[
literal|1
index|]
operator|=
literal|0x03
expr_stmt|;
comment|/*  by looking at this pattern */
name|cm
operator|->
name|cm_byteptrn
index|[
literal|2
index|]
operator|=
literal|0x07
expr_stmt|;
name|cm
operator|->
name|cm_byteptrn
index|[
literal|3
index|]
operator|=
literal|0x0F
expr_stmt|;
name|cm
operator|->
name|cm_wordptrn
index|[
literal|0
index|]
operator|=
literal|0x0103
expr_stmt|;
name|cm
operator|->
name|cm_wordptrn
index|[
literal|1
index|]
operator|=
literal|0x070F
expr_stmt|;
name|cm
operator|->
name|cm_lwordptrn
operator|=
literal|0x0103070F
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|cm
operator|->
name|cm_rsrvd
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_mba
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|cm
operator|->
name|cm_nproc
operator|=
literal|0xFF
expr_stmt|;
name|cm
operator|->
name|cm_nmbox
operator|=
literal|0xFF
expr_stmt|;
name|cm
operator|->
name|cm_nmcast
operator|=
literal|0xFF
expr_stmt|;
name|cm
operator|->
name|cm_nhost
operator|=
literal|1
expr_stmt|;
name|cm
operator|->
name|cm_h2xba
operator|=
name|P_BUSADDR
argument_list|(
name|xs
operator|->
name|xs_qbaddr
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_h2xhdr
operator|=
name|H2XHDR_OFFSET
expr_stmt|;
name|cm
operator|->
name|cm_h2xtyp
operator|=
literal|0
expr_stmt|;
comment|/* should never wait for rqst buffer */
name|cm
operator|->
name|cm_x2hba
operator|=
name|cm
operator|->
name|cm_h2xba
expr_stmt|;
name|cm
operator|->
name|cm_x2hhdr
operator|=
name|X2HHDR_OFFSET
expr_stmt|;
name|cm
operator|->
name|cm_x2htyp
operator|=
name|itype
expr_stmt|;
comment|/* 0 for none, 4 for vectored */
name|cm
operator|->
name|cm_x2haddr
operator|=
name|xs
operator|->
name|xs_cvec
expr_stmt|;
comment|/* ivec allocated in exprobe */
comment|/* 	 * Set up message queues and headers. 	 * First the request queue 	 */
for|for
control|(
name|bp
operator|=
operator|&
name|xs
operator|->
name|xs_h2xent
index|[
literal|0
index|]
init|;
name|bp
operator|<
operator|&
name|xs
operator|->
name|xs_h2xent
index|[
name|NH2X
index|]
condition|;
name|bp
operator|++
control|)
block|{
name|bp
operator|->
name|mb_link
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|bp
operator|+
literal|1
operator|)
operator|-
name|INCORE_BASE
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|mb_rsrv
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|mb_length
operator|=
name|MBDATALEN
expr_stmt|;
name|bp
operator|->
name|mb_status
operator|=
name|MH_HOST
expr_stmt|;
name|bp
operator|->
name|mb_next
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
block|}
name|xs
operator|->
name|xs_h2xhdr
operator|=
name|xs
operator|->
name|xs_h2xent
index|[
name|NH2X
operator|-
literal|1
index|]
operator|.
name|mb_link
operator|=
operator|(
name|u_short
operator|)
name|H2XENT_OFFSET
expr_stmt|;
name|xs
operator|->
name|xs_h2xnext
operator|=
name|xs
operator|->
name|xs_h2xent
index|[
name|NH2X
operator|-
literal|1
index|]
operator|.
name|mb_next
operator|=
name|xs
operator|->
name|xs_h2xent
expr_stmt|;
comment|/* Now the reply queue. */
for|for
control|(
name|bp
operator|=
operator|&
name|xs
operator|->
name|xs_x2hent
index|[
literal|0
index|]
init|;
name|bp
operator|<
operator|&
name|xs
operator|->
name|xs_x2hent
index|[
name|NX2H
index|]
condition|;
name|bp
operator|++
control|)
block|{
name|bp
operator|->
name|mb_link
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|bp
operator|+
literal|1
operator|)
operator|-
name|INCORE_BASE
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|mb_rsrv
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|mb_length
operator|=
name|MBDATALEN
expr_stmt|;
name|bp
operator|->
name|mb_status
operator|=
name|MH_EXOS
expr_stmt|;
name|bp
operator|->
name|mb_next
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
block|}
name|xs
operator|->
name|xs_x2hhdr
operator|=
name|xs
operator|->
name|xs_x2hent
index|[
name|NX2H
operator|-
literal|1
index|]
operator|.
name|mb_link
operator|=
operator|(
name|u_short
operator|)
name|X2HENT_OFFSET
expr_stmt|;
name|xs
operator|->
name|xs_x2hnext
operator|=
name|xs
operator|->
name|xs_x2hent
index|[
name|NX2H
operator|-
literal|1
index|]
operator|.
name|mb_next
operator|=
name|xs
operator|->
name|xs_x2hent
expr_stmt|;
name|xs
operator|->
name|xs_nrec
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|xs_ntrb
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|xs_pkblist
operator|=
name|xs
operator|->
name|xs_vbinfo
operator|+
name|NVBI
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|pkb
operator|=
name|xs
operator|->
name|xs_pkblist
init|;
name|pkb
operator|>
name|xs
operator|->
name|xs_vbinfo
condition|;
name|pkb
operator|--
control|)
name|pkb
operator|->
name|iff_mbuf
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
operator|(
name|pkb
operator|-
literal|1
operator|)
expr_stmt|;
name|xs
operator|->
name|xs_vbinfo
index|[
literal|0
index|]
operator|.
name|iff_mbuf
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Write config msg address to EXOS and wait for configuration to  	 * complete (guaranteed response within 2 seconds). 	 */
name|shiftreg
operator|=
name|P_BUSADDR
argument_list|(
name|xs
operator|->
name|xs_qbaddr
argument_list|)
operator|+
name|CM_OFFSET
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|cmaddr
index|[
name|i
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|shiftreg
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|shiftreg
operator|>>=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
do|do
block|{
name|uncache
argument_list|(
operator|&
name|exaddr
operator|->
name|ex_portb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|exaddr
operator|->
name|ex_portb
operator|&
name|EX_UNREADY
condition|)
do|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|movow
argument_list|(
operator|&
name|exaddr
operator|->
name|ex_portb
argument_list|,
name|cmaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|500000
init|;
name|i
condition|;
operator|--
name|i
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|cm
operator|->
name|cm_cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_cc
operator|!=
literal|0xFF
condition|)
break|break;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_cc
condition|)
name|printf
argument_list|(
literal|"ex%d: configuration failed; cc=%x\n"
argument_list|,
name|unit
argument_list|,
name|cm
operator|->
name|cm_cc
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start or re-start output on interface. Get another datagram to send off of   * the interface queue, and map it to the interface before starting the output.  * This routine is called by exinit(), exoutput(), and excdint().  In all cases,  * interrupts by EXOS are disabled.  */
end_comment

begin_macro
name|exstart
argument_list|(
argument|ifp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|ifp
operator|->
name|if_unit
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|ui
init|=
name|exinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ex_softc
modifier|*
name|xs
init|=
operator|&
name|ex_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|exdevice
modifier|*
name|exaddr
init|=
operator|(
expr|struct
name|exdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|ex_msg
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|register
name|struct
name|ifvba
modifier|*
name|pkb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|nb
init|=
literal|0
decl_stmt|,
name|tlen
init|=
literal|0
decl_stmt|;
union|union
name|l_util
block|{
name|u_long
name|l
decl_stmt|;
name|struct
name|i86_long
name|i
decl_stmt|;
block|}
name|l_util
union|;
if|if
condition|(
name|xs
operator|->
name|xs_ntrb
operator|>=
name|NTRB
condition|)
return|return;
if|if
condition|(
name|xs
operator|->
name|xs_pkblist
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ex%d: vbinfo exhausted, would panic"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|xs
operator|->
name|xs_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Get a transmit request. 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|exgetcbuf
argument_list|(
name|xs
argument_list|,
name|LLRTRANSMIT
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|ex_msg
operator|*
operator|)
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"exstart: no command buffers\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|xs
operator|->
name|xs_ntrb
operator|++
expr_stmt|;
name|GetPkBuf
argument_list|(
name|bp
argument_list|,
name|pkb
argument_list|)
expr_stmt|;
name|pkb
operator|->
name|iff_mbuf
operator|=
name|m
expr_stmt|;
comment|/* save mbuf pointer to free when done */
comment|/* 	 * point directly to the first group of mbufs to be transmitted. The 	 * hardware can only support NFRAGMENTS descriptors. 	 */
while|while
condition|(
name|m
operator|&&
operator|(
operator|(
name|nb
operator|<
name|NFRAGMENTS
operator|-
literal|1
operator|)
operator|||
operator|(
name|m
operator|->
name|m_next
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|l_util
operator|.
name|l
operator|=
name|BUSADDR
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|mb_et
operator|.
name|et_blks
index|[
name|nb
index|]
operator|.
name|bb_len
operator|=
operator|(
name|u_short
operator|)
name|m
operator|->
name|m_len
expr_stmt|;
name|bp
operator|->
name|mb_et
operator|.
name|et_blks
index|[
name|nb
index|]
operator|.
name|bb_addr
operator|=
name|l_util
operator|.
name|i
expr_stmt|;
if|if
condition|(
name|l_util
operator|.
name|l
operator|+
name|m
operator|->
name|m_len
operator|>
name|BUSADDR
argument_list|(
name|VB_MAXADDR24
argument_list|)
condition|)
block|{
comment|/* Here, the phys memory for the mbuf is out 			   of range for the vmebus to talk to it */
if|if
condition|(
name|m
operator|==
name|pkb
operator|->
name|iff_mbuf
condition|)
name|pkb
operator|->
name|iff_mbuf
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|tlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|nb
operator|++
expr_stmt|;
block|}
comment|/* 0 end of chain pointed to by iff_mbuf, to be freed when xmit done */
if|if
condition|(
name|m0
condition|)
name|m0
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
comment|/* 	 * if not all of the descriptors would fit then merge remaining data 	 * into the transmit buffer, and point to it.  Note: the mbufs are freed 	 * during the merge, they do not have to be freed when we get the  	 * transmit interrupt. 	 */
if|if
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|pkb
operator|->
name|iff_mbuf
condition|)
block|{
name|printf
argument_list|(
literal|"ex%d: exstart insanity\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|pkb
operator|->
name|iff_mbuf
operator|=
literal|0
expr_stmt|;
block|}
name|len
operator|=
name|if_vbaput
argument_list|(
name|pkb
operator|->
name|iff_buffer
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|l_util
operator|.
name|l
operator|=
name|BUSADDR
argument_list|(
name|pkb
operator|->
name|iff_buffer
argument_list|)
expr_stmt|;
name|bp
operator|->
name|mb_et
operator|.
name|et_blks
index|[
name|nb
index|]
operator|.
name|bb_len
operator|=
operator|(
name|u_short
operator|)
name|len
expr_stmt|;
name|bp
operator|->
name|mb_et
operator|.
name|et_blks
index|[
name|nb
index|]
operator|.
name|bb_addr
operator|=
name|l_util
operator|.
name|i
expr_stmt|;
name|tlen
operator|+=
name|len
expr_stmt|;
name|nb
operator|++
expr_stmt|;
block|}
comment|/* 	 * If the total length of the packet is too small, 	 * pad the last fragment.  (May run into very obscure problems) 	 */
if|if
condition|(
name|tlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
name|ETHERMIN
condition|)
block|{
name|len
operator|=
operator|(
name|ETHERMIN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
operator|-
name|tlen
expr_stmt|;
name|bp
operator|->
name|mb_et
operator|.
name|et_blks
index|[
name|nb
operator|-
literal|1
index|]
operator|.
name|bb_len
operator|+=
operator|(
name|u_short
operator|)
name|len
expr_stmt|;
name|tlen
operator|+=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|l_util
operator|.
name|l
operator|+
name|m
operator|->
name|m_len
operator|>
name|BUSADDR
argument_list|(
name|VB_MAXADDR24
argument_list|)
condition|)
block|{
name|must
name|copy
name|last
name|frag
name|into
name|private
name|buffer
block|}
endif|#
directive|endif
block|}
comment|/* set number of fragments in descriptor */
name|bp
operator|->
name|mb_et
operator|.
name|et_nblock
operator|=
name|nb
expr_stmt|;
name|bp
operator|->
name|mb_status
operator||=
name|MH_EXOS
expr_stmt|;
name|movow
argument_list|(
operator|&
name|exaddr
operator|->
name|ex_portb
argument_list|,
name|EX_NTRUPT
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * interrupt service routine.  */
end_comment

begin_macro
name|exintr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ex_softc
modifier|*
name|xs
init|=
operator|&
name|ex_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ex_msg
modifier|*
name|bp
init|=
name|xs
operator|->
name|xs_x2hnext
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|ui
init|=
name|exinfo
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|exdevice
modifier|*
name|exaddr
init|=
operator|(
expr|struct
name|exdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
name|struct
name|ex_msg
modifier|*
name|next_bp
decl_stmt|;
while|while
condition|(
operator|(
name|bp
operator|->
name|mb_status
operator|&
name|MH_OWNER
operator|)
operator|==
name|MH_HOST
condition|)
block|{
switch|switch
condition|(
name|bp
operator|->
name|mb_rqst
condition|)
block|{
case|case
name|LLRECEIVE
case|:
if|if
condition|(
operator|--
name|xs
operator|->
name|xs_nrec
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ex%d: internal receive check\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|xs_nrec
operator|=
literal|0
expr_stmt|;
block|}
name|exrecv
argument_list|(
name|unit
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|FreePkBuf
argument_list|(
name|bp
operator|->
name|mb_pkb
argument_list|)
expr_stmt|;
name|bp
operator|->
name|mb_pkb
operator|=
operator|(
expr|struct
name|ifvba
operator|*
operator|)
literal|0
expr_stmt|;
name|exhangrcv
argument_list|(
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|LLTRANSMIT
case|:
case|case
name|LLRTRANSMIT
case|:
if|if
condition|(
operator|--
name|xs
operator|->
name|xs_ntrb
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ex%d: internal transmit check\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|xs_ntrb
operator|=
literal|0
expr_stmt|;
block|}
name|xs
operator|->
name|xs_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|mb_rply
operator|==
name|LL_OK
operator|||
name|bp
operator|->
name|mb_rply
operator|==
name|LLXM_NSQE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|->
name|mb_rply
operator|&
name|LLXM_1RTRY
condition|)
name|xs
operator|->
name|xs_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|->
name|mb_rply
operator|&
name|LLXM_RTRYS
condition|)
name|xs
operator|->
name|xs_if
operator|.
name|if_collisions
operator|+=
literal|2
expr_stmt|;
comment|/* guess */
elseif|else
if|if
condition|(
name|bp
operator|->
name|mb_rply
operator|&
name|LLXM_ERROR
condition|)
if|if
condition|(
name|xs
operator|->
name|xs_if
operator|.
name|if_oerrors
operator|++
operator|%
literal|100
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"ex%d: 100 transmit errors=%b\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|mb_rply
argument_list|,
name|XMIT_BITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|mb_pkb
operator|->
name|iff_mbuf
condition|)
block|{
name|m_freem
argument_list|(
name|bp
operator|->
name|mb_pkb
operator|->
name|iff_mbuf
argument_list|)
expr_stmt|;
name|bp
operator|->
name|mb_pkb
operator|->
name|iff_mbuf
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|FreePkBuf
argument_list|(
name|bp
operator|->
name|mb_pkb
argument_list|)
expr_stmt|;
name|bp
operator|->
name|mb_pkb
operator|=
operator|(
expr|struct
name|ifvba
operator|*
operator|)
literal|0
expr_stmt|;
name|exstart
argument_list|(
operator|&
name|xs
operator|->
name|xs_if
argument_list|)
expr_stmt|;
name|exhangrcv
argument_list|(
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|LLNET_STSTCS
case|:
name|xs
operator|->
name|xs_if
operator|.
name|if_ierrors
operator|+=
name|xs
operator|->
name|xs_xsa
operator|.
name|sa_crc
expr_stmt|;
name|xs
operator|->
name|xs_flags
operator|&=
operator|~
name|EX_STATPENDING
expr_stmt|;
case|case
name|LLNET_ADDRS
case|:
case|case
name|LLNET_RECV
case|:
if|if
condition|(
name|bp
operator|->
name|mb_rply
operator|==
name|LL_OK
operator|||
name|bp
operator|->
name|mb_rply
operator|==
name|LLXM_NSQE
condition|)
empty_stmt|;
else|else
name|printf
argument_list|(
literal|"ex%d: %s, request 0x%x, reply 0x%x\n"
argument_list|,
name|unit
argument_list|,
literal|"unsucessful stat or address change"
argument_list|,
name|bp
operator|->
name|mb_rqst
argument_list|,
name|bp
operator|->
name|mb_rply
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ex%d: unknown reply 0x%x"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|mb_rqst
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|mb_length
operator|=
name|MBDATALEN
expr_stmt|;
name|next_bp
operator|=
name|bp
operator|->
name|mb_next
expr_stmt|;
name|bp
operator|->
name|mb_status
operator||=
name|MH_EXOS
expr_stmt|;
comment|/* free up buffer */
name|bp
operator|=
name|next_bp
expr_stmt|;
comment|/* paranoia about race */
name|movow
argument_list|(
operator|&
name|exaddr
operator|->
name|ex_portb
argument_list|,
name|EX_NTRUPT
argument_list|)
expr_stmt|;
comment|/* tell EXOS about it */
block|}
name|xs
operator|->
name|xs_x2hnext
operator|=
name|bp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get a request buffer, fill in standard values, advance pointer.  */
end_comment

begin_function
name|struct
name|ex_msg
modifier|*
name|exgetcbuf
parameter_list|(
name|xs
parameter_list|,
name|req
parameter_list|)
name|struct
name|ex_softc
modifier|*
name|xs
decl_stmt|;
name|int
name|req
decl_stmt|;
block|{
specifier|register
name|struct
name|ex_msg
modifier|*
name|bp
decl_stmt|;
name|struct
name|ifvba
modifier|*
name|pkb
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|bp
operator|=
name|xs
operator|->
name|xs_h2xnext
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|mb_status
operator|&
name|MH_OWNER
operator|)
operator|==
name|MH_EXOS
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|ex_msg
operator|*
operator|)
literal|0
return|;
block|}
name|xs
operator|->
name|xs_h2xnext
operator|=
name|bp
operator|->
name|mb_next
expr_stmt|;
name|bp
operator|->
name|mb_1rsrv
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|mb_rqst
operator|=
name|req
expr_stmt|;
name|bp
operator|->
name|mb_length
operator|=
name|MBDATALEN
expr_stmt|;
name|bp
operator|->
name|mb_pkb
operator|=
operator|(
expr|struct
name|ifvba
operator|*
operator|)
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * Process Ethernet receive completion:  If input error just drop packet,   * otherwise examine packet to determine type.  If can't determine length from   * type, then have to drop packet, otherwise decapsulate packet based on type   * and pass to type-specific higher-level input routine.  */
end_comment

begin_macro
name|exrecv
argument_list|(
argument|unit
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ex_msg
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ex_softc
modifier|*
name|xs
init|=
operator|&
name|ex_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
name|int
name|len
decl_stmt|,
name|off
decl_stmt|,
name|resid
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|xs
operator|->
name|xs_if
decl_stmt|;
name|int
name|s
decl_stmt|;
name|xs
operator|->
name|xs_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
comment|/*     total length               - header                      - crc */
name|len
operator|=
name|bp
operator|->
name|mb_er
operator|.
name|er_blks
index|[
literal|0
index|]
operator|.
name|bb_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|mb_rply
operator|!=
name|LL_OK
condition|)
block|{
if|if
condition|(
name|xs
operator|->
name|xs_if
operator|.
name|if_ierrors
operator|++
operator|%
literal|100
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"ex%d: 100 receive errors=%b\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|mb_rply
argument_list|,
name|RECV_BITS
argument_list|)
expr_stmt|;
return|return;
block|}
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
operator|(
name|bp
operator|->
name|mb_pkb
operator|->
name|iff_buffer
operator|)
expr_stmt|;
comment|/* 	 * Deal with trailer protocol: if type is PUP trailer get true type from 	 * first 16-bit word past data.  Remember that type was trailer by  	 * setting off. 	 */
name|eh
operator|->
name|ether_type
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
define|#
directive|define
name|exdataaddr
parameter_list|(
name|eh
parameter_list|,
name|off
parameter_list|,
name|type
parameter_list|)
value|((type)(((caddr_t)((eh)+1)+(off))))
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|eh
operator|->
name|ether_type
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|off
operator|=
operator|(
name|eh
operator|->
name|ether_type
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|*
literal|512
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|ETHERMTU
condition|)
return|return;
comment|/* sanity */
name|eh
operator|->
name|ether_type
operator|=
name|ntohs
argument_list|(
operator|*
name|exdataaddr
argument_list|(
name|eh
argument_list|,
name|off
argument_list|,
name|u_short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ntohs
argument_list|(
operator|*
operator|(
name|exdataaddr
argument_list|(
name|eh
argument_list|,
name|off
operator|+
literal|2
argument_list|,
name|u_short
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|resid
operator|>
name|len
condition|)
return|return;
comment|/* sanity */
name|len
operator|=
name|off
operator|+
name|resid
expr_stmt|;
block|}
else|else
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Pull packet off interface.  Off is nonzero if packet 	 * has trailing header; if_vbaget will then force this header 	 * information to be at the front, but we still have to drop 	 * the type and length which are at the front of any trailer data. 	 */
name|m
operator|=
name|if_vbaget
argument_list|(
name|bp
operator|->
name|mb_pkb
operator|->
name|iff_buffer
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|off
condition|)
block|{
name|m
operator|->
name|m_off
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ifnet
operator|*
operator|*
argument_list|)
operator|)
operator|=
name|ifp
expr_stmt|;
block|}
switch|switch
condition|(
name|eh
operator|->
name|ether_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_ARP
case|:
name|arpinput
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|ETHERTYPE_NS
case|:
name|schednetisr
argument_list|(
name|NETISR_NS
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|nsintrq
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Hang a receive request. This routine is called by exinit and excdint,  * with interrupts disabled in both cases.  */
end_comment

begin_macro
name|exhangrcv
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ex_softc
modifier|*
name|xs
init|=
operator|&
name|ex_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ex_msg
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|ifvba
modifier|*
name|pkb
decl_stmt|;
name|short
name|mustint
init|=
literal|0
decl_stmt|;
union|union
name|l_util
block|{
name|u_long
name|l
decl_stmt|;
name|struct
name|i86_long
name|i
decl_stmt|;
block|}
name|l_util
union|;
while|while
condition|(
name|xs
operator|->
name|xs_nrec
operator|<
name|NREC
condition|)
block|{
if|if
condition|(
name|xs
operator|->
name|xs_pkblist
operator|==
operator|(
expr|struct
name|ifvba
operator|*
operator|)
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|bp
operator|=
name|exgetcbuf
argument_list|(
name|xs
argument_list|,
name|LLRECEIVE
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|ex_msg
operator|*
operator|)
literal|0
condition|)
block|{
break|break;
block|}
name|GetPkBuf
argument_list|(
name|bp
argument_list|,
name|pkb
argument_list|)
expr_stmt|;
name|pkb
operator|->
name|iff_mbuf
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|xs_nrec
operator|+=
literal|1
expr_stmt|;
name|bp
operator|->
name|mb_er
operator|.
name|er_nblock
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|mb_er
operator|.
name|er_blks
index|[
literal|0
index|]
operator|.
name|bb_len
operator|=
name|EXMAXRBUF
expr_stmt|;
name|l_util
operator|.
name|l
operator|=
name|BUSADDR
argument_list|(
name|pkb
operator|->
name|iff_buffer
argument_list|)
expr_stmt|;
name|bp
operator|->
name|mb_er
operator|.
name|er_blks
index|[
literal|0
index|]
operator|.
name|bb_addr
operator|=
name|l_util
operator|.
name|i
expr_stmt|;
name|bp
operator|->
name|mb_status
operator||=
name|MH_EXOS
expr_stmt|;
name|mustint
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mustint
operator|==
literal|0
condition|)
return|return;
name|movow
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|exdevice
operator|*
operator|)
name|exinfo
index|[
name|unit
index|]
operator|->
name|ui_addr
operator|)
operator|->
name|ex_portb
argument_list|,
name|EX_NTRUPT
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Ethernet output routine.  * Encapsulate a packet of type family for the local net.  * Use trailer local net encapsulation if enough data in first  * packet leaves a multiple of 512 bytes of data in remainder.  * Assumes that ifp is actually pointer to arpcom structure.  */
end_comment

begin_expr_stmt
name|exoutput
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|,
name|dst
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|type
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|u_char
name|edst
index|[
literal|6
index|]
decl_stmt|;
name|struct
name|in_addr
name|idst
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mcopy
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|usetrailers
decl_stmt|,
name|off
init|=
literal|0
decl_stmt|,
name|totlen
decl_stmt|;
define|#
directive|define
name|ac
value|((struct arpcom *)ifp)
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|)
operator|!=
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
condition|)
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|idst
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_addr
expr_stmt|;
if|if
condition|(
operator|!
name|arpresolve
argument_list|(
name|ac
argument_list|,
name|m
argument_list|,
operator|&
name|idst
argument_list|,
name|edst
argument_list|,
operator|&
name|usetrailers
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* if not yet resolved */
name|off
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|->
name|ip_len
argument_list|)
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|usetrailers
operator|&&
name|off
operator|>
literal|0
operator|&&
operator|(
name|off
operator|&
literal|0x1ff
operator|)
operator|==
literal|0
operator|&&
name|m
operator|->
name|m_off
operator|>=
name|MMINOFF
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
block|{
name|type
operator|=
name|ETHERTYPE_TRAIL
operator|+
operator|(
name|off
operator|>>
literal|9
operator|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_short
operator|*
argument_list|)
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_short
operator|*
argument_list|)
operator|+
literal|1
operator|)
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
goto|goto
name|gottrailertype
goto|;
block|}
name|type
operator|=
name|ETHERTYPE_IP
expr_stmt|;
goto|goto
name|gottype
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
name|type
operator|=
name|ETHERTYPE_NS
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_ns
operator|*
operator|)
name|dst
operator|)
operator|->
name|sns_addr
operator|.
name|x_host
operator|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|edst
argument_list|,
sizeof|sizeof
argument_list|(
name|edst
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|gottype
goto|;
endif|#
directive|endif
case|case
name|AF_UNSPEC
case|:
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|dst
operator|->
name|sa_data
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|caddr_t
operator|)
name|edst
argument_list|,
sizeof|sizeof
argument_list|(
name|edst
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
goto|goto
name|gottype
goto|;
default|default:
name|printf
argument_list|(
literal|"%s%d: can't handle af%d\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|gottrailertype
label|:
comment|/* 	 * Packet to be sent as trailer: move first packet 	 * (control information) to end of chain. 	 */
while|while
condition|(
name|m
operator|->
name|m_next
condition|)
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|m
operator|=
name|m0
operator|->
name|m_next
expr_stmt|;
name|m0
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
name|gottype
label|:
comment|/* 	 * Add local net header.  If no space in first mbuf, 	 * allocate another. 	 */
if|if
condition|(
name|m
operator|->
name|m_off
operator|>
name|MMAXOFF
operator|||
name|MMINOFF
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|>
name|m
operator|->
name|m_off
condition|)
block|{
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMINOFF
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|type
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|type
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|type
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|eh
operator|->
name|ether_type
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|edst
argument_list|,
operator|(
name|caddr_t
operator|)
name|eh
operator|->
name|ether_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|edst
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|eh
operator|->
name|ether_shost
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Queue message on interface, and start output if interface 	 * not yet active. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|exstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Watchdog routine (currently not used). Might use this to get stats from EXOS.  */
end_comment

begin_macro
name|exwatch
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|exdevice
modifier|*
name|exaddr
init|=
operator|(
expr|struct
name|exdevice
operator|*
operator|)
name|exinfo
index|[
name|unit
index|]
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|ex_softc
modifier|*
name|xs
init|=
operator|&
name|ex_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ex_msg
modifier|*
name|bp
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|xs
operator|->
name|xs_flags
operator|&
name|EX_STATPENDING
condition|)
goto|goto
name|exspnd
goto|;
if|if
condition|(
operator|(
name|bp
operator|=
name|exgetcbuf
argument_list|(
name|xs
argument_list|,
name|LLNET_STSTCS
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|ex_msg
operator|*
operator|)
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|xs
operator|->
name|xs_flags
operator||=
name|EX_STATPENDING
expr_stmt|;
name|bp
operator|->
name|mb_ns
operator|.
name|ns_mask
operator|=
name|READ_OBJ
expr_stmt|;
name|bp
operator|->
name|mb_ns
operator|.
name|ns_rsrv
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|mb_ns
operator|.
name|ns_nobj
operator|=
literal|8
expr_stmt|;
name|bp
operator|->
name|mb_ns
operator|.
name|ns_xobj
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|mb_ns
operator|.
name|ns_bufp
operator|=
name|P_BUSADDR
argument_list|(
name|xs
operator|->
name|xs_qbaddr
argument_list|)
operator|+
name|SA_OFFSET
expr_stmt|;
name|bp
operator|->
name|mb_status
operator||=
name|MH_EXOS
expr_stmt|;
name|movow
argument_list|(
operator|&
name|exaddr
operator|->
name|ex_portb
argument_list|,
name|EX_NTRUPT
argument_list|)
expr_stmt|;
name|exspnd
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xs
operator|->
name|xs_if
operator|.
name|if_timer
operator|=
name|EXWATCHINTVL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|exioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|ex_softc
modifier|*
name|xs
init|=
operator|&
name|ex_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|exinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|xs
operator|->
name|xs_addr
operator|)
expr_stmt|;
else|else
name|ex_setaddr
argument_list|(
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|xs
operator|->
name|xs_flags
operator|&
name|EX_RUNNING
condition|)
block|{
name|movow
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|exdevice
operator|*
operator|)
operator|(
name|exinfo
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|->
name|ui_addr
operator|)
operator|)
operator|->
name|ex_porta
argument_list|,
name|EX_RESET
argument_list|)
expr_stmt|;
name|xs
operator|->
name|xs_flags
operator|&=
operator|~
name|EX_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|xs
operator|->
name|xs_flags
operator|&
name|EX_RUNNING
operator|)
operator|==
literal|0
condition|)
name|exinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * set ethernet address for unit  */
end_comment

begin_macro
name|ex_setaddr
argument_list|(
argument|physaddr
argument_list|,
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|physaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ex_softc
modifier|*
name|xs
init|=
operator|&
name|ex_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|physaddr
condition|)
block|{
name|xs
operator|->
name|xs_flags
operator||=
name|EX_SETADDR
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|physaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|xs
operator|->
name|xs_addr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
name|ex_setmulti
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|xs
operator|->
name|xs_addr
argument_list|,
name|unit
argument_list|,
name|PHYSSLOT
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Enable multicast reception for unit.  */
end_comment

begin_macro
name|ex_setmulti
argument_list|(
argument|linkaddr
argument_list|,
argument|unit
argument_list|,
argument|slot
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|linkaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|slot
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ex_softc
modifier|*
name|xs
init|=
operator|&
name|ex_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|ui
init|=
name|exinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|exdevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|exdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|ex_msg
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|xs_flags
operator|&
name|EX_RUNNING
operator|)
condition|)
return|return;
name|bp
operator|=
name|exgetcbuf
argument_list|(
name|xs
argument_list|,
name|LLNET_ADDRS
argument_list|)
expr_stmt|;
name|bp
operator|->
name|mb_na
operator|.
name|na_mask
operator|=
name|READ_OBJ
operator||
name|WRITE_OBJ
expr_stmt|;
name|bp
operator|->
name|mb_na
operator|.
name|na_slot
operator|=
name|slot
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|linkaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|bp
operator|->
name|mb_na
operator|.
name|na_addrs
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bp
operator|->
name|mb_status
operator||=
name|MH_EXOS
expr_stmt|;
name|movow
argument_list|(
operator|&
name|addr
operator|->
name|ex_portb
argument_list|,
name|EX_NTRUPT
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xs
operator|->
name|xs_x2hnext
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|->
name|mb_status
operator|&
name|MH_OWNER
operator|)
operator|==
name|MH_EXOS
condition|)
empty_stmt|;
comment|/* poll for reply */
ifdef|#
directive|ifdef
name|DEBUG
name|log
argument_list|(
argument|LOG_DEBUG
argument_list|,
literal|"ex%d: %s %s (slot %d)\n"
argument_list|,
argument|unit
argument_list|,
argument|(slot == PHYSSLOT ?
literal|"reset addr"
argument|:
literal|"add multicast"
argument|ether_sprintf(bp->mb_na.na_addrs), slot);
endif|#
directive|endif
comment|/* 	 * Now, re-enable reception on slot. 	 */
argument|bp = exgetcbuf(xs, LLNET_RECV); 	bp->mb_nr.nr_mask = ENABLE_RCV|READ_OBJ|WRITE_OBJ; 	bp->mb_nr.nr_slot = slot; 	bp->mb_status |= MH_EXOS; 	movow(&addr->ex_portb, EX_NTRUPT); 	bp = xs->xs_x2hnext; 	while ((bp->mb_status& MH_OWNER) == MH_EXOS);
comment|/* poll for reply */
argument|; }
comment|/*  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)if_vba.c	1.2 (Berkeley) 4/22/89  */
ifdef|#
directive|ifdef
name|notdef
include|#
directive|include
file|"param.h"
include|#
directive|include
file|"systm.h"
include|#
directive|include
file|"mbuf.h"
include|#
directive|include
file|"buf.h"
include|#
directive|include
file|"cmap.h"
include|#
directive|include
file|"vmmac.h"
include|#
directive|include
file|"socket.h"
include|#
directive|include
file|"../tahoe/mtpr.h"
include|#
directive|include
file|"../tahoe/pte.h"
include|#
directive|include
file|"../tahoevba/vbavar.h"
include|#
directive|include
file|"../net/if.h"
include|#
directive|include
file|"../netinet/in.h"
include|#
directive|include
file|"../netinet/if_ether.h"
endif|#
directive|endif
argument|static if_vbareserve(ifvba0, n, bufsize, extra, extrasize) struct ifvba *ifvba0; register int n; int bufsize; caddr_t *extra; int extrasize; { 	register caddr_t cp; 	register struct pte *pte; 	register struct ifvba *ifvba = ifvba0; 	struct ifvba *vlim  = ifvba + n;  	n = roundup(extrasize + (n * bufsize), NBPG); 	cp = (caddr_t)malloc((u_long)n, M_DEVBUF, M_NOWAIT); 	if ((n + kvtophys(cp))> VB_MAXADDR24) { 		free(cp, M_DEVBUF); 		cp =
literal|0
argument|; 	} 	if (cp ==
literal|0
argument|) { 		printf(
literal|"No memory for device buffer(s)\n"
argument|); 		return (
literal|0
argument|); 	}
comment|/* 	 * Make raw buffer pages uncacheable. 	 */
argument|pte = kvtopte(cp); 	for (n = btoc(n); n--; pte++) 		pte->pg_nc =
literal|1
argument|; 	mtpr(TBIA,
literal|0
argument|); 	if (extra) { 		*extra = cp; 		cp += extrasize; 	} 	for (; ifvba< vlim; ifvba++) { 		ifvba->iff_buffer = cp; 		ifvba->iff_physaddr = kvtophys(cp); 		cp += bufsize; 	} 	return (
literal|1
argument|); }
comment|/*  * Routine to copy from VERSAbus memory into mbufs.  *  * Warning: This makes the fairly safe assumption that  * mbufs have even lengths.  */
argument|static struct mbuf * if_vbaget(rxbuf, totlen, off0, ifp) 	u_char *rxbuf; 	int totlen
argument_list|,
argument|off0; 	struct ifnet *ifp; { 	register u_char *cp
argument_list|,
argument|*mcp; 	register struct mbuf *m; 	struct mbuf *top =
literal|0
argument_list|,
argument|**mp =&top; 	int len
argument_list|,
argument|off = off0;  	cp = rxbuf + sizeof (struct ether_header); 	while (totlen>
literal|0
argument|) { 		MGET(m, M_DONTWAIT, MT_DATA); 		if (m ==
literal|0
argument|)  			goto bad; 		if (off) { 			len = totlen - off; 			cp = rxbuf + sizeof (struct ether_header) + off; 		} else 			len = totlen; 		if (len>= NBPG) { 			MCLGET(m); 			if (m->m_len == CLBYTES) 				m->m_len = len = MIN(len, CLBYTES); 			else 				m->m_len = len = MIN(MLEN, len); 		} else { 			m->m_len = len = MIN(MLEN, len); 			m->m_off = MMINOFF; 		} 		mcp = mtod(m, u_char *); 		if (ifp) {
comment|/* 			 * Prepend interface pointer to first mbuf. 			 */
argument|*(mtod(m, struct ifnet **)) = ifp; 			mcp += sizeof (ifp); 			len -= sizeof (ifp); 			ifp = (struct ifnet *)
literal|0
argument|; 		} 		bcopy(cp, mcp, (u_int)len); 		cp += len; 		*mp = m; 		mp =&m->m_next; 		if (off ==
literal|0
argument|) { 			totlen -= len; 			continue; 		} 		off += len; 		if (off == totlen) { 			cp = rxbuf + sizeof (struct ether_header); 			off =
literal|0
argument|; 			totlen = off0; 		} 	} 	return (top); bad: 	m_freem(top); 	return (
literal|0
argument|); }  static if_vbaput(ifu, m0) caddr_t ifu; struct mbuf *m0; { 	register struct mbuf *m = m0; 	register caddr_t cp = ifu;  	while (m) { 		bcopy(mtod(m, caddr_t), cp, (u_int)m->m_len); 		cp += m->m_len; 		MFREE(m, m0); 		m = m0; 	} 	if ((int)cp&
literal|1
argument|) 		*cp++ =
literal|0
argument|; 	return (cp - ifu); }
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

