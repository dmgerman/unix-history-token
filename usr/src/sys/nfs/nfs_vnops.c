begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)nfs_vnops.c	7.22 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * vnode op calls for sun nfs version 2  */
end_comment

begin_include
include|#
directive|include
file|"machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"machine/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"strings.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"../ufs/dir.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"ucred.h"
end_include

begin_include
include|#
directive|include
file|"namei.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"../ufs/inode.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"nfsv2.h"
end_include

begin_include
include|#
directive|include
file|"nfs.h"
end_include

begin_include
include|#
directive|include
file|"nfsnode.h"
end_include

begin_include
include|#
directive|include
file|"nfsmount.h"
end_include

begin_include
include|#
directive|include
file|"xdr_subs.h"
end_include

begin_include
include|#
directive|include
file|"nfsm_subs.h"
end_include

begin_include
include|#
directive|include
file|"nfsiom.h"
end_include

begin_comment
comment|/* Defs */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/* Global vars */
end_comment

begin_decl_stmt
name|int
name|nfs_lookup
argument_list|()
decl_stmt|,
name|nfs_create
argument_list|()
decl_stmt|,
name|nfs_mknod
argument_list|()
decl_stmt|,
name|nfs_open
argument_list|()
decl_stmt|,
name|nfs_close
argument_list|()
decl_stmt|,
name|nfs_access
argument_list|()
decl_stmt|,
name|nfs_getattr
argument_list|()
decl_stmt|,
name|nfs_setattr
argument_list|()
decl_stmt|,
name|nfs_read
argument_list|()
decl_stmt|,
name|nfs_write
argument_list|()
decl_stmt|,
name|vfs_noop
argument_list|()
decl_stmt|,
name|vfs_nullop
argument_list|()
decl_stmt|,
name|nfs_remove
argument_list|()
decl_stmt|,
name|nfs_link
argument_list|()
decl_stmt|,
name|nfs_rename
argument_list|()
decl_stmt|,
name|nfs_mkdir
argument_list|()
decl_stmt|,
name|nfs_rmdir
argument_list|()
decl_stmt|,
name|nfs_symlink
argument_list|()
decl_stmt|,
name|nfs_readdir
argument_list|()
decl_stmt|,
name|nfs_readlink
argument_list|()
decl_stmt|,
name|nfs_abortop
argument_list|()
decl_stmt|,
name|nfs_lock
argument_list|()
decl_stmt|,
name|nfs_unlock
argument_list|()
decl_stmt|,
name|nfs_bmap
argument_list|()
decl_stmt|,
name|nfs_strategy
argument_list|()
decl_stmt|,
name|nfs_fsync
argument_list|()
decl_stmt|,
name|nfs_inactive
argument_list|()
decl_stmt|,
name|nfs_reclaim
argument_list|()
decl_stmt|,
name|nfs_print
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnodeops
name|nfsv2_vnodeops
init|=
block|{
name|nfs_lookup
block|,
comment|/* lookup */
name|nfs_create
block|,
comment|/* create */
name|nfs_mknod
block|,
comment|/* mknod */
name|nfs_open
block|,
comment|/* open */
name|nfs_close
block|,
comment|/* close */
name|nfs_access
block|,
comment|/* access */
name|nfs_getattr
block|,
comment|/* getattr */
name|nfs_setattr
block|,
comment|/* setattr */
name|nfs_read
block|,
comment|/* read */
name|nfs_write
block|,
comment|/* write */
name|vfs_noop
block|,
comment|/* ioctl */
name|vfs_noop
block|,
comment|/* select */
name|vfs_noop
block|,
comment|/* mmap */
name|nfs_fsync
block|,
comment|/* fsync */
name|vfs_nullop
block|,
comment|/* seek */
name|nfs_remove
block|,
comment|/* remove */
name|nfs_link
block|,
comment|/* link */
name|nfs_rename
block|,
comment|/* rename */
name|nfs_mkdir
block|,
comment|/* mkdir */
name|nfs_rmdir
block|,
comment|/* rmdir */
name|nfs_symlink
block|,
comment|/* symlink */
name|nfs_readdir
block|,
comment|/* readdir */
name|nfs_readlink
block|,
comment|/* readlink */
name|nfs_abortop
block|,
comment|/* abortop */
name|nfs_inactive
block|,
comment|/* inactive */
name|nfs_reclaim
block|,
comment|/* reclaim */
name|nfs_lock
block|,
comment|/* lock */
name|nfs_unlock
block|,
comment|/* unlock */
name|nfs_bmap
block|,
comment|/* bmap */
name|nfs_strategy
block|,
comment|/* strategy */
name|nfs_print
block|,
comment|/* print */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Special device vnode ops */
end_comment

begin_decl_stmt
name|int
name|spec_lookup
argument_list|()
decl_stmt|,
name|spec_open
argument_list|()
decl_stmt|,
name|spec_read
argument_list|()
decl_stmt|,
name|spec_write
argument_list|()
decl_stmt|,
name|spec_strategy
argument_list|()
decl_stmt|,
name|spec_bmap
argument_list|()
decl_stmt|,
name|spec_ioctl
argument_list|()
decl_stmt|,
name|spec_select
argument_list|()
decl_stmt|,
name|spec_close
argument_list|()
decl_stmt|,
name|spec_badop
argument_list|()
decl_stmt|,
name|spec_nullop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnodeops
name|spec_nfsv2nodeops
init|=
block|{
name|spec_lookup
block|,
comment|/* lookup */
name|spec_badop
block|,
comment|/* create */
name|spec_badop
block|,
comment|/* mknod */
name|spec_open
block|,
comment|/* open */
name|spec_close
block|,
comment|/* close */
name|nfs_access
block|,
comment|/* access */
name|nfs_getattr
block|,
comment|/* getattr */
name|nfs_setattr
block|,
comment|/* setattr */
name|spec_read
block|,
comment|/* read */
name|spec_write
block|,
comment|/* write */
name|spec_ioctl
block|,
comment|/* ioctl */
name|spec_select
block|,
comment|/* select */
name|spec_badop
block|,
comment|/* mmap */
name|spec_nullop
block|,
comment|/* fsync */
name|spec_badop
block|,
comment|/* seek */
name|spec_badop
block|,
comment|/* remove */
name|spec_badop
block|,
comment|/* link */
name|spec_badop
block|,
comment|/* rename */
name|spec_badop
block|,
comment|/* mkdir */
name|spec_badop
block|,
comment|/* rmdir */
name|spec_badop
block|,
comment|/* symlink */
name|spec_badop
block|,
comment|/* readdir */
name|spec_badop
block|,
comment|/* readlink */
name|spec_badop
block|,
comment|/* abortop */
name|nfs_inactive
block|,
comment|/* inactive */
name|nfs_reclaim
block|,
comment|/* reclaim */
name|nfs_lock
block|,
comment|/* lock */
name|nfs_unlock
block|,
comment|/* unlock */
name|spec_bmap
block|,
comment|/* bmap */
name|spec_strategy
block|,
comment|/* strategy */
name|nfs_print
block|,
comment|/* print */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|nfs_procids
index|[
name|NFS_NPROCS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|nfs_prog
decl_stmt|,
name|nfs_vers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|nfsiobuf
index|[
name|MAXPHYS
operator|+
name|NBPG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|map
name|nfsmap
index|[
name|NFS_MSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|vtype
name|v_type
index|[
name|NFLNK
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|nfs_bqueue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue head for nfsiod's */
end_comment

begin_decl_stmt
name|int
name|nfs_asyncdaemons
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|nfs_iodwant
index|[
name|MAX_ASYNCDAEMON
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsmap_want
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * nfs null call from vfs.  */
end_comment

begin_macro
name|nfs_null
argument_list|(
argument|vp
argument_list|,
argument|cred
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_NULL
index|]
argument_list|,
name|cred
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs access vnode op.  * Essentially just get vattr and then imitate iaccess()  */
end_comment

begin_macro
name|nfs_access
argument_list|(
argument|vp
argument_list|,
argument|mode
argument_list|,
argument|cred
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
specifier|register
name|gid_t
modifier|*
name|gp
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * If you're the super-user, 	 * you always get access. 	 */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vap
operator|=
operator|&
name|vattr
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|nfs_getattr
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|cred
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Access check is based on only one of owner, group, public. 	 * If not owner, then check group. If not a member of the 	 * group, then check public access. 	 */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|vap
operator|->
name|va_uid
condition|)
block|{
name|mode
operator|>>=
literal|3
expr_stmt|;
name|gp
operator|=
name|cred
operator|->
name|cr_groups
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cred
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
operator|,
name|gp
operator|++
control|)
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|==
operator|*
name|gp
condition|)
goto|goto
name|found
goto|;
name|mode
operator|>>=
literal|3
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mode
operator|&
name|mode
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs open vnode op  * Just check to see if the type is ok  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|nfs_open
argument_list|(
argument|vp
argument_list|,
argument|mode
argument_list|,
argument|cred
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|enum
name|vtype
name|vtyp
decl_stmt|;
name|vtyp
operator|=
name|vp
operator|->
name|v_type
expr_stmt|;
if|if
condition|(
name|vtyp
operator|==
name|VREG
operator|||
name|vtyp
operator|==
name|VDIR
operator|||
name|vtyp
operator|==
name|VLNK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs close vnode op  * For reg files, invalidate any buffer cache entries.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|nfs_close
argument_list|(
name|vp
argument_list|,
name|fflags
argument_list|,
name|cred
argument_list|)
specifier|register
expr|struct
name|vnode
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|(
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
operator|)
operator|||
operator|(
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NBUFFERED
operator|)
operator|&&
name|np
operator|->
name|n_sillyrename
operator|)
operator|)
condition|)
block|{
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator|&=
operator|~
operator|(
name|NMODIFIED
operator||
name|NBUFFERED
operator|)
expr_stmt|;
name|vinvalbuf
argument_list|(
name|vp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NWRITEERR
condition|)
block|{
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NWRITEERR
expr_stmt|;
name|error
operator|=
name|np
operator|->
name|n_error
expr_stmt|;
block|}
name|nfs_unlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs getattr call from vfs.  */
end_comment

begin_expr_stmt
name|nfs_getattr
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|cred
argument_list|)
specifier|register
expr|struct
name|vnode
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
comment|/* First look in the cache.. */
if|if
condition|(
name|nfs_getattrcache
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_GETATTR
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_GETATTR
index|]
argument_list|,
name|cred
argument_list|,
name|NFSX_FH
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_loadattr
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs setattr call.  */
end_comment

begin_expr_stmt
name|nfs_setattr
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|cred
argument_list|)
specifier|register
expr|struct
name|vnode
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nfsv2_sattr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_SETATTR
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_SETATTR
index|]
argument_list|,
name|cred
argument_list|,
name|NFSX_FH
operator|+
name|NFSX_SATTR
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|sp
argument_list|,
expr|struct
name|nfsv2_sattr
operator|*
argument_list|,
name|NFSX_SATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|==
literal|0xffff
condition|)
name|sp
operator|->
name|sa_mode
operator|=
name|VNOVAL
expr_stmt|;
else|else
name|sp
operator|->
name|sa_mode
operator|=
name|vtonfs_mode
argument_list|(
name|vp
operator|->
name|v_type
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|==
literal|0xffff
condition|)
name|sp
operator|->
name|sa_uid
operator|=
name|VNOVAL
expr_stmt|;
else|else
name|sp
operator|->
name|sa_uid
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|==
literal|0xffff
condition|)
name|sp
operator|->
name|sa_gid
operator|=
name|VNOVAL
expr_stmt|;
else|else
name|sp
operator|->
name|sa_gid
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_size
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
condition|)
block|{
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NMODIFIED
expr_stmt|;
name|vinvalbuf
argument_list|(
name|vp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|sa_atime
operator|.
name|tv_sec
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_atime
operator|.
name|tv_usec
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_flags
argument_list|)
expr_stmt|;
name|txdr_time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
operator|&
name|sp
operator|->
name|sa_mtime
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_loadattr
argument_list|(
name|vp
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* should we fill in any vap fields ?? */
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs lookup call, one step at a time...  * First look in cache  * If not found, unlock the directory nfsnode and do the rpc  */
end_comment

begin_expr_stmt
name|nfs_lookup
argument_list|(
name|vp
argument_list|,
name|ndp
argument_list|)
specifier|register
expr|struct
name|vnode
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vdp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
decl_stmt|;
name|long
name|len
decl_stmt|;
name|nfsv2fh_t
modifier|*
name|fhp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|int
name|lockparent
decl_stmt|,
name|wantparent
decl_stmt|,
name|flag
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|ndp
operator|->
name|ni_dvp
operator|=
name|vp
expr_stmt|;
name|ndp
operator|->
name|ni_vp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
name|lockparent
operator|=
name|ndp
operator|->
name|ni_nameiop
operator|&
name|LOCKPARENT
expr_stmt|;
name|flag
operator|=
name|ndp
operator|->
name|ni_nameiop
operator|&
name|OPFLAG
expr_stmt|;
name|wantparent
operator|=
name|ndp
operator|->
name|ni_nameiop
operator|&
operator|(
name|LOCKPARENT
operator||
name|WANTPARENT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cache_lookup
argument_list|(
name|ndp
argument_list|)
operator|)
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|vpid
decl_stmt|;
if|if
condition|(
name|vp
operator|==
name|ndp
operator|->
name|ni_rdir
operator|&&
name|ndp
operator|->
name|ni_isdotdot
condition|)
name|panic
argument_list|(
literal|"nfs_lookup: .. through root"
argument_list|)
expr_stmt|;
name|vdp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
name|vpid
operator|=
name|vdp
operator|->
name|v_id
expr_stmt|;
comment|/* 		 * See the comment starting `Step through' in ufs/ufs_lookup.c 		 * for an explanation of the locking protocol 		 */
if|if
condition|(
name|vp
operator|==
name|vdp
condition|)
block|{
name|VREF
argument_list|(
name|vdp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ndp
operator|->
name|ni_isdotdot
condition|)
block|{
name|nfs_unlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|vget
argument_list|(
name|vdp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|vget
argument_list|(
name|vdp
argument_list|)
expr_stmt|;
name|nfs_unlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|vpid
operator|==
name|vdp
operator|->
name|v_id
operator|&&
operator|!
name|nfs_getattr
argument_list|(
name|vdp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ndp
operator|->
name|ni_cred
argument_list|)
condition|)
block|{
name|nfsstats
operator|.
name|lookupcache_hits
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|nfs_nput
argument_list|(
name|vdp
argument_list|)
expr_stmt|;
block|}
block|}
name|ndp
operator|->
name|ni_vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
name|nfs_unlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|nfsstats
operator|.
name|lookupcache_misses
operator|++
expr_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_LOOKUP
index|]
operator|++
expr_stmt|;
name|len
operator|=
name|ndp
operator|->
name|ni_namelen
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_LOOKUP
index|]
argument_list|,
name|ndp
operator|->
name|ni_cred
argument_list|,
name|NFSX_FH
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|ndp
operator|->
name|ni_ptr
argument_list|,
name|len
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|lockparent
operator|||
operator|(
name|flag
operator|!=
name|CREATE
operator|&&
name|flag
operator|!=
name|RENAME
operator|)
operator|||
operator|*
name|ndp
operator|->
name|ni_next
operator|!=
literal|0
condition|)
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|nfsm_disect
argument_list|(
name|fhp
argument_list|,
name|nfsv2fh_t
operator|*
argument_list|,
name|NFSX_FH
argument_list|)
expr_stmt|;
comment|/* 	 * Handle DELETE and RENAME cases... 	 */
if|if
condition|(
name|flag
operator|==
name|DELETE
operator|&&
operator|*
name|ndp
operator|->
name|ni_next
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_fh
operator|.
name|fh_bytes
argument_list|,
operator|(
name|caddr_t
operator|)
name|fhp
argument_list|,
name|NFSX_FH
argument_list|)
condition|)
block|{
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|vp
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|error
operator|=
name|nfs_nget
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|,
name|fhp
argument_list|,
operator|&
name|np
argument_list|)
condition|)
block|{
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|=
name|nfs_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|md
argument_list|,
operator|&
name|dpos
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvp
operator|!=
name|vp
condition|)
name|nfs_nput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ndp
operator|->
name|ni_vp
operator|=
name|newvp
expr_stmt|;
if|if
condition|(
name|lockparent
operator|||
name|vp
operator|==
name|newvp
condition|)
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|flag
operator|==
name|RENAME
operator|&&
name|wantparent
operator|&&
operator|*
name|ndp
operator|->
name|ni_next
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_fh
operator|.
name|fh_bytes
argument_list|,
operator|(
name|caddr_t
operator|)
name|fhp
argument_list|,
name|NFSX_FH
argument_list|)
condition|)
block|{
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EISDIR
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|nfs_nget
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|,
name|fhp
argument_list|,
operator|&
name|np
argument_list|)
condition|)
block|{
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|nfs_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|md
argument_list|,
operator|&
name|dpos
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfs_nput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ndp
operator|->
name|ni_vp
operator|=
name|newvp
expr_stmt|;
if|if
condition|(
name|lockparent
condition|)
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_fh
operator|.
name|fh_bytes
argument_list|,
operator|(
name|caddr_t
operator|)
name|fhp
argument_list|,
name|NFSX_FH
argument_list|)
condition|)
block|{
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|vp
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ndp
operator|->
name|ni_isdotdot
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|nfs_nget
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|,
name|fhp
argument_list|,
operator|&
name|np
argument_list|)
condition|)
block|{
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|error
operator|=
name|nfs_nget
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|,
name|fhp
argument_list|,
operator|&
name|np
argument_list|)
condition|)
block|{
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|=
name|nfs_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|md
argument_list|,
operator|&
name|dpos
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvp
operator|!=
name|vp
condition|)
name|nfs_nput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|newvp
operator|||
operator|(
name|lockparent
operator|&&
operator|*
name|ndp
operator|->
name|ni_next
operator|==
literal|'\0'
operator|)
condition|)
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_vp
operator|=
name|newvp
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|ndp
operator|->
name|ni_makeentry
condition|)
name|cache_enter
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs readlink call  */
end_comment

begin_expr_stmt
name|nfs_readlink
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|cred
argument_list|)
specifier|register
expr|struct
name|vnode
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|long
name|len
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_READLINK
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_READLINK
index|]
argument_list|,
name|cred
argument_list|,
name|NFSX_FH
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_strsiz
argument_list|(
name|len
argument_list|,
name|NFS_MAXPATHLEN
argument_list|)
expr_stmt|;
name|nfsm_mtouio
argument_list|(
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs read call  */
end_comment

begin_expr_stmt
name|nfs_readrpc
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|cred
argument_list|)
specifier|register
expr|struct
name|vnode
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|long
name|len
decl_stmt|,
name|retlen
decl_stmt|,
name|tsiz
decl_stmt|;
name|nmp
operator|=
name|vfs_to_nfs
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|tsiz
operator|=
name|uiop
operator|->
name|uio_resid
expr_stmt|;
while|while
condition|(
name|tsiz
operator|>
literal|0
condition|)
block|{
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_READ
index|]
operator|++
expr_stmt|;
name|len
operator|=
operator|(
name|tsiz
operator|>
name|nmp
operator|->
name|nm_rsize
operator|)
condition|?
name|nmp
operator|->
name|nm_rsize
else|:
name|tsiz
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_READ
index|]
argument_list|,
name|cred
argument_list|,
name|NFSX_FH
operator|+
name|NFSX_UNSIGNED
operator|*
literal|3
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
operator|*
literal|3
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_loadattr
argument_list|(
name|vp
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|nfsm_strsiz
argument_list|(
name|retlen
argument_list|,
name|nmp
operator|->
name|nm_rsize
argument_list|)
expr_stmt|;
name|nfsm_mtouio
argument_list|(
name|uiop
argument_list|,
name|retlen
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|retlen
operator|<
name|len
condition|)
name|tsiz
operator|=
literal|0
expr_stmt|;
else|else
name|tsiz
operator|-=
name|len
expr_stmt|;
block|}
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs write call  */
end_comment

begin_expr_stmt
name|nfs_writerpc
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|cred
argument_list|)
specifier|register
expr|struct
name|vnode
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|long
name|len
decl_stmt|,
name|tsiz
decl_stmt|;
name|nmp
operator|=
name|vfs_to_nfs
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|tsiz
operator|=
name|uiop
operator|->
name|uio_resid
expr_stmt|;
while|while
condition|(
name|tsiz
operator|>
literal|0
condition|)
block|{
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_WRITE
index|]
operator|++
expr_stmt|;
name|len
operator|=
operator|(
name|tsiz
operator|>
name|nmp
operator|->
name|nm_wsize
operator|)
condition|?
name|nmp
operator|->
name|nm_wsize
else|:
name|tsiz
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_WRITE
index|]
argument_list|,
name|cred
argument_list|,
name|NFSX_FH
operator|+
name|NFSX_UNSIGNED
operator|*
literal|4
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
operator|*
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
name|txdr_unsigned
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|3
operator|)
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|nfsm_uiotom
argument_list|(
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_loadattr
argument_list|(
name|vp
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|tsiz
operator|-=
name|len
expr_stmt|;
block|}
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs mknod call  * This call is currently not supported.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|nfs_mknod
argument_list|(
argument|ndp
argument_list|,
argument|vap
argument_list|,
argument|cred
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|nfs_abortop
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs file create call  */
end_comment

begin_expr_stmt
name|nfs_create
argument_list|(
name|ndp
argument_list|,
name|vap
argument_list|)
specifier|register
expr|struct
name|nameidata
operator|*
name|ndp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nfsv2_sattr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_CREATE
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_CREATE
index|]
argument_list|,
name|ndp
operator|->
name|ni_cred
argument_list|,
name|NFSX_FH
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|)
operator|+
name|NFSX_SATTR
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|sp
argument_list|,
expr|struct
name|nfsv2_sattr
operator|*
argument_list|,
name|NFSX_SATTR
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_mode
operator|=
name|vtonfs_mode
argument_list|(
name|VREG
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_uid
operator|=
name|txdr_unsigned
argument_list|(
name|ndp
operator|->
name|ni_cred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_gid
operator|=
name|txdr_unsigned
argument_list|(
name|ndp
operator|->
name|ni_cred
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_size
operator|=
name|txdr_unsigned
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* or should these be VNOVAL ?? */
name|txdr_time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
operator|&
name|sp
operator|->
name|sa_atime
argument_list|)
expr_stmt|;
name|txdr_time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
operator|&
name|sp
operator|->
name|sa_mtime
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_mtofh
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
name|nfs_nput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs file remove call  * To try and make nfs semantics closer to vfs semantics, a file that has  * other references to the vnode is renamed instead of removed and then  * removed later on the last close.  * Unfortunately you must flush the buffer cache and cmap to get rid of  * all extraneous vnode references before you check the reference cnt.  * 1 - If the file could have blocks in the buffer cache  *	  flush them out and invalidate them  *	  mpurge the vnode to flush out cmap references  *	  (This is necessary to update the vnode ref cnt as well as sensible  *	   for actual removes, to free up the buffers)  * 2 - If v_usecount> 1  *	  If a rename is not already in the works  *	     call nfs_sillyrename() to set it up  *     else  *	  do the remove rpc  */
end_comment

begin_expr_stmt
name|nfs_remove
argument_list|(
name|ndp
argument_list|)
specifier|register
expr|struct
name|nameidata
operator|*
name|ndp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ndp
operator|->
name|ni_vp
decl_stmt|;
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
operator|(
name|NMODIFIED
operator||
name|NBUFFERED
operator|)
condition|)
block|{
name|np
operator|->
name|n_flag
operator|&=
operator|~
operator|(
name|NMODIFIED
operator||
name|NBUFFERED
operator|)
expr_stmt|;
name|vinvalbuf
argument_list|(
name|vp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NPAGEDON
condition|)
block|{
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NPAGEDON
expr_stmt|;
name|mpurge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* In case cmap entries still ref it */
block|}
block|}
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|np
operator|->
name|n_sillyrename
condition|)
name|error
operator|=
name|nfs_sillyrename
argument_list|(
name|ndp
argument_list|,
name|REMOVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_REMOVE
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_REMOVE
index|]
argument_list|,
name|ndp
operator|->
name|ni_cred
argument_list|,
name|NFSX_FH
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
comment|/* 		 * Kludge City: If the first reply to the remove rpc is lost.. 		 *   the reply to the retransmitted request will be ENOENT 		 *   since the file was in fact removed 		 *   Therefore, we cheat and return success. 		 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|==
name|ndp
operator|->
name|ni_vp
condition|)
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
else|else
name|nfs_nput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|nfs_nput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs file remove rpc called from nfs_inactive  */
end_comment

begin_expr_stmt
name|nfs_removeit
argument_list|(
name|ndp
argument_list|)
specifier|register
expr|struct
name|nameidata
operator|*
name|ndp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_REMOVE
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_REMOVE
index|]
argument_list|,
name|ndp
operator|->
name|ni_cred
argument_list|,
name|NFSX_FH
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs file rename call  */
end_comment

begin_expr_stmt
name|nfs_rename
argument_list|(
name|sndp
argument_list|,
name|tndp
argument_list|)
specifier|register
expr|struct
name|nameidata
operator|*
name|sndp
operator|,
operator|*
name|tndp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_RENAME
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_RENAME
index|]
argument_list|,
name|tndp
operator|->
name|ni_cred
argument_list|,
operator|(
name|NFSX_FH
operator|+
name|NFSX_UNSIGNED
operator|)
operator|*
literal|2
operator|+
name|nfsm_rndup
argument_list|(
name|sndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|)
operator|+
name|nfsm_rndup
argument_list|(
name|tndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* or sndp->ni_cred?*/
name|nfsm_fhtom
argument_list|(
name|sndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|sndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|sndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|tndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|tndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|tndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|sndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
if|if
condition|(
name|sndp
operator|->
name|ni_vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|tndp
operator|->
name|ni_vp
operator|!=
name|NULL
operator|&&
name|tndp
operator|->
name|ni_vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|cache_purge
argument_list|(
name|tndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|sndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
block|}
name|nfs_abortop
argument_list|(
name|sndp
argument_list|)
expr_stmt|;
name|nfs_abortop
argument_list|(
name|tndp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs file rename rpc called from above  */
end_comment

begin_expr_stmt
name|nfs_renameit
argument_list|(
name|sndp
argument_list|,
name|tndp
argument_list|)
specifier|register
expr|struct
name|nameidata
operator|*
name|sndp
operator|,
operator|*
name|tndp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_RENAME
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_RENAME
index|]
argument_list|,
name|tndp
operator|->
name|ni_cred
argument_list|,
operator|(
name|NFSX_FH
operator|+
name|NFSX_UNSIGNED
operator|)
operator|*
literal|2
operator|+
name|nfsm_rndup
argument_list|(
name|sndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|)
operator|+
name|nfsm_rndup
argument_list|(
name|tndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* or sndp->ni_cred?*/
name|nfsm_fhtom
argument_list|(
name|sndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|sndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|sndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|tndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|tndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|tndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|sndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs hard link create call  */
end_comment

begin_expr_stmt
name|nfs_link
argument_list|(
name|vp
argument_list|,
name|ndp
argument_list|)
specifier|register
expr|struct
name|vnode
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|!=
name|vp
condition|)
name|nfs_lock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_LINK
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_LINK
index|]
argument_list|,
name|ndp
operator|->
name|ni_cred
argument_list|,
name|NFSX_FH
operator|*
literal|2
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|!=
name|vp
condition|)
name|nfs_unlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfs_nput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs symbolic link create call  */
end_comment

begin_macro
name|nfs_symlink
argument_list|(
argument|ndp
argument_list|,
argument|vap
argument_list|,
argument|nm
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|nm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is this the path ?? */
end_comment

begin_block
block|{
specifier|register
name|struct
name|nfsv2_sattr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_SYMLINK
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_SYMLINK
index|]
argument_list|,
name|ndp
operator|->
name|ni_cred
argument_list|,
name|NFSX_FH
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|)
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|nm
argument_list|,
name|strlen
argument_list|(
name|nm
argument_list|)
argument_list|,
name|NFS_MAXPATHLEN
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|sp
argument_list|,
expr|struct
name|nfsv2_sattr
operator|*
argument_list|,
name|NFSX_SATTR
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_mode
operator|=
name|vtonfs_mode
argument_list|(
name|VLNK
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_uid
operator|=
name|txdr_unsigned
argument_list|(
name|ndp
operator|->
name|ni_cred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_gid
operator|=
name|txdr_unsigned
argument_list|(
name|ndp
operator|->
name|ni_cred
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_size
operator|=
name|txdr_unsigned
argument_list|(
name|VNOVAL
argument_list|)
expr_stmt|;
name|txdr_time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
operator|&
name|sp
operator|->
name|sa_atime
argument_list|)
expr_stmt|;
comment|/* or VNOVAL ?? */
name|txdr_time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
operator|&
name|sp
operator|->
name|sa_mtime
argument_list|)
expr_stmt|;
comment|/* or VNOVAL ?? */
name|nfsm_request
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
name|nfs_nput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs make dir call  */
end_comment

begin_expr_stmt
name|nfs_mkdir
argument_list|(
name|ndp
argument_list|,
name|vap
argument_list|)
specifier|register
expr|struct
name|nameidata
operator|*
name|ndp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nfsv2_sattr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_MKDIR
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_MKDIR
index|]
argument_list|,
name|ndp
operator|->
name|ni_cred
argument_list|,
name|NFSX_FH
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|)
operator|+
name|NFSX_SATTR
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|sp
argument_list|,
expr|struct
name|nfsv2_sattr
operator|*
argument_list|,
name|NFSX_SATTR
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_mode
operator|=
name|vtonfs_mode
argument_list|(
name|VDIR
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_uid
operator|=
name|txdr_unsigned
argument_list|(
name|ndp
operator|->
name|ni_cred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_gid
operator|=
name|txdr_unsigned
argument_list|(
name|ndp
operator|->
name|ni_cred
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_size
operator|=
name|txdr_unsigned
argument_list|(
name|VNOVAL
argument_list|)
expr_stmt|;
name|txdr_time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
operator|&
name|sp
operator|->
name|sa_atime
argument_list|)
expr_stmt|;
comment|/* or VNOVAL ?? */
name|txdr_time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
operator|&
name|sp
operator|->
name|sa_mtime
argument_list|)
expr_stmt|;
comment|/* or VNOVAL ?? */
name|nfsm_request
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_mtofh
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
name|nfs_nput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs remove directory call  */
end_comment

begin_expr_stmt
name|nfs_rmdir
argument_list|(
name|ndp
argument_list|)
specifier|register
expr|struct
name|nameidata
operator|*
name|ndp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|==
name|ndp
operator|->
name|ni_vp
condition|)
block|{
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfs_nput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_RMDIR
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_RMDIR
index|]
argument_list|,
name|ndp
operator|->
name|ni_cred
argument_list|,
name|NFSX_FH
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
name|cache_purge
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|nfs_nput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|nfs_nput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs readdir call  * Although cookie is defined as opaque, I translate it to/from net byte  * order so that it looks more sensible. This appears consistent with the  * Ultrix implementation of NFS.  */
end_comment

begin_expr_stmt
name|nfs_readdir
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|cred
argument_list|)
specifier|register
expr|struct
name|vnode
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|len
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md2
decl_stmt|;
name|caddr_t
name|dpos2
decl_stmt|;
name|int
name|siz
decl_stmt|;
name|int
name|more_dirs
decl_stmt|;
name|off_t
name|off
decl_stmt|,
name|savoff
decl_stmt|;
name|struct
name|direct
modifier|*
name|savdp
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_READDIR
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_READDIR
index|]
argument_list|,
name|cred
argument_list|,
name|xid
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|uiop
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|siz
operator|=
literal|0
expr_stmt|;
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* Save the position so that we can do nfsm_mtouio() later */
name|dpos2
operator|=
name|dpos
expr_stmt|;
name|md2
operator|=
name|md
expr_stmt|;
comment|/* loop thru the dir entries, doctoring them to 4bsd form */
name|savoff
operator|=
name|off
operator|=
literal|0
expr_stmt|;
name|savdp
operator|=
name|dp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|more_dirs
operator|&&
name|siz
operator|<
name|uiop
operator|->
name|uio_resid
condition|)
block|{
name|savoff
operator|=
name|off
expr_stmt|;
comment|/* Hold onto offset and dp */
name|savdp
operator|=
name|dp
expr_stmt|;
name|nfsm_disecton
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|p
expr_stmt|;
name|dp
operator|->
name|d_ino
operator|=
name|fxdr_unsigned
argument_list|(
name|u_long
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|dp
operator|->
name|d_namlen
operator|=
operator|(
name|u_short
operator|)
name|len
expr_stmt|;
name|len
operator|=
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|nfsm_adv
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|nfsm_disecton
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|off
operator|=
name|fxdr_unsigned
argument_list|(
name|off_t
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Ensures null termination of name */
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|len
operator|+
literal|4
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|siz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
block|}
comment|/* 	 * If at end of rpc data, get the eof boolean 	 */
if|if
condition|(
operator|!
name|more_dirs
condition|)
name|nfsm_disecton
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* 	 * If there is too much to fit in the data buffer, use savoff and 	 * savdp to trim off the last record. 	 * --> we are not at eof 	 */
if|if
condition|(
name|siz
operator|>
name|uiop
operator|->
name|uio_resid
condition|)
block|{
name|off
operator|=
name|savoff
expr_stmt|;
name|siz
operator|-=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|dp
operator|=
name|savdp
expr_stmt|;
block|}
if|if
condition|(
name|siz
operator|>
literal|0
condition|)
block|{
name|md
operator|=
name|md2
expr_stmt|;
name|dpos
operator|=
name|dpos2
expr_stmt|;
name|nfsm_mtouio
argument_list|(
name|uiop
argument_list|,
name|siz
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|=
name|off
expr_stmt|;
block|}
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs statfs call  * (Actually a vfsop, not a vnode op)  */
end_comment

begin_macro
name|nfs_statfs
argument_list|(
argument|mp
argument_list|,
argument|sbp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|statfs
modifier|*
name|sbp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|nfsv2_statfs
modifier|*
name|sfp
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|nmp
operator|=
name|vfs_to_nfs
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|nfs_nget
argument_list|(
name|mp
argument_list|,
operator|&
name|nmp
operator|->
name|nm_fh
argument_list|,
operator|&
name|np
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_STATFS
index|]
operator|++
expr_stmt|;
name|cred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|cred
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_STATFS
index|]
argument_list|,
name|cred
argument_list|,
name|NFSX_FH
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_disect
argument_list|(
name|sfp
argument_list|,
expr|struct
name|nfsv2_statfs
operator|*
argument_list|,
name|NFSX_STATFS
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_type
operator|=
name|MOUNT_NFS
expr_stmt|;
name|sbp
operator|->
name|f_flags
operator|=
name|nmp
operator|->
name|nm_flag
expr_stmt|;
name|sbp
operator|->
name|f_bsize
operator|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
name|sfp
operator|->
name|sf_tsize
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_fsize
operator|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
name|sfp
operator|->
name|sf_bsize
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
name|sfp
operator|->
name|sf_blocks
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
name|sfp
operator|->
name|sf_bfree
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_bavail
operator|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
name|sfp
operator|->
name|sf_bavail
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|m_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|sbp
operator|->
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|m_fsid
operator|.
name|val
index|[
literal|1
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|nmp
operator|->
name|nm_path
argument_list|,
name|sbp
operator|->
name|f_mntonname
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|nmp
operator|->
name|nm_host
argument_list|,
name|sbp
operator|->
name|f_mntfromname
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
name|nfs_nput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|hextoasc
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Silly rename. To make the NFS filesystem that is stateless look a little  * more like the "ufs" a remove of an active vnode is translated to a rename  * to a funny looking filename that is removed by nfs_inactive on the  * nfsnode. There is the potential for another process on a different client  * to create the same funny name between the nfs_lookitup() fails and the  * nfs_rename() completes, but...  */
end_comment

begin_expr_stmt
name|nfs_sillyrename
argument_list|(
name|ndp
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|nameidata
operator|*
name|ndp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|sillyrename
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|nameidata
modifier|*
name|tndp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|short
name|pid
decl_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|sp
argument_list|,
expr|struct
name|sillyrename
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sillyrename
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_flag
operator|=
name|flag
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|np
operator|->
name|n_fh
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sp
operator|->
name|s_fh
argument_list|,
name|NFSX_FH
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|tndp
operator|=
operator|&
name|sp
operator|->
name|s_namei
expr_stmt|;
name|tndp
operator|->
name|ni_cred
operator|=
name|crdup
argument_list|(
name|ndp
operator|->
name|ni_cred
argument_list|)
expr_stmt|;
comment|/* Fudge together a funny name */
name|pid
operator|=
name|u
operator|.
name|u_procp
operator|->
name|p_pid
expr_stmt|;
name|bcopy
argument_list|(
literal|".nfsAxxxx4.4"
argument_list|,
name|tndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|tndp
operator|->
name|ni_dent
operator|.
name|d_namlen
operator|=
literal|12
expr_stmt|;
name|tndp
operator|->
name|ni_dent
operator|.
name|d_name
index|[
literal|8
index|]
operator|=
name|hextoasc
index|[
name|pid
operator|&
literal|0xf
index|]
expr_stmt|;
name|tndp
operator|->
name|ni_dent
operator|.
name|d_name
index|[
literal|7
index|]
operator|=
name|hextoasc
index|[
operator|(
name|pid
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|tndp
operator|->
name|ni_dent
operator|.
name|d_name
index|[
literal|6
index|]
operator|=
name|hextoasc
index|[
operator|(
name|pid
operator|>>
literal|8
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|tndp
operator|->
name|ni_dent
operator|.
name|d_name
index|[
literal|5
index|]
operator|=
name|hextoasc
index|[
operator|(
name|pid
operator|>>
literal|12
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
comment|/* Try lookitups until we get one that isn't there */
while|while
condition|(
name|nfs_lookitup
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
name|tndp
argument_list|,
operator|(
name|nfsv2fh_t
operator|*
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tndp
operator|->
name|ni_dent
operator|.
name|d_name
index|[
literal|4
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|tndp
operator|->
name|ni_dent
operator|.
name|d_name
index|[
literal|4
index|]
operator|>
literal|'z'
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|error
operator|=
name|nfs_renameit
argument_list|(
name|ndp
argument_list|,
name|tndp
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|nfs_lookitup
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
name|tndp
argument_list|,
operator|&
name|np
operator|->
name|n_fh
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_sillyrename
operator|=
name|sp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|crfree
argument_list|(
name|tndp
operator|->
name|ni_cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Look up a file name for silly rename stuff.  * Just like nfs_lookup() except that it doesn't load returned values  * into the nfsnode table.  * If fhp != NULL it copies the returned file handle out  */
end_comment

begin_expr_stmt
name|nfs_lookitup
argument_list|(
name|vp
argument_list|,
name|ndp
argument_list|,
name|fhp
argument_list|)
specifier|register
expr|struct
name|vnode
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|nfsv2fh_t
modifier|*
name|fhp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|long
name|len
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_LOOKUP
index|]
operator|++
expr_stmt|;
name|ndp
operator|->
name|ni_dvp
operator|=
name|vp
expr_stmt|;
name|ndp
operator|->
name|ni_vp
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|ndp
operator|->
name|ni_dent
operator|.
name|d_namlen
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|nfs_procids
index|[
name|NFSPROC_LOOKUP
index|]
argument_list|,
name|ndp
operator|->
name|ni_cred
argument_list|,
name|NFSX_FH
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|ndp
operator|->
name|ni_dent
operator|.
name|d_name
argument_list|,
name|len
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fhp
operator|!=
name|NULL
condition|)
block|{
name|nfsm_disect
argument_list|(
name|cp
argument_list|,
name|caddr_t
argument_list|,
name|NFSX_FH
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|(
name|caddr_t
operator|)
name|fhp
argument_list|,
name|NFSX_FH
argument_list|)
expr_stmt|;
block|}
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Kludge City..  * - make nfs_bmap() essentially a no-op that does no translation  * - do nfs_strategy() by faking physical I/O with nfs_readit/nfs_writeit  *   after mapping the physical addresses into Kernel Virtual space in the  *   nfsiobuf area.  *   (Maybe I could use the process's page mapping, but I was concerned that  *    Kernel Write might not be enabled and also figured copyout() would do  *    a lot more work than bcopy() and also it currently happens in the  *    context of the swapper process (2).  */
end_comment

begin_macro
name|nfs_bmap
argument_list|(
argument|vp
argument_list|,
argument|bn
argument_list|,
argument|vpp
argument_list|,
argument|bnp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|bn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
modifier|*
name|bnp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|vpp
operator|!=
name|NULL
condition|)
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
if|if
condition|(
name|bnp
operator|!=
name|NULL
condition|)
operator|*
name|bnp
operator|=
name|bn
operator|*
name|btodb
argument_list|(
name|vp
operator|->
name|v_mount
operator|->
name|m_bsize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Strategy routine for phys. i/o  * If the biod's are running, queue a request  * otherwise just call nfs_doio() to get it done  */
end_comment

begin_expr_stmt
name|nfs_strategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|proc
modifier|*
name|rp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|fnd
init|=
literal|0
decl_stmt|;
comment|/* 	 * If an i/o daemon is waiting 	 * queue the request, wake it up and wait for completion 	 * otherwise just do it ourselves 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfs_asyncdaemons
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rp
operator|=
name|nfs_iodwant
index|[
name|i
index|]
condition|)
block|{
comment|/* 			 * Ensure that the async_daemon is still waiting here 			 */
if|if
condition|(
name|rp
operator|->
name|p_stat
operator|!=
name|SSLEEP
operator|||
name|rp
operator|->
name|p_wchan
operator|!=
operator|(
operator|(
name|caddr_t
operator|)
operator|&
name|nfs_iodwant
index|[
name|i
index|]
operator|)
condition|)
block|{
name|nfs_iodwant
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
continue|continue;
block|}
name|dp
operator|=
operator|&
name|nfs_bqueue
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
operator|==
name|NULL
condition|)
block|{
name|dp
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_actf
operator|=
name|dp
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|->
name|b_actf
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_actf
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
block|}
name|dp
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_actl
operator|=
name|dp
expr_stmt|;
name|fnd
operator|++
expr_stmt|;
name|nfs_iodwant
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nfs_iodwant
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|fnd
condition|)
name|error
operator|=
name|nfs_doio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Fun and games with i/o  * Essentially play ubasetup() and disk interrupt service routine by  * mapping the data buffer into kernel virtual space and doing the  * nfs read or write rpc's from it.  * If the biod's are not running, this is just called from nfs_strategy(),  * otherwise it is called by the biod's to do what would normally be  * partially disk interrupt driven.  */
end_comment

begin_expr_stmt
name|nfs_doio
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|,
modifier|*
name|ppte
decl_stmt|;
specifier|register
name|caddr_t
name|vaddr
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
name|int
name|npf
decl_stmt|,
name|npf2
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|caddr_t
name|vbase
decl_stmt|;
name|unsigned
name|v
decl_stmt|;
name|struct
name|proc
modifier|*
name|rp
decl_stmt|;
name|int
name|o
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|io
decl_stmt|;
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
name|uiop
operator|=
operator|&
name|uio
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|=
operator|&
name|io
expr_stmt|;
name|uiop
operator|->
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uiop
operator|->
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
comment|/* 	 * For phys i/o, map the b_addr into kernel virtual space using 	 * the Nfsiomap pte's 	 * Also, add a temporary b_rcred for reading using the process's uid 	 * and a guess at a group 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PHYS
condition|)
block|{
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_flag
operator||=
name|NPAGEDON
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|cr
operator|=
name|crget
argument_list|()
expr_stmt|;
name|rp
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DIRTY
operator|)
condition|?
operator|&
name|proc
index|[
literal|2
index|]
else|:
name|bp
operator|->
name|b_proc
expr_stmt|;
name|cr
operator|->
name|cr_uid
operator|=
name|rp
operator|->
name|p_uid
expr_stmt|;
name|cr
operator|->
name|cr_gid
operator|=
literal|0
expr_stmt|;
comment|/* Anything ?? */
name|cr
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
name|o
operator|=
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|&
name|PGOFSET
expr_stmt|;
name|npf2
operator|=
name|npf
operator|=
name|btoc
argument_list|(
name|bp
operator|->
name|b_bcount
operator|+
name|o
argument_list|)
expr_stmt|;
comment|/* 		 * Get some mapping page table entries 		 */
while|while
condition|(
operator|(
name|reg
operator|=
name|rmalloc
argument_list|(
name|nfsmap
argument_list|,
operator|(
name|long
operator|)
name|npf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|nfsmap_want
operator|++
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nfsmap_want
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|reg
operator|--
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PAGET
condition|)
name|pte
operator|=
operator|&
name|Usrptmap
index|[
name|btokmx
argument_list|(
operator|(
expr|struct
name|pte
operator|*
block|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
block|)
end_block

begin_empty_stmt
unit|]
empty_stmt|;
end_empty_stmt

begin_else
else|else
block|{
name|v
operator|=
name|btop
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_UAREA
condition|)
name|pte
operator|=
operator|&
name|rp
operator|->
name|p_addr
index|[
name|v
index|]
expr_stmt|;
else|else
name|pte
operator|=
name|vtopte
argument_list|(
name|rp
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_else

begin_comment
comment|/* 		 * Play vmaccess() but with the Nfsiomap page table 		 */
end_comment

begin_expr_stmt
name|ppte
operator|=
operator|&
name|Nfsiomap
index|[
name|reg
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vbase
operator|=
name|vaddr
operator|=
operator|&
name|nfsiobuf
index|[
name|reg
operator|*
name|NBPG
index|]
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|npf
operator|!=
literal|0
condition|)
block|{
name|mapin
argument_list|(
name|ppte
argument_list|,
operator|(
name|u_int
operator|)
name|vaddr
argument_list|,
name|pte
operator|->
name|pg_pfnum
argument_list|,
call|(
name|int
call|)
argument_list|(
name|PG_V
operator||
name|PG_KW
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
name|mtpr
argument_list|(
name|P1DC
argument_list|,
name|vaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ppte
operator|++
expr_stmt|;
name|pte
operator|++
expr_stmt|;
name|vaddr
operator|+=
name|NBPG
expr_stmt|;
operator|--
name|npf
expr_stmt|;
block|}
end_while

begin_comment
comment|/* 		 * And do the i/o rpc 		 */
end_comment

begin_expr_stmt
name|io
operator|.
name|iov_base
operator|=
name|vbase
operator|+
name|o
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|io
operator|.
name|iov_len
operator|=
name|uiop
operator|->
name|uio_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|uiop
operator|->
name|uio_offset
operator|=
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|nfsstats
operator|.
name|read_physios
operator|++
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
operator|=
name|nfs_readrpc
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|bp
operator|->
name|b_rcred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|nfsstats
operator|.
name|write_physios
operator|++
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
operator|=
name|nfs_writerpc
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|bp
operator|->
name|b_wcred
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* 		 * Finally, release pte's used by physical i/o 		 */
end_comment

begin_expr_stmt
name|crfree
argument_list|(
name|cr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rmfree
argument_list|(
name|nfsmap
argument_list|,
operator|(
name|long
operator|)
name|npf2
argument_list|,
operator|(
name|long
operator|)
operator|++
name|reg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|nfsmap_want
condition|)
block|{
name|nfsmap_want
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nfsmap_want
argument_list|)
expr_stmt|;
block|}
end_if

begin_block
unit|} else
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|io
operator|.
name|iov_len
operator|=
name|uiop
operator|->
name|uio_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|=
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
expr_stmt|;
name|io
operator|.
name|iov_base
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|nfsstats
operator|.
name|read_bios
operator|++
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
operator|=
name|nfs_readrpc
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|bp
operator|->
name|b_rcred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|io
operator|.
name|iov_len
operator|=
name|uiop
operator|->
name|uio_resid
operator|=
name|bp
operator|->
name|b_dirtyend
operator|-
name|bp
operator|->
name|b_dirtyoff
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|=
operator|(
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|)
operator|+
name|bp
operator|->
name|b_dirtyoff
expr_stmt|;
name|io
operator|.
name|iov_base
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|bp
operator|->
name|b_dirtyoff
expr_stmt|;
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|nfsstats
operator|.
name|write_bios
operator|++
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
operator|=
name|nfs_writerpc
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|bp
operator|->
name|b_wcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_error
operator|=
name|error
expr_stmt|;
name|np
operator|->
name|n_flag
operator||=
name|NWRITEERR
expr_stmt|;
block|}
name|bp
operator|->
name|b_dirtyoff
operator|=
name|bp
operator|->
name|b_dirtyend
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_if
if|if
condition|(
name|error
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
end_if

begin_expr_stmt
name|bp
operator|->
name|b_resid
operator|=
name|uiop
operator|->
name|uio_resid
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|error
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Flush all the blocks associated with a vnode.  * 	Walk through the buffer pool and push any dirty pages  *	associated with the vnode.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
unit|nfs_fsync
operator|(
name|vp
operator|,
name|fflags
operator|,
name|cred
operator|,
name|waitfor
operator|)
specifier|register
expr|struct
name|vnode
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|waitfor
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
condition|)
block|{
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NMODIFIED
expr_stmt|;
name|vflushbuf
argument_list|(
name|vp
argument_list|,
name|waitfor
operator|==
name|MNT_WAIT
condition|?
name|B_SYNC
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NWRITEERR
operator|)
condition|)
name|error
operator|=
name|np
operator|->
name|n_error
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Print out the contents of an nfsnode.  */
end_comment

begin_macro
name|nfs_print
argument_list|(
argument|vp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"tag VT_NFS, fileid %d fsid 0x%x%s\n"
argument_list|,
name|np
operator|->
name|n_vattr
operator|.
name|va_fileid
argument_list|,
name|np
operator|->
name|n_vattr
operator|.
name|va_fsid
argument_list|,
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NLOCKED
operator|)
condition|?
literal|" (LOCKED)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

