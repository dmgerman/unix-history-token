begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)nfs_socket.c	7.7 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Socket operations for use by nfs (similar to uipc_socket.c, but never  * with copies to/from a uio vector)  * NB: For now, they only work for datagram sockets.  * (Use on stream sockets would require some record boundary mark in the  *  stream as defined by "RPC: Remote Procedure Call Protocol  *  Specification" RFC1057 Section 10)  *  and different versions of send, receive and reply that do not assume  *  an atomic protocol  */
end_comment

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"signal.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"rpcv2.h"
end_include

begin_include
include|#
directive|include
file|"nfsv2.h"
end_include

begin_include
include|#
directive|include
file|"nfs.h"
end_include

begin_include
include|#
directive|include
file|"xdr_subs.h"
end_include

begin_include
include|#
directive|include
file|"nfsm_subs.h"
end_include

begin_include
include|#
directive|include
file|"nfsmount.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_define
define|#
directive|define
name|nfs_log
parameter_list|(
name|message
parameter_list|,
name|host
parameter_list|)
value|log(LOG_ERR, message, host)
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_comment
comment|/* set lock on sockbuf sb, sleep at neg prio */
end_comment

begin_define
define|#
directive|define
name|nfs_sblock
parameter_list|(
name|sb
parameter_list|)
value|{ \ 	while ((sb)->sb_flags& SB_LOCK) { \ 		(sb)->sb_flags |= SB_WANT; \ 		sleep((caddr_t)&(sb)->sb_flags, PZERO-1); \ 	} \ 	(sb)->sb_flags |= SB_LOCK; \ }
end_define

begin_comment
comment|/*  * nfs_sbwait() is simply sbwait() but at a negative priority so that it  * can not be interrupted by a signal.  */
end_comment

begin_macro
name|nfs_sbwait
argument_list|(
argument|sb
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sb
operator|->
name|sb_flags
operator||=
name|SB_WAIT
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sb
operator|->
name|sb_cc
argument_list|,
name|PZERO
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * External data, mostly RPC constants in XDR form  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|rpc_reply
decl_stmt|,
name|rpc_msgdenied
decl_stmt|,
name|rpc_mismatch
decl_stmt|,
name|rpc_vers
decl_stmt|,
name|rpc_auth_unix
decl_stmt|,
name|rpc_msgaccepted
decl_stmt|,
name|rpc_call
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|nfs_prog
decl_stmt|,
name|nfs_vers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsrv_null
argument_list|()
decl_stmt|,
name|nfsrv_getattr
argument_list|()
decl_stmt|,
name|nfsrv_setattr
argument_list|()
decl_stmt|,
name|nfsrv_lookup
argument_list|()
decl_stmt|,
name|nfsrv_readlink
argument_list|()
decl_stmt|,
name|nfsrv_read
argument_list|()
decl_stmt|,
name|nfsrv_write
argument_list|()
decl_stmt|,
name|nfsrv_create
argument_list|()
decl_stmt|,
name|nfsrv_remove
argument_list|()
decl_stmt|,
name|nfsrv_rename
argument_list|()
decl_stmt|,
name|nfsrv_link
argument_list|()
decl_stmt|,
name|nfsrv_symlink
argument_list|()
decl_stmt|,
name|nfsrv_mkdir
argument_list|()
decl_stmt|,
name|nfsrv_rmdir
argument_list|()
decl_stmt|,
name|nfsrv_readdir
argument_list|()
decl_stmt|,
name|nfsrv_statfs
argument_list|()
decl_stmt|,
name|nfsrv_noop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|nfsrv_procs
index|[
name|NFS_NPROCS
index|]
function_decl|)
parameter_list|()
init|=
block|{
name|nfsrv_null
operator|,
function_decl|nfsrv_getattr
operator|,
function_decl|nfsrv_setattr
operator|,
function_decl|nfsrv_noop
operator|,
function_decl|nfsrv_lookup
operator|,
function_decl|nfsrv_readlink
operator|,
function_decl|nfsrv_read
operator|,
function_decl|nfsrv_noop
operator|,
function_decl|nfsrv_write
operator|,
function_decl|nfsrv_create
operator|,
function_decl|nfsrv_remove
operator|,
function_decl|nfsrv_rename
operator|,
function_decl|nfsrv_link
operator|,
function_decl|nfsrv_symlink
operator|,
function_decl|nfsrv_mkdir
operator|,
function_decl|nfsrv_rmdir
operator|,
function_decl|nfsrv_readdir
operator|,
function_decl|nfsrv_statfs
operator|,
end_function_decl

begin_decl_stmt
unit|};
name|struct
name|nfshost
modifier|*
name|nfshosth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfsreq
name|nfsreqh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsrexmtthresh
init|=
name|NFS_FISHY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize sockets and per-host congestion for a new NFS connection.  * We do not free the sockaddr if error.  */
end_comment

begin_expr_stmt
name|nfs_connect
argument_list|(
name|nmp
argument_list|,
name|saddr
argument_list|)
specifier|register
expr|struct
name|nfsmount
operator|*
name|nmp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|saddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|srvaddrlen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|nfshost
modifier|*
name|nfshp
decl_stmt|;
name|nmp
operator|->
name|nm_so
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|socreate
argument_list|(
name|mtod
argument_list|(
name|saddr
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
operator|->
name|sa_family
argument_list|,
operator|&
name|nmp
operator|->
name|nm_so
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* Unix sockets do not provide a local bind for server reply */
if|if
condition|(
name|mtod
argument_list|(
name|saddr
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
operator|->
name|sa_family
operator|==
name|AF_UNIX
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
specifier|static
name|char
name|client
index|[]
init|=
literal|"/tmp/.nfs/nfsclient##"
decl_stmt|;
specifier|static
name|int
name|serial
decl_stmt|;
name|int
name|firstserial
decl_stmt|;
name|m
operator|=
name|m_getclr
argument_list|(
name|M_WAIT
argument_list|,
name|MT_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|client
argument_list|)
operator|+
literal|2
expr_stmt|;
name|sa
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
expr_stmt|;
name|sa
operator|->
name|sa_family
operator|=
name|AF_UNIX
expr_stmt|;
ifdef|#
directive|ifdef
name|MSG_TRUNC
comment|/* Have sa_len to set? */
name|sa
operator|->
name|sa_len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
name|client
argument_list|,
name|sa
operator|->
name|sa_data
argument_list|,
sizeof|sizeof
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|firstserial
operator|=
name|serial
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|++
name|serial
operator|>=
literal|100
condition|)
name|serial
operator|=
literal|0
expr_stmt|;
name|sa
operator|->
name|sa_data
index|[
literal|19
index|]
operator|=
operator|(
name|serial
operator|/
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|sa
operator|->
name|sa_data
index|[
literal|20
index|]
operator|=
operator|(
name|serial
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|error
operator|=
name|sobind
argument_list|(
name|nmp
operator|->
name|nm_so
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstserial
operator|==
name|serial
condition|)
break|break;
block|}
do|while
condition|(
name|error
operator|==
name|EADDRINUSE
condition|)
do|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|error
operator|=
name|soconnect
argument_list|(
name|nmp
operator|->
name|nm_so
argument_list|,
name|saddr
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
name|soreserve
argument_list|(
name|nmp
operator|->
name|nm_so
argument_list|,
comment|/* get space ! */
name|nmp
operator|->
name|nm_wsize
operator|+
literal|1024
argument_list|,
comment|/* one out */
operator|(
name|nmp
operator|->
name|nm_rsize
operator|+
literal|1024
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* four in */
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Search mount list for existing server entry. 	 * 	 * Note, even though we have a sockaddr, it is not quite reliable 	 * enough to bcmp against. For instance, a sockaddr_in has a  	 * sin_zero field which is not reliably zeroed by user code (e.g. 	 * mount). So what we do as an attempt at transport independence 	 * is to get the peeraddr of our connected socket into a zeroed 	 * sockaddr. Then we cache that and compare against it. This is 	 * not exactly perfect. However it is not critical that it be, if 	 * we cannot match the sockaddr we will simply allocate a new nfshp 	 * per mount, which will disable the per-host congestion but 	 * everything else will work as normal. 	 */
name|m
operator|=
name|m_getclr
argument_list|(
name|M_WAIT
argument_list|,
name|MT_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
operator|(
operator|*
operator|(
name|nmp
operator|->
name|nm_so
operator|->
name|so_proto
operator|->
name|pr_usrreq
operator|)
operator|)
operator|(
name|nmp
operator|->
name|nm_so
operator|,
name|PRU_PEERADDR
operator|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
operator|,
name|m
operator|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|saddr
argument_list|)
expr_stmt|;
name|saddr
operator|=
name|m
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|srvaddrlen
operator|=
name|saddr
operator|->
name|m_len
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|nfshp
operator|=
name|nfshosth
init|;
name|nfshp
condition|;
name|nfshp
operator|=
name|nfshp
operator|->
name|nh_next
control|)
block|{
if|if
condition|(
name|srvaddrlen
operator|!=
name|nfshp
operator|->
name|nh_salen
condition|)
continue|continue;
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|mtod
argument_list|(
name|saddr
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|nfshp
operator|->
name|nh_sockaddr
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|srvaddrlen
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|nfshp
condition|)
comment|/* Have an existing mount host */
name|m_freem
argument_list|(
name|saddr
argument_list|)
expr_stmt|;
else|else
block|{
name|MALLOC
argument_list|(
name|nfshp
argument_list|,
expr|struct
name|nfshost
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|nfshp
argument_list|,
name|M_NFSMNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfshp
argument_list|,
sizeof|sizeof
expr|*
name|nfshp
argument_list|)
expr_stmt|;
name|nfshp
operator|->
name|nh_sockaddr
operator|=
name|saddr
expr_stmt|;
name|nfshp
operator|->
name|nh_salen
operator|=
name|srvaddrlen
expr_stmt|;
comment|/* Initialize other non-zero congestion variables */
name|nfshp
operator|->
name|nh_currto
operator|=
name|NFS_TIMEO
expr_stmt|;
name|nfshp
operator|->
name|nh_window
operator|=
literal|1
expr_stmt|;
comment|/* Initial send window */
name|nfshp
operator|->
name|nh_ssthresh
operator|=
name|NFS_MAXWINDOW
expr_stmt|;
comment|/* Slowstart threshold */
if|if
condition|(
name|nfshosth
condition|)
name|nfshosth
operator|->
name|nh_prev
operator|=
name|nfshp
expr_stmt|;
comment|/* Chain in */
name|nfshp
operator|->
name|nh_next
operator|=
name|nfshosth
expr_stmt|;
name|nfshosth
operator|=
name|nfshp
expr_stmt|;
block|}
name|nfshp
operator|->
name|nh_refcnt
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_hostinfo
operator|=
name|nfshp
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_rto
operator|==
name|NFS_TIMEO
condition|)
block|{
name|nmp
operator|->
name|nm_rto
operator|=
name|nfshp
operator|->
name|nh_currto
expr_stmt|;
name|nmp
operator|->
name|nm_rttvar
operator|=
name|nmp
operator|->
name|nm_rto
operator|<<
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|nmp
operator|->
name|nm_so
condition|)
operator|(
name|void
operator|)
name|soclose
argument_list|(
name|nmp
operator|->
name|nm_so
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_so
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * NFS disconnect. Clean up and unlink.  */
end_comment

begin_expr_stmt
name|nfs_disconnect
argument_list|(
name|nmp
argument_list|)
specifier|register
expr|struct
name|nfsmount
operator|*
name|nmp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|nfshost
modifier|*
name|nfshp
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_so
condition|)
name|soclose
argument_list|(
name|nmp
operator|->
name|nm_so
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_so
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nfshp
operator|=
name|nmp
operator|->
name|nm_hostinfo
condition|)
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
if|if
condition|(
operator|--
name|nfshp
operator|->
name|nh_refcnt
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|nfshp
operator|->
name|nh_next
condition|)
name|nfshp
operator|->
name|nh_next
operator|->
name|nh_prev
operator|=
name|nfshp
operator|->
name|nh_prev
expr_stmt|;
if|if
condition|(
name|nfshp
operator|->
name|nh_prev
condition|)
name|nfshp
operator|->
name|nh_prev
operator|->
name|nh_next
operator|=
name|nfshp
operator|->
name|nh_next
expr_stmt|;
else|else
name|nfshosth
operator|=
name|nfshp
operator|->
name|nh_next
expr_stmt|;
comment|/* If unix family, remove the nfsclient from /tmp */
if|if
condition|(
name|mtod
argument_list|(
name|nfshp
operator|->
name|nh_sockaddr
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
operator|->
name|sa_family
operator|==
name|AF_UNIX
condition|)
block|{
comment|/* Lookup sa_data, do VOP_REMOVE... */
block|}
name|m_freem
argument_list|(
name|nfshp
operator|->
name|nh_sockaddr
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|nfshp
argument_list|,
name|M_NFSMNT
argument_list|)
expr_stmt|;
block|}
name|nmp
operator|->
name|nm_hostinfo
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * This is a stripped down non-interruptible version of sosend().  */
end_comment

begin_expr_stmt
name|nfs_send
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|top
argument_list|,
name|flags
argument_list|,
name|siz
argument_list|)
specifier|register
expr|struct
name|socket
operator|*
name|so
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|siz
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|MGETHDR
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|siz
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|nfs_sblock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|nfs_sockerr
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|<
name|siz
condition|)
block|{
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|nfs_sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreq
call|)
argument_list|(
name|so
argument_list|,
name|PRU_SEND
argument_list|,
name|top
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|nam
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * This is a stripped down datagram specific version of soreceive()  */
end_comment

begin_expr_stmt
name|nfs_dgreceive
argument_list|(
name|so
argument_list|,
name|msk
argument_list|,
name|mtch
argument_list|,
name|aname
argument_list|,
name|mp
argument_list|)
specifier|register
expr|struct
name|socket
operator|*
name|so
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_long
name|msk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|mtch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|aname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nextrecord
decl_stmt|;
if|if
condition|(
name|aname
condition|)
operator|*
name|aname
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sblock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|nfs_sockerr
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs_dgreceive 1"
argument_list|)
expr_stmt|;
name|nextrecord
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
comment|/* Save sender's address */
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_SONAME
condition|)
name|panic
argument_list|(
literal|"nfs_dgreceive 1a"
argument_list|)
expr_stmt|;
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|aname
condition|)
block|{
operator|*
name|aname
operator|=
name|m
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
block|}
else|else
block|{
name|MFREE
argument_list|(
name|m
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
block|}
comment|/* Drop control mbuf's */
if|if
condition|(
name|m
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_RIGHTS
condition|)
name|panic
argument_list|(
literal|"nfs_dgreceive 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_CONTROL
condition|)
block|{
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MFREE
argument_list|(
name|m
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
block|}
comment|/* Dequeue packet from sockbuf */
operator|*
name|mp
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_DATA
operator|&&
name|m
operator|->
name|m_type
operator|!=
name|MT_HEADER
condition|)
name|panic
argument_list|(
literal|"nfs_dgreceive 3"
argument_list|)
expr_stmt|;
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|nextrecord
expr_stmt|;
comment|/* Return */
break|break;
block|}
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|rpc_replyhead
block|{
name|u_long
name|r_xid
decl_stmt|;
name|u_long
name|r_rep
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Implement NFS client side datagram receive.  * We depend on the way that records are added to the sockbuf  * by sbappend*.  In particular, each record (mbufs linked through m_next)  * must begin with an address, followed by optional MT_CONTROL mbuf  * and then zero or more mbufs of data.  * We must search through the list of received datagrams matching them  * with outstanding requests using the xid, until ours is found.  */
end_comment

begin_expr_stmt
name|nfs_dgreply
argument_list|(
name|so
argument_list|,
name|mntp
argument_list|,
name|myrep
argument_list|)
specifier|register
expr|struct
name|socket
operator|*
name|so
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|nfsmount
modifier|*
name|mntp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfsreq
modifier|*
name|myrep
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|int
name|error
init|=
literal|0
decl_stmt|,
name|s
decl_stmt|;
name|int
name|logged
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nextrecord
decl_stmt|;
name|struct
name|rpc_replyhead
name|replyh
decl_stmt|;
name|restart
label|:
name|nfs_sblock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* Already received and queued for us, bye bye */
if|if
condition|(
name|myrep
operator|->
name|r_mrep
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* If we have run out of retries (hard mounts have bogus count) */
if|if
condition|(
name|myrep
operator|->
name|r_rexmit
operator|>
name|myrep
operator|->
name|r_retry
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
name|nfsstats
operator|.
name|rpctimeouts
operator|++
expr_stmt|;
name|giveup
label|:
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
block|{
name|myrep
operator|->
name|r_flags
operator|&=
operator|~
name|R_TIMING
expr_stmt|;
name|mntp
operator|->
name|nm_rtt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|myrep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
operator|--
name|mntp
operator|->
name|nm_hostinfo
operator|->
name|nh_sent
expr_stmt|;
comment|/* If count now 0, want to initiate new req */
block|}
goto|goto
name|release
goto|;
block|}
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
condition|)
name|panic
argument_list|(
literal|"nfs_soreply 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|nfs_sockerr
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
goto|goto
name|giveup
goto|;
block|}
comment|/* Allow signals to interrupt request? (nfs_timer wakes up) */
if|if
condition|(
operator|(
name|mntp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
operator|)
operator|&&
name|u
operator|.
name|u_procp
operator|->
name|p_sig
operator|&
operator|~
name|u
operator|.
name|u_procp
operator|->
name|p_sigmask
condition|)
block|{
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|giveup
goto|;
block|}
if|if
condition|(
name|mntp
operator|->
name|nm_rexmit
operator|>=
name|nfsrexmtthresh
operator|&&
name|logged
operator|++
operator|==
literal|0
condition|)
name|uprintf
argument_list|(
literal|"NFS server %s not responding, retrying\n"
argument_list|,
name|mntp
operator|->
name|nm_host
argument_list|)
expr_stmt|;
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|nfs_sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Take off the address, check for rights and ditch any control 	 * mbufs. 	 */
name|nextrecord
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_SONAME
condition|)
name|panic
argument_list|(
literal|"nfs reply SONAME"
argument_list|)
expr_stmt|;
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MFREE
argument_list|(
name|m
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_RIGHTS
condition|)
name|panic
argument_list|(
literal|"nfs reply RIGHTS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_CONTROL
condition|)
block|{
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MFREE
argument_list|(
name|m
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|m
operator|->
name|m_nextpkt
operator|=
name|nextrecord
expr_stmt|;
block|}
else|else
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|nextrecord
expr_stmt|;
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Get the xid and check that it is an rpc reply 	 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
name|replyh
condition|)
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|replyh
argument_list|,
sizeof|sizeof
name|replyh
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|mbuf
modifier|*
name|mp
init|=
name|m
decl_stmt|;
name|caddr_t
name|cp
init|=
operator|(
name|caddr_t
operator|)
operator|&
name|replyh
decl_stmt|;
name|int
name|cnt
init|=
sizeof|sizeof
name|replyh
decl_stmt|;
do|do
block|{
if|if
condition|(
name|mp
operator|->
name|m_len
operator|>
literal|0
condition|)
block|{
name|int
name|xfer
init|=
operator|(
name|mp
operator|->
name|m_len
operator|>=
name|cnt
operator|)
condition|?
name|cnt
else|:
name|mp
operator|->
name|m_len
decl_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|cp
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|cnt
operator|-=
name|xfer
expr_stmt|;
name|cp
operator|+=
name|xfer
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|mp
operator|&&
name|cnt
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
comment|/* Insufficient length */
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
block|}
if|if
condition|(
name|replyh
operator|.
name|r_rep
operator|!=
name|rpc_reply
condition|)
block|{
comment|/* Not a reply */
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
comment|/* 	 * Loop through the request list to match up the reply 	 * If no match, just drop the datagram 	 */
if|if
condition|(
name|rep
operator|=
name|nfsreqh
operator|.
name|r_next
condition|)
block|{
while|while
condition|(
name|rep
operator|!=
operator|&
name|nfsreqh
condition|)
block|{
comment|/* The socket, being connected, will only queue matches */
if|if
condition|(
name|replyh
operator|.
name|r_xid
operator|==
name|rep
operator|->
name|r_xid
operator|&&
name|so
operator|==
name|rep
operator|->
name|r_mntp
operator|->
name|nm_so
condition|)
block|{
comment|/* Found it.. */
if|if
condition|(
name|rep
operator|->
name|r_mrep
condition|)
comment|/* Already there - duplicate */
break|break;
name|rep
operator|->
name|r_mrep
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_DATA
operator|&&
name|m
operator|->
name|m_type
operator|!=
name|MT_HEADER
condition|)
name|panic
argument_list|(
literal|"nfs_soreply 3"
argument_list|)
expr_stmt|;
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|nextrecord
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
block|{
name|nfs_updatetimer
argument_list|(
name|mntp
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_TIMING
expr_stmt|;
name|mntp
operator|->
name|nm_rtt
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* re-arm timer */
block|}
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
operator|--
name|mntp
operator|->
name|nm_hostinfo
operator|->
name|nh_sent
expr_stmt|;
comment|/* If count now 0, want to initiate new req */
block|}
if|if
condition|(
name|rep
operator|==
name|myrep
condition|)
block|{
comment|/* This is success */
if|if
condition|(
name|logged
condition|)
name|uprintf
argument_list|(
literal|"NFS server %s responded\n"
argument_list|,
name|mntp
operator|->
name|nm_host
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* Else wake up other sleeper and wait for next */
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|rep
operator|=
name|rep
operator|->
name|r_next
expr_stmt|;
block|}
block|}
comment|/* If not matched to request, drop it */
name|nfsstats
operator|.
name|rpcunexpected
operator|++
expr_stmt|;
name|dropit
label|:
name|sbdroprecord
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
name|release
label|:
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs_request - goes something like this  *	- fill in request struct  *	- links it into list  *	- calls nfs_sosend() for first transmit  *	- calls nfs_soreceive() to get reply  *	- break down rpc header and return with nfs reply pointed to  *	  by mrep or error  * nb: always frees up mreq mbuf list  */
end_comment

begin_macro
name|nfs_request
argument_list|(
argument|vp
argument_list|,
argument|mreq
argument_list|,
argument|xid
argument_list|,
argument|idem
argument_list|,
argument|mp
argument_list|,
argument|mrp
argument_list|,
argument|mdp
argument_list|,
argument|dposp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|xid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|idem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mrp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|dposp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mrep
decl_stmt|;
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|mntp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|reph
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
name|int
name|t1
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mntp
operator|=
name|vfs_to_nfs
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|m
operator|=
name|mreq
expr_stmt|;
name|MALLOC
argument_list|(
name|rep
argument_list|,
expr|struct
name|nfsreq
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsreq
argument_list|)
argument_list|,
name|M_NFSREQ
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_xid
operator|=
name|xid
expr_stmt|;
name|rep
operator|->
name|r_mntp
operator|=
name|mntp
expr_stmt|;
name|rep
operator|->
name|r_vp
operator|=
name|vp
expr_stmt|;
if|if
condition|(
name|mntp
operator|->
name|nm_flag
operator|&
name|NFSMNT_SOFT
condition|)
name|rep
operator|->
name|r_retry
operator|=
name|mntp
operator|->
name|nm_retry
expr_stmt|;
else|else
name|rep
operator|->
name|r_retry
operator|=
name|NFS_MAXREXMIT
operator|+
literal|1
expr_stmt|;
comment|/* past clip limit */
name|rep
operator|->
name|r_flags
operator|=
name|rep
operator|->
name|r_rexmit
operator|=
literal|0
expr_stmt|;
comment|/* Idempotency: add N * MINTIMEO to requests if not, else use 0 */
name|rep
operator|->
name|r_timer
operator|=
name|rep
operator|->
name|r_timerinit
operator|=
operator|-
operator|(
name|idem
operator|*
name|NFS_MINTIMEO
operator|)
expr_stmt|;
name|rep
operator|->
name|r_mrep
operator|=
name|NULL
expr_stmt|;
name|rep
operator|->
name|r_mreq
operator|=
name|m
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|rep
operator|->
name|r_msiz
operator|=
name|len
expr_stmt|;
comment|/* 	 * Do the client side RPC. 	 */
name|nfsstats
operator|.
name|rpcrequests
operator|++
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* Chain request into list of outstanding requests. Be sure 	 * to put it LAST so timer finds oldest requests first. */
name|reph
operator|=
operator|&
name|nfsreqh
expr_stmt|;
if|if
condition|(
name|reph
operator|->
name|r_prev
operator|==
name|NULL
condition|)
block|{
name|reph
operator|->
name|r_next
operator|=
name|rep
expr_stmt|;
name|rep
operator|->
name|r_prev
operator|=
name|reph
expr_stmt|;
block|}
else|else
block|{
name|reph
operator|->
name|r_prev
operator|->
name|r_next
operator|=
name|rep
expr_stmt|;
name|rep
operator|->
name|r_prev
operator|=
name|reph
operator|->
name|r_prev
expr_stmt|;
block|}
name|reph
operator|->
name|r_prev
operator|=
name|rep
expr_stmt|;
name|rep
operator|->
name|r_next
operator|=
name|reph
expr_stmt|;
comment|/* 	 * If backing off another request or avoiding congestion, don't 	 * send this one now but let timer do it. If not timing a request, 	 * do it now. 	 */
if|if
condition|(
name|mntp
operator|->
name|nm_hostinfo
operator|->
name|nh_sent
operator|>
literal|0
operator|&&
operator|(
name|mntp
operator|->
name|nm_hostinfo
operator|->
name|nh_currexmit
operator|!=
literal|0
operator|||
name|mntp
operator|->
name|nm_hostinfo
operator|->
name|nh_sent
operator|>=
name|mntp
operator|->
name|nm_hostinfo
operator|->
name|nh_window
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|skipsend
goto|;
block|}
operator|++
name|mntp
operator|->
name|nm_hostinfo
operator|->
name|nh_sent
expr_stmt|;
comment|/* Inconsistent if can't NFSMCOPY */
name|rep
operator|->
name|r_flags
operator||=
name|R_SENT
expr_stmt|;
comment|/* But not a catastrophe */
if|if
condition|(
name|mntp
operator|->
name|nm_rtt
operator|==
operator|-
literal|1
condition|)
block|{
name|mntp
operator|->
name|nm_rtt
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_TIMING
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * If we can get a packet to send, send it off... 	 * otherwise the timer will retransmit later 	 */
name|m
operator|=
name|NFSMCOPY
argument_list|(
name|mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|nfs_send
argument_list|(
name|mntp
operator|->
name|nm_so
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the reply from our send or the timer's. 	 */
name|skipsend
label|:
name|error
operator|=
name|nfs_dgreply
argument_list|(
name|mntp
operator|->
name|nm_so
argument_list|,
name|mntp
argument_list|,
name|rep
argument_list|)
expr_stmt|;
comment|/* 	 * RPC done, unlink the request. 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|rep
operator|->
name|r_prev
operator|->
name|r_next
operator|=
name|rep
operator|->
name|r_next
expr_stmt|;
name|rep
operator|->
name|r_next
operator|->
name|r_prev
operator|=
name|rep
operator|->
name|r_prev
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|mrep
operator|=
name|md
operator|=
name|rep
operator|->
name|r_mrep
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * break down the rpc header and check if ok 	 */
name|dpos
operator|=
name|mtod
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|rpc_msgdenied
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|rpc_mismatch
condition|)
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
else|else
name|error
operator|=
name|EACCES
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * skip over the auth_verf, someday we may want to cache auth_short's 	 * for nfs_reqhead(), but for now just dump it 	 */
if|if
condition|(
operator|*
operator|++
name|p
operator|!=
literal|0
condition|)
block|{
name|len
operator|=
name|nfsm_rndup
argument_list|(
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_adv
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* 0 == ok */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get a request for the server main loop  * - receive a request via. nfs_soreceive()  * - verify it  * - fill in the cred struct.  */
end_comment

begin_macro
name|nfs_getreq
argument_list|(
argument|so
argument_list|,
argument|prog
argument_list|,
argument|vers
argument_list|,
argument|maxproc
argument_list|,
argument|nam
argument_list|,
argument|mrp
argument_list|,
argument|mdp
argument_list|,
argument|dposp
argument_list|,
argument|retxid
argument_list|,
argument|proc
argument_list|,
argument|cr
argument_list|,
argument|msk
argument_list|,
argument|mtch
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|prog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|vers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mrp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|dposp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
modifier|*
name|retxid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
modifier|*
name|proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|msk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|mtch
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|nfs_dgreceive
argument_list|(
name|so
argument_list|,
name|msk
argument_list|,
name|mtch
argument_list|,
name|nam
argument_list|,
operator|&
name|mrep
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|md
operator|=
name|mrep
expr_stmt|;
name|dpos
operator|=
name|mtod
argument_list|(
name|mrep
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|10
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|retxid
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|rpc_call
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERPCMISMATCH
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|rpc_vers
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERPCMISMATCH
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|prog
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROGUNAVAIL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|vers
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROGMISMATCH
operator|)
return|;
block|}
operator|*
name|proc
operator|=
name|fxdr_unsigned
argument_list|(
name|u_long
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|proc
operator|==
name|NFSPROC_NULL
condition|)
block|{
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|proc
operator|>
name|maxproc
operator|||
operator|*
name|p
operator|++
operator|!=
name|rpc_auth_unix
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROCUNAVAIL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|++
name|p
argument_list|)
expr_stmt|;
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_uid
operator|=
name|fxdr_unsigned
argument_list|(
name|uid_t
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_gid
operator|=
name|fxdr_unsigned
argument_list|(
name|gid_t
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|10
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
operator|(
name|len
operator|+
literal|2
operator|)
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|++
control|)
name|cr
operator|->
name|cr_groups
index|[
name|i
index|]
operator|=
name|fxdr_unsigned
argument_list|(
name|gid_t
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_ngroups
operator|=
name|len
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Do we have any use for the verifier. 	 * According to the "Remote Procedure Call Protocol Spec." it 	 * should be AUTH_NULL, but some clients make it AUTH_UNIX? 	 * For now, just skip over it 	 */
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|++
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Generate the rpc reply header  * siz arg. is used to decide if adding a cluster is worthwhile  */
end_comment

begin_macro
name|nfs_rephead
argument_list|(
argument|siz
argument_list|,
argument|retxid
argument_list|,
argument|err
argument_list|,
argument|mrq
argument_list|,
argument|mbp
argument_list|,
argument|bposp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|siz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|retxid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|err
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mrq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|bposp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|NFSMGETHDR
argument_list|(
name|mreq
argument_list|)
expr_stmt|;
name|mb
operator|=
name|mreq
expr_stmt|;
if|if
condition|(
operator|(
name|siz
operator|+
name|RPC_REPLYSIZ
operator|)
operator|>
name|MHLEN
condition|)
name|NFSMCLGET
argument_list|(
name|mreq
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|mreq
argument_list|,
name|u_long
operator|*
argument_list|)
expr_stmt|;
name|mreq
operator|->
name|m_len
operator|=
literal|6
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|bpos
operator|=
operator|(
operator|(
name|caddr_t
operator|)
name|p
operator|)
operator|+
name|mreq
operator|->
name|m_len
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|retxid
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rpc_reply
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERPCMISMATCH
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|rpc_msgdenied
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rpc_mismatch
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|rpc_msgaccepted
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|EPROGUNAVAIL
case|:
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_PROGUNAVAIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPROGMISMATCH
case|:
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_PROGMISMATCH
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* someday 3 */
break|break;
case|case
name|EPROCUNAVAIL
case|:
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_PROCUNAVAIL
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|VNOVAL
condition|)
block|{
name|nfsm_build
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
empty_stmt|;
block|}
operator|*
name|mrq
operator|=
name|mreq
expr_stmt|;
operator|*
name|mbp
operator|=
name|mb
expr_stmt|;
operator|*
name|bposp
operator|=
name|bpos
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|VNOVAL
condition|)
name|nfsstats
operator|.
name|srvrpc_errs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Nfs timer routine  * Scan the nfsreq list and retranmit any requests that have timed out  * To avoid retransmission attempts on STREAM sockets (in the future) make  * sure to set the r_retry field to 0 (implies nm_retry == 0).  */
end_comment

begin_macro
name|nfs_timer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
specifier|register
name|struct
name|nfsmount
modifier|*
name|mntp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|rep
operator|=
name|nfsreqh
operator|.
name|r_next
expr_stmt|;
if|if
condition|(
name|rep
condition|)
for|for
control|(
init|;
name|rep
operator|!=
operator|&
name|nfsreqh
condition|;
name|rep
operator|=
name|rep
operator|->
name|r_next
control|)
block|{
name|mntp
operator|=
name|rep
operator|->
name|r_mntp
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
comment|/* update rtt in mount */
name|mntp
operator|->
name|nm_rtt
operator|++
expr_stmt|;
comment|/* If not timed out or reply already received, skip */
if|if
condition|(
operator|++
name|rep
operator|->
name|r_timer
operator|<
name|mntp
operator|->
name|nm_rto
operator|||
name|rep
operator|->
name|r_mrep
condition|)
continue|continue;
comment|/* Do backoff and save new timeout in mount */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
block|{
name|nfs_backofftimer
argument_list|(
name|mntp
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_TIMING
expr_stmt|;
name|mntp
operator|->
name|nm_rtt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
operator|--
name|mntp
operator|->
name|nm_hostinfo
operator|->
name|nh_sent
expr_stmt|;
block|}
comment|/* Check state of socket, cf nfs_send */
name|so
operator|=
name|mntp
operator|->
name|nm_so
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|nfs_sockerr
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|wakeup
goto|;
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|<
name|rep
operator|->
name|r_msiz
condition|)
goto|goto
name|wakeup
goto|;
comment|/* Check for too many retries, cf nfs_dgreply */
if|if
condition|(
operator|++
name|rep
operator|->
name|r_rexmit
operator|>
name|NFS_MAXREXMIT
condition|)
comment|/* clip */
name|rep
operator|->
name|r_rexmit
operator|=
name|NFS_MAXREXMIT
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_rexmit
operator|>
name|rep
operator|->
name|r_retry
condition|)
comment|/* too many */
goto|goto
name|wakeup
goto|;
comment|/* Check for congestion control, cf nfs_request */
if|if
condition|(
name|mntp
operator|->
name|nm_hostinfo
operator|->
name|nh_sent
operator|>=
name|mntp
operator|->
name|nm_hostinfo
operator|->
name|nh_window
condition|)
goto|goto
name|wakeup
goto|;
comment|/* Send it! */
name|m
operator|=
name|NFSMCOPY
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|wakeup
goto|;
name|nfsstats
operator|.
name|rpcretries
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MGETHDR
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|rep
operator|->
name|r_msiz
expr_stmt|;
endif|#
directive|endif
call|(
name|void
call|)
argument_list|(
operator|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreq
argument_list|)
argument_list|(
name|so
argument_list|,
name|PRU_SEND
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* We need to time the request even though we're 		 * retransmitting, in order to maintain backoff. */
name|mntp
operator|->
name|nm_rtt
operator|=
literal|0
expr_stmt|;
operator|++
name|mntp
operator|->
name|nm_hostinfo
operator|->
name|nh_sent
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
operator|(
name|R_SENT
operator||
name|R_TIMING
operator|)
expr_stmt|;
name|rep
operator|->
name|r_timer
operator|=
name|rep
operator|->
name|r_timerinit
expr_stmt|;
name|wakeup
label|:
comment|/* If error or interruptible mount, give user a look */
if|if
condition|(
name|error
operator|||
operator|(
name|mntp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
operator|)
condition|)
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|nfs_timer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
operator|/
name|NFS_HZ
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * NFS timer update and backoff. The "Jacobson/Karels/Karn" scheme is  * used here. The timer state is held in the nfsmount structure and  * a single request is used to clock the response. When successful  * the rtt smoothing in nfs_updatetimer is used, when failed the backoff  * is done by nfs_backofftimer. We also log failure messages in these  * routines.  *  * Congestion variables are held in the nfshost structure which  * is referenced by nfsmounts and shared per-server. This separation  * makes it possible to do per-mount timing which allows varying disk  * access times to be dealt with, while preserving a network oriented  * congestion control scheme.  *  * The windowing implements the Jacobson/Karels slowstart algorithm  * with adjusted scaling factors. We start with one request, then send  * 4 more after each success until the ssthresh limit is reached, then  * we increment at a rate proportional to the window. On failure, we  * remember 3/4 the current window and clamp the send limit to 1. Note  * ICMP source quench is not reflected in so->so_error so we ignore that  * for now.  *  * NFS behaves much more like a transport protocol with these changes,  * shedding the teenage pedal-to-the-metal tendencies of "other"  * implementations.  *  * Timers and congestion avoidance by Tom Talpey, Open Software Foundation.  */
end_comment

begin_comment
comment|/*  * The TCP algorithm was not forgiving enough. Because the NFS server  * responds only after performing lookups/diskio/etc, we have to be  * more prepared to accept a spiky variance. The TCP algorithm is:  * TCP_RTO(mntp) ((((mntp)->nm_srtt>> 2) + (mntp)->nm_rttvar)>> 1)  */
end_comment

begin_define
define|#
directive|define
name|NFS_RTO
parameter_list|(
name|mntp
parameter_list|)
value|(((mntp)->nm_srtt>> 3) + (mntp)->nm_rttvar)
end_define

begin_expr_stmt
name|nfs_updatetimer
argument_list|(
name|mntp
argument_list|)
specifier|register
expr|struct
name|nfsmount
operator|*
name|mntp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|nfshost
modifier|*
name|nfshp
init|=
name|mntp
operator|->
name|nm_hostinfo
decl_stmt|;
comment|/* If retransmitted, clear and return */
if|if
condition|(
name|mntp
operator|->
name|nm_rexmit
operator|||
name|nfshp
operator|->
name|nh_currexmit
condition|)
block|{
if|if
condition|(
name|nfshp
operator|->
name|nh_currexmit
operator|>=
name|nfsrexmtthresh
condition|)
name|nfs_log
argument_list|(
literal|"NFS server %s OK\n"
argument_list|,
name|mntp
operator|->
name|nm_host
argument_list|)
expr_stmt|;
name|mntp
operator|->
name|nm_rexmit
operator|=
name|nfshp
operator|->
name|nh_currexmit
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* If have a measurement, do smoothing */
if|if
condition|(
name|mntp
operator|->
name|nm_srtt
condition|)
block|{
specifier|register
name|short
name|delta
decl_stmt|;
name|delta
operator|=
name|mntp
operator|->
name|nm_rtt
operator|-
operator|(
name|mntp
operator|->
name|nm_srtt
operator|>>
literal|3
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mntp
operator|->
name|nm_srtt
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|mntp
operator|->
name|nm_srtt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
name|delta
operator|-=
operator|(
name|mntp
operator|->
name|nm_rttvar
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mntp
operator|->
name|nm_rttvar
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|mntp
operator|->
name|nm_rttvar
operator|=
literal|1
expr_stmt|;
comment|/* Else initialize */
block|}
else|else
block|{
name|mntp
operator|->
name|nm_rttvar
operator|=
name|mntp
operator|->
name|nm_rtt
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|mntp
operator|->
name|nm_rttvar
operator|==
literal|0
condition|)
name|mntp
operator|->
name|nm_rttvar
operator|=
literal|2
expr_stmt|;
name|mntp
operator|->
name|nm_srtt
operator|=
name|mntp
operator|->
name|nm_rttvar
operator|<<
literal|2
expr_stmt|;
block|}
comment|/* Compute new Retransmission TimeOut and clip */
name|mntp
operator|->
name|nm_rto
operator|=
name|NFS_RTO
argument_list|(
name|mntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mntp
operator|->
name|nm_rto
operator|<
name|NFS_MINTIMEO
condition|)
name|mntp
operator|->
name|nm_rto
operator|=
name|NFS_MINTIMEO
expr_stmt|;
elseif|else
if|if
condition|(
name|mntp
operator|->
name|nm_rto
operator|>
name|NFS_MAXTIMEO
condition|)
name|mntp
operator|->
name|nm_rto
operator|=
name|NFS_MAXTIMEO
expr_stmt|;
name|nfshp
operator|->
name|nh_currto
operator|=
name|mntp
operator|->
name|nm_rto
expr_stmt|;
comment|/* Update window estimate */
if|if
condition|(
name|nfshp
operator|->
name|nh_window
operator|<
name|nfshp
operator|->
name|nh_ssthresh
condition|)
comment|/* quickly */
name|nfshp
operator|->
name|nh_window
operator|+=
literal|4
expr_stmt|;
else|else
block|{
comment|/* slowly */
specifier|register
name|long
name|incr
init|=
operator|++
name|nfshp
operator|->
name|nh_winext
decl_stmt|;
name|incr
operator|=
operator|(
name|incr
operator|*
name|incr
operator|)
operator|/
name|nfshp
operator|->
name|nh_window
expr_stmt|;
if|if
condition|(
name|incr
operator|>
literal|0
condition|)
block|{
name|nfshp
operator|->
name|nh_winext
operator|=
literal|0
expr_stmt|;
operator|++
name|nfshp
operator|->
name|nh_window
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nfshp
operator|->
name|nh_window
operator|>
name|NFS_MAXWINDOW
condition|)
name|nfshp
operator|->
name|nh_window
operator|=
name|NFS_MAXWINDOW
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|nfs_backofftimer
argument_list|(
name|mntp
argument_list|)
specifier|register
expr|struct
name|nfsmount
operator|*
name|mntp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|nfshost
modifier|*
name|nfshp
init|=
name|mntp
operator|->
name|nm_hostinfo
decl_stmt|;
specifier|register
name|unsigned
name|long
name|newrto
decl_stmt|;
comment|/* Clip shift count */
if|if
condition|(
operator|++
name|mntp
operator|->
name|nm_rexmit
operator|>
literal|8
operator|*
sizeof|sizeof
name|mntp
operator|->
name|nm_rto
condition|)
name|mntp
operator|->
name|nm_rexmit
operator|=
literal|8
operator|*
sizeof|sizeof
name|mntp
operator|->
name|nm_rto
expr_stmt|;
comment|/* Back off RTO exponentially */
name|newrto
operator|=
name|NFS_RTO
argument_list|(
name|mntp
argument_list|)
expr_stmt|;
name|newrto
operator|<<=
operator|(
name|mntp
operator|->
name|nm_rexmit
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|newrto
operator|==
literal|0
operator|||
name|newrto
operator|>
name|NFS_MAXTIMEO
condition|)
name|newrto
operator|=
name|NFS_MAXTIMEO
expr_stmt|;
name|mntp
operator|->
name|nm_rto
operator|=
name|nfshp
operator|->
name|nh_currto
operator|=
name|newrto
expr_stmt|;
comment|/* If too many retries, message, assume a bogus RTT and re-measure */
if|if
condition|(
name|nfshp
operator|->
name|nh_currexmit
operator|<
name|mntp
operator|->
name|nm_rexmit
condition|)
block|{
name|nfshp
operator|->
name|nh_currexmit
operator|=
name|mntp
operator|->
name|nm_rexmit
expr_stmt|;
if|if
condition|(
name|nfshp
operator|->
name|nh_currexmit
operator|>=
name|nfsrexmtthresh
condition|)
block|{
if|if
condition|(
name|nfshp
operator|->
name|nh_currexmit
operator|==
name|nfsrexmtthresh
condition|)
block|{
name|nfs_log
argument_list|(
literal|"NFS server %s not responding\n"
argument_list|,
name|mntp
operator|->
name|nm_host
argument_list|)
expr_stmt|;
name|mntp
operator|->
name|nm_rttvar
operator|+=
operator|(
name|mntp
operator|->
name|nm_srtt
operator|>>
literal|2
operator|)
expr_stmt|;
name|mntp
operator|->
name|nm_srtt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The routing invalidation should be a usrreq PRU */
if|if
condition|(
name|mtod
argument_list|(
name|nfshp
operator|->
name|nh_sockaddr
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|in_losing
argument_list|(
name|mntp
operator|->
name|nm_so
operator|->
name|so_pcb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Close down window but remember this point (3/4 current) for later */
name|nfshp
operator|->
name|nh_ssthresh
operator|=
operator|(
operator|(
name|nfshp
operator|->
name|nh_window
operator|<<
literal|1
operator|)
operator|+
name|nfshp
operator|->
name|nh_window
operator|)
operator|>>
literal|2
expr_stmt|;
name|nfshp
operator|->
name|nh_window
operator|=
literal|1
expr_stmt|;
name|nfshp
operator|->
name|nh_winext
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Not all errors are fatal. The closed checks deal  * with errors a little strangely.  */
end_comment

begin_macro
name|nfs_sockerr
argument_list|(
argument|so
argument_list|,
argument|sending
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sending
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sending
operator|&&
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTSENDMORE
operator|)
condition|)
block|{
name|so
operator|->
name|so_error
operator|=
name|EPIPE
expr_stmt|;
return|return
operator|(
name|EPIPE
operator|)
return|;
block|}
switch|switch
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
comment|/* inhibit certain errors */
case|case
name|ENETDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|EHOSTUNREACH
case|:
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
case|case
literal|0
case|:
break|break;
default|default:
comment|/* return all others */
name|printf
argument_list|(
literal|"nfs_sockerr: error %d on %s\n"
argument_list|,
name|so
operator|->
name|so_error
argument_list|,
name|sending
condition|?
literal|"send"
else|:
literal|"receive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|so
operator|->
name|so_error
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|sending
operator|&&
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTRCVMORE
operator|)
condition|)
block|{
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
comment|/* (no error) */
return|return
operator|(
name|EPIPE
operator|)
return|;
block|}
return|return
operator|(
name|so
operator|->
name|so_error
operator|)
return|;
block|}
end_block

end_unit

