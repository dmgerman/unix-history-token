begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)nfs_socket.c	7.4 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Socket operations for use by nfs (similar to uipc_socket.c, but never  * with copies to/from a uio vector)  * NB: For now, they only work for UDP datagram sockets.  * (Use on stream sockets would require some record boundary mark in the  *  stream such as Sun's RM (Section 3.2 of the Sun RPC Message Protocol  *  manual, in Networking on the Sun Workstation, Part #800-1324-03  *  and different versions of send, receive and reply that do not assume  *  an atomic protocol  */
end_comment

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"rpcv2.h"
end_include

begin_include
include|#
directive|include
file|"nfsv2.h"
end_include

begin_include
include|#
directive|include
file|"nfs.h"
end_include

begin_include
include|#
directive|include
file|"xdr_subs.h"
end_include

begin_include
include|#
directive|include
file|"nfsm_subs.h"
end_include

begin_include
include|#
directive|include
file|"nfsmount.h"
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_comment
comment|/* set lock on sockbuf sb, sleep at neg prio */
end_comment

begin_define
define|#
directive|define
name|nfs_sblock
parameter_list|(
name|sb
parameter_list|)
value|{ \ 	while ((sb)->sb_flags& SB_LOCK) { \ 		(sb)->sb_flags |= SB_WANT; \ 		sleep((caddr_t)&(sb)->sb_flags, PZERO-1); \ 	} \ 	(sb)->sb_flags |= SB_LOCK; \ }
end_define

begin_comment
comment|/*  * External data, mostly RPC constants in XDR form  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|rpc_reply
decl_stmt|,
name|rpc_msgdenied
decl_stmt|,
name|rpc_mismatch
decl_stmt|,
name|rpc_vers
decl_stmt|,
name|rpc_auth_unix
decl_stmt|,
name|rpc_msgaccepted
decl_stmt|,
name|rpc_call
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|nfs_prog
decl_stmt|,
name|nfs_vers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsrv_null
argument_list|()
decl_stmt|,
name|nfsrv_getattr
argument_list|()
decl_stmt|,
name|nfsrv_setattr
argument_list|()
decl_stmt|,
name|nfsrv_lookup
argument_list|()
decl_stmt|,
name|nfsrv_readlink
argument_list|()
decl_stmt|,
name|nfsrv_read
argument_list|()
decl_stmt|,
name|nfsrv_write
argument_list|()
decl_stmt|,
name|nfsrv_create
argument_list|()
decl_stmt|,
name|nfsrv_remove
argument_list|()
decl_stmt|,
name|nfsrv_rename
argument_list|()
decl_stmt|,
name|nfsrv_link
argument_list|()
decl_stmt|,
name|nfsrv_symlink
argument_list|()
decl_stmt|,
name|nfsrv_mkdir
argument_list|()
decl_stmt|,
name|nfsrv_rmdir
argument_list|()
decl_stmt|,
name|nfsrv_readdir
argument_list|()
decl_stmt|,
name|nfsrv_statfs
argument_list|()
decl_stmt|,
name|nfsrv_noop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|nfsrv_procs
index|[
name|NFS_NPROCS
index|]
function_decl|)
parameter_list|()
init|=
block|{
name|nfsrv_null
operator|,
function_decl|nfsrv_getattr
operator|,
function_decl|nfsrv_setattr
operator|,
function_decl|nfsrv_noop
operator|,
function_decl|nfsrv_lookup
operator|,
function_decl|nfsrv_readlink
operator|,
function_decl|nfsrv_read
operator|,
function_decl|nfsrv_noop
operator|,
function_decl|nfsrv_write
operator|,
function_decl|nfsrv_create
operator|,
function_decl|nfsrv_remove
operator|,
function_decl|nfsrv_rename
operator|,
function_decl|nfsrv_link
operator|,
function_decl|nfsrv_symlink
operator|,
function_decl|nfsrv_mkdir
operator|,
function_decl|nfsrv_rmdir
operator|,
function_decl|nfsrv_readdir
operator|,
function_decl|nfsrv_statfs
operator|,
end_function_decl

begin_comment
unit|};
comment|/*  * This is a stripped down version of sosend() specific to  * udp/ip and uses the mbuf list provdied  */
end_comment

begin_expr_stmt
name|nfs_udpsend
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|top
argument_list|,
name|flags
argument_list|,
name|siz
argument_list|)
specifier|register
expr|struct
name|socket
operator|*
name|so
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|siz
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|space
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|s
decl_stmt|,
name|dontroute
decl_stmt|;
name|dontroute
operator|=
operator|(
name|flags
operator|&
name|MSG_DONTROUTE
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_ATOMIC
operator|)
expr_stmt|;
define|#
directive|define
name|snderr
parameter_list|(
name|errno
parameter_list|)
value|{ error = errno; splx(s); goto release; }
ifdef|#
directive|ifdef
name|MGETHDR
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|siz
expr_stmt|;
endif|#
directive|endif
name|restart
label|:
name|nfs_sblock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTSENDMORE
condition|)
name|snderr
argument_list|(
name|EPIPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
name|snderr
argument_list|(
name|so
operator|->
name|so_error
argument_list|)
expr_stmt|;
name|space
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|<
name|siz
condition|)
block|{
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|nfs_sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontroute
condition|)
name|so
operator|->
name|so_options
operator||=
name|SO_DONTROUTE
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* XXX */
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreq
call|)
argument_list|(
name|so
argument_list|,
name|PRU_SEND
argument_list|,
name|top
argument_list|,
operator|(
name|caddr_t
operator|)
name|nam
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontroute
condition|)
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_DONTROUTE
expr_stmt|;
name|top
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|release
label|:
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
condition|)
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * This is a stripped down udp specific version of soreceive()  */
end_comment

begin_expr_stmt
name|nfs_udpreceive
argument_list|(
name|so
argument_list|,
name|aname
argument_list|,
name|mp
argument_list|)
specifier|register
expr|struct
name|socket
operator|*
name|so
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|aname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nextrecord
decl_stmt|;
if|if
condition|(
name|aname
condition|)
operator|*
name|aname
operator|=
literal|0
expr_stmt|;
name|restart
label|:
name|sblock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTRCVMORE
condition|)
goto|goto
name|release
goto|;
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs_receive 1"
argument_list|)
expr_stmt|;
name|nextrecord
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_SONAME
condition|)
name|panic
argument_list|(
literal|"nfs_receive 1a"
argument_list|)
expr_stmt|;
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|aname
condition|)
block|{
operator|*
name|aname
operator|=
name|m
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
block|}
else|else
block|{
name|MFREE
argument_list|(
name|m
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_RIGHTS
condition|)
name|panic
argument_list|(
literal|"nfs_receive 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_CONTROL
condition|)
block|{
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MFREE
argument_list|(
name|m
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
block|}
operator|*
name|mp
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_DATA
operator|&&
name|m
operator|->
name|m_type
operator|!=
name|MT_HEADER
condition|)
name|panic
argument_list|(
literal|"nfs_receive 3"
argument_list|)
expr_stmt|;
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|nextrecord
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_RCVATMARK
expr_stmt|;
comment|/* Necessary ?? */
name|release
label|:
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|struct
name|nfsreq
name|nfsreqh
init|=
block|{
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
block|,
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
block|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
block|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
block|,
operator|(
expr|struct
name|nfsmount
operator|*
operator|)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|rpc_replyhead
block|{
name|u_long
name|r_xid
decl_stmt|;
name|u_long
name|r_rep
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Implement receipt of reply on a socket.  * We depend on the way that records are added to the sockbuf  * by sbappend*.  In particular, each record (mbufs linked through m_next)  * must begin with an address, followed by optional MT_CONTROL mbuf  * and then zero or more mbufs of data.  * Although the sockbuf is locked, new data may still be appended,  * and thus we must maintain consistency of the sockbuf during that time.  * We must search through the list of received datagrams matching them  * with outstanding requests using the xid, until ours is found.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|nfs_udpreply
argument_list|(
name|so
argument_list|,
name|mntp
argument_list|,
name|myrep
argument_list|)
specifier|register
expr|struct
name|socket
operator|*
name|so
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|nfsmount
modifier|*
name|mntp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfsreq
modifier|*
name|myrep
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|int
name|error
init|=
literal|0
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nextrecord
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|saddr
decl_stmt|;
name|u_long
name|inaddr
decl_stmt|;
name|struct
name|rpc_replyhead
name|replyh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|xfer
decl_stmt|;
name|int
name|found
decl_stmt|;
name|restart
label|:
name|nfs_sblock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Already received, bye bye */
if|if
condition|(
name|myrep
operator|->
name|r_mrep
operator|!=
name|NULL
condition|)
block|{
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If a soft mount and we have run out of retries */
if|if
condition|(
name|myrep
operator|->
name|r_retry
operator|==
literal|0
operator|&&
name|myrep
operator|->
name|r_timer
operator|==
literal|0
condition|)
block|{
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
condition|)
name|panic
argument_list|(
literal|"nfs_soreply 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTRCVMORE
condition|)
goto|goto
name|release
goto|;
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|nfs_sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|nextrecord
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
comment|/* 	 * Take off the address, check for rights and ditch any control 	 * mbufs. 	 */
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_SONAME
condition|)
name|panic
argument_list|(
literal|"nfs reply SONAME"
argument_list|)
expr_stmt|;
name|saddr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
name|inaddr
operator|=
name|saddr
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MFREE
argument_list|(
name|m
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_RIGHTS
condition|)
name|panic
argument_list|(
literal|"nfs reply RIGHTS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_CONTROL
condition|)
block|{
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MFREE
argument_list|(
name|m
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|m
operator|->
name|m_nextpkt
operator|=
name|nextrecord
expr_stmt|;
block|}
else|else
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|nextrecord
expr_stmt|;
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Get the xid and check that it is an rpc reply 	 */
name|mp
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
literal|2
operator|*
name|NFSX_UNSIGNED
condition|)
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|replyh
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
else|else
block|{
name|cnt
operator|=
literal|2
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|cp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|replyh
expr_stmt|;
while|while
condition|(
name|mp
operator|&&
name|cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_len
operator|>
literal|0
condition|)
block|{
name|xfer
operator|=
operator|(
name|mp
operator|->
name|m_len
operator|>=
name|cnt
operator|)
condition|?
name|cnt
else|:
name|mp
operator|->
name|m_len
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|cp
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|cnt
operator|-=
name|xfer
expr_stmt|;
name|cp
operator|+=
name|xfer
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
block|}
block|}
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|replyh
operator|.
name|r_rep
operator|!=
name|rpc_reply
operator|||
name|mp
operator|==
name|NULL
condition|)
goto|goto
name|dropit
goto|;
comment|/* 	 * Loop through the request list to match up the reply 	 * Iff no match, just drop the datagram 	 */
name|rep
operator|=
name|nfsreqh
operator|.
name|r_next
expr_stmt|;
while|while
condition|(
operator|!
name|found
operator|&&
name|rep
operator|!=
operator|&
name|nfsreqh
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|==
name|NULL
operator|&&
name|replyh
operator|.
name|r_xid
operator|==
name|rep
operator|->
name|r_xid
operator|&&
name|inaddr
operator|==
name|rep
operator|->
name|r_inaddr
condition|)
block|{
comment|/* Found it.. */
name|rep
operator|->
name|r_mrep
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_DATA
operator|&&
name|m
operator|->
name|m_type
operator|!=
name|MT_HEADER
condition|)
name|panic
argument_list|(
literal|"nfs_soreply 3"
argument_list|)
expr_stmt|;
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|nextrecord
expr_stmt|;
if|if
condition|(
name|rep
operator|==
name|myrep
condition|)
goto|goto
name|release
goto|;
name|found
operator|++
expr_stmt|;
block|}
name|rep
operator|=
name|rep
operator|->
name|r_next
expr_stmt|;
block|}
comment|/* Iff not matched to request, drop it */
name|dropit
label|:
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|sbdroprecord
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&
name|SB_WAIT
condition|)
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_WAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
block|}
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
name|release
label|:
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs_request - goes something like this  *	- fill in request struct  *	- links it into list  *	- calls nfs_sosend() for first transmit  *	- calls nfs_soreceive() to get reply  *	- break down rpc header and return with nfs reply pointed to  *	  by mrep or error  * nb: always frees up mreq mbuf list  */
end_comment

begin_macro
name|nfs_request
argument_list|(
argument|vp
argument_list|,
argument|mreq
argument_list|,
argument|xid
argument_list|,
argument|mp
argument_list|,
argument|mrp
argument_list|,
argument|mdp
argument_list|,
argument|dposp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|xid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mrp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|dposp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mrep
decl_stmt|;
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|mntp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|saddr
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|reph
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
name|int
name|t1
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mntp
operator|=
name|vfs_to_nfs
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|m
operator|=
name|mreq
expr_stmt|;
name|MALLOC
argument_list|(
name|rep
argument_list|,
expr|struct
name|nfsreq
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsreq
argument_list|)
argument_list|,
name|M_NFSREQ
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_xid
operator|=
name|xid
expr_stmt|;
name|rep
operator|->
name|r_mntp
operator|=
name|mntp
expr_stmt|;
name|saddr
operator|=
name|mtod
argument_list|(
name|mntp
operator|->
name|nm_sockaddr
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_inaddr
operator|=
name|saddr
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|rep
operator|->
name|r_vp
operator|=
name|vp
expr_stmt|;
if|if
condition|(
name|mntp
operator|->
name|nm_flag
operator|&
name|NFSMNT_SOFT
condition|)
name|rep
operator|->
name|r_retry
operator|=
name|mntp
operator|->
name|nm_retrans
expr_stmt|;
else|else
name|rep
operator|->
name|r_retry
operator|=
name|VNOVAL
expr_stmt|;
name|rep
operator|->
name|r_mrep
operator|=
name|NULL
expr_stmt|;
name|rep
operator|->
name|r_mreq
operator|=
name|m
expr_stmt|;
name|rep
operator|->
name|r_timer
operator|=
name|rep
operator|->
name|r_timeout
operator|=
name|mntp
operator|->
name|nm_timeo
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|rep
operator|->
name|r_msiz
operator|=
name|len
expr_stmt|;
name|m
operator|=
name|NFSMCOPY
argument_list|(
name|mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
comment|/* Chain it into list of outstanding requests */
name|reph
operator|=
operator|&
name|nfsreqh
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|reph
operator|->
name|r_prev
operator|==
name|NULL
condition|)
block|{
name|reph
operator|->
name|r_next
operator|=
name|rep
expr_stmt|;
name|rep
operator|->
name|r_prev
operator|=
name|reph
expr_stmt|;
block|}
else|else
block|{
name|reph
operator|->
name|r_prev
operator|->
name|r_next
operator|=
name|rep
expr_stmt|;
name|rep
operator|->
name|r_prev
operator|=
name|reph
operator|->
name|r_prev
expr_stmt|;
block|}
name|reph
operator|->
name|r_prev
operator|=
name|rep
expr_stmt|;
name|rep
operator|->
name|r_next
operator|=
name|reph
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Iff the NFSMCOPY above succeeded, send it off... 	 * otherwise the timer will retransmit later 	 */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|error
operator|=
name|nfs_udpsend
argument_list|(
name|mntp
operator|->
name|nm_so
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_udpreply
argument_list|(
name|mntp
operator|->
name|nm_so
argument_list|,
name|mntp
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|rep
operator|->
name|r_prev
operator|->
name|r_next
operator|=
name|rep
operator|->
name|r_next
expr_stmt|;
name|rep
operator|->
name|r_next
operator|->
name|r_prev
operator|=
name|rep
operator|->
name|r_prev
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|mrep
operator|=
name|md
operator|=
name|rep
operator|->
name|r_mrep
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * break down the rpc header and check if ok 	 */
name|dpos
operator|=
name|mtod
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|rpc_msgdenied
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|rpc_mismatch
condition|)
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
else|else
name|error
operator|=
name|EACCES
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * skip over the auth_verf, someday we may want to cache auth_short's 	 * for nfs_reqhead(), but for now just dump it 	 */
if|if
condition|(
operator|*
operator|++
name|p
operator|!=
literal|0
condition|)
block|{
name|len
operator|=
name|nfsm_rndup
argument_list|(
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_adv
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* 0 == ok */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get a request for the server main loop  * - receive a request via. nfs_soreceive()  * - verify it  * - fill in the cred struct.  */
end_comment

begin_macro
name|nfs_getreq
argument_list|(
argument|so
argument_list|,
argument|prog
argument_list|,
argument|vers
argument_list|,
argument|maxproc
argument_list|,
argument|nam
argument_list|,
argument|mrp
argument_list|,
argument|mdp
argument_list|,
argument|dposp
argument_list|,
argument|retxid
argument_list|,
argument|proc
argument_list|,
argument|cr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|prog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|vers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mrp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|dposp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
modifier|*
name|retxid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
modifier|*
name|proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|nfs_udpreceive
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
operator|&
name|mrep
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|md
operator|=
name|mrep
expr_stmt|;
name|dpos
operator|=
name|mtod
argument_list|(
name|mrep
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|10
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|retxid
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|rpc_call
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERPCMISMATCH
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|rpc_vers
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERPCMISMATCH
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|prog
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROGUNAVAIL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|vers
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROGMISMATCH
operator|)
return|;
block|}
operator|*
name|proc
operator|=
name|fxdr_unsigned
argument_list|(
name|u_long
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|proc
operator|==
name|NFSPROC_NULL
condition|)
block|{
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|proc
operator|>
name|maxproc
operator|||
operator|*
name|p
operator|++
operator|!=
name|rpc_auth_unix
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROCUNAVAIL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|++
name|p
argument_list|)
expr_stmt|;
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_uid
operator|=
name|fxdr_unsigned
argument_list|(
name|uid_t
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_gid
operator|=
name|fxdr_unsigned
argument_list|(
name|gid_t
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|10
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
operator|(
name|len
operator|+
literal|2
operator|)
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|++
control|)
name|cr
operator|->
name|cr_groups
index|[
name|i
index|]
operator|=
name|fxdr_unsigned
argument_list|(
name|gid_t
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_ngroups
operator|=
name|len
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Do we have any use for the verifier. 	 * According to the "Remote Procedure Call Protocol Spec." it 	 * should be AUTH_NULL, but some clients make it AUTH_UNIX? 	 * For now, just skip over it 	 */
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|++
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Generate the rpc reply header  * siz arg. is used to decide if adding a cluster is worthwhile  */
end_comment

begin_macro
name|nfs_rephead
argument_list|(
argument|siz
argument_list|,
argument|retxid
argument_list|,
argument|err
argument_list|,
argument|mrq
argument_list|,
argument|mbp
argument_list|,
argument|bposp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|siz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|retxid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|err
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mrq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|bposp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|NFSMGETHDR
argument_list|(
name|mreq
argument_list|)
expr_stmt|;
name|mb
operator|=
name|mreq
expr_stmt|;
if|if
condition|(
operator|(
name|siz
operator|+
name|RPC_REPLYSIZ
operator|)
operator|>
name|MHLEN
condition|)
name|NFSMCLGET
argument_list|(
name|mreq
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|mreq
argument_list|,
name|u_long
operator|*
argument_list|)
expr_stmt|;
name|mreq
operator|->
name|m_len
operator|=
literal|6
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|bpos
operator|=
operator|(
operator|(
name|caddr_t
operator|)
name|p
operator|)
operator|+
name|mreq
operator|->
name|m_len
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|retxid
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rpc_reply
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERPCMISMATCH
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|rpc_msgdenied
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rpc_mismatch
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|rpc_msgaccepted
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|EPROGUNAVAIL
case|:
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_PROGUNAVAIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPROGMISMATCH
case|:
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_PROGMISMATCH
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* someday 3 */
break|break;
case|case
name|EPROCUNAVAIL
case|:
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_PROCUNAVAIL
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|VNOVAL
condition|)
block|{
name|nfsm_build
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
empty_stmt|;
block|}
operator|*
name|mrq
operator|=
name|mreq
expr_stmt|;
operator|*
name|mbp
operator|=
name|mb
expr_stmt|;
operator|*
name|bposp
operator|=
name|bpos
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|VNOVAL
condition|)
name|nfsstats
operator|.
name|srvrpc_errs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Nfs timer routine  * Scan the nfsreq list and retranmit any requests that have timed out  * To avoid retransmission attempts on STREAM sockets (in the future) make  * sure to set the r_retry field to 0.  */
end_comment

begin_macro
name|nfs_timer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|rep
operator|=
name|nfsreqh
operator|.
name|r_next
expr_stmt|;
while|while
condition|(
name|rep
operator|&&
name|rep
operator|!=
operator|&
name|nfsreqh
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_timer
operator|>
literal|0
condition|)
name|rep
operator|->
name|r_timer
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|==
name|NULL
operator|&&
name|rep
operator|->
name|r_retry
operator|>
literal|0
condition|)
block|{
name|so
operator|=
name|rep
operator|->
name|r_mntp
operator|->
name|nm_so
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTSENDMORE
operator|)
operator|==
literal|0
operator|&&
operator|!
name|so
operator|->
name|so_error
operator|&&
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|>=
name|rep
operator|->
name|r_msiz
condition|)
block|{
name|m
operator|=
name|NFSMCOPY
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|nfsstats
operator|.
name|rpcretries
operator|++
expr_stmt|;
name|rep
operator|->
name|r_timeout
operator|<<=
literal|2
expr_stmt|;
comment|/* x4 backoff */
if|if
condition|(
name|rep
operator|->
name|r_timeout
operator|>
name|NFS_MAXTIMEO
condition|)
name|rep
operator|->
name|r_timeout
operator|=
name|NFS_MAXTIMEO
expr_stmt|;
name|rep
operator|->
name|r_timer
operator|=
name|rep
operator|->
name|r_timeout
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_retry
operator|!=
name|VNOVAL
condition|)
name|rep
operator|->
name|r_retry
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|MGETHDR
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|rep
operator|->
name|r_msiz
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreq
call|)
argument_list|(
name|so
argument_list|,
name|PRU_SEND
argument_list|,
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|rep
operator|=
name|rep
operator|->
name|r_next
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|nfs_timer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * nfs_sbwait() is simply sbwait() but at a negative priority so that it  * can not be interrupted by a signal.  */
end_comment

begin_macro
name|nfs_sbwait
argument_list|(
argument|sb
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sb
operator|->
name|sb_flags
operator||=
name|SB_WAIT
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sb
operator|->
name|sb_cc
argument_list|,
name|PZERO
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

