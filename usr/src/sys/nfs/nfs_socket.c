begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * %sccs.include.redist.c%  *  *	@(#)nfs_socket.c	7.18 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Socket operations for use by nfs  */
end_comment

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"signal.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/tcp.h"
end_include

begin_include
include|#
directive|include
file|"rpcv2.h"
end_include

begin_include
include|#
directive|include
file|"nfsv2.h"
end_include

begin_include
include|#
directive|include
file|"nfs.h"
end_include

begin_include
include|#
directive|include
file|"xdr_subs.h"
end_include

begin_include
include|#
directive|include
file|"nfsm_subs.h"
end_include

begin_include
include|#
directive|include
file|"nfsmount.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/*  * External data, mostly RPC constants in XDR form  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|rpc_reply
decl_stmt|,
name|rpc_msgdenied
decl_stmt|,
name|rpc_mismatch
decl_stmt|,
name|rpc_vers
decl_stmt|,
name|rpc_auth_unix
decl_stmt|,
name|rpc_msgaccepted
decl_stmt|,
name|rpc_call
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|nfs_prog
decl_stmt|,
name|nfs_vers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maybe these should be bits in a u_long ?? */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nonidempotent
index|[
name|NFS_NPROCS
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|nfs_sbwait
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|nfs_disconnect
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|nfsrv_null
argument_list|()
decl_stmt|,
name|nfsrv_getattr
argument_list|()
decl_stmt|,
name|nfsrv_setattr
argument_list|()
decl_stmt|,
name|nfsrv_lookup
argument_list|()
decl_stmt|,
name|nfsrv_readlink
argument_list|()
decl_stmt|,
name|nfsrv_read
argument_list|()
decl_stmt|,
name|nfsrv_write
argument_list|()
decl_stmt|,
name|nfsrv_create
argument_list|()
decl_stmt|,
name|nfsrv_remove
argument_list|()
decl_stmt|,
name|nfsrv_rename
argument_list|()
decl_stmt|,
name|nfsrv_link
argument_list|()
decl_stmt|,
name|nfsrv_symlink
argument_list|()
decl_stmt|,
name|nfsrv_mkdir
argument_list|()
decl_stmt|,
name|nfsrv_rmdir
argument_list|()
decl_stmt|,
name|nfsrv_readdir
argument_list|()
decl_stmt|,
name|nfsrv_statfs
argument_list|()
decl_stmt|,
name|nfsrv_noop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|nfsrv_procs
index|[
name|NFS_NPROCS
index|]
function_decl|)
parameter_list|()
init|=
block|{
name|nfsrv_null
operator|,
function_decl|nfsrv_getattr
operator|,
function_decl|nfsrv_setattr
operator|,
function_decl|nfsrv_noop
operator|,
function_decl|nfsrv_lookup
operator|,
function_decl|nfsrv_readlink
operator|,
function_decl|nfsrv_read
operator|,
function_decl|nfsrv_noop
operator|,
function_decl|nfsrv_write
operator|,
function_decl|nfsrv_create
operator|,
function_decl|nfsrv_remove
operator|,
function_decl|nfsrv_rename
operator|,
function_decl|nfsrv_link
operator|,
function_decl|nfsrv_symlink
operator|,
function_decl|nfsrv_mkdir
operator|,
function_decl|nfsrv_rmdir
operator|,
function_decl|nfsrv_readdir
operator|,
function_decl|nfsrv_statfs
operator|,
end_function_decl

begin_decl_stmt
unit|};
name|struct
name|nfsreq
name|nfsreqh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsrexmtthresh
init|=
name|NFS_FISHY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfs_tcpnodelay
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize sockets and congestion for a new NFS connection.  * We do not free the sockaddr if error.  */
end_comment

begin_expr_stmt
name|nfs_connect
argument_list|(
name|nmp
argument_list|)
specifier|register
expr|struct
name|nfsmount
operator|*
name|nmp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|nmp
operator|->
name|nm_so
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|socreate
argument_list|(
name|mtod
argument_list|(
name|nmp
operator|->
name|nm_nam
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
operator|->
name|sa_family
argument_list|,
operator|&
name|nmp
operator|->
name|nm_so
argument_list|,
name|nmp
operator|->
name|nm_sotype
argument_list|,
name|nmp
operator|->
name|nm_soproto
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|so
operator|=
name|nmp
operator|->
name|nm_so
expr_stmt|;
name|nmp
operator|->
name|nm_soflags
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
expr_stmt|;
comment|/* 	 * Protocols that do not require connections may be optionally left 	 * unconnected for servers that reply from a port other than NFS_PORT. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOCONN
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|error
operator|=
name|soconnect
argument_list|(
name|so
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* 		 * Wait for the connection to complete. Cribbed from the 		 * connect system call but with the wait at negative prio. 		 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTING
operator|)
operator|&&
name|so
operator|->
name|so_error
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|so
operator|->
name|so_timeo
argument_list|,
name|PSOCK
argument_list|,
literal|"nfscon"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_DGRAM
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
operator|(
name|NFSMNT_SOFT
operator||
name|NFSMNT_SPONGY
operator||
name|NFSMNT_INT
operator|)
condition|)
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
operator|(
literal|5
operator|*
name|hz
operator|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
operator|(
literal|5
operator|*
name|hz
operator|)
expr_stmt|;
block|}
else|else
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
argument_list|,
name|nmp
operator|->
name|nm_rsize
operator|+
name|NFS_MAXPKTHDR
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
operator|(
name|NFSMNT_SOFT
operator||
name|NFSMNT_SPONGY
operator||
name|NFSMNT_INT
operator|)
condition|)
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
operator|(
literal|5
operator|*
name|hz
operator|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
operator|(
literal|5
operator|*
name|hz
operator|)
expr_stmt|;
block|}
else|else
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|int
operator|*
argument_list|)
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|AF_INET
operator|&&
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_TCP
operator|&&
name|nfs_tcpnodelay
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|int
operator|*
argument_list|)
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|TCP_NODELAY
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|nmp
operator|->
name|nm_rsize
operator|+
name|NFS_MAXPKTHDR
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|SB_NOINTR
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|SB_NOINTR
expr_stmt|;
comment|/* Initialize other non-zero congestion variables */
name|nmp
operator|->
name|nm_rto
operator|=
name|NFS_TIMEO
expr_stmt|;
name|nmp
operator|->
name|nm_window
operator|=
literal|2
expr_stmt|;
comment|/* Initial send window */
name|nmp
operator|->
name|nm_ssthresh
operator|=
name|NFS_MAXWINDOW
expr_stmt|;
comment|/* Slowstart threshold */
name|nmp
operator|->
name|nm_rttvar
operator|=
name|nmp
operator|->
name|nm_rto
operator|<<
literal|1
expr_stmt|;
name|nmp
operator|->
name|nm_sent
operator|=
literal|0
expr_stmt|;
name|nmp
operator|->
name|nm_currexmit
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|nfs_disconnect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Reconnect routine:  * Called when a connection is broken on a reliable protocol.  * - clean up the old socket  * - nfs_connect() again  * - set R_MUSTRESEND for all outstanding requests on mount point  * If this fails the mount point is DEAD!  * nb: Must be called with the nfs_solock() set on the mount point.  */
end_comment

begin_expr_stmt
name|nfs_reconnect
argument_list|(
name|rep
argument_list|,
name|nmp
argument_list|)
specifier|register
expr|struct
name|nfsreq
operator|*
name|rep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nfsreq
modifier|*
name|rp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_procp
condition|)
name|tprintf
argument_list|(
name|rep
operator|->
name|r_procp
operator|->
name|p_session
argument_list|,
literal|"Nfs server %s, trying reconnect\n"
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
else|else
name|tprintf
argument_list|(
name|NULL
argument_list|,
literal|"Nfs server %s, trying a reconnect\n"
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
while|while
condition|(
name|error
operator|=
name|nfs_connect
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|lint
name|error
operator|=
name|error
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
operator|)
operator|&&
name|nfs_sigintr
argument_list|(
name|rep
operator|->
name|r_procp
argument_list|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PSOCK
argument_list|,
literal|"nfscon"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_procp
condition|)
name|tprintf
argument_list|(
name|rep
operator|->
name|r_procp
operator|->
name|p_session
argument_list|,
literal|"Nfs server %s, reconnected\n"
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
else|else
name|tprintf
argument_list|(
name|NULL
argument_list|,
literal|"Nfs server %s, reconnected\n"
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
comment|/* 	 * Loop through outstanding request list and fix up all requests 	 * on old socket. 	 */
name|rp
operator|=
name|nfsreqh
operator|.
name|r_next
expr_stmt|;
while|while
condition|(
name|rp
operator|!=
operator|&
name|nfsreqh
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_nmp
operator|==
name|nmp
condition|)
name|rp
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
name|rp
operator|=
name|rp
operator|->
name|r_next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * NFS disconnect. Clean up and unlink.  */
end_comment

begin_function
name|void
name|nfs_disconnect
parameter_list|(
name|nmp
parameter_list|)
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
block|{
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_so
condition|)
block|{
name|so
operator|=
name|nmp
operator|->
name|nm_so
expr_stmt|;
name|nmp
operator|->
name|nm_so
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
expr_stmt|;
name|soshutdown
argument_list|(
name|so
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|soclose
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the nfs send routine. For connection based socket types, it  * must be called with an nfs_solock() on the socket.  * "rep == NULL" indicates that it has been called from a server.  */
end_comment

begin_expr_stmt
name|nfs_send
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|top
argument_list|,
name|rep
argument_list|)
specifier|register
expr|struct
name|socket
operator|*
name|so
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|sendnam
decl_stmt|;
name|int
name|error
decl_stmt|,
name|soflags
decl_stmt|;
if|if
condition|(
name|rep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_nmp
operator|->
name|nm_so
operator|==
name|NULL
operator|&&
operator|(
name|error
operator|=
name|nfs_reconnect
argument_list|(
name|rep
argument_list|,
name|rep
operator|->
name|r_nmp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_MUSTRESEND
expr_stmt|;
name|so
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_so
expr_stmt|;
name|soflags
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_soflags
expr_stmt|;
block|}
else|else
name|soflags
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
expr_stmt|;
if|if
condition|(
operator|(
name|soflags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
condition|)
name|sendnam
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
else|else
name|sendnam
operator|=
name|nam
expr_stmt|;
name|error
operator|=
name|sosend
argument_list|(
name|so
argument_list|,
name|sendnam
argument_list|,
operator|(
expr|struct
name|uio
operator|*
operator|)
literal|0
argument_list|,
name|top
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
name|rep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
else|else
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Ignore socket errors?? 	 */
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EINTR
operator|&&
name|error
operator|!=
name|ERESTART
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Receive a Sun RPC Request/Reply. For SOCK_DGRAM, the work is all  * done by soreceive(), but for SOCK_STREAM we must deal with the Record  * Mark and consolidate the data into a new mbuf list.  * nb: Sometimes TCP passes the data up to soreceive() in long lists of  *     small mbufs.  * For SOCK_STREAM we must be very careful to read an entire record once  * we have read any of it, even if the system call has been interrupted.  */
end_comment

begin_expr_stmt
name|nfs_receive
argument_list|(
name|so
argument_list|,
name|aname
argument_list|,
name|mp
argument_list|,
name|rep
argument_list|)
specifier|register
expr|struct
name|socket
operator|*
name|so
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|aname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aio
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|,
modifier|*
name|m3
decl_stmt|,
modifier|*
name|mnew
decl_stmt|,
modifier|*
modifier|*
name|mbp
decl_stmt|;
name|caddr_t
name|fcp
decl_stmt|,
name|tcp
decl_stmt|;
name|u_long
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|getnam
decl_stmt|;
name|int
name|error
decl_stmt|,
name|siz
decl_stmt|,
name|mlen
decl_stmt|,
name|soflags
decl_stmt|,
name|rcvflg
init|=
name|MSG_WAITALL
decl_stmt|;
comment|/* 	 * Set up arguments for soreceive() 	 */
operator|*
name|mp
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|aname
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|rep
condition|)
name|soflags
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_soflags
expr_stmt|;
else|else
name|soflags
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
expr_stmt|;
comment|/* 	 * For reliable protocols, lock against other senders/receivers 	 * in case a reconnect is necessary. 	 * For SOCK_STREAM, first get the Record Mark to find out how much 	 * more there is to get. 	 * We must lock the socket against other receivers 	 * until we have an entire rpc request/reply. 	 */
if|if
condition|(
name|soflags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
name|tryagain
label|:
comment|/* 		 * Check for fatal errors and resending request. 		 */
if|if
condition|(
name|rep
condition|)
block|{
comment|/* 			 * Ugh: If a reconnect attempt just happened, nm_so 			 * would have changed. NULL indicates a failed 			 * attempt that has essentially shut down this 			 * mount point. 			 */
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|||
operator|(
name|so
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_so
operator|)
operator|==
name|NULL
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
while|while
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_MUSTRESEND
condition|)
block|{
name|m
operator|=
name|m_copym
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|nfsstats
operator|.
name|rpcretries
operator|++
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|nfs_send
argument_list|(
name|so
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_nam
argument_list|,
name|m
argument_list|,
name|rep
argument_list|)
condition|)
goto|goto
name|errout
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|soflags
operator|&
name|PR_ATOMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|aio
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|len
expr_stmt|;
name|aio
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aio
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
do|do
block|{
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|auio
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
name|rep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_MUSTRESEND
condition|)
goto|goto
name|tryagain
goto|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
do|;
if|if
condition|(
operator|!
name|error
operator|&&
name|auio
operator|.
name|uio_resid
operator|>
literal|0
condition|)
name|error
operator|=
name|EPIPE
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|errout
goto|;
name|len
operator|=
name|ntohl
argument_list|(
name|len
argument_list|)
operator|&
operator|~
literal|0x80000000
expr_stmt|;
comment|/* 			 * This is SERIOUS! We are out of sync with the sender 			 * and forcing a disconnect/reconnect is all I can do. 			 */
if|if
condition|(
name|len
operator|>
name|NFS_MAXPACKET
condition|)
block|{
name|error
operator|=
name|EFBIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|auio
operator|.
name|uio_resid
operator|=
name|len
expr_stmt|;
do|do
block|{
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|auio
argument_list|,
name|mp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
do|;
if|if
condition|(
operator|!
name|error
operator|&&
name|auio
operator|.
name|uio_resid
operator|>
literal|0
condition|)
name|error
operator|=
name|EPIPE
expr_stmt|;
block|}
else|else
block|{
name|auio
operator|.
name|uio_resid
operator|=
name|len
operator|=
literal|1000000
expr_stmt|;
comment|/* Anything Big */
do|do
block|{
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|auio
argument_list|,
name|mp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
name|rep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_MUSTRESEND
condition|)
goto|goto
name|tryagain
goto|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
do|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|*
name|mp
operator|==
name|NULL
condition|)
name|error
operator|=
name|EPIPE
expr_stmt|;
name|len
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
block|}
name|errout
label|:
if|if
condition|(
name|error
operator|&&
name|rep
operator|&&
name|error
operator|!=
name|EINTR
operator|&&
name|error
operator|!=
name|ERESTART
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|nfs_disconnect
argument_list|(
name|rep
operator|->
name|r_nmp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_reconnect
argument_list|(
name|rep
argument_list|,
name|rep
operator|->
name|r_nmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
goto|goto
name|tryagain
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
condition|)
name|getnam
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
else|else
name|getnam
operator|=
name|aname
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|len
operator|=
literal|1000000
expr_stmt|;
do|do
block|{
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
name|getnam
argument_list|,
operator|&
name|auio
argument_list|,
name|mp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
name|rep
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|len
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* 	 * Search for any mbufs that are not a multiple of 4 bytes long. 	 * These could cause pointer alignment problems, so copy them to 	 * well aligned mbufs. 	 */
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|mbp
operator|=
name|mp
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
comment|/* 		 * All this for something that may never happen. 		 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|&
literal|0x3
condition|)
block|{
name|printf
argument_list|(
literal|"nfs_rcv odd length!\n"
argument_list|)
expr_stmt|;
name|fcp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|mnew
operator|=
name|m2
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|m3
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|mlen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m2
operator|==
name|NULL
operator|||
name|mlen
operator|==
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|m2
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m2
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|m2
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|mlen
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|m2
argument_list|)
expr_stmt|;
name|tcp
operator|=
name|mtod
argument_list|(
name|m2
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnew
condition|)
block|{
name|m3
operator|->
name|m_next
operator|=
name|m2
expr_stmt|;
name|m3
operator|=
name|m2
expr_stmt|;
block|}
else|else
name|mnew
operator|=
name|m3
operator|=
name|m2
expr_stmt|;
block|}
name|siz
operator|=
operator|(
name|mlen
operator|>
name|m
operator|->
name|m_len
operator|)
condition|?
name|m
operator|->
name|m_len
else|:
name|mlen
expr_stmt|;
name|bcopy
argument_list|(
name|fcp
argument_list|,
name|tcp
argument_list|,
name|siz
argument_list|)
expr_stmt|;
name|m2
operator|->
name|m_len
operator|+=
name|siz
expr_stmt|;
name|mlen
operator|-=
name|siz
expr_stmt|;
name|len
operator|-=
name|siz
expr_stmt|;
name|tcp
operator|+=
name|siz
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|siz
expr_stmt|;
name|fcp
operator|+=
name|siz
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
do|do
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|&&
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|m
condition|)
name|fcp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
block|}
name|m
operator|=
operator|*
name|mbp
expr_stmt|;
operator|*
name|mbp
operator|=
name|mnew
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|mbp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|rpc_replyhead
block|{
name|u_long
name|r_xid
decl_stmt|;
name|u_long
name|r_rep
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Implement receipt of reply on a socket.  * We must search through the list of received datagrams matching them  * with outstanding requests using the xid, until ours is found.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|nfs_reply
argument_list|(
argument|nmp
argument_list|,
argument|myrep
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfsreq
modifier|*
name|myrep
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|rpc_replyhead
name|replyh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|,
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|xfer
decl_stmt|;
comment|/* 	 * Loop around until we get our own reply 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Lock against other receivers so that I don't get stuck in 		 * sbwait() after someone else has received my reply for me. 		 * Also necessary for connection based protocols to avoid 		 * race conditions during a reconnect. 		 */
name|nfs_solock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|)
expr_stmt|;
comment|/* Already received, bye bye */
if|if
condition|(
name|myrep
operator|->
name|r_mrep
operator|!=
name|NULL
condition|)
block|{
name|nfs_sounlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Get the next Rpc reply off the socket 		 */
if|if
condition|(
name|error
operator|=
name|nfs_receive
argument_list|(
name|nmp
operator|->
name|nm_so
argument_list|,
operator|&
name|nam
argument_list|,
operator|&
name|mp
argument_list|,
name|myrep
argument_list|)
condition|)
block|{
name|nfs_sounlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|)
expr_stmt|;
comment|/* 			 * Ignore routing errors on connectionless protocols?? 			 */
if|if
condition|(
name|NFSIGNORE_SOERROR
argument_list|(
name|nmp
operator|->
name|nm_soflags
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|nmp
operator|->
name|nm_so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Otherwise cleanup and return a fatal error. 			 */
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
block|{
name|myrep
operator|->
name|r_flags
operator|&=
operator|~
name|R_TIMING
expr_stmt|;
name|nmp
operator|->
name|nm_rtt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|myrep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
name|nmp
operator|->
name|nm_sent
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Get the xid and check that it is an rpc reply 		 */
name|m
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
literal|2
operator|*
name|NFSX_UNSIGNED
condition|)
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|replyh
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
else|else
block|{
name|cnt
operator|=
literal|2
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|cp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|replyh
expr_stmt|;
while|while
condition|(
name|m
operator|&&
name|cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
literal|0
condition|)
block|{
name|xfer
operator|=
operator|(
name|m
operator|->
name|m_len
operator|>=
name|cnt
operator|)
condition|?
name|cnt
else|:
name|m
operator|->
name|m_len
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|cp
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|cnt
operator|-=
name|xfer
expr_stmt|;
name|cp
operator|+=
name|xfer
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|replyh
operator|.
name|r_rep
operator|!=
name|rpc_reply
operator|||
name|m
operator|==
name|NULL
condition|)
block|{
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|nfs_sounlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Loop through the request list to match up the reply 		 * Iff no match, just drop the datagram 		 */
name|m
operator|=
name|mp
expr_stmt|;
name|rep
operator|=
name|nfsreqh
operator|.
name|r_next
expr_stmt|;
while|while
condition|(
name|rep
operator|!=
operator|&
name|nfsreqh
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|==
name|NULL
operator|&&
name|replyh
operator|.
name|r_xid
operator|==
name|rep
operator|->
name|r_xid
condition|)
block|{
comment|/* Found it.. */
name|rep
operator|->
name|r_mrep
operator|=
name|m
expr_stmt|;
comment|/* 				 * Update timing 				 */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
block|{
name|nfs_updatetimer
argument_list|(
name|rep
operator|->
name|r_nmp
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_TIMING
expr_stmt|;
name|rep
operator|->
name|r_nmp
operator|->
name|nm_rtt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
name|rep
operator|->
name|r_nmp
operator|->
name|nm_sent
operator|--
expr_stmt|;
block|}
break|break;
block|}
name|rep
operator|=
name|rep
operator|->
name|r_next
expr_stmt|;
block|}
name|nfs_sounlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|nam
condition|)
name|m_freem
argument_list|(
name|nam
argument_list|)
expr_stmt|;
comment|/* 		 * If not matched to a request, drop it. 		 * If it's mine, get out. 		 */
if|if
condition|(
name|rep
operator|==
operator|&
name|nfsreqh
condition|)
block|{
name|nfsstats
operator|.
name|rpcunexpected
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rep
operator|==
name|myrep
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * nfs_request - goes something like this  *	- fill in request struct  *	- links it into list  *	- calls nfs_send() for first transmit  *	- calls nfs_receive() to get reply  *	- break down rpc header and return with nfs reply pointed to  *	  by mrep or error  * nb: always frees up mreq mbuf list  */
end_comment

begin_macro
name|nfs_request
argument_list|(
argument|vp
argument_list|,
argument|mreq
argument_list|,
argument|xid
argument_list|,
argument|procnum
argument_list|,
argument|procp
argument_list|,
argument|tryhard
argument_list|,
argument|mp
argument_list|,
argument|mrp
argument_list|,
argument|mdp
argument_list|,
argument|dposp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|xid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|procnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tryhard
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mrp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|dposp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mrep
decl_stmt|;
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|reph
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
name|int
name|t1
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|m
operator|=
name|mreq
expr_stmt|;
name|MALLOC
argument_list|(
name|rep
argument_list|,
expr|struct
name|nfsreq
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsreq
argument_list|)
argument_list|,
name|M_NFSREQ
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_xid
operator|=
name|xid
expr_stmt|;
name|rep
operator|->
name|r_nmp
operator|=
name|nmp
expr_stmt|;
name|rep
operator|->
name|r_vp
operator|=
name|vp
expr_stmt|;
name|rep
operator|->
name|r_procp
operator|=
name|procp
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_SOFT
operator|)
operator|||
operator|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_SPONGY
operator|)
operator|&&
operator|!
name|tryhard
operator|)
condition|)
name|rep
operator|->
name|r_retry
operator|=
name|nmp
operator|->
name|nm_retry
expr_stmt|;
else|else
name|rep
operator|->
name|r_retry
operator|=
name|NFS_MAXREXMIT
operator|+
literal|1
expr_stmt|;
comment|/* past clip limit */
name|rep
operator|->
name|r_flags
operator|=
name|rep
operator|->
name|r_rexmit
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Three cases: 	 * - non-idempotent requests on SOCK_DGRAM use NFS_MINIDEMTIMEO 	 * - idempotent requests on SOCK_DGRAM use 0 	 * - Reliable transports, NFS_RELIABLETIMEO 	 *   Timeouts are still done on reliable transports to ensure detection 	 *   of excessive connection delay. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|!=
name|SOCK_DGRAM
condition|)
name|rep
operator|->
name|r_timerinit
operator|=
operator|-
name|NFS_RELIABLETIMEO
expr_stmt|;
elseif|else
if|if
condition|(
name|nonidempotent
index|[
name|procnum
index|]
condition|)
name|rep
operator|->
name|r_timerinit
operator|=
operator|-
name|NFS_MINIDEMTIMEO
expr_stmt|;
else|else
name|rep
operator|->
name|r_timerinit
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|r_timer
operator|=
name|rep
operator|->
name|r_timerinit
expr_stmt|;
name|rep
operator|->
name|r_mrep
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|mreq
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|mreq
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* 	 * For non-atomic protocols, insert a Sun RPC Record Mark. 	 */
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_ATOMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|M_PREPEND
argument_list|(
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|mreq
argument_list|,
name|u_long
operator|*
argument_list|)
operator|=
name|htonl
argument_list|(
literal|0x80000000
operator||
name|len
argument_list|)
expr_stmt|;
block|}
name|rep
operator|->
name|r_mreq
operator|=
name|mreq
expr_stmt|;
comment|/* 	 * Do the client side RPC. 	 */
name|nfsstats
operator|.
name|rpcrequests
operator|++
expr_stmt|;
comment|/* 	 * Chain request into list of outstanding requests. Be sure 	 * to put it LAST so timer finds oldest requests first. 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|reph
operator|=
operator|&
name|nfsreqh
expr_stmt|;
name|reph
operator|->
name|r_prev
operator|->
name|r_next
operator|=
name|rep
expr_stmt|;
name|rep
operator|->
name|r_prev
operator|=
name|reph
operator|->
name|r_prev
expr_stmt|;
name|reph
operator|->
name|r_prev
operator|=
name|rep
expr_stmt|;
name|rep
operator|->
name|r_next
operator|=
name|reph
expr_stmt|;
comment|/* 	 * If backing off another request or avoiding congestion, don't 	 * send this one now but let timer do it. If not timing a request, 	 * do it now. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_sent
operator|<=
literal|0
operator|||
name|nmp
operator|->
name|nm_sotype
operator|!=
name|SOCK_DGRAM
operator|||
operator|(
name|nmp
operator|->
name|nm_currexmit
operator|==
literal|0
operator|&&
name|nmp
operator|->
name|nm_sent
operator|<
name|nmp
operator|->
name|nm_window
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_sent
operator|++
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_SENT
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_rtt
operator|==
operator|-
literal|1
condition|)
block|{
name|nmp
operator|->
name|nm_rtt
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_TIMING
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_copym
argument_list|(
name|mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
name|nfs_solock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_send
argument_list|(
name|nmp
operator|->
name|nm_so
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
name|m
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
name|nfs_sounlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|NFSIGNORE_SOERROR
argument_list|(
name|nmp
operator|->
name|nm_soflags
argument_list|,
name|error
argument_list|)
condition|)
name|nmp
operator|->
name|nm_so
operator|->
name|so_error
operator|=
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the reply from our send or the timer's. 	 */
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfs_reply
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|)
expr_stmt|;
comment|/* 	 * RPC done, unlink the request. 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|rep
operator|->
name|r_prev
operator|->
name|r_next
operator|=
name|rep
operator|->
name|r_next
expr_stmt|;
name|rep
operator|->
name|r_next
operator|->
name|r_prev
operator|=
name|rep
operator|->
name|r_prev
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * If there was a successful reply and a tprintf msg. 	 * tprintf a response. 	 */
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TPRINTFMSG
operator|)
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_procp
condition|)
name|tprintf
argument_list|(
name|rep
operator|->
name|r_procp
operator|->
name|p_session
argument_list|,
literal|"Nfs server %s, is alive again\n"
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
else|else
name|tprintf
argument_list|(
name|NULL
argument_list|,
literal|"Nfs server %s, is alive again\n"
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|mrep
operator|=
name|md
operator|=
name|rep
operator|->
name|r_mrep
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * break down the rpc header and check if ok 	 */
name|dpos
operator|=
name|mtod
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|rpc_msgdenied
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|rpc_mismatch
condition|)
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
else|else
name|error
operator|=
name|EACCES
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * skip over the auth_verf, someday we may want to cache auth_short's 	 * for nfs_reqhead(), but for now just dump it 	 */
if|if
condition|(
operator|*
operator|++
name|p
operator|!=
literal|0
condition|)
block|{
name|len
operator|=
name|nfsm_rndup
argument_list|(
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_adv
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* 0 == ok */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get a request for the server main loop  * - receive a request via. nfs_soreceive()  * - verify it  * - fill in the cred struct.  */
end_comment

begin_macro
name|nfs_getreq
argument_list|(
argument|so
argument_list|,
argument|prog
argument_list|,
argument|vers
argument_list|,
argument|maxproc
argument_list|,
argument|nam
argument_list|,
argument|mrp
argument_list|,
argument|mdp
argument_list|,
argument|dposp
argument_list|,
argument|retxid
argument_list|,
argument|procnum
argument_list|,
argument|cr
argument_list|,
argument|msk
argument_list|,
argument|mtch
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|prog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|vers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mrp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|dposp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
modifier|*
name|retxid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
modifier|*
name|procnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|msk
decl_stmt|,
modifier|*
name|mtch
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
name|error
operator|=
name|nfs_receive
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
operator|&
name|mrep
argument_list|,
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mrep
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|mrep
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|nam
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfs_receive
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
operator|&
name|mrep
argument_list|,
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|error
operator|&&
name|nfs_badnam
argument_list|(
operator|*
name|nam
argument_list|,
name|msk
argument_list|,
name|mtch
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|md
operator|=
name|mrep
expr_stmt|;
name|dpos
operator|=
name|mtod
argument_list|(
name|mrep
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|10
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|retxid
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|rpc_call
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERPCMISMATCH
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|rpc_vers
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERPCMISMATCH
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|prog
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROGUNAVAIL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|vers
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROGMISMATCH
operator|)
return|;
block|}
operator|*
name|procnum
operator|=
name|fxdr_unsigned
argument_list|(
name|u_long
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|procnum
operator|==
name|NFSPROC_NULL
condition|)
block|{
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|procnum
operator|>
name|maxproc
operator|||
operator|*
name|p
operator|++
operator|!=
name|rpc_auth_unix
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROCUNAVAIL
operator|)
return|;
block|}
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|RPCAUTH_MAXSIZ
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|++
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_uid
operator|=
name|fxdr_unsigned
argument_list|(
name|uid_t
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_gid
operator|=
name|fxdr_unsigned
argument_list|(
name|gid_t
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|RPCAUTH_UNIXGIDS
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
name|nfsm_disect
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
operator|(
name|len
operator|+
literal|2
operator|)
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|NGROUPS
condition|)
name|cr
operator|->
name|cr_groups
index|[
name|i
index|]
operator|=
name|fxdr_unsigned
argument_list|(
name|gid_t
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|cr
operator|->
name|cr_ngroups
operator|=
operator|(
name|len
operator|>=
name|NGROUPS
operator|)
condition|?
name|NGROUPS
else|:
operator|(
name|len
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Do we have any use for the verifier. 	 * According to the "Remote Procedure Call Protocol Spec." it 	 * should be AUTH_NULL, but some clients make it AUTH_UNIX? 	 * For now, just skip over it 	 */
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|++
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|RPCAUTH_MAXSIZ
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Generate the rpc reply header  * siz arg. is used to decide if adding a cluster is worthwhile  */
end_comment

begin_macro
name|nfs_rephead
argument_list|(
argument|siz
argument_list|,
argument|retxid
argument_list|,
argument|err
argument_list|,
argument|mrq
argument_list|,
argument|mbp
argument_list|,
argument|bposp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|siz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|retxid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|err
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mrq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|bposp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|p
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|NFSMGETHDR
argument_list|(
name|mreq
argument_list|)
expr_stmt|;
name|mb
operator|=
name|mreq
expr_stmt|;
if|if
condition|(
operator|(
name|siz
operator|+
name|RPC_REPLYSIZ
operator|)
operator|>
name|MHLEN
condition|)
name|MCLGET
argument_list|(
name|mreq
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|mreq
argument_list|,
name|u_long
operator|*
argument_list|)
expr_stmt|;
name|mreq
operator|->
name|m_len
operator|=
literal|6
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|bpos
operator|=
operator|(
operator|(
name|caddr_t
operator|)
name|p
operator|)
operator|+
name|mreq
operator|->
name|m_len
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|retxid
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rpc_reply
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERPCMISMATCH
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|rpc_msgdenied
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rpc_mismatch
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|rpc_msgaccepted
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|EPROGUNAVAIL
case|:
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_PROGUNAVAIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPROGMISMATCH
case|:
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_PROGMISMATCH
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* someday 3 */
break|break;
case|case
name|EPROCUNAVAIL
case|:
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_PROCUNAVAIL
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|VNOVAL
condition|)
block|{
name|nfsm_build
argument_list|(
name|p
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|txdr_unsigned
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
empty_stmt|;
block|}
operator|*
name|mrq
operator|=
name|mreq
expr_stmt|;
operator|*
name|mbp
operator|=
name|mb
expr_stmt|;
operator|*
name|bposp
operator|=
name|bpos
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|VNOVAL
condition|)
name|nfsstats
operator|.
name|srvrpc_errs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Nfs timer routine  * Scan the nfsreq list and retranmit any requests that have timed out  * To avoid retransmission attempts on STREAM sockets (in the future) make  * sure to set the r_retry field to 0 (implies nm_retry == 0).  */
end_comment

begin_macro
name|nfs_timer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|rep
operator|=
name|nfsreqh
operator|.
name|r_next
init|;
name|rep
operator|!=
operator|&
name|nfsreqh
condition|;
name|rep
operator|=
name|rep
operator|->
name|r_next
control|)
block|{
name|nmp
operator|=
name|rep
operator|->
name|r_nmp
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
operator|||
operator|(
name|so
operator|=
name|nmp
operator|->
name|nm_so
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
operator|)
operator|&&
name|nfs_sigintr
argument_list|(
name|rep
operator|->
name|r_procp
argument_list|)
condition|)
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_SOFTTERM
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
comment|/* update rtt in mount */
name|nmp
operator|->
name|nm_rtt
operator|++
expr_stmt|;
comment|/* If not timed out */
if|if
condition|(
operator|++
name|rep
operator|->
name|r_timer
operator|<
name|nmp
operator|->
name|nm_rto
condition|)
continue|continue;
comment|/* Do backoff and save new timeout in mount */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
block|{
name|nfs_backofftimer
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_TIMING
expr_stmt|;
name|nmp
operator|->
name|nm_rtt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
name|nmp
operator|->
name|nm_sent
operator|--
expr_stmt|;
block|}
comment|/* 		 * Check for too many retries on soft mount. 		 * nb: For hard mounts, r_retry == NFS_MAXREXMIT+1 		 */
if|if
condition|(
operator|++
name|rep
operator|->
name|r_rexmit
operator|>
name|NFS_MAXREXMIT
condition|)
name|rep
operator|->
name|r_rexmit
operator|=
name|NFS_MAXREXMIT
expr_stmt|;
comment|/* 		 * Check for server not responding 		 */
if|if
condition|(
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TPRINTFMSG
operator|)
operator|==
literal|0
operator|&&
name|rep
operator|->
name|r_rexmit
operator|>
name|NFS_FISHY
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_procp
operator|&&
name|rep
operator|->
name|r_procp
operator|->
name|p_session
condition|)
name|tprintf
argument_list|(
name|rep
operator|->
name|r_procp
operator|->
name|p_session
argument_list|,
literal|"Nfs server %s, not responding\n"
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
else|else
name|tprintf
argument_list|(
name|NULL
argument_list|,
literal|"Nfs server %s, not responding\n"
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_TPRINTFMSG
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_rexmit
operator|>=
name|rep
operator|->
name|r_retry
condition|)
block|{
comment|/* too many */
name|nfsstats
operator|.
name|rpctimeouts
operator|++
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_SOFTTERM
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|!=
name|SOCK_DGRAM
condition|)
continue|continue;
comment|/* 		 * If there is enough space and the window allows.. 		 *	Resend it 		 */
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|>=
name|rep
operator|->
name|r_mreq
operator|->
name|m_pkthdr
operator|.
name|len
operator|&&
name|nmp
operator|->
name|nm_sent
operator|<
name|nmp
operator|->
name|nm_window
operator|&&
operator|(
name|m
operator|=
name|m_copym
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
operator|)
condition|)
block|{
name|nfsstats
operator|.
name|rpcretries
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOCONN
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreq
call|)
argument_list|(
name|so
argument_list|,
name|PRU_SEND
argument_list|,
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreq
call|)
argument_list|(
name|so
argument_list|,
name|PRU_SEND
argument_list|,
name|m
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|NFSIGNORE_SOERROR
argument_list|(
name|nmp
operator|->
name|nm_soflags
argument_list|,
name|error
argument_list|)
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We need to time the request even though we 				 * are retransmitting. 				 */
name|nmp
operator|->
name|nm_rtt
operator|=
literal|0
expr_stmt|;
name|nmp
operator|->
name|nm_sent
operator|++
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
operator|(
name|R_SENT
operator||
name|R_TIMING
operator|)
expr_stmt|;
name|rep
operator|->
name|r_timer
operator|=
name|rep
operator|->
name|r_timerinit
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|nfs_timer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
operator|/
name|NFS_HZ
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * NFS timer update and backoff. The "Jacobson/Karels/Karn" scheme is  * used here. The timer state is held in the nfsmount structure and  * a single request is used to clock the response. When successful  * the rtt smoothing in nfs_updatetimer is used, when failed the backoff  * is done by nfs_backofftimer. We also log failure messages in these  * routines.  *  * Congestion variables are held in the nfshost structure which  * is referenced by nfsmounts and shared per-server. This separation  * makes it possible to do per-mount timing which allows varying disk  * access times to be dealt with, while preserving a network oriented  * congestion control scheme.  *  * The windowing implements the Jacobson/Karels slowstart algorithm  * with adjusted scaling factors. We start with one request, then send  * 4 more after each success until the ssthresh limit is reached, then  * we increment at a rate proportional to the window. On failure, we  * remember 3/4 the current window and clamp the send limit to 1. Note  * ICMP source quench is not reflected in so->so_error so we ignore that  * for now.  *  * NFS behaves much more like a transport protocol with these changes,  * shedding the teenage pedal-to-the-metal tendencies of "other"  * implementations.  *  * Timers and congestion avoidance by Tom Talpey, Open Software Foundation.  */
end_comment

begin_comment
comment|/*  * The TCP algorithm was not forgiving enough. Because the NFS server  * responds only after performing lookups/diskio/etc, we have to be  * more prepared to accept a spiky variance. The TCP algorithm is:  * TCP_RTO(nmp) ((((nmp)->nm_srtt>> 2) + (nmp)->nm_rttvar)>> 1)  */
end_comment

begin_define
define|#
directive|define
name|NFS_RTO
parameter_list|(
name|nmp
parameter_list|)
value|(((nmp)->nm_srtt>> 3) + (nmp)->nm_rttvar)
end_define

begin_expr_stmt
name|nfs_updatetimer
argument_list|(
name|nmp
argument_list|)
specifier|register
expr|struct
name|nfsmount
operator|*
name|nmp
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* If retransmitted, clear and return */
if|if
condition|(
name|nmp
operator|->
name|nm_rexmit
operator|||
name|nmp
operator|->
name|nm_currexmit
condition|)
block|{
name|nmp
operator|->
name|nm_rexmit
operator|=
name|nmp
operator|->
name|nm_currexmit
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* If have a measurement, do smoothing */
if|if
condition|(
name|nmp
operator|->
name|nm_srtt
condition|)
block|{
specifier|register
name|short
name|delta
decl_stmt|;
name|delta
operator|=
name|nmp
operator|->
name|nm_rtt
operator|-
operator|(
name|nmp
operator|->
name|nm_srtt
operator|>>
literal|3
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_srtt
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|nmp
operator|->
name|nm_srtt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
name|delta
operator|-=
operator|(
name|nmp
operator|->
name|nm_rttvar
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_rttvar
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|nmp
operator|->
name|nm_rttvar
operator|=
literal|1
expr_stmt|;
comment|/* Else initialize */
block|}
else|else
block|{
name|nmp
operator|->
name|nm_rttvar
operator|=
name|nmp
operator|->
name|nm_rtt
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_rttvar
operator|==
literal|0
condition|)
name|nmp
operator|->
name|nm_rttvar
operator|=
literal|2
expr_stmt|;
name|nmp
operator|->
name|nm_srtt
operator|=
name|nmp
operator|->
name|nm_rttvar
operator|<<
literal|2
expr_stmt|;
block|}
comment|/* Compute new Retransmission TimeOut and clip */
name|nmp
operator|->
name|nm_rto
operator|=
name|NFS_RTO
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_rto
operator|<
name|NFS_MINTIMEO
condition|)
name|nmp
operator|->
name|nm_rto
operator|=
name|NFS_MINTIMEO
expr_stmt|;
elseif|else
if|if
condition|(
name|nmp
operator|->
name|nm_rto
operator|>
name|NFS_MAXTIMEO
condition|)
name|nmp
operator|->
name|nm_rto
operator|=
name|NFS_MAXTIMEO
expr_stmt|;
comment|/* Update window estimate */
if|if
condition|(
name|nmp
operator|->
name|nm_window
operator|<
name|nmp
operator|->
name|nm_ssthresh
condition|)
comment|/* quickly */
name|nmp
operator|->
name|nm_window
operator|+=
literal|4
expr_stmt|;
else|else
block|{
comment|/* slowly */
specifier|register
name|long
name|incr
init|=
operator|++
name|nmp
operator|->
name|nm_winext
decl_stmt|;
name|incr
operator|=
operator|(
name|incr
operator|*
name|incr
operator|)
operator|/
name|nmp
operator|->
name|nm_window
expr_stmt|;
if|if
condition|(
name|incr
operator|>
literal|0
condition|)
block|{
name|nmp
operator|->
name|nm_winext
operator|=
literal|0
expr_stmt|;
operator|++
name|nmp
operator|->
name|nm_window
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_window
operator|>
name|NFS_MAXWINDOW
condition|)
name|nmp
operator|->
name|nm_window
operator|=
name|NFS_MAXWINDOW
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|nfs_backofftimer
argument_list|(
name|nmp
argument_list|)
specifier|register
expr|struct
name|nfsmount
operator|*
name|nmp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|long
name|newrto
decl_stmt|;
comment|/* Clip shift count */
if|if
condition|(
operator|++
name|nmp
operator|->
name|nm_rexmit
operator|>
literal|8
operator|*
sizeof|sizeof
name|nmp
operator|->
name|nm_rto
condition|)
name|nmp
operator|->
name|nm_rexmit
operator|=
literal|8
operator|*
sizeof|sizeof
name|nmp
operator|->
name|nm_rto
expr_stmt|;
comment|/* Back off RTO exponentially */
name|newrto
operator|=
name|NFS_RTO
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|newrto
operator|<<=
operator|(
name|nmp
operator|->
name|nm_rexmit
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|newrto
operator|==
literal|0
operator|||
name|newrto
operator|>
name|NFS_MAXTIMEO
condition|)
name|newrto
operator|=
name|NFS_MAXTIMEO
expr_stmt|;
name|nmp
operator|->
name|nm_rto
operator|=
name|newrto
expr_stmt|;
comment|/* If too many retries, message, assume a bogus RTT and re-measure */
if|if
condition|(
name|nmp
operator|->
name|nm_currexmit
operator|<
name|nmp
operator|->
name|nm_rexmit
condition|)
block|{
name|nmp
operator|->
name|nm_currexmit
operator|=
name|nmp
operator|->
name|nm_rexmit
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_currexmit
operator|>=
name|nfsrexmtthresh
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_currexmit
operator|==
name|nfsrexmtthresh
condition|)
block|{
name|nmp
operator|->
name|nm_rttvar
operator|+=
operator|(
name|nmp
operator|->
name|nm_srtt
operator|>>
literal|2
operator|)
expr_stmt|;
name|nmp
operator|->
name|nm_srtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Close down window but remember this point (3/4 current) for later */
name|nmp
operator|->
name|nm_ssthresh
operator|=
operator|(
operator|(
name|nmp
operator|->
name|nm_window
operator|<<
literal|1
operator|)
operator|+
name|nmp
operator|->
name|nm_window
operator|)
operator|>>
literal|2
expr_stmt|;
name|nmp
operator|->
name|nm_window
operator|=
literal|1
expr_stmt|;
name|nmp
operator|->
name|nm_winext
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Test for a termination signal pending on procp.  * This is used for NFSMNT_INT mounts.  */
end_comment

begin_expr_stmt
name|nfs_sigintr
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|p_sig
operator|&&
operator|(
operator|(
operator|(
name|p
operator|->
name|p_sig
operator|&
operator|~
name|p
operator|->
name|p_sigmask
operator|)
operator|&
operator|~
name|p
operator|->
name|p_sigignore
operator|)
operator|&
name|NFSINT_SIGMASK
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Lock a socket against others.  * Necessary for STREAM sockets to ensure you get an entire rpc request/reply  * and also to avoid race conditions between the processes with nfs requests  * in progress when a reconnect is necessary.  */
end_comment

begin_expr_stmt
name|nfs_solock
argument_list|(
name|flagp
argument_list|)
specifier|register
name|int
operator|*
name|flagp
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|flagp
operator|&
name|NFSMNT_SCKLOCK
condition|)
block|{
operator|*
name|flagp
operator||=
name|NFSMNT_WANTSCK
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|flagp
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
literal|"nfsolck"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|flagp
operator||=
name|NFSMNT_SCKLOCK
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Unlock the stream socket for others.  */
end_comment

begin_expr_stmt
name|nfs_sounlock
argument_list|(
name|flagp
argument_list|)
specifier|register
name|int
operator|*
name|flagp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|flagp
operator|&
name|NFSMNT_SCKLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs sounlock"
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator|&=
operator|~
name|NFSMNT_SCKLOCK
expr_stmt|;
if|if
condition|(
operator|*
name|flagp
operator|&
name|NFSMNT_WANTSCK
condition|)
block|{
operator|*
name|flagp
operator|&=
operator|~
name|NFSMNT_WANTSCK
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|flagp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * This function compares two net addresses by family and returns TRUE  * if they are the same.  * If there is any doubt, return FALSE.  */
end_comment

begin_macro
name|nfs_netaddr_match
argument_list|(
argument|nam1
argument_list|,
argument|nam2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|nam1
decl_stmt|,
modifier|*
name|nam2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sockaddr
modifier|*
name|saddr1
decl_stmt|,
modifier|*
name|saddr2
decl_stmt|;
name|saddr1
operator|=
name|mtod
argument_list|(
name|nam1
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
expr_stmt|;
name|saddr2
operator|=
name|mtod
argument_list|(
name|nam2
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|saddr1
operator|->
name|sa_family
operator|!=
name|saddr2
operator|->
name|sa_family
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Must do each address family separately since unused fields 	 * are undefined values and not always zeroed. 	 */
switch|switch
condition|(
name|saddr1
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|saddr1
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|saddr2
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
default|default:
break|break;
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Check the hostname fields for nfsd's mask and match fields.  * By address family:  * - Bitwise AND the mask with the host address field  * - Compare for == with match  * return TRUE if not equal  */
end_comment

begin_expr_stmt
name|nfs_badnam
argument_list|(
name|nam
argument_list|,
name|msk
argument_list|,
name|mtch
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|nam
operator|,
operator|*
name|msk
operator|,
operator|*
name|mtch
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
return|return
operator|(
operator|(
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|&
name|mtod
argument_list|(
name|msk
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|)
operator|!=
name|mtod
argument_list|(
name|mtch
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"nfs_badmatch, unknown sa_family\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
block|}
end_block

end_unit

