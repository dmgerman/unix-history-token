begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * %sccs.include.redist.c%  *  *	@(#)nfs_syscalls.c	8.1 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<nfs/rpcv2.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsv2.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsrvcache.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsmount.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nqnfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsrtt.h>
end_include

begin_comment
comment|/* Global defs. */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|nfs_prog
decl_stmt|,
name|nfs_vers
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|nfsrv_procs
index|[
name|NFS_NPROCS
index|]
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|queue_entry
name|nfs_bufq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|proc
modifier|*
name|nfs_iodwant
index|[
name|NFS_MAXASYNCDAEMON
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfs_numasync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|time_t
name|nqnfsstarttime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsrv_req
name|nsrvq_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsd
name|nfsd_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nqsrv_writeslack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrtton
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfssvc_sock
modifier|*
name|nfs_udpsock
decl_stmt|,
modifier|*
name|nfs_cltpsock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nuidhash_max
init|=
name|NFS_MAXUIDHASH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_numnfsd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsd_waiting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|notstarted
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|modify_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nfsdrt
name|nfsdrt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|nfsrv_cleancache
argument_list|()
decl_stmt|,
name|nfsrv_rcv
argument_list|()
decl_stmt|,
name|nfsrv_wakenfsd
argument_list|()
decl_stmt|,
name|nfs_sndunlock
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|nfsd_rt
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|nfsrv_slpderef
argument_list|()
decl_stmt|,
name|nfsrv_init
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_decl_stmt
specifier|static
name|int
name|nfs_asyncdaemon
index|[
name|NFS_MAXASYNCDAEMON
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * NFS server system calls  * getfh() lives here too, but maybe should move to kern/vfs_syscalls.c  */
end_comment

begin_comment
comment|/*  * Get file handle system call  */
end_comment

begin_struct
struct|struct
name|getfh_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|fhandle_t
modifier|*
name|fhp
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|getfh
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|getfh_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|fhandle_t
name|fh
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
comment|/* 	 * Must be super user 	 */
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|fname
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fh
argument_list|,
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
argument_list|)
expr_stmt|;
name|fh
operator|.
name|fh_fsid
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
expr_stmt|;
name|error
operator|=
name|VFS_VPTOFH
argument_list|(
name|vp
argument_list|,
operator|&
name|fh
operator|.
name|fh_fid
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fh
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|fhp
argument_list|,
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|struct
name|nfssvc_sock
name|nfssvc_sockhead
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SLP_DEREFFREE
value|0x100
end_define

begin_define
define|#
directive|define
name|SLP_CLRFREE
value|0x200
end_define

begin_comment
comment|/*  * Nfs server psuedo system call for the nfsd's  * Based on the flag value it either:  * - adds a socket to the selection list  * - remains in the kernel as an nfsd  * - remains in the kernel as an nfsiod  */
end_comment

begin_struct
struct|struct
name|nfssvc_args
block|{
name|int
name|flag
decl_stmt|;
name|caddr_t
name|argp
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|nfssvc
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|nfssvc_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
name|struct
name|nfsd_args
name|nfsdarg
decl_stmt|;
name|struct
name|nfsd_srvargs
name|nfsd_srvargs
decl_stmt|,
modifier|*
name|nsd
init|=
operator|&
name|nfsd_srvargs
decl_stmt|;
name|struct
name|nfsd_cargs
name|ncd
decl_stmt|;
name|struct
name|nfsd
modifier|*
name|nfsd
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|struct
name|nfsuid
modifier|*
name|nuidp
decl_stmt|,
modifier|*
modifier|*
name|nuh
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Must be super user 	 */
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
while|while
condition|(
name|nfssvc_sockhead
operator|.
name|ns_flag
operator|&
name|SLP_INIT
condition|)
block|{
name|nfssvc_sockhead
operator|.
name|ns_flag
operator||=
name|SLP_WANTINIT
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nfssvc_sockhead
argument_list|,
name|PSOCK
argument_list|,
literal|"nfsd init"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_BIOD
condition|)
name|error
operator|=
name|nfssvc_iod
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_MNTD
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ncd
argument_list|,
sizeof|sizeof
argument_list|(
name|ncd
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|ncd
operator|.
name|ncd_dirp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|nd
operator|.
name|ni_vp
operator|->
name|v_flag
operator|&
name|VROOT
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|nd
operator|.
name|ni_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_MNTD
operator|)
operator|&&
operator|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_GOTAUTH
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nmp
operator|->
name|nm_flag
operator||=
name|NFSMNT_MNTD
expr_stmt|;
name|error
operator|=
name|nqnfs_clientd
argument_list|(
name|nmp
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|ncd
argument_list|,
name|uap
operator|->
name|flag
argument_list|,
name|uap
operator|->
name|argp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_ADDSOCK
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nfsdarg
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsdarg
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|getsock
argument_list|(
name|p
operator|->
name|p_fd
argument_list|,
name|nfsdarg
operator|.
name|sock
argument_list|,
operator|&
name|fp
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Get the client address for connected sockets. 		 */
if|if
condition|(
name|nfsdarg
operator|.
name|name
operator|==
name|NULL
operator|||
name|nfsdarg
operator|.
name|namelen
operator|==
literal|0
condition|)
name|nam
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|=
name|sockargs
argument_list|(
operator|&
name|nam
argument_list|,
name|nfsdarg
operator|.
name|name
argument_list|,
name|nfsdarg
operator|.
name|namelen
argument_list|,
name|MT_SONAME
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfssvc_addsock
argument_list|(
name|fp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
name|nsd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nsd
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_AUTHIN
operator|)
operator|&&
operator|(
name|nfsd
operator|=
name|nsd
operator|->
name|nsd_nfsd
operator|)
operator|&&
operator|(
name|nfsd
operator|->
name|nd_slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
condition|)
block|{
name|slp
operator|=
name|nfsd
operator|->
name|nd_slp
expr_stmt|;
comment|/* 			 * First check to see if another nfsd has already 			 * added this credential. 			 */
name|nuidp
operator|=
name|slp
operator|->
name|ns_uidh
index|[
name|NUIDHASH
argument_list|(
name|nsd
operator|->
name|nsd_uid
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|nuidp
condition|)
block|{
if|if
condition|(
name|nuidp
operator|->
name|nu_uid
operator|==
name|nsd
operator|->
name|nsd_uid
condition|)
break|break;
name|nuidp
operator|=
name|nuidp
operator|->
name|nu_hnext
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nuidp
condition|)
block|{
comment|/* 			     * Nope, so we will. 			     */
if|if
condition|(
name|slp
operator|->
name|ns_numuids
operator|<
name|nuidhash_max
condition|)
block|{
name|slp
operator|->
name|ns_numuids
operator|++
expr_stmt|;
name|nuidp
operator|=
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsuid
argument_list|)
argument_list|,
name|M_NFSUID
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
else|else
name|nuidp
operator|=
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nuidp
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nuidp
argument_list|,
name|M_NFSUID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nuidp
operator|==
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
literal|0
condition|)
block|{
name|nuidp
operator|=
name|slp
operator|->
name|ns_lruprev
expr_stmt|;
name|remque
argument_list|(
name|nuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nuidp
operator|->
name|nu_hprev
condition|)
name|nuidp
operator|->
name|nu_hprev
operator|->
name|nu_hnext
operator|=
name|nuidp
operator|->
name|nu_hnext
expr_stmt|;
if|if
condition|(
name|nuidp
operator|->
name|nu_hnext
condition|)
name|nuidp
operator|->
name|nu_hnext
operator|->
name|nu_hprev
operator|=
name|nuidp
operator|->
name|nu_hprev
expr_stmt|;
block|}
name|nuidp
operator|->
name|nu_cr
operator|=
name|nsd
operator|->
name|nsd_cr
expr_stmt|;
if|if
condition|(
name|nuidp
operator|->
name|nu_cr
operator|.
name|cr_ngroups
operator|>
name|NGROUPS
condition|)
name|nuidp
operator|->
name|nu_cr
operator|.
name|cr_ngroups
operator|=
name|NGROUPS
expr_stmt|;
name|nuidp
operator|->
name|nu_cr
operator|.
name|cr_ref
operator|=
literal|1
expr_stmt|;
name|nuidp
operator|->
name|nu_uid
operator|=
name|nsd
operator|->
name|nsd_uid
expr_stmt|;
name|insque
argument_list|(
name|nuidp
argument_list|,
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
name|slp
argument_list|)
expr_stmt|;
name|nuh
operator|=
operator|&
name|slp
operator|->
name|ns_uidh
index|[
name|NUIDHASH
argument_list|(
name|nsd
operator|->
name|nsd_uid
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|nuidp
operator|->
name|nu_hnext
operator|=
operator|*
name|nuh
condition|)
name|nuidp
operator|->
name|nu_hnext
operator|->
name|nu_hprev
operator|=
name|nuidp
expr_stmt|;
name|nuidp
operator|->
name|nu_hprev
operator|=
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|nuh
operator|=
name|nuidp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_AUTHINFAIL
operator|)
operator|&&
operator|(
name|nfsd
operator|=
name|nsd
operator|->
name|nsd_nfsd
operator|)
condition|)
name|nfsd
operator|->
name|nd_flag
operator||=
name|NFSD_AUTHFAIL
expr_stmt|;
name|error
operator|=
name|nfssvc_nfsd
argument_list|(
name|nsd
argument_list|,
name|uap
operator|->
name|argp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Adds a socket to the list for servicing by nfsds.  */
end_comment

begin_macro
name|nfssvc_addsock
argument_list|(
argument|fp
argument_list|,
argument|mynam
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|mynam
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|siz
decl_stmt|;
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|tslp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|so
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
name|tslp
operator|=
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* 	 * Add it to the list, as required. 	 */
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_UDP
condition|)
block|{
name|tslp
operator|=
name|nfs_udpsock
expr_stmt|;
if|if
condition|(
name|tslp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
condition|)
block|{
name|m_freem
argument_list|(
name|mynam
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ISO
block|}
elseif|else
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|ISOPROTO_CLTP
condition|)
block|{
name|tslp
operator|=
name|nfs_cltpsock
expr_stmt|;
if|if
condition|(
name|tslp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
condition|)
block|{
name|m_freem
argument_list|(
name|mynam
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* ISO */
block|}
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
condition|)
name|siz
operator|=
name|NFS_MAXPACKET
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
else|else
name|siz
operator|=
name|NFS_MAXPACKET
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|siz
argument_list|,
name|siz
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|mynam
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Set protocol specific options { for now TCP only } and 	 * reserve some space. For datagram sockets, this can get called 	 * repeatedly for the same socket, but that isn't harmful. 	 */
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|int
operator|*
argument_list|)
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|AF_INET
operator|&&
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|int
operator|*
argument_list|)
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|TCP_NODELAY
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_NOINTR
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_NOINTR
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tslp
condition|)
name|slp
operator|=
name|tslp
expr_stmt|;
else|else
block|{
name|slp
operator|=
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfssvc_sock
argument_list|)
argument_list|,
name|M_NFSSVC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Alloc nfssvc_sock 0x%x\n"
argument_list|,
name|slp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|slp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfssvc_sock
argument_list|)
argument_list|)
expr_stmt|;
name|slp
operator|->
name|ns_prev
operator|=
name|nfssvc_sockhead
operator|.
name|ns_prev
expr_stmt|;
name|slp
operator|->
name|ns_prev
operator|->
name|ns_next
operator|=
name|slp
expr_stmt|;
name|slp
operator|->
name|ns_next
operator|=
operator|&
name|nfssvc_sockhead
expr_stmt|;
name|nfssvc_sockhead
operator|.
name|ns_prev
operator|=
name|slp
expr_stmt|;
name|slp
operator|->
name|ns_lrunext
operator|=
name|slp
operator|->
name|ns_lruprev
operator|=
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
name|slp
expr_stmt|;
block|}
name|slp
operator|->
name|ns_so
operator|=
name|so
expr_stmt|;
name|slp
operator|->
name|ns_nam
operator|=
name|mynam
expr_stmt|;
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
name|slp
operator|->
name|ns_fp
operator|=
name|fp
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|so
operator|->
name|so_upcallarg
operator|=
operator|(
name|caddr_t
operator|)
name|slp
expr_stmt|;
name|so
operator|->
name|so_upcall
operator|=
name|nfsrv_rcv
expr_stmt|;
name|slp
operator|->
name|ns_flag
operator|=
operator|(
name|SLP_VALID
operator||
name|SLP_NEEDQ
operator|)
expr_stmt|;
name|nfsrv_wakenfsd
argument_list|(
name|slp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Called by nfssvc() for nfsds. Just loops around servicing rpc requests  * until it is killed by a signal.  */
end_comment

begin_macro
name|nfssvc_nfsd
argument_list|(
argument|nsd
argument_list|,
argument|argp
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nfsd_srvargs
modifier|*
name|nsd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|argp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nam2
decl_stmt|;
specifier|register
name|int
name|siz
decl_stmt|;
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
specifier|register
name|int
modifier|*
name|solockp
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|oslp
decl_stmt|;
name|struct
name|nfsd
modifier|*
name|nd
init|=
name|nsd
operator|->
name|nsd_nfsd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|nam
decl_stmt|;
name|struct
name|timeval
name|starttime
decl_stmt|;
name|struct
name|nfsuid
modifier|*
name|uidp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cacherep
decl_stmt|,
name|s
decl_stmt|;
name|int
name|sotype
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|nd
operator|==
operator|(
expr|struct
name|nfsd
operator|*
operator|)
literal|0
condition|)
block|{
name|nsd
operator|->
name|nsd_nfsd
operator|=
name|nd
operator|=
operator|(
expr|struct
name|nfsd
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsd
argument_list|)
argument_list|,
name|M_NFSD
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|nd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsd
argument_list|)
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_procp
operator|=
name|p
expr_stmt|;
name|nd
operator|->
name|nd_cr
operator|.
name|cr_ref
operator|=
literal|1
expr_stmt|;
name|insque
argument_list|(
name|nd
argument_list|,
operator|&
name|nfsd_head
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_nqlflag
operator|=
name|NQL_NOVAL
expr_stmt|;
name|nfs_numnfsd
operator|++
expr_stmt|;
block|}
comment|/* 	 * Loop getting rpc requests until SIGKILL. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|NFSD_REQINPROG
operator|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|nd
operator|->
name|nd_slp
operator|==
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
literal|0
operator|&&
operator|(
name|nfsd_head
operator|.
name|nd_flag
operator|&
name|NFSD_CHECKSLP
operator|)
operator|==
literal|0
condition|)
block|{
name|nd
operator|->
name|nd_flag
operator||=
name|NFSD_WAITING
expr_stmt|;
name|nfsd_waiting
operator|++
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|nd
argument_list|,
name|PSOCK
operator||
name|PCATCH
argument_list|,
literal|"nfsd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nfsd_waiting
operator|--
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_slp
operator|==
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
literal|0
operator|&&
operator|(
name|nfsd_head
operator|.
name|nd_flag
operator|&
name|NFSD_CHECKSLP
operator|)
condition|)
block|{
name|slp
operator|=
name|nfssvc_sockhead
operator|.
name|ns_next
expr_stmt|;
while|while
condition|(
name|slp
operator|!=
operator|&
name|nfssvc_sockhead
condition|)
block|{
if|if
condition|(
operator|(
name|slp
operator|->
name|ns_flag
operator|&
operator|(
name|SLP_VALID
operator||
name|SLP_DOREC
operator|)
operator|)
operator|==
operator|(
name|SLP_VALID
operator||
name|SLP_DOREC
operator|)
condition|)
block|{
name|slp
operator|->
name|ns_flag
operator|&=
operator|~
name|SLP_DOREC
expr_stmt|;
name|slp
operator|->
name|ns_sref
operator|++
expr_stmt|;
name|nd
operator|->
name|nd_slp
operator|=
name|slp
expr_stmt|;
break|break;
block|}
name|slp
operator|=
name|slp
operator|->
name|ns_next
expr_stmt|;
block|}
if|if
condition|(
name|slp
operator|==
operator|&
name|nfssvc_sockhead
condition|)
name|nfsd_head
operator|.
name|nd_flag
operator|&=
operator|~
name|NFSD_CHECKSLP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|slp
operator|=
name|nd
operator|->
name|nd_slp
operator|)
operator|==
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
literal|0
condition|)
continue|continue;
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
condition|)
block|{
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_DISCONN
condition|)
name|nfsrv_zapsock
argument_list|(
name|slp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_NEEDQ
condition|)
block|{
name|slp
operator|->
name|ns_flag
operator|&=
operator|~
name|SLP_NEEDQ
expr_stmt|;
operator|(
name|void
operator|)
name|nfs_sndlock
argument_list|(
operator|&
name|slp
operator|->
name|ns_solock
argument_list|,
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|nfsrv_rcv
argument_list|(
name|slp
operator|->
name|ns_so
argument_list|,
operator|(
name|caddr_t
operator|)
name|slp
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|nfs_sndunlock
argument_list|(
operator|&
name|slp
operator|->
name|ns_solock
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfsrv_dorec
argument_list|(
name|slp
argument_list|,
name|nd
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|NFSD_REQINPROG
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|slp
operator|=
name|nd
operator|->
name|nd_slp
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|||
operator|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|nd
operator|->
name|nd_slp
operator|=
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
literal|0
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator|&=
operator|~
name|NFSD_REQINPROG
expr_stmt|;
name|nfsrv_slpderef
argument_list|(
name|slp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|so
operator|=
name|slp
operator|->
name|ns_so
expr_stmt|;
name|sotype
operator|=
name|so
operator|->
name|so_type
expr_stmt|;
name|starttime
operator|=
name|time
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
name|solockp
operator|=
operator|&
name|slp
operator|->
name|ns_solock
expr_stmt|;
else|else
name|solockp
operator|=
operator|(
name|int
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* 		 * nam == nam2 for connectionless protocols such as UDP 		 * nam2 == NULL for connection based protocols to disable 		 *    recent request caching. 		 */
if|if
condition|(
name|nam2
operator|=
name|nd
operator|->
name|nd_nam
condition|)
block|{
name|nam
operator|=
name|nam2
expr_stmt|;
name|cacherep
operator|=
name|RC_CHECKIT
expr_stmt|;
block|}
else|else
block|{
name|nam
operator|=
name|slp
operator|->
name|ns_nam
expr_stmt|;
name|cacherep
operator|=
name|RC_DOIT
expr_stmt|;
block|}
comment|/* 		 * Check to see if authorization is needed. 		 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|NFSD_NEEDAUTH
condition|)
block|{
specifier|static
name|int
name|logauth
init|=
literal|0
decl_stmt|;
name|nd
operator|->
name|nd_flag
operator|&=
operator|~
name|NFSD_NEEDAUTH
expr_stmt|;
comment|/* 			 * Check for a mapping already installed. 			 */
name|uidp
operator|=
name|slp
operator|->
name|ns_uidh
index|[
name|NUIDHASH
argument_list|(
name|nd
operator|->
name|nd_cr
operator|.
name|cr_uid
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|uidp
condition|)
block|{
if|if
condition|(
name|uidp
operator|->
name|nu_uid
operator|==
name|nd
operator|->
name|nd_cr
operator|.
name|cr_uid
condition|)
break|break;
name|uidp
operator|=
name|uidp
operator|->
name|nu_hnext
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|uidp
condition|)
block|{
name|nsd
operator|->
name|nsd_uid
operator|=
name|nd
operator|->
name|nd_cr
operator|.
name|cr_uid
expr_stmt|;
if|if
condition|(
name|nam2
operator|&&
name|logauth
operator|++
operator|==
literal|0
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Kerberized NFS using UDP\n"
argument_list|)
expr_stmt|;
name|nsd
operator|->
name|nsd_haddr
operator|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|nsd
operator|->
name|nsd_authlen
operator|=
name|nd
operator|->
name|nd_authlen
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|nd
operator|->
name|nd_authstr
argument_list|,
name|nsd
operator|->
name|nsd_authstr
argument_list|,
name|nd
operator|->
name|nd_authlen
argument_list|)
operator|==
literal|0
operator|&&
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|nsd
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nsd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENEEDAUTH
operator|)
return|;
name|cacherep
operator|=
name|RC_DROPIT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cacherep
operator|==
name|RC_CHECKIT
condition|)
name|cacherep
operator|=
name|nfsrv_getcache
argument_list|(
name|nam2
argument_list|,
name|nd
argument_list|,
operator|&
name|mreq
argument_list|)
expr_stmt|;
comment|/* 		 * Check for just starting up for NQNFS and send 		 * fake "try again later" replies to the NQNFS clients. 		 */
if|if
condition|(
name|notstarted
operator|&&
name|nqnfsstarttime
operator|<=
name|time
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
name|modify_flag
condition|)
block|{
name|nqnfsstarttime
operator|=
name|time
operator|.
name|tv_sec
operator|+
name|nqsrv_writeslack
expr_stmt|;
name|modify_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|notstarted
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|notstarted
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_nqlflag
operator|==
name|NQL_NOVAL
condition|)
name|cacherep
operator|=
name|RC_DROPIT
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_WRITE
condition|)
block|{
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|NQNFS_TRYLATER
expr_stmt|;
name|cacherep
operator|=
name|RC_DOIT
expr_stmt|;
block|}
else|else
name|modify_flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|NFSD_AUTHFAIL
condition|)
block|{
name|nd
operator|->
name|nd_flag
operator|&=
operator|~
name|NFSD_AUTHFAIL
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|NQNFS_AUTHERR
expr_stmt|;
name|cacherep
operator|=
name|RC_DOIT
expr_stmt|;
block|}
switch|switch
condition|(
name|cacherep
condition|)
block|{
case|case
name|RC_DOIT
case|:
name|error
operator|=
operator|(
operator|*
operator|(
name|nfsrv_procs
index|[
name|nd
operator|->
name|nd_procnum
index|]
operator|)
operator|)
operator|(
name|nd
operator|,
name|nd
operator|->
name|nd_mrep
operator|,
name|nd
operator|->
name|nd_md
operator|,
name|nd
operator|->
name|nd_dpos
operator|,
operator|&
name|nd
operator|->
name|nd_cr
operator|,
name|nam
operator|,
operator|&
name|mreq
operator|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_cr
operator|.
name|cr_ref
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"nfssvc cref=%d\n"
argument_list|,
name|nd
operator|->
name|nd_cr
operator|.
name|cr_ref
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"nfssvc cref"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|!=
name|NQNFSPROC_VACATED
condition|)
name|nfsstats
operator|.
name|srv_errs
operator|++
expr_stmt|;
if|if
condition|(
name|nam2
condition|)
block|{
name|nfsrv_updatecache
argument_list|(
name|nam2
argument_list|,
name|nd
argument_list|,
name|FALSE
argument_list|,
name|mreq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|nam2
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|nfsstats
operator|.
name|srvrpccnt
index|[
name|nd
operator|->
name|nd_procnum
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|nam2
condition|)
name|nfsrv_updatecache
argument_list|(
name|nam2
argument_list|,
name|nd
argument_list|,
name|TRUE
argument_list|,
name|mreq
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
case|case
name|RC_REPLY
case|:
name|m
operator|=
name|mreq
expr_stmt|;
name|siz
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|siz
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|siz
operator|<=
literal|0
operator|||
name|siz
operator|>
name|NFS_MAXPACKET
condition|)
block|{
name|printf
argument_list|(
literal|"mbuf siz=%d\n"
argument_list|,
name|siz
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Bad nfs svc reply"
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|mreq
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|siz
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* 			 * For stream protocols, prepend a Sun RPC 			 * Record Mark. 			 */
if|if
condition|(
name|sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|NFSX_UNSIGNED
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_long
operator|*
argument_list|)
operator|=
name|htonl
argument_list|(
literal|0x80000000
operator||
name|siz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|solockp
condition|)
operator|(
name|void
operator|)
name|nfs_sndlock
argument_list|(
name|solockp
argument_list|,
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
condition|)
name|error
operator|=
name|nfs_send
argument_list|(
name|so
argument_list|,
name|nam2
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|error
operator|=
name|EPIPE
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfsrtton
condition|)
name|nfsd_rt
argument_list|(
operator|&
name|starttime
argument_list|,
name|sotype
argument_list|,
name|nd
argument_list|,
name|nam
argument_list|,
name|cacherep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nam2
condition|)
name|MFREE
argument_list|(
name|nam2
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_mrep
condition|)
name|m_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EPIPE
condition|)
name|nfsrv_zapsock
argument_list|(
name|slp
argument_list|)
expr_stmt|;
if|if
condition|(
name|solockp
condition|)
name|nfs_sndunlock
argument_list|(
name|solockp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
block|{
name|nfsrv_slpderef
argument_list|(
name|slp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|RC_DROPIT
case|:
if|if
condition|(
name|nfsrtton
condition|)
name|nfsd_rt
argument_list|(
operator|&
name|starttime
argument_list|,
name|sotype
argument_list|,
name|nd
argument_list|,
name|nam
argument_list|,
name|cacherep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|nam2
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|nfsrv_dorec
argument_list|(
name|slp
argument_list|,
name|nd
argument_list|)
condition|)
block|{
name|nd
operator|->
name|nd_flag
operator|&=
operator|~
name|NFSD_REQINPROG
expr_stmt|;
name|nd
operator|->
name|nd_slp
operator|=
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
literal|0
expr_stmt|;
name|nfsrv_slpderef
argument_list|(
name|slp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|p
operator|->
name|p_spare
index|[
literal|0
index|]
condition|)
name|panic
argument_list|(
literal|"nfssvc: M_NAMEI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_spare
index|[
literal|1
index|]
condition|)
name|panic
argument_list|(
literal|"nfssvc: STARTSAVE"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|done
label|:
name|remque
argument_list|(
name|nd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nd
argument_list|,
name|M_NFSD
argument_list|)
expr_stmt|;
name|nsd
operator|->
name|nsd_nfsd
operator|=
operator|(
expr|struct
name|nfsd
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|nfs_numnfsd
operator|==
literal|0
condition|)
name|nfsrv_init
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Reinitialize everything */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Asynchronous I/O daemons for client nfs.  * They do read-ahead and write-behind operations on the block I/O cache.  * Never returns unless it fails or gets killed.  */
end_comment

begin_macro
name|nfssvc_iod
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|myiod
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Assign my position or return error if too many already running 	 */
name|myiod
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFS_MAXASYNCDAEMON
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nfs_asyncdaemon
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|nfs_asyncdaemon
index|[
name|i
index|]
operator|++
expr_stmt|;
name|myiod
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|myiod
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|nfs_numasync
operator|++
expr_stmt|;
comment|/* 	 * Just loop around doin our stuff until SIGKILL 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|nfs_bufq
operator|.
name|qe_next
operator|==
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|nfs_iodwant
index|[
name|myiod
index|]
operator|=
name|p
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nfs_iodwant
index|[
name|myiod
index|]
argument_list|,
name|PWAIT
operator||
name|PCATCH
argument_list|,
literal|"nfsidl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|bp
operator|=
name|nfs_bufq
operator|.
name|qe_next
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Take one off the front of the list */
name|queue_remove
argument_list|(
operator|&
name|nfs_bufq
argument_list|,
name|bp
argument_list|,
expr|struct
name|buf
operator|*
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
operator|(
name|void
operator|)
name|nfs_doio
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_rcred
argument_list|,
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|nfs_doio
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_wcred
argument_list|,
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|nfs_asyncdaemon
index|[
name|myiod
index|]
operator|=
literal|0
expr_stmt|;
name|nfs_numasync
operator|--
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Shut down a socket associated with an nfssvc_sock structure.  * Should be called with the send lock set, if required.  * The trick here is to increment the sref at the start, so that the nfsds  * will stop using it and clear ns_flag at the end so that it will not be  * reassigned during cleanup.  */
end_comment

begin_expr_stmt
name|nfsrv_zapsock
argument_list|(
name|slp
argument_list|)
specifier|register
expr|struct
name|nfssvc_sock
operator|*
name|slp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|nfsuid
modifier|*
name|nuidp
decl_stmt|,
modifier|*
name|onuidp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|slp
operator|->
name|ns_flag
operator|&=
operator|~
name|SLP_ALLFLAGS
expr_stmt|;
if|if
condition|(
name|fp
operator|=
name|slp
operator|->
name|ns_fp
condition|)
block|{
name|slp
operator|->
name|ns_fp
operator|=
operator|(
expr|struct
name|file
operator|*
operator|)
literal|0
expr_stmt|;
name|so
operator|=
name|slp
operator|->
name|ns_so
expr_stmt|;
name|so
operator|->
name|so_upcall
operator|=
name|NULL
expr_stmt|;
name|soshutdown
argument_list|(
name|so
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|closef
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|slp
operator|->
name|ns_nam
condition|)
name|MFREE
argument_list|(
name|slp
operator|->
name|ns_nam
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|slp
operator|->
name|ns_raw
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|slp
operator|->
name|ns_rec
argument_list|)
expr_stmt|;
name|nuidp
operator|=
name|slp
operator|->
name|ns_lrunext
expr_stmt|;
while|while
condition|(
name|nuidp
operator|!=
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
name|slp
condition|)
block|{
name|onuidp
operator|=
name|nuidp
expr_stmt|;
name|nuidp
operator|=
name|nuidp
operator|->
name|nu_lrunext
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|onuidp
argument_list|,
name|M_NFSUID
argument_list|)
expr_stmt|;
block|}
name|slp
operator|->
name|ns_lrunext
operator|=
name|slp
operator|->
name|ns_lruprev
operator|=
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
name|slp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUIDHASHSIZ
condition|;
name|i
operator|++
control|)
name|slp
operator|->
name|ns_uidh
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Get an authorization string for the uid by having the mount_nfs sitting  * on this mount point porpous out of the kernel and do it.  */
end_comment

begin_expr_stmt
name|nfs_getauth
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|,
name|cred
argument_list|,
name|auth_type
argument_list|,
name|auth_str
argument_list|,
name|auth_len
argument_list|)
specifier|register
expr|struct
name|nfsmount
operator|*
name|nmp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|auth_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|auth_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|auth_len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_WAITAUTH
operator|)
operator|==
literal|0
condition|)
block|{
name|nmp
operator|->
name|nm_flag
operator||=
name|NFSMNT_WANTAUTH
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_authtype
argument_list|,
name|PSOCK
argument_list|,
literal|"nfsauth1"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|nfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|,
name|rep
operator|->
name|r_procp
argument_list|)
condition|)
block|{
name|nmp
operator|->
name|nm_flag
operator|&=
operator|~
name|NFSMNT_WANTAUTH
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|nmp
operator|->
name|nm_flag
operator|&=
operator|~
operator|(
name|NFSMNT_WAITAUTH
operator||
name|NFSMNT_WANTAUTH
operator|)
expr_stmt|;
name|nmp
operator|->
name|nm_authstr
operator|=
operator|*
name|auth_str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|RPCAUTH_MAXSIZ
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_authuid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_authstr
argument_list|)
expr_stmt|;
comment|/* 	 * And wait for mount_nfs to do its stuff. 	 */
while|while
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_HASAUTH
operator|)
operator|==
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_authlen
argument_list|,
name|PSOCK
argument_list|,
literal|"nfsauth2"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|,
name|rep
operator|->
name|r_procp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_AUTHERR
condition|)
block|{
name|nmp
operator|->
name|nm_flag
operator|&=
operator|~
name|NFSMNT_AUTHERR
expr_stmt|;
name|error
operator|=
name|EAUTH
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
operator|*
name|auth_str
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|auth_type
operator|=
name|nmp
operator|->
name|nm_authtype
expr_stmt|;
operator|*
name|auth_len
operator|=
name|nmp
operator|->
name|nm_authlen
expr_stmt|;
block|}
name|nmp
operator|->
name|nm_flag
operator|&=
operator|~
name|NFSMNT_HASAUTH
expr_stmt|;
name|nmp
operator|->
name|nm_flag
operator||=
name|NFSMNT_WAITAUTH
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_WANTAUTH
condition|)
block|{
name|nmp
operator|->
name|nm_flag
operator|&=
operator|~
name|NFSMNT_WANTAUTH
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_authtype
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Derefence a server socket structure. If it has no more references and  * is no longer valid, you can throw it away.  */
end_comment

begin_function
name|void
name|nfsrv_slpderef
parameter_list|(
name|slp
parameter_list|)
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
block|{
if|if
condition|(
operator|--
operator|(
name|slp
operator|->
name|ns_sref
operator|)
operator|==
literal|0
operator|&&
operator|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NOTYET
name|slp
operator|->
name|ns_prev
operator|->
name|ns_next
operator|=
name|slp
operator|->
name|ns_next
expr_stmt|;
name|slp
operator|->
name|ns_next
operator|->
name|ns_prev
operator|=
name|slp
operator|->
name|ns_prev
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|slp
argument_list|,
name|M_NFSSVC
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_DEREFFREE
condition|)
name|panic
argument_list|(
literal|"deref dup free 0x%x of deref free\n"
argument_list|,
name|slp
argument_list|)
expr_stmt|;
else|else
block|{
name|slp
operator|->
name|ns_prev
operator|->
name|ns_next
operator|=
name|slp
operator|->
name|ns_next
expr_stmt|;
name|slp
operator|->
name|ns_next
operator|->
name|ns_prev
operator|=
name|slp
operator|->
name|ns_prev
expr_stmt|;
block|}
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_CLRFREE
condition|)
name|panic
argument_list|(
literal|"deref dup free 0x%x of clrall free\n"
argument_list|,
name|slp
argument_list|)
expr_stmt|;
name|slp
operator|->
name|ns_flag
operator||=
name|SLP_DEREFFREE
expr_stmt|;
name|printf
argument_list|(
literal|"Free deref sock 0x%x\n"
argument_list|,
name|slp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the data structures for the server.  * Handshake with any new nfsds starting up to avoid any chance of  * corruption.  */
end_comment

begin_function
name|void
name|nfsrv_init
parameter_list|(
name|terminating
parameter_list|)
name|int
name|terminating
decl_stmt|;
block|{
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|oslp
decl_stmt|;
if|if
condition|(
name|nfssvc_sockhead
operator|.
name|ns_flag
operator|&
name|SLP_INIT
condition|)
name|panic
argument_list|(
literal|"nfsd init"
argument_list|)
expr_stmt|;
name|nfssvc_sockhead
operator|.
name|ns_flag
operator||=
name|SLP_INIT
expr_stmt|;
if|if
condition|(
name|terminating
condition|)
block|{
name|slp
operator|=
name|nfssvc_sockhead
operator|.
name|ns_next
expr_stmt|;
while|while
condition|(
name|slp
operator|!=
operator|&
name|nfssvc_sockhead
condition|)
block|{
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
condition|)
name|nfsrv_zapsock
argument_list|(
name|slp
argument_list|)
expr_stmt|;
name|slp
operator|->
name|ns_next
operator|->
name|ns_prev
operator|=
name|slp
operator|->
name|ns_prev
expr_stmt|;
name|slp
operator|->
name|ns_prev
operator|->
name|ns_next
operator|=
name|slp
operator|->
name|ns_next
expr_stmt|;
name|oslp
operator|=
name|slp
expr_stmt|;
name|slp
operator|=
name|slp
operator|->
name|ns_next
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTYET
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|oslp
argument_list|,
name|M_NFSSVC
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|oslp
operator|->
name|ns_flag
operator|&
name|SLP_DEREFFREE
condition|)
name|panic
argument_list|(
literal|"clrall dup free 0x%x of deref free\n"
argument_list|,
name|oslp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oslp
operator|->
name|ns_flag
operator|&
name|SLP_CLRFREE
condition|)
name|panic
argument_list|(
literal|"clrall dup free 0x%x of clrall free\n"
argument_list|,
name|oslp
argument_list|)
expr_stmt|;
name|oslp
operator|->
name|ns_flag
operator||=
name|SLP_CLRFREE
expr_stmt|;
name|printf
argument_list|(
literal|"Free all socks 0x%x\n"
argument_list|,
name|oslp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|nfsrv_cleancache
argument_list|()
expr_stmt|;
comment|/* And clear out server cache */
block|}
name|nfs_udpsock
operator|=
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfssvc_sock
argument_list|)
argument_list|,
name|M_NFSSVC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Alloc nfs_udpsock 0x%x\n"
argument_list|,
name|nfs_udpsock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfs_udpsock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfssvc_sock
argument_list|)
argument_list|)
expr_stmt|;
name|nfs_cltpsock
operator|=
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfssvc_sock
argument_list|)
argument_list|,
name|M_NFSSVC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Alloc nfs_cltpsock 0x%x\n"
argument_list|,
name|nfs_cltpsock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfs_cltpsock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfssvc_sock
argument_list|)
argument_list|)
expr_stmt|;
name|nfssvc_sockhead
operator|.
name|ns_next
operator|=
name|nfs_udpsock
expr_stmt|;
name|nfs_udpsock
operator|->
name|ns_next
operator|=
name|nfs_cltpsock
expr_stmt|;
name|nfs_cltpsock
operator|->
name|ns_next
operator|=
operator|&
name|nfssvc_sockhead
expr_stmt|;
name|nfssvc_sockhead
operator|.
name|ns_prev
operator|=
name|nfs_cltpsock
expr_stmt|;
name|nfs_cltpsock
operator|->
name|ns_prev
operator|=
name|nfs_udpsock
expr_stmt|;
name|nfs_udpsock
operator|->
name|ns_prev
operator|=
operator|&
name|nfssvc_sockhead
expr_stmt|;
name|nfs_udpsock
operator|->
name|ns_lrunext
operator|=
name|nfs_udpsock
operator|->
name|ns_lruprev
operator|=
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
name|nfs_udpsock
expr_stmt|;
name|nfs_cltpsock
operator|->
name|ns_lrunext
operator|=
name|nfs_cltpsock
operator|->
name|ns_lruprev
operator|=
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
name|nfs_cltpsock
expr_stmt|;
name|nfsd_head
operator|.
name|nd_next
operator|=
name|nfsd_head
operator|.
name|nd_prev
operator|=
operator|&
name|nfsd_head
expr_stmt|;
name|nfsd_head
operator|.
name|nd_flag
operator|=
literal|0
expr_stmt|;
name|nfssvc_sockhead
operator|.
name|ns_flag
operator|&=
operator|~
name|SLP_INIT
expr_stmt|;
if|if
condition|(
name|nfssvc_sockhead
operator|.
name|ns_flag
operator|&
name|SLP_WANTINIT
condition|)
block|{
name|nfssvc_sockhead
operator|.
name|ns_flag
operator|&=
operator|~
name|SLP_WANTINIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nfssvc_sockhead
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add entries to the server monitor log.  */
end_comment

begin_function
specifier|static
name|void
name|nfsd_rt
parameter_list|(
name|startp
parameter_list|,
name|sotype
parameter_list|,
name|nd
parameter_list|,
name|nam
parameter_list|,
name|cacherep
parameter_list|)
name|struct
name|timeval
modifier|*
name|startp
decl_stmt|;
name|int
name|sotype
decl_stmt|;
specifier|register
name|struct
name|nfsd
modifier|*
name|nd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
name|int
name|cacherep
decl_stmt|;
block|{
specifier|register
name|struct
name|drt
modifier|*
name|rt
decl_stmt|;
name|rt
operator|=
operator|&
name|nfsdrt
operator|.
name|drt
index|[
name|nfsdrt
operator|.
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|cacherep
operator|==
name|RC_DOIT
condition|)
name|rt
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cacherep
operator|==
name|RC_REPLY
condition|)
name|rt
operator|->
name|flag
operator|=
name|DRT_CACHEREPLY
expr_stmt|;
else|else
name|rt
operator|->
name|flag
operator|=
name|DRT_CACHEDROP
expr_stmt|;
if|if
condition|(
name|sotype
operator|==
name|SOCK_STREAM
condition|)
name|rt
operator|->
name|flag
operator||=
name|DRT_TCP
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_nqlflag
operator|!=
name|NQL_NOVAL
condition|)
name|rt
operator|->
name|flag
operator||=
name|DRT_NQNFS
expr_stmt|;
name|rt
operator|->
name|proc
operator|=
name|nd
operator|->
name|nd_procnum
expr_stmt|;
if|if
condition|(
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|rt
operator|->
name|ipadr
operator|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
else|else
name|rt
operator|->
name|ipadr
operator|=
name|INADDR_ANY
expr_stmt|;
name|rt
operator|->
name|resptime
operator|=
operator|(
operator|(
name|time
operator|.
name|tv_sec
operator|-
name|startp
operator|->
name|tv_sec
operator|)
operator|*
literal|1000000
operator|)
operator|+
operator|(
name|time
operator|.
name|tv_usec
operator|-
name|startp
operator|->
name|tv_usec
operator|)
expr_stmt|;
name|rt
operator|->
name|tstamp
operator|=
name|time
expr_stmt|;
name|nfsdrt
operator|.
name|pos
operator|=
operator|(
name|nfsdrt
operator|.
name|pos
operator|+
literal|1
operator|)
operator|%
name|NFSRTTLOGSIZ
expr_stmt|;
block|}
end_function

end_unit

