begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/* $Header: /var/src/sys/netiso/RCS/clnp_subr.c,v 5.1 89/02/09 16:20:46 hagens Exp $ */
end_comment

begin_comment
comment|/* $Source: /var/src/sys/netiso/RCS/clnp_subr.c,v $ */
end_comment

begin_comment
comment|/*	@(#)clnp_subr.c	7.8 (Berkeley) %G% */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /var/src/sys/netiso/RCS/clnp_subr.c,v 5.1 89/02/09 16:20:46 hagens Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"iso_var.h"
end_include

begin_include
include|#
directive|include
file|"iso_pcb.h"
end_include

begin_include
include|#
directive|include
file|"iso_snpac.h"
end_include

begin_include
include|#
directive|include
file|"clnp.h"
end_include

begin_include
include|#
directive|include
file|"clnp_stat.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_comment
comment|/*  * FUNCTION:		clnp_data_ck  *  * PURPOSE:			Check that the amount of data in the mbuf chain is  *					at least as much as the clnp header would have us  *					expect. Trim mbufs if longer than expected, drop  *					packet if shorter than expected.  *  * RETURNS:			success - ptr to mbuf chain  *					failure - 0  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|clnp_data_ck
parameter_list|(
name|m
parameter_list|,
name|length
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* ptr to mbuf chain containing hdr& data */
name|int
name|length
decl_stmt|;
comment|/* length (in bytes) of packet */
block|{
specifier|register
name|int
name|len
decl_stmt|;
comment|/* length of data */
specifier|register
name|struct
name|mbuf
modifier|*
name|mhead
decl_stmt|;
comment|/* ptr to head of chain */
name|len
operator|=
operator|-
name|length
expr_stmt|;
name|mhead
operator|=
name|m
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
literal|0
condition|)
break|break;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|INCSTAT
argument_list|(
name|cns_toosmall
argument_list|)
expr_stmt|;
name|clnp_discard
argument_list|(
name|mhead
argument_list|,
name|GEN_INCOMPLETE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|len
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_len
operator|-=
name|len
expr_stmt|;
else|else
name|m_adj
argument_list|(
name|mhead
argument_list|,
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|mhead
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ndef
end_ifdef

begin_comment
comment|/*  * FUNCTION:		clnp_extract_addr  *  * PURPOSE:			Extract the source and destination address from the  *					supplied buffer. Place them in the supplied address buffers.  *					If insufficient data is supplied, then fail.  *  * RETURNS:			success - Address of first byte in the packet past   *						the address part.  *					failure - 0  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|caddr_t
name|clnp_extract_addr
parameter_list|(
name|bufp
parameter_list|,
name|buflen
parameter_list|,
name|srcp
parameter_list|,
name|destp
parameter_list|)
name|caddr_t
name|bufp
decl_stmt|;
comment|/* ptr to buffer containing addresses */
name|int
name|buflen
decl_stmt|;
comment|/* length of buffer */
specifier|register
name|struct
name|iso_addr
modifier|*
name|srcp
decl_stmt|;
comment|/* ptr to source address buffer */
specifier|register
name|struct
name|iso_addr
modifier|*
name|destp
decl_stmt|;
comment|/* ptr to destination address buffer */
block|{
name|int
name|len
decl_stmt|;
comment|/* argument to bcopy */
comment|/*  	 *	check that we have enough data. Plus1 is for length octet 	 */
if|if
condition|(
operator|(
name|u_char
operator|)
operator|*
name|bufp
operator|+
literal|1
operator|>
name|buflen
condition|)
block|{
return|return
operator|(
operator|(
name|caddr_t
operator|)
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|destp
operator|->
name|isoa_len
operator|=
operator|(
name|u_char
operator|)
operator|*
name|bufp
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|bufp
argument_list|,
operator|(
name|caddr_t
operator|)
name|destp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buflen
operator|-=
name|len
expr_stmt|;
name|bufp
operator|+=
name|len
expr_stmt|;
comment|/*  	 *	check that we have enough data. Plus1 is for length octet 	 */
if|if
condition|(
operator|(
name|u_char
operator|)
operator|*
name|bufp
operator|+
literal|1
operator|>
name|buflen
condition|)
block|{
return|return
operator|(
operator|(
name|caddr_t
operator|)
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|srcp
operator|->
name|isoa_len
operator|=
operator|(
name|u_char
operator|)
operator|*
name|bufp
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|bufp
argument_list|,
operator|(
name|caddr_t
operator|)
name|srcp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|len
expr_stmt|;
comment|/* 	 *	Insure that the addresses make sense 	 */
if|if
condition|(
name|iso_ck_addr
argument_list|(
name|srcp
argument_list|)
operator|&&
name|iso_ck_addr
argument_list|(
name|destp
argument_list|)
condition|)
return|return
name|bufp
return|;
else|else
return|return
operator|(
name|caddr_t
operator|)
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|ndef
end_endif

begin_comment
comment|/*  * FUNCTION:		clnp_ours  *  * PURPOSE:			Decide whether the supplied packet is destined for  *					us, or that it should be forwarded on.  *  * RETURNS:			packet is for us - 1  *					packet is not for us - 0  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_expr_stmt
name|clnp_ours
argument_list|(
name|dst
argument_list|)
specifier|register
expr|struct
name|iso_addr
operator|*
name|dst
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ptr to destination address */
end_comment

begin_block
block|{
specifier|register
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
comment|/* scan through interface addresses */
for|for
control|(
name|ia
operator|=
name|iso_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"clnp_ours: ia_sis x%x, dst x%x\n"
argument_list|,
operator|&
name|IA_SIS
argument_list|(
name|ia
argument_list|)
operator|->
name|siso_addr
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* PHASE 2: uses iso_addrmatch& mask from iso_ifaddr */
if|if
condition|(
name|iso_addrmatch1
argument_list|(
operator|&
name|IA_SIS
argument_list|(
name|ia
argument_list|)
operator|->
name|siso_addr
argument_list|,
name|dst
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Dec bit set if ifp qlen is greater than congest_threshold */
end_comment

begin_decl_stmt
name|int
name|congest_threshold
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FUNCTION:		clnp_forward  *  * PURPOSE:			Forward the datagram passed  *					clnpintr guarantees that the header will be  *					contigious (a cluster mbuf will be used if necessary).  *  *					If oidx is NULL, no options are present.  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|clnp_forward
argument_list|(
argument|m
argument_list|,
argument|len
argument_list|,
argument|dst
argument_list|,
argument|oidx
argument_list|,
argument|seg_off
argument_list|,
argument|inbound_shp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pkt to forward */
end_comment

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of pkt */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* destination address */
end_comment

begin_decl_stmt
name|struct
name|clnp_optidx
modifier|*
name|oidx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* option index */
end_comment

begin_decl_stmt
name|int
name|seg_off
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offset of segmentation part */
end_comment

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|inbound_shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subnetwork header of inbound packet */
end_comment

begin_block
block|{
name|struct
name|clnp_fixed
modifier|*
name|clnp
decl_stmt|;
comment|/* ptr to fixed part of header */
name|int
name|error
decl_stmt|;
comment|/* return value of route function */
name|struct
name|sockaddr
modifier|*
name|next_hop
decl_stmt|;
comment|/* next hop for dgram */
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* ptr to outgoing interface */
name|struct
name|iso_ifaddr
modifier|*
name|ia
init|=
literal|0
decl_stmt|;
comment|/* ptr to iso name for ifp */
name|struct
name|route_iso
name|route
decl_stmt|;
comment|/* filled in by clnp_route */
specifier|extern
name|int
name|iso_systype
decl_stmt|;
name|clnp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnp_fixed
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|route
argument_list|,
sizeof|sizeof
argument_list|(
name|route
argument_list|)
argument_list|)
expr_stmt|;
comment|/* MUST be done before "bad:" */
comment|/* 	 *	Don't forward multicast or broadcast packets 	 */
if|if
condition|(
operator|(
name|inbound_shp
operator|)
operator|&&
operator|(
name|IS_MULTICAST
argument_list|(
name|inbound_shp
operator|->
name|snh_dhost
argument_list|)
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_FORWARD
argument_list|)
name|printf
argument_list|(
literal|"clnp_forward: dropping multicast packet\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|clnp
operator|->
name|cnf_type
operator|&=
operator|~
name|CNF_ERR_OK
expr_stmt|;
comment|/* so we don't generate an ER */
name|clnp_discard
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INCSTAT
argument_list|(
name|cns_cantforward
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|IFDEBUG
argument_list|(
argument|D_FORWARD
argument_list|)
name|printf
argument_list|(
literal|"clnp_forward: %d bytes, to %s, options x%x\n"
argument_list|,
name|len
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|dst
argument_list|)
argument_list|,
name|oidx
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	Decrement ttl, and if zero drop datagram 	 *	Can't compare ttl as less than zero 'cause its a unsigned 	 */
if|if
condition|(
operator|(
name|clnp
operator|->
name|cnf_ttl
operator|==
literal|0
operator|)
operator|||
operator|(
operator|--
name|clnp
operator|->
name|cnf_ttl
operator|==
literal|0
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_FORWARD
argument_list|)
name|printf
argument_list|(
literal|"clnp_forward: discarding datagram because ttl is zero\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|INCSTAT
parameter_list|(
name|cns_ttlexpired
parameter_list|)
function_decl|;
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|TTL_EXPTRANSIT
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 *	Route packet; special case for source rt 	 */
if|if CLNPSRCRT_VALID
condition|(
name|oidx
condition|)
block|{
comment|/* 		 *	Update src route first 		 */
name|clnp_update_srcrt
argument_list|(
name|m
argument_list|,
name|oidx
argument_list|)
expr_stmt|;
name|error
operator|=
name|clnp_srcroute
argument_list|(
name|m
argument_list|,
name|oidx
argument_list|,
operator|&
name|route
argument_list|,
operator|&
name|next_hop
argument_list|,
operator|&
name|ia
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|clnp_route
argument_list|(
name|dst
argument_list|,
operator|&
name|route
argument_list|,
literal|0
argument_list|,
operator|&
name|next_hop
argument_list|,
operator|&
name|ia
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|||
name|ia
operator|==
literal|0
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_FORWARD
argument_list|)
name|printf
argument_list|(
literal|"clnp_forward: can't route packet (errno %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|clnp_discard
parameter_list|(
name|m
parameter_list|,
name|ADDR_DESTUNREACH
parameter_list|)
function_decl|;
name|INCSTAT
argument_list|(
name|cns_cantforward
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ifp
operator|=
name|ia
operator|->
name|ia_ifp
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_FORWARD
argument_list|)
name|printf
argument_list|(
literal|"clnp_forward: packet routed to %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|next_hop
operator|)
operator|->
name|siso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|INCSTAT
parameter_list|(
name|cns_forward
parameter_list|)
function_decl|;
comment|/* 	 *	If we are an intermediate system and 	 *	we are routing outbound on the same ifp that the packet 	 *	arrived upon, and we know the next hop snpa,  	 *	then generate a redirect request 	 */
if|if
condition|(
operator|(
name|iso_systype
operator|&
name|SNPA_IS
operator|)
operator|&&
operator|(
name|inbound_shp
operator|)
operator|&&
operator|(
name|ifp
operator|==
name|inbound_shp
operator|->
name|snh_ifp
operator|)
condition|)
block|{
name|struct
name|snpa_cache
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|snpac_look
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|next_hop
operator|)
operator|->
name|siso_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|esis_rdoutput
argument_list|(
name|inbound_shp
argument_list|,
name|m
argument_list|,
name|oidx
argument_list|,
name|dst
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 *	If options are present, update them 	 */
if|if
condition|(
name|oidx
condition|)
block|{
name|struct
name|iso_addr
modifier|*
name|mysrc
init|=
operator|&
name|ia
operator|->
name|ia_addr
operator|.
name|siso_addr
decl_stmt|;
if|if
condition|(
name|mysrc
operator|==
name|NULL
condition|)
block|{
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|ADDR_DESTUNREACH
argument_list|)
expr_stmt|;
name|INCSTAT
argument_list|(
name|cns_cantforward
argument_list|)
expr_stmt|;
name|clnp_stat
operator|.
name|cns_forward
operator|--
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|clnp_dooptions
argument_list|(
name|m
argument_list|,
name|oidx
argument_list|,
name|ifp
argument_list|,
name|mysrc
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DECBIT
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_len
operator|>
name|congest_threshold
condition|)
block|{
comment|/* 		 *	Congestion! Set the Dec Bit and thank Dave Oran 		 */
name|IFDEBUG
argument_list|(
argument|D_FORWARD
argument_list|)
name|printf
argument_list|(
literal|"clnp_forward: congestion experienced\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|oidx
operator|)
operator|&&
operator|(
name|oidx
operator|->
name|cni_qos_formatp
operator|)
condition|)
block|{
name|caddr_t
name|qosp
init|=
name|CLNP_OFFTOOPT
argument_list|(
name|m
argument_list|,
name|oidx
operator|->
name|cni_qos_formatp
argument_list|)
decl_stmt|;
name|u_char
name|qos
init|=
operator|*
name|qosp
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_FORWARD
argument_list|)
name|printf
argument_list|(
literal|"clnp_forward: setting congestion bit (qos x%x)\n"
argument_list|,
name|qos
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|qos
operator|&
name|CLNPOVAL_GLOBAL
operator|)
operator|==
name|CLNPOVAL_GLOBAL
condition|)
block|{
name|qos
operator||=
name|CLNPOVAL_CONGESTED
expr_stmt|;
name|INCSTAT
argument_list|(
name|cns_congest_set
argument_list|)
expr_stmt|;
operator|*
name|qosp
operator|=
name|qos
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
endif|DECBIT
comment|/* 	 *	Dispatch the datagram if it is small enough, otherwise fragment 	 */
if|if
condition|(
name|len
operator|<=
name|SN_MTU
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|iso_gen_csum
argument_list|(
name|m
argument_list|,
name|CLNP_CKSUM_OFF
argument_list|,
operator|(
name|int
operator|)
name|clnp
operator|->
name|cnf_hdr_len
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|ifp
operator|->
name|if_output
argument_list|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|next_hop
argument_list|,
name|route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|clnp_fragment
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|next_hop
argument_list|,
name|len
argument_list|,
name|seg_off
argument_list|,
comment|/* flags */
literal|0
argument_list|,
name|route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* 	 *	Free route 	 */
if|if
condition|(
name|route
operator|.
name|ro_rt
operator|!=
name|NULL
condition|)
block|{
name|RTFREE
argument_list|(
name|route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|ndef
end_ifdef

begin_comment
comment|/*  * FUNCTION:		clnp_insert_addr  *  * PURPOSE:			Insert the address part into a clnp datagram.  *  * RETURNS:			Address of first byte after address part in datagram.  *  * SIDE EFFECTS:	  *  * NOTES:			Assume that there is enough space for the address part.  */
end_comment

begin_function
name|caddr_t
name|clnp_insert_addr
parameter_list|(
name|bufp
parameter_list|,
name|srcp
parameter_list|,
name|dstp
parameter_list|)
name|caddr_t
name|bufp
decl_stmt|;
comment|/* address of where addr part goes */
specifier|register
name|struct
name|iso_addr
modifier|*
name|srcp
decl_stmt|;
comment|/* ptr to src addr */
specifier|register
name|struct
name|iso_addr
modifier|*
name|dstp
decl_stmt|;
comment|/* ptr to dst addr */
block|{
operator|*
name|bufp
operator|++
operator|=
name|dstp
operator|->
name|isoa_len
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|dstp
argument_list|,
name|bufp
argument_list|,
name|dstp
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|dstp
operator|->
name|isoa_len
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|srcp
operator|->
name|isoa_len
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|srcp
argument_list|,
name|bufp
argument_list|,
name|srcp
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|srcp
operator|->
name|isoa_len
expr_stmt|;
return|return
name|bufp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|ndef
end_endif

begin_comment
comment|/*  * FUNCTION:		clnp_route  *  * PURPOSE:			Route a clnp datagram to the first hop toward its   *					destination. In many cases, the first hop will be  *					the destination. The address of a route  *					is specified. If a routing entry is present in  *					that route, and it is still up to the same destination,  *					then no further action is necessary. Otherwise, a  *					new routing entry will be allocated.  *  * RETURNS:			route found - 0  *					unix error code  *  * SIDE EFFECTS:	  *  * NOTES:			It is up to the caller to free the routing entry  *					allocated in route.  */
end_comment

begin_macro
name|clnp_route
argument_list|(
argument|dst
argument_list|,
argument|ro
argument_list|,
argument|flags
argument_list|,
argument|first_hop
argument_list|,
argument|ifa
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to datagram destination */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|route_iso
modifier|*
name|ro
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* existing route structure */
end_comment

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flags for routing */
end_comment

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
modifier|*
name|first_hop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result: fill in with ptr to firsthop */
end_comment

begin_decl_stmt
name|struct
name|iso_ifaddr
modifier|*
modifier|*
name|ifa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result: fill in with ptr to interface */
end_comment

begin_block
block|{
if|if
condition|(
name|flags
operator|&
name|SO_DONTROUTE
condition|)
block|{
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
sizeof|sizeof
argument_list|(
name|ro
operator|->
name|ro_dst
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|dst
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ro
operator|->
name|ro_dst
operator|.
name|siso_addr
argument_list|,
literal|1
operator|+
operator|(
name|unsigned
operator|)
name|dst
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_dst
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|ro
operator|->
name|ro_dst
operator|.
name|siso_len
operator|=
sizeof|sizeof
argument_list|(
name|ro
operator|->
name|ro_dst
argument_list|)
expr_stmt|;
name|ia
operator|=
name|iso_localifa
argument_list|(
operator|&
name|ro
operator|->
name|ro_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
literal|0
condition|)
return|return
name|EADDRNOTAVAIL
return|;
if|if
condition|(
name|ifa
condition|)
operator|*
name|ifa
operator|=
name|ia
expr_stmt|;
if|if
condition|(
name|first_hop
condition|)
operator|*
name|first_hop
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 *	If there is a cached route, check that it is still up and to 	 *	the same destination. If not, free it and try again. 	 */
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|&&
operator|(
operator|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
operator|||
operator|(
name|Bcmp
argument_list|(
name|ro
operator|->
name|ro_dst
operator|.
name|siso_data
argument_list|,
name|dst
operator|->
name|isoa_genaddr
argument_list|,
name|dst
operator|->
name|isoa_len
argument_list|)
operator|)
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"clnp_route: freeing old route: ro->ro_rt 0x%x\n"
argument_list|,
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clnp_route: old route refcnt: 0x%x\n"
argument_list|,
name|ro
operator|->
name|ro_rt
operator|->
name|rt_refcnt
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* free old route entry */
name|RTFREE
parameter_list|(
name|ro
operator|->
name|ro_rt
parameter_list|)
function_decl|;
name|ro
operator|->
name|ro_rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"clnp_route: OK route exists\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
literal|0
condition|)
block|{
comment|/* set up new route structure */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
sizeof|sizeof
argument_list|(
name|ro
operator|->
name|ro_dst
argument_list|)
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_dst
operator|.
name|siso_len
operator|=
sizeof|sizeof
argument_list|(
name|ro
operator|->
name|ro_dst
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_dst
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|Bcopy
argument_list|(
name|dst
argument_list|,
operator|&
name|ro
operator|->
name|ro_dst
operator|.
name|siso_addr
argument_list|,
literal|1
operator|+
name|dst
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
comment|/* allocate new route */
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"clnp_route: allocating new route to %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|rtalloc
argument_list|(
operator|(
expr|struct
name|route
operator|*
operator|)
name|ro
argument_list|)
decl_stmt|;
block|}
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
literal|0
condition|)
return|return
operator|(
name|ENETUNREACH
operator|)
return|;
comment|/* rtalloc failed */
name|ro
operator|->
name|ro_rt
operator|->
name|rt_use
operator|++
expr_stmt|;
if|if
condition|(
name|ifa
condition|)
if|if
condition|(
operator|(
operator|*
name|ifa
operator|=
operator|(
expr|struct
name|iso_ifaddr
operator|*
operator|)
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifa
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"clnp_route"
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_hop
condition|)
block|{
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
operator|*
name|first_hop
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_gateway
expr_stmt|;
else|else
operator|*
name|first_hop
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		clnp_srcroute  *  * PURPOSE:			Source route the datagram. If complete source  *					routing is specified but not possible, then  *					return an error. If src routing is terminated, then  *					try routing on destination.  *					Usage of first_hop,  *					ifp, and error return is identical to clnp_route.  *  * RETURNS:			0 or unix error code  *  * SIDE EFFECTS:	  *  * NOTES:			Remember that option index pointers are really  *					offsets from the beginning of the mbuf.  */
end_comment

begin_macro
name|clnp_srcroute
argument_list|(
argument|options
argument_list|,
argument|oidx
argument_list|,
argument|route
argument_list|,
argument|first_hop
argument_list|,
argument|ifa
argument_list|,
argument|final_dst
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to options */
end_comment

begin_decl_stmt
name|struct
name|clnp_optidx
modifier|*
name|oidx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index to options */
end_comment

begin_decl_stmt
name|struct
name|route_iso
modifier|*
name|route
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* route structure */
end_comment

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
modifier|*
name|first_hop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN: fill in with ptr to firsthop */
end_comment

begin_decl_stmt
name|struct
name|iso_ifaddr
modifier|*
modifier|*
name|ifa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN: fill in with ptr to interface */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|final_dst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* final destination */
end_comment

begin_block
block|{
name|struct
name|iso_addr
name|dst
decl_stmt|;
comment|/* first hop specified by src rt */
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* return code */
comment|/* 	 *	Check if we have run out of routes  	 *	If so, then try to route on destination. 	 */
if|if CLNPSRCRT_TERM
condition|(
name|oidx
operator|,
name|options
condition|)
block|{
name|dst
operator|.
name|isoa_len
operator|=
name|final_dst
operator|->
name|isoa_len
expr_stmt|;
name|bcopy
argument_list|(
name|final_dst
operator|->
name|isoa_genaddr
argument_list|,
name|dst
operator|.
name|isoa_genaddr
argument_list|,
name|dst
operator|.
name|isoa_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * setup dst based on src rt specified 		 */
name|dst
operator|.
name|isoa_len
operator|=
name|CLNPSRCRT_CLEN
argument_list|(
name|oidx
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|CLNPSRCRT_CADDR
argument_list|(
name|oidx
argument_list|,
name|options
argument_list|)
argument_list|,
name|dst
operator|.
name|isoa_genaddr
argument_list|,
name|dst
operator|.
name|isoa_len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	try to route it 	 */
name|error
operator|=
name|clnp_route
argument_list|(
operator|&
name|dst
argument_list|,
name|route
argument_list|,
literal|0
argument_list|,
name|first_hop
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* 	 *	If complete src rt, first hop must be equal to dst 	 */
if|if
condition|(
operator|(
name|CLNPSRCRT_TYPE
argument_list|(
name|oidx
argument_list|,
name|options
argument_list|)
operator|==
name|CLNPOVAL_COMPRT
operator|)
operator|&&
operator|(
operator|!
name|iso_addrmatch1
argument_list|(
operator|&
operator|(
operator|*
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|*
operator|)
name|first_hop
operator|)
operator|->
name|siso_addr
argument_list|,
operator|&
name|dst
argument_list|)
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_srcroute: complete src route failed\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|EHOSTUNREACH
return|;
comment|/* RAH? would like ESRCRTFAILED */
block|}
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		clnp_ypocb - backwards bcopy  *  * PURPOSE:			bcopy starting at end of src rather than beginning.  *  * RETURNS:			none  *  * SIDE EFFECTS:	  *  * NOTES:			No attempt has been made to make this efficient  */
end_comment

begin_macro
name|clnp_ypocb
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|from
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* src buffer */
end_comment

begin_decl_stmt
name|caddr_t
name|to
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dst buffer */
end_comment

begin_decl_stmt
name|u_int
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bytes */
end_comment

begin_block
block|{
while|while
condition|(
name|len
operator|--
condition|)
operator|*
operator|(
name|to
operator|+
name|len
operator|)
operator|=
operator|*
operator|(
name|from
operator|+
name|len
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		clnp_hdrsize  *  * PURPOSE:			Return the size of a typical clnp hdr.  *  * RETURNS:			Size of hdr in bytes.  *  * SIDE EFFECTS:	  *  * NOTES:			Assumes segmenting subset. If addrlen is  *					zero, default to largest nsap address size.  */
end_comment

begin_macro
name|clnp_hdrsize
argument_list|(
argument|addrlen
argument_list|)
end_macro

begin_decl_stmt
name|u_char
name|addrlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of nsap address */
end_comment

begin_block
block|{
if|if
condition|(
name|addrlen
operator|==
literal|0
condition|)
name|addrlen
operator|=
literal|20
expr_stmt|;
name|addrlen
operator|++
expr_stmt|;
comment|/* length of address byte */
name|addrlen
operator|*=
literal|2
expr_stmt|;
comment|/* src and dst addresses */
name|addrlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_fixed
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_segment
argument_list|)
expr_stmt|;
return|return
operator|(
name|addrlen
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|ISO
end_endif

end_unit

