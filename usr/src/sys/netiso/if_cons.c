begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * $Header: if_cons.c,v 4.7 88/08/11 15:52:55 nhall Exp $  * $Source: /usr/argo/sys/netiso/RCS/if_cons.c,v $  *  * cons.c - Connection Oriented Network Service:  * including support for a) user transport-level service,   *	b) COSNS below CLNP, and c) CONS below TP.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: if_cons.c,v 4.7 88/08/11 15:52:55 nhall Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|Static
end_define

begin_decl_stmt
name|unsigned
name|LAST_CALL_PCB
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
else|ARGO_DEBUG
end_else

begin_define
define|#
directive|define
name|Static
value|static
end_define

begin_endif
endif|#
directive|endif
endif|ARGO_DEBUG
end_endif

begin_include
include|#
directive|include
file|"ecn.h"
end_include

begin_include
include|#
directive|include
file|"argoxtwentyfive.h"
end_include

begin_if
if|#
directive|if
name|NARGOXTWENTYFIVE
operator|>
literal|0
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso_errno.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_trace.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/cons.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/cons_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../caif/eicon.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|MT_XCONN
value|0x50
end_define

begin_define
define|#
directive|define
name|MT_XCLOSE
value|0x51
end_define

begin_define
define|#
directive|define
name|MT_XCONFIRM
value|0x52
end_define

begin_define
define|#
directive|define
name|MT_XDATA
value|0x53
end_define

begin_define
define|#
directive|define
name|MT_XHEADER
value|0x54
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MT_XCONN
value|MT_DATA
end_define

begin_define
define|#
directive|define
name|MT_XCLOSE
value|MT_DATA
end_define

begin_define
define|#
directive|define
name|MT_XCONFIRM
value|MT_DATA
end_define

begin_define
define|#
directive|define
name|MT_XDATA
value|MT_DATA
end_define

begin_define
define|#
directive|define
name|MT_XHEADER
value|MT_HEADER
end_define

begin_endif
endif|#
directive|endif
endif|ARGO_DEBUG
end_endif

begin_define
define|#
directive|define
name|DONTCLEAR
value|-1
end_define

begin_comment
comment|/*********************************************************************	  * cons.c - CONS interface to the eicon adapter  * Includes connection manager - for (TP, CLNP)/x.25  *  * TODO: figure out what resources we might run out of besides mbufs.  *  If we run out of any of them (including mbufs) close and recycle  *  lru x% of the connections, for some parameter x.  *  * There are 4 interfaces from above:  * 0) from CLNP:   *    cons is an interface driver - CLNP calls  *    cosns_output(ifp, m, dst), a device-type interface output routine  *    that does some connection management stuff and queues a  *    request on the eicon driver queue by calling ifp->if_output.  *    The eicon's ifp structure contains cosns_output as its output routine  *    rather than ifp_>if_output! Kludge, but we don't have much choice...  *    X25 connections created in this manner may always be multiplexed  *    but only with their own kind (not with connections servicing TP  *    directly.)  *	  	co_flags& CONSF_DGM   * 1) from TP0:   *    cons CO network service  *    TP associates a transport connection with a network connection.  * 	  cons_output( isop, m, len, isdgm==0 )   *        co_flags == 0  * 2) from TP 4:  *	  It's a datagram service, like clnp is. - even though it calls  *			cons_output( isop, m, len, isdgm==1 )   *	  it eventually goes through  *			cosns_output(ifp, m, dst).  *    TP4 permits multiplexing (reuse, possibly simultaneously) of the   *	  network connections.  *    This means that many sockets (many tpcbs) may be associated with  *    this cons_pcb, hence cannot have a back ptr from cons_pcb to a tpcb.  *        co_flags& CONSF_DGM   *    co_socket is null since there may be many sockets that use this copcb.  * 3) from user: cons_usrreq(), cons_ctloutput()   *    cons is a standard transport service interface.  *    There is a 1-1 correspondence between net connections and sockets.  *	  co_socket points to a socket.  * NOTE: 	streams would really be nice. sigh. NOTE: 	eicon<--> cons interface: the first mbuf (the ecn_request structure) 	had better NOT be a cluster. NOTE: 	PVCs could be handled by config-ing a cons with an address and with the 	IFF_POINTTOPOINT flag on.  This code would then have to skip the 	connection setup stuff for pt-to-pt links.   NOTE: 	We keep track of the ifp for each connection.  Right now this is 	unnecessary, but just in case someone comes up with some kind 	of a kludge to allow> 1 eicon to be attached at a time, 	(i.e., some meaningful netof( a type 37 address ) ), 	we do keep track of this.    *********************************************************************/
end_comment

begin_define
define|#
directive|define
name|touch
parameter_list|(
name|copcb
parameter_list|)
value|copcb->co_ttl = copcb->co_init_ttl
end_define

begin_define
define|#
directive|define
name|CONS_IFQMAXLEN
value|5
end_define

begin_define
define|#
directive|define
name|SET_CHANMASK
parameter_list|(
name|isop
parameter_list|,
name|chan
parameter_list|)
define|\
value|if( (u_int)(chan)< 32 ) \ 		(isop)->isop_chanmask = (1<<((chan)-1));\ 	else \ 		(isop)->isop_negchanmask = (1<<((256-(chan))-1))
end_define

begin_define
define|#
directive|define
name|ADD_CHANMASK
parameter_list|(
name|isop
parameter_list|,
name|chan
parameter_list|)
define|\
value|if( (u_int)(chan)< 32 ) \ 		(isop)->isop_chanmask |= (1<<((chan)-1));\ 	else \ 		(isop)->isop_negchanmask |= (1<<((256-(chan))-1))
end_define

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|consif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TO BE REMOVED */
end_comment

begin_decl_stmt
name|Static
name|int
name|consinit
argument_list|()
decl_stmt|,
name|consioctl
argument_list|()
decl_stmt|,
name|consattach
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* protosw pointers for getting to higher layer */
end_comment

begin_decl_stmt
name|Static
name|struct
name|protosw
modifier|*
name|CLNP_proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|protosw
modifier|*
name|TP_proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|protosw
modifier|*
name|X25_proto
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Static
name|int
name|issue_clear_req
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|PHASEONE
end_ifndef

begin_function_decl
specifier|extern
name|struct
name|ifaddr
modifier|*
name|ifa_ifwithnet
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|PHASEONE
end_endif

begin_function_decl
specifier|extern
name|struct
name|ifaddr
modifier|*
name|ifa_ifwithaddr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|Static
name|struct
name|socket
name|dummysocket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for use by cosns */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|isopcb
name|tp_isopcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chain of all TP pcbs */
end_comment

begin_decl_stmt
name|struct
name|isopcb
name|cons_isopcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chain of all cons pcbs */
end_comment

begin_decl_stmt
name|struct
name|isopcb
name|tp_incoming_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* incoming connections 										for TP, pending */
end_comment

begin_decl_stmt
name|struct
name|isopcb
modifier|*
name|Xpcblist
index|[]
init|=
block|{
operator|&
name|cons_isopcb
block|,
operator|&
name|tp_incoming_pending
block|,
operator|&
name|tp_isopcb
block|,
operator|(
expr|struct
name|isopcb
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|int
name|parse_facil
argument_list|()
decl_stmt|,
name|NSAPtoDTE
argument_list|()
decl_stmt|,
name|make_partial_x25_packet
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|int
name|FACILtoNSAP
argument_list|()
decl_stmt|,
name|DTEtoNSAP
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Static
name|struct
name|cons_pcb
modifier|*
name|cons_chan_to_pcb
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|HIGH_NIBBLE
value|1
end_define

begin_define
define|#
directive|define
name|LOW_NIBBLE
value|0
end_define

begin_comment
comment|/*  * NAME:	nibble_copy()  * FUNCTION and ARGUMENTS:  * 	copies (len) nibbles from (src_octet), high or low nibble  *  to (dst_octet), high or low nibble,  * src_nibble& dst_nibble should be:  * 	HIGH_NIBBLE (1) if leftmost 4 bits/ most significant nibble  * 	LOW_NIBBLE (0) if rightmost 4 bits/ least significant nibble  * RETURNS: VOID  */
end_comment

begin_function
name|void
name|nibble_copy
parameter_list|(
name|src_octet
parameter_list|,
name|src_nibble
parameter_list|,
name|dst_octet
parameter_list|,
name|dst_nibble
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|src_octet
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst_octet
decl_stmt|;
specifier|register
name|unsigned
name|src_nibble
decl_stmt|;
specifier|register
name|unsigned
name|dst_nibble
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|unsigned
name|dshift
decl_stmt|,
name|sshift
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"nibble_copy ( 0x%x, 0x%x, 0x%x, 0x%x 0x%x)\n"
argument_list|,
name|src_octet
argument_list|,
name|src_nibble
argument_list|,
name|dst_octet
argument_list|,
name|dst_nibble
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
define|#
directive|define
name|SHIFT
value|0x4
name|dshift
init|=
name|dst_nibble
operator|<<
literal|2
decl_stmt|;
name|sshift
operator|=
name|src_nibble
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* clear dst_nibble  */
operator|*
name|dst_octet
operator|&=
operator|~
operator|(
literal|0xf
operator|<<
name|dshift
operator|)
expr_stmt|;
comment|/* set dst nibble */
operator|*
name|dst_octet
operator||=
operator|(
literal|0xf
operator|&
operator|(
operator|*
name|src_octet
operator|>>
name|sshift
operator|)
operator|)
operator|<<
name|dshift
expr_stmt|;
name|dshift
operator|^=
name|SHIFT
expr_stmt|;
name|sshift
operator|^=
name|SHIFT
expr_stmt|;
name|src_nibble
operator|=
literal|1
operator|-
name|src_nibble
expr_stmt|;
name|dst_nibble
operator|=
literal|1
operator|-
name|dst_nibble
expr_stmt|;
name|src_octet
operator|+=
name|src_nibble
expr_stmt|;
name|dst_octet
operator|+=
name|dst_nibble
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"nibble_copy DONE\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_function

begin_comment
comment|/*  * NAME:	nibble_match()  * FUNCTION and ARGUMENTS:  * 	compares src_octet/src_nibble and dst_octet/dst_nibble  for len nibbles.  * RETURNS: 0 if they differ, 1 if they are the same.  */
end_comment

begin_function
name|int
name|nibble_match
parameter_list|(
name|src_octet
parameter_list|,
name|src_nibble
parameter_list|,
name|dst_octet
parameter_list|,
name|dst_nibble
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|src_octet
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst_octet
decl_stmt|;
specifier|register
name|unsigned
name|src_nibble
decl_stmt|;
specifier|register
name|unsigned
name|dst_nibble
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|unsigned
name|dshift
decl_stmt|,
name|sshift
decl_stmt|;
name|u_char
name|nibble_a
decl_stmt|,
name|nibble_b
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"nibble_match ( 0x%x, 0x%x, 0x%x, 0x%x 0x%x)\n"
argument_list|,
name|src_octet
argument_list|,
name|src_nibble
argument_list|,
name|dst_octet
argument_list|,
name|dst_nibble
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
define|#
directive|define
name|SHIFT
value|0x4
name|dshift
init|=
name|dst_nibble
operator|<<
literal|2
decl_stmt|;
name|sshift
operator|=
name|src_nibble
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|nibble_b
operator|=
operator|(
operator|(
operator|*
name|dst_octet
operator|)
operator|>>
name|dshift
operator|)
operator|&
literal|0xf
expr_stmt|;
name|nibble_a
operator|=
operator|(
literal|0xf
operator|&
operator|(
operator|*
name|src_octet
operator|>>
name|sshift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|nibble_b
operator|!=
name|nibble_a
condition|)
return|return
literal|0
return|;
name|dshift
operator|^=
name|SHIFT
expr_stmt|;
name|sshift
operator|^=
name|SHIFT
expr_stmt|;
name|src_nibble
operator|=
literal|1
operator|-
name|src_nibble
expr_stmt|;
name|dst_nibble
operator|=
literal|1
operator|-
name|dst_nibble
expr_stmt|;
name|src_octet
operator|+=
name|src_nibble
expr_stmt|;
name|dst_octet
operator|+=
name|dst_nibble
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"nibble_match DONE\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_function
name|Static
name|dump_copcb
parameter_list|(
name|copcb
parameter_list|,
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"XPCB DUMP %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|copcb
condition|)
block|{
name|printf
argument_list|(
literal|"\t copcb 0x%x next 0x%x head 0x%x socket 0x%x ifp 0x%x\n"
argument_list|,
name|copcb
argument_list|,
name|copcb
operator|->
name|co_next
argument_list|,
name|copcb
operator|->
name|co_head
argument_list|,
name|copcb
operator|->
name|co_socket
argument_list|,
name|copcb
operator|->
name|co_ifp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t channel 0x%x state 0x%x flags 0x%x proto 0x%x\n"
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|,
name|copcb
operator|->
name|co_state
argument_list|,
name|copcb
operator|->
name|co_flags
argument_list|,
name|copcb
operator|->
name|co_proto
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t laddr :\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|copcb
operator|->
name|co_laddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t faddr :\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tttl 0x%x init_ttl 0x%x pending: %d\n"
argument_list|,
name|copcb
operator|->
name|co_ttl
argument_list|,
name|copcb
operator|->
name|co_init_ttl
argument_list|,
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_len
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"END DUMP\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|ARGO_DEBUG
end_endif

begin_comment
comment|/*  * FUNCTION : choose_output - chooses between the eicon and loopback.  * This MUST be here because the ifp->if_output routine is cosns_output  * -- due to our need to look like a device driver for CLNP. sigh.  * ARGUMENTS& PURPOSE:  (copcb) ptr to a protocol control block for  *			x.25, (m) is an mbuf ptr. *m is a request destined either  * 			for the eicon driver or for the loopback driver.  * RETURNS : whatever error value the 2I or loopback returns.  */
end_comment

begin_function
name|Static
name|int
name|choose_output
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|,
name|loop
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|loop
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
literal|0
return|;
name|ASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|!=
literal|0
condition|)
name|error
operator|=
name|lpboutput
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ecnoutput
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
else|else
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_CDATA
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"choose_output: ifp  m error loop\n"
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|,
name|error
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|ENDTRACE
block|}
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"choose_output returns 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  **************************** NET PROTOCOL cons ***************************  */
end_comment

begin_comment
comment|/*  * NAME:	cons_init()  * CALLED FROM:  *	autoconf  * FUNCTION:  *	initialize the protocol  */
end_comment

begin_macro
name|cons_init
argument_list|()
end_macro

begin_block
block|{
name|init_lpb
argument_list|()
expr_stmt|;
name|consattach
argument_list|()
expr_stmt|;
comment|/* protocol init stuff */
name|consintrq
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|consintrq
operator|.
name|ifq_head
operator|=
name|consintrq
operator|.
name|ifq_tail
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|CLNP_proto
operator|=
name|pffindproto
argument_list|(
name|AF_ISO
argument_list|,
name|ISOPROTO_CLNP
argument_list|,
name|SOCK_DGRAM
argument_list|)
expr_stmt|;
name|X25_proto
operator|=
name|pffindproto
argument_list|(
name|AF_ISO
argument_list|,
name|ISOPROTO_X25
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
name|TP_proto
operator|=
name|pffindproto
argument_list|(
name|AF_ISO
argument_list|,
name|ISOPROTO_TP0
argument_list|,
name|SOCK_SEQPACKET
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cons_init end : cnlp_proto 0x%x cons proto 0x%x tp proto 0x%x\n"
argument_list|,
name|CLNP_proto
argument_list|,
name|X25_proto
argument_list|,
name|TP_proto
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|cons_isopcb
operator|.
name|isop_next
init|=
name|cons_isopcb
operator|.
name|isop_prev
operator|=
operator|&
name|cons_isopcb
decl_stmt|;
name|tp_incoming_pending
operator|.
name|isop_next
operator|=
name|tp_incoming_pending
operator|.
name|isop_prev
operator|=
operator|&
name|tp_incoming_pending
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * NAME:	cons_free_lru()  * some day CALLED FROM:   * 	wherever we run out of mbufs (not used right yet)  * FUNCTION:  *	get rid of the num least recently used connections and  *  recycle their mbufs.  * NOTE: GROTESQUELY INEFFICIENT needs to be written nicely  */
end_comment

begin_function
name|Static
name|cons_free_lru
parameter_list|(
name|qty
parameter_list|)
name|int
name|qty
decl_stmt|;
block|{
specifier|register
name|struct
name|cons_pcb
modifier|*
modifier|*
name|copcblist
init|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|*
operator|)
name|Xpcblist
decl_stmt|;
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
name|struct
name|cons_pcb
name|Lru
decl_stmt|;
name|struct
name|cons_pcb
modifier|*
name|lru
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cons_free_lru( 0x%x )\n"
argument_list|,
name|qty
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|Lru
operator|.
name|co_ttl
init|=
name|X25_TTL
decl_stmt|;
name|lru
operator|=
operator|&
name|Lru
expr_stmt|;
while|while
condition|(
name|qty
operator|>
literal|1
condition|)
block|{
comment|/* GROT */
name|cons_free_lru
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|qty
operator|--
expr_stmt|;
block|}
for|for
control|(
name|copcb
operator|=
operator|*
name|copcblist
init|;
name|copcb
condition|;
name|copcb
operator|=
operator|*
operator|(
operator|++
name|copcblist
operator|)
control|)
block|{
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
while|while
condition|(
name|copcb
operator|!=
operator|*
name|copcblist
condition|)
block|{
if|if
condition|(
name|copcb
operator|->
name|co_ttl
operator|<
name|lru
operator|->
name|co_ttl
condition|)
name|lru
operator|=
name|copcb
expr_stmt|;
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lru
operator|->
name|co_socket
condition|)
block|{
name|soisdisconnected
argument_list|(
name|lru
operator|->
name|co_socket
argument_list|)
expr_stmt|;
name|sohasoutofband
argument_list|(
name|lru
operator|->
name|co_socket
argument_list|)
expr_stmt|;
comment|/* signal */
block|}
name|cons_clear_and_detach
argument_list|(
name|lru
argument_list|,
name|E_CO_HLI_RESYNC
argument_list|,
name|PRC_TIMXCEED_REASS
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|notdef
end_endif

begin_comment
comment|/*  * NAME:	cons_slowtimo()  * CALLED FROM:   * 	the clock  * FUNCTION:  *	get rid of any timed-out cons connections  *  cons connections get "touched" with every use, meaning the  *  time-to-live gets reset to its max value w/ every use.  *  The slowtimo() rtn decrements the time-to-live for each  *  cons connection.  If one of them hits zero ---> zap the connection.  *  This really only applies to those used for CLNP and TP4.  *  TP4 keeps the connections open with keepalive.  * TODO:  *  Have this happen ONLY for international connections since  *  there's no connect time charge for domestic calls.  *  Make default 5 min; make a user option to change it.  * TODO:  *  Maybe if the ttl gets lower than a certain threshold, move this   *  copcb to the END of its queue so it doesn't slow down the others.  */
end_comment

begin_macro
name|cons_slowtimo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|cons_pcb
modifier|*
modifier|*
name|copcblist
init|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|*
operator|)
name|Xpcblist
decl_stmt|;
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|qlen
init|=
literal|0
decl_stmt|;
name|int
name|qdrops
init|=
literal|0
decl_stmt|;
name|int
name|nvisited
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGO_DEBUG
name|Static
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|ARGO_DEBUG
name|IncStat
argument_list|(
name|co_slowtimo
argument_list|)
expr_stmt|;
for|for
control|(
name|copcb
operator|=
operator|*
name|copcblist
init|;
name|copcb
condition|;
name|copcb
operator|=
operator|*
operator|(
operator|++
name|copcblist
operator|)
control|)
block|{
ifdef|#
directive|ifdef
name|ARGO_DEBUG
if|if
condition|(
name|copcb
operator|==
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TURNING OFF cons_slowtimo()!!! \n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|ARGO_DEBUG
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
while|while
condition|(
name|copcb
operator|!=
operator|*
name|copcblist
condition|)
block|{
ifdef|#
directive|ifdef
name|ARGO_DEBUG
if|if
condition|(
operator|++
name|count
operator|>
literal|50
condition|)
block|{
name|printf
argument_list|(
literal|"cons PANIC: slowtimo LOOP\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|ARGO_DEBUG
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|copcb
operator|->
name|co_init_ttl
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
operator|(
operator|*
name|copcblist
operator|)
operator|==
operator|(
expr|struct
name|isopcb
operator|*
operator|)
operator|&
name|tp_isopcb
argument_list|)
expr_stmt|;
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
endif|notdef
name|nvisited
operator|++
expr_stmt|;
name|ASSERT
argument_list|(
name|copcb
operator|!=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|qlen
operator|+=
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_len
expr_stmt|;
name|qdrops
operator|+=
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_drops
expr_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_socket
condition|)
block|{
comment|/* don't want XTS, TP0 connections to be subject to time out */
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|--
operator|(
name|copcb
operator|->
name|co_ttl
operator|)
operator|>
literal|0
condition|)
block|{
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
continue|continue;
block|}
name|IncStat
argument_list|(
name|co_timedout
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"TIMING OUT chan 0x%x copcb 0x%x flags 0x%x\n"
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|,
name|copcb
argument_list|,
name|copcb
operator|->
name|co_flags
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|{
specifier|register
name|struct
name|cons_pcb
modifier|*
name|next
init|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
decl_stmt|;
name|cons_clear_and_detach
argument_list|(
name|copcb
argument_list|,
name|E_CO_HLI_RESYNC
argument_list|,
name|PRC_TIMXCEED_REASS
argument_list|)
expr_stmt|;
name|copcb
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nvisited
condition|)
block|{
name|cons_stat
operator|.
name|co_avg_qlen
operator|=
name|qlen
operator|/
name|nvisited
expr_stmt|;
name|cons_stat
operator|.
name|co_avg_qdrop
operator|=
name|qdrops
operator|/
name|nvisited
expr_stmt|;
name|cons_stat
operator|.
name|co_active
operator|=
name|nvisited
expr_stmt|;
block|}
name|done
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DUMP_PCBLIST
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
specifier|register
name|struct
name|cons_pcb
modifier|*
modifier|*
name|copcblist
init|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|*
operator|)
name|Xpcblist
decl_stmt|;
for|for
control|(
name|copcb
operator|=
operator|*
name|copcblist
init|;
name|copcb
condition|;
name|copcb
operator|=
operator|*
operator|(
operator|++
name|copcblist
operator|)
control|)
block|{
name|printf
argument_list|(
literal|"FOR %d: 0x%x "
argument_list|,
operator|++
name|i
argument_list|,
name|copcb
argument_list|)
expr_stmt|;
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
name|printf
argument_list|(
literal|" next 0x%x, *copcblist 0x%x\n"
argument_list|,
name|copcb
argument_list|,
operator|*
name|copcblist
argument_list|)
expr_stmt|;
while|while
condition|(
name|copcb
operator|!=
operator|*
name|copcblist
condition|)
block|{
name|ASSERT
argument_list|(
name|copcb
operator|!=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tCOPCB 0x%x\n"
argument_list|,
name|copcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|copcb
condition|)
name|dump_buf
argument_list|(
name|copcb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|copcb
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * NAME:	cons_pcballoc()  * CALLED FROM:  *	cons_usrreq() when doing PRU_ATTACH,   *  cons_incoming() when opening a new connection.    * FUNCTION and ARGUMENTS:  *	Allocates a new pcb.  *  The flags and proto arguments are stashed into the new pcb.  * RETURN VALUE:  *  E* if error, 0 if ok  */
end_comment

begin_function
name|Static
name|int
name|cons_pcballoc
parameter_list|(
name|so
parameter_list|,
name|head
parameter_list|,
name|flags
parameter_list|,
name|proto
parameter_list|,
name|dest
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|head
decl_stmt|;
name|u_short
name|flags
decl_stmt|;
name|struct
name|protosw
modifier|*
name|proto
decl_stmt|;
name|struct
name|cons_pcb
modifier|*
modifier|*
name|dest
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_pcballoc (0x%x, 0x%x, 0x%x, 0x%x, 0x%x\n"
argument_list|,
name|so
argument_list|,
name|head
argument_list|,
name|flags
argument_list|,
name|proto
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|proto
operator|==
operator|(
expr|struct
name|protosw
operator|*
operator|)
literal|0
condition|)
return|return
name|EPROTONOSUPPORT
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|iso_pcballoc
argument_list|(
name|so
argument_list|,
name|head
argument_list|)
operator|)
operator|==
name|EOK
condition|)
block|{
comment|/* Have allocated a cleared mbuf */
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|copcb
operator|->
name|co_ttl
operator|=
name|copcb
operator|->
name|co_init_ttl
operator|=
name|X25_TTL
expr_stmt|;
name|copcb
operator|->
name|co_flags
operator|=
name|flags
expr_stmt|;
name|copcb
operator|->
name|co_proto
operator|=
name|proto
expr_stmt|;
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_maxlen
operator|=
name|CONS_IFQMAXLEN
expr_stmt|;
name|copcb
operator|->
name|co_myself
operator|=
name|copcb
expr_stmt|;
if|if
condition|(
name|so
operator|==
operator|&
name|dummysocket
condition|)
name|copcb
operator|->
name|co_socket
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|dest
operator|=
name|copcb
expr_stmt|;
block|}
name|done
label|:
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_pcballoc returns 0x%x: DUMP\n"
argument_list|,
name|copcb
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|copcb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|copcb
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|flags
operator|&
name|CONSF_ICRE
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|dte_addr
modifier|*
name|dtea
init|=
operator|&
operator|(
operator|*
name|dest
operator|)
operator|->
name|co_peer_dte
decl_stmt|;
name|int
name|len
decl_stmt|;
name|error
operator|=
name|iso_8208snparesolve
argument_list|(
operator|&
operator|(
operator|*
name|dest
operator|)
operator|->
name|co_faddr
argument_list|,
name|dtea
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|dte_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	cons_connect()  * CALLED FROM:  *	cons_usrreq() when opening a new connection.    * FUNCTION anD ARGUMENTS:  *  Figures out which device to use, finding a route if one doesn't  *  already exist.  * 	Builds an eicon connection request and gives it to the device.  * RETURN VALUE:  *  returns E*  */
end_comment

begin_function
name|Static
name|int
name|cons_connect
parameter_list|(
name|copcb
parameter_list|)
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
block|{
specifier|register
name|struct
name|eicon_request
modifier|*
name|ecnrq
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_connect( 0x%x ) : ifp 0x%x\npeer: "
argument_list|,
name|copcb
argument_list|,
name|copcb
operator|->
name|co_ifp
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nmyaddr: "
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|copcb
operator|->
name|co_laddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* PHASE 2: this call is OK */
if|if
condition|(
name|ifa
operator|=
name|ifa_ifwithaddr
argument_list|(
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|)
condition|)
block|{
comment|/* foreign address is me */
name|copcb
operator|->
name|co_ifp
operator|=
name|ifa
operator|->
name|ifa_ifp
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_connect: after if_withaddr copcb->co_ifp 0x%x\n"
argument_list|,
name|copcb
operator|->
name|co_ifp
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_LOOPBACK
operator||
name|IFF_UP
operator|)
operator|)
operator|==
operator|(
name|IFF_LOOPBACK
operator||
name|IFF_UP
operator|)
condition|)
block|{
name|copcb
operator|->
name|co_flags
operator||=
name|CONSF_LOOPBACK
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ifa
operator|->
name|ifa_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_laddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_connect: co_flags 0x%x\n"
argument_list|,
name|copcb
operator|->
name|co_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
condition|)
block|{
name|printf
argument_list|(
literal|" cons_connect withaddr returns %s\n"
argument_list|,
name|copcb
operator|->
name|co_ifp
operator|->
name|if_name
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
elseif|else
if|if
condition|(
name|copcb
operator|->
name|co_ifp
operator|==
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PHASEONE
comment|/* 		 *	We need to get the local nsap address. 		 *	First, route to the destination. This will provide us with 		 *	an ifp. Second, determine which local address linked on 		 *	that ifp is appropriate 		 */
name|struct
name|sockaddr_iso
modifier|*
name|first_hop
decl_stmt|;
comment|/* filled by clnp_route */
name|struct
name|iso_addr
modifier|*
name|localaddr
decl_stmt|,
modifier|*
name|clnp_srcaddr
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|clnp_route
argument_list|(
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|copcb
operator|)
operator|->
name|isop_route
argument_list|,
comment|/* flags */
literal|0
argument_list|,
operator|&
name|first_hop
argument_list|,
operator|&
name|copcb
operator|->
name|co_ifp
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* determine local address based upon ifp */
if|if
condition|(
operator|(
name|localaddr
operator|=
name|clnp_srcaddr
argument_list|(
name|copcb
operator|->
name|co_ifp
argument_list|,
operator|&
name|first_hop
operator|->
name|siso_addr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENETUNREACH
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|copcb
operator|->
name|co_laddr
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|copcb
operator|->
name|co_laddr
operator|.
name|siso_addr
operator|=
operator|*
name|localaddr
expr_stmt|;
else|#
directive|else
comment|/* Foreign addr isn't me (lpb). If still don't have an ifp or have 		 * an ifp but don't know its address, look for a route  		 */
if|if
condition|(
name|ifa
operator|=
name|ifa_ifwithnet
argument_list|(
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|)
condition|)
block|{
name|copcb
operator|->
name|co_ifp
operator|=
name|ifa
operator|->
name|ifa_ifp
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|" cons_connect withnet returns %s\n"
argument_list|,
name|copcb
operator|->
name|co_ifp
operator|->
name|if_name
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
else|else
block|{
name|printf
argument_list|(
literal|"cons PANIC: connect: can't find SNPA \n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENETUNREACH
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
endif|PHASEONE
block|}
ifndef|#
directive|ifndef
name|PHASEONE
if|if
condition|(
name|ifa
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
block|{
name|struct
name|ifaddr
modifier|*
name|iso_ifwithidi
parameter_list|()
function_decl|;
if|if
condition|(
name|ifa
operator|=
name|iso_ifwithidi
argument_list|(
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|)
condition|)
block|{
name|copcb
operator|->
name|co_ifp
operator|=
name|ifa
operator|->
name|ifa_ifp
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|" cons_connect withnet returns %s\n"
argument_list|,
name|copcb
operator|->
name|co_ifp
operator|->
name|if_name
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
else|else
block|{
name|printf
argument_list|(
literal|"cons PANIC: connect: can't find SNPA \n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENETUNREACH
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ifa
operator|->
name|ifa_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_laddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PHASEONE
name|copcb
operator|->
name|co_state
operator|=
name|CONNECTING
expr_stmt|;
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_ifp
operator|!=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_ifp
operator|==
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
condition|)
block|{
name|error
operator|=
name|ENETUNREACH
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m
operator|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_XCONN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|copcb
operator|->
name|co_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
expr_stmt|;
name|ecnrq
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|eicon_request
operator|*
argument_list|)
expr_stmt|;
name|copcb
operator|->
name|co_myself
operator|=
name|copcb
expr_stmt|;
name|ecnrq
operator|->
name|e_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|copcb
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGO_DEBUG
name|LAST_CALL_PCB
operator|=
operator|(
name|unsigned
operator|)
name|ecnrq
operator|->
name|e_pcb
expr_stmt|;
endif|#
directive|endif
endif|ARGO_DEBUG
name|ecnrq
operator|->
name|e_cmd
operator|=
name|ECN_CALL
expr_stmt|;
name|ecnrq
operator|->
name|e_vc
operator|=
literal|0
expr_stmt|;
comment|/* mbz ? */
name|ecnrq
operator|->
name|e_info
operator|=
literal|0
expr_stmt|;
comment|/* mbz */
comment|/* get data buffer */
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|MGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_XCONN
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|MNULL
condition|)
block|{
name|copcb
operator|->
name|co_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|e_data
argument_list|(
name|ecnrq
argument_list|)
operator|=
name|n
expr_stmt|;
comment|/* e_data is really dtom(ecnrq)->m_next */
block|}
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"calling make_partial_x25_packet( 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n"
argument_list|,
operator|&
name|copcb
operator|->
name|co_laddr
argument_list|,
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|,
name|copcb
operator|->
name|co_proto
operator|->
name|pr_protocol
argument_list|,
name|e_data
argument_list|(
name|ecnrq
argument_list|)
argument_list|,
name|copcb
operator|->
name|co_flags
operator|&
name|CONSF_XTS
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|error
operator|=
name|make_partial_x25_packet
argument_list|(
name|copcb
argument_list|,
name|e_data
argument_list|(
name|ecnrq
argument_list|)
argument_list|)
condition|)
block|{
name|copcb
operator|->
name|co_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|IncStat
argument_list|(
name|co_call
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CDUMP_REQ
argument_list|)
name|printf
argument_list|(
literal|"cons_connect ecnrq:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|ecnrq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ecnrq
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_channel
operator|==
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_channel
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cons_connect PANIC: channel is 0x%x\n"
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|choose_output
argument_list|(
name|copcb
operator|->
name|co_ifp
argument_list|,
name|m
argument_list|,
name|copcb
operator|->
name|co_flags
operator|&
name|CONSF_LOOPBACK
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
comment|/* ok */
break|break;
default|default:
comment|/* problem */
name|printf
argument_list|(
literal|"cons: PANIC: if_output returns 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|cons_clear_and_detach
argument_list|(
name|copcb
argument_list|,
name|DONTCLEAR
argument_list|,
name|PRC_ROUTEDEAD
argument_list|)
expr_stmt|;
block|}
name|bad
label|:
name|IFTRACE
argument_list|(
argument|D_CDATA
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"cons_connect: choose (copcb m) returned  error\n"
argument_list|,
name|copcb
argument_list|,
name|m
argument_list|,
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	cons_find()  * CALLED FROM:  *	cosns_output1() thus:  *		cons_find( CONSF_DGM, dst, proto, 0, 0) where  *		proto is one of { TP_proto, CLNP_proto }  * FUNCTION and ARGUMENTS:  *  Looks through list of connections for the destination,  *  for one marked for the use indicated by flags.  *  If none found, opens up a new connection.  *   These connections will be eliminated by :  *     a) slowtimo timer, or   *     b) the need for a new connection, when we've run out of resources.  *  The argument flags describes the type of pcb we want - may  *  specify multiplexing-ok, datagram use, etc.  *  The argument proto points the the higher layer protocol that  *  will be using this connection.  * RETURN VALUE:  *  returns a ptr to a pcb whose characteristics match those  *  described by (flags, proto)  */
end_comment

begin_decl_stmt
name|Static
name|struct
name|cons_pcb
modifier|*
name|cons_find
argument_list|(
name|flags
argument_list|,
name|dst
argument_list|,
name|proto
argument_list|,
name|addl_criteria
argument_list|,
name|mask
argument_list|)
name|u_int
name|flags
decl_stmt|,
name|mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|protosw
modifier|*
name|proto
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|addl_criteria
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
specifier|register
name|struct
name|cons_pcb
modifier|*
modifier|*
name|copcblist
init|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|*
operator|)
name|Xpcblist
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* or whatever, for the device! */
name|struct
name|dte_addr
name|dest_dte
decl_stmt|;
name|int
name|dummy
decl_stmt|;
struct|struct
name|copcb_descriptor
block|{
name|int
name|xd_qlen
decl_stmt|;
name|struct
name|cons_pcb
modifier|*
name|xd_pcb
decl_stmt|;
block|}
name|next_best
init|=
block|{
literal|0
block|,
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
block|}
struct|;
name|IFDEBUG
argument_list|(
argument|D_CFIND
argument_list|)
name|printf
argument_list|(
literal|"cons_find( flags 0x%x proto 0x%x) "
argument_list|,
name|flags
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|iso_8208snparesolve
argument_list|(
name|dst
argument_list|,
operator|&
name|dest_dte
argument_list|,
operator|&
name|dummy
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
return|;
comment|/* error */
block|}
name|ASSERT
argument_list|(
name|dummy
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|dte_addr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|copcb
operator|=
operator|*
name|copcblist
init|;
name|copcb
condition|;
name|copcb
operator|=
operator|*
operator|(
operator|++
name|copcblist
operator|)
control|)
block|{
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
while|while
condition|(
name|copcb
operator|!=
operator|*
name|copcblist
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CFIND
argument_list|)
name|printf
argument_list|(
literal|"cons_find: chan 0x%x flags 0x%x proto 0x%x state 0x%x \n"
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|,
name|copcb
operator|->
name|co_flags
argument_list|,
name|copcb
operator|->
name|co_proto
argument_list|,
name|copcb
operator|->
name|co_state
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 			 * if flags is a subset of the bits in co_flags, it will suffice 			 */
if|if
condition|(
operator|(
operator|(
name|copcb
operator|->
name|co_flags
operator|&
name|flags
operator|)
operator|==
name|flags
operator|)
operator|&&
comment|/* PHASE2: where do we get the mask if we use nsaps ???? 				 * If dte addresses are used, then use 				 * nibble compare otherwise...??? 				 */
ifdef|#
directive|ifdef
name|notdef
name|iso_addrmatch1
argument_list|(
argument|&(copcb->co_faddr.siso_addr)
argument_list|,
argument|&(dst->siso_addr)
argument_list|)
else|#
directive|else
name|dest_dte
operator|.
name|dtea_niblen
operator|==
name|copcb
operator|->
name|co_peer_dte
operator|.
name|dtea_niblen
operator|&&
name|nibble_match
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|copcb
operator|->
name|co_peer_dte
operator|.
name|dtea_addr
operator|)
argument_list|,
name|HIGH_NIBBLE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dest_dte
operator|.
name|dtea_addr
argument_list|,
name|HIGH_NIBBLE
argument_list|,
name|dest_dte
operator|.
name|dtea_niblen
argument_list|)
endif|#
directive|endif
endif|notdef
operator|&&
operator|(
name|copcb
operator|->
name|co_proto
operator|==
name|proto
operator|)
operator|&&
operator|(
name|copcb
operator|->
name|co_state
operator|>=
name|MIN_USABLE_STATE
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CFIND
argument_list|)
name|printf
argument_list|(
literal|"cons_find: add'l criteria...\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|copcb
operator|->
name|co_state
operator|!=
name|OPEN
operator|)
operator|&&
operator|(
name|next_best
operator|.
name|xd_qlen
operator|>
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_len
operator|)
condition|)
block|{
name|next_best
operator|.
name|xd_pcb
operator|=
name|copcb
expr_stmt|;
name|next_best
operator|.
name|xd_qlen
operator|=
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_len
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addl_criteria
operator|||
call|(
modifier|*
name|addl_criteria
call|)
argument_list|(
name|copcb
argument_list|,
name|mask
argument_list|)
condition|)
block|{
goto|goto
name|found
goto|;
comment|/* have to break out of 2 loops */
block|}
block|}
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* TODO:  	 * have a limit of the number of calls per desitination. 	 * If we didn't find one already open AND our limit for this 	 * destination hasn't been reached, return 0 'cause 	 * then the caller will open a new one. 	 * Otherwise return next_best. 	 * To do this we need some sort of per-destination info. 	 * Could go into the directory service. Oh, grotesque. 	 */
endif|#
directive|endif
endif|notdef
if|if
condition|(
name|copcb
operator|==
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
condition|)
block|{
name|copcb
operator|=
name|next_best
operator|.
name|xd_pcb
expr_stmt|;
comment|/* may be zero too */
name|IFDEBUG
argument_list|(
argument|D_CFIND
argument_list|)
name|printf
argument_list|(
literal|"NEXT_BEST! \n"
argument_list|)
expr_stmt|;
name|dump_copcb
argument_list|(
name|copcb
argument_list|,
literal|"find: next_best"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
name|found
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CFIND
argument_list|)
name|printf
argument_list|(
literal|"returns 0x%x \n"
argument_list|,
name|copcb
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|copcb
return|;
block|}
end_block

begin_comment
comment|/*  * NAME:	issue_clear_req()  * CALLED FROM:  *	cons_clear() and wherever we get an error from x.25 that makes us  *  	want to close the vc on which it came, but don't have  *		a copcb assoc. with that vc.  * FUNCTION and ARGUMENTS:  *  Creates an eicon_request for a clear request, returns it in an mbuf.  *  (chan) is the channel on which to do the clear, (reason) is the   *  clear reason(diagnostic).  * RETURN VALUE:  *  returns E*  */
end_comment

begin_function
name|Static
name|int
name|issue_clear_req
parameter_list|(
name|chan
parameter_list|,
name|reason
parameter_list|,
name|ifp
parameter_list|,
name|loop
parameter_list|)
name|u_char
name|chan
decl_stmt|,
name|reason
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|loop
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|cdm
decl_stmt|;
specifier|register
name|struct
name|eicon_request
modifier|*
name|ecnrq
decl_stmt|;
name|struct
name|e_clear_data
modifier|*
name|ecd
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"issue_clear_req(0x%x, 0x%x, 0x%x, 0x%x)\n"
argument_list|,
name|chan
argument_list|,
name|reason
argument_list|,
name|ifp
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|m
init|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_XCLOSE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
expr_stmt|;
name|ecnrq
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|eicon_request
operator|*
argument_list|)
expr_stmt|;
name|ecnrq
operator|->
name|e_cmd
operator|=
name|ECN_CLEAR
expr_stmt|;
name|ecnrq
operator|->
name|e_vc
operator|=
name|chan
operator|&
literal|0xff
expr_stmt|;
comment|/*  	 *  see p. 149 of 8208 for reasons (diagnostic codes) 	 */
name|MGET
argument_list|(
name|cdm
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_XCLOSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cdm
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|cdm
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|e_clear_data
argument_list|)
expr_stmt|;
comment|/* cause, diagnostic */
name|e_data
argument_list|(
name|ecnrq
argument_list|)
operator|=
name|cdm
expr_stmt|;
name|ecd
operator|=
name|mtod
argument_list|(
name|cdm
argument_list|,
expr|struct
name|e_clear_data
operator|*
argument_list|)
expr_stmt|;
name|ecd
operator|->
name|ecd_cause
operator|=
literal|0x0
expr_stmt|;
comment|/* DTE initiated, diagnostic tells more */
name|ecd
operator|->
name|ecd_diagnostic
operator|=
operator|(
name|u_char
operator|)
name|reason
expr_stmt|;
name|IncStat
argument_list|(
name|co_clear_out
argument_list|)
expr_stmt|;
return|return
name|choose_output
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|loop
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	cons_clear()  * CALLED FROM:  *  cons_usrreq(), PRU_DISCONNECT,  *  cons_slowtimo(), cons_free_lru()  * FUNCTION and ARGUMENTS:  *	Builds a clear request for the connection represented by copcb,  *  gives it to the device.  * ECN_CLEAR(request) takes e_vc only, returns adr_status.  * RETURN VALUE:  */
end_comment

begin_function
name|Static
name|int
name|cons_clear
parameter_list|(
name|copcb
parameter_list|,
name|reason
parameter_list|)
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
name|u_char
name|reason
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_clear(0x%x, 0x%x)\n"
argument_list|,
name|copcb
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|!
name|copcb
condition|)
block|{
name|printf
argument_list|(
literal|"cons PANIC: clear: No copcb\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_len
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|copcb
operator|->
name|co_pending
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|copcb
operator|->
name|co_state
operator|==
name|CLOSED
operator|)
operator|||
operator|(
name|copcb
operator|->
name|co_state
operator|==
name|CLOSING
operator|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|ARGO_DEBUG
if|if
condition|(
name|copcb
operator|->
name|co_state
operator|==
name|CONNECTING
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|dump_copcb
argument_list|(
name|copcb
argument_list|,
literal|"clear"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
elseif|else
if|if
condition|(
operator|(
name|copcb
operator|->
name|co_channel
operator|==
literal|0
operator|)
operator|||
operator|(
name|copcb
operator|->
name|co_channel
operator|==
name|X_NOCHANNEL
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|dump_copcb
argument_list|(
name|copcb
argument_list|,
literal|"clear"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
endif|#
directive|endif
endif|ARGO_DEBUG
name|copcb
operator|->
name|co_state
operator|=
name|CLOSING
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_clear: channel 0x%x copcb 0x%x dst: "
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|,
name|copcb
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|)
expr_stmt|;
name|dump_copcb
argument_list|(
name|copcb
argument_list|,
literal|"clear"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|error
init|=
name|issue_clear_req
argument_list|(
name|copcb
operator|->
name|co_channel
argument_list|,
name|reason
argument_list|,
name|copcb
operator|->
name|co_ifp
argument_list|,
name|copcb
operator|->
name|co_flags
operator|&
name|CONSF_LOOPBACK
argument_list|)
decl_stmt|;
name|copcb
operator|->
name|co_channel
operator|=
name|X_NOCHANNEL
expr_stmt|;
name|copcb
operator|->
name|co_state
operator|=
name|CLOSED
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*   * NAME:	cons_senddata()  * CALLED FROM:  *  cons_output(), consoutput(), consintr()  * FUNCTION and ARGUMENTS:  *	issued a data (write) command - if the device isn't ready,  *  it enqueues the command on a per-connection queue.  * RETURN VALUE:  *	ENOBUFS  *  Is responsible for freeing m0!  *  * ECN_SEND (write)   */
end_comment

begin_function
name|Static
name|int
name|cons_senddata
parameter_list|(
name|copcb
parameter_list|,
name|m0
parameter_list|)
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|eicon_request
modifier|*
name|ecnrq
decl_stmt|;
name|int
name|s
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CDATA
argument_list|)
name|printf
argument_list|(
literal|"cons_senddata( 0x%x, m 0x%x ) chan 0x%x"
argument_list|,
name|copcb
argument_list|,
name|m0
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" co_lport 0x%x\n"
argument_list|,
name|copcb
operator|->
name|co_lport
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|m0
operator|==
name|MNULL
condition|)
return|return;
name|ASSERT
argument_list|(
name|m0
operator|->
name|m_len
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cons_senddata : BAD MLEN? 0x%x"
argument_list|,
name|m0
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|touch
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|copcb
operator|->
name|co_state
operator|==
name|CONNECTING
operator|)
operator|||
operator|(
name|copcb
operator|->
name|co_state
operator|==
name|ACKWAIT
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CDATA
argument_list|)
name|printf
argument_list|(
literal|"senddata PUTTING ON PENDING Q copcb 0x%x state 0x%x\n"
argument_list|,
name|copcb
argument_list|,
name|copcb
operator|->
name|co_state
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|copcb
operator|->
name|co_pending
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CDATA
argument_list|)
name|printf
argument_list|(
literal|"senddata DROPPING m0 0x%x\n"
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IF_DROP
argument_list|(
operator|&
name|copcb
operator|->
name|co_pending
argument_list|)
decl_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_ifp
condition|)
block|{
name|copcb
operator|->
name|co_ifp
operator|->
name|if_snd
operator|.
name|ifq_drops
operator|++
expr_stmt|;
block|}
name|IncStat
argument_list|(
name|co_Xdrops
argument_list|)
expr_stmt|;
name|copcb
operator|->
name|co_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_proto
operator|&&
name|copcb
operator|->
name|co_proto
operator|->
name|pr_ctlinput
condition|)
block|{
call|(
modifier|*
name|copcb
operator|->
name|co_proto
operator|->
name|pr_ctlinput
call|)
argument_list|(
name|PRC_QUENCH
argument_list|,
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|copcb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|E_CO_QFULL
return|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CDATA
argument_list|)
name|printf
argument_list|(
literal|"Putting 0x%x on 0x%x->pending Q\n"
argument_list|,
name|m0
argument_list|,
name|copcb
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IF_ENQUEUE
argument_list|(
operator|&
name|copcb
operator|->
name|co_pending
argument_list|,
name|m0
argument_list|)
decl_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|copcb
operator|->
name|co_channel
operator|==
literal|0
condition|)
block|{
return|return
name|E_CO_CHAN
return|;
block|}
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_state
operator|==
name|OPEN
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_XDATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|copcb
operator|->
name|co_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
expr_stmt|;
name|ecnrq
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|eicon_request
operator|*
argument_list|)
expr_stmt|;
name|ecnrq
operator|->
name|e_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|copcb
expr_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_myself
operator|!=
name|copcb
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
comment|/* TODO: REMOVE THIS DEBUGGING HACK */
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BAD e_pcb from HL (0x%x,0x%x)\n"
argument_list|,
name|copcb
argument_list|,
name|copcb
operator|->
name|co_myself
argument_list|)
expr_stmt|;
name|mm
operator|=
name|dtom
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|->
name|m_type
operator|==
name|MT_FREE
condition|)
name|printf
argument_list|(
literal|"FREED MBUF!\n"
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_channel
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_channel
operator|!=
name|X_NOCHANNEL
argument_list|)
expr_stmt|;
name|ecnrq
operator|->
name|e_vc
operator|=
operator|(
name|copcb
operator|->
name|co_channel
operator|&
literal|0xff
operator|)
expr_stmt|;
name|ecnrq
operator|->
name|e_cmd
operator|=
name|ECN_SEND
expr_stmt|;
name|e_data
argument_list|(
name|ecnrq
argument_list|)
operator|=
name|m0
expr_stmt|;
block|{
comment|/* TODO: REMOVE THIS DEBUGGING HACK */
name|struct
name|mbuf
modifier|*
name|thedata
init|=
name|e_data
argument_list|(
name|ecnrq
argument_list|)
decl_stmt|;
name|u_int
modifier|*
name|firstint
init|=
name|mtod
argument_list|(
name|thedata
argument_list|,
name|u_int
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|firstint
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0x81000000
condition|)
block|{
comment|/* not clnp */
switch|switch
condition|(
operator|(
operator|(
operator|*
name|firstint
operator|)
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|20
condition|)
block|{
case|case
literal|0x1
case|:
case|case
literal|0x2
case|:
case|case
literal|0x3
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
case|case
literal|0x8
case|:
case|case
literal|0xc
case|:
case|case
literal|0xd
case|:
case|case
literal|0xe
case|:
case|case
literal|0xf
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|" ECN_SEND! BAD DATA\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|thedata
argument_list|,
literal|20
operator|+
literal|12
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
block|}
block|}
name|ecnrq
operator|->
name|e_info
operator|=
literal|0
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CDUMP_REQ
argument_list|)
name|printf
argument_list|(
literal|"senddata ecnrq\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IncStat
argument_list|(
name|co_send
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_state
operator|==
name|OPEN
argument_list|)
expr_stmt|;
name|copcb
operator|->
name|co_state
operator|=
name|ACKWAIT
expr_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_myself
operator|!=
name|copcb
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
comment|/* TODO: REMOVE this and all mention of co_myself */
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BAD e_pcb TO THE BOARD ecn (0x%x) cmd 0x%x\n"
argument_list|,
name|ecnrq
operator|->
name|e_pcb
argument_list|,
name|ecnrq
operator|->
name|e_cmd
argument_list|)
expr_stmt|;
name|mm
operator|=
name|dtom
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|->
name|m_type
operator|==
name|MT_FREE
condition|)
name|printf
argument_list|(
literal|"FREED MBUF!\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|ecnrq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ecnrq
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
return|return
name|choose_output
argument_list|(
name|copcb
operator|->
name|co_ifp
argument_list|,
name|dtom
argument_list|(
name|ecnrq
argument_list|)
argument_list|,
name|copcb
operator|->
name|co_flags
operator|&
name|CONSF_LOOPBACK
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	cons_send_on_vc()  * CALLED FROM:  *  tp_error_emit()  * FUNCTION and ARGUMENTS:  *  Take a packet(m0), of length (datalen) from tp and   * send it on the channel (chan).  *	  * RETURN VALUE:  *  whatever (E*) is returned form the net layer output routine.  */
end_comment

begin_function
name|int
name|cons_send_on_vc
parameter_list|(
name|chan
parameter_list|,
name|m
parameter_list|,
name|datalen
parameter_list|)
name|int
name|chan
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|struct
name|cons_pcb
modifier|*
name|copcb
init|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|MNULL
condition|)
return|return;
if|if
condition|(
operator|(
name|copcb
operator|=
ifdef|#
directive|ifdef
name|ARGO_DEBUG
name|cons_chan_to_pcb
argument_list|(
argument|chan
argument_list|,
argument|__LINE__
argument_list|)
else|#
directive|else
else|ARGO_DEBUG
name|cons_chan_to_pcb
argument_list|(
name|chan
argument_list|)
endif|#
directive|endif
endif|ARGO_DEBUG
operator|)
operator|==
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
condition|)
return|return
name|E_CO_CHAN
return|;
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cons_send_on_vc m 0x%x m_len 0x%x\n"
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|cons_senddata
argument_list|(
name|copcb
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	cons_output()  * CALLED FROM:  *  tpiso_output(), can have whatever interface we want it to...  *  tpiso_output() decides whether to give a packet to CLNP or to   *  cons; if the latter, it calls this routine.  * FUNCTION and ARGUMENTS:  *  tp has alloc-ed a pcb - but it may not be open.  *  some classes of tp may allow multiplexing, in which  *  case, you may choose to send the data on ANOTHER cons connection.  *  This decides which net connection to use, opens one if necessary.  *  Then it sends the data.  */
end_comment

begin_macro
name|cons_output
argument_list|(
argument|isop
argument_list|,
argument|m
argument_list|,
argument|len
argument_list|,
argument|isdgm
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|isdgm
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|cons_pcb
modifier|*
name|copcb
init|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cons_output( isop 0x%x, m 0x%x, len 0x%x, dgm 0x%x )\n"
argument_list|,
name|isop
argument_list|,
name|m
argument_list|,
name|len
argument_list|,
name|isdgm
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|m
operator|==
name|MNULL
condition|)
return|return
literal|0
return|;
name|ASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdgm
condition|)
block|{
name|error
operator|=
name|cosns_output1
argument_list|(
literal|0
argument_list|,
name|m
argument_list|,
operator|&
name|isop
operator|->
name|isop_faddr
argument_list|,
name|TP_proto
argument_list|,
name|isop
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CDATA
argument_list|)
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"cosns_output1 RETURNS ERROR 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|error
return|;
block|}
if|if
condition|(
name|isop
operator|->
name|isop_chanmask
operator|||
name|isop
operator|->
name|isop_negchanmask
condition|)
block|{
specifier|register
name|int
name|mask
init|=
name|isop
operator|->
name|isop_chanmask
decl_stmt|;
specifier|register
name|int
name|chan
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
name|mask
operator|=
name|isop
operator|->
name|isop_negchanmask
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|1
init|;
operator|(
name|mask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|chan
operator|++
operator|,
name|mask
operator|>>=
literal|1
control|)
empty_stmt|;
if|if
condition|(
name|isop
operator|->
name|isop_chanmask
operator|==
literal|0
condition|)
name|chan
operator|=
operator|-
name|chan
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cons_output: isop 0x%x cmask 0x%x negmask 0x%x, chan 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_chanmask
argument_list|,
name|isop
operator|->
name|isop_negchanmask
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|ASSERT
argument_list|(
name|chan
operator|!=
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGO_DEBUG
name|copcb
operator|=
name|cons_chan_to_pcb
argument_list|(
name|chan
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
else|#
directive|else
else|ARGO_DEBUG
name|copcb
operator|=
name|cons_chan_to_pcb
argument_list|(
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|ARGO_DEBUG
block|}
if|if
condition|(
name|copcb
operator|==
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* get a new one */
if|if
condition|(
operator|(
name|error
operator|=
name|cons_pcballoc
argument_list|(
operator|&
name|dummysocket
argument_list|,
operator|&
name|cons_isopcb
argument_list|,
name|CONSF_OCRE
argument_list|,
name|TP_proto
argument_list|,
operator|&
name|copcb
argument_list|)
operator|)
operator|!=
name|EOK
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cosns_output: no copcb; returns 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
argument_list|(
argument|void
argument_list|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* abbreviated form of iso_pcbconnect(): */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|isop
operator|->
name|isop_faddr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|cons_connect
argument_list|(
name|copcb
argument_list|)
condition|)
block|{
comment|/* if it doesn't work */
comment|/* oh, dear, throw packet away */
name|remque
argument_list|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|copcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|copcb
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|copcb
operator|->
name|co_socket
condition|)
block|{
while|while
condition|(
operator|(
name|copcb
operator|->
name|co_state
operator|!=
name|OPEN
operator|)
operator|&&
operator|!
operator|(
name|error
operator|=
name|copcb
operator|->
name|co_socket
operator|->
name|so_error
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"SLEEP1 copcb 0x%x isop 0x%x state 0x%x chan 0x%x mask 0x%x neg 0x%x\n"
argument_list|,
name|copcb
argument_list|,
name|isop
argument_list|,
name|copcb
operator|->
name|co_state
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|,
operator|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|isop_chanmask
argument_list|,
operator|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|isop_negchanmask
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_state
argument_list|,
name|PZERO
operator|+
literal|1
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"AFTER SLEEP 1 chan 0x%x chanmask 0x%x negchanmask 0x%x\n"
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|,
name|isop
operator|->
name|isop_chanmask
argument_list|,
name|isop
operator|->
name|isop_negchanmask
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|SET_CHANMASK
argument_list|(
name|isop
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|)
expr_stmt|;
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_CDATA
argument_list|)
name|printf
argument_list|(
literal|"cons_output calling senddata(0x%x 0x%x)\n"
argument_list|,
name|copcb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|m
operator|!=
name|MNULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|cons_senddata
argument_list|(
name|copcb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * NAME:	cons_openvc()  * CALLED FROM:  *  TP when it decides to open a VC for TP 0  * FUNCTION:  *  opens a connection and stashes the pcb info in the socket  *  substitute for iso_pcbconnect/ in_pcbconnect for the class 0 case  *  only.  */
end_comment

begin_function
name|int
name|cons_openvc
parameter_list|(
name|copcb
parameter_list|,
name|faddr
parameter_list|,
name|so
parameter_list|)
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|faddr
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|struct
name|cons_pcb
modifier|*
name|cons_chan_to_pcb
parameter_list|()
function_decl|;
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_socket
operator|==
name|so
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_CCONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"cons_openvc( copcb so )\n"
argument_list|,
name|copcb
argument_list|,
name|so
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_openvc( copcb 0x%x, so 0x%x )\n"
argument_list|,
name|copcb
argument_list|,
name|so
argument_list|)
decl_stmt|;
name|ENDDEBUG
comment|/* 	 * initialize the copcb part of the isopcb 	 */
name|copcb
operator|->
name|co_ttl
init|=
name|copcb
operator|->
name|co_init_ttl
operator|=
name|X25_TTL
decl_stmt|;
name|copcb
operator|->
name|co_flags
operator|=
name|CONSF_OCRE
expr_stmt|;
name|copcb
operator|->
name|co_proto
operator|=
name|TP_proto
expr_stmt|;
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_maxlen
operator|=
name|CONS_IFQMAXLEN
expr_stmt|;
comment|/* abbreviated form of iso_pcbconnect(): */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|faddr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_socket
operator|==
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|cons_connect
argument_list|(
name|copcb
argument_list|)
condition|)
goto|goto
name|done
goto|;
while|while
condition|(
operator|(
name|copcb
operator|->
name|co_state
operator|!=
name|OPEN
operator|)
operator|&&
operator|!
operator|(
name|error
operator|=
name|so
operator|->
name|so_error
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"SLEEP2 copcb 0x%x state 0x%x chan 0x%x mask 0x%x neg 0x%x\n"
argument_list|,
name|copcb
argument_list|,
name|copcb
operator|->
name|co_state
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|,
name|copcb
operator|->
name|co_chanmask
argument_list|,
name|copcb
operator|->
name|co_negchanmask
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_state
argument_list|,
name|PZERO
operator|+
literal|2
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"AFTER SLEEP2 chan 0x%x chanmask 0x%x negchanmask 0x%x\n"
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|,
name|copcb
operator|->
name|co_chanmask
argument_list|,
name|copcb
operator|->
name|co_negchanmask
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|SET_CHANMASK
argument_list|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|copcb
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|)
expr_stmt|;
name|done
label|:
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_socket
operator|==
name|so
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_openvc: copcb 0x%x error 0x%x\n"
argument_list|,
name|copcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	cons_netcmd()  * CALLED FROM:  *  tp_route_to() when it decides to accept or reject an incoming  *  connection it calls this.  * FUNCTION:  *  either closes the cons connection named by (channel)  *  or associates the copcb with the channel #.  *	and removes the old copcb from the tp_incoming_pending list.  */
end_comment

begin_function
name|int
name|cons_netcmd
parameter_list|(
name|cmd
parameter_list|,
name|isop
parameter_list|,
name|channel
parameter_list|,
name|isdgm
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|int
name|channel
decl_stmt|;
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|cons_pcb
modifier|*
name|copcb
init|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|cons_pcb
modifier|*
name|cons_chan_to_pcb
parameter_list|()
function_decl|;
name|IFTRACE
argument_list|(
argument|D_CCONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"cons_netcmd( cmd isopcb channel isdgm)\n"
argument_list|,
name|cmd
argument_list|,
name|isop
argument_list|,
name|channel
argument_list|,
name|isdgm
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_netcmd( cmd 0x%x, isop 0x%x, channel 0x%x, isdgm 0x%x)\n"
argument_list|,
name|cmd
argument_list|,
name|isop
argument_list|,
name|channel
argument_list|,
name|isdgm
argument_list|)
decl_stmt|;
if|if
condition|(
name|isop
condition|)
name|printf
argument_list|(
literal|"cons_netcmd: isop->socket 0x%x\n"
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|ASSERT
argument_list|(
name|cmd
operator|!=
name|CONN_OPEN
argument_list|)
decl_stmt|;
comment|/* Can we find a cons-level pcb based on channel? */
if|if
condition|(
name|channel
condition|)
block|{
if|if
condition|(
operator|(
name|copcb
operator|=
ifdef|#
directive|ifdef
name|ARGO_DEBUG
name|cons_chan_to_pcb
argument_list|(
argument|channel
argument_list|,
argument|__LINE__
argument_list|)
else|#
directive|else
else|ARGO_DEBUG
name|cons_chan_to_pcb
argument_list|(
name|channel
argument_list|)
endif|#
directive|endif
endif|ARGO_DEBUG
operator|)
operator|==
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
condition|)
block|{
name|error
operator|=
name|ECONNABORTED
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|copcb
operator|==
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
condition|)
block|{
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* avoid operating on a pcb twice */
block|}
else|else
block|{
comment|/* if isop is null (close/refuse): 			 * this would remove from the TP list, which is NOT what we want  			 * so only remove if there is an isop (gag) 			 */
if|if
condition|(
name|isop
condition|)
block|{
name|remque
argument_list|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
argument_list|)
expr_stmt|;
comment|/* take it off pending list */
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|(
name|cmd
operator|==
name|CONN_CLOSE
operator|)
operator|||
operator|(
name|cmd
operator|==
name|CONN_REFUSE
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* now we have one of these cases: 	 * 1) isop is non-null and copcb is null  	 * 2) isop is non-null and copcb is non-null and they are different 	 * 3) isop is null and copcb is non-null  	 */
name|ASSERT
argument_list|(
operator|(
name|isop
operator|!=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
literal|0
operator|)
operator|||
operator|(
name|copcb
operator|!=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CONN_CONFIRM
case|:
if|if
condition|(
name|isdgm
condition|)
block|{
comment|/* we want two separate pcbs */
comment|/* if we don't have a copcb, get one */
if|if
condition|(
name|copcb
operator|==
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|cons_pcballoc
argument_list|(
operator|&
name|dummysocket
argument_list|,
operator|&
name|cons_isopcb
argument_list|,
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|co_flags
argument_list|,
name|TP_proto
argument_list|,
operator|&
name|copcb
argument_list|)
operator|)
operator|!=
name|EOK
condition|)
return|return
name|error
return|;
comment|/* copy missing info from isop */
name|copcb
operator|->
name|co_laddr
operator|=
name|isop
operator|->
name|isop_laddr
expr_stmt|;
name|copcb
operator|->
name|co_faddr
operator|=
name|isop
operator|->
name|isop_faddr
expr_stmt|;
comment|/* don't care about tsuffices */
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|co_channel
operator|=
literal|0
expr_stmt|;
comment|/* no longer used */
name|copcb
operator|->
name|co_ifp
operator|=
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|co_ifp
expr_stmt|;
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_len
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insque
argument_list|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|copcb
argument_list|,
operator|(
expr|struct
name|isopcb
operator|*
operator|)
operator|&
name|cons_isopcb
argument_list|)
expr_stmt|;
block|}
name|copcb
operator|->
name|co_state
operator|=
name|OPEN
expr_stmt|;
name|copcb
operator|->
name|co_flags
operator||=
name|CONSF_DGM
expr_stmt|;
name|copcb
operator|->
name|co_channel
operator|=
name|channel
expr_stmt|;
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_channel
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_netcmd: put 0x%x on regular list \n"
argument_list|,
name|copcb
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
else|else
block|{
comment|/* must be TP 0, since this is never called from XTS code */
comment|/* we want ONE pcb, namely isop. 				 * If this TPE were the active side, 				 * there ought not to be a copcb, since TP should 				 * know that you can't send a CR with dgm and negot down 				 * to non-dgm. 				 * If this TPE were the passive side, we want to copy from 				 * the copcb that was on the pending list, and delete the 				 * pending copcb. 				 */
if|if
condition|(
name|copcb
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_netcmd: copied info from 0x%x to 0x%x\n"
argument_list|,
name|copcb
argument_list|,
name|isop
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|isop
operator|->
name|isop_laddr
init|=
name|copcb
operator|->
name|co_laddr
decl_stmt|;
name|isop
operator|->
name|isop_faddr
operator|=
name|copcb
operator|->
name|co_faddr
expr_stmt|;
comment|/* tsuffices, socket should be there already */
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|co_flags
operator|=
name|copcb
operator|->
name|co_flags
operator|&
operator|~
name|CONSF_DGM
expr_stmt|;
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|co_init_ttl
operator|=
name|copcb
operator|->
name|co_init_ttl
expr_stmt|;
name|touch
argument_list|(
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|co_channel
operator|=
name|channel
expr_stmt|;
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|co_ifp
operator|=
name|copcb
operator|->
name|co_ifp
expr_stmt|;
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|co_proto
operator|=
name|copcb
operator|->
name|co_proto
expr_stmt|;
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|co_myself
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
expr_stmt|;
name|SET_CHANMASK
argument_list|(
name|isop
argument_list|,
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|co_channel
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_len
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* get rid of the copcb that was on the pending list */
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|copcb
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
operator|)
operator|->
name|co_state
operator|=
name|OPEN
expr_stmt|;
block|}
break|break;
case|case
name|CONN_CLOSE
case|:
case|case
name|CONN_REFUSE
case|:
comment|/* if dgm then ignore; the connections will  			 * be re-used or will time out 			 */
if|if
condition|(
name|isdgm
condition|)
break|break;
comment|/* we should never come in here with both isop and copcb 			 * unless is dgm, hence the following assertion: 			 */
name|ASSERT
argument_list|(
operator|(
name|copcb
operator|==
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
operator|)
operator|||
operator|(
name|isop
operator|==
operator|(
expr|struct
name|isopcb
operator|*
operator|)
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* close whichever pcb we have */
if|if
condition|(
name|copcb
condition|)
name|error
operator|=
name|cons_clear
argument_list|(
name|copcb
argument_list|,
operator|(
name|cmd
operator|==
name|CONN_CLOSE
operator|)
condition|?
name|E_CO_HLI_DISCN
else|:
name|E_CO_HLI_REJT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isop
condition|)
name|error
operator|=
name|cons_clear
argument_list|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|isop
argument_list|,
operator|(
name|cmd
operator|==
name|CONN_CLOSE
operator|)
condition|?
name|E_CO_HLI_DISCN
else|:
name|E_CO_HLI_REJT
argument_list|)
expr_stmt|;
if|if
condition|(
name|copcb
operator|&&
operator|(
name|copcb
operator|->
name|co_socket
operator|==
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_flags
operator|&
operator|(
name|CONSF_DGM
operator||
name|CONSF_ICRE
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|copcb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* detached */
block|}
comment|/* isop will always be detached by the higher layer */
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_netcmd returns 0x%x: isop 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	addr_proto_consistency_check()  * CALLED FROM: cons_incoming()  * FUNCTION and ARGUMENTS:  *  Enforces a set of rules regarding what addresses will serve  *  what protocol stack.  This is a kludge forced upon us by the  *  fact that there's no way to tell which NET layer you want to  *  run when opening a socket.  Besides, no doubt, OSI directory  *  services won't advertise any kind of a protocol stack with the  *  NSAPs.  sigh.  * RETURNS  * 	EAFNOSUPPORT or EOK.  */
end_comment

begin_function
name|Static
name|int
name|addr_proto_consistency_check
parameter_list|(
name|proto
parameter_list|,
name|addr
parameter_list|)
name|int
name|proto
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|addr
decl_stmt|;
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|ISOPROTO_CLNP
case|:
break|break;
case|case
name|ISOPROTO_INACT_NL
case|:
case|case
name|ISOPROTO_CLTP
case|:
return|return
name|E_CO_HLI_PROTOID
return|;
case|case
name|ISOPROTO_TP
case|:
case|case
name|ISOPROTO_X25
case|:
comment|/* hl is TP or X.25 */
if|if
condition|(
name|addr
operator|->
name|siso_addr
operator|.
name|isoa_afi
operator|!=
name|AFI_37
condition|)
return|return
name|E_CO_AIWP
return|;
comment|/* kludge - necessary because this is the only type of 				 * NSAP we build for an incoming NC 				 */
break|break;
default|default:
comment|/* unsupported */
return|return
name|E_CO_HLI_PROTOID
return|;
block|}
return|return
name|EOK
return|;
block|}
end_function

begin_comment
comment|/*   * NAME:	cons_incoming()  * CALLED FROM:  *  consintr() for incoming OPEN  * FUNCTION and ARGUMENTS:  *  Determines which higher layer gets this call, and   *  thus whether to immediately accept, reject, or to let the  *	higher layer determine this question.   */
end_comment

begin_function
name|Static
name|cons_incoming
parameter_list|(
name|ifp
parameter_list|,
name|ecnrq
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|struct
name|eicon_request
modifier|*
name|ecnrq
decl_stmt|;
block|{
name|struct
name|sockaddr_iso
name|me
decl_stmt|;
name|struct
name|sockaddr_iso
name|peer
decl_stmt|;
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
name|int
name|loop
init|=
literal|0
decl_stmt|;
name|int
name|proto
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|dte_addr
name|peer_dte
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_INCOMING
argument_list|)
name|printf
argument_list|(
literal|"consincoming enter: ifp 0x%x ecnrq 0x%x\n"
argument_list|,
name|ifp
argument_list|,
name|ecnrq
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|bzero
argument_list|(
operator|&
name|me
argument_list|,
sizeof|sizeof
argument_list|(
name|me
argument_list|)
argument_list|)
decl_stmt|;
name|error
operator|=
name|parse_facil
argument_list|(
name|mtod
argument_list|(
name|e_data
argument_list|(
name|ecnrq
argument_list|)
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|e_data
argument_list|(
name|ecnrq
argument_list|)
operator|)
operator|->
name|m_len
argument_list|,
operator|&
name|me
argument_list|,
operator|&
name|peer
argument_list|,
operator|&
name|proto
argument_list|,
operator|&
name|peer_dte
argument_list|)
expr_stmt|;
name|loop
operator|=
name|is_me
argument_list|(
operator|&
name|peer
argument_list|)
expr_stmt|;
comment|/*<-- THIS may be a problem : 							* peer may be nonsense. 							* We can only expect that WE will do it right 							* and never will we get an error return from 							* parse_facil on a facil that WE generated, 							* so if garbage comes in, peer will be garbage, 							* and loop will be false. 							*/
if|if
condition|(
name|error
operator|!=
name|EOK
condition|)
block|{
operator|(
name|void
operator|)
name|issue_clear_req
argument_list|(
name|ecnrq
operator|->
name|e_vc
argument_list|,
name|error
argument_list|,
name|ifp
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|co_parse_facil_err
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|co_Rdrops
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|addr_proto_consistency_check
argument_list|(
name|proto
argument_list|,
operator|&
name|me
argument_list|)
operator|)
operator|!=
name|EOK
condition|)
block|{
comment|/* problem with consistency */
operator|(
name|void
operator|)
name|issue_clear_req
argument_list|(
name|ecnrq
operator|->
name|e_vc
argument_list|,
name|error
argument_list|,
name|ifp
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|co_addr_proto_consist_err
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|co_Rdrops
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|ISOPROTO_X25
case|:
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
operator|(
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
operator|(
operator|&
name|cons_isopcb
operator|)
operator|)
operator|->
name|co_next
expr_stmt|;
while|while
condition|(
name|copcb
operator|!=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
operator|&
name|cons_isopcb
condition|)
block|{
if|if
condition|(
name|copcb
operator|->
name|co_lport
operator|==
name|me
operator|.
name|siso_tsuffix
condition|)
block|{
comment|/* for cons "transport service", 						 * multiplexing is not allowed  						 */
if|if
condition|(
operator|!
name|copcb
operator|->
name|co_socket
condition|)
block|{
name|printf
argument_list|(
literal|"PANIC cons_incoming NOT TP but no sock\n"
argument_list|)
expr_stmt|;
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copcb
operator|->
name|co_socket
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
name|struct
name|cons_pcb
modifier|*
name|newx
decl_stmt|;
name|newx
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|sonewconn
argument_list|(
name|copcb
operator|->
name|co_socket
argument_list|)
operator|->
name|so_pcb
expr_stmt|;
name|newx
operator|->
name|co_laddr
operator|=
name|copcb
operator|->
name|co_laddr
expr_stmt|;
name|newx
operator|->
name|co_peer_dte
operator|=
name|peer_dte
expr_stmt|;
name|newx
operator|->
name|co_proto
operator|=
name|copcb
operator|->
name|co_proto
expr_stmt|;
name|newx
operator|->
name|co_myself
operator|=
name|newx
expr_stmt|;
name|touch
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
name|copcb
operator|=
name|newx
expr_stmt|;
name|soisconnected
argument_list|(
name|copcb
operator|->
name|co_socket
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else keep looking */
block|}
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
block|}
if|if
condition|(
name|copcb
operator|==
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
operator|&
name|cons_isopcb
condition|)
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
case|case
name|ISOPROTO_TP
case|:
name|ASSERT
argument_list|(
name|me
operator|.
name|siso_tsuffix
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * We treat this rather like we do for CLNP.   				 * TP can't tell which socket 				 * wants this until the TP header comes in, so there's no way 				 * to associate this channel with a tpcb/isopcb. 				 * We assume data will arrive (a CR TPDU) and be given to TP along with 				 * the channel number.  We can then expect TP to call us with 				 * the channel number and pcb ptr, telling us to keep this connection 				 * or clear it. 				 * Now, tp will have created an isopcb in the tp_isopcb list. 				 * We will have to keep another copcb though, because there is no 				 * 1-1 correspondence between socket and copcb when multiplexing 				 * is allowed.  				 * But we want to save the peer address, ifp, and state, proto. 				 * If the channel should clear before TP responds, we need 				 * to know that also, so we create a tp-pending list... 				 */
if|if
condition|(
name|cons_pcballoc
argument_list|(
operator|&
name|dummysocket
argument_list|,
operator|&
name|tp_incoming_pending
argument_list|,
name|CONSF_ICRE
argument_list|,
name|TP_proto
argument_list|,
operator|&
name|copcb
argument_list|)
operator|!=
name|EOK
condition|)
block|{
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|copcb
operator|->
name|co_peer_dte
operator|=
name|peer_dte
expr_stmt|;
block|}
break|break;
case|case
name|ISOPROTO_CLNP
case|:
if|if
condition|(
name|cons_pcballoc
argument_list|(
operator|&
name|dummysocket
argument_list|,
operator|&
name|cons_isopcb
argument_list|,
name|CONSF_ICRE
operator||
name|CONSF_DGM
argument_list|,
name|CLNP_proto
argument_list|,
operator|&
name|copcb
argument_list|)
operator|!=
name|EOK
condition|)
block|{
comment|/* choke */
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|copcb
operator|->
name|co_peer_dte
operator|=
name|peer_dte
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"cons_incoming"
argument_list|)
expr_stmt|;
block|}
comment|/* end switch */
if|if
condition|(
name|copcb
condition|)
block|{
name|touch
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
name|copcb
operator|->
name|co_channel
operator|=
operator|(
name|int
operator|)
name|ecnrq
operator|->
name|e_vc
expr_stmt|;
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_channel
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|copcb
operator|->
name|co_state
operator|=
name|OPEN
expr_stmt|;
name|copcb
operator|->
name|co_ifp
operator|=
name|ifp
expr_stmt|;
name|copcb
operator|->
name|co_laddr
operator|=
name|me
expr_stmt|;
name|copcb
operator|->
name|co_faddr
operator|=
name|peer
expr_stmt|;
if|if
condition|(
name|loop
condition|)
name|copcb
operator|->
name|co_flags
operator||=
name|CONSF_LOOPBACK
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"cons_incoming found XPCB 0x%x, loop 0x%x\n"
argument_list|,
name|copcb
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nco_laddr: "
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
operator|&
name|copcb
operator|->
name|co_laddr
argument_list|,
sizeof|sizeof
argument_list|(
name|copcb
operator|->
name|co_laddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nco_faddr: "
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|,
sizeof|sizeof
argument_list|(
name|copcb
operator|->
name|co_faddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
else|else
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|issue_clear_req
argument_list|(
name|ecnrq
operator|->
name|e_vc
argument_list|,
name|E_CO_OSI_UNSAP
argument_list|,
name|ifp
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|co_no_copcb
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|co_Rdrops
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* caller frees the mbuf so we don't have to do any such thing */
block|}
end_function

begin_comment
comment|/*  **************************** DEVICE cons ***************************  */
end_comment

begin_comment
comment|/*  * NAME:	cosns_output()  * CALLED FROM:  *  clnp - this routine is given as the device-output routine  *  for the adcom driver.  * FUNCTION and ARGUMENTS:  *  (ifp) is the cons/adcom, found by routing function.  *  (m0) is the clnp datagram.  *  (dst) is the destination address  * This routine finds an x.25 connection for datagram use and  * sends the packet.  */
end_comment

begin_function
name|int
name|cosns_output
parameter_list|(
name|ifp
parameter_list|,
name|m0
parameter_list|,
name|dst
parameter_list|)
block|{
return|return
name|cosns_output1
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|,
name|dst
argument_list|,
name|CLNP_proto
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* DEBUGGING ONLY? */
end_comment

begin_decl_stmt
name|int
name|total_cosns_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|total_cosns_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|total_pkts_to_clnp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *		The isop is passed here so that if we have set x25crud in the  *		pcb, it can be passed down to cons_connect. It could be null  *		however, in the case of tp4/x25/clnp  */
end_comment

begin_function
name|Static
name|int
name|cosns_output1
parameter_list|(
name|ifp
parameter_list|,
name|m0
parameter_list|,
name|dst
parameter_list|,
name|proto
parameter_list|,
name|isop
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|dst
decl_stmt|;
name|struct
name|protosw
modifier|*
name|proto
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
comment|/* NULL if coming from clnp */
block|{
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
init|=
name|m0
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|m_next
operator|==
name|MNULL
condition|)
block|{
break|break;
block|}
name|n
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
block|}
name|total_cosns_len
operator|+=
name|len
expr_stmt|;
name|total_cosns_cnt
operator|++
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cosns_output1( ifp 0x%x, m 0x%x, dst 0x%x )\n"
argument_list|,
name|ifp
argument_list|,
name|m0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|!
operator|(
name|copcb
operator|=
name|cons_find
argument_list|(
name|CONSF_DGM
argument_list|,
name|dst
argument_list|,
name|proto
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|struct
name|cons_pcb
modifier|*
name|newcopcb
decl_stmt|;
comment|/* so we can pass addr of this to pcballoc */
if|if
condition|(
operator|(
name|error
operator|=
name|cons_pcballoc
argument_list|(
operator|&
name|dummysocket
argument_list|,
operator|&
name|cons_isopcb
argument_list|,
name|CONSF_DGM
operator||
name|CONSF_OCRE
argument_list|,
name|proto
argument_list|,
operator|&
name|newcopcb
argument_list|)
operator|)
operator|!=
name|EOK
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cosns_output: no copcb; returns \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
argument_list|(
argument|void
argument_list|)
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|copcb
operator|=
name|newcopcb
expr_stmt|;
comment|/* abbreviated form of iso_pcbconnect(): */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|dst
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy x25crud into copcb if necessary */
if|if
condition|(
operator|(
name|isop
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|isop
operator|->
name|isop_x25crud_len
operator|>
literal|0
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|isop
operator|->
name|isop_x25crud
argument_list|,
name|copcb
operator|->
name|co_x25crud
argument_list|,
name|isop
operator|->
name|isop_x25crud_len
argument_list|)
expr_stmt|;
name|copcb
operator|->
name|co_x25crud_len
operator|=
name|isop
operator|->
name|isop_x25crud_len
expr_stmt|;
block|}
name|copcb
operator|->
name|co_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* NULL IF COMING FROM TP4! */
if|if
condition|(
name|error
operator|=
name|cons_connect
argument_list|(
name|copcb
argument_list|)
condition|)
block|{
comment|/* if it doesn't work */
comment|/* oh, dear, throw packet away */
name|remque
argument_list|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|copcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|copcb
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_CDATA
argument_list|)
name|printf
argument_list|(
literal|"cosns_output1 @ senddata: state 0x%x flags 0x%x channel 0x%x\n"
argument_list|,
name|copcb
operator|->
name|co_state
argument_list|,
name|copcb
operator|->
name|co_flags
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_channel
operator|!=
name|X_NOCHANNEL
argument_list|)
decl_stmt|;
name|error
operator|=
name|cons_senddata
argument_list|(
name|copcb
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|done
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  **************************** TRANSPORT cons ***************************  */
end_comment

begin_comment
comment|/*  * NAME:	cons_detach()  * CALLED FROM:  *  cons_usrreq() on PRU_DETACH  *  cons_netcmd() when TP releases a net connection  *	cons_slowtimo()  when timeout releases a net connection  * FUNCTION and ARGUMENT:  *  removes the copcb from the list of copcbs in use, and frees the mbufs.  *  detaches the pcb from the socket, where a socket exists.  * RETURN VALUE:  *  ENOTCONN if it couldn't find the copcb in the list of connections.  */
end_comment

begin_function
name|Static
name|int
name|cons_detach
parameter_list|(
name|copcb
parameter_list|)
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|copcb
operator|->
name|co_socket
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_detach( copcb 0x%x )\n"
argument_list|,
name|copcb
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|so
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_head
condition|)
block|{
if|if
condition|(
operator|!
name|soqremque
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|soqremque
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
condition|)
name|panic
argument_list|(
literal|"sofree dq"
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_head
operator|=
literal|0
expr_stmt|;
block|}
operator|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|copcb
operator|)
operator|->
name|isop_options
operator|=
literal|0
expr_stmt|;
comment|/* kludge */
name|iso_pcbdetach
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
comment|/* detaches from so */
block|}
else|else
block|{
name|remque
argument_list|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|copcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|copcb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Static
name|int
name|cons_clear_and_detach
parameter_list|(
name|copcb
parameter_list|,
name|clearreason
parameter_list|,
name|ctlcmd
parameter_list|)
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
name|int
name|clearreason
decl_stmt|;
name|int
name|ctlcmd
decl_stmt|;
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"Clear and Detach (0x%x, 0x%x, 0x%x)\n"
argument_list|,
name|copcb
argument_list|,
name|clearreason
argument_list|,
name|ctlcmd
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|clearreason
operator|!=
name|DONTCLEAR
condition|)
block|{
operator|(
name|void
operator|)
name|cons_clear
argument_list|(
name|copcb
argument_list|,
name|clearreason
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copcb
operator|->
name|co_proto
operator|&&
name|copcb
operator|->
name|co_proto
operator|->
name|pr_ctlinput
condition|)
call|(
modifier|*
name|copcb
operator|->
name|co_proto
operator|->
name|pr_ctlinput
call|)
argument_list|(
name|ctlcmd
argument_list|,
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|copcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_socket
operator|==
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* tp4, clnp users only */
operator|(
name|void
operator|)
name|cons_detach
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
block|}
comment|/* else detach will be called by the socket's closing */
else|else
block|{
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_socket
operator|!=
operator|&
name|dummysocket
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|copcb
operator|->
name|co_flags
operator|&
name|CONSF_DGM
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"END OF Clear and Detach (0x%x, 0x%x, 0x%x)\n"
argument_list|,
name|copcb
argument_list|,
name|clearreason
argument_list|,
name|ctlcmd
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_function

begin_function
name|Static
name|int
name|cons_pcbbind
parameter_list|(
name|copcb
parameter_list|,
name|nam
parameter_list|)
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|iso_pcbbind
argument_list|(
name|copcb
argument_list|,
name|nam
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* iso_pcbbind already ensured that if port< 1024 it's superuser */
comment|/* Now we check: must be in range 0 .. 23 or in range 1024 .. 99 */
if|if
condition|(
operator|(
name|copcb
operator|->
name|co_lport
operator|<
name|X25_PORT_RESERVED
operator|)
operator|||
operator|(
operator|(
name|copcb
operator|->
name|co_lport
operator|>=
name|ISO_PORT_RESERVED
operator|)
operator|&&
operator|(
name|copcb
operator|->
name|co_lport
operator|<=
name|X25_PORT_USERMAX
operator|)
operator|)
condition|)
block|{
name|munge
argument_list|(
name|copcb
operator|->
name|co_lport
argument_list|,
operator|(
operator|&
name|copcb
operator|->
name|co_laddr
operator|)
operator|->
name|siso_addr
operator|.
name|t37_idi
operator|+
name|ADDR37_IDI_LEN
argument_list|,
literal|1
comment|/* nibble */
argument_list|)
expr_stmt|;
name|munge
argument_list|(
name|copcb
operator|->
name|co_fport
argument_list|,
operator|(
operator|&
name|copcb
operator|->
name|co_faddr
operator|)
operator|->
name|siso_addr
operator|.
name|t37_idi
operator|+
name|ADDR37_IDI_LEN
argument_list|,
literal|1
comment|/* nibble */
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EADDRNOTAVAIL
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	cons_usrreq()  * CALLED FROM:  *  user level via proto switch  * FUNCTION and ARGUMENTS:  *  so : socket  *  req: which PRU* request  *  m : data or mbuf ptr into which to stash data  *	nam: mbuf ptr which is really a sockaddr_iso  *  ifq: in PRU_CONTROL case, an ifnet structure   * RETURN VALUE:  *  ENOTCONN if trying to do something which requires a connection  * 	 and it's not yet connected  *  EISCONN if trying to do something which cannot be done to a connection  * 	 but it's connected  * 	ENOBUFS if ran out of mbufs  * 	EWOULDBLOCK if in nonblocking mode& can't send right away  * 	EOPNOSUPP if req isn't supported  * 	E* other passed up from lower layers or from other routines  */
end_comment

begin_macro
name|cons_usrreq
argument_list|(
argument|so
argument_list|,
argument|req
argument_list|,
argument|m
argument_list|,
argument|nam
argument_list|,
argument|ifp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|cons_pcb
modifier|*
name|copcb
init|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cons_usrreq 0x%x so 0x%x copcb 0x%x\n"
argument_list|,
name|req
argument_list|,
name|so
argument_list|,
name|copcb
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|req
operator|==
name|PRU_CONTROL
condition|)
block|{
name|error
operator|=
name|iso_control
argument_list|(
name|so
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
name|nam
argument_list|,
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|copcb
operator|==
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
operator|&&
name|req
operator|!=
name|PRU_ATTACH
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOTCONN
return|;
block|}
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRU_ATTACH
case|:
if|if
condition|(
name|copcb
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
break|break;
block|}
name|soreserve
argument_list|(
name|so
argument_list|,
name|X25_SBSIZE
argument_list|,
name|X25_SBSIZE
argument_list|)
expr_stmt|;
comment|/* CONS size */
name|error
operator|=
name|cons_pcballoc
argument_list|(
name|so
argument_list|,
operator|&
name|cons_isopcb
argument_list|,
name|CONSF_XTS
argument_list|,
name|X25_proto
argument_list|,
operator|&
name|copcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_ABORT
case|:
comment|/* called from close() */
comment|/* called for each incoming connect queued on the parent (accepting)  		 * socket (SO_ACCEPTCONN);  		 */
name|error
operator|=
name|cons_detach
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_DETACH
case|:
comment|/* called from close() */
comment|/* called after disconnect was called iff was connected at the time 		 * of the close, or directly if socket never got connected */
name|error
operator|=
name|cons_detach
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_SHUTDOWN
case|:
comment|/* recv end may have been released; local credit might be zero  */
case|case
name|PRU_DISCONNECT
case|:
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|cons_clear
argument_list|(
name|copcb
argument_list|,
name|E_CO_HLI_DISCN
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_BIND
case|:
name|error
operator|=
name|cons_pcbbind
argument_list|(
name|copcb
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_LISTEN
case|:
if|if
condition|(
name|copcb
operator|->
name|co_lport
operator|==
literal|0
condition|)
name|error
operator|=
name|cons_pcbbind
argument_list|(
name|copcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_SOCKADDR
case|:
block|{
name|struct
name|sockaddr_iso
modifier|*
name|siso
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
decl_stmt|;
name|nam
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
expr_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_ifp
condition|)
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_laddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|siso
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|siso
operator|)
operator|->
name|siso_tsuffix
operator|=
name|copcb
operator|->
name|co_lport
expr_stmt|;
block|}
break|break;
case|case
name|PRU_PEERADDR
case|:
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTING
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|sockaddr_iso
modifier|*
name|siso
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
decl_stmt|;
name|nam
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|siso
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
case|case
name|PRU_CONNECT
case|:
comment|/* TODO: We need to bind to the RIGHT interface.  		 * The only way to have the right interface is to have 		 * the right route. 		 */
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"PRU_CONNECT 1: local tsuffix 0x%x so->so_head 0x%x nam:\n"
argument_list|,
name|copcb
operator|->
name|co_lport
argument_list|,
name|so
operator|->
name|so_head
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|copcb
operator|->
name|co_lport
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|cons_pcbbind
argument_list|(
name|copcb
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"PRU_CONNECT 2: local tsuffix 0x%x so->so_head 0x%x nam:\n"
argument_list|,
name|copcb
operator|->
name|co_lport
argument_list|,
name|so
operator|->
name|so_head
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|{
comment|/* change the destination address so the last 2 digits 			 * are the port/suffix/selector (whatever you want to call it) 			 */
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|siso
operator|->
name|siso_tsuffix
operator|<
name|X25_PORT_RESERVED
operator|)
operator|||
operator|(
operator|(
name|siso
operator|->
name|siso_tsuffix
operator|>=
name|ISO_PORT_RESERVED
operator|)
operator|&&
operator|(
name|siso
operator|->
name|siso_tsuffix
operator|<=
name|X25_PORT_USERMAX
operator|)
operator|)
condition|)
name|munge
argument_list|(
name|siso
operator|->
name|siso_tsuffix
argument_list|,
name|siso
operator|->
name|siso_addr
operator|.
name|t37_idi
operator|+
name|ADDR37_IDI_LEN
argument_list|,
literal|1
comment|/* nibble */
argument_list|)
expr_stmt|;
block|}
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|iso_pcbconnect
argument_list|(
name|copcb
argument_list|,
name|nam
argument_list|)
condition|)
break|break;
name|error
operator|=
name|cons_connect
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			remque((struct isopcb *)copcb); 			(void) m_free(dtom(copcb)); 			*/
break|break;
block|}
while|while
condition|(
operator|(
name|copcb
operator|->
name|co_state
operator|!=
name|OPEN
operator|)
operator|&&
operator|(
name|copcb
operator|->
name|co_socket
operator|->
name|so_error
operator|==
literal|0
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"PRU_CONNECT: error 0x%x sleeping on 0x%x\n"
argument_list|,
name|copcb
operator|->
name|co_socket
operator|->
name|so_error
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_state
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_state
argument_list|,
name|PZERO
operator|+
literal|3
argument_list|)
decl_stmt|;
block|}
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_channel
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|SET_CHANMASK
argument_list|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|copcb
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_ACCEPT
case|:
comment|/* so here is the NEW socket */
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
block|{
name|struct
name|sockaddr_iso
modifier|*
name|siso
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
decl_stmt|;
comment|/* copy the peer's address into the return argument */
name|nam
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|siso
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PRU_SEND
case|:
case|case
name|PRU_SENDEOT
case|:
comment|/* 		 * sosend calls this until sbspace goes negative. 		 * Sbspace may be made negative by appending this mbuf chain, 		 * possibly by a whole cluster. 		 */
block|{
comment|/* no need to actually queue this stuff and dequeue it, 			 * just bump the pointers in so_snd so that higher 			 * layer of socket code will cause it to sleep when 			 * we've run out of socket space 			 * TODO: 			 * Unfortunately that makes sbflush vomit so we have 			 * to allocate a single real mbuf (say size 240) 			 * and sballoc it and sbfree it upon CONS_SEND_DONE. 			 * Oh, my, is this sickening or what? 			 */
block|{
name|struct
name|mbuf
modifier|*
name|mx
decl_stmt|;
name|MGET
argument_list|(
name|mx
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|mx
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
name|sbappend
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_socket
operator|->
name|so_snd
argument_list|,
name|mx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CDATA
argument_list|)
name|printf
argument_list|(
literal|"X.25 Usrreq calling cons_senddata(0x%x, 0x%x)\n"
argument_list|,
name|copcb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|error
init|=
name|cons_senddata
argument_list|(
name|copcb
argument_list|,
name|m
argument_list|)
decl_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"PRU_SEND sent tsuffix 0x%x, m 0x%x error 0x%x\n"
argument_list|,
name|copcb
operator|->
name|co_lport
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|req
operator|==
name|PRU_SENDEOT
condition|)
block|{
while|while
condition|(
name|copcb
operator|->
name|co_socket
operator|->
name|so_snd
operator|.
name|sb_cc
operator|>
literal|0
condition|)
name|sbwait
argument_list|(
operator|&
name|copcb
operator|->
name|co_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PRU_CONTROL
case|:
name|error
operator|=
name|cons_ioctl
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_RCVD
case|:
case|case
name|PRU_RCVOOB
case|:
case|case
name|PRU_SENDOOB
case|:
comment|/* COULD support INTERRUPT packets as oob */
case|case
name|PRU_PROTOSEND
case|:
case|case
name|PRU_PROTORCV
case|:
case|case
name|PRU_SENSE
case|:
case|case
name|PRU_SLOWTIMO
case|:
case|case
name|PRU_CONNECT2
case|:
case|case
name|PRU_FASTTIMO
case|:
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cons_usrreq cmd 0x%x copcb 0x%x returned error 0x%x\n"
argument_list|,
name|req
argument_list|,
name|copcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|splx
parameter_list|(
name|s
parameter_list|)
function_decl|;
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * NAME:	cons_input()  * CALLED FROM:  *  consintr() through the isosw protosw for "transport" version of X25  * FUNCTION& ARGUMENTS:  *  process incoming data  */
end_comment

begin_expr_stmt
name|cons_input
argument_list|(
name|m
argument_list|,
name|faddr
argument_list|,
name|laddr
argument_list|,
name|so
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|faddr
decl_stmt|,
modifier|*
name|laddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not used */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cons_input( m 0x%x, so 0x%x)\n"
argument_list|,
name|m
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|sbappend
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|sbwakeup
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*    * NAME:	cons_ctloutput()  * CALLED FROM:  *  set/get sockopts()  * 	Presently the protosw has 0 in the ctloutput spot  *	 because we haven't inplemented anything yet.  * 	If there's reason to put some options in here,  * 	be sure to stick this routine name in the protosw in iso_proto.c  */
end_comment

begin_macro
name|cons_ctloutput
argument_list|(
argument|cmd
argument_list|,
argument|so
argument_list|,
argument|level
argument_list|,
argument|optname
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|,
name|level
decl_stmt|,
name|optname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|notdef
end_endif

begin_comment
comment|/*   * NAME:	cons_ctlinput()  * CALLED FROM:  *  lower layer when ECN_CLEAR occurs : this routine is here  *  for consistency - cons subnet service calls its higher layer  *  through the protosw entry.  * FUNCTION& ARGUMENTS:  *  cmd is a PRC_* command, list found in ../sys/protosw.h  *  copcb is the obvious.  *  This serves the higher-layer cons service.  * NOTE: this takes 3rd arg. because cons uses it to inform itself  *  of things (timeouts, etc) but has a pcb instead of an address.  */
end_comment

begin_macro
name|cons_ctlinput
argument_list|(
argument|cmd
argument_list|,
argument|sa
argument_list|,
argument|copcb
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
specifier|extern
name|u_char
name|inetctlerrmap
index|[]
decl_stmt|;
specifier|extern
name|int
name|iso_rtchange
parameter_list|()
function_decl|;
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cons_ctlinput( cmd 0x%x, copcb 0x%x)\n"
argument_list|,
name|cmd
argument_list|,
name|copcb
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* co_socket had better exist */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_CONS_SEND_DONE
case|:
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_socket
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|copcb
operator|->
name|co_flags
operator|&
name|CONSF_XTS
argument_list|)
expr_stmt|;
name|sbdrop
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_socket
operator|->
name|so_snd
argument_list|,
name|MLEN
argument_list|)
expr_stmt|;
name|sbwakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_ROUTEDEAD
case|:
name|error
operator|=
name|ENETUNREACH
expr_stmt|;
break|break;
case|case
name|PRC_TIMXCEED_REASS
case|:
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
comment|/* 		case PRC_QUENCH: 			iso_pcbnotify(&cons_pcb, sa, 					(int)inetctlerrmap[cmd], iso_rtchange); 			iso_pcbnotify(&tp_incoming_pending, sa, 					(int)inetctlerrmap[cmd], tpiso_quench); 			iso_pcbnotify(&tp_isopcb, sa, 					(int)inetctlerrmap[cmd], tpiso_quench); 	*/
case|case
name|PRC_IFDOWN
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|cons_isopcb
argument_list|,
name|sa
argument_list|,
operator|(
name|int
operator|)
name|inetctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|iso_rtchange
argument_list|)
expr_stmt|;
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_incoming_pending
argument_list|,
name|sa
argument_list|,
operator|(
name|int
operator|)
name|inetctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|iso_rtchange
argument_list|)
expr_stmt|;
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
name|sa
argument_list|,
operator|(
name|int
operator|)
name|inetctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|iso_rtchange
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"cons_ctlinput: unknown cmd 0x%x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|soisdisconnected
argument_list|(
name|copcb
operator|->
name|co_socket
argument_list|)
expr_stmt|;
name|sohasoutofband
argument_list|(
name|copcb
operator|->
name|co_socket
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *********************** SERVES ALL cons embodiments  *******************  */
end_comment

begin_comment
comment|/*   * NAME:	cons_chan_to_pcb()  * CALLED FROM:  *  cons_chan_to_tpcb() in tp_cons.c  * and in this file: incoming requests that give only a channel number, i.e.,  *  ECN_ACCEPT, ECN_RECEIVE, ECN_CLEAR  * FUNCTION:  *  identify the pcb assoc with that channel  * RETURN:  *  ptr to the pcb  */
end_comment

begin_function
name|struct
name|cons_pcb
modifier|*
ifdef|#
directive|ifdef
name|ARGO_DEBUG
name|cons_chan_to_pcb
parameter_list|(
name|channel
parameter_list|,
name|linenumber
parameter_list|)
name|int
name|linenumber
decl_stmt|;
else|#
directive|else
else|ARGO_DEBUG
function|cons_chan_to_pcb
parameter_list|(
name|channel
parameter_list|)
endif|#
directive|endif
endif|ARGO_DEBUG
specifier|register
name|int
name|channel
decl_stmt|;
block|{
specifier|register
name|struct
name|cons_pcb
modifier|*
modifier|*
name|copcblist
init|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|*
operator|)
name|Xpcblist
decl_stmt|;
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
comment|/* just to be sure */
name|channel
operator|=
name|channel
operator|&
literal|0xff
expr_stmt|;
for|for
control|(
name|copcb
operator|=
operator|*
name|copcblist
init|;
name|copcb
condition|;
name|copcb
operator|=
operator|*
operator|(
operator|++
name|copcblist
operator|)
control|)
block|{
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
while|while
condition|(
name|copcb
operator|!=
operator|*
name|copcblist
condition|)
block|{
if|if
condition|(
name|copcb
operator|->
name|co_channel
operator|==
name|channel
condition|)
goto|goto
name|found
goto|;
comment|/* want to break out of both loops */
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|copcb
operator|->
name|co_next
expr_stmt|;
block|}
block|}
name|found
label|:
comment|/* or maybe not... */
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cons_chan_to_pcb( 0x%x, %d ) %s 0x%x\n"
argument_list|,
name|channel
argument_list|,
name|linenumber
argument_list|,
name|copcb
condition|?
literal|"FOUND"
else|:
literal|"FAILED"
argument_list|,
name|copcb
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|copcb
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	is_me()  * CALLED FROM:  *  cons_incoming().  Perhaps could just expand in line.  * FUNCTION and ARGUMENTS:  * 	for the given remote address (remadr) if it exactly matches  *  one of the addresses of ME, and I am up as loopback,   *  return TRUE, else return FALSE.  * RETURNS:  *  Boolean  */
end_comment

begin_function
name|Static
name|int
name|is_me
parameter_list|(
name|remaddr
parameter_list|)
name|struct
name|sockaddr_iso
modifier|*
name|remaddr
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|consif
decl_stmt|;
comment|/* PHASE2: this is ok */
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
name|ifa_ifwithaddr
argument_list|(
name|remaddr
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"is_me: withaddr returns %s\n"
argument_list|,
name|ifa
condition|?
name|ifa
operator|->
name|ifa_ifp
operator|->
name|if_name
else|:
literal|"NONE"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|ifa
condition|)
block|{
comment|/* remaddr matches one of my interfaces exactly */
if|if
condition|(
name|ifa
operator|->
name|ifa_ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
block|{
name|ASSERT
argument_list|(
name|ifp
operator|==
name|ifa
operator|->
name|ifa_ifp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|find_error_reason
argument_list|(
name|ecnrq
argument_list|)
specifier|register
expr|struct
name|eicon_request
operator|*
name|ecnrq
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|u_char
name|x25_error_stats
index|[]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|cdm
decl_stmt|;
name|struct
name|e_clear_data
modifier|*
name|ecd
decl_stmt|;
name|cdm
operator|=
name|e_data
argument_list|(
name|ecnrq
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdm
operator|&&
name|cdm
operator|->
name|m_len
operator|>
literal|0
condition|)
block|{
name|ecd
operator|=
name|mtod
argument_list|(
name|cdm
argument_list|,
expr|struct
name|e_clear_data
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ecd
operator|->
name|ecd_cause
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0x80
case|:
comment|/* DTE originated; look at the diagnostic */
name|error
operator|=
operator|(
name|CONL_ERROR_MASK
operator||
name|ecd
operator|->
name|ecd_diagnostic
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|0x01
case|:
comment|/* number busy */
case|case
literal|0x81
case|:
case|case
literal|0x09
case|:
comment|/* Out of order */
case|case
literal|0x89
case|:
case|case
literal|0x11
case|:
comment|/* Remot Procedure Error */
case|case
literal|0x91
case|:
case|case
literal|0x19
case|:
comment|/* reverse charging accept not subscribed */
case|case
literal|0x99
case|:
case|case
literal|0x21
case|:
comment|/* Incampat destination */
case|case
literal|0xa1
case|:
case|case
literal|0x29
case|:
comment|/* fast select accept not subscribed */
case|case
literal|0xa9
case|:
case|case
literal|0x39
case|:
comment|/* ship absent */
case|case
literal|0xb9
case|:
case|case
literal|0x03
case|:
comment|/* invalid facil request */
case|case
literal|0x83
case|:
case|case
literal|0x0b
case|:
comment|/* access barred */
case|case
literal|0x8b
case|:
case|case
literal|0x13
case|:
comment|/* local procedure error */
case|case
literal|0x93
case|:
case|case
literal|0x05
case|:
comment|/* network congestion */
case|case
literal|0x85
case|:
case|case
literal|0x8d
case|:
comment|/* not obtainable */
case|case
literal|0x0d
case|:
case|case
literal|0x95
case|:
comment|/* RPOA out of order */
case|case
literal|0x15
case|:
comment|/* take out bit 8  				 * so we don't have to have so many perror entries  				 */
name|error
operator|=
operator|(
name|CONL_ERROR_MASK
operator||
literal|0x100
operator||
operator|(
name|ecd
operator|->
name|ecd_cause
operator|&
operator|~
literal|0x80
operator|)
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|0xc1
case|:
comment|/* gateway-detected proc error */
case|case
literal|0xc3
case|:
comment|/* gateway congestion */
name|error
operator|=
operator|(
name|CONL_ERROR_MASK
operator||
literal|0x100
operator||
name|ecd
operator|->
name|ecd_cause
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* otherwise, a *hopefully* valid perror exists in the e_reason field */
name|error
operator|=
name|ecnrq
operator|->
name|e_reason
expr_stmt|;
if|if
condition|(
name|error
operator|=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Incoming PKT TYPE 0x%x with reason 0x%x\n"
argument_list|,
name|ecnrq
operator|->
name|e_cmd
argument_list|,
name|ecnrq
operator|->
name|e_reason
argument_list|)
expr_stmt|;
name|error
operator|=
name|E_CO_HLI_DISCA
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|error
operator|&
literal|0x1ff
operator|==
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|&
literal|0x1ff
operator|>
sizeof|sizeof
argument_list|(
name|x25_error_stats
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x25_error_stats
index|[
name|error
operator|&
literal|0x1ff
index|]
operator|++
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * NAME:	consintr()  * CALLED FROM:  *  the eicon driver via software interrupt  * FUNCTION and ARGUMENTS:  *  processes incoming indications, passing them  *  along to clnp, tp, or x.25-transport as appropriate.  */
end_comment

begin_macro
name|consintr
argument_list|()
end_macro

begin_block
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|consif
decl_stmt|;
specifier|register
name|struct
name|eicon_request
modifier|*
name|ecnrq
decl_stmt|;
specifier|register
name|struct
name|cons_pcb
modifier|*
name|copcb
init|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|s
decl_stmt|,
name|s0
init|=
name|splnet
argument_list|()
decl_stmt|;
name|IncStat
argument_list|(
name|co_intr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Get next request off input queue  		 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|consintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_INCOMING
argument_list|)
name|printf
argument_list|(
literal|"cons intr() 0x%x m_off 0x%x m_len 0x%x dequeued\n"
argument_list|,
name|m
argument_list|,
name|m
condition|?
name|m
operator|->
name|m_off
else|:
literal|0
argument_list|,
name|m
condition|?
name|m
operator|->
name|m_len
else|:
literal|0
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|m_off
operator|!=
name|MMINOFF
operator|)
operator|||
operator|(
name|m
operator|->
name|m_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|IncStat
argument_list|(
name|co_Rdrops
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Cons R DROP! BAD MBUF FROM LL 0x%x sizeof(...) 0x%x\n"
argument_list|,
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ecnrq
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|eicon_request
operator|*
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_INCOMING
argument_list|)
name|printf
argument_list|(
literal|"INTR: e_cmd 0x%x, e_data 0x%x\n"
argument_list|,
name|ecnrq
operator|->
name|e_cmd
argument_list|,
name|e_data
argument_list|(
name|ecnrq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_data
argument_list|(
name|ecnrq
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* let's just look at the first few bytes */
comment|/* 				dump_buf( e_data(ecnrq), (e_data(ecnrq))->m_len + 12); 				*/
name|dump_buf
argument_list|(
name|e_data
argument_list|(
name|ecnrq
argument_list|)
argument_list|,
literal|20
operator|+
literal|12
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_CDATA
parameter_list|)
function_decl|tptrace
parameter_list|(
name|TPPTmisc
parameter_list|,
function_decl|"INTR: req_type m lun\n"
operator|,
function_decl|ecnrq->e_cmd
operator|,
function_decl|m
operator|,
function_decl|ecnrq->e_vc
operator|,
function_decl|0
block|)
empty_stmt|;
name|ENDTRACE
switch|switch
condition|(
name|ecnrq
operator|->
name|e_cmd
condition|)
block|{
case|case
name|ECN_ACK
case|:
comment|/* data put on the board */
name|IncStat
argument_list|(
name|co_ack
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ecnrq
operator|->
name|e_vc
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* from ACKWAIT to OPEN */
if|if
condition|(
operator|(
name|copcb
operator|=
ifdef|#
directive|ifdef
name|ARGO_DEBUG
name|cons_chan_to_pcb
argument_list|(
argument|(int)ecnrq->e_vc
argument_list|,
argument|__LINE__
argument_list|)
else|#
directive|else
else|ARGO_DEBUG
name|cons_chan_to_pcb
argument_list|(
operator|(
name|int
operator|)
name|ecnrq
operator|->
name|e_vc
argument_list|)
endif|#
directive|endif
endif|ARGO_DEBUG
operator|)
operator|==
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
condition|)
break|break;
name|copcb
operator|->
name|co_state
operator|=
name|OPEN
expr_stmt|;
comment|/* 				 * Anything on the pending queue for this connection? 				 */
if|if
condition|(
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|copcb
operator|->
name|co_proto
operator|->
name|pr_ctlinput
condition|)
comment|/* for the sake of higher layer protocol (tp) */
call|(
modifier|*
name|copcb
operator|->
name|co_proto
operator|->
name|pr_ctlinput
call|)
argument_list|(
name|PRC_CONS_SEND_DONE
argument_list|,
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|copcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|copcb
operator|->
name|co_pending
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* CAN ONLY DO 1 item here 					 * if you change this if to while, HA HA  					 * it'll go right back onto 					 * the pending queue (which means things will 					 * be reordered on the queue!) 					 */
if|if
condition|(
name|m0
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CDATA
argument_list|)
name|printf
argument_list|(
literal|"ACK sending pending queue 0x%x len 0x%x\n"
argument_list|,
name|m0
argument_list|,
name|m0
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|ASSERT
argument_list|(
name|m0
operator|->
name|m_len
operator|!=
literal|0
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|cons_senddata
argument_list|(
name|copcb
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* send more? */
break|break;
case|case
name|ECN_ACCEPT
case|:
comment|/* call accepted at other end */
comment|/* adr_src, adr_dst are as given in the ECN_CALL 				 * pcb field is copied from our ECN_CALL 				 * request, confirm gives me a channel number 				 */
name|ASSERT
argument_list|(
name|ecnrq
operator|->
name|e_vc
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|co_accept
argument_list|)
expr_stmt|;
if|if
condition|(
name|copcb
operator|=
ifdef|#
directive|ifdef
name|ARGO_DEBUG
name|cons_chan_to_pcb
argument_list|(
argument|(int)ecnrq->e_vc
argument_list|,
argument|__LINE__
argument_list|)
else|#
directive|else
else|ARGO_DEBUG
name|cons_chan_to_pcb
argument_list|(
operator|(
name|int
operator|)
name|ecnrq
operator|->
name|e_vc
argument_list|)
endif|#
directive|endif
endif|ARGO_DEBUG
condition|)
block|{
comment|/* error: already exists */
name|printf
argument_list|(
literal|"cons PANIC: dbl confirm for channel 0x%x\n"
argument_list|,
name|ecnrq
operator|->
name|e_vc
argument_list|)
expr_stmt|;
break|break;
block|}
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|ecnrq
operator|->
name|e_pcb
expr_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_myself
operator|!=
name|copcb
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
comment|/* TODO: REMOVE */
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BAD e_pcb from ecn (0x%x) cmd 0x%x\n"
argument_list|,
name|ecnrq
operator|->
name|e_pcb
argument_list|,
name|ecnrq
operator|->
name|e_cmd
argument_list|)
expr_stmt|;
name|mm
operator|=
name|dtom
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|->
name|m_type
operator|==
name|MT_FREE
condition|)
name|printf
argument_list|(
literal|"FREED MBUF!\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|ecnrq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ecnrq
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"BAD ecnrq"
argument_list|)
expr_stmt|;
break|break;
block|}
name|touch
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
name|copcb
operator|->
name|co_state
operator|=
name|OPEN
expr_stmt|;
name|copcb
operator|->
name|co_channel
operator|=
operator|(
name|int
operator|)
name|ecnrq
operator|->
name|e_vc
expr_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_socket
condition|)
block|{
comment|/* tp0 will take care of itself */
if|if
condition|(
name|copcb
operator|->
name|co_flags
operator|&
name|CONSF_XTS
condition|)
name|soisconnected
argument_list|(
name|copcb
operator|->
name|co_socket
argument_list|)
expr_stmt|;
comment|/* wake 'em up */
block|}
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_state
argument_list|)
expr_stmt|;
comment|/* 				 * Anything on the pending queue for this connection? 				 */
if|if
condition|(
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_len
operator|>
literal|0
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|copcb
operator|->
name|co_pending
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* CAN ONLY DO 1 item here 					 * if you change this if to while, HA HA  					 * it'll go right back onto 					 * the pending queue (which means things will 					 * be reordered on the queue!) 					 */
if|if
condition|(
name|m0
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CDATA
argument_list|)
name|printf
argument_list|(
literal|"ACPT sending pending queue 0x%x len 0x%x\n"
argument_list|,
name|m0
argument_list|,
name|m0
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|ASSERT
argument_list|(
name|m0
operator|->
name|m_len
operator|!=
literal|0
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|cons_senddata
argument_list|(
name|copcb
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ECN_REFUSE
case|:
comment|/* other end refused our connect request */
comment|/* src, dst are as given in the ECN_CALL */
name|IncStat
argument_list|(
name|co_refuse
argument_list|)
expr_stmt|;
name|copcb
operator|=
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
name|ecnrq
operator|->
name|e_pcb
expr_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_myself
operator|!=
name|copcb
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
comment|/* TODO: REMOVE */
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BAD e_pcb from ecn (0x%x) cmd 0x%x\n"
argument_list|,
name|ecnrq
operator|->
name|e_pcb
argument_list|,
name|ecnrq
operator|->
name|e_cmd
argument_list|)
expr_stmt|;
name|mm
operator|=
name|dtom
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|->
name|m_type
operator|==
name|MT_FREE
condition|)
name|printf
argument_list|(
literal|"FREED MBUF!\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|ecnrq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ecnrq
argument_list|)
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|copcb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|copcb
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"BAD ecnrq"
argument_list|)
expr_stmt|;
break|break;
block|}
name|touch
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
name|copcb
operator|->
name|co_state
operator|=
name|CLOSED
expr_stmt|;
comment|/* do we have to do a clear?? */
name|copcb
operator|->
name|co_channel
operator|=
name|X_NOCHANNEL
expr_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_socket
condition|)
block|{
name|copcb
operator|->
name|co_socket
operator|->
name|so_error
operator|=
name|ECONNREFUSED
expr_stmt|;
comment|/* TODO: if there's diagnostic info in the  					 * packet, and it's more useful than this E*, 					 * get it 					 */
name|soisdisconnected
argument_list|(
name|copcb
operator|->
name|co_socket
argument_list|)
expr_stmt|;
comment|/* wake 'em up */
name|IFDEBUG
argument_list|(
argument|D_INCOMING
argument_list|)
name|printf
argument_list|(
literal|"ECN_REFUSE: waking up 0x%x\n"
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_state
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|copcb
operator|->
name|co_state
argument_list|)
decl_stmt|;
block|}
comment|/* 				 * Anything on the pending queue for this connection? 				 */
while|while
condition|(
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_len
operator|>
literal|0
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|copcb
operator|->
name|co_pending
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ecnrq
operator|->
name|e_reason
operator|==
name|E_CO_NORESOURCES
condition|)
block|{
name|IncStat
argument_list|(
name|co_noresources
argument_list|)
expr_stmt|;
name|cons_clear_and_detach
argument_list|(
name|copcb
argument_list|,
name|DONTCLEAR
argument_list|,
name|PRC_QUENCH
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|copcb
operator|->
name|co_socket
condition|)
block|{
name|copcb
operator|->
name|co_socket
operator|->
name|so_error
operator|=
name|find_error_reason
argument_list|(
name|ecnrq
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ECN_CONNECT
case|:
comment|/* incoming call */
comment|/* 				 * ECN_CONNECT indication gives adc_src, adc_dst  and channel 				 */
name|ASSERT
argument_list|(
name|ecnrq
operator|->
name|e_vc
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|co_connect
argument_list|)
expr_stmt|;
name|cons_incoming
argument_list|(
name|ifp
argument_list|,
name|ecnrq
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECN_RESET
case|:
case|case
name|ECN_CLEAR
case|:
comment|/* 				 * ECN_CLEAR(indication) (if we can construct such a beast) 				 * gives e_vc,  				 * Throw away anything queued pending on this connection 				 * give a reset indication to the upper layer if TP 				 * free the mbufs  				 */
name|ASSERT
argument_list|(
name|ecnrq
operator|->
name|e_vc
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecnrq
operator|->
name|e_cmd
operator|==
name|ECN_CLEAR
condition|)
name|IncStat
argument_list|(
name|co_clear_in
argument_list|)
expr_stmt|;
else|else
name|IncStat
argument_list|(
name|co_reset_in
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGO_DEBUG
if|if
condition|(
operator|!
operator|(
name|copcb
operator|=
name|cons_chan_to_pcb
argument_list|(
operator|(
name|int
operator|)
name|ecnrq
operator|->
name|e_vc
argument_list|,
name|__LINE__
argument_list|)
operator|)
condition|)
else|#
directive|else
else|ARGO_DEBUG
if|if
condition|(
operator|!
operator|(
name|copcb
operator|=
name|cons_chan_to_pcb
argument_list|(
operator|(
name|int
operator|)
name|ecnrq
operator|->
name|e_vc
argument_list|)
operator|)
condition|)
endif|#
directive|endif
endif|ARGO_DEBUG
break|break;
while|while
condition|(
name|copcb
operator|->
name|co_pending
operator|.
name|ifq_len
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|copcb
operator|->
name|co_pending
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
name|copcb
operator|->
name|co_state
operator|=
name|CLOSED
expr_stmt|;
comment|/* do we have to do a clear? */
name|copcb
operator|->
name|co_channel
operator|=
name|X_NOCHANNEL
expr_stmt|;
name|cons_clear_and_detach
argument_list|(
name|copcb
argument_list|,
name|DONTCLEAR
argument_list|,
name|PRC_ROUTEDEAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|copcb
operator|->
name|co_socket
condition|)
block|{
name|copcb
operator|->
name|co_socket
operator|->
name|so_error
operator|=
name|find_error_reason
argument_list|(
name|ecnrq
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ECN_RECEIVE
case|:
comment|/* 				  * ECN_RECEIVE (read)  				  */
name|ASSERT
argument_list|(
name|ecnrq
operator|->
name|e_vc
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|co_receive
argument_list|)
expr_stmt|;
block|{
comment|/* TODO: REMOVE */
name|struct
name|mbuf
modifier|*
name|thedata
init|=
name|e_data
argument_list|(
name|ecnrq
argument_list|)
decl_stmt|;
name|u_int
modifier|*
name|firstint
init|=
name|mtod
argument_list|(
name|thedata
argument_list|,
name|u_int
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|firstint
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0x81000000
condition|)
block|{
comment|/* not clnp */
switch|switch
condition|(
operator|(
operator|(
operator|*
name|firstint
operator|)
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|20
condition|)
block|{
case|case
literal|0x1
case|:
case|case
literal|0x2
case|:
case|case
literal|0x3
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
case|case
literal|0x8
case|:
case|case
literal|0xc
case|:
case|case
literal|0xd
case|:
case|case
literal|0xe
case|:
case|case
literal|0xf
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|" ECN_RECEIVE! BAD DATA\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|thedata
argument_list|,
literal|20
operator|+
literal|12
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|copcb
operator|=
ifdef|#
directive|ifdef
name|ARGO_DEBUG
name|cons_chan_to_pcb
argument_list|(
argument|(int)ecnrq->e_vc
argument_list|,
argument|__LINE__
argument_list|)
else|#
directive|else
else|ARGO_DEBUG
name|cons_chan_to_pcb
argument_list|(
operator|(
name|int
operator|)
name|ecnrq
operator|->
name|e_vc
argument_list|)
endif|#
directive|endif
endif|ARGO_DEBUG
operator|)
operator|==
operator|(
expr|struct
name|cons_pcb
operator|*
operator|)
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_CDATA
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"ECN_RECEIVE DROPPED chan \n"
argument_list|,
name|ecnrq
operator|->
name|e_vc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
break|break;
block|}
name|touch
argument_list|(
name|copcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecnrq
operator|->
name|e_info
operator|&
name|ECN_INFO_RCVD_INT
condition|)
block|{
comment|/* interrupt packet */
name|printf
argument_list|(
literal|"consintr: interrupt pkttype : DROPPED\n"
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|co_intrpt_pkts_in
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|co_Rdrops
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* new way */
if|if
condition|(
name|copcb
operator|->
name|co_proto
operator|==
name|CLNP_proto
condition|)
block|{
comment|/* IP: put it on the queue and set soft interrupt */
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
specifier|extern
name|struct
name|ifqueue
name|clnlintrq
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|ifpp
decl_stmt|;
comment|/* for ptr to ifp */
specifier|register
name|struct
name|mbuf
modifier|*
name|data
init|=
name|e_data
argument_list|(
name|ecnrq
argument_list|)
decl_stmt|;
name|total_pkts_to_clnp
operator|++
expr_stmt|;
comment|/* when acting as a subnet service, have to prepend a 					 * pointer to the ifnet before handing this to clnp 					 * GAG 					 */
if|if
condition|(
operator|(
name|data
operator|->
name|m_off
operator|>
name|MMINOFF
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|snpa_hdr
argument_list|)
operator|)
operator|&&
operator|(
name|data
operator|->
name|m_off
operator|<=
name|MMAXOFF
operator|)
condition|)
block|{
name|data
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|snpa_hdr
argument_list|)
expr_stmt|;
name|data
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|snpa_hdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MGET
argument_list|(
name|ifpp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_XHEADER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifpp
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* frees everything */
return|return;
block|}
name|ifpp
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|snpa_hdr
argument_list|)
expr_stmt|;
name|ifpp
operator|->
name|m_act
operator|=
literal|0
expr_stmt|;
name|ifpp
operator|->
name|m_next
operator|=
name|data
expr_stmt|;
name|data
operator|=
name|ifpp
expr_stmt|;
block|}
name|IFTRACE
argument_list|(
argument|D_CDATA
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"-->CLNP copcb\n"
argument_list|,
name|copcb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
block|{
comment|/* 						 *	TODO: if we ever use esis/cons we have to 						 *	think of something reasonable to stick in the 						 *	snh_shost,snh_dhost fields. I guess 						 *	the x.121 address is what we want. 						 * 						 *	That would also require length fields in the 						 *	snpa_hdr structure. 						 */
name|struct
name|snpa_hdr
modifier|*
name|snh
init|=
name|mtod
argument_list|(
name|data
argument_list|,
expr|struct
name|snpa_hdr
operator|*
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|snh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|snpa_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ifp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|snh
operator|->
name|snh_ifp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifnet
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|mtod
argument_list|(
name|data
argument_list|,
expr|struct
name|ifnet
operator|*
operator|*
argument_list|)
operator|)
operator|=
name|ifp
expr_stmt|;
comment|/* KLUDGE */
name|ifq
operator|=
operator|&
name|clnlintrq
expr_stmt|;
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|ifq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_INCOMING
argument_list|)
name|printf
argument_list|(
literal|"DROPPED! ecnrq 0x%x, data 0x%x\n"
argument_list|,
name|m
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|splx
parameter_list|(
name|s0
parameter_list|)
function_decl|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_INCOMING
argument_list|)
name|printf
argument_list|(
literal|"0x%x enqueued on ip Q: m_len 0x%x m_type 0x%x m_off 0x%x\n"
argument_list|,
name|data
argument_list|,
name|data
operator|->
name|m_len
argument_list|,
name|data
operator|->
name|m_type
argument_list|,
name|data
operator|->
name|m_off
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|mtod
argument_list|(
name|data
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|data
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|e_data
parameter_list|(
name|ecnrq
parameter_list|)
init|=
operator|(
init|struct
name|mbuf
operator|*
init|)
function_decl|0;
name|schednetisr
argument_list|(
name|NETISR_CLNP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* HL is NOT clnp */
name|IFTRACE
argument_list|(
argument|D_CDATA
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"-->HL pr_input so copcb channel\n"
argument_list|,
name|copcb
operator|->
name|co_proto
operator|->
name|pr_input
argument_list|,
name|copcb
operator|->
name|co_socket
argument_list|,
name|copcb
argument_list|,
name|copcb
operator|->
name|co_channel
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
parameter_list|(
name|D_INCOMING
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"0x%x --> HL proto 0x%x chan 0x%x\n"
operator|,
function_decl|e_data
parameter_list|(
name|ecnrq
parameter_list|)
operator|,
function_decl|copcb->co_proto
operator|,
function_decl|copcb->co_channel
block|)
empty_stmt|;
name|ENDDEBUG
argument_list|(
operator|*
name|copcb
operator|->
name|co_proto
operator|->
name|pr_input
argument_list|)
argument_list|(
name|e_data
argument_list|(
name|ecnrq
argument_list|)
argument_list|,
operator|&
name|copcb
operator|->
name|co_faddr
argument_list|,
operator|&
name|copcb
operator|->
name|co_laddr
argument_list|,
name|copcb
operator|->
name|co_socket
argument_list|,
comment|/* used by cons-transport interface */
operator|(
name|copcb
operator|->
name|co_flags
operator|&
name|CONSF_DGM
operator|)
condition|?
literal|0
else|:
name|copcb
operator|->
name|co_channel
argument_list|)
expr_stmt|;
comment|/* used by tp-cons interface */
comment|/*  					 * the pr_input will free the data chain, so we must 					 * zero the ptr to is so that m_free doesn't panic 					 */
name|e_data
argument_list|(
name|ecnrq
argument_list|)
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
block|}
break|break;
default|default:
comment|/* error */
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"consintr: unknown request\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|IFDEBUG
argument_list|(
argument|D_INCOMING
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"consintr: m_freem( 0x%x )\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|ENDDEBUG
name|m_freem
parameter_list|(
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
unit|} 	splx
operator|(
name|s0
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * Process an ioctl request.  * also set-time-limit, extend-time-limit  * for ALL channels, the time-limit ioctls will be done by open-a-dummy-socket,  * do ioctl with the channel number, close the socket (dumb!).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
unit|cons_ioctl
operator|(
name|so
operator|,
name|cmd
operator|,
name|data
operator|)
expr|struct
name|socket
operator|*
name|so
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cons_ioctl( cmd 0x%x )\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ENDDEBUG
ifdef|#
directive|ifdef
name|notdef
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
endif|#
directive|endif
endif|notdef
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
block|}
endif|#
directive|endif
endif|notdef
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *************************************************************  *                                                           *  *                                                           *  * Interface to CO Subnetwork service from CLNP              *  * Must be a device interface.                             *****  *                                                          ***   *                                                           *  *                                                          Poof!  */
end_comment

begin_comment
comment|/*  * NAME:	consioctl()  * CALLED FROM:  * 	called through the ifnet structure.  * FUNCTION and ARGUMENTS:  *	the usual ioctl stuff  * RETURNS:  * 	E*  * SIDE EFFECTS:  * NOTES:  */
end_comment

begin_expr_stmt
name|consioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
specifier|register
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|int
name|error
init|=
literal|0
decl_stmt|;
name|void
name|consshutdown
parameter_list|()
function_decl|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_ISO
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
name|consinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"CANNOT config cons with address family %d\n"
argument_list|,
name|ifa
operator|->
name|ifa_addr
operator|.
name|sa_family
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"consioctl: set flags to x%x\n"
argument_list|,
name|ifr
operator|->
name|ifr_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"consioctl: ifp flags are x%x\n"
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|ifr
operator|->
name|ifr_flags
operator|&
name|IFF_LOOPBACK
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LOOPBACK
expr_stmt|;
else|else
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_LOOPBACK
expr_stmt|;
comment|/* if board is down but request takes it up, init the board */
if|if
condition|(
name|ifr
operator|->
name|ifr_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
name|consinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* if board is up but request takes it down, shut the board down */
if|if
condition|(
operator|(
operator|(
name|ifr
operator|->
name|ifr_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|consshutdown
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"consioctl: flags are x%x\n"
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ENDDEBUG
break|break;
case|case
name|SIOCGSTATUS
case|:
comment|/* warning: must coerse ifp to (struct ifstatus *) in order to use */
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"consioctl: EICON status request\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|#
directive|if
name|NECN
operator|>
literal|0
name|ecnioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
function_decl|;
else|#
directive|else
name|error
operator|=
name|ENODEV
expr_stmt|;
endif|#
directive|endif
endif|NECN>0
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * NAME:	consattach()  * CALLED FROM:  * 	cons_init() (which comes from autoconf)  * FUNCTION and ARGUMENTS:  *	creates an ifp and fills it in; calls ifattach() on it.	  * RETURNS:  *  no return value  * SIDE EFFECTS:  * NOTES:  */
end_comment

begin_macro
name|consattach
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|ifnet
argument_list|)
operator|>
name|MLEN
condition|)
block|{
name|printf
argument_list|(
literal|"Can't attach cons!  sizeof(struct ifnet)> MLEN\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_IFADDR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|printf
argument_list|(
literal|"Can't attach cons!  NO MBUFS!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ifnet
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|consif
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ifnet
operator|*
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"cons"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ECN_MTU
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|consinit
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|consioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|cosns_output
expr_stmt|;
comment|/* called by clnp */
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_LOOPBACK
expr_stmt|;
comment|/* default */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cons%d: pseudo device attached \n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * NAME:	consinit()  * CALLED FROM:  * 	consioctl()  * FUNCTION and ARGUMENTS:  * 	Initializes apropos data structures, etc.  *  Marks the device as up.  *  Zaps the address list.  *  Calls device layer restart on the device if necessary.  */
end_comment

begin_function
name|Static
name|consinit
parameter_list|(
name|_unit
parameter_list|)
specifier|register
name|int
name|_unit
decl_stmt|;
comment|/* unit to initialize */
block|{
name|struct
name|ifnet
modifier|*
name|ecnifp
parameter_list|()
function_decl|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|ecnifp
argument_list|(
name|_unit
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
condition|)
block|{
name|ecnrestart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|co_restart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|consif
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|consif
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|consif
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * NAME:	consshutdown()  * CALLED FROM:  *	cons_ioctl() when user takes down an interface w/ SIOCSIFFLAGS   * FUNCTION and ARGUMENTS:  *  calls lower layer shutdown routine on the device.  *  and marks the if as down if the if is the sw loopback pseudodevice.  * RETURNS:  *	no return value  */
end_comment

begin_function
name|void
name|consshutdown
parameter_list|(
name|_unit
parameter_list|)
specifier|register
name|int
name|_unit
decl_stmt|;
comment|/* unit to shutdown */
block|{
specifier|extern
name|struct
name|ifnet
modifier|*
name|ecnifp
parameter_list|()
function_decl|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|ecnifp
argument_list|(
name|_unit
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
condition|)
block|{
name|ecnshutdown
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|consif
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|consif
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|KERNEL
end_endif

begin_comment
comment|/*  * NAME:	munge()  * CALLED FROM:  * 	cons_pcbbind(), cons_usrreq()  * FUNCTION and ARGUMENTS:  *  Takes the argument (value) and stashes it into the last two  *  nibbles of an X.121 address.  Does this in the two nibbles beginning  *  at the location defined by the character pointer (dst_octet) and the   *  integer (dst_nibble).  Nibble 0 is the lower nibble (high  *  order 4 bits); nibble 1 is the low order 4 bits of *(dst_octet).  *  * RETURNS:  * 	no return value  */
end_comment

begin_function
name|Static
name|munge
parameter_list|(
name|value
parameter_list|,
name|dst_octet
parameter_list|,
name|dst_nibble
parameter_list|)
name|int
name|value
decl_stmt|;
name|caddr_t
name|dst_octet
decl_stmt|;
name|int
name|dst_nibble
decl_stmt|;
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"MUNGE: value 0x%x dst_octet 0x%x, nibble 0x%x)\n"
argument_list|,
name|value
argument_list|,
name|dst_octet
argument_list|,
name|dst_nibble
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|value
operator|>=
name|ISO_PORT_RESERVED
condition|)
name|value
operator|-=
literal|1000
expr_stmt|;
block|{
comment|/* convert so it  looks like a decimal number */
specifier|register
name|int
name|tens
decl_stmt|,
name|ones
decl_stmt|;
name|tens
operator|=
name|value
operator|/
literal|10
expr_stmt|;
name|ASSERT
argument_list|(
name|tens
operator|<=
literal|9
argument_list|)
expr_stmt|;
name|ones
operator|=
name|value
operator|-
operator|(
name|tens
operator|*
literal|10
operator|)
expr_stmt|;
name|value
operator|=
name|tens
operator|*
literal|16
operator|+
name|ones
expr_stmt|;
block|}
name|dst_octet
operator|--
expr_stmt|;
comment|/* leave nibble same 'cause it's one after the last set nibble */
operator|*
name|dst_octet
operator|&=
operator|~
operator|(
literal|0xff
operator|<<
operator|(
name|dst_nibble
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* zero it */
operator|*
name|dst_octet
operator||=
operator|(
operator|(
name|value
operator|>>
literal|4
operator|)
operator|<<
operator|(
name|dst_nibble
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|dst_nibble
operator|=
literal|1
operator|-
name|dst_nibble
expr_stmt|;
name|dst_octet
operator|+=
name|dst_nibble
expr_stmt|;
operator|*
name|dst_octet
operator|&=
operator|~
operator|(
literal|0xff
operator|<<
operator|(
name|dst_nibble
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* zero it */
operator|*
name|dst_octet
operator||=
operator|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|<<
operator|(
name|dst_nibble
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NAME:	unmunge()  * CALLED FROM:  *  DTEtoNSAP(), FACILtoNSAP()  * FUNCTION and ARGUMENTS:  *  return the port/tsuffix represented by the two digits found in a  *  bcd string beginning at the (dst_nibble)th nibble of the  *  octet BEFORE (dst_octet).  *    * dst_octet,dst_nibble  is the nibble after the one we'll look at  * RETURNS:  *  an integer, the port/tsuffix  *  Note- converts to a port> 1000 if necessary.  */
end_comment

begin_function
name|Static
name|int
name|unmunge
parameter_list|(
name|dst_octet
parameter_list|,
name|dst_nibble
parameter_list|)
name|caddr_t
name|dst_octet
decl_stmt|;
name|int
name|dst_nibble
decl_stmt|;
block|{
specifier|register
name|u_short
name|last
init|=
literal|0
decl_stmt|;
name|dst_octet
operator|--
expr_stmt|;
comment|/* leave nibble same 'cause it's one after the last set nibble */
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"unmunge: *octet 0x%x, nibble 0x%x\n"
argument_list|,
operator|*
name|dst_octet
argument_list|,
name|dst_nibble
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|last
init|=
operator|(
operator|(
operator|*
name|dst_octet
operator|)
operator|&
operator|(
literal|0xff
operator|<<
operator|(
name|dst_nibble
operator|<<
literal|2
operator|)
operator|)
operator|)
decl_stmt|;
name|dst_nibble
operator|=
literal|1
operator|-
name|dst_nibble
expr_stmt|;
name|dst_octet
operator|+=
name|dst_nibble
expr_stmt|;
name|last
operator||=
operator|(
operator|(
operator|*
name|dst_octet
operator|)
operator|&
operator|(
literal|0xff
operator|<<
operator|(
name|dst_nibble
operator|<<
literal|2
operator|)
operator|)
operator|)
expr_stmt|;
block|{
comment|/* convert to a decimal number */
specifier|register
name|int
name|tens
decl_stmt|,
name|ones
decl_stmt|;
name|tens
operator|=
operator|(
name|last
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
expr_stmt|;
name|ones
operator|=
name|last
operator|&
literal|0xf
expr_stmt|;
name|last
operator|=
name|tens
operator|*
literal|10
operator|+
name|ones
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"unmunge computes 0x%x\n"
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|int
operator|)
name|last
operator|+
literal|1000
operator|>=
name|ISO_PORT_RESERVED
condition|)
name|last
operator|+=
literal|1000
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"unmunge returns 0x%x\n"
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	make_partial_x25_packet()  *  * FUNCTION and ARGUMENTS:  *	Makes part of an X.25 call packet, for use by the eicon board.  *  (src) and (dst) are the NSAP-addresses of source and destination.  *	(proto) is the higher-layer protocol number (in iso.h)  *	(buf) is a ptr to a buffer into which to write this partial header.  *  *  The partial header looks like (choke):  *	octet		meaning  *  1			calling DTE len  |  called DTE len (lengths in nibbles)  *  2..n-1		called DTE addr  | (<-- boundary may be middle of an octet)  *  			calling DTE addr  | zero nibble to round to octet boundary.  *	n			Facility length (in octets)  *	n+1			Facility field, which is a set of:  *	  m			facil code  *	  m+1		facil param len (for>2-byte facilities) in octets  *	  m+2..p	facil param field  *  q			user data (protocol identification octet)  *   *  * RETURNS:   *  0 if OK  *  E* if failed.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|X25_1984
end_ifdef

begin_decl_stmt
name|int
name|cons_use_facils
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
else|X25_1984
end_else

begin_decl_stmt
name|int
name|cons_use_facils
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|X25_1984
end_endif

begin_decl_stmt
name|int
name|cons_use_udata
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* KLUDGE FOR DEBUGGING */
end_comment

begin_function
name|Static
name|int
name|make_partial_x25_packet
parameter_list|(
name|copcb
parameter_list|,
name|m
parameter_list|)
name|struct
name|cons_pcb
modifier|*
name|copcb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|sockaddr_iso
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|u_int
name|proto
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|caddr_t
name|buf
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
decl_stmt|;
specifier|register
name|caddr_t
name|ptr
init|=
name|buf
operator|+
literal|1
decl_stmt|;
comment|/* make room for 2 length nibbles */
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|buflen
init|=
literal|0
decl_stmt|;
name|caddr_t
name|facil_len
decl_stmt|;
name|int
name|oddness
init|=
literal|0
decl_stmt|;
name|src
operator|=
operator|&
name|copcb
operator|->
name|co_laddr
expr_stmt|;
name|dst
operator|=
operator|&
name|copcb
operator|->
name|co_faddr
expr_stmt|;
name|proto
operator|=
name|copcb
operator|->
name|co_proto
operator|->
name|pr_protocol
operator|,
name|flag
operator|=
name|copcb
operator|->
name|co_flags
operator|&
name|CONSF_XTS
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"make_partial_x25_packet(0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|proto
argument_list|,
name|m
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 * Note - order of addrs in x25 pkt hdr is wierd:  	 * calling len/called len/called addr/calling addr (p.40 ISO 8202) 	 */
if|if
condition|(
operator|(
name|len
operator|=
name|copcb
operator|->
name|co_peer_dte
operator|.
name|dtea_niblen
operator|)
operator|>
literal|0
condition|)
block|{
name|nibble_copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|copcb
operator|->
name|co_peer_dte
operator|.
name|dtea_addr
operator|)
argument_list|,
name|HIGH_NIBBLE
argument_list|,
name|ptr
argument_list|,
name|HIGH_NIBBLE
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|NSAPtoDTE
argument_list|(
name|ptr
argument_list|,
name|HIGH_NIBBLE
argument_list|,
name|dst
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
return|return
name|E_CO_OSI_UNSAP
return|;
block|}
block|}
operator|*
name|buf
operator|=
name|len
expr_stmt|;
comment|/* fill in called dte addr length */
name|ptr
operator|+=
name|len
operator|>>
literal|1
expr_stmt|;
comment|/* len is in nibbles */
name|oddness
operator|+=
name|len
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|NSAPtoDTE
argument_list|(
name|ptr
argument_list|,
literal|1
operator|-
operator|(
name|len
operator|&
literal|0x1
operator|)
argument_list|,
name|src
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
return|return
name|E_CO_OSI_UNSAP
return|;
block|}
name|ptr
operator|+=
name|len
operator|>>
literal|1
expr_stmt|;
comment|/* len is in nibbles */
operator|*
name|buf
operator||=
name|len
operator|<<
literal|4
expr_stmt|;
comment|/* fill in calling dte addr length */
name|oddness
operator|+=
name|len
operator|&
literal|0x1
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"make_partial  2: ptr 0x%x, len 0x%x oddness 0x%x\n"
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|,
name|oddness
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* if either of the addresses were an odd length, the count is off by 1 */
if|if
condition|(
name|oddness
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
block|}
comment|/* ptr now points to facil length (len of whole facil field in OCTETS */
name|facil_len
operator|=
name|ptr
operator|++
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"make_partial  calling: ptr 0x%x, len 0x%x\n"
argument_list|,
name|ptr
argument_list|,
name|src
operator|->
name|siso_addr
operator|.
name|isoa_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cons_use_facils
condition|)
block|{
operator|*
name|ptr
operator|=
literal|0xcb
expr_stmt|;
comment|/* calling facility code */
name|ptr
operator|++
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
comment|/* leave room for facil param len (in OCTETS + 1) */
name|ptr
operator|++
expr_stmt|;
comment|/* leave room for the facil param len (in nibbles), 				* high two bits of which indicate full/partial NSAP 				*/
name|len
operator|=
name|src
operator|->
name|siso_addr
operator|.
name|isoa_len
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|src
operator|->
name|siso_addr
operator|.
name|isoa_afi
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ptr
operator|-
literal|2
operator|)
operator|=
name|len
operator|+
literal|2
expr_stmt|;
comment|/* facil param len in octets */
operator|*
operator|(
name|ptr
operator|-
literal|1
operator|)
operator|=
name|len
operator|<<
literal|1
expr_stmt|;
comment|/* facil param len in nibbles */
name|ptr
operator|+=
name|len
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"make_partial  called: ptr 0x%x, len 0x%x\n"
argument_list|,
name|ptr
argument_list|,
name|dst
operator|->
name|siso_addr
operator|.
name|isoa_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
modifier|*
name|ptr
init|=
literal|0xc9
decl_stmt|;
comment|/* called facility code */
name|ptr
operator|++
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
comment|/* leave room for facil param len (in OCTETS + 1) */
name|ptr
operator|++
expr_stmt|;
comment|/* leave room for the facil param len (in nibbles), 				* high two bits of which indicate full/partial NSAP 				*/
name|len
operator|=
name|dst
operator|->
name|siso_addr
operator|.
name|isoa_len
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dst
operator|->
name|siso_addr
operator|.
name|isoa_afi
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ptr
operator|-
literal|2
operator|)
operator|=
name|len
operator|+
literal|2
expr_stmt|;
comment|/* facil param len = addr len + 1 for each of these 						  * two length fields, in octets */
operator|*
operator|(
name|ptr
operator|-
literal|1
operator|)
operator|=
name|len
operator|<<
literal|1
expr_stmt|;
comment|/* facil param len in nibbles */
name|ptr
operator|+=
name|len
expr_stmt|;
block|}
operator|*
name|facil_len
operator|=
name|ptr
operator|-
name|facil_len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|facil_len
operator|>
name|X25_FACIL_LEN_MAX
condition|)
return|return
name|E_CO_PNA_LONG
return|;
if|if
condition|(
name|cons_use_udata
condition|)
block|{
if|if
condition|(
name|copcb
operator|->
name|co_x25crud_len
operator|>
literal|0
condition|)
block|{
comment|/* 			 *	The user specified something. Stick it in 			 */
name|bcopy
argument_list|(
name|copcb
operator|->
name|co_x25crud
argument_list|,
name|ptr
argument_list|,
name|copcb
operator|->
name|co_x25crud_len
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|copcb
operator|->
name|co_x25crud_len
expr_stmt|;
block|}
else|else
block|{
comment|/* protocol identifier */
switch|switch
condition|(
name|proto
condition|)
block|{
comment|/* unfortunately all are considered 1 protocol */
case|case
name|ISOPROTO_TP0
case|:
case|case
name|ISOPROTO_TP1
case|:
case|case
name|ISOPROTO_TP2
case|:
case|case
name|ISOPROTO_TP3
case|:
case|case
name|ISOPROTO_TP4
case|:
case|case
name|ISOPROTO_CLTP
case|:
comment|/* no user data for TP */
break|break;
case|case
name|ISOPROTO_CLNP
case|:
operator|*
name|ptr
operator|=
literal|0x81
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
comment|/* count the proto id byte! */
break|break;
case|case
name|ISOPROTO_INACT_NL
case|:
operator|*
name|ptr
operator|=
literal|0x0
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
comment|/* count the proto id byte! */
break|break;
case|case
name|ISOPROTO_X25
case|:
operator|*
name|ptr
operator|=
literal|0xff
expr_stmt|;
comment|/* reserved for future extensions */
comment|/* we're stealing this value for local use */
name|ptr
operator|++
expr_stmt|;
comment|/* count the proto id byte! */
break|break;
default|default:
return|return
name|EPROTONOSUPPORT
return|;
block|}
block|}
block|}
name|buflen
operator|=
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|buf
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
name|D_CDUMP_REQ
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"ECN_CONNECT DATA buf 0x%x len %d (0x%x)\n"
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buflen
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"+%d: %x %x %x %x    %x %x %x %x\n"
argument_list|,
name|i
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|3
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|4
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|5
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|6
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|7
operator|)
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|8
expr_stmt|;
block|}
name|ENDDEBUG
name|IFDEBUG
argument_list|(
name|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"make_partial returns buf 0x%x size 0x%x bytes\n"
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buflen
argument_list|)
decl_stmt|;
name|ENDDEBUG
name|ASSERT
argument_list|(
name|X25_PARTIAL_PKT_LEN_MAX
operator|<
name|MLEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|buflen
operator|>
name|X25_PARTIAL_PKT_LEN_MAX
condition|)
return|return
name|E_CO_PNA_LONG
return|;
name|m
operator|->
name|m_len
operator|=
name|buflen
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	NSAPtoDTE()  * CALLED FROM:  *  make_partial_x25_packet()  * FUNCTION and ARGUMENTS:   *  get a DTE address from an NSAP-address (struct sockaddr_iso)  *  (dst_octet) is the octet into which to begin stashing the DTE addr  *  (dst_nibble) takes 0 or 1.  1 means begin filling in the DTE addr  * 		in the high-order nibble of dst_octet.  0 means low-order nibble.  *  (addr) is the NSAP-address  *  (flag) is true if the transport suffix is to become the  *		last two digits of the DTE address  *  A DTE address is a series of BCD digits  *  *	A DTE address may have leading zeros. The are significant.  *		1 digit per nibble, may be an odd number of nibbles.  *  *  An NSAP-address has the DTE address in the IDI. Leading zeros are  *		significant. Trailing hex f indicates the end of the DTE address.  *  	Also is a series of BCD digits, one per nibble.  *  * RETURNS  *  # significant digits in the DTE address, -1 if error.  */
end_comment

begin_function
name|Static
name|int
name|NSAPtoDTE
parameter_list|(
name|dst_octet
parameter_list|,
name|dst_nibble
parameter_list|,
name|addr
parameter_list|)
name|caddr_t
name|dst_octet
decl_stmt|;
name|int
name|dst_nibble
decl_stmt|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|addr
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|u_char
name|x121string
index|[
literal|7
index|]
decl_stmt|;
comment|/* maximum is 14 digits */
name|int
name|x121strlen
decl_stmt|;
name|struct
name|dte_addr
modifier|*
name|dtea
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"NSAPtoDTE: nsap: %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|addr
operator|->
name|siso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|error
init|=
name|iso_8208snparesolve
argument_list|(
name|addr
argument_list|,
name|x121string
argument_list|,
operator|&
name|x121strlen
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* no snpa - cannot send */
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"NSAPtoDTE: 8208resolve: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
literal|0
return|;
block|}
name|ASSERT
argument_list|(
name|x121strlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|dte_addr
argument_list|)
argument_list|)
expr_stmt|;
name|dtea
operator|=
operator|(
expr|struct
name|dte_addr
operator|*
operator|)
name|x121string
expr_stmt|;
name|x121strlen
operator|=
name|dtea
operator|->
name|dtea_niblen
expr_stmt|;
name|nibble_copy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x121string
argument_list|,
name|HIGH_NIBBLE
argument_list|,
name|dst_octet
argument_list|,
name|dst_nibble
argument_list|,
name|x121strlen
argument_list|)
expr_stmt|;
return|return
name|x121strlen
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	FACILtoNSAP()  * CALLED FROM:  *  parse_facil()  * FUNCTION and ARGUMENTS:  * 	Creates and NSAP in the sockaddr_iso (addr) from the  *  x.25 facility found at (buf), of length (buf_len).  * RETURNS:  *  0 if ok, non-zero if error;  */
end_comment

begin_function
name|Static
name|int
name|FACILtoNSAP
parameter_list|(
name|buf
parameter_list|,
name|buf_len
parameter_list|,
name|addr
parameter_list|)
name|caddr_t
name|buf
decl_stmt|;
name|u_char
name|buf_len
decl_stmt|;
comment|/* in bytes */
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|addr
decl_stmt|;
block|{
name|int
name|len_in_nibbles
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"FACILtoNSAP( 0x%x, 0x%x, 0x%x )\n"
argument_list|,
name|buf
argument_list|,
name|buf_len
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|len_in_nibbles
init|=
operator|*
name|buf
decl_stmt|;
comment|/* despite the fact that X.25 makes us put a length in nibbles 	 * here, the NSAP-addrs are always in full octets 	 */
name|buf
operator|++
expr_stmt|;
name|bzero
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf_len
operator|<=
literal|1
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_len
operator|>
literal|1
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|/* error */
block|}
name|ASSERT
argument_list|(
name|len_in_nibbles
operator|==
operator|(
name|buf_len
operator|-
literal|1
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len_in_nibbles
operator|!=
operator|(
name|buf_len
operator|-
literal|1
operator|)
operator|<<
literal|1
condition|)
block|{
return|return
operator|-
literal|2
return|;
comment|/* error */
block|}
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|&
name|addr
operator|->
name|siso_addr
operator|.
name|isoa_afi
argument_list|,
name|buf_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|->
name|siso_addr
operator|.
name|isoa_len
operator|=
name|buf_len
operator|-
literal|1
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"FACILtoNSAP: isoa_len 0x%x\n"
argument_list|,
name|addr
operator|->
name|siso_addr
operator|.
name|isoa_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|addr
operator|->
name|siso_family
init|=
name|AF_ISO
decl_stmt|;
name|addr
operator|->
name|siso_tsuffix
operator|=
name|unmunge
argument_list|(
operator|(
operator|(
name|caddr_t
operator|)
operator|&
name|addr
operator|->
name|siso_addr
operator|.
name|t37_idi
operator|)
operator|+
name|ADDR37_IDI_LEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	DTEtoNSAP()  * CALLED FROM:  *  parse_facil()  * FUNCTION and ARGUMENTS:  *  Creates a type 37 NSAP in the sockaddr_iso (addr)  * 	from a DTE address found at the (src_nibble)th nibble of  * 	the octet (src_octet), of length (src_nib_len).  *    * RETURNS:  *  0 if ok; E* otherwise.  */
end_comment

begin_function
name|Static
name|int
name|DTEtoNSAP
parameter_list|(
name|addr
parameter_list|,
name|src_octet
parameter_list|,
name|src_nibble
parameter_list|,
name|src_nib_len
parameter_list|)
name|struct
name|sockaddr_iso
modifier|*
name|addr
decl_stmt|;
name|caddr_t
name|src_octet
decl_stmt|;
name|int
name|src_nibble
decl_stmt|,
name|src_nib_len
decl_stmt|;
block|{
name|caddr_t
name|dst_octet
decl_stmt|;
name|int
name|pad_len
decl_stmt|;
name|int
name|dst_nibble
decl_stmt|;
name|char
name|first_nib
decl_stmt|;
specifier|static
name|char
modifier|*
name|z_pad
init|=
literal|"\0\0\0\0\0\0\0"
decl_stmt|;
specifier|static
name|char
modifier|*
name|f_pad
init|=
literal|"\021\021\021\021\021\021\021"
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"DTEtoNSAP( 0x%x, 0x%x, 0x%x, 0x%x )\n"
argument_list|,
name|src_octet
argument_list|,
name|src_nibble
argument_list|,
name|src_nib_len
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|bzero
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
argument_list|)
decl_stmt|;
name|addr
operator|->
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
comment|/* 	 * Coming from a DTE addr it's always type 37. 	 * src_octet<-- starting place in the NSAP-address of  	 * the embedded SNPA-address (x.121 addr or DTE addr). 	 */
name|addr
operator|->
name|siso_addr
operator|.
name|isoa_afi
operator|=
literal|0x37
expr_stmt|;
comment|/* first, figure out what pad to use and pad */
name|first_nib
operator|=
operator|(
operator|*
name|src_octet
operator|)
operator|>>
operator|(
name|SHIFT
operator|*
operator|(
literal|1
operator|-
name|src_nibble
operator|)
operator|)
expr_stmt|;
name|pad_len
operator|=
operator|(
name|ADDR37_IDI_LEN
operator|<<
literal|1
operator|-
name|src_nib_len
operator|)
expr_stmt|;
name|nibble_copy
argument_list|(
name|first_nib
condition|?
name|z_pad
else|:
name|f_pad
argument_list|,
name|HIGH_NIBBLE
argument_list|,
operator|(
name|caddr_t
operator|)
name|addr
operator|->
name|siso_addr
operator|.
name|t37_idi
argument_list|,
name|HIGH_NIBBLE
argument_list|,
name|pad_len
argument_list|)
expr_stmt|;
name|dst_octet
operator|+=
operator|(
name|pad_len
operator|>>
literal|1
operator|)
expr_stmt|;
name|dst_nibble
operator|=
literal|1
operator|-
operator|(
name|pad_len
operator|&
literal|0x1
operator|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"DTEtoNSAP 2( 0x%x, 0x%x, 0x%x, 0x%x )\n"
argument_list|,
name|dst_octet
argument_list|,
name|dst_nibble
argument_list|,
name|pad_len
argument_list|,
name|src_nib_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* now copy the dte address */
name|nibble_copy
argument_list|(
name|src_octet
argument_list|,
name|src_nibble
argument_list|,
name|dst_octet
argument_list|,
name|dst_nibble
argument_list|,
name|src_nib_len
argument_list|)
decl_stmt|;
name|addr
operator|->
name|siso_addr
operator|.
name|isoa_len
operator|=
name|ADDR37_IDI_LEN
operator|+
name|ADDR37_DSP_LEN
operator|+
literal|1
comment|/* for afi */
expr_stmt|;
comment|/* kludge */
name|addr
operator|->
name|siso_tsuffix
operator|=
name|unmunge
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|addr
operator|->
name|siso_addr
operator|.
name|t37_idi
index|[
name|ADDR37_IDI_LEN
index|]
operator|)
argument_list|,
name|HIGH_NIBBLE
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"DTEtoNSAP 3 returning 0 tsuffix 0x%x\n"
argument_list|,
name|addr
operator|->
name|siso_tsuffix
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
literal|0
return|;
comment|/* ok */
block|}
end_function

begin_comment
comment|/*  * FUNCTION and ARGUMENTS:  *	parses (buf_len) bytes beginning at (buf) and finds  *  a called nsap, a calling nsap, and protocol identifier.  * RETURNS:  *  0 if ok, E* otherwise.  */
end_comment

begin_function
name|Static
name|int
name|parse_facil
parameter_list|(
name|buf
parameter_list|,
name|buf_len
parameter_list|,
name|called
parameter_list|,
name|calling
parameter_list|,
name|proto
parameter_list|,
name|peer_dte
parameter_list|)
name|caddr_t
name|buf
decl_stmt|;
name|u_char
name|buf_len
decl_stmt|;
comment|/* in bytes */
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|called
decl_stmt|,
decl|*
name|calling
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dte_addr
modifier|*
name|peer_dte
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|caddr_t
name|ptr
decl_stmt|;
name|caddr_t
name|facil_len
decl_stmt|;
name|int
name|facil_param_len
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|addr
decl_stmt|;
name|int
name|addrs_not_parsed
init|=
operator|(
name|int
operator|)
literal|0xcb
operator|+
operator|(
name|int
operator|)
literal|0xc9
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"parse_facil( 0x%x, 0x%x, 0x%x, 0x%x, 0x%x )\n"
argument_list|,
name|buf
argument_list|,
name|buf_len
argument_list|,
name|called
argument_list|,
name|calling
argument_list|,
operator|*
name|proto
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* find the beginnings of the facility fields in buf  	 * by skipping over the called& calling DTE addresses 	 * i<- # nibbles in called + # nibbles in calling 	 * i += 1 so that an odd nibble gets rounded up to even   	 * before dividing by 2, then divide by two to get # octets 	 */
name|i
init|=
call|(
name|int
call|)
argument_list|(
operator|*
name|buf
operator|>>
literal|4
argument_list|)
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
name|buf
operator|&
literal|0xf
argument_list|)
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|ptr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|buf
operator|+
operator|(
name|i
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* now i is number of octets */
name|ptr
operator|++
expr_stmt|;
comment|/* plus one for the DTE lengths byte */
comment|/* ptr now is at facil_length field */
name|facil_len
operator|=
name|ptr
operator|++
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"parse_facils: facil length is  0x%x\n"
argument_list|,
operator|(
name|int
operator|)
operator|*
name|facil_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
while|while
condition|(
name|ptr
operator|<=
call|(
name|caddr_t
call|)
argument_list|(
name|facil_len
operator|+
operator|(
name|int
operator|)
operator|*
name|facil_len
argument_list|)
condition|)
block|{
comment|/* get NSAP addresses from facilities */
switch|switch
condition|(
operator|*
name|ptr
condition|)
block|{
case|case
literal|0xcb
case|:
name|facil_param_len
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|calling
expr_stmt|;
name|addrs_not_parsed
operator|-=
literal|0xcb
expr_stmt|;
break|break;
case|case
literal|0xc9
case|:
name|facil_param_len
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|called
expr_stmt|;
name|addrs_not_parsed
operator|-=
literal|0xc9
expr_stmt|;
break|break;
comment|/* from here to default are legit cases that I ignore */
comment|/* variable length */
case|case
literal|0xca
case|:
comment|/* end-to-end transit delay negot */
case|case
literal|0xc6
case|:
comment|/* network user id */
case|case
literal|0xc5
case|:
comment|/* charging info : indicating monetary unit */
case|case
literal|0xc2
case|:
comment|/* charging info : indicating segment count */
case|case
literal|0xc1
case|:
comment|/* charging info : indicating call duration */
case|case
literal|0xc4
case|:
comment|/* RPOA extended format */
case|case
literal|0xc3
case|:
comment|/* call redirection notification */
name|facil_param_len
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
comment|/* 1 octet */
case|case
literal|0x0a
case|:
comment|/* min. throughput class negot */
case|case
literal|0x02
case|:
comment|/* throughput class */
case|case
literal|0x03
case|:
case|case
literal|0x47
case|:
comment|/* CUG shit */
case|case
literal|0x0b
case|:
comment|/* expedited data negot */
case|case
literal|0x01
case|:
comment|/* Fast select or reverse charging  						(example of intelligent protocol design) */
case|case
literal|0x04
case|:
comment|/* charging info : requesting service */
case|case
literal|0x08
case|:
comment|/* called line addr modified notification */
name|facil_param_len
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
comment|/* any 2 octets */
case|case
literal|0x42
case|:
comment|/* pkt size */
case|case
literal|0x43
case|:
comment|/* win size */
case|case
literal|0x44
case|:
comment|/* RPOA basic format */
case|case
literal|0x41
case|:
comment|/* bilateral CUG shit */
case|case
literal|0x49
case|:
comment|/* transit delay selection and indication */
name|facil_param_len
operator|=
literal|2
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
comment|/* don't have any 3 octets */
comment|/* 				facil_param_len = 3; 				*/
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BOGUS FACILITY CODE facil_len 0x%x *facil_len 0x%x, ptr 0x%x *ptr 0x%x\n"
argument_list|,
name|facil_len
argument_list|,
operator|*
name|facil_len
argument_list|,
name|ptr
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* facil that we don't handle */
return|return
name|E_CO_HLI_REJI
return|;
block|}
name|ptr
operator|++
expr_stmt|;
comment|/* one for facil code */
if|if
condition|(
name|facil_param_len
operator|==
literal|0
condition|)
comment|/* variable length */
name|facil_param_len
operator|=
operator|(
name|int
operator|)
operator|*
name|ptr
expr_stmt|;
comment|/* 1 + the real facil param */
if|if
condition|(
name|addr
operator|&&
name|FACILtoNSAP
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
name|facil_param_len
operator|-
literal|1
argument_list|,
name|addr
argument_list|)
condition|)
block|{
return|return
name|E_CO_OSI_UNSAP
return|;
block|}
name|ptr
operator|+=
name|facil_param_len
expr_stmt|;
block|}
if|if
condition|(
name|addrs_not_parsed
condition|)
block|{
comment|/* no facilities, get NSAP addresses from DTE addresses */
specifier|register
name|int
name|ed
decl_stmt|,
name|ing
decl_stmt|;
name|ed
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
name|buf
operator|&
literal|0xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"Called DTE address absent"
argument_list|)
expr_stmt|;
block|}
name|DTEtoNSAP
argument_list|(
name|called
argument_list|,
operator|(
name|buf
operator|+
literal|1
operator|)
comment|/*octet*/
argument_list|,
literal|1
comment|/*nibble*/
argument_list|,
name|ed
argument_list|)
expr_stmt|;
name|ing
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
name|buf
operator|>>
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ing
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cons: panic: Calling DTE address absent"
argument_list|)
expr_stmt|;
return|return
name|E_CO_HLI_REJI
return|;
block|}
name|nibble_copy
argument_list|(
operator|(
name|buf
operator|+
operator|(
name|ed
operator|>>
literal|1
operator|)
operator|+
literal|1
operator|)
comment|/*octet*/
argument_list|,
literal|1
operator|-
operator|(
name|ed
operator|&
literal|0x1
operator|)
comment|/*nibble*/
argument_list|,
name|peer_dte
operator|->
name|dtea_addr
argument_list|,
name|HIGH_NIBBLE
argument_list|,
name|ing
argument_list|)
expr_stmt|;
name|DTEtoNSAP
argument_list|(
name|calling
argument_list|,
operator|(
name|buf
operator|+
operator|(
name|ed
operator|>>
literal|1
operator|)
operator|+
literal|1
operator|)
comment|/*octet*/
argument_list|,
literal|1
operator|-
operator|(
name|ed
operator|&
literal|0x1
operator|)
comment|/*nibble*/
argument_list|,
name|ing
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|ptr
operator|==
call|(
name|caddr_t
call|)
argument_list|(
name|facil_len
operator|+
literal|1
operator|+
operator|(
name|int
operator|)
operator|*
name|facil_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  	 * now look for user data to find protocol identifier 	 */
if|if
condition|(
name|ptr
operator|==
name|buf
operator|+
name|buf_len
condition|)
block|{
comment|/* no user data */
operator|*
name|proto
operator|=
name|ISOPROTO_TP
expr_stmt|;
comment|/* to proto id --> use TP */
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"NO USER DATA: use TP\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|ptr
operator|<
name|buf
operator|+
name|buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|>=
name|buf
operator|+
name|buf_len
condition|)
block|{
name|printf
argument_list|(
literal|"ptr 0x%x buf 0x%x buf_len 0x%x buf+buf_len 0x%x\n"
argument_list|,
name|ptr
argument_list|,
name|buf
argument_list|,
name|buf_len
argument_list|,
name|buf
operator|+
name|buf_len
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"proto byte 0x%x, value 0x%x\n"
argument_list|,
name|ptr
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
name|ENDDEBUG
switch|switch
condition|(
operator|*
name|ptr
condition|)
block|{
case|case
literal|0x81
case|:
operator|*
name|proto
operator|=
name|ISOPROTO_CLNP
expr_stmt|;
break|break;
case|case
literal|0x0
case|:
operator|*
name|proto
operator|=
name|ISOPROTO_INACT_NL
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* for EAN */
operator|*
name|proto
operator|=
name|ISOPROTO_TP
expr_stmt|;
comment|/* can check for "an2" or can ignore the rest of the u data */
break|break;
case|case
literal|0xff
case|:
comment|/* reserved for future extensions */
operator|*
name|proto
operator|=
name|ISOPROTO_X25
expr_stmt|;
break|break;
case|case
literal|0x82
case|:
comment|/* 9542 not implemented */
case|case
literal|0x84
case|:
comment|/* 8878/A SNDCP not implemented */
default|default:
operator|*
name|proto
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|E_CO_HLI_PROTOID
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|NARGOXTWENTYFIVE> 0
end_endif

end_unit

