begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * $Header: iso_pcb.c,v 4.5 88/06/29 14:59:56 hagens Exp $  * $Source: /usr/argo/sys/netiso/RCS/iso_pcb.c,v $  *	@(#)iso_pcb.c	7.6 (Berkeley) %G%  *  * Iso address family net-layer(s) pcb stuff. NEH 1/29/87  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: iso_pcb.c,v 4.5 88/06/29 14:59:56 hagens Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"clnp.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"iso_pcb.h"
end_include

begin_include
include|#
directive|include
file|"iso_var.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_define
define|#
directive|define
name|PCBNULL
value|(struct isopcb *)0
end_define

begin_decl_stmt
name|struct
name|iso_addr
name|zeroiso_addr
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FUNCTION:		iso_pcballoc  *  * PURPOSE:			creates an isopcb structure in an mbuf,  *					with socket (so), and   *					puts it in the queue with head (head)  *  * RETURNS:			0 if OK, ENOBUFS if can't alloc the necessary mbuf  */
end_comment

begin_function
name|int
name|iso_pcballoc
parameter_list|(
name|so
parameter_list|,
name|head
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|head
decl_stmt|;
block|{
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcballoc(so 0x%x)\n"
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|MALLOC
argument_list|(
name|isop
argument_list|,
expr|struct
name|isopcb
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|isop
argument_list|)
argument_list|,
name|M_PCB
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|isop
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|isop
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|isop
argument_list|)
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_head
operator|=
name|head
expr_stmt|;
name|isop
operator|->
name|isop_socket
operator|=
name|so
expr_stmt|;
name|insque
argument_list|(
name|isop
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|isop
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		iso_pcbbind  *  * PURPOSE:			binds the address given in *(nam) to the socket  *					specified by the isopcb in *(isop)  *					If the given address is zero, it makes sure the  *					address isn't already in use and if it's got a network  *					portion, we look for an interface with that network  *					address.  If the address given is zero, we allocate  *					a port and stuff it in the (nam) structure.  *  * RETURNS:			errno E* or 0 if ok.  *  * SIDE EFFECTS:	increments head->isop_lport if it allocates a port #  *  * NOTES:			  */
end_comment

begin_define
define|#
directive|define
name|satosiso
parameter_list|(
name|sa
parameter_list|)
value|((struct sockaddr_iso *)(sa))
end_define

begin_function
name|int
name|iso_pcbbind
parameter_list|(
name|isop
parameter_list|,
name|nam
parameter_list|)
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
block|{
specifier|register
name|struct
name|isopcb
modifier|*
name|head
init|=
name|isop
operator|->
name|isop_head
decl_stmt|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
union|union
block|{
name|char
name|data
index|[
literal|2
index|]
decl_stmt|;
name|u_short
name|s
decl_stmt|;
block|}
name|suf
union|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbbind(isop 0x%x, nam 0x%x)\n"
argument_list|,
name|isop
argument_list|,
name|nam
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|suf
operator|.
name|s
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|iso_ifaddr
operator|==
literal|0
condition|)
comment|/* any interfaces attached? */
return|return
name|EADDRNOTAVAIL
return|;
if|if
condition|(
name|isop
operator|->
name|isop_laddr
condition|)
comment|/* already bound */
return|return
name|EADDRINUSE
return|;
if|if
condition|(
name|nam
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
block|{
name|isop
operator|->
name|isop_laddr
operator|=
operator|&
name|isop
operator|->
name|isop_sladdr
expr_stmt|;
name|isop
operator|->
name|isop_sladdr
operator|.
name|siso_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_sladdr
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|isop
operator|->
name|isop_sladdr
operator|.
name|siso_tlen
operator|=
literal|2
expr_stmt|;
name|isop
operator|->
name|isop_sladdr
operator|.
name|siso_nlen
operator|=
literal|0
expr_stmt|;
name|isop
operator|->
name|isop_sladdr
operator|.
name|siso_slen
operator|=
literal|0
expr_stmt|;
name|isop
operator|->
name|isop_sladdr
operator|.
name|siso_plen
operator|=
literal|0
expr_stmt|;
goto|goto
name|noname
goto|;
block|}
name|siso
operator|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbbind(name len 0x%x)\n"
argument_list|,
name|nam
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The address is %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 * We would like sort of length check but since some OSI addrs 	 * do not have fixed length, we can't really do much. 	 * The ONLY thing we can say is that an osi addr has to have 	 * at LEAST an afi and one more byte and had better fit into 	 * a struct iso_addr. 	 * However, in fact the size of the whole thing is a struct 	 * sockaddr_iso, so probably this is what we should check for. 	 */
if|if
condition|(
operator|(
name|nam
operator|->
name|m_len
operator|<
literal|2
operator|)
operator|||
operator|(
name|nam
operator|->
name|m_len
operator|<
name|siso
operator|->
name|siso_len
operator|)
condition|)
block|{
return|return
name|ENAMETOOLONG
return|;
block|}
if|if
condition|(
name|siso
operator|->
name|siso_tlen
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|TSEL
argument_list|(
name|siso
argument_list|)
decl_stmt|;
name|suf
operator|.
name|data
index|[
literal|0
index|]
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|suf
operator|.
name|data
index|[
literal|1
index|]
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|siso
operator|->
name|siso_nlen
condition|)
block|{
comment|/* non-zero net addr- better match one of our interfaces */
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbbind: bind to NOT zeroisoaddr\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
for|for
control|(
name|ia
operator|=
name|iso_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
if|if
condition|(
name|SAME_ISOADDR
argument_list|(
name|siso
argument_list|,
operator|&
name|ia
operator|->
name|ia_addr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ia
operator|==
literal|0
condition|)
return|return
name|EADDRNOTAVAIL
return|;
block|}
if|if
condition|(
name|siso
operator|->
name|siso_len
operator|<=
sizeof|sizeof
argument_list|(
name|isop
operator|->
name|isop_sladdr
argument_list|)
condition|)
block|{
name|isop
operator|->
name|isop_laddr
operator|=
operator|&
name|isop
operator|->
name|isop_sladdr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|nam
operator|=
name|m_copy
argument_list|(
name|nam
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOBUFS
return|;
name|isop
operator|->
name|isop_laddr
operator|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|siso
argument_list|,
operator|(
name|caddr_t
operator|)
name|isop
operator|->
name|isop_laddr
argument_list|,
name|siso
operator|->
name|siso_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|suf
operator|.
name|s
operator|||
name|siso
operator|->
name|siso_tlen
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|suf
operator|.
name|s
operator|<
name|ISO_PORT_RESERVED
operator|)
operator|&&
operator|(
name|siso
operator|->
name|siso_tlen
operator|<=
literal|2
operator|)
operator|&&
operator|(
name|u
operator|.
name|u_uid
operator|!=
literal|0
operator|)
condition|)
return|return
name|EACCES
return|;
if|if
condition|(
operator|(
name|isop
operator|->
name|isop_socket
operator|->
name|so_options
operator|&
name|SO_REUSEADDR
operator|)
operator|==
literal|0
operator|&&
name|iso_pcblookup
argument_list|(
name|head
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|isop
operator|->
name|isop_laddr
argument_list|)
condition|)
return|return
name|EADDRINUSE
return|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|noname
label|:
name|cp
operator|=
name|TSEL
argument_list|(
name|isop
operator|->
name|isop_laddr
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbbind noname\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
do|do
block|{
if|if
condition|(
name|head
operator|->
name|isop_lport
operator|++
operator|<
name|ISO_PORT_RESERVED
operator|||
name|head
operator|->
name|isop_lport
operator|>
name|ISO_PORT_USERRESERVED
condition|)
name|head
operator|->
name|isop_lport
operator|=
name|ISO_PORT_RESERVED
expr_stmt|;
name|suf
operator|.
name|s
operator|=
name|head
operator|->
name|isop_lport
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|suf
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
name|suf
operator|.
name|data
index|[
literal|1
index|]
expr_stmt|;
block|}
do|while
condition|(
name|iso_pcblookup
argument_list|(
name|head
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|isop
operator|->
name|isop_laddr
argument_list|)
condition|)
do|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbbind returns 0, suf 0x%x\n"
argument_list|,
name|suf
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		iso_pcbconnect  *  * PURPOSE:			Make the isopcb (isop) look like it's connected.  *					In other words, give it the peer address given in   *					the mbuf * (nam).   Make sure such a combination  *					of local, peer addresses doesn't already exist  *					for this protocol.  Internet mentality prevails here,  *					wherein a src,dst pair uniquely identifies a connection.  * 					Both net address and port must be specified in argument   *					(nam).  * 					If we don't have a local address for this socket yet,   *					we pick one by calling iso_pcbbind().  *  * RETURNS:			errno E* or 0 if ok.  *  * SIDE EFFECTS:	Looks up a route, which may cause one to be left  *					in the isopcb.  *  * NOTES:			  */
end_comment

begin_function
name|int
name|iso_pcbconnect
parameter_list|(
name|isop
parameter_list|,
name|nam
parameter_list|)
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
decl_stmt|;
name|int
name|local_zero
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbconnect(isop 0x%x sock 0x%x nam 0x%x"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|,
name|nam
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"nam->m_len 0x%x), addr:\n"
argument_list|,
name|nam
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|siso
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|nam
operator|->
name|m_len
operator|<
name|siso
operator|->
name|siso_len
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|siso
operator|->
name|siso_family
operator|!=
name|AF_ISO
condition|)
return|return
name|EAFNOSUPPORT
return|;
if|if
condition|(
name|siso
operator|->
name|siso_nlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ia
operator|=
name|iso_ifaddr
condition|)
block|{
name|int
name|nlen
init|=
name|ia
operator|->
name|ia_addr
operator|.
name|siso_nlen
decl_stmt|;
name|ovbcopy
argument_list|(
name|TSEL
argument_list|(
name|siso
argument_list|)
argument_list|,
name|nlen
operator|+
name|TSEL
argument_list|(
name|siso
argument_list|)
argument_list|,
name|siso
operator|->
name|siso_plen
operator|+
name|siso
operator|->
name|siso_tlen
operator|+
name|siso
operator|->
name|siso_slen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ia
operator|->
name|ia_addr
operator|.
name|siso_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
name|nlen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* includes siso->siso_nlen = nlen; */
block|}
else|else
return|return
name|EADDRNOTAVAIL
return|;
block|}
comment|/* 	 * Local zero means either not bound, or bound to a TSEL, but no 	 * particular local interface.  So, if we want to send somebody 	 * we need to choose a return address. 	 */
name|local_zero
operator|=
operator|(
operator|(
name|isop
operator|->
name|isop_laddr
operator|==
literal|0
operator|)
operator|||
operator|(
name|isop
operator|->
name|isop_laddr
operator|->
name|siso_nlen
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|local_zero
condition|)
block|{
name|int
name|flags
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbconnect localzero 1\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/*  		 * If route is known or can be allocated now, 		 * our src addr is taken from the i/f, else punt. 		 */
name|flags
init|=
name|isop
operator|->
name|isop_socket
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|clnp_route
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
operator|&
name|isop
operator|->
name|isop_route
argument_list|,
name|flags
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|ia
argument_list|)
condition|)
return|return
name|error
return|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbconnect localzero 2, ro->ro_rt 0x%x"
argument_list|,
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ia 0x%x\n"
argument_list|,
name|ia
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"in iso_pcbconnect before lookup isop 0x%x isop->sock 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|local_zero
condition|)
block|{
name|int
name|nlen
decl_stmt|,
name|tlen
decl_stmt|,
name|totlen
decl_stmt|;
name|caddr_t
name|oldtsel
decl_stmt|,
name|newtsel
decl_stmt|;
name|siso
operator|=
name|isop
operator|->
name|isop_laddr
expr_stmt|;
if|if
condition|(
name|siso
operator|==
literal|0
operator|||
name|siso
operator|->
name|siso_tlen
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|iso_pcbbind
argument_list|(
name|isop
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Here we have problem of squezeing in a definite network address 		 * into an existing sockaddr_iso, which in fact may not have room 		 * for it.  This gets messy. 		 */
name|siso
operator|=
name|isop
operator|->
name|isop_laddr
expr_stmt|;
name|oldtsel
operator|=
name|TSEL
argument_list|(
name|siso
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|siso
operator|->
name|siso_tlen
expr_stmt|;
name|nlen
operator|=
name|ia
operator|->
name|ia_addr
operator|.
name|siso_nlen
expr_stmt|;
name|totlen
operator|=
name|tlen
operator|+
name|nlen
operator|+
name|_offsetof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|,
name|siso_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|siso
operator|==
operator|&
name|isop
operator|->
name|isop_sladdr
operator|)
operator|&&
operator|(
name|totlen
operator|>
sizeof|sizeof
argument_list|(
name|isop
operator|->
name|isop_sladdr
argument_list|)
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m_get
argument_list|(
name|MT_SONAME
argument_list|,
name|M_DONTWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
name|ENOBUFS
return|;
name|m
operator|->
name|m_len
operator|=
name|totlen
expr_stmt|;
name|isop
operator|->
name|isop_laddr
operator|=
name|siso
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
block|}
name|siso
operator|->
name|siso_nlen
operator|=
name|ia
operator|->
name|ia_addr
operator|.
name|siso_nlen
expr_stmt|;
name|newtsel
operator|=
name|TSEL
argument_list|(
name|siso
argument_list|)
expr_stmt|;
name|ovbcopy
argument_list|(
name|oldtsel
argument_list|,
name|newtsel
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ia
operator|->
name|ia_addr
operator|.
name|siso_data
argument_list|,
name|siso
operator|->
name|siso_data
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|siso
operator|->
name|siso_tlen
operator|=
name|tlen
expr_stmt|;
name|siso
operator|->
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|siso
operator|->
name|siso_len
operator|=
name|totlen
expr_stmt|;
name|siso
operator|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"in iso_pcbconnect before bcopy isop 0x%x isop->sock 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 * If we had to allocate space to a previous big foreign address, 	 * and for some reason we didn't free it, we reuse it knowing 	 * that is going to be big enough, as sockaddrs are delivered in 	 * 128 byte mbufs. 	 * If the foreign address is small enough, we use default space; 	 * otherwise, we grab an mbuf to copy into. 	 */
if|if
condition|(
name|isop
operator|->
name|isop_faddr
operator|==
literal|0
operator|||
name|isop
operator|->
name|isop_faddr
operator|==
operator|&
name|isop
operator|->
name|isop_sfaddr
condition|)
block|{
if|if
condition|(
name|siso
operator|->
name|siso_len
operator|<=
sizeof|sizeof
argument_list|(
name|isop
operator|->
name|isop_sfaddr
argument_list|)
condition|)
name|isop
operator|->
name|isop_faddr
operator|=
operator|&
name|isop
operator|->
name|isop_sfaddr
expr_stmt|;
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m_get
argument_list|(
name|MT_SONAME
argument_list|,
name|M_DONTWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
name|ENOBUFS
return|;
name|isop
operator|->
name|isop_faddr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|siso
argument_list|,
operator|(
name|caddr_t
operator|)
name|isop
operator|->
name|isop_faddr
argument_list|,
name|siso
operator|->
name|siso_len
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"in iso_pcbconnect after bcopy isop 0x%x isop->sock 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iso_pcbconnect connected to addr:\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iso_pcbconnect end: src addr:\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|isop
operator|->
name|isop_laddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		iso_pcbdisconnect()  *  * PURPOSE:			washes away the peer address info so the socket  *					appears to be disconnected.  *					If there's no file descriptor associated with the socket  *					it detaches the pcb.  *  * RETURNS:			Nada.  *  * SIDE EFFECTS:	May detach the pcb.  *  * NOTES:			  */
end_comment

begin_function
name|void
name|iso_pcbdisconnect
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|void
name|iso_pcbdetach
parameter_list|()
function_decl|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdisconnect(isop 0x%x)\n"
argument_list|,
name|isop
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 * Preserver binding infnormation if already bound. 	 */
if|if
condition|(
operator|(
name|siso
operator|=
name|isop
operator|->
name|isop_laddr
operator|)
operator|&&
name|siso
operator|->
name|siso_nlen
operator|&&
name|siso
operator|->
name|siso_tlen
condition|)
block|{
name|caddr_t
name|otsel
init|=
name|TSEL
argument_list|(
name|siso
argument_list|)
decl_stmt|;
name|siso
operator|->
name|siso_nlen
operator|=
literal|0
expr_stmt|;
name|ovbcopy
argument_list|(
name|otsel
argument_list|,
name|TSEL
argument_list|(
name|siso
argument_list|)
argument_list|,
name|siso
operator|->
name|siso_tlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isop
operator|->
name|isop_faddr
operator|&&
name|isop
operator|->
name|isop_faddr
operator|!=
operator|&
name|isop
operator|->
name|isop_sfaddr
condition|)
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|)
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_faddr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isop
operator|->
name|isop_socket
operator|->
name|so_state
operator|&
name|SS_NOFDREF
condition|)
name|iso_pcbdetach
argument_list|(
name|isop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		iso_pcbdetach  *  * PURPOSE:			detach the pcb at *(isop) from it's socket and free  *					the mbufs associated with the pcb..  *					Dequeues (isop) from its head.  *  * RETURNS:			Nada.  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|void
name|iso_pcbdetach
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|isop
operator|->
name|isop_socket
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach(isop 0x%x socket 0x%x so 0x%x)\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|so
condition|)
block|{
comment|/* in the x.25 domain, we sometimes have no socket */
name|so
operator|->
name|so_pcb
operator|=
literal|0
expr_stmt|;
name|sofree
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 2 \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|isop
operator|->
name|isop_options
condition|)
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|isop
operator|->
name|isop_options
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 3 \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
condition|)
name|rtfree
argument_list|(
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 3.1\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|isop
operator|->
name|isop_clnpcache
operator|!=
name|NULL
condition|)
block|{
name|struct
name|clnp_cache
modifier|*
name|clcp
init|=
name|mtod
argument_list|(
name|isop
operator|->
name|isop_clnpcache
argument_list|,
expr|struct
name|clnp_cache
operator|*
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 3.2: clcp 0x%x freeing clc_hdr x%x\n"
argument_list|,
name|clcp
argument_list|,
name|clcp
operator|->
name|clc_hdr
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|clcp
operator|->
name|clc_hdr
operator|!=
name|NULL
condition|)
name|m_free
argument_list|(
name|clcp
operator|->
name|clc_hdr
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 3.3: freeing cache x%x\n"
argument_list|,
name|isop
operator|->
name|isop_clnpcache
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|m_free
argument_list|(
name|isop
operator|->
name|isop_clnpcache
argument_list|)
decl_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 4 \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|remque
argument_list|(
name|isop
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 5 \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|isop
operator|->
name|isop_laddr
operator|&&
operator|(
name|isop
operator|->
name|isop_laddr
operator|!=
operator|&
name|isop
operator|->
name|isop_sladdr
operator|)
condition|)
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|isop
operator|->
name|isop_laddr
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|isop
argument_list|,
name|M_IFADDR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		iso_pcbnotify  *  * PURPOSE:			notify all connections in this protocol's queue (head)  *					that have peer address (dst) of the problem (errno)  *					by calling (notify) on the connections' isopcbs.  *  * RETURNS:			Rien.  *  * SIDE EFFECTS:	  *  * NOTES:			(notify) is called at splimp!  */
end_comment

begin_decl_stmt
name|void
name|iso_pcbnotify
argument_list|(
name|head
argument_list|,
name|siso
argument_list|,
name|errno
argument_list|,
name|notify
argument_list|)
decl|struct
name|isopcb
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errno
decl_stmt|,
argument_list|(
operator|*
name|notify
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbnotify(head 0x%x, notify 0x%x) dst:\n"
argument_list|,
name|head
argument_list|,
name|notify
argument_list|)
expr_stmt|;
name|ENDDEBUG
for|for
control|(
name|isop
operator|=
name|head
operator|->
name|isop_next
init|;
name|isop
operator|!=
name|head
condition|;
name|isop
operator|=
name|isop
operator|->
name|isop_next
control|)
block|{
if|if
condition|(
name|isop
operator|->
name|isop_socket
operator|==
literal|0
operator|||
name|isop
operator|->
name|isop_faddr
operator|==
literal|0
operator|||
operator|!
name|SAME_ISOADDR
argument_list|(
name|siso
argument_list|,
name|isop
operator|->
name|isop_faddr
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbnotify: CONTINUE isop 0x%x, sock 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"addrmatch cmp'd with (0x%x):\n"
argument_list|,
name|isop
operator|->
name|isop_faddr
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
continue|continue;
block|}
if|if
condition|(
name|errno
condition|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|notify
condition|)
call|(
modifier|*
name|notify
call|)
argument_list|(
name|isop
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"END OF iso_pcbnotify\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_pcblookup  *  * PURPOSE:			looks for a given combination of (faddr), (fport),  *					(lport), (laddr) in the queue named by (head).  *					Argument (flags) is ignored.  *  * RETURNS:			ptr to the isopcb if it finds a connection matching  *					these arguments, o.w. returns zero.  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|struct
name|isopcb
modifier|*
name|iso_pcblookup
parameter_list|(
name|head
parameter_list|,
name|fportlen
parameter_list|,
name|fport
parameter_list|,
name|laddr
parameter_list|)
name|struct
name|isopcb
modifier|*
name|head
decl_stmt|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|laddr
decl_stmt|;
name|caddr_t
name|fport
decl_stmt|;
name|int
name|fportlen
decl_stmt|;
block|{
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
specifier|register
name|caddr_t
name|lp
init|=
name|TSEL
argument_list|(
name|laddr
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|llen
init|=
name|laddr
operator|->
name|siso_tlen
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcblookup(head 0x%x laddr 0x%x fport 0x%x)\n"
argument_list|,
name|head
argument_list|,
name|laddr
argument_list|,
name|fport
argument_list|)
expr_stmt|;
name|ENDDEBUG
for|for
control|(
name|isop
operator|=
name|head
operator|->
name|isop_next
init|;
name|isop
operator|!=
name|head
condition|;
name|isop
operator|=
name|isop
operator|->
name|isop_next
control|)
block|{
if|if
condition|(
name|isop
operator|->
name|isop_laddr
operator|==
literal|0
operator|||
name|isop
operator|->
name|isop_laddr
operator|==
name|laddr
condition|)
continue|continue;
if|if
condition|(
name|isop
operator|->
name|isop_laddr
operator|->
name|siso_tlen
operator|!=
name|llen
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
name|lp
argument_list|,
name|TSEL
argument_list|(
name|isop
operator|->
name|isop_laddr
argument_list|)
argument_list|,
name|llen
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fportlen
operator|&&
name|isop
operator|->
name|isop_faddr
operator|&&
name|bcmp
argument_list|(
name|fport
argument_list|,
name|TSEL
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|fportlen
argument_list|)
condition|)
continue|continue;
comment|/*	PHASE2 		 *	addrmatch1 should be iso_addrmatch(a, b, mask) 		 *	where mask is taken from isop->isop_laddrmask (new field) 		 *	isop_lnetmask will also be available in isop 		if (laddr !=&zeroiso_addr&& 			!iso_addrmatch1(laddr,&(isop->isop_laddr.siso_addr))) 			continue; 		*/
if|if
condition|(
name|laddr
operator|->
name|siso_nlen
operator|&&
operator|(
operator|!
name|SAME_ISOADDR
argument_list|(
name|laddr
argument_list|,
name|isop
operator|->
name|isop_laddr
argument_list|)
operator|)
condition|)
continue|continue;
return|return
operator|(
name|isop
operator|)
return|;
block|}
return|return
operator|(
expr|struct
name|isopcb
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|ISO
end_endif

end_unit

