begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*   * ARGO TP  *  * $Header: tp_subr.c,v 5.3 88/11/18 17:28:43 nhall Exp $  * $Source: /usr/argo/sys/netiso/RCS/tp_subr.c,v $  *	@(#)tp_subr.c	7.3 (Berkeley) %G% *  *  * The main work of data transfer is done here.  * These routines are called from tp.trans.  * They include the routines that check the validity of acks and Xacks,  * (tp_goodack() and tp_goodXack() )  * take packets from socket buffers and send them (tp_send()),  * drop the data from the socket buffers (tp_sbdrop()),    * and put incoming packet data into socket buffers (tp_stash()).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: tp_subr.c,v 5.3 88/11/18 17:28:43 nhall Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"tp_ip.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"tp_timer.h"
end_include

begin_include
include|#
directive|include
file|"tp_param.h"
end_include

begin_include
include|#
directive|include
file|"tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"tp_pcb.h"
end_include

begin_include
include|#
directive|include
file|"tp_tpdu.h"
end_include

begin_include
include|#
directive|include
file|"tp_trace.h"
end_include

begin_include
include|#
directive|include
file|"tp_meas.h"
end_include

begin_include
include|#
directive|include
file|"tp_seq.h"
end_include

begin_function_decl
name|int
name|tp_emit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tp_sbdrop
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SMOOTH
parameter_list|(
name|newtype
parameter_list|,
name|alpha
parameter_list|,
name|old
parameter_list|,
name|new
parameter_list|)
define|\
value|(newtype) (((new - old)>>alpha) + (old))
end_define

begin_define
define|#
directive|define
name|ABS
parameter_list|(
name|type
parameter_list|,
name|val
parameter_list|)
define|\
value|(type) (((int)(val)<0)?-(val):(val))
end_define

begin_define
define|#
directive|define
name|TP_MAKE_RTC
parameter_list|(
name|Xreg
parameter_list|,
name|Xseq
parameter_list|,
name|Xeot
parameter_list|,
name|Xdata
parameter_list|,
name|Xlen
parameter_list|,
name|Xretval
parameter_list|,
name|Xtype
parameter_list|)
define|\
value|{ 	struct mbuf *xxn;\ 	MGET(xxn, M_DONTWAIT, Xtype);\ 	if( xxn == (struct mbuf *)0 ) {\ 		printf("MAKE RTC FAILED: ENOBUFS\n");\ 		return (int)Xretval;\ 	}\ 	xxn->m_act=MNULL;\ 	Xreg = mtod(xxn, struct tp_rtc *);\ 	if( Xreg == (struct tp_rtc *)0 ) {\ 		return (int)Xretval;\ 	}\ 	Xreg->tprt_eot = Xeot;\ 	Xreg->tprt_seq = Xseq;\ 	Xreg->tprt_data = Xdata;\ 	Xreg->tprt_octets = Xlen;\ }
end_define

begin_comment
comment|/*  * CALLED FROM:  *	tp.trans, when an XAK arrives  * FUNCTION and ARGUMENTS:  * 	Determines if the sequence number (seq) from the XAK   * 	acks anything new.  If so, drop the appropriate tpdu  * 	from the XPD send queue.  * RETURN VALUE:  * 	Returns 1 if it did this, 0 if the ack caused no action.  */
end_comment

begin_function
name|int
name|tp_goodXack
parameter_list|(
name|tpcb
parameter_list|,
name|seq
parameter_list|)
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|SeqNum
name|seq
decl_stmt|;
block|{
name|IFTRACE
argument_list|(
argument|D_XPD
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTgotXack
argument_list|,
name|seq
argument_list|,
name|tpcb
operator|->
name|tp_Xuna
argument_list|,
name|tpcb
operator|->
name|tp_Xsndnxt
argument_list|,
name|tpcb
operator|->
name|tp_sndhiwat
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|seq
operator|==
name|tpcb
operator|->
name|tp_Xuna
condition|)
block|{
name|tpcb
operator|->
name|tp_Xuna
operator|=
name|tpcb
operator|->
name|tp_Xsndnxt
expr_stmt|;
comment|/* DROP 1 packet from the Xsnd socket buf - just so happens 			 * that only one packet can be there at any time 			 * so drop the whole thing.  If you allow> 1 packet 			 * the socket buffer, then you'll have to keep 			 * track of how many characters went w/ each XPD tpdu, so this 			 * will get messier 			 */
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|dump_mbuf
argument_list|(
name|tpcb
operator|->
name|tp_Xsnd
operator|.
name|sb_mb
argument_list|,
literal|"tp_goodXack Xsnd before sbdrop"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_XPD
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"goodXack: dropping cc "
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tpcb
operator|->
name|tp_Xsnd
operator|.
name|sb_cc
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
name|sbdrop
argument_list|(
operator|&
name|tpcb
operator|->
name|tp_Xsnd
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tpcb
operator|->
name|tp_Xsnd
operator|.
name|sb_cc
argument_list|)
argument_list|)
decl_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_good_ack()  * FUNCTION and ARGUMENTS:  *  updates  *  smoothed average round trip time (base_rtt)  *  roundtrip time variance (base_rtv) - actually deviation, not variance  *  given the new value (diff)  * RETURN VALUE:  * void  */
end_comment

begin_function
name|void
name|tp_rtt_rtv
parameter_list|(
name|base_rtt
parameter_list|,
name|base_rtv
parameter_list|,
name|newmeas
parameter_list|)
name|struct
name|timeval
modifier|*
name|base_rtt
decl_stmt|,
decl|*
name|base_rtv
decl_stmt|,
modifier|*
name|newmeas
decl_stmt|;
end_function

begin_block
block|{
comment|/* update  rt variance (really just the deviation):  	 * 	rtv.smooth_ave =  SMOOTH( | oldrtt.smooth_avg - rtt.this_instance | ) 	 */
name|base_rtv
operator|->
name|tv_sec
operator|=
name|SMOOTH
argument_list|(
name|long
argument_list|,
name|TP_RTV_ALPHA
argument_list|,
name|base_rtv
operator|->
name|tv_sec
argument_list|,
name|ABS
argument_list|(
name|long
argument_list|,
name|base_rtv
operator|->
name|tv_sec
operator|-
name|newmeas
operator|->
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
name|base_rtv
operator|->
name|tv_usec
operator|=
name|SMOOTH
argument_list|(
name|long
argument_list|,
name|TP_RTV_ALPHA
argument_list|,
name|base_rtv
operator|->
name|tv_usec
argument_list|,
name|ABS
argument_list|(
name|long
argument_list|,
name|base_rtv
operator|->
name|tv_usec
operator|-
name|newmeas
operator|->
name|tv_usec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update smoothed average rtt */
name|base_rtt
operator|->
name|tv_sec
operator|=
name|SMOOTH
argument_list|(
name|long
argument_list|,
name|TP_RTT_ALPHA
argument_list|,
name|base_rtt
operator|->
name|tv_sec
argument_list|,
name|newmeas
operator|->
name|tv_sec
argument_list|)
expr_stmt|;
name|base_rtt
operator|->
name|tv_usec
operator|=
name|SMOOTH
argument_list|(
name|long
argument_list|,
name|TP_RTT_ALPHA
argument_list|,
name|base_rtt
operator|->
name|tv_usec
argument_list|,
name|newmeas
operator|->
name|tv_usec
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans when an AK arrives  * FUNCTION and ARGUMENTS:  * 	Given (cdt), the credit from the AK tpdu, and   *	(seq), the sequence number from the AK tpdu,  *  tp_goodack() determines if the AK acknowledges something in the send  * 	window, and if so, drops the appropriate packets from the retransmission  *  list, computes the round trip time, and updates the retransmission timer  *  based on the new smoothed round trip time.  * RETURN VALUE:  * 	Returns 1 if  * 	EITHER it actually acked something heretofore unacknowledged  * 	OR no news but the credit should be processed.  * 	If something heretofore unacked was acked with this sequence number,  * 	the appropriate tpdus are dropped from the retransmission control list,  * 	by calling tp_sbdrop().  * 	No need to see the tpdu itself.  */
end_comment

begin_function
name|int
name|tp_goodack
parameter_list|(
name|tpcb
parameter_list|,
name|cdt
parameter_list|,
name|seq
parameter_list|,
name|subseq
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|u_int
name|cdt
decl_stmt|;
specifier|register
name|SeqNum
name|seq
decl_stmt|,
name|subseq
decl_stmt|;
block|{
name|int
name|old_fcredit
init|=
name|tpcb
operator|->
name|tp_fcredit
decl_stmt|;
name|int
name|bang
init|=
literal|0
decl_stmt|;
comment|/* bang --> ack for something heretofore unacked */
name|IFDEBUG
argument_list|(
argument|D_ACKRECV
argument_list|)
name|printf
argument_list|(
literal|"goodack seq 0x%x cdt 0x%x snduna 0x%x sndhiwat 0x%x\n"
argument_list|,
name|seq
argument_list|,
name|cdt
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|,
name|tpcb
operator|->
name|tp_sndhiwat
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_ACKRECV
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTgotack
argument_list|,
name|seq
argument_list|,
name|cdt
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|,
name|tpcb
operator|->
name|tp_sndhiwat
argument_list|,
name|subseq
argument_list|)
decl_stmt|;
name|ENDTRACE
name|IFPERF
argument_list|(
name|tpcb
argument_list|)
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_ack_rcvd
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDPERF
if|if
condition|(
name|subseq
operator|!=
literal|0
operator|&&
operator|(
name|subseq
operator|<=
name|tpcb
operator|->
name|tp_r_subseq
operator|)
condition|)
block|{
comment|/* discard the ack */
name|IFTRACE
argument_list|(
argument|D_ACKRECV
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"goodack discard : subseq tp_r_subseq"
argument_list|,
name|subseq
argument_list|,
name|tpcb
operator|->
name|tp_r_subseq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
return|return
literal|0
return|;
block|}
else|else
block|{
name|tpcb
operator|->
name|tp_r_subseq
operator|=
name|subseq
expr_stmt|;
block|}
if|if
condition|(
name|IN_SWINDOW
argument_list|(
name|tpcb
argument_list|,
name|seq
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|,
name|SEQ
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndhiwat
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|dump_mbuf
argument_list|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_snd
operator|.
name|sb_mb
argument_list|,
literal|"tp_goodack snd before sbdrop"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tp_sbdrop
argument_list|(
name|tpcb
argument_list|,
name|SEQ_SUB
argument_list|(
name|tpcb
argument_list|,
name|seq
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* increase congestion window but don't let it get too big */
block|{
specifier|register
name|int
name|maxcdt
init|=
name|tpcb
operator|->
name|tp_xtd_format
condition|?
literal|0xffff
else|:
literal|0xf
decl_stmt|;
if|if
condition|(
operator|++
name|tpcb
operator|->
name|tp_cong_win
operator|>
name|maxcdt
condition|)
name|tpcb
operator|->
name|tp_cong_win
operator|=
name|maxcdt
expr_stmt|;
block|}
comment|/* Compute smoothed round trip time. 		 * Only measure rtt for tp_snduna if tp_snduna was among  		 * the last TP_RTT_NUM seq numbers sent. 		 */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|,
name|SEQ
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndhiwat
operator|-
name|TP_RTT_NUM
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|timeval
modifier|*
name|t
init|=
operator|&
name|tpcb
operator|->
name|tp_rttemit
index|[
name|tpcb
operator|->
name|tp_snduna
operator|&
name|TP_RTT_NUM
index|]
decl_stmt|;
name|struct
name|timeval
name|x
decl_stmt|;
name|GET_TIME_SINCE
argument_list|(
name|t
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|tp_rtt_rtv
argument_list|(
operator|&
operator|(
name|tpcb
operator|->
name|tp_rtt
operator|)
argument_list|,
operator|&
operator|(
name|tpcb
operator|->
name|tp_rtv
operator|)
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
block|{
comment|/* update the global rtt, rtv stats */
specifier|register
name|int
name|i
init|=
operator|(
name|int
operator|)
name|tpcb
operator|->
name|tp_flags
operator|&
operator|(
name|TPF_PEER_ON_SAMENET
operator||
name|TPF_NLQOS_PDN
operator|)
decl_stmt|;
name|tp_rtt_rtv
argument_list|(
operator|&
operator|(
name|tp_stat
operator|.
name|ts_rtt
index|[
name|i
index|]
operator|)
argument_list|,
operator|&
operator|(
name|tp_stat
operator|.
name|ts_rtv
index|[
name|i
index|]
operator|)
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_RTT
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"Global rtt, rtv: i"
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
block|}
name|IFTRACE
argument_list|(
argument|D_RTT
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"Smoothed rtt: tp_snduna, (time.sec, time.usec), peer_acktime"
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|,
name|time
operator|.
name|tv_sec
argument_list|,
name|time
operator|.
name|tv_usec
argument_list|,
name|tpcb
operator|->
name|tp_peer_acktime
argument_list|)
expr_stmt|;
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"(secs): emittime diff(x) rtt, rtv"
argument_list|,
name|t
operator|->
name|tv_sec
argument_list|,
name|x
operator|.
name|tv_sec
argument_list|,
name|tpcb
operator|->
name|tp_rtt
operator|.
name|tv_sec
argument_list|,
name|tpcb
operator|->
name|tp_rtv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"(usecs): emittime diff(x) rtt rtv"
argument_list|,
name|t
operator|->
name|tv_usec
argument_list|,
name|x
operator|.
name|tv_usec
argument_list|,
name|tpcb
operator|->
name|tp_rtt
operator|.
name|tv_usec
argument_list|,
name|tpcb
operator|->
name|tp_rtv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|ENDTRACE
block|{
comment|/* Update data retransmission timer based on the smoothed 				 * round trip time, peer ack time, and the pseudo-arbitrary 				 * number 4. 				 * new ticks: avg rtt + 2*dev 				 * rtt, rtv are in microsecs, and ticks are 500 ms 				 * so 1 tick = 500*1000 us = 500000 us 				 * so ticks = (rtt + 2 rtv)/500000 				 * with ticks no les than peer ack time and no less than 4 				 */
name|int
name|rtt
init|=
name|tpcb
operator|->
name|tp_rtt
operator|.
name|tv_usec
operator|+
name|tpcb
operator|->
name|tp_rtt
operator|.
name|tv_sec
operator|*
literal|1000000
decl_stmt|;
name|int
name|rtv
init|=
name|tpcb
operator|->
name|tp_rtv
operator|.
name|tv_usec
operator|+
name|tpcb
operator|->
name|tp_rtv
operator|.
name|tv_sec
operator|*
literal|1000000
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_RTT
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"oldticks ,rtv, rtt, newticks"
argument_list|,
name|tpcb
operator|->
name|tp_dt_ticks
argument_list|,
name|rtv
argument_list|,
name|rtt
argument_list|,
operator|(
name|rtt
operator|/
literal|500000
operator|+
operator|(
literal|2
operator|*
name|rtv
operator|)
operator|/
literal|500000
operator|)
argument_list|)
expr_stmt|;
name|ENDTRACE
name|tpcb
operator|->
name|tp_dt_ticks
init|=
operator|(
name|rtt
operator|+
operator|(
literal|2
operator|*
name|rtv
operator|)
operator|)
operator|/
literal|500000
decl_stmt|;
name|tpcb
operator|->
name|tp_dt_ticks
operator|=
name|MAX
argument_list|(
name|tpcb
operator|->
name|tp_dt_ticks
argument_list|,
name|tpcb
operator|->
name|tp_peer_acktime
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_dt_ticks
operator|=
name|MAX
argument_list|(
name|tpcb
operator|->
name|tp_dt_ticks
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|tpcb
operator|->
name|tp_snduna
operator|=
name|seq
expr_stmt|;
name|bang
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cdt
operator|!=
literal|0
operator|&&
name|old_fcredit
operator|==
literal|0
condition|)
block|{
name|tpcb
operator|->
name|tp_sendfcc
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cdt
operator|==
literal|0
operator|&&
name|old_fcredit
operator|!=
literal|0
condition|)
block|{
name|IncStat
argument_list|(
name|ts_zfcdt
argument_list|)
expr_stmt|;
block|}
name|tpcb
operator|->
name|tp_fcredit
operator|=
name|cdt
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ACKRECV
argument_list|)
name|printf
argument_list|(
literal|"goodack returning 0x%x, bang 0x%x cdt 0x%x old_fcredit 0x%x\n"
argument_list|,
operator|(
name|bang
operator|||
operator|(
name|old_fcredit
operator|<
name|cdt
operator|)
operator|)
argument_list|,
name|bang
argument_list|,
name|cdt
argument_list|,
name|old_fcredit
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
name|bang
operator|||
operator|(
name|old_fcredit
operator|<
name|cdt
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_goodack()  * FUNCTION and ARGUMENTS:  *  drops everything up TO and INCLUDING seq # (seq)  *  from the retransmission queue.  */
end_comment

begin_function
specifier|static
name|void
name|tp_sbdrop
parameter_list|(
name|tpcb
parameter_list|,
name|seq
parameter_list|)
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|SeqNum
name|seq
decl_stmt|;
block|{
specifier|register
name|struct
name|tp_rtc
modifier|*
name|s
init|=
name|tpcb
operator|->
name|tp_snduna_rtc
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ACKRECV
argument_list|)
name|printf
argument_list|(
literal|"tp_sbdrop up through seq 0x%x\n"
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|ENDDEBUG
while|while
condition|(
name|s
operator|!=
operator|(
expr|struct
name|tp_rtc
operator|*
operator|)
literal|0
operator|&&
operator|(
name|SEQ_LEQ
argument_list|(
name|tpcb
argument_list|,
name|s
operator|->
name|tprt_seq
argument_list|,
name|seq
argument_list|)
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|s
operator|->
name|tprt_data
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_snduna_rtc
operator|=
name|s
operator|->
name|tprt_next
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|tpcb
operator|->
name|tp_snduna_rtc
expr_stmt|;
block|}
if|if
condition|(
name|tpcb
operator|->
name|tp_snduna_rtc
operator|==
operator|(
expr|struct
name|tp_rtc
operator|*
operator|)
literal|0
condition|)
name|tpcb
operator|->
name|tp_sndhiwat_rtc
operator|=
operator|(
expr|struct
name|tp_rtc
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  * 	tp.trans on user send request, arrival of AK and arrival of XAK  * FUNCTION and ARGUMENTS:  * 	Emits tpdus starting at sequence number (lowseq).  * 	Emits until a) runs out of data, or  b) runs into an XPD mark, or  * 			c) it hits seq number (highseq)  * 	Removes the octets from the front of the socket buffer   * 	and repackages them in one mbuf chain per tpdu.  * 	Moves the mbuf chain to the doubly linked list that runs from  * 	tpcb->tp_sndhiwat_rtc to tpcb->tp_snduna_rtc.  *  * 	Creates tpdus that are no larger than<tpcb->tp_l_tpdusize - headersize>,  *  * 	If you want XPD to buffer> 1 du per socket buffer, you can  * 	modifiy this to issue XPD tpdus also, but then it'll have  * 	to take some argument(s) to distinguish between the type of DU to  * 	hand tp_emit, the socket buffer from which to get the data, and  * 	the chain of tp_rtc structures on which to put the data sent.  *  * 	When something is sent for the first time, its time-of-send  * 	is stashed (the last RTT_NUM of them are stashed).  When the  * 	ack arrives, the smoothed round-trip time is figured using this value.  * RETURN VALUE:  * 	the highest seq # sent successfully.  */
end_comment

begin_expr_stmt
name|tp_send
argument_list|(
name|tpcb
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* the one we're inspecting now */
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
comment|/* beginning of this tpdu */
name|struct
name|mbuf
modifier|*
name|nextrecord
decl_stmt|;
comment|/* NOT next tpdu but next sb record */
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_snd
decl_stmt|;
name|int
name|maxsize
init|=
name|tpcb
operator|->
name|tp_l_tpdusize
operator|-
name|tp_headersize
argument_list|(
name|DT_TPDU_type
argument_list|,
name|tpcb
argument_list|)
operator|-
operator|(
name|tpcb
operator|->
name|tp_use_checksum
condition|?
literal|4
else|:
literal|0
operator|)
decl_stmt|;
name|unsigned
name|int
name|eotsdu_reached
init|=
literal|0
decl_stmt|;
name|SeqNum
name|lowseq
decl_stmt|,
name|highseq
decl_stmt|;
name|SeqNum
name|lowsave
decl_stmt|;
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
name|struct
name|timeval
name|send_start_time
decl_stmt|;
endif|#
directive|endif
endif|TP_PERF_MEAS
name|lowsave
operator|=
name|lowseq
operator|=
name|SEQ
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndhiwat
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_cong_win
operator|>
literal|0
operator|&&
name|tpcb
operator|->
name|tp_cong_win
operator|<
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_rx_strat
operator|&
name|TPRX_USE_CW
condition|)
block|{
comment|/*first hiseq is temp vbl*/
name|highseq
operator|=
name|MIN
argument_list|(
name|tpcb
operator|->
name|tp_fcredit
argument_list|,
name|tpcb
operator|->
name|tp_cong_win
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|highseq
operator|=
name|tpcb
operator|->
name|tp_fcredit
expr_stmt|;
block|}
name|highseq
operator|=
name|SEQ
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_snduna
operator|+
name|highseq
argument_list|)
expr_stmt|;
name|SEQ_DEC
argument_list|(
name|tpcb
argument_list|,
name|highseq
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_DATA
argument_list|)
name|printf
argument_list|(
literal|"tp_send enter tpcb 0x%x l %d -> h %d\ndump of sb_mb:\n"
argument_list|,
name|tpcb
argument_list|,
name|lowseq
argument_list|,
name|highseq
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|"sb_mb:"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_DATA
parameter_list|)
function_decl|tptraceTPCB
parameter_list|(
name|TPPTmisc
parameter_list|,
function_decl|"tp_send lowsave sndhiwat snduna"
operator|,
function_decl|lowsave
operator|,
function_decl|tpcb->tp_sndhiwat
operator|,
function_decl|tpcb->tp_snduna
operator|,
function_decl|0
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_send low high fcredit congwin"
argument_list|,
name|lowseq
argument_list|,
name|highseq
argument_list|,
name|tpcb
operator|->
name|tp_fcredit
argument_list|,
name|tpcb
operator|->
name|tp_cong_win
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDTRACE
end_macro

begin_if
if|if
condition|(
name|SEQ_GT
argument_list|(
name|tpcb
argument_list|,
name|lowseq
argument_list|,
name|highseq
argument_list|)
condition|)
return|return ;
end_if

begin_comment
comment|/* don't send, don't change hiwat, don't set timers */
end_comment

begin_macro
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
end_macro

begin_expr_stmt
name|GET_CUR_TIME
argument_list|(
operator|&
name|send_start_time
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ENDPERF
name|ASSERT
argument_list|(
name|SEQ_LEQ
argument_list|(
name|tpcb
argument_list|,
name|lowseq
argument_list|,
name|highseq
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SEQ_DEC
argument_list|(
name|tpcb
argument_list|,
name|lowseq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|IFTRACE
argument_list|(
argument|D_DATA
argument_list|)
end_macro

begin_expr_stmt
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_send 2 low high fcredit congwin"
argument_list|,
name|lowseq
argument_list|,
name|highseq
argument_list|,
name|tpcb
operator|->
name|tp_fcredit
argument_list|,
name|tpcb
operator|->
name|tp_cong_win
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDTRACE
end_macro

begin_while
while|while
condition|(
operator|(
name|SEQ_LT
argument_list|(
name|tpcb
argument_list|,
name|lowseq
argument_list|,
name|highseq
argument_list|)
operator|)
operator|&&
operator|(
name|mb
operator|=
name|m
operator|=
name|sb
operator|->
name|sb_mb
operator|)
condition|)
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_Xsnd
operator|.
name|sb_mb
condition|)
block|{
name|IFTRACE
argument_list|(
argument|D_XPD
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_send XPD mark low high tpcb.Xuna"
argument_list|,
name|lowseq
argument_list|,
name|highseq
argument_list|,
name|tpcb
operator|->
name|tp_Xsnd
operator|.
name|sb_mb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
comment|/* stop sending here because there are unacked XPD which were  			 * given to us before the next data were. 			 */
name|IncStat
parameter_list|(
name|ts_xpd_intheway
parameter_list|)
function_decl|;
break|break;
block|}
name|eotsdu_reached
operator|=
literal|0
expr_stmt|;
name|nextrecord
operator|=
name|m
operator|->
name|m_act
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EOR
condition|)
name|eotsdu_reached
operator|=
literal|1
expr_stmt|;
name|sbfree
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* reduce counts in socket buffer */
block|}
name|sb
operator|->
name|sb_mb
operator|=
name|nextrecord
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_STASH
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_send whole mbuf: m_len len maxsize"
argument_list|,
literal|0
argument_list|,
name|mb
operator|->
name|m_len
argument_list|,
name|len
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
operator|!
name|eotsdu_reached
condition|)
block|{
comment|/* THIS SHOULD NEVER HAPPEN! */
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* If we arrive here one of the following holds: 		 * 1. We have exactly<maxsize> octets of whole mbufs, 		 * 2. We accumulated<maxsize> octets using partial mbufs, 		 * 3. We found an TPMT_EOT or an XPD mark  		 * 4. We hit the end of a chain through m_next. 		 *    In this case, we'd LIKE to continue with the next record, 		 *    but for the time being, for simplicity, we'll stop here. 		 * In all cases, m points to mbuf containing first octet to be 		 * sent in the tpdu AFTER the one we're going to send now, 		 * or else m is null. 		 * 		 * The chain we're working on now begins at mb and has length<len>. 		 */
name|IFTRACE
argument_list|(
argument|D_STASH
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_send mcopy low high eotsdu_reached len"
argument_list|,
name|lowseq
argument_list|,
name|highseq
argument_list|,
name|eotsdu_reached
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDTRACE
comment|/* make a copy - mb goes into the retransmission list  		 * while m gets emitted.  m_copy won't copy a zero-length mbuf. 		 */
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_copy
argument_list|(
name|mb
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|MNULL
condition|)
goto|goto
name|done
goto|;
block|}
else|else
block|{
comment|/* eotsdu reached */
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|TPMT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|MNULL
condition|)
goto|goto
name|done
goto|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
block|}
name|SEQ_INC
argument_list|(
name|tpcb
argument_list|,
name|lowseq
argument_list|)
expr_stmt|;
comment|/* it was decremented at the beginning */
block|{
name|struct
name|tp_rtc
modifier|*
name|t
decl_stmt|;
comment|/* make an rtc and put it at the end of the chain */
name|TP_MAKE_RTC
argument_list|(
name|t
argument_list|,
name|lowseq
argument_list|,
name|eotsdu_reached
argument_list|,
name|mb
argument_list|,
name|len
argument_list|,
name|lowseq
argument_list|,
name|TPMT_SNDRTC
argument_list|)
expr_stmt|;
name|t
operator|->
name|tprt_next
operator|=
operator|(
expr|struct
name|tp_rtc
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_sndhiwat_rtc
operator|!=
operator|(
expr|struct
name|tp_rtc
operator|*
operator|)
literal|0
condition|)
name|tpcb
operator|->
name|tp_sndhiwat_rtc
operator|->
name|tprt_next
operator|=
name|t
expr_stmt|;
else|else
block|{
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_snduna_rtc
operator|==
operator|(
expr|struct
name|tp_rtc
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_snduna_rtc
operator|=
name|t
expr_stmt|;
block|}
name|tpcb
operator|->
name|tp_sndhiwat_rtc
operator|=
name|t
expr_stmt|;
block|}
name|IFTRACE
argument_list|(
argument|D_DATA
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_send emitting DT lowseq eotsdu_reached"
argument_list|,
name|lowseq
argument_list|,
name|eotsdu_reached
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_error
operator|=
name|tp_emit
argument_list|(
name|DT_TPDU_type
argument_list|,
name|tpcb
argument_list|,
name|lowseq
argument_list|,
name|eotsdu_reached
argument_list|,
name|m
argument_list|)
condition|)
block|{
comment|/* error */
name|SEQ_DEC
argument_list|(
name|tpcb
argument_list|,
name|lowseq
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* set the transmit-time for computation of round-trip times */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|time
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|tpcb
operator|->
name|tp_rttemit
index|[
name|lowseq
operator|&
name|TP_RTT_NUM
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_while

begin_label
name|done
label|:
end_label

begin_macro
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|npkts
decl_stmt|;
name|struct
name|timeval
name|send_end_time
decl_stmt|;
specifier|register
name|struct
name|timeval
modifier|*
name|t
decl_stmt|;
name|npkts
operator|=
name|lowseq
expr_stmt|;
name|SEQ_INC
argument_list|(
name|tpcb
argument_list|,
name|npkts
argument_list|)
expr_stmt|;
name|npkts
operator|=
name|SEQ_SUB
argument_list|(
name|tpcb
argument_list|,
name|npkts
argument_list|,
name|lowsave
argument_list|)
expr_stmt|;
if|if
condition|(
name|npkts
operator|>
literal|0
condition|)
name|tpcb
operator|->
name|tp_Nwindow
operator|++
expr_stmt|;
if|if
condition|(
name|npkts
operator|>
name|TP_PM_MAX
condition|)
name|npkts
operator|=
name|TP_PM_MAX
expr_stmt|;
name|GET_TIME_SINCE
argument_list|(
operator|&
name|send_start_time
argument_list|,
operator|&
name|send_end_time
argument_list|)
expr_stmt|;
name|t
operator|=
operator|&
operator|(
name|tpcb
operator|->
name|tp_p_meas
operator|->
name|tps_sendtime
index|[
name|npkts
index|]
operator|)
expr_stmt|;
name|t
operator|->
name|tv_sec
operator|=
name|SMOOTH
argument_list|(
name|long
argument_list|,
name|TP_RTT_ALPHA
argument_list|,
name|t
operator|->
name|tv_sec
argument_list|,
name|send_end_time
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|t
operator|->
name|tv_usec
operator|=
name|SMOOTH
argument_list|(
name|long
argument_list|,
name|TP_RTT_ALPHA
argument_list|,
name|t
operator|->
name|tv_usec
argument_list|,
name|send_end_time
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tpcb
argument_list|,
name|lowseq
argument_list|,
name|highseq
argument_list|)
condition|)
block|{
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_win_lim_by_data
index|[
name|npkts
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_win_lim_by_cdt
index|[
name|npkts
index|]
argument_list|)
expr_stmt|;
comment|/* not true with congestion-window being used */
block|}
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPsbsend
argument_list|,
operator|&
name|send_end_time
argument_list|,
name|lowsave
argument_list|,
name|tpcb
operator|->
name|tp_Nwindow
argument_list|,
name|npkts
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|ENDPERF
name|tpcb
operator|->
name|tp_sndhiwat
init|=
name|lowseq
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|tpcb
argument_list|,
name|lowsave
argument_list|,
name|tpcb
operator|->
name|tp_sndhiwat
argument_list|)
operator|&&
operator|(
name|tpcb
operator|->
name|tp_class
operator|!=
name|TP_CLASS_0
operator|)
condition|)
name|tp_etimeout
argument_list|(
name|tpcb
operator|->
name|tp_refp
argument_list|,
name|TM_data_retrans
argument_list|,
name|lowsave
argument_list|,
name|tpcb
operator|->
name|tp_sndhiwat
argument_list|,
operator|(
name|u_int
operator|)
name|tpcb
operator|->
name|tp_Nretrans
argument_list|,
operator|(
name|int
operator|)
name|tpcb
operator|->
name|tp_dt_ticks
argument_list|)
expr_stmt|;
end_if

begin_macro
name|IFTRACE
argument_list|(
argument|D_DATA
argument_list|)
end_macro

begin_expr_stmt
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_send at end: sndhiwat lowseq eotsdu_reached error"
argument_list|,
name|tpcb
operator|->
name|tp_sndhiwat
argument_list|,
name|lowseq
argument_list|,
name|eotsdu_reached
argument_list|,
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_error
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ENDTRACE
end_expr_stmt

begin_comment
unit|}
comment|/*  * NAME: tp_stash()  * CALLED FROM:  *	tp.trans on arrival of a DT tpdu  * FUNCTION, ARGUMENTS, and RETURN VALUE:  * 	Returns 1 if   *		a) something new arrived and it's got eotsdu_reached bit on,  * 		b) this arrival was caused other out-of-sequence things to be  *    	accepted, or  * 		c) this arrival is the highest seq # for which we last gave credit  *   	(sender just sent a whole window)  *  In other words, returns 1 if tp should send an ack immediately, 0 if   *  the ack can wait a while.  *  * Note: this implementation no longer renegs on credit, (except  * when debugging option D_RENEG is on, for the purpose of testing  * ack subsequencing), so we don't  need to check for incoming tpdus   * being in a reneged portion of the window.  */
end_comment

begin_expr_stmt
unit|int
name|tp_stash
argument_list|(
name|tpcb
argument_list|,
name|e
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|tp_event
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|ack_reason
init|=
name|tpcb
operator|->
name|tp_ack_strat
operator|&
name|ACK_STRAT_EACH
decl_stmt|;
comment|/* 0--> delay acks until full window */
comment|/* 1--> ack each tpdu */
name|int
name|newrec
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
define|#
directive|define
name|E
value|e->ATTR(DT_TPDU)
else|#
directive|else
else|lint
define|#
directive|define
name|E
value|e->ev_union.EV_DT_TPDU
endif|#
directive|endif
endif|lint
if|if
condition|(
name|E
operator|.
name|e_eot
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
init|=
name|E
operator|.
name|e_data
decl_stmt|;
name|n
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
name|n
operator|->
name|m_act
operator|=
literal|0
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_STASH
argument_list|)
name|dump_mbuf
argument_list|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
literal|"stash: so_rcv before appending"
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|E
operator|.
name|e_data
argument_list|,
literal|"stash: e_data before appending"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFPERF
argument_list|(
name|tpcb
argument_list|)
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_from_ll
argument_list|)
decl|+=
name|E
operator|.
name|e_datalen
decl_stmt|;
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_from_ll
argument_list|,
operator|&
name|e
operator|->
name|e_time
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
operator|(
name|u_int
operator|)
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_from_ll
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
name|E
operator|.
name|e_datalen
argument_list|)
expr_stmt|;
name|ENDPERF
if|if
condition|(
name|E
operator|.
name|e_seq
operator|==
name|tpcb
operator|->
name|tp_rcvnxt
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_STASH
argument_list|)
name|printf
argument_list|(
literal|"stash EQ: seq 0x%x datalen 0x%x eot 0x%x\n"
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
name|E
operator|.
name|e_datalen
argument_list|,
name|E
operator|.
name|e_eot
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_STASH
parameter_list|)
function_decl|tptraceTPCB
parameter_list|(
name|TPPTmisc
parameter_list|,
function_decl|"stash EQ: seq len eot"
operator|,
function_decl|E.e_seq
operator|,
function_decl|E.e_datalen
operator|,
function_decl|E.e_eot
operator|,
function_decl|0
block|)
empty_stmt|;
name|ENDTRACE
name|sbappend
argument_list|(
operator|&
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_rcv
argument_list|,
name|E
operator|.
name|e_data
argument_list|)
decl_stmt|;
if|if
condition|(
name|newrec
operator|=
name|E
operator|.
name|e_eot
condition|)
comment|/* ASSIGNMENT */
name|ack_reason
operator||=
name|ACK_EOT
expr_stmt|;
name|SEQ_INC
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
argument_list|)
expr_stmt|;
comment|/*  		 * move chains from the rtc list to the socket buffer 		 * and free the rtc header 		 */
block|{
specifier|register
name|struct
name|tp_rtc
modifier|*
modifier|*
name|r
init|=
operator|&
name|tpcb
operator|->
name|tp_rcvnxt_rtc
decl_stmt|;
specifier|register
name|struct
name|tp_rtc
modifier|*
name|s
init|=
name|tpcb
operator|->
name|tp_rcvnxt_rtc
decl_stmt|;
while|while
condition|(
name|s
operator|!=
operator|(
expr|struct
name|tp_rtc
operator|*
operator|)
literal|0
operator|&&
name|s
operator|->
name|tprt_seq
operator|==
name|tpcb
operator|->
name|tp_rcvnxt
condition|)
block|{
operator|*
name|r
operator|=
name|s
operator|->
name|tprt_next
expr_stmt|;
name|sbappend
argument_list|(
operator|&
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_rcv
argument_list|,
name|s
operator|->
name|tprt_data
argument_list|)
expr_stmt|;
name|SEQ_INC
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|*
name|r
expr_stmt|;
name|ack_reason
operator||=
name|ACK_REORDER
expr_stmt|;
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_STASH
argument_list|)
name|dump_mbuf
argument_list|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
literal|"stash: so_rcv after appending"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_else
else|else
block|{
specifier|register
name|struct
name|tp_rtc
modifier|*
modifier|*
name|s
init|=
operator|&
name|tpcb
operator|->
name|tp_rcvnxt_rtc
decl_stmt|;
specifier|register
name|struct
name|tp_rtc
modifier|*
name|r
init|=
name|tpcb
operator|->
name|tp_rcvnxt_rtc
decl_stmt|;
specifier|register
name|struct
name|tp_rtc
modifier|*
name|t
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_STASH
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"stash Reseq: seq rcvnxt lcdt"
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
argument_list|,
name|tpcb
operator|->
name|tp_lcredit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|r
init|=
name|tpcb
operator|->
name|tp_rcvnxt_rtc
decl_stmt|;
while|while
condition|(
name|r
operator|!=
operator|(
expr|struct
name|tp_rtc
operator|*
operator|)
literal|0
operator|&&
name|SEQ_LT
argument_list|(
name|tpcb
argument_list|,
name|r
operator|->
name|tprt_seq
argument_list|,
name|E
operator|.
name|e_seq
argument_list|)
condition|)
block|{
name|s
operator|=
operator|&
name|r
operator|->
name|tprt_next
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|tprt_next
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
operator|(
expr|struct
name|tp_rtc
operator|*
operator|)
literal|0
operator|||
name|SEQ_GT
argument_list|(
name|tpcb
argument_list|,
name|r
operator|->
name|tprt_seq
argument_list|,
name|E
operator|.
name|e_seq
argument_list|)
condition|)
block|{
name|IncStat
argument_list|(
name|ts_dt_ooo
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_STASH
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_stash OUT OF ORDER- MAKE RTC: seq, 1st seq in list\n"
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
name|r
operator|->
name|tprt_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
parameter_list|(
name|D_STASH
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"tp_stash OUT OF ORDER- MAKE RTC\n"
block|)
empty_stmt|;
name|ENDDEBUG
name|TP_MAKE_RTC
argument_list|(
name|t
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
name|E
operator|.
name|e_eot
argument_list|,
name|E
operator|.
name|e_data
argument_list|,
name|E
operator|.
name|e_datalen
argument_list|,
literal|0
argument_list|,
name|TPMT_RCVRTC
argument_list|)
decl_stmt|;
operator|*
name|s
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|tprt_next
operator|=
operator|(
expr|struct
name|tp_rtc
operator|*
operator|)
name|r
expr_stmt|;
name|ack_reason
operator|=
name|ACK_DONT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_else

begin_else
else|else
block|{
name|IFDEBUG
argument_list|(
argument|D_STASH
argument_list|)
name|printf
argument_list|(
literal|"tp_stash - drop& ack\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* retransmission - drop it and force an ack */
name|IncStat
parameter_list|(
name|ts_dt_dup
parameter_list|)
function_decl|;
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_n_ack_cuz_dup
argument_list|)
expr_stmt|;
name|ENDPERF
name|m_freem
parameter_list|(
name|E
operator|.
name|e_data
parameter_list|)
function_decl|;
name|ack_reason
operator||=
name|ACK_DUP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_else

begin_comment
unit|}
comment|/* 	 * an ack should be sent when at least one of the 	 * following holds: 	 * a) we've received a TPDU with EOTSDU set 	 * b) the TPDU that just arrived represents the 	 *    full window last advertised, or 	 * c) when seq X arrives [ where 	 * 		X = last_sent_uwe - 1/2 last_lcredit_sent  	 * 		(the packet representing 1/2 the last advertised window) ] 	 * 		and lcredit at the time of X arrival>  last_lcredit_sent/2 	 * 		In other words, if the last ack sent advertised cdt=8 and uwe = 8 	 * 		then when seq 4 arrives I'd like to send a new ack 	 * 		iff the credit at the time of 4's arrival is> 4. 	 * 		The other end thinks it has cdt of 4 so if local cdt 	 * 		is still 4 there's no point in sending an ack, but if 	 * 		my credit has increased because the receiver has taken 	 * 		some data out of the buffer (soreceive doesn't notify 	 * 		me until the SYSTEM CALL finishes), I'd like to tell 	 * 		the other end.   	 */
end_comment

begin_block
unit|done:
block|{
name|LOCAL_CREDIT
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|E
operator|.
name|e_seq
operator|==
name|tpcb
operator|->
name|tp_sent_uwe
condition|)
name|ack_reason
operator||=
name|ACK_STRAT_FULLWIN
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_STASH
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"end of stash, eot, ack_reason, sent_uwe "
argument_list|,
name|E
operator|.
name|e_eot
argument_list|,
name|ack_reason
argument_list|,
name|tpcb
operator|->
name|tp_sent_uwe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|ack_reason
operator|==
name|ACK_DONT
condition|)
block|{
name|IncStat
argument_list|(
name|ts_ackreason
index|[
name|ACK_DONT
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
if|if
condition|(
name|ack_reason
operator|&
name|ACK_EOT
condition|)
block|{
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_n_ack_cuz_eot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ack_reason
operator|&
name|ACK_STRAT_EACH
condition|)
block|{
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_n_ack_cuz_strat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ack_reason
operator|&
name|ACK_STRAT_FULLWIN
condition|)
block|{
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_n_ack_cuz_fullwin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ack_reason
operator|&
name|ACK_REORDER
condition|)
block|{
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_n_ack_cuz_reorder
argument_list|)
expr_stmt|;
block|}
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_ack_sent
argument_list|,
literal|0
argument_list|,
name|SEQ_ADD
argument_list|(
name|tpcb
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDPERF
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* keep track of all reasons that apply */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|_ACK_NUM_REASONS_
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ack_reason
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|IncStat
argument_list|(
name|ts_ackreason
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
block|}
end_block

begin_comment
unit|}
comment|/* class zero version */
end_comment

begin_expr_stmt
unit|void
name|tp0_stash
argument_list|(
name|tpcb
argument_list|,
name|e
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|tp_event
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|lint
define|#
directive|define
name|E
value|e->ATTR(DT_TPDU)
else|#
directive|else
else|lint
define|#
directive|define
name|E
value|e->ev_union.EV_DT_TPDU
endif|#
directive|endif
endif|lint
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_from_ll
argument_list|)
operator|+=
name|E
operator|.
name|e_datalen
expr_stmt|;
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_from_ll
argument_list|,
operator|&
name|e
operator|->
name|e_time
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_from_ll
argument_list|)
argument_list|,
name|E
operator|.
name|e_datalen
argument_list|)
expr_stmt|;
name|ENDPERF
name|IFDEBUG
parameter_list|(
name|D_STASH
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"stash EQ: seq 0x%x datalen 0x%x eot 0x%x"
operator|,
function_decl|E.e_seq
operator|,
function_decl|E.e_datalen
operator|,
function_decl|E.e_eot
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_STASH
parameter_list|)
function_decl|tptraceTPCB
parameter_list|(
name|TPPTmisc
parameter_list|,
function_decl|"stash EQ: seq len eot"
operator|,
function_decl|E.e_seq
operator|,
function_decl|E.e_datalen
operator|,
function_decl|E.e_eot
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_macro
name|ENDTRACE
end_macro

begin_if
if|if
condition|(
name|E
operator|.
name|e_eot
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
init|=
name|E
operator|.
name|e_data
decl_stmt|;
name|n
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
name|n
operator|->
name|m_act
operator|=
name|MNULL
expr_stmt|;
comment|/* set on tp_input */
block|}
end_if

begin_expr_stmt
name|sbappend
argument_list|(
operator|&
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_rcv
argument_list|,
name|E
operator|.
name|e_data
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|IFDEBUG
argument_list|(
argument|D_STASH
argument_list|)
end_macro

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
literal|"stash 0: so_rcv after appending"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ENDDEBUG
end_expr_stmt

unit|}
end_unit

