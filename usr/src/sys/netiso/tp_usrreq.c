begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*   * ARGO TP  *  * $Header: tp_usrreq.c,v 5.4 88/11/18 17:29:18 nhall Exp $  * $Source: /usr/argo/sys/netiso/RCS/tp_usrreq.c,v $  *	@(#)tp_usrreq.c	7.4 (Berkeley) %G% *  *  * tp_usrreq(), the fellow that gets called from most of the socket code.  * Pretty straighforward.  * THe only really awful stuff here is the OOB processing, which is done  * wholly here.  * tp_rcvoob() and tp_sendoob() are contained here and called by tp_usrreq().  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: tp_usrreq.c,v 5.4 88/11/18 17:29:18 nhall Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"tp_param.h"
end_include

begin_include
include|#
directive|include
file|"tp_timer.h"
end_include

begin_include
include|#
directive|include
file|"tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"tp_seq.h"
end_include

begin_include
include|#
directive|include
file|"tp_ip.h"
end_include

begin_include
include|#
directive|include
file|"tp_pcb.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"tp_trace.h"
end_include

begin_include
include|#
directive|include
file|"tp_meas.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"iso_errno.h"
end_include

begin_decl_stmt
name|int
name|tp_attach
argument_list|()
decl_stmt|,
name|tp_driver
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_comment
comment|/*  * CALLED FROM:  *  anywhere you want to debug...  * FUNCTION and ARGUMENTS:  *  print (str) followed by the control info in the mbufs of an mbuf chain (n)  */
end_comment

begin_function
name|void
name|dump_mbuf
parameter_list|(
name|n
parameter_list|,
name|str
parameter_list|)
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|nextrecord
decl_stmt|;
name|printf
argument_list|(
literal|"dump %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|MNULL
condition|)
block|{
name|printf
argument_list|(
literal|"EMPTY:\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
name|n
condition|;
control|)
block|{
name|nextrecord
operator|=
name|n
operator|->
name|m_act
expr_stmt|;
name|printf
argument_list|(
literal|"RECORD:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|printf
argument_list|(
literal|"%x : Len %x Data %x A %x Nx %x Tp %x\n"
argument_list|,
name|n
argument_list|,
name|n
operator|->
name|m_len
argument_list|,
name|n
operator|->
name|m_data
argument_list|,
name|n
operator|->
name|m_act
argument_list|,
name|n
operator|->
name|m_next
argument_list|,
name|n
operator|->
name|m_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|mtod
argument_list|(
name|n
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"data: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|->
name|m_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
operator|*
operator|(
name|p
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|notdef
if|if
condition|(
name|n
operator|->
name|m_next
operator|==
name|n
condition|)
block|{
name|printf
argument_list|(
literal|"LOOP!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
block|}
name|n
operator|=
name|nextrecord
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|ARGO_DEBUG
end_endif

begin_comment
comment|/*  * CALLED FROM:  *  tp_usrreq(), PRU_RCVOOB  * FUNCTION and ARGUMENTS:  * 	Copy data from the expedited data socket buffer into  * 	the pre-allocated mbuf m.  * 	There is an isomorphism between XPD TPDUs and expedited data TSDUs.  * 	XPD tpdus are limited to 16 bytes of data so they fit in one mbuf.  * RETURN VALUE:  *  EINVAL if debugging is on and a disaster has occurred  *  ENOTCONN if the socket isn't connected  *  EWOULDBLOCK if the socket is in non-blocking mode and there's no  *		xpd data in the buffer  *  E* whatever is returned from the fsm.  */
end_comment

begin_macro
name|tp_rcvoob
argument_list|(
argument|tpcb
argument_list|,
argument|so
argument_list|,
argument|m
argument_list|,
argument|outflags
argument_list|,
argument|inflags
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|outflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inflags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_rcv
decl_stmt|;
name|struct
name|tp_event
name|E
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|nn
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|printf
argument_list|(
literal|"PRU_RCVOOB, sostate 0x%x\n"
argument_list|,
name|so
operator|->
name|so_state
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* if you use soreceive */
if|if
condition|(
name|m
operator|==
name|MNULL
condition|)
return|return
name|ENOBUFS
return|;
name|restart
label|:
if|if
condition|(
operator|(
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTING
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
condition|)
block|{
return|return
name|ENOTCONN
return|;
block|}
comment|/* Take the first mbuf off the chain. 	 * Each XPD TPDU gives you a complete TSDU so the chains don't get  	 * coalesced, but one TSDU may span several mbufs. 	 * Nevertheless, since n should have a most 16 bytes, it 	 * will fit into m.  (size was checked in tp_input() ) 	 */
comment|/* 	 * Code for excision of OOB data should be added to 	 * uipc_socket2.c (like sbappend). 	 */
name|sblock
argument_list|(
name|sb
argument_list|)
expr_stmt|;
for|for
control|(
name|nn
operator|=
operator|&
name|sb
operator|->
name|sb_mb
init|;
name|n
operator|=
operator|*
name|nn
condition|;
name|nn
operator|=
operator|&
name|n
operator|->
name|m_act
control|)
if|if
condition|(
name|n
operator|->
name|m_type
operator|==
name|MT_OOBDATA
condition|)
break|break;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
name|tpcb
operator|->
name|tp_flags
operator|&
name|TPF_DISC_DATA_IN
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|printf
argument_list|(
literal|"RCVOOB: empty queue!\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|sbunlock
parameter_list|(
name|sb
parameter_list|)
function_decl|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
condition|)
block|{
return|return
name|EWOULDBLOCK
return|;
block|}
name|sbwait
argument_list|(
name|sb
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
comment|/* Assuming at most one xpd tpdu is in the buffer at once */
while|while
condition|(
name|n
operator|!=
name|MNULL
condition|)
block|{
name|m
operator|->
name|m_len
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|n
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
comment|/* so mtod() in bcopy() above gives right addr */
name|n
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
block|}
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_dat
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|printf
argument_list|(
literal|"tp_rcvoob: xpdlen 0x%x\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
literal|"RCVOOB: Rcv socketbuf"
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|"RCVOOB: Xrcv socketbuf"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|inflags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|=
operator|*
name|nn
expr_stmt|;
operator|*
name|nn
operator|=
name|n
operator|->
name|m_act
expr_stmt|;
name|sb
operator|->
name|sb_cc
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|release
label|:
name|sbunlock
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_XPD
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"PRU_RCVOOB @ release sb_cc m_len"
argument_list|,
name|tpcb
operator|->
name|tp_Xrcv
operator|.
name|sb_cc
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|DoEvent
argument_list|(
name|T_USR_Xrcvd
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  *  tp_usrreq(), PRU_SENDOOB  * FUNCTION and ARGUMENTS:  * 	Send what's in the mbuf chain (m) as an XPD TPDU.  * 	The mbuf may not contain more then 16 bytes of data.  * 	XPD TSDUs aren't segmented, so they translate into  * 	exactly one XPD TPDU, with EOT bit set.  * RETURN VALUE:  *  EWOULDBLOCK if socket is in non-blocking mode and the previous  *   xpd data haven't been acked yet.  *  EMSGSIZE if trying to send> max-xpd bytes (16)  *  ENOBUFS if ran out of mbufs  */
end_comment

begin_macro
name|tp_sendoob
argument_list|(
argument|tpcb
argument_list|,
argument|so
argument_list|,
argument|xdata
argument_list|,
argument|outflags
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|xdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|outflags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not used */
end_comment

begin_block
block|{
comment|/* 	 * Each mbuf chain represents a sequence # in the XPD seq space. 	 * The first one in the queue has sequence # tp_Xuna. 	 * When we add to the XPD queue, we stuff a zero-length 	 * mbuf (mark) into the DATA queue, with its sequence number in m_next 	 * to be assigned to this XPD tpdu, so data xfer can stop 	 * when it reaches the zero-length mbuf if this XPD TPDU hasn't 	 * yet been acknowledged.   	 */
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
operator|(
name|tpcb
operator|->
name|tp_Xsnd
operator|)
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|xmark
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
name|struct
name|tp_event
name|E
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|printf
argument_list|(
literal|"tp_sendoob:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdata
condition|)
name|printf
argument_list|(
literal|"xdata len 0x%x\n"
argument_list|,
name|xdata
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* DO NOT LOCK the Xsnd buffer!!!! You can have at MOST one  	 * socket buf locked at any time!!! (otherwise you might 	 * sleep() in sblock() w/ a signal pending and cause the 	 * system call to be aborted w/ a locked socketbuf, which 	 * is a problem.  So the so_snd buffer lock 	 * (done in sosend()) serves as the lock for Xpd. 	 */
if|if
condition|(
name|sb
operator|->
name|sb_mb
condition|)
block|{
comment|/* Anything already in eXpedited data sockbuf? */
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
condition|)
block|{
return|return
name|EWOULDBLOCK
return|;
block|}
while|while
condition|(
name|sb
operator|->
name|sb_mb
condition|)
block|{
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* already locked by sosend */
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|sblock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* sosend will unlock on return */
block|}
block|}
if|if
condition|(
name|xdata
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* empty xpd packet */
name|MGETHDR
argument_list|(
name|xdata
argument_list|,
name|M_WAIT
argument_list|,
name|MT_OOBDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdata
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOBUFS
return|;
block|}
name|xdata
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|xdata
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|printf
argument_list|(
literal|"tp_sendoob 1:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdata
condition|)
name|printf
argument_list|(
literal|"xdata len 0x%x\n"
argument_list|,
name|xdata
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|xmark
init|=
name|xdata
decl_stmt|;
comment|/* temporary use of variable xmark */
while|while
condition|(
name|xmark
condition|)
block|{
name|len
operator|+=
name|xmark
operator|->
name|m_len
expr_stmt|;
name|xmark
operator|=
name|xmark
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|TP_MAX_XPD_DATA
condition|)
block|{
return|return
name|EMSGSIZE
return|;
block|}
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|printf
argument_list|(
literal|"tp_sendoob 2:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdata
condition|)
name|printf
argument_list|(
literal|"xdata len 0x%x\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_XPD
parameter_list|)
function_decl|tptraceTPCB
parameter_list|(
name|TPPTmisc
parameter_list|,
function_decl|"XPD mark m_next "
operator|,
function_decl|xdata->m_next
operator|,
function_decl|0
operator|,
function_decl|0
operator|,
function_decl|0
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
name|ENDTRACE
name|sbappendrecord
parameter_list|(
name|sb
parameter_list|,
name|xdata
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"tp_sendoob len 0x%x\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|so
operator|->
name|so_snd
operator|.
name|sb_mb
argument_list|,
literal|"XPD request Regular sndbuf:"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|tpcb
operator|->
name|tp_Xsnd
operator|.
name|sb_mb
argument_list|,
literal|"XPD request Xsndbuf:"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDDEBUG
end_macro

begin_return
return|return
name|DoEvent
argument_list|(
name|T_XPD_req
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/*  * CALLED FROM:  *  the socket routines  * FUNCTION and ARGUMENTS:  * 	Handles all "user requests" except the [gs]ockopts() requests.  * 	The argument (req) is the request type (PRU*),   * 	(m) is an mbuf chain, generally used for send and  * 	receive type requests only.  * 	(nam) is used for addresses usually, in particular for the bind request.  *   */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
unit|ProtoHook
name|tp_usrreq
argument_list|(
argument|so
argument_list|,
argument|req
argument_list|,
argument|m
argument_list|,
argument|nam
argument_list|,
argument|rightsp
argument_list|,
argument|controlp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nam
decl_stmt|,
modifier|*
name|rightsp
decl_stmt|,
modifier|*
name|controlp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
init|=
name|sototpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|flags
decl_stmt|,
modifier|*
name|outflags
init|=
operator|&
name|flags
decl_stmt|;
name|u_long
name|eotsdu
init|=
literal|0
decl_stmt|;
name|struct
name|tp_event
name|E
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"usrreq(0x%x,%d,0x%x,0x%x,0x%x)\n"
argument_list|,
name|so
argument_list|,
name|req
argument_list|,
name|m
argument_list|,
name|nam
argument_list|,
name|outflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
name|printf
argument_list|(
literal|"WARNING!!! so->so_error is 0x%x\n"
argument_list|,
name|so
operator|->
name|so_error
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_REQUEST
parameter_list|)
function_decl|tptraceTPCB
parameter_list|(
name|TPPTusrreq
parameter_list|,
function_decl|"req so m state ["
operator|,
function_decl|req
operator|,
function_decl|so
operator|,
function_decl|m
operator|,
function_decl|tpcb?tpcb->tp_state:0
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|ENDTRACE
end_macro

begin_if
if|if
condition|(
operator|(
name|u_int
operator|)
name|tpcb
operator|==
literal|0
operator|&&
name|req
operator|!=
name|PRU_ATTACH
condition|)
block|{
name|IFTRACE
argument_list|(
argument|D_REQUEST
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTusrreq
argument_list|,
literal|"req failed NO TPCB["
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|splx
parameter_list|(
name|s
parameter_list|)
function_decl|;
return|return
name|ENOTCONN
return|;
block|}
end_if

begin_switch
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRU_ATTACH
case|:
if|if
condition|(
name|tpcb
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|=
name|tp_attach
argument_list|(
name|so
argument_list|,
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
argument_list|)
condition|)
break|break;
name|tpcb
operator|=
name|sototpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_ABORT
case|:
comment|/* called from close() */
comment|/* called for each incoming connect queued on the  		 *	parent (accepting) socket  		 */
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_OPEN
condition|)
block|{
name|E
operator|.
name|ATTR
argument_list|(
name|T_DISC_req
argument_list|)
operator|.
name|e_reason
operator|=
name|E_TP_NO_SESSION
expr_stmt|;
name|error
operator|=
name|DoEvent
argument_list|(
name|T_DISC_req
argument_list|)
expr_stmt|;
comment|/* pretend it was a close() */
break|break;
block|}
comment|/* else DROP THROUGH */
case|case
name|PRU_DETACH
case|:
comment|/* called from close() */
comment|/* called only after disconnect was called */
name|error
operator|=
name|DoEvent
argument_list|(
name|T_DETACH
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CLOSED
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
name|tpcb
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|PRU_SHUTDOWN
case|:
comment|/* recv end may have been released; local credit might be zero  */
case|case
name|PRU_DISCONNECT
case|:
name|E
operator|.
name|ATTR
argument_list|(
name|T_DISC_req
argument_list|)
operator|.
name|e_reason
operator|=
name|E_TP_NORMAL_DISC
expr_stmt|;
name|error
operator|=
name|DoEvent
argument_list|(
name|T_DISC_req
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_BIND
case|:
name|error
operator|=
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_pcbbind
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_getsufx
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
operator|&
name|tpcb
operator|->
name|tp_lsuffixlen
argument_list|,
name|tpcb
operator|->
name|tp_lsuffix
argument_list|,
name|TP_LOCAL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PRU_LISTEN
case|:
if|if
condition|(
name|tpcb
operator|->
name|tp_lsuffixlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|=
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_pcbbind
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
name|MNULL
argument_list|)
condition|)
break|break;
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_getsufx
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
operator|&
name|tpcb
operator|->
name|tp_lsuffixlen
argument_list|,
name|tpcb
operator|->
name|tp_lsuffix
argument_list|,
name|TP_LOCAL
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|!=
name|TP_CLOSED
condition|)
name|printf
argument_list|(
literal|"LISTEN ERROR: state 0x%x\n"
argument_list|,
name|tpcb
operator|->
name|tp_state
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|error
init|=
name|DoEvent
argument_list|(
name|T_LISTEN_req
argument_list|)
decl_stmt|;
break|break;
case|case
name|PRU_CONNECT2
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
comment|/* for unix domain sockets */
break|break;
case|case
name|PRU_CONNECT
case|:
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"PRU_CONNECT: so 0x%x *SHORT_LSUFXP(tpcb) 0x%x lsuflen 0x%x, class 0x%x"
argument_list|,
name|tpcb
operator|->
name|tp_sock
argument_list|,
operator|*
name|SHORT_LSUFXP
argument_list|(
name|tpcb
argument_list|)
argument_list|,
name|tpcb
operator|->
name|tp_lsuffixlen
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
parameter_list|(
name|D_CONN
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"PRU_CONNECT: so *SHORT_LSUFXP(tpcb) 0x%x lsuflen 0x%x, class 0x%x"
operator|,
function_decl|tpcb->tp_sock
operator|,
function_decl|*SHORT_LSUFXP
parameter_list|(
name|tpcb
parameter_list|)
operator|,
function_decl|tpcb->tp_lsuffixlen
operator|,
function_decl|tpcb->tp_class
block|)
empty_stmt|;
end_switch

begin_macro
name|ENDDEBUG
end_macro

begin_if
if|if
condition|(
name|tpcb
operator|->
name|tp_lsuffixlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|=
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_pcbbind
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
name|MNULL
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"pcbbind returns error 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
break|break;
block|}
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_getsufx
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
operator|&
name|tpcb
operator|->
name|tp_lsuffixlen
argument_list|,
name|tpcb
operator|->
name|tp_lsuffix
argument_list|,
name|TP_LOCAL
argument_list|)
expr_stmt|;
block|}
end_if

begin_macro
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"isop 0x%x isop->isop_socket offset 12 :\n"
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_buf
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|,
literal|16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDDEBUG
end_macro

begin_if
if|if
condition|(
name|error
operator|=
name|tp_route_to
argument_list|(
name|nam
argument_list|,
name|tpcb
argument_list|,
comment|/* channel */
literal|0
argument_list|)
condition|)
break|break;
end_if

begin_macro
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"PRU_CONNECT after tpcb 0x%x so 0x%x npcb 0x%x flags 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|so
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|tpcb
operator|->
name|tp_flags
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|printf
argument_list|(
literal|"isop 0x%x isop->isop_socket offset 12 :\n"
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_buf
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|,
literal|16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDDEBUG
end_macro

begin_if
if|if
condition|(
name|tpcb
operator|->
name|tp_fsuffixlen
operator|==
literal|0
condition|)
block|{
comment|/* didn't set peer extended suffix */
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_getsufx
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
operator|&
name|tpcb
operator|->
name|tp_fsuffixlen
argument_list|,
name|tpcb
operator|->
name|tp_fsuffix
argument_list|,
name|TP_FOREIGN
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
call|(
name|void
call|)
argument_list|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_mtu
argument_list|)
argument_list|(
name|so
argument_list|,
name|so
operator|->
name|so_pcb
argument_list|,
operator|&
name|tpcb
operator|->
name|tp_l_tpdusize
argument_list|,
operator|&
name|tpcb
operator|->
name|tp_tpdusize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CLOSED
condition|)
block|{
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|DoEvent
argument_list|(
name|T_CONN_req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_pcbdisc
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|)
expr_stmt|;
name|error
operator|=
name|EISCONN
expr_stmt|;
block|}
end_if

begin_macro
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|lsufx
decl_stmt|,
name|fsufx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|lsufx
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_lsuffix
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fsufx
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_fsuffix
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_open
operator||
operator|(
name|tpcb
operator|->
name|tp_xtd_format
operator|<<
literal|4
operator|)
argument_list|,
operator|&
name|time
argument_list|,
name|lsufx
argument_list|,
name|fsufx
argument_list|,
name|tpcb
operator|->
name|tp_fref
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDPERF
end_macro

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_ACCEPT
case|:
end_case

begin_expr_stmt
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_getnetaddr
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
name|nam
argument_list|,
name|TP_FOREIGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"ACCEPT PEERADDDR:"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_buf
argument_list|(
name|mtod
argument_list|(
name|nam
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|nam
operator|->
name|m_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ENDDEBUG
name|IFPERF
argument_list|(
name|tpcb
argument_list|)
name|u_int
name|lsufx
decl_stmt|,
name|fsufx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|lsufx
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_lsuffix
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fsufx
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_fsuffix
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_open
argument_list|,
operator|&
name|time
argument_list|,
name|lsufx
argument_list|,
name|fsufx
argument_list|,
name|tpcb
operator|->
name|tp_fref
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDPERF
end_macro

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_RCVD
case|:
end_case

begin_if
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONFIRMING
condition|)
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CONFIRMING
condition|)
name|error
operator|=
name|tp_confirm
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
break|break;
block|}
end_if

begin_macro
name|IFTRACE
argument_list|(
argument|D_DATA
argument_list|)
end_macro

begin_expr_stmt
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"RCVD BF: lcredit sent_lcdt cc hiwat \n"
argument_list|,
name|tpcb
operator|->
name|tp_lcredit
argument_list|,
name|tpcb
operator|->
name|tp_sent_lcdt
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LOCAL_CREDIT
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"PRU_RCVD AF sbspace lcredit hiwat cc"
argument_list|,
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
argument_list|,
name|tpcb
operator|->
name|tp_lcredit
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|ENDTRACE
name|IFDEBUG
parameter_list|(
name|D_REQUEST
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"RCVD: cc %d space %d hiwat %d\n"
operator|,
function_decl|so->so_rcv.sb_cc
operator|,
function_decl|sbspace
parameter_list|(
function_decl|&so->so_rcv
end_function_decl

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_macro
name|ENDDEBUG
end_macro

begin_if
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|nam
operator|)
operator|&
name|MSG_OOB
condition|)
name|error
operator|=
name|DoEvent
argument_list|(
name|T_USR_Xrcvd
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|DoEvent
argument_list|(
name|T_USR_rcvd
argument_list|)
expr_stmt|;
end_if

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_RCVOOB
case|:
end_case

begin_if
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|tpcb
operator|->
name|tp_xpd_service
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
end_if

begin_comment
comment|/* kludge - nam is really flags here */
end_comment

begin_expr_stmt
name|error
operator|=
name|tp_rcvoob
argument_list|(
name|tpcb
argument_list|,
name|so
argument_list|,
name|m
argument_list|,
name|outflags
argument_list|,
operator|(
name|int
operator|)
name|nam
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_SEND
case|:
end_case

begin_case
case|case
name|PRU_SENDOOB
case|:
end_case

begin_if
if|if
condition|(
name|controlp
operator|&&
operator|(
name|error
operator|=
name|tp_snd_control
argument_list|(
name|controlp
argument_list|,
name|so
argument_list|,
operator|&
name|m
argument_list|)
operator|)
condition|)
break|break;
end_if

begin_if
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONFIRMING
condition|)
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CONFIRMING
condition|)
name|error
operator|=
name|tp_confirm
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|m
operator|->
name|m_len
operator|!=
literal|0
condition|)
name|error
operator|=
name|ENOTCONN
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
end_if

begin_if
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
end_if

begin_if
if|if
condition|(
name|req
operator|==
name|PRU_SENDOOB
condition|)
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_xpd_service
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|tp_sendoob
argument_list|(
name|tpcb
argument_list|,
name|so
argument_list|,
name|m
argument_list|,
name|outflags
argument_list|)
expr_stmt|;
break|break;
block|}
end_if

begin_comment
comment|/* 		 * The protocol machine copies mbuf chains, 		 * prepends headers, assigns seq numbers, and 		 * puts the packets on the device. 		 * When they are acked they are removed from the socket buf. 		 * 		 * sosend calls this up until sbspace goes negative. 		 * Sbspace may be made negative by appending this mbuf chain, 		 * possibly by a whole cluster. 		 */
end_comment

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
init|=
name|m
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_snd
decl_stmt|;
name|int
name|maxsize
init|=
name|tpcb
operator|->
name|tp_l_tpdusize
operator|-
name|tp_headersize
argument_list|(
name|DT_TPDU_type
argument_list|,
name|tpcb
argument_list|)
operator|-
operator|(
name|tpcb
operator|->
name|tp_use_checksum
condition|?
literal|4
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|totlen
init|=
name|n
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
comment|/* 			 * Could have eotsdu and no data.(presently MUST have 			 * an mbuf though, even if its length == 0)  			 */
if|if
condition|(
name|n
operator|->
name|m_flags
operator|&
name|M_EOR
condition|)
block|{
name|eotsdu
operator|=
literal|1
expr_stmt|;
name|n
operator|->
name|m_flags
operator|&=
operator|~
name|M_EOR
expr_stmt|;
block|}
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_from_sess
argument_list|)
operator|+=
name|totlen
expr_stmt|;
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_from_session
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_from_sess
argument_list|)
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|ENDPERF
name|IFDEBUG
parameter_list|(
name|D_SYSCALL
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"PRU_SEND: eot %d before sbappend 0x%x len 0x%x to sb @ 0x%x\n"
operator|,
function_decl|eotsdu
operator|,
function_decl|m
operator|,
function_decl|len
operator|,
function_decl|sb
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|"so_snd.sb_mb"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|m
argument_list|,
literal|"m : to be added"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDDEBUG
end_macro

begin_comment
comment|/* 			 * Pre-packetize the data in the sockbuf 			 * according to negotiated mtu.  Do it here 			 * where we can safely wait for mbufs. 			 */
end_comment

begin_while
while|while
condition|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|maxsize
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|nn
init|=
name|m_copym
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
name|maxsize
argument_list|,
name|M_WAIT
argument_list|)
decl_stmt|;
name|sbappendrecord
argument_list|(
name|sb
argument_list|,
name|nn
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|n
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|sbappendrecord
argument_list|(
name|sb
argument_list|,
name|n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|eotsdu
condition|)
comment|/* This presumes knowledge of sbappendrecord() */
name|n
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
end_if

begin_macro
name|IFDEBUG
argument_list|(
argument|D_SYSCALL
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"PRU_SEND: eot %d after sbappend 0x%x len 0x%x\n"
argument_list|,
name|eotsdu
argument_list|,
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|"so_snd.sb_mb"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ENDDEBUG
name|error
init|=
name|DoEvent
argument_list|(
name|T_DATA_req
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|IFDEBUG
argument_list|(
argument|D_SYSCALL
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"PRU_SEND: after driver error 0x%x \n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|printf
argument_list|(
literal|"so_snd 0x%x cc 0t%d mbcnt 0t%d\n"
argument_list|,
name|sb
argument_list|,
name|sb
operator|->
name|sb_cc
argument_list|,
name|sb
operator|->
name|sb_mbcnt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|"so_snd.sb_mb after driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ENDDEBUG
end_expr_stmt

begin_empty_stmt
unit|} 		break
empty_stmt|;
end_empty_stmt

begin_case
case|case
name|PRU_SOCKADDR
case|:
end_case

begin_expr_stmt
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_getnetaddr
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
name|nam
argument_list|,
name|TP_LOCAL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_PEERADDR
case|:
end_case

begin_expr_stmt
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_getnetaddr
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
name|nam
argument_list|,
name|TP_FOREIGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_CONTROL
case|:
end_case

begin_expr_stmt
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_PROTOSEND
case|:
end_case

begin_case
case|case
name|PRU_PROTORCV
case|:
end_case

begin_case
case|case
name|PRU_SENSE
case|:
end_case

begin_case
case|case
name|PRU_SLOWTIMO
case|:
end_case

begin_case
case|case
name|PRU_FASTTIMO
case|:
end_case

begin_expr_stmt
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_default
default|default:
end_default

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_expr_stmt
name|printf
argument_list|(
literal|"tp_usrreq UNKNOWN PRU %d\n"
argument_list|,
name|req
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
endif|ARGO_DEBUG
end_endif

begin_expr_stmt
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  	IFDEBUG
operator|(
name|D_REQUEST
operator|)
name|printf
argument_list|(
literal|"%s, so 0x%x, tpcb 0x%x, error %d, state %d\n"
argument_list|,
literal|"returning from tp_usrreq"
argument_list|,
name|so
argument_list|,
name|tpcb
argument_list|,
name|error
argument_list|,
name|tpcb
condition|?
literal|0
else|:
name|tpcb
operator|->
name|tp_state
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_REQUEST
parameter_list|)
function_decl|tptraceTPCB
parameter_list|(
name|TPPTusrreq
parameter_list|,
function_decl|"END req so m state ["
operator|,
function_decl|req
operator|,
function_decl|so
operator|,
function_decl|m
operator|,
function_decl|tpcb?0:tpcb->tp_state
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
name|ENDTRACE
name|splx
parameter_list|(
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_return
return|return
name|error
return|;
end_return

begin_expr_stmt
unit|}  tp_confirm
operator|(
name|tpcb
operator|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|tp_event
name|E
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CONFIRMING
condition|)
return|return
name|DoEvent
argument_list|(
name|T_ACPT_req
argument_list|)
return|;
name|printf
argument_list|(
literal|"Tp confirm called when not confirming; tpcb 0x%x, state 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Process control data sent with sendmsg()  */
end_comment

begin_expr_stmt
name|tp_snd_control
argument_list|(
name|m0
argument_list|,
name|so
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tp_control_hdr
modifier|*
name|ch
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m0
operator|&&
name|m0
operator|->
name|m_len
condition|)
block|{
name|ch
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|tp_control_hdr
operator|*
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_copym
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|error
operator|=
name|tp_ctloutput
argument_list|(
name|PRCO_SETOPT
argument_list|,
name|so
argument_list|,
name|ch
operator|->
name|cmsg_level
argument_list|,
name|ch
operator|->
name|cmsg_type
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|cmsg_type
operator|==
name|TPOPT_DISC_DATA
condition|)
block|{
if|if
condition|(
name|data
operator|&&
operator|*
name|data
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
literal|0
expr_stmt|;
block|}
name|m0
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|tp_usrreq
argument_list|(
name|so
argument_list|,
name|PRU_DISCONNECT
argument_list|,
name|m0
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|m0
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_block

end_unit

