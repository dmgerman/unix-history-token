begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*	@(#)esis.c	7.5 (Berkeley) %G% */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: esis.c,v 4.10 88/09/15 18:57:03 hagens Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"iso_pcb.h"
end_include

begin_include
include|#
directive|include
file|"iso_var.h"
end_include

begin_include
include|#
directive|include
file|"iso_snpac.h"
end_include

begin_include
include|#
directive|include
file|"clnl.h"
end_include

begin_include
include|#
directive|include
file|"clnp.h"
end_include

begin_include
include|#
directive|include
file|"clnp_stat.h"
end_include

begin_include
include|#
directive|include
file|"esis.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_comment
comment|/*  *	Global variables to esis implementation  *  *	esis_holding_time - the holding time (sec) parameter for outgoing pdus  *	esis_config_time  - the frequency (sec) that hellos are generated  *  */
end_comment

begin_decl_stmt
name|struct
name|isopcb
name|esis_pcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|esis_sendspace
init|=
literal|2048
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|esis_recvspace
init|=
literal|2048
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|esis_holding_time
init|=
name|ESIS_HT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|esis_config_time
init|=
name|ESIS_CONFIG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|iso_systype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|snpa_cache
name|all_es
decl_stmt|,
name|all_is
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EXTEND_PACKET
parameter_list|(
name|m
parameter_list|,
name|mhdr
parameter_list|,
name|cp
parameter_list|)
define|\
value|if (((m)->m_next = m_getclr(M_DONTWAIT, MT_HEADER)) == NULL) {\ 		esis_stat.es_nomem++;\ 		m_freem(mhdr);\ 		return;\ 	} else {\ 		(m) = (m)->m_next;\ 		(cp) = mtod((m), caddr_t);\ 	}
end_define

begin_comment
comment|/*  * FUNCTION:		esis_init  *  * PURPOSE:			Initialize the kernel portion of esis protocol  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|esis_init
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|struct
name|clnl_protosw
name|clnl_protox
index|[
literal|256
index|]
decl_stmt|;
name|int
name|esis_input
parameter_list|()
function_decl|;
name|int
name|snpac_age
parameter_list|()
function_decl|;
name|int
name|esis_config
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|ISO_X25ESIS
name|x25esis_input
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|ISO_X25ESIS
name|esis_pcb
operator|.
name|isop_next
operator|=
name|esis_pcb
operator|.
name|isop_prev
operator|=
operator|&
name|esis_pcb
expr_stmt|;
name|clnl_protox
index|[
name|ISO9542_ESIS
index|]
operator|.
name|clnl_input
operator|=
name|esis_input
expr_stmt|;
name|timeout
argument_list|(
name|snpac_age
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|esis_config
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISO_X25ESIS
name|clnl_protox
index|[
name|ISO9542X25_ESIS
index|]
operator|.
name|clnl_input
operator|=
name|x25esis_input
expr_stmt|;
endif|#
directive|endif
endif|ISO_X25ESIS
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_usrreq  *  * PURPOSE:			Handle user level esis requests  *  * RETURNS:			0 or appropriate errno  *  * SIDE EFFECTS:	  *  * NOTES:			This is here only so esis gets initialized.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|esis_usrreq
argument_list|(
argument|so
argument_list|,
argument|req
argument_list|,
argument|m
argument_list|,
argument|nam
argument_list|,
argument|rights
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket: used only to get to this code */
end_comment

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* request */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data for request */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* optional name */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|rights
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* optional rights */
end_comment

begin_block
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_input  *  * PURPOSE:			Process an incoming esis packet  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|esis_input
argument_list|(
argument|m0
argument_list|,
argument|shp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to first mbuf of pkt */
end_comment

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subnetwork header */
end_comment

begin_block
block|{
name|struct
name|esis_fixed
modifier|*
name|pdu
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|esis_fixed
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ESISINPUT
argument_list|)
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"esis_input: pdu on ifp x%x (%s%d): from:"
argument_list|,
name|shp
operator|->
name|snh_ifp
argument_list|,
name|shp
operator|->
name|snh_ifp
operator|->
name|if_name
argument_list|,
name|shp
operator|->
name|snh_ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
name|shp
operator|->
name|snh_shost
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|,
operator|(
name|i
operator|<
literal|5
operator|)
condition|?
literal|':'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" to:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
name|shp
operator|->
name|snh_dhost
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|,
operator|(
name|i
operator|<
literal|5
operator|)
condition|?
literal|':'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	check checksum if necessary 	 */
if|if
condition|(
name|ESIS_CKSUM_REQUIRED
argument_list|(
name|pdu
argument_list|)
operator|&&
name|iso_check_csum
argument_list|(
name|m0
argument_list|,
operator|(
name|int
operator|)
name|pdu
operator|->
name|esis_hdr_len
argument_list|)
condition|)
block|{
name|esis_stat
operator|.
name|es_badcsum
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* check version */
if|if
condition|(
name|pdu
operator|->
name|esis_vers
operator|!=
name|ESIS_VERSION
condition|)
block|{
name|esis_stat
operator|.
name|es_badvers
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|type
operator|=
name|pdu
operator|->
name|esis_type
operator|&
literal|0x1f
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ESIS_ESH
case|:
name|esis_eshinput
argument_list|(
name|m0
argument_list|,
name|shp
argument_list|)
expr_stmt|;
return|return;
case|case
name|ESIS_ISH
case|:
name|esis_ishinput
argument_list|(
name|m0
argument_list|,
name|shp
argument_list|)
expr_stmt|;
return|return;
case|case
name|ESIS_RD
case|:
name|esis_rdinput
argument_list|(
name|m0
argument_list|,
name|shp
argument_list|)
expr_stmt|;
return|return;
default|default:
block|{
name|esis_stat
operator|.
name|es_badtype
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|bad
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_rdoutput  *  * PURPOSE:			Transmit a redirect pdu  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			Assumes there is enough space for fixed part of header,  *					DA, BSNPA and NET in first mbuf.  */
end_comment

begin_macro
name|esis_rdoutput
argument_list|(
argument|inbound_shp
argument_list|,
argument|inbound_m
argument_list|,
argument|inbound_oidx
argument_list|,
argument|rd_dstnsap
argument_list|,
argument|nhop_sc
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|inbound_shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* snpa hdr from incoming packet */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|inbound_m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* incoming pkt itself */
end_comment

begin_decl_stmt
name|struct
name|clnp_optidx
modifier|*
name|inbound_oidx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clnp options assoc with incoming pkt */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|rd_dstnsap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ultimate destination of pkt */
end_comment

begin_decl_stmt
name|struct
name|snpa_cache
modifier|*
name|nhop_sc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* snpa cache info regarding next hop of 										pkt */
end_comment

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|struct
name|esis_fixed
modifier|*
name|pdu
decl_stmt|;
name|int
name|len
decl_stmt|,
name|total_len
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_iso
name|siso
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|inbound_shp
operator|->
name|snh_ifp
decl_stmt|;
name|esis_stat
operator|.
name|es_rdsent
operator|++
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ESISOUTPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_rdoutput: ifp x%x (%s%d), ht %d, m x%x, oidx x%x\n"
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|esis_holding_time
argument_list|,
name|inbound_m
argument_list|,
name|inbound_oidx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tdestination: %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|rd_dstnsap
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tredirected toward:%s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|nhop_sc
operator|->
name|sc_nsap
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|m0
operator|=
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|esis_stat
operator|.
name|es_nomem
operator|++
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MHLEN
argument_list|)
expr_stmt|;
name|pdu
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|esis_fixed
operator|*
argument_list|)
expr_stmt|;
name|cp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|pdu
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*pointer arith.; 1st byte after header */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|esis_fixed
argument_list|)
expr_stmt|;
comment|/* 	 *	Build fixed part of header 	 */
name|pdu
operator|->
name|esis_proto_id
operator|=
name|ISO9542_ESIS
expr_stmt|;
name|pdu
operator|->
name|esis_vers
operator|=
name|ESIS_VERSION
expr_stmt|;
name|pdu
operator|->
name|esis_type
operator|=
name|ESIS_RD
expr_stmt|;
name|HTOC
argument_list|(
name|pdu
operator|->
name|esis_ht_msb
argument_list|,
name|pdu
operator|->
name|esis_ht_lsb
argument_list|,
name|esis_holding_time
argument_list|)
expr_stmt|;
comment|/* Insert destination address */
operator|(
name|void
operator|)
name|esis_insert_addr
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|len
argument_list|,
name|rd_dstnsap
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Insert the snpa of better next hop */
operator|*
name|cp
operator|++
operator|=
name|nhop_sc
operator|->
name|sc_len
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|nhop_sc
operator|->
name|sc_snpa
argument_list|,
name|cp
argument_list|,
name|nhop_sc
operator|->
name|sc_len
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
name|nhop_sc
operator|->
name|sc_len
operator|+
literal|1
operator|)
expr_stmt|;
comment|/*  	 *	If the next hop is not the destination, then it ought to be 	 *	an IS and it should be inserted next. Else, set the 	 *	NETL to 0 	 */
comment|/* PHASE2 use mask from ifp of outgoing interface */
if|if
condition|(
operator|!
name|iso_addrmatch1
argument_list|(
name|rd_dstnsap
argument_list|,
operator|&
name|nhop_sc
operator|->
name|sc_nsap
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|nhop_sc
operator|->
name|sc_flags
operator|&
name|SNPA_IS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* this should not happen */
name|printf
argument_list|(
literal|"esis_rdoutput: next hop is not dst and not an IS\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|esis_insert_addr
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|nhop_sc
operator|->
name|sc_nsap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NETL */
name|len
operator|++
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* 	 *	PHASE2 	 *	If redirect is to an IS, add an address mask. The mask to be 	 *	used should be the mask present in the routing entry used to 	 *	forward the original data packet. 	 */
comment|/* 	 *	Copy Qos, priority, or security options present in original npdu 	 */
if|if
condition|(
name|inbound_oidx
condition|)
block|{
comment|/* THIS CODE IS CURRENTLY UNTESTED */
name|int
name|optlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inbound_oidx
operator|->
name|cni_qos_formatp
condition|)
name|optlen
operator|+=
operator|(
name|inbound_oidx
operator|->
name|cni_qos_len
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|inbound_oidx
operator|->
name|cni_priorp
condition|)
comment|/* priority option is 1 byte long */
name|optlen
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|inbound_oidx
operator|->
name|cni_securep
condition|)
name|optlen
operator|+=
operator|(
name|inbound_oidx
operator|->
name|cni_secure_len
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|<
name|optlen
condition|)
block|{
name|EXTEND_PACKET
argument_list|(
name|m
argument_list|,
name|m0
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
comment|/* assumes MLEN> optlen */
block|}
comment|/* assume MLEN-len> optlen */
comment|/*  		 *	When copying options, copy from ptr - 2 in order to grab 		 *	the option code and length 		 */
if|if
condition|(
name|inbound_oidx
operator|->
name|cni_qos_formatp
condition|)
block|{
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|inbound_m
operator|+
name|inbound_oidx
operator|->
name|cni_qos_formatp
operator|-
literal|2
argument_list|)
argument_list|,
name|cp
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|inbound_oidx
operator|->
name|cni_qos_len
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
name|inbound_oidx
operator|->
name|cni_qos_len
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|inbound_oidx
operator|->
name|cni_priorp
condition|)
block|{
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|inbound_m
operator|+
name|inbound_oidx
operator|->
name|cni_priorp
operator|-
literal|2
argument_list|)
argument_list|,
name|cp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|inbound_oidx
operator|->
name|cni_securep
condition|)
block|{
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|inbound_m
operator|+
name|inbound_oidx
operator|->
name|cni_securep
operator|-
literal|2
argument_list|)
argument_list|,
name|cp
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|inbound_oidx
operator|->
name|cni_secure_len
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
name|inbound_oidx
operator|->
name|cni_secure_len
operator|+
literal|2
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|+=
name|optlen
expr_stmt|;
block|}
name|pdu
operator|->
name|esis_hdr_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|iso_gen_csum
argument_list|(
name|m0
argument_list|,
name|ESIS_CKSUM_OFF
argument_list|,
operator|(
name|int
operator|)
name|pdu
operator|->
name|esis_hdr_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|siso
argument_list|,
sizeof|sizeof
argument_list|(
name|siso
argument_list|)
argument_list|)
expr_stmt|;
name|siso
operator|.
name|siso_len
operator|=
literal|12
expr_stmt|;
name|siso
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|siso
operator|.
name|siso_data
index|[
literal|0
index|]
operator|=
name|AFI_SNA
expr_stmt|;
name|siso
operator|.
name|siso_nlen
operator|=
literal|6
operator|+
literal|1
expr_stmt|;
comment|/* should be taken from snpa_hdr */
comment|/* +1 is for AFI */
name|bcopy
argument_list|(
name|inbound_shp
operator|->
name|snh_shost
argument_list|,
name|siso
operator|.
name|siso_data
operator|+
literal|1
argument_list|,
literal|6
argument_list|)
expr_stmt|;
call|(
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|,
operator|&
name|siso
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_insert_addr  *  * PURPOSE:			Insert an iso_addr into a buffer  *  * RETURNS:			true if buffer was big enough, else false  *  * SIDE EFFECTS:	Increment buf& len according to size of iso_addr  *  * NOTES:			Plus 1 here is for length byte  */
end_comment

begin_macro
name|esis_insert_addr
argument_list|(
argument|buf
argument_list|,
argument|len
argument_list|,
argument|isoa
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to buffer to put address into */
end_comment

begin_decl_stmt
name|int
modifier|*
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to length of buffer so far */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to address */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* determine if there remains space */
end_comment

begin_block
block|{
specifier|register
name|int
name|newlen
init|=
name|isoa
operator|->
name|isoa_len
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newlen
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|isoa
argument_list|,
operator|*
name|buf
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
operator|*
name|len
operator|+=
name|newlen
expr_stmt|;
operator|*
name|buf
operator|+=
name|newlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|newlen
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|ESIS_EXTRACT_ADDR
parameter_list|(
name|d
parameter_list|,
name|b
parameter_list|)
value|{ d = (struct iso_addr *)(b); b += (1 + *b); \ 	    if (b> buflim) {esis_stat.es_toosmall++; goto bad;}}
end_define

begin_define
define|#
directive|define
name|ESIS_NEXT_OPTION
parameter_list|(
name|b
parameter_list|)
value|{ b += (2 + b[1]); \ 	    if (b> buflim) {esis_stat.es_toosmall++; goto bad;}}
end_define

begin_decl_stmt
name|int
name|ESHonly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   /*  * FUNCTION:		esis_eshinput  *  * PURPOSE:			Process an incoming ESH pdu  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|esis_eshinput
argument_list|(
argument|m
argument_list|,
argument|shp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* esh pdu */
end_comment

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subnetwork header */
end_comment

begin_block
block|{
name|struct
name|esis_fixed
modifier|*
name|pdu
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|esis_fixed
operator|*
argument_list|)
decl_stmt|;
name|u_short
name|ht
decl_stmt|;
comment|/* holding time */
name|struct
name|iso_addr
modifier|*
name|nsap
decl_stmt|;
name|int
name|naddr
decl_stmt|;
name|u_char
modifier|*
name|buf
init|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|pdu
operator|+
literal|1
operator|)
decl_stmt|;
name|u_char
modifier|*
name|buflim
init|=
name|pdu
operator|->
name|esis_hdr_len
operator|+
operator|(
name|u_char
operator|*
operator|)
name|pdu
decl_stmt|;
name|int
name|new_entry
decl_stmt|;
name|esis_stat
operator|.
name|es_eshrcvd
operator|++
expr_stmt|;
name|CTOH
argument_list|(
name|pdu
operator|->
name|esis_ht_msb
argument_list|,
name|pdu
operator|->
name|esis_ht_lsb
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|naddr
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
if|if
condition|(
name|buf
operator|>=
name|buflim
condition|)
goto|goto
name|bad
goto|;
name|IFDEBUG
argument_list|(
argument|D_ESISINPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_eshinput: esh: ht %d, naddr %d\n"
argument_list|,
name|ht
argument_list|,
name|naddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
while|while
condition|(
name|naddr
operator|--
operator|>
literal|0
condition|)
block|{
name|ESIS_EXTRACT_ADDR
argument_list|(
name|nsap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|new_entry
operator|=
operator|(
name|snpac_look
argument_list|(
name|nsap
argument_list|)
operator|==
name|NULL
operator|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ESISINPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_eshinput: nsap %s is %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|nsap
argument_list|)
argument_list|,
name|new_entry
condition|?
literal|"new"
else|:
literal|"old"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|snpac_add
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|nsap
argument_list|,
name|shp
operator|->
name|snh_shost
argument_list|,
literal|6
argument_list|,
name|SNPA_ES
argument_list|,
name|ht
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_entry
condition|)
name|esis_shoutput
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|iso_systype
operator|&
name|SNPA_ES
condition|?
name|ESIS_ESH
else|:
name|ESIS_ISH
argument_list|,
name|esis_holding_time
argument_list|,
name|shp
operator|->
name|snh_shost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_ishinput  *  * PURPOSE:			process an incoming ISH pdu  *  * RETURNS:			  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|esis_ishinput
argument_list|(
argument|m
argument_list|,
argument|shp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* esh pdu */
end_comment

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subnetwork header */
end_comment

begin_block
block|{
name|struct
name|esis_fixed
modifier|*
name|pdu
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|esis_fixed
operator|*
argument_list|)
decl_stmt|;
name|u_short
name|ht
decl_stmt|;
comment|/* holding time */
name|struct
name|iso_addr
modifier|*
name|nsap
decl_stmt|;
comment|/* Network Entity Title */
specifier|register
name|u_char
modifier|*
name|buf
init|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|pdu
operator|+
literal|1
operator|)
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|buflim
init|=
name|pdu
operator|->
name|esis_hdr_len
operator|+
operator|(
name|u_char
operator|*
operator|)
name|pdu
decl_stmt|;
name|int
name|new_entry
decl_stmt|;
name|esis_stat
operator|.
name|es_ishrcvd
operator|++
expr_stmt|;
name|CTOH
argument_list|(
name|pdu
operator|->
name|esis_ht_msb
argument_list|,
name|pdu
operator|->
name|esis_ht_lsb
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ESISINPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_ishinput: ish: ht %d\n"
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|ESHonly
condition|)
goto|goto
name|bad
goto|;
name|ESIS_EXTRACT_ADDR
argument_list|(
name|nsap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|buflim
condition|)
block|{
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
name|ESISOVAL_ESCT
case|:
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|2
condition|)
goto|goto
name|bad
goto|;
name|CTOH
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|,
name|esis_config_time
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown ISH option: %x\n"
argument_list|,
operator|*
name|buf
argument_list|)
expr_stmt|;
block|}
name|ESIS_NEXT_OPTION
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|new_entry
operator|=
operator|(
name|snpac_look
argument_list|(
name|nsap
argument_list|)
operator|==
name|NULL
operator|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ESISINPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_ishinput: nsap %s is %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|nsap
argument_list|)
argument_list|,
name|new_entry
condition|?
literal|"new"
else|:
literal|"old"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|snpac_add
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|nsap
argument_list|,
name|shp
operator|->
name|snh_shost
argument_list|,
literal|6
argument_list|,
name|SNPA_IS
argument_list|,
name|ht
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_entry
condition|)
name|esis_shoutput
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|iso_systype
operator|&
name|SNPA_ES
condition|?
name|ESIS_ESH
else|:
name|ESIS_ISH
argument_list|,
name|esis_holding_time
argument_list|,
name|shp
operator|->
name|snh_shost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_rdinput  *  * PURPOSE:			Process an incoming RD pdu  *  * RETURNS:			  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|esis_rdinput
argument_list|(
argument|m0
argument_list|,
argument|shp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* esh pdu */
end_comment

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subnetwork header */
end_comment

begin_block
block|{
name|struct
name|esis_fixed
modifier|*
name|pdu
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|esis_fixed
operator|*
argument_list|)
decl_stmt|;
name|u_short
name|ht
decl_stmt|;
comment|/* holding time */
name|struct
name|iso_addr
modifier|*
name|da
decl_stmt|,
modifier|*
name|net
init|=
literal|0
decl_stmt|,
modifier|*
name|netmask
init|=
literal|0
decl_stmt|,
modifier|*
name|snpamask
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|iso_addr
modifier|*
name|bsnpa
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|buf
init|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|pdu
operator|+
literal|1
operator|)
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|buflim
init|=
name|pdu
operator|->
name|esis_hdr_len
operator|+
operator|(
name|u_char
operator|*
operator|)
name|pdu
decl_stmt|;
name|esis_stat
operator|.
name|es_rdrcvd
operator|++
expr_stmt|;
comment|/* intermediate systems ignore redirects */
if|if
condition|(
name|iso_systype
operator|&
name|SNPA_IS
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|ESHonly
condition|)
goto|goto
name|bad
goto|;
name|CTOH
argument_list|(
name|pdu
operator|->
name|esis_ht_msb
argument_list|,
name|pdu
operator|->
name|esis_ht_lsb
argument_list|,
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|>=
name|buflim
condition|)
goto|goto
name|bad
goto|;
comment|/* Extract DA */
name|ESIS_EXTRACT_ADDR
argument_list|(
name|da
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Extract better snpa */
name|ESIS_EXTRACT_ADDR
argument_list|(
name|bsnpa
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Extract NET if present */
if|if
condition|(
name|buf
operator|<
name|buflim
condition|)
block|{
name|ESIS_EXTRACT_ADDR
argument_list|(
name|net
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* process options */
while|while
condition|(
name|buf
operator|<
name|buflim
condition|)
block|{
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
name|ESISOVAL_SNPAMASK
case|:
if|if
condition|(
name|snpamask
condition|)
comment|/* duplicate */
goto|goto
name|bad
goto|;
name|snpamask
operator|=
operator|(
expr|struct
name|iso_addr
operator|*
operator|)
operator|(
name|buf
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|ESISOVAL_NETMASK
case|:
if|if
condition|(
name|netmask
condition|)
comment|/* duplicate */
goto|goto
name|bad
goto|;
name|netmask
operator|=
operator|(
expr|struct
name|iso_addr
operator|*
operator|)
operator|(
name|buf
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown option in ESIS RD (0x%x)\n"
argument_list|,
name|buf
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|ESIS_NEXT_OPTION
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ESISINPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_rdinput: rd: ht %d, da %s\n"
argument_list|,
name|ht
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|da
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
condition|)
name|printf
argument_list|(
literal|"\t: net %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|net
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	If netl is zero, then redirect is to an ES. We need to add an entry 	 *	to the snpa cache for (destination, better snpa). 	 *	If netl is not zero, then the redirect is to an IS. In this 	 *	case, add an snpa cache entry for (net, better snpa). 	 * 	 *	If the redirect is to an IS, add a route entry towards that 	 *	IS. 	 */
if|if
condition|(
name|net
operator|==
literal|0
operator|||
name|net
operator|->
name|isoa_len
operator|==
literal|0
operator|||
name|snpamask
condition|)
block|{
comment|/* redirect to an ES */
name|snpac_add
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|da
argument_list|,
name|bsnpa
operator|->
name|isoa_genaddr
argument_list|,
name|bsnpa
operator|->
name|isoa_len
argument_list|,
name|SNPA_ES
argument_list|,
name|ht
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snpac_add
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|net
argument_list|,
name|bsnpa
operator|->
name|isoa_genaddr
argument_list|,
name|bsnpa
operator|->
name|isoa_len
argument_list|,
name|SNPA_IS
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|snpac_addrt
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|da
argument_list|,
name|net
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
block|}
name|bad
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_config  *  * PURPOSE:			Report configuration  *  * RETURNS:			  *  * SIDE EFFECTS:	  *  * NOTES:			Called every esis_config_time seconds  */
end_comment

begin_macro
name|esis_config
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|timeout
argument_list|(
name|esis_config
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
operator|*
name|esis_config_time
argument_list|)
expr_stmt|;
comment|/*  	 *	Report configuration for each interface that  	 *	- is UP 	 *	- is not loopback 	 *	- has broadcast capabilities 	 *	- has an ISO address 	 */
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|if_next
control|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* search for an ISO address family */
name|struct
name|ifaddr
modifier|*
name|ia
decl_stmt|;
for|for
control|(
name|ia
operator|=
name|ifp
operator|->
name|if_addrlist
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
name|ia
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_ISO
condition|)
block|{
name|esis_shoutput
argument_list|(
name|ifp
argument_list|,
name|iso_systype
operator|&
name|SNPA_ES
condition|?
name|ESIS_ESH
else|:
name|ESIS_ISH
argument_list|,
name|esis_holding_time
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|iso_systype
operator|&
name|SNPA_ES
condition|?
name|all_is
operator|.
name|sc_snpa
else|:
name|all_es
operator|.
name|sc_snpa
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_shoutput  *  * PURPOSE:			Transmit an esh or ish pdu  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|esis_shoutput
argument_list|(
argument|ifp
argument_list|,
argument|type
argument_list|,
argument|ht
argument_list|,
argument|sn_addr
argument_list|,
argument|sn_len
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ht
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|sn_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sn_len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|,
name|naddrp
decl_stmt|;
name|int
name|naddr
init|=
literal|0
decl_stmt|;
name|struct
name|esis_fixed
modifier|*
name|pdu
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|sockaddr_iso
name|siso
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|ESIS_ESH
condition|)
name|esis_stat
operator|.
name|es_eshsent
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|ESIS_ISH
condition|)
name|esis_stat
operator|.
name|es_ishsent
operator|++
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"esis_shoutput: bad pdu type\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|IFDEBUG
argument_list|(
argument|D_ESISOUTPUT
argument_list|)
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"esis_shoutput: ifp x%x (%s%d), %s, ht %d, to: [%d] "
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|type
operator|==
name|ESIS_ESH
condition|?
literal|"esh"
else|:
literal|"ish"
argument_list|,
name|ht
argument_list|,
name|sn_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sn_len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
operator|*
operator|(
name|sn_addr
operator|+
name|i
operator|)
argument_list|,
name|i
operator|<
operator|(
name|sn_len
operator|-
literal|1
operator|)
condition|?
literal|':'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|m0
operator|=
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|esis_stat
operator|.
name|es_nomem
operator|++
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MHLEN
argument_list|)
expr_stmt|;
name|pdu
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|esis_fixed
operator|*
argument_list|)
expr_stmt|;
name|naddrp
operator|=
name|cp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|pdu
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|esis_fixed
argument_list|)
expr_stmt|;
comment|/* 	 *	Build fixed part of header 	 */
name|pdu
operator|->
name|esis_proto_id
operator|=
name|ISO9542_ESIS
expr_stmt|;
name|pdu
operator|->
name|esis_vers
operator|=
name|ESIS_VERSION
expr_stmt|;
name|pdu
operator|->
name|esis_type
operator|=
name|type
expr_stmt|;
name|HTOC
argument_list|(
name|pdu
operator|->
name|esis_ht_msb
argument_list|,
name|pdu
operator|->
name|esis_ht_lsb
argument_list|,
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ESIS_ESH
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
for|for
control|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_ISO
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ESISOUTPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_shoutput: adding nsap %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|IA_SIS
argument_list|(
name|ifa
argument_list|)
operator|->
name|siso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|!
name|esis_insert_addr
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|IA_SIS
argument_list|(
name|ifa
argument_list|)
operator|->
name|siso_addr
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|EXTEND_PACKET
argument_list|(
name|m
argument_list|,
name|m0
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|esis_insert_addr
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|IA_SIS
argument_list|(
name|ifa
argument_list|)
operator|->
name|siso_addr
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|naddr
operator|++
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ESIS_ISH
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|ESIS_ESH
condition|)
operator|*
name|naddrp
operator|=
name|naddr
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|pdu
operator|->
name|esis_hdr_len
operator|=
name|len
expr_stmt|;
name|iso_gen_csum
argument_list|(
name|m0
argument_list|,
name|ESIS_CKSUM_OFF
argument_list|,
operator|(
name|int
operator|)
name|pdu
operator|->
name|esis_hdr_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|siso
argument_list|,
sizeof|sizeof
argument_list|(
name|siso
argument_list|)
argument_list|)
expr_stmt|;
name|siso
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|siso
operator|.
name|siso_data
index|[
literal|0
index|]
operator|=
name|AFI_SNA
expr_stmt|;
name|siso
operator|.
name|siso_nlen
operator|=
name|sn_len
operator|+
literal|1
expr_stmt|;
name|siso
operator|.
name|siso_len
operator|=
name|sn_len
operator|+
literal|6
expr_stmt|;
name|bcopy
argument_list|(
name|sn_addr
argument_list|,
name|siso
operator|.
name|siso_data
operator|+
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|sn_len
argument_list|)
expr_stmt|;
call|(
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|,
operator|&
name|siso
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_ctlinput  *  * PURPOSE:			Handle the PRC_IFDOWN transition  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			Calls snpac_flush for interface specified.  *					The loop through iso_ifaddr is stupid because  *					back in if_down, we knew the ifp...  */
end_comment

begin_macro
name|esis_ctlinput
argument_list|(
argument|req
argument_list|,
argument|siso
argument_list|)
end_macro

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* request: we handle only PRC_IFDOWN */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address of ifp */
end_comment

begin_block
block|{
specifier|register
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
comment|/* scan through interface addresses */
if|if
condition|(
name|req
operator|==
name|PRC_IFDOWN
condition|)
for|for
control|(
name|ia
operator|=
name|iso_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
if|if
condition|(
name|iso_addrmatch
argument_list|(
name|IA_SIS
argument_list|(
name|ia
argument_list|)
argument_list|,
name|siso
argument_list|)
condition|)
name|snpac_flushifp
argument_list|(
name|ia
operator|->
name|ia_ifp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|ISO
end_endif

end_unit

