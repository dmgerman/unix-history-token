begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)if_eon.c	8.1 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * $Header: if_eon.c,v 1.4 88/07/19 15:53:59 hagens Exp $   * $Source: /usr/argo/sys/netiso/RCS/if_eon.c,v $   *  *	EON rfc   *  Layer between IP and CLNL  *  * TODO:  * Put together a current rfc986 address format and get the right offset  * for the nsel  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EON
end_ifdef

begin_define
define|#
directive|define
name|NEON
value|1
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<machine/mtpr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_var.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_snpac.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_errno.h>
end_include

begin_include
include|#
directive|include
file|<netiso/eonvar.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|timeval
name|time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
name|loif
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EOK
value|0
end_define

begin_function_decl
name|int
name|eoninput
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|eonoutput
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|eonioctl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|eonattach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|eoninit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|eonrtrequest
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|ifnet
name|eonif
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|eonprotoinit
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|eonattach
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|struct
name|eon_llinfo
name|eon_llinfo
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PROBE_OK
value|0;
end_define

begin_comment
comment|/*  * FUNCTION:		eonattach  *  * PURPOSE:			autoconf attach routine  *  * RETURNS:			void  */
end_comment

begin_macro
name|eonattach
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|eonif
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EON
argument_list|)
name|printf
argument_list|(
literal|"eonattach()\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|ifp
operator|->
name|if_unit
init|=
literal|0
decl_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"eon"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
comment|/* since everything will go out over ether or token ring */
name|ifp
operator|->
name|if_init
operator|=
name|eoninit
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|eonioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|eonoutput
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_EON
expr_stmt|;
name|ifp
operator|->
name|if_addrlen
operator|=
literal|5
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
name|EONIPLEN
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|eonioctl
argument_list|(
name|ifp
argument_list|,
name|SIOCSIFADDR
argument_list|,
operator|(
name|caddr_t
operator|)
name|ifp
operator|->
name|if_addrlist
argument_list|)
expr_stmt|;
name|eon_llinfo
operator|.
name|el_qhdr
operator|.
name|link
operator|=
name|eon_llinfo
operator|.
name|el_qhdr
operator|.
name|rlink
operator|=
operator|&
operator|(
name|eon_llinfo
operator|.
name|el_qhdr
operator|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EON
argument_list|)
name|printf
argument_list|(
literal|"eonattach()\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		eonioctl  *  * PURPOSE:			io controls - ifconfig  *				need commands to   *					link-UP (core addr) (flags: ES, IS)  *					link-DOWN (core addr) (flags: ES, IS)  *				must be callable from kernel or user  *  * RETURNS:			nothing  */
end_comment

begin_expr_stmt
name|eonioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
specifier|register
name|int
name|error
init|=
literal|0
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EON
argument_list|)
name|printf
argument_list|(
literal|"eonioctl (cmd 0x%x) \n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ENDDEBUG
switch|switch
condition|(
name|cmd
condition|)
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
name|ifa
operator|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
name|ifa
operator|->
name|ifa_rtrequest
operator|=
name|eonrtrequest
expr_stmt|;
block|}
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|eoniphdr
argument_list|(
argument|hdr
argument_list|,
argument|loc
argument_list|,
argument|ro
argument_list|,
argument|class
argument_list|,
argument|zero
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|eon_iphdr
modifier|*
name|hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mbuf
name|mhead
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
decl_stmt|;
if|if
condition|(
name|zero
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ro
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ro
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|loc
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If there is a cached route, 	 * check that it is to the same destination 	 * and is still up.  If not, free it and try again. 	 */
if|if
condition|(
name|ro
operator|->
name|ro_rt
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|dst
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|rt_key
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
operator|||
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
name|dst
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
name|rtalloc
argument_list|(
name|ro
argument_list|)
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
condition|)
name|ro
operator|->
name|ro_rt
operator|->
name|rt_use
operator|++
expr_stmt|;
name|hdr
operator|->
name|ei_ip
operator|.
name|ip_dst
operator|=
name|sin
operator|->
name|sin_addr
expr_stmt|;
name|hdr
operator|->
name|ei_ip
operator|.
name|ip_p
operator|=
name|IPPROTO_EON
expr_stmt|;
name|hdr
operator|->
name|ei_ip
operator|.
name|ip_ttl
operator|=
name|MAXTTL
expr_stmt|;
name|hdr
operator|->
name|ei_eh
operator|.
name|eonh_class
operator|=
name|class
expr_stmt|;
name|hdr
operator|->
name|ei_eh
operator|.
name|eonh_vers
operator|=
name|EON_VERSION
expr_stmt|;
name|hdr
operator|->
name|ei_eh
operator|.
name|eonh_csum
operator|=
literal|0
expr_stmt|;
name|mhead
operator|.
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|hdr
operator|->
name|ei_eh
expr_stmt|;
name|mhead
operator|.
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eon_hdr
argument_list|)
expr_stmt|;
name|mhead
operator|.
name|m_next
operator|=
literal|0
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EON
argument_list|)
name|printf
argument_list|(
literal|"eonoutput : gen csum (0x%x, offset %d, datalen %d)\n"
argument_list|,
operator|&
name|mhead
argument_list|,
name|_offsetof
argument_list|(
expr|struct
name|eon_hdr
argument_list|,
name|eonh_csum
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eon_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|iso_gen_csum
argument_list|(
operator|&
name|mhead
argument_list|,
name|_offsetof
argument_list|(
expr|struct
name|eon_hdr
argument_list|,
name|eonh_csum
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eon_hdr
argument_list|)
argument_list|)
decl_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		eonrtrequest  *  * PURPOSE:			maintains list of direct eon recipients.  *					sets up IP route for rest.  *  * RETURNS:			nothing  */
end_comment

begin_function
name|void
name|eonrtrequest
parameter_list|(
name|cmd
parameter_list|,
name|rt
parameter_list|,
name|gate
parameter_list|)
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
specifier|register
name|struct
name|sockaddr
modifier|*
name|gate
decl_stmt|;
block|{
name|unsigned
name|long
name|zerodst
init|=
literal|0
decl_stmt|;
name|caddr_t
name|ipaddrloc
init|=
operator|(
name|caddr_t
operator|)
operator|&
name|zerodst
decl_stmt|;
specifier|register
name|struct
name|eon_llinfo
modifier|*
name|el
init|=
operator|(
expr|struct
name|eon_llinfo
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
decl_stmt|;
comment|/* 	 * Common Housekeeping 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RTM_DELETE
case|:
if|if
condition|(
name|el
condition|)
block|{
name|remque
argument_list|(
operator|&
operator|(
name|el
operator|->
name|el_qhdr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_iproute
operator|.
name|ro_rt
condition|)
name|RTFREE
argument_list|(
name|el
operator|->
name|el_iproute
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
literal|0
expr_stmt|;
block|}
return|return;
case|case
name|RTM_ADD
case|:
case|case
name|RTM_RESOLVE
case|:
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|=
name|loif
operator|.
name|if_mtu
expr_stmt|;
comment|/* unless better below */
name|R_Malloc
argument_list|(
name|el
argument_list|,
expr|struct
name|eon_llinfo
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|el
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
operator|(
name|caddr_t
operator|)
name|el
expr_stmt|;
if|if
condition|(
name|el
operator|==
literal|0
condition|)
return|return;
name|Bzero
argument_list|(
name|el
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|el
argument_list|)
argument_list|)
expr_stmt|;
name|insque
argument_list|(
operator|&
operator|(
name|el
operator|->
name|el_qhdr
operator|)
argument_list|,
operator|&
name|eon_llinfo
operator|.
name|el_qhdr
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_rt
operator|=
name|rt
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gate
operator|||
operator|(
name|gate
operator|=
name|rt
operator|->
name|rt_gateway
operator|)
condition|)
switch|switch
condition|(
name|gate
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_LINK
case|:
define|#
directive|define
name|SDL
parameter_list|(
name|x
parameter_list|)
value|((struct sockaddr_dl *)x)
if|if
condition|(
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_alen
operator|==
literal|1
condition|)
name|el
operator|->
name|el_snpaoffset
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|LLADDR
argument_list|(
name|SDL
argument_list|(
name|gate
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ipaddrloc
operator|=
name|LLADDR
argument_list|(
name|SDL
argument_list|(
name|gate
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET
case|:
define|#
directive|define
name|SIN
parameter_list|(
name|x
parameter_list|)
value|((struct sockaddr_in *)x)
name|ipaddrloc
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|SIN
argument_list|(
name|gate
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|el
operator|->
name|el_flags
operator||=
name|RTF_UP
expr_stmt|;
name|eoniphdr
argument_list|(
operator|&
name|el
operator|->
name|el_ei
argument_list|,
name|ipaddrloc
argument_list|,
operator|&
name|el
operator|->
name|el_iproute
argument_list|,
name|EON_NORMAL_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_iproute
operator|.
name|ro_rt
condition|)
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|=
name|el
operator|->
name|el_iproute
operator|.
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|-
sizeof|sizeof
argument_list|(
name|el
operator|->
name|el_ei
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		eoninit  *  * PURPOSE:			initialization  *  * RETURNS:			nothing  */
end_comment

begin_macro
name|eoninit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"eon driver-init eon%d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		eonoutput  *  * PURPOSE:			prepend an eon header and hand to IP  * ARGUMENTS:	 	(ifp) is points to the ifnet structure for this unit/device  *					(m)  is an mbuf *, *m is a CLNL packet  *					(dst) is a destination address - have to interp. as  *					multicast or broadcast or real address.  *  * RETURNS:			unix error code  *  * NOTES:			  *  */
end_comment

begin_macro
name|eonoutput
argument_list|(
argument|ifp
argument_list|,
argument|m
argument_list|,
argument|dst
argument_list|,
argument|rt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packet */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* destination addr */
end_comment

begin_decl_stmt
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|eon_llinfo
modifier|*
name|el
decl_stmt|;
specifier|register
name|struct
name|eon_iphdr
modifier|*
name|ei
decl_stmt|;
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mh
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|class
init|=
literal|0
decl_stmt|,
name|alen
init|=
literal|0
decl_stmt|;
name|caddr_t
name|ipaddrloc
decl_stmt|;
specifier|static
name|struct
name|eon_iphdr
name|eon_iphdr
decl_stmt|;
specifier|static
name|struct
name|route
name|route
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EON
argument_list|)
name|printf
argument_list|(
literal|"eonoutput \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|ifp
operator|->
name|if_lastchange
init|=
name|time
decl_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|rt
operator|==
literal|0
operator|||
operator|(
name|el
operator|=
operator|(
expr|struct
name|eon_llinfo
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dst
operator|->
name|siso_family
operator|==
name|AF_LINK
condition|)
block|{
specifier|register
name|struct
name|sockaddr_dl
modifier|*
name|sdl
init|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|dst
decl_stmt|;
name|ipaddrloc
operator|=
name|LLADDR
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|alen
operator|=
name|sdl
operator|->
name|sdl_alen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|->
name|siso_family
operator|==
name|AF_ISO
operator|&&
name|dst
operator|->
name|siso_data
index|[
literal|0
index|]
operator|==
name|AFI_SNA
condition|)
block|{
name|alen
operator|=
name|dst
operator|->
name|siso_nlen
operator|-
literal|1
expr_stmt|;
name|ipaddrloc
operator|=
operator|(
name|caddr_t
operator|)
name|dst
operator|->
name|siso_data
operator|+
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|alen
condition|)
block|{
case|case
literal|5
case|:
name|class
operator|=
literal|4
index|[
operator|(
name|u_char
operator|*
operator|)
name|ipaddrloc
index|]
expr_stmt|;
case|case
literal|4
case|:
name|ro
operator|=
operator|&
name|route
expr_stmt|;
name|ei
operator|=
operator|&
name|eon_iphdr
expr_stmt|;
name|eoniphdr
argument_list|(
name|ei
argument_list|,
name|ipaddrloc
argument_list|,
name|ro
argument_list|,
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|send
goto|;
block|}
name|einval
label|:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
if|if
condition|(
operator|(
name|el
operator|->
name|el_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|eonrtrequest
argument_list|(
name|RTM_CHANGE
argument_list|,
name|rt
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|el
operator|->
name|el_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"eon: got non headered packet\n"
argument_list|)
expr_stmt|;
goto|goto
name|einval
goto|;
block|}
name|ei
operator|=
operator|&
name|el
operator|->
name|el_ei
expr_stmt|;
name|ro
operator|=
operator|&
name|el
operator|->
name|el_iproute
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_snpaoffset
condition|)
block|{
if|if
condition|(
name|dst
operator|->
name|siso_family
operator|==
name|AF_ISO
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dst
operator|->
name|siso_data
index|[
name|el
operator|->
name|el_snpaoffset
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ei
operator|->
name|ei_ip
operator|.
name|ip_dst
argument_list|,
sizeof|sizeof
argument_list|(
name|ei
operator|->
name|ei_ip
operator|.
name|ip_dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|einval
goto|;
block|}
name|send
label|:
comment|/* put an eon_hdr in the buffer, prepended by an ip header */
name|datalen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|EONIPLEN
expr_stmt|;
name|MGETHDR
argument_list|(
name|mh
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
goto|goto
name|flush
goto|;
name|mh
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|mh
expr_stmt|;
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eon_iphdr
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eon_iphdr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|+=
operator|(
name|ei
operator|->
name|ei_ip
operator|.
name|ip_len
operator|=
call|(
name|u_short
call|)
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|datalen
argument_list|)
operator|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|eon_iphdr
operator|*
argument_list|)
operator|=
operator|*
name|ei
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EON
argument_list|)
name|printf
argument_list|(
literal|"eonoutput dst ip addr : %x\n"
argument_list|,
name|ei
operator|->
name|ei_ip
operator|.
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"eonoutput ip_output : eonip header:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|ei
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eon_iphdr
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|error
init|=
name|ip_output
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
name|ro
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|--
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|-=
name|datalen
expr_stmt|;
block|}
name|flush
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_expr_stmt
name|eoninput
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|iphlen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|eon_hdr
modifier|*
name|eonhdr
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|iphdr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|eonifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|eonifp
operator|=
operator|&
name|eonif
index|[
literal|0
index|]
expr_stmt|;
comment|/* kludge - really want to give CLNP 						* the ifp for eon, not for the real device 						*/
name|IFDEBUG
argument_list|(
argument|D_EON
argument_list|)
name|printf
argument_list|(
literal|"eoninput() 0x%x m_data 0x%x m_len 0x%x dequeued\n"
argument_list|,
name|m
argument_list|,
name|m
condition|?
name|m
operator|->
name|m_data
else|:
literal|0
argument_list|,
name|m
condition|?
name|m
operator|->
name|m_len
else|:
literal|0
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|iphlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
name|ip_stripoptions
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|EONIPLEN
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|EONIPLEN
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|IncStat
argument_list|(
name|es_badhdr
argument_list|)
expr_stmt|;
name|drop
label|:
name|IFDEBUG
argument_list|(
argument|D_EON
argument_list|)
name|printf
argument_list|(
literal|"eoninput: DROP \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|eonifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|eonif
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|eonif
operator|->
name|if_lastchange
operator|=
name|time
expr_stmt|;
name|iphdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* do a few checks for debugging */
if|if
condition|(
name|iphdr
operator|->
name|ip_p
operator|!=
name|IPPROTO_EON
condition|)
block|{
name|IncStat
argument_list|(
name|es_badhdr
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* temporarily drop ip header from the mbuf */
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|eonhdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|eon_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso_check_csum
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eon_hdr
argument_list|)
argument_list|)
operator|!=
name|EOK
condition|)
block|{
name|IncStat
argument_list|(
name|es_badcsum
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|m
operator|->
name|m_data
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EON
argument_list|)
name|printf
argument_list|(
literal|"eoninput csum ok class 0x%x\n"
argument_list|,
name|eonhdr
operator|->
name|eonh_class
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"eoninput: eon header:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|eonhdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eon_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* checks for debugging */
if|if
condition|(
name|eonhdr
operator|->
name|eonh_vers
operator|!=
name|EON_VERSION
condition|)
block|{
name|IncStat
argument_list|(
name|es_badhdr
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|m
operator|->
name|m_flags
operator|&=
operator|~
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
expr_stmt|;
switch|switch
condition|(
name|eonhdr
operator|->
name|eonh_class
condition|)
block|{
case|case
name|EON_BROADCAST
case|:
name|IncStat
argument_list|(
name|es_in_broad
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_BCAST
expr_stmt|;
break|break;
case|case
name|EON_NORMAL_ADDR
case|:
name|IncStat
argument_list|(
name|es_in_normal
argument_list|)
expr_stmt|;
break|break;
case|case
name|EON_MULTICAST_ES
case|:
name|IncStat
argument_list|(
name|es_in_multi_es
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_MCAST
expr_stmt|;
break|break;
case|case
name|EON_MULTICAST_IS
case|:
name|IncStat
argument_list|(
name|es_in_multi_is
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_MCAST
expr_stmt|;
break|break;
block|}
name|eonifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|{
comment|/* put it on the CLNP queue and set soft interrupt */
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
specifier|extern
name|struct
name|ifqueue
name|clnlintrq
decl_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|eonifp
expr_stmt|;
comment|/* KLUDGE */
name|IFDEBUG
argument_list|(
argument|D_EON
argument_list|)
name|printf
argument_list|(
literal|"eoninput to clnl IFQ\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|ifq
init|=
operator|&
name|clnlintrq
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|ifq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|eonifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
name|eonifp
operator|->
name|if_ipackets
operator|--
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EON
argument_list|)
name|printf
argument_list|(
literal|"0x%x enqueued on clnp Q: m_len 0x%x m_type 0x%x m_data 0x%x\n"
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_type
argument_list|,
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|schednetisr
parameter_list|(
name|NETISR_ISO
parameter_list|)
function_decl|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|int
name|eonctlinput
parameter_list|(
name|cmd
parameter_list|,
name|sin
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
block|{
specifier|extern
name|u_char
name|inetctlerrmap
index|[]
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EON
argument_list|)
name|printf
argument_list|(
literal|"eonctlinput: cmd 0x%x addr: "
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cmd
operator|<
literal|0
operator|||
name|cmd
operator|>
name|PRC_NCMDS
condition|)
return|return
literal|0
return|;
name|IncStat
argument_list|(
name|es_icmp
index|[
name|cmd
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_QUENCH
case|:
case|case
name|PRC_QUENCH2
case|:
comment|/* TODO: set the dec bit */
break|break;
case|case
name|PRC_TIMXCEED_REASS
case|:
case|case
name|PRC_ROUTEDEAD
case|:
case|case
name|PRC_HOSTUNREACH
case|:
case|case
name|PRC_UNREACH_NET
case|:
case|case
name|PRC_IFDOWN
case|:
case|case
name|PRC_UNREACH_HOST
case|:
case|case
name|PRC_HOSTDEAD
case|:
case|case
name|PRC_TIMXCEED_INTRANS
case|:
comment|/* TODO: mark the link down */
break|break;
case|case
name|PRC_UNREACH_PROTOCOL
case|:
case|case
name|PRC_UNREACH_PORT
case|:
case|case
name|PRC_UNREACH_SRCFAIL
case|:
case|case
name|PRC_REDIRECT_NET
case|:
case|case
name|PRC_REDIRECT_HOST
case|:
case|case
name|PRC_REDIRECT_TOSNET
case|:
case|case
name|PRC_REDIRECT_TOSHOST
case|:
case|case
name|PRC_MSGSIZE
case|:
case|case
name|PRC_PARAMPROB
case|:
comment|/* printf("eonctlinput: ICMP cmd 0x%x\n", cmd );*/
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

