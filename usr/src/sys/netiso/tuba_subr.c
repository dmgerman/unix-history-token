begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)tuba_subr.c	7.4 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/clnp.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_var.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tuba_addr.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_iso
name|null_siso
init|=
block|{
sizeof|sizeof
argument_list|(
name|null_siso
argument_list|)
block|,
name|AF_ISO
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|isopcb
name|tuba_isopcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tuba_table_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tcppcbcachemiss
decl_stmt|,
name|tcppredack
decl_stmt|,
name|tcppreddat
decl_stmt|,
name|tcprexmtthresh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|inpcb
modifier|*
name|tcp_last_inpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|tcpiphdr
name|tcp_saveti
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Tuba initialization  */
end_comment

begin_macro
name|tuba_init
argument_list|()
end_macro

begin_block
block|{
define|#
directive|define
name|TUBAHDRSIZE
value|(3
comment|/*LLC*/
value|+ 9
comment|/*CLNP Fixed*/
value|+ 42
comment|/*Addresses*/
value|\ 		     + 6
comment|/*CLNP Segment*/
value|+ 20
comment|/*TCP*/
value|)
name|tuba_isopcb
operator|.
name|isop_next
operator|=
name|tuba_isopcb
operator|.
name|isop_prev
operator|=
operator|&
name|tuba_isopcb
expr_stmt|;
name|tuba_isopcb
operator|.
name|isop_faddr
operator|=
operator|&
name|tuba_isopcb
operator|.
name|isop_sfaddr
expr_stmt|;
name|tuba_isopcb
operator|.
name|isop_laddr
operator|=
operator|&
name|tuba_isopcb
operator|.
name|isop_sladdr
expr_stmt|;
if|if
condition|(
name|max_protohdr
operator|<
name|TUBAHDRSIZE
condition|)
name|max_protohdr
operator|=
name|TUBAHDRSIZE
expr_stmt|;
if|if
condition|(
name|max_linkhdr
operator|+
name|TUBAHDRSIZE
operator|>
name|MHLEN
condition|)
name|panic
argument_list|(
literal|"tuba_init"
argument_list|)
expr_stmt|;
name|tuba_table_init
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|tuba_getaddr
parameter_list|(
name|error
parameter_list|,
name|sum
parameter_list|,
name|siso
parameter_list|,
name|index
parameter_list|)
name|int
modifier|*
name|error
decl_stmt|;
name|u_long
modifier|*
name|sum
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
name|u_long
name|index
decl_stmt|;
block|{
specifier|register
name|struct
name|tuba_cache
modifier|*
name|tc
decl_stmt|;
if|if
condition|(
name|index
operator|<
name|tuba_table_size
operator|&&
operator|(
name|tc
operator|=
name|tuba_table
index|[
name|index
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|siso
condition|)
block|{
operator|*
name|siso
operator|=
name|null_siso
expr_stmt|;
name|siso
operator|->
name|siso_addr
operator|=
name|tc
operator|->
name|tc_addr
expr_stmt|;
block|}
name|sum
operator|+=
name|tc
operator|->
name|tc_sum_out
expr_stmt|;
block|}
else|else
operator|*
name|error
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|tuba_output
argument_list|(
name|m
argument_list|,
name|tp
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
specifier|register
name|struct
name|tcpiphdr
modifier|*
name|n
decl_stmt|;
name|u_long
name|sum
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|tp
operator|==
literal|0
operator|||
operator|(
name|n
operator|=
name|tp
operator|->
name|t_template
operator|)
operator|==
literal|0
condition|)
block|{
name|isop
operator|=
operator|&
name|tuba_isopcb
expr_stmt|;
name|i
operator|=
name|sum
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tcpiphdr
operator|*
argument_list|)
expr_stmt|;
name|tuba_getaddr
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|sum
argument_list|,
name|tuba_isopcb
operator|.
name|isop_faddr
argument_list|,
name|n
operator|->
name|ti_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|tuba_getaddr
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|sum
argument_list|,
name|tuba_isopcb
operator|.
name|isop_laddr
argument_list|,
name|n
operator|->
name|ti_src
operator|.
name|s_addr
argument_list|)
expr_stmt|;
goto|goto
name|adjust
goto|;
block|}
name|isop
operator|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|tp
operator|->
name|t_tuba_pcb
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|ti_sum
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|sum
operator|=
literal|0
expr_stmt|;
name|tuba_getaddr
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|sum
argument_list|,
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
literal|0
argument_list|,
name|n
operator|->
name|ti_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|tuba_getaddr
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|sum
argument_list|,
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
literal|0
argument_list|,
name|n
operator|->
name|ti_src
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|ICKSUM
argument_list|(
name|sum
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|n
operator|->
name|ti_sum
operator|=
name|sum
expr_stmt|;
name|n
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tcpiphdr
operator|*
argument_list|)
expr_stmt|;
name|adjust
label|:
if|if
condition|(
name|i
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|ICKSUM
argument_list|(
name|n
operator|->
name|ti_sum
argument_list|,
name|sum
operator|+
name|n
operator|->
name|ti_sum
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|clnp_output
argument_list|(
name|m
argument_list|,
name|isop
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|tuba_refcnt
argument_list|(
argument|isop
argument_list|,
argument|delta
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tuba_cache
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|index
decl_stmt|,
name|sum
decl_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|1
condition|)
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|isop
operator|==
literal|0
operator|||
name|isop
operator|->
name|isop_faddr
operator|==
literal|0
operator|||
name|isop
operator|->
name|isop_laddr
operator|==
literal|0
operator|||
operator|(
name|delta
operator|==
operator|-
literal|1
operator|&&
name|isop
operator|->
name|isop_tuba_cached
operator|==
literal|0
operator|)
operator|||
operator|(
name|delta
operator|==
literal|1
operator|&&
name|isop
operator|->
name|isop_tuba_cached
operator|!=
literal|0
operator|)
condition|)
return|return;
name|isop
operator|->
name|isop_tuba_cached
operator|=
operator|(
name|delta
operator|==
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|=
name|tuba_lookup
argument_list|(
operator|&
name|isop
operator|->
name|isop_sfaddr
operator|.
name|siso_addr
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|tc
operator|=
name|tuba_table
index|[
name|index
index|]
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|delta
operator|==
literal|1
operator|||
name|tc
operator|->
name|tc_refcnt
operator|>
literal|0
operator|)
condition|)
name|tc
operator|->
name|tc_refcnt
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|=
name|tuba_lookup
argument_list|(
operator|&
name|isop
operator|->
name|isop_sladdr
operator|.
name|siso_addr
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|tc
operator|=
name|tuba_table
index|[
name|index
index|]
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|delta
operator|==
literal|1
operator|||
name|tc
operator|->
name|tc_refcnt
operator|>
literal|0
operator|)
condition|)
name|tc
operator|->
name|tc_refcnt
operator|+=
name|delta
expr_stmt|;
block|}
end_block

begin_macro
name|tuba_pcbdetach
argument_list|(
argument|isop
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|isop
operator|==
literal|0
condition|)
return|return;
name|tuba_refcnt
argument_list|(
name|isop
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_socket
operator|=
literal|0
expr_stmt|;
name|iso_pcbdetach
argument_list|(
name|isop
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Avoid  in_pcbconnect in faked out tcp_input()  */
end_comment

begin_expr_stmt
name|tuba_pcbconnect
argument_list|(
name|inp
argument_list|,
name|nam
argument_list|)
specifier|register
expr|struct
name|inpcb
operator|*
name|inp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|unsigned
name|index
init|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
decl_stmt|;
name|struct
name|tuba_cache
modifier|*
name|tc
init|=
name|tuba_table
index|[
name|index
index|]
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|isop
init|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|tp
operator|->
name|t_tuba_pcb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|=
name|index
expr_stmt|;
name|inp
operator|->
name|inp_fport
operator|=
name|sin
operator|->
name|sin_port
expr_stmt|;
operator|*
name|siso
operator|=
name|null_siso
expr_stmt|;
name|siso
operator|->
name|siso_addr
operator|=
name|tc
operator|->
name|tc_addr
expr_stmt|;
name|siso
operator|->
name|siso_tlen
operator|=
sizeof|sizeof
argument_list|(
name|inp
operator|->
name|inp_fport
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|inp
operator|->
name|inp_fport
argument_list|,
name|TSEL
argument_list|(
name|siso
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|inp
operator|->
name|inp_fport
argument_list|)
argument_list|)
expr_stmt|;
name|nam
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|siso
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iso_pcbconnect
argument_list|(
name|isop
argument_list|,
name|nam
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tuba_refcnt
argument_list|(
name|isop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  * 	clnp's input routine, indirectly through the protosw.  * FUNCTION and ARGUMENTS:  * Take a packet (m) from clnp, strip off the clnp header  * and do tcp input processing.  * No return value.    */
end_comment

begin_expr_stmt
name|tuba_tcpinput
argument_list|(
name|m
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|clnp_len
argument_list|,
name|ce_bit
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clnp_len
decl_stmt|,
name|ce_bit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|unsigned
name|long
name|fix_cksum
decl_stmt|,
name|lindex
decl_stmt|,
name|findex
decl_stmt|;
specifier|register
name|struct
name|tcpiphdr
modifier|*
name|ti
decl_stmt|;
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|om
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tlen
decl_stmt|,
name|off
decl_stmt|;
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
literal|0
decl_stmt|;
name|int
name|tiflags
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|todrop
decl_stmt|,
name|acked
decl_stmt|,
name|ourfinisacked
decl_stmt|,
name|needoutput
init|=
literal|0
decl_stmt|;
name|short
name|ostate
decl_stmt|;
name|struct
name|in_addr
name|laddr
decl_stmt|;
name|int
name|dropsocket
init|=
literal|0
decl_stmt|,
name|iss
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"tuba_input"
argument_list|)
expr_stmt|;
comment|/* 	 * Do some housekeeping looking up CLNP addresses. 	 * If we are out of space might as well drop the packet now. 	 */
name|tcpstat
operator|.
name|tcps_rcvtotal
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|lindex
operator|=
name|tuba_lookup
argument_list|(
operator|&
name|dst
operator|->
name|siso_addr
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|findex
operator|=
name|tuba_lookup
argument_list|(
operator|&
name|dst
operator|->
name|siso_addr
argument_list|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Get CLNP and TCP header together in first mbuf. 	 * CLNP gave us an mbuf chain WITH the clnp header pulled up, 	 * and the length of the clnp header. 	 */
name|len
operator|=
name|clnp_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|len
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvshort
operator|++
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Calculate checksum of extended TCP header and data, 	 * by adjusting the checksum for missing parts of the header. 	 */
name|m
operator|->
name|m_data
operator|+=
name|clnp_len
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|clnp_len
expr_stmt|;
name|tlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|clnp_len
expr_stmt|;
name|ICKSUM
argument_list|(
name|fix_cksum
argument_list|,
name|tuba_table
index|[
name|findex
index|]
operator|->
name|tc_sum_in
operator|+
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|tlen
argument_list|)
operator|+
name|tuba_table
index|[
name|lindex
index|]
operator|->
name|tc_sum_in
operator|+
name|in_cksum
argument_list|(
name|m
argument_list|,
name|tlen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fix_cksum
operator|!=
literal|0xffff
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvbadsum
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|m
operator|->
name|m_data
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * The reassembly code assumes it will be overwriting a useless 	 * part of the packet, which is why we need to have ti point 	 * into the packet itself. 	 * 	 * Check to see if the data is properly alligned 	 * so that we can save copying the tcp header. 	 * This code knows way too much about the structure of mbufs! 	 */
name|off
operator|=
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|?
operator|(
name|m
operator|->
name|m_data
operator|-
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|)
else|:
operator|(
name|m
operator|->
name|m_data
operator|-
name|m
operator|->
name|m_pktdat
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|off
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
decl_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
block|{
goto|goto
name|drop
goto|;
block|}
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|=
name|m
operator|->
name|m_pkthdr
expr_stmt|;
name|m0
operator|->
name|m_flags
operator|=
name|m
operator|->
name|m_flags
operator|&
name|M_COPYFLAGS
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
block|}
name|ti
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tcpiphdr
operator|*
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_src
operator|.
name|s_addr
operator|=
name|findex
expr_stmt|;
name|ti
operator|->
name|ti_dst
operator|.
name|s_addr
operator|=
name|lindex
expr_stmt|;
name|ti
operator|->
name|ti_len
operator|=
name|tlen
expr_stmt|;
comment|/* 	 * Now include the rest of TCP input 	 */
define|#
directive|define
name|TUBA_INCLUDE
define|#
directive|define
name|in_pcbconnect
value|tuba_pcbconnect
include|#
directive|include
file|<netinet/tcp_input.c>
block|}
end_block

end_unit

