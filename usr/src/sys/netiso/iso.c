begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)iso.c	7.23 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * $Header: iso.c,v 4.11 88/09/19 14:58:35 root Exp $   * $Source: /usr/argo/sys/netiso/RCS/iso.c,v $   *  * iso.c: miscellaneous routines to support the iso address family  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/af.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_var.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_snpac.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/clnp.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TUBA
end_ifdef

begin_include
include|#
directive|include
file|<netiso/tuba_table.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_decl_stmt
name|int
name|iso_interfaces
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of external interfaces */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
name|loif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* loopback interface */
end_comment

begin_function_decl
name|int
name|ether_output
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|llc_rtrequest
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * FUNCTION:		iso_addrmatch1  *  * PURPOSE:			decide if the two iso_addrs passed are equal  *  * RETURNS:			true if the addrs match, false if they do not  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_expr_stmt
name|iso_addrmatch1
argument_list|(
name|isoaa
argument_list|,
name|isoab
argument_list|)
specifier|register
expr|struct
name|iso_addr
operator|*
name|isoaa
operator|,
operator|*
name|isoab
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* addresses to check */
end_comment

begin_block
block|{
name|u_int
name|compare_len
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_addrmatch1: comparing lengths: %d to %d\n"
argument_list|,
name|isoaa
operator|->
name|isoa_len
argument_list|,
name|isoab
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"a:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|isoaa
operator|->
name|isoa_genaddr
argument_list|,
name|isoaa
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"b:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|isoab
operator|->
name|isoa_genaddr
argument_list|,
name|isoab
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|compare_len
operator|=
name|isoaa
operator|->
name|isoa_len
operator|)
operator|!=
name|isoab
operator|->
name|isoa_len
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_addrmatch1: returning false because of lengths\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* TODO : generalize this to all afis with masks */
if|if
condition|(
name|isoaa
operator|->
name|isoa_afi
operator|==
name|AFI_37
condition|)
block|{
comment|/* must not compare 2 least significant digits, or for 		 * that matter, the DSP 		 */
name|compare_len
operator|=
name|ADDR37_IDI_LEN
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|a
operator|=
name|isoaa
operator|->
name|isoa_genaddr
expr_stmt|;
name|b
operator|=
name|isoab
operator|->
name|isoa_genaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|compare_len
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"<%x=%x>"
argument_list|,
name|a
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|,
name|b
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
name|i
index|]
operator|!=
name|b
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"\naddrs are not equal at byte %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"addrs are equal\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|ENDDEBUG
return|return
operator|(
operator|!
name|bcmp
argument_list|(
name|isoaa
operator|->
name|isoa_genaddr
argument_list|,
name|isoab
operator|->
name|isoa_genaddr
argument_list|,
name|compare_len
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_addrmatch  *  * PURPOSE:			decide if the two sockadrr_isos passed are equal  *  * RETURNS:			true if the addrs match, false if they do not  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|iso_addrmatch
argument_list|(
argument|sisoa
argument_list|,
argument|sisob
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|sisoa
decl_stmt|,
modifier|*
name|sisob
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* addresses to check */
end_comment

begin_block
block|{
return|return
operator|(
name|iso_addrmatch1
argument_list|(
operator|&
name|sisoa
operator|->
name|siso_addr
argument_list|,
operator|&
name|sisob
operator|->
name|siso_addr
argument_list|)
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * FUNCTION:		iso_netmatch  *  * PURPOSE:			similar to iso_addrmatch but takes sockaddr_iso  *					as argument.  *  * RETURNS:			true if same net, false if not  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|iso_netmatch
argument_list|(
argument|sisoa
argument_list|,
argument|sisob
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|sisoa
decl_stmt|,
modifier|*
name|sisob
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_char
name|bufa
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
index|]
decl_stmt|;
name|u_char
name|bufb
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|lena
decl_stmt|,
name|lenb
decl_stmt|;
name|lena
operator|=
name|iso_netof
argument_list|(
operator|&
name|sisoa
operator|->
name|siso_addr
argument_list|,
name|bufa
argument_list|)
expr_stmt|;
name|lenb
operator|=
name|iso_netof
argument_list|(
operator|&
name|sisob
operator|->
name|siso_addr
argument_list|,
name|bufb
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_netmatch: comparing lengths: %d to %d\n"
argument_list|,
name|lena
argument_list|,
name|lenb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"a:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|bufa
argument_list|,
name|lena
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"b:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|bufb
argument_list|,
name|lenb
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
operator|(
name|lena
operator|==
name|lenb
operator|)
operator|&&
operator|(
operator|!
name|bcmp
argument_list|(
name|bufa
argument_list|,
name|bufb
argument_list|,
name|lena
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notdef */
end_comment

begin_comment
comment|/*  * FUNCTION:		iso_hashchar  *  * PURPOSE:			Hash all character in the buffer specified into  *					a long. Return the long.  *  * RETURNS:			The hash value.  *  * SIDE EFFECTS:	  *  * NOTES:			The hash is achieved by exclusive ORing 4 byte  *					quantities.   */
end_comment

begin_function
name|u_long
name|iso_hashchar
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
specifier|register
name|caddr_t
name|buf
decl_stmt|;
comment|/* buffer to pack from */
specifier|register
name|int
name|len
decl_stmt|;
comment|/* length of buffer */
block|{
specifier|register
name|u_long
name|h
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|4
control|)
block|{
specifier|register
name|u_long
name|l
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|-
name|i
operator|)
operator|<
literal|4
condition|)
block|{
comment|/* buffer not multiple of 4 */
switch|switch
condition|(
name|len
operator|-
name|i
condition|)
block|{
case|case
literal|3
case|:
name|l
operator||=
name|buf
index|[
name|i
operator|+
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
case|case
literal|2
case|:
name|l
operator||=
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|16
expr_stmt|;
case|case
literal|1
case|:
name|l
operator||=
name|buf
index|[
name|i
index|]
operator|<<
literal|24
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"iso_hashchar: unexpected value x%x\n"
argument_list|,
name|len
operator|-
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|l
operator||=
name|buf
index|[
name|i
index|]
operator|<<
literal|24
expr_stmt|;
name|l
operator||=
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|16
expr_stmt|;
name|l
operator||=
name|buf
index|[
name|i
operator|+
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
name|l
operator||=
name|buf
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
name|h
operator|^=
name|l
expr_stmt|;
block|}
name|h
operator|^=
call|(
name|u_long
call|)
argument_list|(
name|len
operator|%
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * FUNCTION:		iso_hash  *  * PURPOSE:			Fill in fields of afhash structure based upon addr passed.  *  * RETURNS:			none  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|iso_hash
argument_list|(
argument|siso
argument_list|,
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address to perform hash on */
end_comment

begin_decl_stmt
name|struct
name|afhash
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN: hash info here */
end_comment

begin_block
block|{
name|u_long
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
operator|+
literal|1
operator|/
literal|4
index|]
decl_stmt|;
specifier|register
name|int
name|bufsize
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|bufsize
operator|=
name|iso_netof
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|hp
operator|->
name|afh_nethash
operator|=
name|iso_hashchar
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_hash: iso_netof: bufsize = %d\n"
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|hp
operator|->
name|afh_hosthash
init|=
name|iso_hashchar
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
name|siso
operator|->
name|siso_addr
operator|.
name|isoa_len
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_hash: %s: nethash = x%x, hosthash = x%x\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|)
argument_list|,
name|hp
operator|->
name|afh_nethash
argument_list|,
name|hp
operator|->
name|afh_hosthash
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_netof  *  * PURPOSE:			Extract the network portion of the iso address.  *					The network portion of the iso address varies depending  *					on the type of address. The network portion of the  *					address will include the IDP. The network portion is:  *			  *						TYPE			DESC  *					t37					The AFI and x.121 (IDI)  *					osinet				The AFI, orgid, snetid  *					rfc986				The AFI, vers and network part of  *										internet address.  *  * RETURNS:			number of bytes placed into buf.  *  * SIDE EFFECTS:	  *  * NOTES:			Buf is assumed to be big enough  */
end_comment

begin_macro
name|iso_netof
argument_list|(
argument|isoa
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address */
end_comment

begin_decl_stmt
name|caddr_t
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RESULT: network portion of address here */
end_comment

begin_block
block|{
name|u_int
name|len
init|=
literal|1
decl_stmt|;
comment|/* length of afi */
switch|switch
condition|(
name|isoa
operator|->
name|isoa_afi
condition|)
block|{
case|case
name|AFI_37
case|:
comment|/* 			 * Due to classic x.25 tunnel vision, there is no 			 * net portion of an x.121 address.  For our purposes 			 * the AFI will do, so that all x.25 -type addresses 			 * map to the single x.25 SNPA. (Cannot have more than 			 * one, obviously). 			 */
break|break;
comment|/* 		case AFI_OSINET:*/
case|case
name|AFI_RFC986
case|:
block|{
name|u_short
name|idi
decl_stmt|;
comment|/* value of idi */
comment|/* osinet and rfc986 have idi in the same place */
name|CTOH
argument_list|(
name|isoa
operator|->
name|rfc986_idi
index|[
literal|0
index|]
argument_list|,
name|isoa
operator|->
name|rfc986_idi
index|[
literal|1
index|]
argument_list|,
name|idi
argument_list|)
expr_stmt|;
if|if
condition|(
name|idi
operator|==
name|IDI_OSINET
condition|)
comment|/*  *	Network portion of OSINET address can only be the IDI. Clearly,  *	with one x25 interface, one could get to several orgids, and  *	several snetids. 				len += (ADDROSINET_IDI_LEN + OVLOSINET_ORGID_LEN +  						OVLOSINET_SNETID_LEN);  */
name|len
operator|+=
name|ADDROSINET_IDI_LEN
expr_stmt|;
elseif|else
if|if
condition|(
name|idi
operator|==
name|IDI_RFC986
condition|)
block|{
name|u_long
name|inetaddr
decl_stmt|;
name|struct
name|ovl_rfc986
modifier|*
name|o986
init|=
operator|(
expr|struct
name|ovl_rfc986
operator|*
operator|)
name|isoa
decl_stmt|;
comment|/* bump len to include idi and version (1 byte) */
name|len
operator|+=
name|ADDRRFC986_IDI_LEN
operator|+
literal|1
expr_stmt|;
comment|/* get inet addr long aligned */
name|bcopy
argument_list|(
name|o986
operator|->
name|o986_inetaddr
argument_list|,
operator|&
name|inetaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inetaddr
argument_list|)
argument_list|)
expr_stmt|;
name|inetaddr
operator|=
name|ntohl
argument_list|(
name|inetaddr
argument_list|)
expr_stmt|;
comment|/* convert to host byte order */
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_netof: isoa "
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|isoa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|isoa
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iso_netof: inetaddr 0x%x "
argument_list|,
name|inetaddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* bump len by size of network portion of inet address */
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|inetaddr
argument_list|)
condition|)
block|{
name|len
operator|+=
literal|4
operator|-
name|IN_CLASSA_NSHIFT
operator|/
literal|8
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_netof: class A net len is now %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|inetaddr
argument_list|)
condition|)
block|{
name|len
operator|+=
literal|4
operator|-
name|IN_CLASSB_NSHIFT
operator|/
literal|8
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_netof: class B net len is now %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
else|else
block|{
name|len
operator|+=
literal|4
operator|-
name|IN_CLASSC_NSHIFT
operator|/
literal|8
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_netof: class C net len is now %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
block|}
else|else
name|len
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|isoa
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_netof: isoa "
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|isoa
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iso_netof: net "
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|len
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notdef */
end_comment

begin_comment
comment|/*  * Generic iso control operations (ioctl's).  * Ifp is 0 if not an interface-specific ioctl.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|iso_control
argument_list|(
argument|so
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|ifp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iso_ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|iso_ifreq
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|iso_ifaddr
modifier|*
name|ia
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|iso_ifaddr
modifier|*
name|oia
decl_stmt|;
name|struct
name|iso_aliasreq
modifier|*
name|ifra
init|=
operator|(
expr|struct
name|iso_aliasreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
decl_stmt|,
name|hostIsNew
decl_stmt|,
name|maskIsNew
decl_stmt|;
comment|/* 	 * Find address for this interface, if it exists. 	 */
if|if
condition|(
name|ifp
condition|)
for|for
control|(
name|ia
operator|=
name|iso_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
if|if
condition|(
name|ia
operator|->
name|ia_ifp
operator|==
name|ifp
condition|)
break|break;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCAIFADDR_ISO
case|:
case|case
name|SIOCDIFADDR_ISO
case|:
if|if
condition|(
name|ifra
operator|->
name|ifra_addr
operator|.
name|siso_family
operator|==
name|AF_ISO
condition|)
for|for
control|(
name|oia
operator|=
name|ia
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
if|if
condition|(
name|ia
operator|->
name|ia_ifp
operator|==
name|ifp
operator|&&
name|SAME_ISOADDR
argument_list|(
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
operator|&
name|ifra
operator|->
name|ifra_addr
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_PRIV
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"iso_control"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
operator|(
expr|struct
name|iso_ifaddr
operator|*
operator|)
literal|0
condition|)
block|{
name|struct
name|iso_ifaddr
modifier|*
name|nia
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|SIOCDIFADDR_ISO
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
ifdef|#
directive|ifdef
name|TUBA
comment|/* XXXXXX can't be done in the proto init routines */
if|if
condition|(
name|tuba_tree
operator|==
literal|0
condition|)
name|tuba_table_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|MALLOC
argument_list|(
name|nia
argument_list|,
expr|struct
name|iso_ifaddr
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nia
argument_list|)
argument_list|,
name|M_IFADDR
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|nia
operator|==
operator|(
expr|struct
name|iso_ifaddr
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|nia
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nia
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|=
name|iso_ifaddr
condition|)
block|{
for|for
control|(
init|;
name|ia
operator|->
name|ia_next
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
empty_stmt|;
name|ia
operator|->
name|ia_next
operator|=
name|nia
expr_stmt|;
block|}
else|else
name|iso_ifaddr
operator|=
name|nia
expr_stmt|;
name|ia
operator|=
name|nia
expr_stmt|;
if|if
condition|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
condition|)
block|{
for|for
control|(
init|;
name|ifa
operator|->
name|ifa_next
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
empty_stmt|;
name|ifa
operator|->
name|ifa_next
operator|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|ia
expr_stmt|;
block|}
else|else
name|ifp
operator|->
name|if_addrlist
operator|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|ia
expr_stmt|;
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ia
operator|->
name|ia_addr
expr_stmt|;
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_dstaddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ia
operator|->
name|ia_dstaddr
expr_stmt|;
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_netmask
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ia
operator|->
name|ia_sockmask
expr_stmt|;
name|ia
operator|->
name|ia_ifp
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
operator|&
name|loif
condition|)
name|iso_interfaces
operator|++
expr_stmt|;
block|}
break|break;
define|#
directive|define
name|cmdbyte
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 8)& 0xff)
default|default:
if|if
condition|(
name|cmdbyte
argument_list|(
name|cmd
argument_list|)
operator|==
literal|'a'
condition|)
return|return
operator|(
name|snpac_ioctl
argument_list|(
name|so
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
operator|)
return|;
if|if
condition|(
name|ia
operator|==
operator|(
expr|struct
name|iso_ifaddr
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGIFADDR_ISO
case|:
name|ifr
operator|->
name|ifr_Addr
operator|=
name|ia
operator|->
name|ia_addr
expr_stmt|;
break|break;
case|case
name|SIOCGIFDSTADDR_ISO
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ifr
operator|->
name|ifr_Addr
operator|=
name|ia
operator|->
name|ia_dstaddr
expr_stmt|;
break|break;
case|case
name|SIOCGIFNETMASK_ISO
case|:
name|ifr
operator|->
name|ifr_Addr
operator|=
name|ia
operator|->
name|ia_sockmask
expr_stmt|;
break|break;
case|case
name|SIOCAIFADDR_ISO
case|:
name|maskIsNew
operator|=
literal|0
expr_stmt|;
name|hostIsNew
operator|=
literal|1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ia
operator|->
name|ia_addr
operator|.
name|siso_family
operator|==
name|AF_ISO
condition|)
block|{
if|if
condition|(
name|ifra
operator|->
name|ifra_addr
operator|.
name|siso_len
operator|==
literal|0
condition|)
block|{
name|ifra
operator|->
name|ifra_addr
operator|=
name|ia
operator|->
name|ia_addr
expr_stmt|;
name|hostIsNew
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SAME_ISOADDR
argument_list|(
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
operator|&
name|ifra
operator|->
name|ifra_addr
argument_list|)
condition|)
name|hostIsNew
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ifra
operator|->
name|ifra_mask
operator|.
name|siso_len
condition|)
block|{
name|iso_ifscrub
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
name|ia
operator|->
name|ia_sockmask
operator|=
name|ifra
operator|->
name|ifra_mask
expr_stmt|;
name|maskIsNew
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|&&
operator|(
name|ifra
operator|->
name|ifra_dstaddr
operator|.
name|siso_family
operator|==
name|AF_ISO
operator|)
condition|)
block|{
name|iso_ifscrub
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
name|ia
operator|->
name|ia_dstaddr
operator|=
name|ifra
operator|->
name|ifra_dstaddr
expr_stmt|;
name|maskIsNew
operator|=
literal|1
expr_stmt|;
comment|/* We lie; but the effect's the same */
block|}
if|if
condition|(
name|ifra
operator|->
name|ifra_addr
operator|.
name|siso_family
operator|==
name|AF_ISO
operator|&&
operator|(
name|hostIsNew
operator|||
name|maskIsNew
operator|)
condition|)
block|{
name|error
operator|=
name|iso_ifinit
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|,
operator|&
name|ifra
operator|->
name|ifra_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifra
operator|->
name|ifra_snpaoffset
condition|)
name|ia
operator|->
name|ia_snpaoffset
operator|=
name|ifra
operator|->
name|ifra_snpaoffset
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
case|case
name|SIOCDIFADDR_ISO
case|:
name|iso_ifscrub
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
operator|)
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|ia
condition|)
name|ifp
operator|->
name|if_addrlist
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
else|else
block|{
while|while
condition|(
name|ifa
operator|->
name|ifa_next
operator|&&
operator|(
name|ifa
operator|->
name|ifa_next
operator|!=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|ia
operator|)
condition|)
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_next
condition|)
name|ifa
operator|->
name|ifa_next
operator|=
operator|(
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|ia
operator|)
operator|->
name|ifa_next
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Couldn't unlink isoifaddr from ifp\n"
argument_list|)
expr_stmt|;
block|}
name|oia
operator|=
name|ia
expr_stmt|;
if|if
condition|(
name|oia
operator|==
operator|(
name|ia
operator|=
name|iso_ifaddr
operator|)
condition|)
block|{
name|iso_ifaddr
operator|=
name|ia
operator|->
name|ia_next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|ia
operator|->
name|ia_next
operator|&&
operator|(
name|ia
operator|->
name|ia_next
operator|!=
name|oia
operator|)
condition|)
block|{
name|ia
operator|=
name|ia
operator|->
name|ia_next
expr_stmt|;
block|}
if|if
condition|(
name|ia
operator|->
name|ia_next
condition|)
name|ia
operator|->
name|ia_next
operator|=
name|oia
operator|->
name|ia_next
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Didn't unlink isoifadr from list\n"
argument_list|)
expr_stmt|;
block|}
name|IFAFREE
argument_list|(
operator|(
operator|&
name|oia
operator|->
name|ia_ifa
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ifp
operator|==
literal|0
operator|||
name|ifp
operator|->
name|if_ioctl
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Delete any existing route for an interface.  */
end_comment

begin_expr_stmt
name|iso_ifscrub
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nsellength
init|=
name|ia
operator|->
name|ia_addr
operator|.
name|siso_tlen
decl_stmt|;
if|if
condition|(
operator|(
name|ia
operator|->
name|ia_flags
operator|&
name|IFA_ROUTE
operator|)
operator|==
literal|0
condition|)
return|return;
name|ia
operator|->
name|ia_addr
operator|.
name|siso_tlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
name|rtinit
argument_list|(
operator|&
operator|(
name|ia
operator|->
name|ia_ifa
operator|)
argument_list|,
operator|(
name|int
operator|)
name|RTM_DELETE
argument_list|,
name|RTF_HOST
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
name|rtinit
argument_list|(
operator|&
operator|(
name|ia
operator|->
name|ia_ifa
operator|)
argument_list|,
operator|(
name|int
operator|)
name|RTM_DELETE
argument_list|,
name|RTF_HOST
argument_list|)
expr_stmt|;
else|else
block|{
name|rtinit
argument_list|(
operator|&
operator|(
name|ia
operator|->
name|ia_ifa
operator|)
argument_list|,
operator|(
name|int
operator|)
name|RTM_DELETE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ia
operator|->
name|ia_addr
operator|.
name|siso_tlen
operator|=
name|nsellength
expr_stmt|;
name|ia
operator|->
name|ia_flags
operator|&=
operator|~
name|IFA_ROUTE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialize an interface's internet address  * and routing table entry.  */
end_comment

begin_expr_stmt
name|iso_ifinit
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|,
name|siso
argument_list|,
name|scrub
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sockaddr_iso
name|oldaddr
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
decl_stmt|,
name|nsellength
decl_stmt|;
name|oldaddr
operator|=
name|ia
operator|->
name|ia_addr
expr_stmt|;
name|ia
operator|->
name|ia_addr
operator|=
operator|*
name|siso
expr_stmt|;
comment|/* 	 * Give the interface a chance to initialize 	 * if this is its first address, 	 * and to validate the address if necessary. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_ioctl
operator|&&
operator|(
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|SIOCSIFADDR
argument_list|,
operator|(
name|caddr_t
operator|)
name|ia
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ia
operator|->
name|ia_addr
operator|=
name|oldaddr
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|scrub
condition|)
block|{
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|oldaddr
expr_stmt|;
name|iso_ifscrub
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ia
operator|->
name|ia_addr
expr_stmt|;
block|}
comment|/* XXX -- The following is here temporarily out of laziness 	   in not changing every ethernet driver's if_ioctl routine */
if|if
condition|(
name|ifp
operator|->
name|if_output
operator|==
name|ether_output
condition|)
block|{
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_rtrequest
operator|=
name|llc_rtrequest
expr_stmt|;
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_flags
operator||=
name|RTF_CLONING
expr_stmt|;
block|}
comment|/* 	 * Add route for the network. 	 */
name|nsellength
operator|=
name|ia
operator|->
name|ia_addr
operator|.
name|siso_tlen
expr_stmt|;
name|ia
operator|->
name|ia_addr
operator|.
name|siso_tlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
block|{
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_dstaddr
operator|=
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_addr
expr_stmt|;
name|error
operator|=
name|rtinit
argument_list|(
operator|&
operator|(
name|ia
operator|->
name|ia_ifa
operator|)
argument_list|,
operator|(
name|int
operator|)
name|RTM_ADD
argument_list|,
name|RTF_HOST
operator||
name|RTF_UP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
operator|&&
name|ia
operator|->
name|ia_dstaddr
operator|.
name|siso_family
operator|==
name|AF_ISO
condition|)
name|error
operator|=
name|rtinit
argument_list|(
operator|&
operator|(
name|ia
operator|->
name|ia_ifa
operator|)
argument_list|,
operator|(
name|int
operator|)
name|RTM_ADD
argument_list|,
name|RTF_HOST
operator||
name|RTF_UP
argument_list|)
expr_stmt|;
else|else
block|{
name|rt_maskedcopy
argument_list|(
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_addr
argument_list|,
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_dstaddr
argument_list|,
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_netmask
argument_list|)
expr_stmt|;
name|ia
operator|->
name|ia_dstaddr
operator|.
name|siso_nlen
operator|=
name|min
argument_list|(
name|ia
operator|->
name|ia_addr
operator|.
name|siso_nlen
argument_list|,
operator|(
name|ia
operator|->
name|ia_sockmask
operator|.
name|siso_len
operator|-
literal|6
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|rtinit
argument_list|(
operator|&
operator|(
name|ia
operator|->
name|ia_ifa
operator|)
argument_list|,
operator|(
name|int
operator|)
name|RTM_ADD
argument_list|,
name|RTF_UP
argument_list|)
expr_stmt|;
block|}
name|ia
operator|->
name|ia_addr
operator|.
name|siso_tlen
operator|=
name|nsellength
expr_stmt|;
name|ia
operator|->
name|ia_flags
operator||=
name|IFA_ROUTE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_function
name|struct
name|ifaddr
modifier|*
name|iso_ifwithidi
parameter_list|(
name|addr
parameter_list|)
specifier|register
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
specifier|register
name|u_int
name|af
init|=
name|addr
operator|->
name|sa_family
decl_stmt|;
if|if
condition|(
name|af
operator|!=
name|AF_ISO
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|">>> iso_ifwithidi addr\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
operator|(
name|addr
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|if_next
control|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_ifwithidi ifnet %s\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|)
expr_stmt|;
name|ENDDEBUG
for|for
control|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_ifwithidi address "
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
operator|(
name|ifa
operator|->
name|ifa_addr
operator|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|addr
operator|->
name|sa_family
condition|)
continue|continue;
define|#
directive|define
name|IFA_SIS
parameter_list|(
name|ifa
parameter_list|)
define|\
value|((struct sockaddr_iso *)((ifa)->ifa_addr))
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|" af same, args to iso_eqtype:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|IFA_SIS
argument_list|(
name|ifa
argument_list|)
operator|->
name|siso_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" 0x%x\n"
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|addr
operator|)
operator|->
name|siso_addr
operator|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|iso_eqtype
argument_list|(
operator|&
operator|(
name|IFA_SIS
argument_list|(
name|ifa
argument_list|)
operator|->
name|siso_addr
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|addr
operator|)
operator|->
name|siso_addr
operator|)
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"ifa_ifwithidi: ifa found\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
name|ifa
operator|)
return|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|" iso_eqtype failed\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
block|}
return|return
operator|(
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notdef */
end_comment

begin_comment
comment|/*  * FUNCTION:		iso_ck_addr  *  * PURPOSE:			return true if the iso_addr passed is   *					within the legal size limit for an iso address.  *  * RETURNS:			true or false  *  * SIDE EFFECTS:	  *  */
end_comment

begin_macro
name|iso_ck_addr
argument_list|(
argument|isoa
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address to check */
end_comment

begin_block
block|{
return|return
operator|(
name|isoa
operator|->
name|isoa_len
operator|<=
literal|20
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * FUNCTION:		iso_eqtype  *  * PURPOSE:			Determine if two iso addresses are of the same type.  *  This is flaky.  Really we should consider all type 47 addrs to be the  *  same - but there do exist different structures for 47 addrs.  *  Gosip adds a 3rd.  *  * RETURNS:			true if the addresses are the same type  *  * SIDE EFFECTS:	  *  * NOTES:			By type, I mean rfc986, t37, or osinet  *  *					This will first compare afis. If they match, then  *					if the addr is not t37, the idis must be compared.  */
end_comment

begin_macro
name|iso_eqtype
argument_list|(
argument|isoaa
argument_list|,
argument|isoab
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoaa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first addr to check */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* other addr to check */
end_comment

begin_block
block|{
if|if
condition|(
name|isoaa
operator|->
name|isoa_afi
operator|==
name|isoab
operator|->
name|isoa_afi
condition|)
block|{
if|if
condition|(
name|isoaa
operator|->
name|isoa_afi
operator|==
name|AFI_37
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|!
name|bcmp
argument_list|(
operator|&
name|isoaa
operator|->
name|isoa_u
argument_list|,
operator|&
name|isoab
operator|->
name|isoa_u
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notdef */
end_comment

begin_comment
comment|/*  * FUNCTION:		iso_localifa()  *  * PURPOSE:			Find an interface addresss having a given destination  *					or at least matching the net.  *  * RETURNS:			ptr to an interface address   *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|struct
name|iso_ifaddr
modifier|*
name|iso_localifa
parameter_list|(
name|siso
parameter_list|)
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
block|{
specifier|register
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
modifier|*
name|cp3
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|iso_ifaddr
modifier|*
name|ia_maybe
init|=
literal|0
decl_stmt|;
comment|/* 	 * We make one pass looking for both net matches and an exact 	 * dst addr. 	 */
for|for
control|(
name|ia
operator|=
name|iso_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|=
name|ia
operator|->
name|ia_ifp
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
if|if
condition|(
operator|(
name|ia
operator|->
name|ia_dstaddr
operator|.
name|siso_family
operator|==
name|AF_ISO
operator|)
operator|&&
name|SAME_ISOADDR
argument_list|(
operator|&
name|ia
operator|->
name|ia_dstaddr
argument_list|,
name|siso
argument_list|)
condition|)
return|return
operator|(
name|ia
operator|)
return|;
elseif|else
if|if
condition|(
name|SAME_ISOADDR
argument_list|(
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
name|siso
argument_list|)
condition|)
name|ia_maybe
operator|=
name|ia
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ia
operator|->
name|ia_sockmask
operator|.
name|siso_len
condition|)
block|{
name|char
modifier|*
name|cplim
init|=
name|ia
operator|->
name|ia_sockmask
operator|.
name|siso_len
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|ia
operator|->
name|ia_sockmask
decl_stmt|;
name|cp1
operator|=
name|ia
operator|->
name|ia_sockmask
operator|.
name|siso_data
expr_stmt|;
name|cp2
operator|=
name|siso
operator|->
name|siso_data
expr_stmt|;
name|cp3
operator|=
name|ia
operator|->
name|ia_addr
operator|.
name|siso_data
expr_stmt|;
while|while
condition|(
name|cp1
operator|<
name|cplim
condition|)
if|if
condition|(
operator|*
name|cp1
operator|++
operator|&
operator|(
operator|*
name|cp2
operator|++
operator|^
operator|*
name|cp3
operator|++
operator|)
condition|)
goto|goto
name|next
goto|;
name|ia_maybe
operator|=
name|ia
expr_stmt|;
block|}
if|if
condition|(
name|SAME_ISOADDR
argument_list|(
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
name|siso
argument_list|)
condition|)
return|return
name|ia
return|;
name|next
label|:
empty_stmt|;
block|}
return|return
name|ia_maybe
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TPCONS
end_ifdef

begin_include
include|#
directive|include
file|<netiso/cons.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TPCONS */
end_comment

begin_comment
comment|/*  * FUNCTION:		iso_nlctloutput  *  * PURPOSE:			Set options at the network level  *  * RETURNS:			E*  *  * SIDE EFFECTS:	  *  * NOTES:			This could embody some of the functions of  *					rclnp_ctloutput and cons_ctloutput.  */
end_comment

begin_macro
name|iso_nlctloutput
argument_list|(
argument|cmd
argument_list|,
argument|optname
argument_list|,
argument|pcb
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command:set or get */
end_comment

begin_decl_stmt
name|int
name|optname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* option of interest */
end_comment

begin_decl_stmt
name|caddr_t
name|pcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nl pcb */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data for set, buffer for get */
end_comment

begin_block
block|{
name|struct
name|isopcb
modifier|*
name|isop
init|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|pcb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* return value */
name|caddr_t
name|data
decl_stmt|;
comment|/* data for option */
name|int
name|data_len
decl_stmt|;
comment|/* data's length */
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_nlctloutput: cmd %x, opt %x, pcb %x, m %x\n"
argument_list|,
name|cmd
argument_list|,
name|optname
argument_list|,
name|pcb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|cmd
operator|!=
name|PRCO_GETOPT
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|PRCO_SETOPT
operator|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|data_len
operator|=
operator|(
name|m
operator|)
operator|->
name|m_len
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_nlctloutput: data is:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
switch|switch
condition|(
name|optname
condition|)
block|{
ifdef|#
directive|ifdef
name|TPCONS
case|case
name|CONSOPT_X25CRUD
case|:
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|data_len
operator|>
name|MAXX25CRUDLEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_nlctloutput: setting x25 crud\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|bcopy
argument_list|(
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
name|isop
operator|->
name|isop_x25crud
argument_list|,
operator|(
name|unsigned
operator|)
name|data_len
argument_list|)
decl_stmt|;
name|isop
operator|->
name|isop_x25crud_len
operator|=
name|data_len
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* TPCONS */
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
name|PRCO_SETOPT
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_comment
comment|/*  * FUNCTION:		dump_isoaddr  *  * PURPOSE:			debugging  *  * RETURNS:			nada   *  */
end_comment

begin_macro
name|dump_isoaddr
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|clnp_saddr_isop
parameter_list|()
function_decl|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|siso_family
operator|==
name|AF_ISO
condition|)
block|{
name|printf
argument_list|(
literal|"ISO address: suffixlen %d, %s\n"
argument_list|,
name|s
operator|->
name|siso_tlen
argument_list|,
name|clnp_saddr_isop
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|siso_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* hack */
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|s
decl_stmt|;
name|printf
argument_list|(
literal|"%d.%d.%d.%d: %d"
argument_list|,
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|)
operator|&
literal|0xff
argument_list|,
name|sin
operator|->
name|sin_port
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGO_DEBUG */
end_comment

end_unit

