begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*   * ARGO TP  * $Header: /var/src/sys/netiso/RCS/tp_iso.c,v 5.1 89/02/09 16:20:51 hagens Exp $  * $Source: /var/src/sys/netiso/RCS/tp_iso.c,v $  *	@(#)tp_iso.c	7.4 (Berkeley) %G%  *  * Here is where you find the iso-dependent code.  We've tried  * keep all net-level and (primarily) address-family-dependent stuff  * out of the tp source, and everthing here is reached indirectly  * through a switch table (struct nl_protosw *) tpcb->tp_nlproto   * (see tp_pcb.c).   * The routines here are:  * 		iso_getsufx: gets transport suffix out of an isopcb structure.  * 		iso_putsufx: put transport suffix into an isopcb structure.  *		iso_putnetaddr: put a whole net addr into an isopcb.  *		iso_getnetaddr: get a whole net addr from an isopcb.  *		iso_recycle_suffix: clear suffix for reuse in isopcb  * 		tpclnp_ctlinput: handle ER CNLPdu : icmp-like stuff  * 		tpclnp_mtu: figure out what size tpdu to use  *		tpclnp_input: take a pkt from clnp, strip off its clnp header,   *				give to tp  *		tpclnp_output_dg: package a pkt for clnp given 2 addresses& some data  *		tpclnp_output: package a pkt for clnp given an isopcb& some data  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /var/src/sys/netiso/RCS/tp_iso.c,v 5.1 89/02/09 16:20:51 hagens Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"tp_param.h"
end_include

begin_include
include|#
directive|include
file|"tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"tp_pcb.h"
end_include

begin_include
include|#
directive|include
file|"tp_trace.h"
end_include

begin_include
include|#
directive|include
file|"tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"tp_tpdu.h"
end_include

begin_include
include|#
directive|include
file|"tp_clnp.h"
end_include

begin_comment
comment|/*  * CALLED FROM:  * 	pr_usrreq() on PRU_BIND, PRU_CONNECT, PRU_ACCEPT, and PRU_PEERADDR  * FUNCTION, ARGUMENTS:  * 	The argument (which) takes the value TP_LOCAL or TP_FOREIGN.  */
end_comment

begin_macro
name|iso_getsufx
argument_list|(
argument|isop
argument_list|,
argument|lenp
argument_list|,
argument|data_out
argument_list|,
argument|which
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
modifier|*
name|lenp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data_out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|which
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|addr
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|TP_LOCAL
case|:
name|addr
operator|=
name|isop
operator|->
name|isop_laddr
expr_stmt|;
break|break;
case|case
name|TP_FOREIGN
case|:
name|addr
operator|=
name|isop
operator|->
name|isop_faddr
expr_stmt|;
block|}
if|if
condition|(
name|addr
condition|)
name|bcopy
argument_list|(
name|TSEL
argument_list|(
name|addr
argument_list|)
argument_list|,
name|data_out
argument_list|,
operator|(
operator|*
name|lenp
operator|=
name|addr
operator|->
name|siso_tlen
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* CALLED FROM:  * 	tp_newsocket(); i.e., when a connection is being established by an  * 	incoming CR_TPDU.  *  * FUNCTION, ARGUMENTS:  * 	Put a transport suffix (found in name) into an isopcb structure (isop).  * 	The argument (which) takes the value TP_LOCAL or TP_FOREIGN.  */
end_comment

begin_function
name|void
name|iso_putsufx
parameter_list|(
name|isop
parameter_list|,
name|sufxloc
parameter_list|,
name|sufxlen
parameter_list|,
name|which
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|caddr_t
name|sufxloc
decl_stmt|;
name|int
name|sufxlen
decl_stmt|,
name|which
decl_stmt|;
block|{
name|struct
name|sockaddr_iso
modifier|*
modifier|*
name|dst
decl_stmt|,
modifier|*
name|backup
decl_stmt|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|addr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
default|default:
return|return;
case|case
name|TP_LOCAL
case|:
name|dst
operator|=
operator|&
name|isop
operator|->
name|isop_laddr
expr_stmt|;
name|backup
operator|=
operator|&
name|isop
operator|->
name|isop_sladdr
expr_stmt|;
break|break;
case|case
name|TP_FOREIGN
case|:
name|dst
operator|=
operator|&
name|isop
operator|->
name|isop_faddr
expr_stmt|;
name|backup
operator|=
operator|&
name|isop
operator|->
name|isop_sfaddr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|addr
operator|=
operator|*
name|dst
operator|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|=
operator|*
name|dst
operator|=
name|backup
expr_stmt|;
name|addr
operator|->
name|siso_nlen
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|siso_slen
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|siso_plen
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"iso_putsufx on un-initialized isopcb\n"
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|sufxlen
operator|+
name|addr
operator|->
name|siso_nlen
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|addr
operator|->
name|siso_data
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|backup
condition|)
block|{
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|addr
operator|=
operator|*
name|dst
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
operator|*
name|backup
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
block|}
name|bcopy
argument_list|(
name|sufxloc
argument_list|,
name|TSEL
argument_list|(
name|addr
argument_list|)
argument_list|,
name|sufxlen
argument_list|)
expr_stmt|;
name|addr
operator|->
name|siso_tlen
operator|=
name|sufxlen
expr_stmt|;
name|addr
operator|->
name|siso_len
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  * 	tp.trans whenever we go into REFWAIT state.  * FUNCTION and ARGUMENT:  *	 Called when a ref is frozen, to allow the suffix to be reused.   * 	(isop) is the net level pcb.  This really shouldn't have to be  * 	done in a NET level pcb but... for the internet world that just  * 	the way it is done in BSD...  * 	The alternative is to have the port unusable until the reference  * 	timer goes off.  */
end_comment

begin_function
name|void
name|iso_recycle_tsuffix
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|isop
operator|->
name|isop_laddr
operator|->
name|siso_tlen
operator|=
name|isop
operator|->
name|isop_faddr
operator|->
name|siso_tlen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  * 	tp_newsocket(); i.e., when a connection is being established by an  * 	incoming CR_TPDU.  *  * FUNCTION and ARGUMENTS:  * 	Copy a whole net addr from a struct sockaddr (name).  * 	into an isopcb (isop).  * 	The argument (which) takes values TP_LOCAL or TP_FOREIGN  */
end_comment

begin_function
name|void
name|iso_putnetaddr
parameter_list|(
name|isop
parameter_list|,
name|name
parameter_list|,
name|which
parameter_list|)
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|name
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
name|struct
name|sockaddr_iso
modifier|*
modifier|*
name|sisop
decl_stmt|,
modifier|*
name|backup
decl_stmt|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|TP_LOCAL
case|:
name|sisop
operator|=
operator|&
name|isop
operator|->
name|isop_laddr
expr_stmt|;
name|backup
operator|=
operator|&
name|isop
operator|->
name|isop_sladdr
expr_stmt|;
break|break;
case|case
name|TP_FOREIGN
case|:
name|sisop
operator|=
operator|&
name|isop
operator|->
name|isop_faddr
expr_stmt|;
name|backup
operator|=
operator|&
name|isop
operator|->
name|isop_sfaddr
expr_stmt|;
block|}
name|siso
operator|=
operator|(
operator|(
operator|*
name|sisop
operator|==
literal|0
operator|)
condition|?
operator|(
operator|*
name|sisop
operator|=
name|backup
operator|)
else|:
operator|*
name|sisop
operator|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"ISO_PUTNETADDR\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|siso
operator|->
name|siso_addr
init|=
name|name
operator|->
name|siso_addr
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  pr_usrreq() PRU_SOCKADDR, PRU_ACCEPT, PRU_PEERADDR  * FUNCTION and ARGUMENTS:  * 	Copy a whole net addr from an isopcb (isop) into  * 	a struct sockaddr (name).  * 	The argument (which) takes values TP_LOCAL or TP_FOREIGN.  */
end_comment

begin_function
name|void
name|iso_getnetaddr
parameter_list|(
name|isop
parameter_list|,
name|name
parameter_list|,
name|which
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|name
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
name|struct
name|sockaddr_iso
modifier|*
name|siso
init|=
operator|(
name|which
operator|==
name|TP_LOCAL
condition|?
name|isop
operator|->
name|isop_laddr
else|:
name|isop
operator|->
name|isop_faddr
operator|)
decl_stmt|;
if|if
condition|(
name|siso
condition|)
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|siso
argument_list|,
name|mtod
argument_list|(
name|name
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|name
operator|->
name|m_len
operator|=
name|siso
operator|->
name|siso_len
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_input() on incoming CR, CC, and pr_usrreq() for PRU_CONNECT  * FUNCTION, ARGUMENTS, SIDE EFFECTS and RETURN VALUE:  * Determine the proper maximum transmission unit, i.e., MTU, to use, given  * a) the header size for the network protocol and the max transmission  *	  unit on the subnet interface, determined from the information in (isop),  * b) the max size negotiated so far (negot)  * c) the window size used by the tp connection (found in so),  *  * The result is put in the integer *size in its integer form and in  * *negot in its logarithmic form.    *   * The rules are:  * a) can only negotiate down from the value found in *negot.  * b) the MTU must be< the windowsize,  * c) If src and dest are on the same net,  * 	  we will negotiate the closest size larger than  MTU but really USE   *    the actual device mtu - ll hdr sizes.  *   otherwise we negotiate the closest size smaller than MTU - ll hdr sizes.  */
end_comment

begin_function
name|void
name|tpclnp_mtu
parameter_list|(
name|so
parameter_list|,
name|isop
parameter_list|,
name|size
parameter_list|,
name|negot
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|int
modifier|*
name|size
decl_stmt|;
name|u_char
modifier|*
name|negot
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
literal|0
decl_stmt|;
name|struct
name|iso_ifaddr
modifier|*
name|ia
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|windowsize
init|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
decl_stmt|;
name|int
name|clnp_size
decl_stmt|;
name|int
name|sizeismtu
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_mtu(0x%x,0x%x,0x%x,0x%x)\n"
argument_list|,
name|so
argument_list|,
name|isop
argument_list|,
name|size
argument_list|,
name|negot
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"ENTER GET MTU: size negot \n"
argument_list|,
operator|*
name|size
argument_list|,
operator|*
name|negot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
modifier|*
name|size
init|=
literal|1
operator|<<
operator|*
name|negot
decl_stmt|;
if|if
condition|(
operator|*
name|size
operator|>
name|windowsize
condition|)
block|{
operator|*
name|size
operator|=
name|windowsize
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
literal|0
operator|||
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|==
literal|0
operator|)
operator|||
operator|(
name|ia
operator|=
operator|(
expr|struct
name|iso_ifaddr
operator|*
operator|)
name|rt
operator|->
name|rt_ifa
operator|)
operator|==
literal|0
operator|||
operator|(
name|ifp
operator|=
name|ia
operator|->
name|ia_ifp
operator|)
operator|==
literal|0
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_mtu routing abort rt=0x%x ia=0x%x ifp=0x%x\n"
argument_list|,
argument|rt
argument_list|,
argument|ia
argument_list|,
argument|ifp
argument_list|)
name|ENDDEBUG
return|return;
block|}
comment|/* TODO - make this indirect off the socket structure to the 	 * network layer to get headersize 	 */
if|if
condition|(
name|isop
operator|->
name|isop_laddr
condition|)
name|clnp_size
operator|=
name|clnp_hdrsize
argument_list|(
name|isop
operator|->
name|isop_laddr
operator|->
name|siso_addr
operator|.
name|isoa_len
argument_list|)
expr_stmt|;
else|else
name|clnp_size
operator|=
literal|20
expr_stmt|;
if|if
condition|(
operator|*
name|size
operator|>
name|ifp
operator|->
name|if_mtu
operator|-
name|clnp_size
condition|)
block|{
operator|*
name|size
operator|=
name|ifp
operator|->
name|if_mtu
operator|-
name|clnp_size
expr_stmt|;
name|sizeismtu
operator|=
literal|1
expr_stmt|;
block|}
comment|/* have to transform size to the log2 of size */
for|for
control|(
name|i
operator|=
name|TP_MIN_TPDUSIZE
init|;
operator|(
name|i
operator|<
name|TP_MAX_TPDUSIZE
operator|&&
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|<=
operator|*
name|size
operator|)
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|i
operator|--
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"GET MTU MID: tpcb size negot i \n"
argument_list|,
operator|*
name|size
argument_list|,
operator|*
name|negot
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
comment|/* are we on the same LAN? if so, negotiate one tpdu size larger, 	 * and actually send the real mtu size 	 */
if|if
condition|(
name|iso_localifa
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|size
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
operator|*
name|negot
operator|=
name|i
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"GET MTU RETURNS: ifp %s size 0x%x negot 0x%x\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
operator|*
name|size
argument_list|,
operator|*
name|negot
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"EXIT GET MTU: tpcb size negot \n"
argument_list|,
operator|*
name|size
argument_list|,
operator|*
name|negot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_emit()  * FUNCTION and ARGUMENTS:  *  Take a packet(m0) from tp and package it so that clnp will accept it.  *  This means prepending space for the clnp header and filling in a few  *  of the fields.  *  inp is the isopcb structure; datalen is the length of the data in the  *  mbuf string m0.  * RETURN VALUE:  *  whatever (E*) is returned form the net layer output routine.  */
end_comment

begin_function
name|int
name|tpclnp_output
parameter_list|(
name|isop
parameter_list|,
name|m0
parameter_list|,
name|datalen
parameter_list|,
name|nochksum
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|int
name|nochksum
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|IncStat
argument_list|(
name|ts_tpdu_sent
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|struct
name|tpdu
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|tpdu
operator|*
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"abt to call clnp_output: datalen 0x%x, hdr.li 0x%x, hdr.dutype 0x%x nocsum x%x dst addr:\n"
argument_list|,
name|datalen
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|->
name|tpdu_li
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|->
name|tpdu_type
argument_list|,
name|nochksum
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nsrc addr:\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|isop
operator|->
name|isop_laddr
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|m0
argument_list|,
literal|"at tpclnp_output"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|clnp_output
argument_list|(
name|m0
argument_list|,
name|isop
argument_list|,
name|datalen
argument_list|,
comment|/* flags */
name|nochksum
condition|?
name|CLNP_NO_CKSUM
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_error_emit()  * FUNCTION and ARGUMENTS:  *  This is a copy of tpclnp_output that takes the addresses  *  instead of a pcb.  It's used by the tp_error_emit, when we  *  don't have an iso_pcb with which to call the normal output rtn.  * RETURN VALUE:  *  ENOBUFS or  *  whatever (E*) is returned form the net layer output routine.  */
end_comment

begin_function
name|int
name|tpclnp_output_dg
parameter_list|(
name|laddr
parameter_list|,
name|faddr
parameter_list|,
name|m0
parameter_list|,
name|datalen
parameter_list|,
name|ro
parameter_list|,
name|nochksum
parameter_list|)
name|struct
name|iso_addr
modifier|*
name|laddr
decl_stmt|,
decl|*
name|faddr
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nochksum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|isopcb
name|tmppcb
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_output_dg  datalen 0x%x m0 0x%x\n"
argument_list|,
name|datalen
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	Fill in minimal portion of isopcb so that clnp can send the 	 *	packet. 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tmppcb
argument_list|,
sizeof|sizeof
argument_list|(
name|tmppcb
argument_list|)
argument_list|)
decl_stmt|;
name|tmppcb
operator|.
name|isop_laddr
operator|=
operator|&
name|tmppcb
operator|.
name|isop_sladdr
expr_stmt|;
name|tmppcb
operator|.
name|isop_laddr
operator|->
name|siso_addr
operator|=
operator|*
name|laddr
expr_stmt|;
name|tmppcb
operator|.
name|isop_faddr
operator|=
operator|&
name|tmppcb
operator|.
name|isop_sfaddr
expr_stmt|;
name|tmppcb
operator|.
name|isop_faddr
operator|->
name|siso_addr
operator|=
operator|*
name|faddr
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_output_dg  faddr: \n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|tmppcb
operator|.
name|isop_sfaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ntpclnp_output_dg  laddr: \n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|tmppcb
operator|.
name|isop_sladdr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	Do not use packet cache since this is a one shot error packet 	 */
name|flags
init|=
operator|(
name|CLNP_NOCACHE
operator||
operator|(
name|nochksum
condition|?
name|CLNP_NO_CKSUM
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|IncStat
argument_list|(
name|ts_tpdu_sent
argument_list|)
expr_stmt|;
name|err
operator|=
name|clnp_output
argument_list|(
name|m0
argument_list|,
operator|&
name|tmppcb
argument_list|,
name|datalen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 *	Free route allocated by clnp (if the route was indeed allocated) 	 */
if|if
condition|(
name|tmppcb
operator|.
name|isop_route
operator|.
name|ro_rt
condition|)
name|RTFREE
argument_list|(
name|tmppcb
operator|.
name|isop_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|struct
name|sockaddr_iso
name|blank_siso
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * CALLED FROM:  * 	clnp's input routine, indirectly through the protosw.  * FUNCTION and ARGUMENTS:  * Take a packet (m) from clnp, strip off the clnp header and give it to tp  * No return value.    */
end_comment

begin_function
name|ProtoHook
name|tpclnp_input
parameter_list|(
name|m
parameter_list|,
name|faddr
parameter_list|,
name|laddr
parameter_list|,
name|clnp_len
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|iso_addr
modifier|*
name|faddr
decl_stmt|,
decl|*
name|laddr
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|clnp_len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sockaddr_iso
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|tp_inputprep
parameter_list|()
function_decl|;
name|IncStat
argument_list|(
name|ts_pkt_rcvd
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_input: m 0x%x clnp_len 0x%x\n"
argument_list|,
name|m
argument_list|,
name|clnp_len
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|m
argument_list|,
literal|"at tpclnp_input"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 * CLNP gives us an mbuf chain WITH the clnp header pulled up, 	 * and the length of the clnp header. 	 * First, strip off the Clnp header. leave the mbuf there for the 	 * pullup that follows. 	 */
name|m
operator|->
name|m_len
operator|-=
name|clnp_len
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|clnp_len
expr_stmt|;
name|m
operator|=
name|tp_inputprep
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|dump_mbuf
argument_list|(
name|m
argument_list|,
literal|"after tpclnp_input both pullups"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|src
init|=
name|blank_siso
decl_stmt|;
name|dst
operator|=
name|blank_siso
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|faddr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|src
operator|.
name|siso_addr
argument_list|,
literal|1
operator|+
name|faddr
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|laddr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dst
operator|.
name|siso_addr
argument_list|,
literal|1
operator|+
name|laddr
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"calling tp_input:&src 0x%x&dst 0x%x, src addr:\n"
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" dst addr:\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|dst
argument_list|)
expr_stmt|;
name|ENDDEBUG
argument_list|(
argument|void
argument_list|)
name|tp_input
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dst
argument_list|,
literal|0
argument_list|,
name|tpclnp_output_dg
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_QUENCH
argument_list|)
block|{
if|if
condition|(
name|time
operator|.
name|tv_usec
operator|&
literal|0x4
operator|&&
name|time
operator|.
name|tv_usec
operator|&
literal|0x40
condition|)
block|{
name|printf
argument_list|(
literal|"tpclnp_input: FAKING %s\n"
argument_list|,
name|tp_stat
operator|.
name|ts_pkt_rcvd
operator|&
literal|0x1
condition|?
literal|"QUENCH"
else|:
literal|"QUENCH2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp_stat
operator|.
name|ts_pkt_rcvd
operator|&
literal|0x1
condition|)
block|{
name|tpclnp_ctlinput
argument_list|(
name|PRC_QUENCH
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tpclnp_ctlinput
argument_list|(
name|PRC_QUENCH2
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ENDDEBUG
name|splx
parameter_list|(
name|s
parameter_list|)
function_decl|;
return|return
literal|0
return|;
block|}
end_block

begin_function
name|ProtoHook
name|iso_rtchange
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tpclnp_ctlinput()  * FUNCTION and ARGUMENTS:  *  find the tpcb pointer and pass it to tp_quench  */
end_comment

begin_function
name|void
name|tpiso_decbit
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|tp_quench
argument_list|(
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_tpcb
argument_list|,
name|PRC_QUENCH2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tpclnp_ctlinput()  * FUNCTION and ARGUMENTS:  *  find the tpcb pointer and pass it to tp_quench  */
end_comment

begin_function
name|void
name|tpiso_quench
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|tp_quench
argument_list|(
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_tpcb
argument_list|,
name|PRC_QUENCH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  The network layer through the protosw table.  * FUNCTION and ARGUMENTS:  *	When clnp an ICMP-like msg this gets called.  *	It either returns an error status to the user or  *	it causes all connections on this address to be aborted  *	by calling the appropriate xx_notify() routine.  *	(cmd) is the type of ICMP error.     * 	(siso) is the address of the guy who sent the ER CLNPDU  */
end_comment

begin_function
name|ProtoHook
name|tpclnp_ctlinput
parameter_list|(
name|cmd
parameter_list|,
name|siso
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
block|{
return|return
name|tpclnp_ctlinput1
argument_list|(
name|cmd
argument_list|,
operator|&
name|siso
operator|->
name|siso_addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Entry to ctlinput with argument of an iso_addr rather than a sockaddr  */
end_comment

begin_function
name|ProtoHook
name|tpclnp_ctlinput1
parameter_list|(
name|cmd
parameter_list|,
name|isoa
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
block|{
specifier|extern
name|u_char
name|inetctlerrmap
index|[]
decl_stmt|;
specifier|extern
name|ProtoHook
name|tpiso_abort
parameter_list|()
function_decl|;
specifier|extern
name|ProtoHook
name|iso_rtchange
parameter_list|()
function_decl|;
specifier|extern
name|ProtoHook
name|tpiso_reset
parameter_list|()
function_decl|;
name|void
name|iso_pcbnotify
parameter_list|()
function_decl|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_ctlinput1: cmd 0x%x addr: %s\n"
argument_list|,
name|cmd
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|isoa
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cmd
operator|<
literal|0
operator|||
name|cmd
operator|>
name|PRC_NCMDS
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_QUENCH2
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
name|isoa
argument_list|,
literal|0
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tpiso_decbit
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_QUENCH
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
name|isoa
argument_list|,
literal|0
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tpiso_quench
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_TIMXCEED_REASS
case|:
case|case
name|PRC_ROUTEDEAD
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
name|isoa
argument_list|,
literal|0
argument_list|,
name|tpiso_reset
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_HOSTUNREACH
case|:
case|case
name|PRC_UNREACH_NET
case|:
case|case
name|PRC_IFDOWN
case|:
case|case
name|PRC_HOSTDEAD
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
name|isoa
argument_list|,
operator|(
name|int
operator|)
name|inetctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|iso_rtchange
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		case	PRC_MSGSIZE: 		case	PRC_UNREACH_HOST: 		case	PRC_UNREACH_PROTOCOL: 		case	PRC_UNREACH_PORT: 		case	PRC_UNREACH_NEEDFRAG: 		case	PRC_UNREACH_SRCFAIL: 		case	PRC_REDIRECT_NET: 		case	PRC_REDIRECT_HOST: 		case	PRC_REDIRECT_TOSNET: 		case	PRC_REDIRECT_TOSHOST: 		case	PRC_TIMXCEED_INTRANS: 		case	PRC_PARAMPROB: 		*/
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
name|isoa
argument_list|,
operator|(
name|int
operator|)
name|inetctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|tpiso_abort
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * These next 2 routines are  * CALLED FROM:  *	xxx_notify() from tp_ctlinput() when  *  net level gets some ICMP-equiv. type event.  * FUNCTION and ARGUMENTS:  *  Cause the connection to be aborted with some sort of error  *  reason indicating that the network layer caused the abort.  *  Fakes an ER TPDU so we can go through the driver.  *  abort always aborts the TP connection.  *  reset may or may not, depending on the TP class that's in use.  */
end_comment

begin_function
name|ProtoHook
name|tpiso_abort
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|struct
name|tp_event
name|e
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tpiso_abort 0x%x\n"
argument_list|,
name|isop
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|e
operator|.
name|ev_number
init|=
name|ER_TPDU
decl_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|ER_TPDU
argument_list|)
operator|.
name|e_reason
operator|=
name|ECONNABORTED
expr_stmt|;
return|return
name|tp_driver
argument_list|(
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_tpcb
argument_list|,
operator|&
name|e
argument_list|)
return|;
block|}
end_function

begin_function
name|ProtoHook
name|tpiso_reset
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|struct
name|tp_event
name|e
decl_stmt|;
name|e
operator|.
name|ev_number
operator|=
name|T_NETRESET
expr_stmt|;
return|return
name|tp_driver
argument_list|(
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_tpcb
argument_list|,
operator|&
name|e
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|ISO
end_endif

end_unit

