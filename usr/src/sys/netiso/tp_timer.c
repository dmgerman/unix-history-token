begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)tp_timer.c	7.8 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*   * ARGO TP  *  * $Header: tp_timer.c,v 5.2 88/11/18 17:29:07 nhall Exp $  * $Source: /usr/argo/sys/netiso/RCS/tp_timer.c,v $  *  * Contains all the timer code.    * There are two sources of calls to these routines:  * the clock, and tp.trans. (ok, and tp_pcb.c calls it at init time)  *  * Timers come in two flavors - those that generally get  * cancelled (tp_ctimeout, tp_cuntimeout)  * and those that either usually expire (tp_etimeout,   * tp_euntimeout, tp_slowtimo) or may require more than one instance  * of the timer active at a time.  *  * The C timers are stored in the tp_ref structure. Their "going off"  * is manifested by a driver event of the TM_xxx form.  *  * The E timers are handled like the generic kernel callouts.  * Their "going off" is manifested by a function call w/ 3 arguments.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"tp_param.h"
end_include

begin_include
include|#
directive|include
file|"tp_timer.h"
end_include

begin_include
include|#
directive|include
file|"tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"tp_pcb.h"
end_include

begin_include
include|#
directive|include
file|"tp_tpdu.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"tp_trace.h"
end_include

begin_include
include|#
directive|include
file|"tp_seq.h"
end_include

begin_decl_stmt
name|struct
name|Ecallout
modifier|*
name|TP_callfree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Ecallout
modifier|*
name|TP_callout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tp_ref
modifier|*
name|tp_ref
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|N_TPREF
init|=
literal|127
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tp_refinfo
name|tp_refinfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * CALLED FROM:  *  at autoconfig time from tp_init()   * 	a combo of event, state, predicate  * FUNCTION and ARGUMENTS:  *  initialize data structures for the timers  */
end_comment

begin_function
name|void
name|tp_timerinit
parameter_list|()
block|{
specifier|register
name|struct
name|Ecallout
modifier|*
name|e
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
define|#
directive|define
name|GETME
parameter_list|(
name|x
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|{s = (n)*sizeof(*x); x = (t) malloc(s, M_PCB, M_NOWAIT);\ if (x == 0) panic("tp_timerinit"); bzero((caddr_t)x, s);}
comment|/* 	 * Initialize storage 	 */
name|GETME
argument_list|(
name|tp_ref
argument_list|,
expr|struct
name|tp_ref
operator|*
argument_list|,
literal|1
operator|+
name|N_TPREF
argument_list|)
expr_stmt|;
name|tp_refinfo
operator|.
name|tpr_base
operator|=
name|tp_ref
expr_stmt|;
name|tp_refinfo
operator|.
name|tpr_size
operator|=
name|N_TPREF
operator|+
literal|1
expr_stmt|;
comment|/* Need to start somewhere */
undef|#
directive|undef
name|GETME
block|}
end_function

begin_comment
comment|/**********************  e timers *************************/
end_comment

begin_decl_stmt
name|int
name|Enoisy
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans all over  * FUNCTION and ARGUMENTS:  * Set an E type timer.  (refp) is the ref structure.  * Causes  fun(arg1,arg2,arg3) to be called after time t.  */
end_comment

begin_function
name|void
name|tp_etimeout
parameter_list|(
name|refp
parameter_list|,
name|fun
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|ticks
parameter_list|)
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
name|int
name|fun
decl_stmt|;
comment|/* function to be called */
name|u_int
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|int
name|arg3
decl_stmt|;
specifier|register
name|int
name|ticks
decl_stmt|;
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
init|=
name|refp
operator|->
name|tpr_pcb
decl_stmt|;
specifier|register
name|struct
name|Ccallout
modifier|*
name|callp
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TIMER
argument_list|)
name|printf
argument_list|(
literal|"etimeout pcb 0x%x state 0x%x\n"
argument_list|,
name|refp
operator|->
name|tpr_pcb
argument_list|,
name|refp
operator|->
name|tpr_pcb
operator|->
name|tp_state
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_etimeout ref refstate tks Etick"
argument_list|,
name|refp
operator|-
name|tp_ref
argument_list|,
name|refp
operator|->
name|tpr_state
argument_list|,
name|ticks
argument_list|,
name|tp_stat
operator|.
name|ts_Eticks
argument_list|)
decl_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
operator|==
literal|0
condition|)
return|return;
name|IncStat
argument_list|(
name|ts_Eset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticks
operator|==
literal|0
condition|)
name|ticks
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fun
operator|==
name|TM_data_retrans
condition|)
block|{
name|tpcb
operator|->
name|tp_retransargs
operator|.
name|c_arg1
operator|=
name|arg1
expr_stmt|;
name|tpcb
operator|->
name|tp_retransargs
operator|.
name|c_arg2
operator|=
name|arg2
expr_stmt|;
name|tpcb
operator|->
name|tp_retransargs
operator|.
name|c_arg3
operator|=
name|arg3
expr_stmt|;
block|}
name|callp
operator|=
name|tpcb
operator|->
name|tp_refcallout
operator|+
name|fun
expr_stmt|;
if|if
condition|(
name|Enoisy
operator|&&
name|callp
operator|->
name|c_time
condition|)
name|printf
argument_list|(
literal|"E timer allready set: %d of ref %d\n"
argument_list|,
name|fun
argument_list|,
name|tpcb
operator|->
name|tp_lref
argument_list|)
expr_stmt|;
if|if
condition|(
name|callp
operator|->
name|c_time
operator|==
literal|0
operator|||
name|callp
operator|->
name|c_time
operator|>
name|ticks
condition|)
name|callp
operator|->
name|c_time
operator|=
name|ticks
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans all over  * FUNCTION and ARGUMENTS:  *  Cancel all occurrences of E-timer function (fun) for reference (refp)  */
end_comment

begin_function
name|void
name|tp_euntimeout
parameter_list|(
name|refp
parameter_list|,
name|fun
parameter_list|)
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
name|int
name|fun
decl_stmt|;
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
init|=
name|refp
operator|->
name|tpr_pcb
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_euntimeout ref"
argument_list|,
name|refp
operator|-
name|tp_ref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
condition|)
name|tpcb
operator|->
name|tp_refcallout
index|[
name|fun
index|]
operator|.
name|c_time
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans, when an incoming ACK causes things to be dropped  *  from the retransmission queue, and we want their associated  *  timers to be cancelled.  *  NOTE: (by sklower) only called with TM_data_retrans.  * FUNCTION and ARGUMENTS:  *  cancel all occurrences of function (fun) where (arg2)< (seq)  */
end_comment

begin_function
name|void
name|tp_euntimeout_lss
parameter_list|(
name|refp
parameter_list|,
name|fun
parameter_list|,
name|seq
parameter_list|)
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
name|int
name|fun
decl_stmt|;
name|SeqNum
name|seq
decl_stmt|;
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
init|=
name|refp
operator|->
name|tpr_pcb
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_euntimeoutLSS ref"
argument_list|,
name|refp
operator|-
name|tp_ref
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
operator|==
literal|0
operator|||
name|tpcb
operator|->
name|tp_refcallout
index|[
name|fun
index|]
operator|.
name|c_time
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_retransargs
operator|.
name|c_arg2
argument_list|,
name|seq
argument_list|)
condition|)
block|{
name|IncStat
argument_list|(
name|ts_Ecan_act
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_refcallout
index|[
name|fun
index|]
operator|.
name|c_time
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************  c timers **********************  *  * These are not chained together; they sit  * in the tp_ref structure. they are the kind that  * are typically cancelled so it's faster not to  * mess with the chains  */
end_comment

begin_comment
comment|/*  * CALLED FROM:  *  the clock, every 500 ms  * FUNCTION and ARGUMENTS:  *  Look for open references with active timers.  *  If they exist, call the appropriate timer routines to update  *  the timers and possibly generate events.  *  (The E timers are done in other procedures; the C timers are  *  updated here, and events for them are generated here.)  */
end_comment

begin_function
name|ProtoHook
name|tp_slowtimo
parameter_list|()
block|{
specifier|register
name|struct
name|Ccallout
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpbase
decl_stmt|;
specifier|register
name|struct
name|tp_ref
modifier|*
name|rp
decl_stmt|;
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|struct
name|tp_event
name|E
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|,
name|t
decl_stmt|;
comment|/* check only open reference structures */
name|IncStat
argument_list|(
name|ts_Cticks
argument_list|)
expr_stmt|;
comment|/* tp_ref[0] is never used */
for|for
control|(
name|rp
operator|=
name|tp_ref
operator|+
name|tp_refinfo
operator|.
name|tpr_maxopen
init|;
name|rp
operator|>
name|tp_ref
condition|;
name|rp
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|tpcb
operator|=
name|rp
operator|->
name|tpr_pcb
operator|)
operator|==
literal|0
operator|||
name|rp
operator|->
name|tpr_state
operator|<
name|REF_OPEN
condition|)
continue|continue;
name|cpbase
operator|=
name|tpcb
operator|->
name|tp_refcallout
expr_stmt|;
name|t
operator|=
name|N_CTIMERS
expr_stmt|;
comment|/* check the C-type timers */
for|for
control|(
name|cp
operator|=
name|cpbase
operator|+
name|t
init|;
operator|(
operator|--
name|t
operator|,
operator|--
name|cp
operator|)
operator|>=
name|cpbase
condition|;
control|)
block|{
if|if
condition|(
name|cp
operator|->
name|c_time
operator|&&
operator|--
operator|(
name|cp
operator|->
name|c_time
operator|)
operator|<=
literal|0
condition|)
block|{
name|cp
operator|->
name|c_time
operator|=
literal|0
expr_stmt|;
name|E
operator|.
name|ev_number
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TM_data_retrans
condition|)
block|{
specifier|register
name|struct
name|Ecallarg
modifier|*
name|p1
init|=
operator|&
name|tpcb
operator|->
name|tp_retransargs
decl_stmt|;
name|E
operator|.
name|ATTR
argument_list|(
name|TM_data_retrans
argument_list|)
operator|.
name|e_low
operator|=
operator|(
name|SeqNum
operator|)
name|p1
operator|->
name|c_arg1
expr_stmt|;
name|E
operator|.
name|ATTR
argument_list|(
name|TM_data_retrans
argument_list|)
operator|.
name|e_high
operator|=
operator|(
name|SeqNum
operator|)
name|p1
operator|->
name|c_arg2
expr_stmt|;
name|E
operator|.
name|ATTR
argument_list|(
name|TM_data_retrans
argument_list|)
operator|.
name|e_retrans
operator|=
name|p1
operator|->
name|c_arg3
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_TIMER
argument_list|)
name|printf
argument_list|(
literal|"C expired! type 0x%x\n"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IncStat
argument_list|(
name|ts_Cexpired
argument_list|)
decl_stmt|;
name|tp_driver
argument_list|(
name|rp
operator|->
name|tpr_pcb
argument_list|,
operator|&
name|E
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TM_reference
operator|&&
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CLOSED
condition|)
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_notdetached
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"PRU_DETACH: not detached\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tp_detach
argument_list|(
name|tpcb
argument_list|)
decl_stmt|;
block|}
comment|/* XXX wart; where else to do it? */
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans, tp_emit()  * FUNCTION and ARGUMENTS:  * 	Set a C type timer of type (which) to go off after (ticks) time.  */
end_comment

begin_function
name|void
name|tp_ctimeout
parameter_list|(
name|refp
parameter_list|,
name|which
parameter_list|,
name|ticks
parameter_list|)
specifier|register
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
name|int
name|which
decl_stmt|,
name|ticks
decl_stmt|;
block|{
specifier|register
name|struct
name|Ccallout
modifier|*
name|cp
init|=
operator|&
operator|(
name|refp
operator|->
name|tpr_callout
index|[
name|which
index|]
operator|)
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_ctimeout ref which tpcb active"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|refp
operator|-
name|tp_ref
argument_list|)
argument_list|,
name|which
argument_list|,
name|refp
operator|->
name|tpr_pcb
argument_list|,
name|cp
operator|->
name|c_time
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|cp
operator|->
name|c_time
condition|)
name|IncStat
argument_list|(
name|ts_Ccan_act
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|ts_Cset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticks
operator|<=
literal|0
condition|)
name|ticks
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|c_time
operator|=
name|ticks
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans   * FUNCTION and ARGUMENTS:  * 	Version of tp_ctimeout that resets the C-type time if the   * 	parameter (ticks) is> the current value of the timer.  */
end_comment

begin_function
name|void
name|tp_ctimeout_MIN
parameter_list|(
name|refp
parameter_list|,
name|which
parameter_list|,
name|ticks
parameter_list|)
specifier|register
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
name|int
name|which
decl_stmt|,
name|ticks
decl_stmt|;
block|{
specifier|register
name|struct
name|Ccallout
modifier|*
name|cp
init|=
operator|&
operator|(
name|refp
operator|->
name|tpr_callout
index|[
name|which
index|]
operator|)
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_ctimeout_MIN ref which tpcb active"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|refp
operator|-
name|tp_ref
argument_list|)
argument_list|,
name|which
argument_list|,
name|refp
operator|->
name|tpr_pcb
argument_list|,
name|cp
operator|->
name|c_time
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IncStat
argument_list|(
name|ts_Cset
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_time
condition|)
block|{
name|cp
operator|->
name|c_time
operator|=
name|MIN
argument_list|(
name|ticks
argument_list|,
name|cp
operator|->
name|c_time
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|ts_Ccan_act
argument_list|)
expr_stmt|;
block|}
else|else
name|cp
operator|->
name|c_time
operator|=
name|ticks
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans  * FUNCTION and ARGUMENTS:  *  Cancel the (which) timer in the ref structure indicated by (refp).  */
end_comment

begin_function
name|void
name|tp_cuntimeout
parameter_list|(
name|refp
parameter_list|,
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
specifier|register
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
block|{
specifier|register
name|struct
name|Ccallout
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
operator|&
operator|(
name|refp
operator|->
name|tpr_callout
index|[
name|which
index|]
operator|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TIMER
argument_list|)
name|printf
argument_list|(
literal|"tp_cuntimeout(0x%x, %d) active %d\n"
argument_list|,
name|refp
argument_list|,
name|which
argument_list|,
name|cp
operator|->
name|c_time
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_cuntimeout ref which, active"
argument_list|,
name|refp
operator|-
name|tp_ref
argument_list|,
name|which
argument_list|,
name|cp
operator|->
name|c_time
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
if|if
condition|(
name|cp
operator|->
name|c_time
condition|)
name|IncStat
argument_list|(
name|ts_Ccan_act
argument_list|)
expr_stmt|;
else|else
name|IncStat
argument_list|(
name|ts_Ccan_inact
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_time
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

