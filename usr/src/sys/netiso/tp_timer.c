begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)tp_timer.c	7.11 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*   * ARGO TP  *  * $Header: tp_timer.c,v 5.2 88/11/18 17:29:07 nhall Exp $  * $Source: /usr/argo/sys/netiso/RCS/tp_timer.c,v $  *  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"tp_param.h"
end_include

begin_include
include|#
directive|include
file|"tp_timer.h"
end_include

begin_include
include|#
directive|include
file|"tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"tp_pcb.h"
end_include

begin_include
include|#
directive|include
file|"tp_tpdu.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"tp_trace.h"
end_include

begin_include
include|#
directive|include
file|"tp_seq.h"
end_include

begin_decl_stmt
name|struct
name|tp_ref
modifier|*
name|tp_ref
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tp_rttdiv
decl_stmt|,
name|tp_rttadd
decl_stmt|,
name|N_TPREF
init|=
literal|127
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tp_refinfo
name|tp_refinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tp_pcb
modifier|*
name|tp_ftimeolist
init|=
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
operator|&
name|tp_ftimeolist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * CALLED FROM:  *  at autoconfig time from tp_init()   * 	a combo of event, state, predicate  * FUNCTION and ARGUMENTS:  *  initialize data structures for the timers  */
end_comment

begin_function
name|void
name|tp_timerinit
parameter_list|()
block|{
specifier|register
name|int
name|s
decl_stmt|;
comment|/* 	 * Initialize storage 	 */
if|if
condition|(
name|tp_refinfo
operator|.
name|tpr_base
condition|)
return|return;
name|tp_refinfo
operator|.
name|tpr_size
operator|=
name|N_TPREF
operator|+
literal|1
expr_stmt|;
comment|/* Need to start somewhere */
name|s
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tp_ref
argument_list|)
operator|*
name|tp_refinfo
operator|.
name|tpr_size
expr_stmt|;
if|if
condition|(
operator|(
name|tp_ref
operator|=
operator|(
expr|struct
name|tp_ref
operator|*
operator|)
name|malloc
argument_list|(
name|s
argument_list|,
name|M_PCB
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"tp_timerinit"
argument_list|)
expr_stmt|;
name|tp_refinfo
operator|.
name|tpr_base
operator|=
name|tp_ref
expr_stmt|;
name|tp_rttdiv
operator|=
name|hz
operator|/
name|PR_SLOWHZ
expr_stmt|;
name|tp_rttadd
operator|=
operator|(
literal|2
operator|*
name|tp_rttdiv
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TP_DEBUG_TIMERS
end_ifdef

begin_comment
comment|/**********************  e timers *************************/
end_comment

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans all over  * FUNCTION and ARGUMENTS:  * Set an E type timer.  */
end_comment

begin_function
name|void
name|tp_etimeout
parameter_list|(
name|tpcb
parameter_list|,
name|fun
parameter_list|,
name|ticks
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|int
name|fun
decl_stmt|;
comment|/* function to be called */
name|int
name|ticks
decl_stmt|;
block|{
specifier|register
name|u_int
modifier|*
name|callp
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TIMER
argument_list|)
name|printf
argument_list|(
literal|"etimeout pcb 0x%x state 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_state
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_etimeout ref refstate tks Etick"
argument_list|,
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|tpcb
operator|->
name|tp_state
argument_list|,
name|ticks
argument_list|,
name|tp_stat
operator|.
name|ts_Eticks
argument_list|)
decl_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
operator|==
literal|0
condition|)
return|return;
name|IncStat
argument_list|(
name|ts_Eset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticks
operator|==
literal|0
condition|)
name|ticks
operator|=
literal|1
expr_stmt|;
name|callp
operator|=
name|tpcb
operator|->
name|tp_timer
operator|+
name|fun
expr_stmt|;
if|if
condition|(
operator|*
name|callp
operator|==
literal|0
operator|||
operator|*
name|callp
operator|>
name|ticks
condition|)
operator|*
name|callp
operator|=
name|ticks
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans all over  * FUNCTION and ARGUMENTS:  *  Cancel all occurrences of E-timer function (fun) for reference (refp)  */
end_comment

begin_function
name|void
name|tp_euntimeout
parameter_list|(
name|tpcb
parameter_list|,
name|fun
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|int
name|fun
decl_stmt|;
block|{
name|IFTRACE
argument_list|(
argument|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_euntimeout ref"
argument_list|,
name|tpcb
operator|->
name|tp_lref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
condition|)
name|tpcb
operator|->
name|tp_timer
index|[
name|fun
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************  c timers **********************  *  * These are not chained together; they sit  * in the tp_ref structure. they are the kind that  * are typically cancelled so it's faster not to  * mess with the chains  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * CALLED FROM:  *  the clock, every 500 ms  * FUNCTION and ARGUMENTS:  *  Look for open references with active timers.  *  If they exist, call the appropriate timer routines to update  *  the timers and possibly generate events.  *  (The E timers are done in other procedures; the C timers are  *  updated here, and events for them are generated here.)  */
end_comment

begin_function
name|ProtoHook
name|tp_slowtimo
parameter_list|()
block|{
specifier|register
name|u_int
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpbase
decl_stmt|;
specifier|register
name|struct
name|tp_ref
modifier|*
name|rp
decl_stmt|;
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|struct
name|tp_event
name|E
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|,
name|t
decl_stmt|;
comment|/* check only open reference structures */
name|IncStat
argument_list|(
name|ts_Cticks
argument_list|)
expr_stmt|;
comment|/* tp_ref[0] is never used */
for|for
control|(
name|rp
operator|=
name|tp_ref
operator|+
name|tp_refinfo
operator|.
name|tpr_maxopen
init|;
name|rp
operator|>
name|tp_ref
condition|;
name|rp
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|tpcb
operator|=
name|rp
operator|->
name|tpr_pcb
operator|)
operator|==
literal|0
operator|||
name|tpcb
operator|->
name|tp_refstate
operator|<
name|REF_OPEN
condition|)
continue|continue;
name|cpbase
operator|=
name|tpcb
operator|->
name|tp_timer
expr_stmt|;
name|t
operator|=
name|TM_NTIMERS
expr_stmt|;
comment|/* check the timers */
for|for
control|(
name|cp
operator|=
name|cpbase
operator|+
name|t
init|;
operator|(
operator|--
name|t
operator|,
operator|--
name|cp
operator|)
operator|>=
name|cpbase
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|&&
operator|--
operator|(
operator|*
name|cp
operator|)
operator|<=
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|E
operator|.
name|ev_number
operator|=
name|t
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TIMER
argument_list|)
name|printf
argument_list|(
literal|"C expired! type 0x%x\n"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IncStat
argument_list|(
name|ts_Cexpired
argument_list|)
decl_stmt|;
name|tp_driver
argument_list|(
name|rp
operator|->
name|tpr_pcb
argument_list|,
operator|&
name|E
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TM_reference
operator|&&
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CLOSED
condition|)
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_notdetached
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"PRU_DETACH: not detached\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tp_detach
argument_list|(
name|tpcb
argument_list|)
decl_stmt|;
block|}
comment|/* XXX wart; where else to do it? */
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Called From: tp.trans from tp_slowtimo() -- retransmission timer went off.  */
end_comment

begin_expr_stmt
name|tp_data_retrans
argument_list|(
name|tpcb
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|rexmt
decl_stmt|,
name|win
decl_stmt|;
name|tpcb
operator|->
name|tp_rttemit
operator|=
literal|0
expr_stmt|;
comment|/* cancel current round trip time */
name|tpcb
operator|->
name|tp_dupacks
operator|=
literal|0
expr_stmt|;
name|tpcb
operator|->
name|tp_sndnxt
operator|=
name|tpcb
operator|->
name|tp_snduna
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_fcredit
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We transmitted new data, started timing it and the window 		 * got shrunk under us.  This can only happen if all data 		 * that they wanted us to send got acked, so don't 		 * bother shrinking the congestion windows, et. al. 		 * The retransmission timer should have been reset in goodack() 		 */
name|tpcb
operator|->
name|tp_rxtshift
operator|=
literal|0
expr_stmt|;
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_data_retrans
index|]
operator|=
literal|0
expr_stmt|;
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_sendack
index|]
operator|=
name|tpcb
operator|->
name|tp_dt_ticks
expr_stmt|;
block|}
name|rexmt
operator|=
name|tpcb
operator|->
name|tp_dt_ticks
operator|<<
name|min
argument_list|(
name|tpcb
operator|->
name|tp_rxtshift
argument_list|,
name|TP_MAXRXTSHIFT
argument_list|)
expr_stmt|;
name|win
operator|=
name|min
argument_list|(
name|tpcb
operator|->
name|tp_fcredit
argument_list|,
operator|(
name|tpcb
operator|->
name|tp_cong_win
operator|/
name|tpcb
operator|->
name|tp_l_tpdusize
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
name|win
operator|=
name|max
argument_list|(
name|win
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_cong_win
operator|=
name|tpcb
operator|->
name|tp_l_tpdusize
expr_stmt|;
comment|/* slow start again. */
name|tpcb
operator|->
name|tp_ssthresh
operator|=
name|win
operator|*
name|tpcb
operator|->
name|tp_l_tpdusize
expr_stmt|;
comment|/* We're losing; our srtt estimate is probably bogus. 	 * Clobber it so we'll take the next rtt measurement as our srtt; 	 * Maintain current rxt times until then. 	 */
if|if
condition|(
operator|++
name|tpcb
operator|->
name|tp_rxtshift
operator|>
name|TP_NRETRANS
operator|/
literal|4
condition|)
block|{
comment|/* tpcb->tp_nlprotosw->nlp_losing(tpcb->tp_npcb) someday */
name|tpcb
operator|->
name|tp_rtt
operator|=
literal|0
expr_stmt|;
block|}
name|TP_RANGESET
argument_list|(
name|tpcb
operator|->
name|tp_rxtcur
argument_list|,
name|rexmt
argument_list|,
name|tpcb
operator|->
name|tp_peer_acktime
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_data_retrans
index|]
operator|=
name|tpcb
operator|->
name|tp_rxtcur
expr_stmt|;
name|tp_send
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|tp_fasttimo
parameter_list|()
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
name|t
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|struct
name|tp_event
name|E
decl_stmt|;
name|E
operator|.
name|ev_number
operator|=
name|TM_sendack
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|tp_ftimeolist
operator|)
operator|!=
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
operator|&
name|tp_ftimeolist
condition|)
block|{
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"tp_fasttimeo: should panic"
argument_list|)
expr_stmt|;
name|tp_ftimeolist
operator|=
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
operator|&
name|tp_ftimeolist
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t
operator|->
name|tp_flags
operator|&
name|TPF_DELACK
condition|)
block|{
name|t
operator|->
name|tp_flags
operator|&=
operator|~
name|TPF_DELACK
expr_stmt|;
name|IncStat
argument_list|(
name|ts_Fdelack
argument_list|)
expr_stmt|;
name|tp_driver
argument_list|(
name|t
argument_list|,
operator|&
name|E
argument_list|)
expr_stmt|;
name|t
operator|->
name|tp_timer
index|[
name|TM_sendack
index|]
operator|=
name|t
operator|->
name|tp_keepalive_ticks
expr_stmt|;
block|}
else|else
name|IncStat
argument_list|(
name|ts_Fpruned
argument_list|)
expr_stmt|;
name|tp_ftimeolist
operator|=
name|t
operator|->
name|tp_fasttimeo
expr_stmt|;
name|t
operator|->
name|tp_fasttimeo
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TP_DEBUG_TIMERS
end_ifdef

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans, tp_emit()  * FUNCTION and ARGUMENTS:  * 	Set a C type timer of type (which) to go off after (ticks) time.  */
end_comment

begin_function
name|void
name|tp_ctimeout
parameter_list|(
name|tpcb
parameter_list|,
name|which
parameter_list|,
name|ticks
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|int
name|which
decl_stmt|,
name|ticks
decl_stmt|;
block|{
name|IFTRACE
argument_list|(
argument|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_ctimeout ref which tpcb active"
argument_list|,
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|which
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_timer
index|[
name|which
index|]
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
operator|->
name|tp_timer
index|[
name|which
index|]
condition|)
name|IncStat
argument_list|(
name|ts_Ccan_act
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|ts_Cset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticks
operator|<=
literal|0
condition|)
name|ticks
operator|=
literal|1
expr_stmt|;
name|tpcb
operator|->
name|tp_timer
index|[
name|which
index|]
operator|=
name|ticks
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans   * FUNCTION and ARGUMENTS:  * 	Version of tp_ctimeout that resets the C-type time if the   * 	parameter (ticks) is> the current value of the timer.  */
end_comment

begin_function
name|void
name|tp_ctimeout_MIN
parameter_list|(
name|tpcb
parameter_list|,
name|which
parameter_list|,
name|ticks
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|int
name|which
decl_stmt|,
name|ticks
decl_stmt|;
block|{
name|IFTRACE
argument_list|(
argument|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_ctimeout_MIN ref which tpcb active"
argument_list|,
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|which
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_timer
index|[
name|which
index|]
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IncStat
argument_list|(
name|ts_Cset
argument_list|)
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_timer
index|[
name|which
index|]
condition|)
block|{
name|tpcb
operator|->
name|tp_timer
index|[
name|which
index|]
operator|=
name|MIN
argument_list|(
name|ticks
argument_list|,
name|tpcb
operator|->
name|tp_timer
index|[
name|which
index|]
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|ts_Ccan_act
argument_list|)
expr_stmt|;
block|}
else|else
name|tpcb
operator|->
name|tp_timer
index|[
name|which
index|]
operator|=
name|ticks
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans  * FUNCTION and ARGUMENTS:  *  Cancel the (which) timer in the ref structure indicated by (refp).  */
end_comment

begin_function
name|void
name|tp_cuntimeout
parameter_list|(
name|tpcb
parameter_list|,
name|which
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
name|IFDEBUG
argument_list|(
argument|D_TIMER
argument_list|)
name|printf
argument_list|(
literal|"tp_cuntimeout(0x%x, %d) active %d\n"
argument_list|,
name|tpcb
argument_list|,
name|which
argument_list|,
name|tpcb
operator|->
name|tp_timer
index|[
name|which
index|]
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_cuntimeout ref which, active"
argument_list|,
name|refp
operator|-
name|tp_ref
argument_list|,
name|which
argument_list|,
name|tpcb
operator|->
name|tp_timer
index|[
name|which
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
operator|->
name|tp_timer
index|[
name|which
index|]
condition|)
name|IncStat
argument_list|(
name|ts_Ccan_act
argument_list|)
expr_stmt|;
else|else
name|IncStat
argument_list|(
name|ts_Ccan_inact
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_timer
index|[
name|which
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

