begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/* $Header: clnp_raw.c,v 4.2 88/06/29 14:58:56 hagens Exp $ */
end_comment

begin_comment
comment|/* $Source: /usr/argo/sys/netiso/RCS/clnp_raw.c,v $ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: clnp_raw.c,v 4.2 88/06/29 14:58:56 hagens Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|"../h/types.h"
end_include

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/domain.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/time.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../net/raw_cb.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/clnp.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/clnp_stat.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/argo_debug.h"
end_include

begin_decl_stmt
name|struct
name|sockaddr_iso
name|rclnp_src
init|=
block|{
name|AF_ISO
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_iso
name|rclnp_dst
init|=
block|{
name|AF_ISO
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockproto
name|rclnp_proto
init|=
block|{
name|PF_ISO
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FUNCTION:		rclnp_input  *  * PURPOSE:			Setup generic address an protocol structures for  *					raw input routine, then pass them along with the  *					mbuf chain.  *  * RETURNS:			none  *  * SIDE EFFECTS:	  *  * NOTES:			The protocol field of rclnp_proto is set to zero indicating  *					no protocol.  */
end_comment

begin_macro
name|rclnp_input
argument_list|(
argument|m
argument_list|,
argument|src
argument_list|,
argument|dst
argument_list|,
argument|hdrlen
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to packet */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|src
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to src address */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to dest address */
end_comment

begin_decl_stmt
name|int
name|hdrlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length (in bytes) of clnp header */
end_comment

begin_block
block|{
ifdef|#
directive|ifdef
name|TROLL
if|if
condition|(
name|trollctl
operator|.
name|tr_ops
operator|&
name|TR_CHUCK
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|TROLL
name|rclnp_src
operator|.
name|siso_addr
operator|=
operator|*
name|src
expr_stmt|;
name|rclnp_dst
operator|.
name|siso_addr
operator|=
operator|*
name|dst
expr_stmt|;
name|raw_input
argument_list|(
name|m
argument_list|,
operator|&
name|rclnp_proto
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rclnp_src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rclnp_dst
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		rclnp_output  *  * PURPOSE:			Prepare to send a raw clnp packet. Setup src and dest  *					addresses, count the number of bytes to send, and  *					call clnp_output.  *  * RETURNS:			success - 0  *					failure - an appropriate error code  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|rclnp_output
argument_list|(
argument|m0
argument_list|,
argument|so
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packet to send */
end_comment

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket to send from */
end_comment

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* used to scan a chain */
name|int
name|len
init|=
literal|0
decl_stmt|;
comment|/* store length of chain here */
name|struct
name|rawcb
modifier|*
name|rp
init|=
name|sotorawcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
comment|/* ptr to raw cb */
name|int
name|error
decl_stmt|;
comment|/* return value of function */
name|u_int
name|flags
decl_stmt|;
comment|/* flags for clnp_output */
name|struct
name|isopcb
name|isopcb
decl_stmt|;
comment|/* isopcb used to interface w/clnp */
comment|/* Calculate length of data */
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|isopcb
argument_list|,
sizeof|sizeof
argument_list|(
name|isopcb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *	Set up src address. If user has bound socket to an address, use it. 	 *	Otherwise, do not specify src (clnp_output will fill it in). 	 */
if|if
condition|(
name|rp
operator|->
name|rcb_flags
operator|&
name|RAW_LADDR
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|rcb_laddr
operator|.
name|sa_family
operator|!=
name|AF_ISO
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rp
operator|->
name|rcb_laddr
argument_list|,
operator|&
name|isopcb
operator|.
name|isop_laddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* set up route structure, if route is present */
if|if
condition|(
name|rp
operator|->
name|rcb_route
operator|.
name|ro_rt
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rp
operator|->
name|rcb_route
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|isopcb
operator|.
name|isop_route
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|route
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set up dest address */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rp
operator|->
name|rcb_faddr
argument_list|,
operator|&
name|isopcb
operator|.
name|isop_faddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  	 *	setup option index - this was done when option was set, but raw 	 *	cb has no place to put it. 	 */
if|if
condition|(
name|rp
operator|->
name|rcb_options
operator|!=
name|NULL
condition|)
block|{
name|isopcb
operator|.
name|isop_options
operator|=
name|rp
operator|->
name|rcb_options
expr_stmt|;
name|isopcb
operator|.
name|isop_optindex
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clnp_opt_sanity
argument_list|(
name|isopcb
operator|.
name|isop_options
argument_list|,
name|mtod
argument_list|(
name|isopcb
operator|.
name|isop_options
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|isopcb
operator|.
name|isop_options
operator|->
name|m_len
argument_list|,
name|mtod
argument_list|(
name|isopcb
operator|.
name|isop_optindex
argument_list|,
expr|struct
name|clnp_optidx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* get flags and ship it off */
name|flags
operator|=
name|rp
operator|->
name|rcb_flags
operator|&
name|CLNP_VFLAGS
expr_stmt|;
ifdef|#
directive|ifdef
name|TROLL
if|if
condition|(
name|trollctl
operator|.
name|tr_ops
operator|&
name|TR_BLAST
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|start
decl_stmt|,
name|stop
decl_stmt|;
specifier|extern
name|struct
name|timeval
name|time
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf_orig
decl_stmt|;
name|mbuf_orig
operator|=
name|m0
expr_stmt|;
name|start
operator|=
name|time
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|trollctl
operator|.
name|tr_blast_cnt
condition|;
name|i
operator|++
control|)
block|{
name|m0
operator|=
name|m_copy
argument_list|(
name|mbuf_orig
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|clnp_output
argument_list|(
name|m0
argument_list|,
operator|&
name|isopcb
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|stop
operator|=
name|time
expr_stmt|;
name|printf
argument_list|(
literal|"rclnp_output: %d pkts in %d sec\n"
argument_list|,
name|i
argument_list|,
name|stop
operator|.
name|tv_sec
operator|-
name|start
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mbuf_orig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *	Don't bother creating the cache since this is raw; probably 		 *	a one shot send 		 */
name|error
operator|=
name|clnp_output
argument_list|(
name|m0
argument_list|,
operator|&
name|isopcb
argument_list|,
name|len
argument_list|,
name|flags
operator||
name|CLNP_NOCACHE
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|error
operator|=
name|clnp_output
argument_list|(
name|m0
argument_list|,
operator|&
name|isopcb
argument_list|,
name|len
argument_list|,
name|flags
operator||
name|CLNP_NOCACHE
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TROLL
if|if
condition|(
name|isopcb
operator|.
name|isop_route
operator|.
name|ro_rt
condition|)
name|RTFREE
argument_list|(
name|isopcb
operator|.
name|isop_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
comment|/* free clnp cached hdr if necessary */
if|if
condition|(
name|isopcb
operator|.
name|isop_clnpcache
operator|!=
name|NULL
condition|)
block|{
name|struct
name|clnp_cache
modifier|*
name|clcp
init|=
name|mtod
argument_list|(
name|isopcb
operator|.
name|isop_clnpcache
argument_list|,
expr|struct
name|clnp_cache
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|clcp
operator|->
name|clc_hdr
operator|!=
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|clcp
operator|->
name|clc_hdr
argument_list|)
expr_stmt|;
block|}
name|m_free
argument_list|(
name|isopcb
operator|.
name|isop_clnpcache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isopcb
operator|.
name|isop_optindex
operator|!=
name|NULL
condition|)
name|m_free
argument_list|(
name|isopcb
operator|.
name|isop_optindex
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		rclnp_ctloutput  *  * PURPOSE:			Raw clnp socket option processing  *					All options are stored inside an mbuf.   *  * RETURNS:			success - 0  *					failure - unix error code  *  * SIDE EFFECTS:	If the options mbuf does not exist, it the mbuf passed  *					is used.  *  * NOTES:			  */
end_comment

begin_macro
name|rclnp_ctloutput
argument_list|(
argument|op
argument_list|,
argument|so
argument_list|,
argument|level
argument_list|,
argument|optname
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of operation */
end_comment

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to socket */
end_comment

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* level of option */
end_comment

begin_decl_stmt
name|int
name|optname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of option */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to ptr to option data */
end_comment

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|rawcb
modifier|*
name|rp
init|=
name|sotorawcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
comment|/* raw cb ptr */
name|IFDEBUG
argument_list|(
argument|D_CTLOUTPUT
argument_list|)
name|printf
argument_list|(
literal|"rclnp_ctloutput: op = x%x, level = x%x, name = x%x\n"
argument_list|,
name|op
argument_list|,
name|level
argument_list|,
name|optname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|m
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rclnp_ctloutput: %d bytes of mbuf data\n"
argument_list|,
operator|(
operator|*
name|m
operator|)
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|mtod
argument_list|(
operator|(
operator|*
name|m
operator|)
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
operator|*
name|m
operator|)
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
ifdef|#
directive|ifdef
name|SOL_NETWORK
if|if
condition|(
name|level
operator|!=
name|SOL_NETWORK
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
switch|switch
condition|(
name|op
condition|)
block|{
else|#
directive|else
switch|switch
condition|(
name|op
condition|)
block|{
endif|#
directive|endif
endif|SOL_NETWORK
case|case
name|PRCO_SETOPT
case|:
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|CLNPOPT_FLAGS
case|:
block|{
name|u_short
name|usr_flags
decl_stmt|;
comment|/*  					 *	Insure that the data passed has exactly one short in it  					 */
if|if
condition|(
operator|(
operator|*
name|m
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_len
operator|!=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 					 *	Don't allow invalid flags to be set 					 */
name|usr_flags
operator|=
operator|(
operator|*
name|mtod
argument_list|(
operator|(
operator|*
name|m
operator|)
argument_list|,
name|short
operator|*
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|usr_flags
operator|&
operator|(
name|CLNP_VFLAGS
operator|)
operator|)
operator|!=
name|usr_flags
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
name|rp
operator|->
name|rcb_flags
operator||=
name|usr_flags
expr_stmt|;
block|}
break|break;
case|case
name|CLNPOPT_OPTS
case|:
name|error
operator|=
name|clnp_set_opts
argument_list|(
operator|&
name|rp
operator|->
name|rcb_options
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PRCO_GETOPT
case|:
ifdef|#
directive|ifdef
name|notdef
comment|/* commented out to keep hi C quiet */
switch|switch
condition|(
name|optname
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
endif|notdef
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op
operator|==
name|PRCO_SETOPT
condition|)
block|{
comment|/* note: m_freem does not barf is *m is NULL */
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
comment|/*ARGSUSED*/
name|clnp_usrreq
argument_list|(
argument|so
argument_list|,
argument|req
argument_list|,
argument|m
argument_list|,
argument|nam
argument_list|,
argument|rights
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|req
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nam
decl_stmt|,
modifier|*
name|rights
decl_stmt|;
block|{
return|return
name|EPROTOTYPE
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|ISO
end_endif

end_unit

