begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/* $Header: iso_snpac.c,v 1.8 88/09/19 13:51:36 hagens Exp $ */
end_comment

begin_comment
comment|/* $Source: /usr/argo/sys/netiso/RCS/iso_snpac.c,v $ */
end_comment

begin_comment
comment|/*	@(#)iso_snpac.c	7.10 (Berkeley) %G% */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: iso_snpac.c,v 1.8 88/09/19 13:51:36 hagens Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/if_dl.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"iso_var.h"
end_include

begin_include
include|#
directive|include
file|"iso_snpac.h"
end_include

begin_include
include|#
directive|include
file|"clnp.h"
end_include

begin_include
include|#
directive|include
file|"clnp_stat.h"
end_include

begin_include
include|#
directive|include
file|"esis.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_decl_stmt
name|int
name|iso_systype
init|=
name|SNPA_ES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default to be an ES */
end_comment

begin_decl_stmt
specifier|extern
name|short
name|esis_holding_time
decl_stmt|,
name|esis_config_time
decl_stmt|,
name|esis_esconfig_time
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|esis_config
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|sockaddr_iso
name|blank_siso
init|=
block|{
sizeof|sizeof
argument_list|(
name|blank_siso
argument_list|)
block|,
name|AF_ISO
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|u_long
name|iso_hashchar
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_iso
name|dst
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_ISO
block|}
decl_stmt|,
name|gte
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_ISO
block|}
decl_stmt|,
name|src
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_ISO
block|}
decl_stmt|,
name|msk
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_ISO
block|}
decl_stmt|,
name|zmk
init|=
block|{
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|zsi
value|blank_siso
end_define

begin_define
define|#
directive|define
name|zero_isoa
value|zsi.siso_addr
end_define

begin_define
define|#
directive|define
name|zap_isoaddr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(bzero((caddr_t)&a.siso_addr, sizeof(*r)), \ 	   ((r = b)&& bcopy((caddr_t)r, (caddr_t)&a.siso_addr, 1 + (r)->isoa_len)))
end_define

begin_define
define|#
directive|define
name|S
parameter_list|(
name|x
parameter_list|)
value|((struct sockaddr *)&(x))
end_define

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_dl
name|blank_dl
init|=
block|{
sizeof|sizeof
argument_list|(
name|blank_dl
argument_list|)
block|,
name|AF_LINK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_dl
name|gte_dl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|zap_linkaddr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|i
parameter_list|)
define|\
value|(*a = blank_dl, bcopy(b, a->sdl_data, a->sdl_alen = c), a->sdl_index = i)
end_define

begin_comment
comment|/*  *	We only keep track of a single IS at a time.  */
end_comment

begin_decl_stmt
name|struct
name|rtentry
modifier|*
name|known_is
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Addresses taken from NBS agreements, December 1987.  *  *	These addresses assume on-the-wire transmission of least significant  *	bit first. This is the method used by 802.3. When these  *	addresses are passed to the token ring driver, (802.5), they  *	must be bit-swaped because 802.5 transmission order is MSb first.  *  *	Furthermore, according to IBM Austin, these addresses are not  *	true token ring multicast addresses. More work is necessary  *	to get multicast to work right on token ring.  *  *	Currently, the token ring driver does not handle multicast, so  *	these addresses are converted into the broadcast address in  *	lan_output() That means that if these multicast addresses change  *	the token ring driver must be altered.  */
end_comment

begin_decl_stmt
name|char
name|all_es_snpa
index|[]
init|=
block|{
literal|0x09
block|,
literal|0x00
block|,
literal|0x2b
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x04
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|all_is_snpa
index|[]
init|=
block|{
literal|0x09
block|,
literal|0x00
block|,
literal|0x2b
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x05
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|all_l1is_snpa
index|[]
init|=
block|{
literal|0x01
block|,
literal|0x80
block|,
literal|0xc2
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x14
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|all_l2is_snpa
index|[]
init|=
block|{
literal|0x01
block|,
literal|0x80
block|,
literal|0xc2
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x15
block|}
decl_stmt|;
end_decl_stmt

begin_union
union|union
name|sockunion
block|{
name|struct
name|sockaddr_iso
name|siso
decl_stmt|;
name|struct
name|sockaddr_dl
name|sdl
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/*  * FUNCTION:		llc_rtrequest  *  * PURPOSE:			Manage routing table entries specific to LLC for ISO.  *  * NOTES:			This does a lot of obscure magic;  */
end_comment

begin_macro
name|llc_rtrequest
argument_list|(
argument|req
argument_list|,
argument|rt
argument_list|,
argument|sa
argument_list|)
end_macro

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|union
name|sockunion
modifier|*
name|gate
init|=
operator|(
expr|union
name|sockunion
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
decl_stmt|;
specifier|register
name|struct
name|llinfo_llc
modifier|*
name|lc
init|=
operator|(
expr|struct
name|llinfo_llc
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
decl_stmt|,
modifier|*
name|lc2
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt2
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|rt
operator|->
name|rt_ifp
decl_stmt|;
name|int
name|addrlen
init|=
name|ifp
operator|->
name|if_addrlen
decl_stmt|;
specifier|static
name|struct
name|rtentry
modifier|*
name|recursing
init|=
literal|0
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_SNPA
argument_list|)
name|printf
argument_list|(
literal|"llc_rtrequest(%d, %x, %x)\n"
argument_list|,
name|req
argument_list|,
name|rt
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
block|{
if|if
condition|(
name|recursing
condition|)
block|{
name|log
argument_list|(
literal|"llc_rtrequest: gateway route points to same type %x %x\n"
argument_list|,
name|recursing
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|RTM_RESOLVE
case|:
case|case
name|RTM_ADD
case|:
name|recursing
operator|=
name|rt
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
operator|(
name|caddr_t
operator|)
name|rtalloc1
argument_list|(
operator|&
name|gate
operator|->
name|sa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|recursing
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|RTM_DELETE
case|:
if|if
condition|(
name|lc
condition|)
name|RTFREE
argument_list|(
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|lc
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|RTM_ADD
case|:
comment|/* 		 * Case 1: This route may come from a route to iface with mask 		 * or from a default route. 		 */
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_CLONING
condition|)
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
specifier|register
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
for|for
control|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
init|;
name|ifa
condition|;
name|ifa
operator|->
name|ifa_next
control|)
if|if
condition|(
operator|(
name|sa
operator|=
name|ifa
operator|->
name|ifa_addr
operator|)
operator|->
name|sa_family
operator|==
name|AF_LINK
condition|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|>
name|gate
operator|->
name|sa
operator|.
name|sa_len
condition|)
name|log
argument_list|(
literal|"llc_rtrequest: cloning address too small\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|Bcopy
argument_list|(
name|sa
argument_list|,
name|gate
argument_list|,
name|gate
operator|->
name|sa
operator|.
name|sa_len
argument_list|)
expr_stmt|;
name|gate
operator|->
name|sdl
operator|.
name|sdl_alen
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|ifa
operator|==
literal|0
condition|)
name|log
argument_list|(
literal|"llc_rtrequest: can't find LL ifaddr for iface\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHROUGH */
case|case
name|RTM_RESOLVE
case|:
comment|/* 		 * Case 2:  This route may come from cloning, or a manual route 		 * add with a LL address. 		 */
if|if
condition|(
name|gate
operator|->
name|sdl
operator|.
name|sdl_family
operator|!=
name|AF_LINK
condition|)
block|{
name|log
argument_list|(
literal|"llc_rtrequest: got non-link non-gateway route\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lc
operator|!=
literal|0
condition|)
name|log
argument_list|(
literal|"llc_rtrequest: losing old rt_llinfo\n"
argument_list|)
expr_stmt|;
name|R_Malloc
argument_list|(
name|lc
argument_list|,
expr|struct
name|llinfo_llc
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lc
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
operator|(
name|caddr_t
operator|)
name|lc
expr_stmt|;
if|if
condition|(
name|lc
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
literal|"llc_rtrequest: malloc failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Bzero
argument_list|(
name|lc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lc
argument_list|)
argument_list|)
expr_stmt|;
name|lc
operator|->
name|lc_rt
operator|=
name|rt
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator||=
name|RTF_LLINFO
expr_stmt|;
name|insque
argument_list|(
name|lc
argument_list|,
operator|&
name|llinfo_llc
argument_list|)
expr_stmt|;
if|if
condition|(
name|gate
operator|->
name|sdl
operator|.
name|sdl_alen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|esis_req
argument_list|)
operator|+
name|addrlen
condition|)
block|{
name|gate
operator|->
name|sdl
operator|.
name|sdl_alen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|esis_req
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|addrlen
operator|+
name|LLADDR
argument_list|(
operator|&
name|gate
operator|->
name|sdl
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|lc
operator|->
name|lc_er
argument_list|,
sizeof|sizeof
argument_list|(
name|lc
operator|->
name|lc_er
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gate
operator|->
name|sdl
operator|.
name|sdl_alen
operator|==
name|addrlen
condition|)
name|lc
operator|->
name|lc_flags
operator|=
operator|(
name|SNPA_ES
operator||
name|SNPA_VALID
operator||
name|SNPA_PERM
operator|)
expr_stmt|;
break|break;
case|case
name|RTM_DELETE
case|:
if|if
condition|(
name|lc
operator|==
literal|0
operator|||
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_CLONING
operator|)
condition|)
return|return;
name|remque
argument_list|(
name|lc
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|lc
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_LLINFO
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_snparesolve  *  * PURPOSE:			Resolve an iso address into snpa address  *  * RETURNS:			0 if addr is resolved  *					errno if addr is unknown  *  * SIDE EFFECTS:	  *  * NOTES:			Now that we have folded the snpa cache into the routing  *					table, we know there is no snpa address known for this  *					destination.  If we know of a default IS, then the address  *					of the IS is returned.  If no IS is known, then return the  *					multi-cast address for "all ES" for this interface.  *  *					NB: the last case described above constitutes the  *					query configuration function 9542, sec 6.5  *					A mechanism is needed to prevent this function from  *					being invoked if the system is an IS.  */
end_comment

begin_macro
name|iso_snparesolve
argument_list|(
argument|ifp
argument_list|,
argument|dest
argument_list|,
argument|snpa
argument_list|,
argument|snpa_len
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* outgoing interface */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|dest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* destination */
end_comment

begin_decl_stmt
name|caddr_t
name|snpa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RESULT: snpa to be used */
end_comment

begin_decl_stmt
name|int
modifier|*
name|snpa_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RESULT: length of snpa */
end_comment

begin_block
block|{
name|struct
name|llinfo_llc
modifier|*
name|sc
decl_stmt|;
comment|/* ptr to snpa table entry */
name|caddr_t
name|found_snpa
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
comment|/* 	 *	This hack allows us to send esis packets that have the destination snpa 	 *	addresss embedded in the destination nsap address  	 */
if|if
condition|(
name|dest
operator|->
name|siso_data
index|[
literal|0
index|]
operator|==
name|AFI_SNA
condition|)
block|{
comment|/* 		 *	This is a subnetwork address. Return it immediately 		 */
name|IFDEBUG
argument_list|(
argument|D_SNPA
argument_list|)
name|printf
argument_list|(
literal|"iso_snparesolve: return SN address\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|addrlen
init|=
name|dest
operator|->
name|siso_nlen
operator|-
literal|1
decl_stmt|;
comment|/* subtract size of AFI */
name|found_snpa
operator|=
operator|(
name|caddr_t
operator|)
name|dest
operator|->
name|siso_data
operator|+
literal|1
expr_stmt|;
comment|/*  	 * If we are an IS, we can't do much with the packet; 	 *	Check if we know about an IS. 	 */
block|}
elseif|else
if|if
condition|(
name|iso_systype
operator|!=
name|SNPA_IS
operator|&&
name|known_is
operator|!=
literal|0
operator|&&
operator|(
name|sc
operator|=
operator|(
expr|struct
name|llinfo_llc
operator|*
operator|)
name|known_is
operator|->
name|rt_llinfo
operator|)
operator|&&
operator|(
name|sc
operator|->
name|lc_flags
operator|&
name|SNPA_VALID
operator|)
condition|)
block|{
specifier|register
name|struct
name|sockaddr_dl
modifier|*
name|sdl
init|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
name|known_is
operator|->
name|rt_gateway
operator|)
decl_stmt|;
name|found_snpa
operator|=
name|LLADDR
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|addrlen
operator|=
name|sdl
operator|->
name|sdl_alen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
comment|/*  		 *	no IS, no match. Return "all es" multicast address for this 		 *	interface, as per Query Configuration Function (9542 sec 6.5) 		 * 		 *	Note: there is a potential problem here. If the destination 		 *	is on the subnet and it does not respond with a ESH, but 		 *	does send back a TP CC, a connection could be established 		 *	where we always transmit the CLNP packet to "all es" 		 */
name|addrlen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
name|found_snpa
operator|=
operator|(
name|caddr_t
operator|)
name|all_es_snpa
expr_stmt|;
block|}
else|else
return|return
operator|(
name|ENETUNREACH
operator|)
return|;
name|bcopy
argument_list|(
name|found_snpa
argument_list|,
name|snpa
argument_list|,
operator|*
name|snpa_len
operator|=
name|addrlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_free  *  * PURPOSE:			free an entry in the iso address map table  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			If there is a route entry associated with cache  *					entry, then delete that as well  */
end_comment

begin_expr_stmt
name|snpac_free
argument_list|(
name|lc
argument_list|)
specifier|register
expr|struct
name|llinfo_llc
operator|*
name|lc
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* entry to free */
end_comment

begin_block
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|lc
operator|->
name|lc_rt
decl_stmt|;
specifier|register
name|struct
name|iso_addr
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|known_is
operator|==
name|rt
condition|)
name|known_is
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rt
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_DYNAMIC
operator||
name|RTF_MODIFIED
operator|)
operator|)
condition|)
block|{
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rtrequest
argument_list|(
name|RTM_DELETE
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt
operator|->
name|rt_gateway
argument_list|,
name|rt_mask
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt
operator|->
name|rt_flags
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_add  *  * PURPOSE:			Add an entry to the snpa cache  *  * RETURNS:			  *  * SIDE EFFECTS:	  *  * NOTES:			If entry already exists, then update holding time.  */
end_comment

begin_macro
name|snpac_add
argument_list|(
argument|ifp
argument_list|,
argument|nsap
argument_list|,
argument|snpa
argument_list|,
argument|type
argument_list|,
argument|ht
argument_list|,
argument|nsellength
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interface info is related to */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|nsap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nsap to add */
end_comment

begin_decl_stmt
name|caddr_t
name|snpa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* translation */
end_comment

begin_decl_stmt
name|char
name|type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SNPA_IS or SNPA_ES */
end_comment

begin_decl_stmt
name|u_short
name|ht
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holding time (in seconds) */
end_comment

begin_decl_stmt
name|int
name|nsellength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nsaps may differ only in trailing bytes */
end_comment

begin_block
block|{
specifier|register
name|struct
name|llinfo_llc
modifier|*
name|lc
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|mrt
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|iso_addr
modifier|*
name|r
decl_stmt|;
comment|/* for zap_isoaddr macro */
name|int
name|snpalen
init|=
name|min
argument_list|(
name|ifp
operator|->
name|if_addrlen
argument_list|,
name|MAX_SNPALEN
argument_list|)
decl_stmt|;
name|int
name|new_entry
init|=
literal|0
decl_stmt|,
name|index
init|=
name|ifp
operator|->
name|if_index
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_SNPA
argument_list|)
name|printf
argument_list|(
literal|"snpac_add(%x, %x, %x, %x, %x, %x)\n"
argument_list|,
name|ifp
argument_list|,
name|nsap
argument_list|,
name|snpa
argument_list|,
name|type
argument_list|,
name|ht
argument_list|,
name|nsellength
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|zap_isoaddr
parameter_list|(
name|dst
parameter_list|,
name|nsap
parameter_list|)
function_decl|;
name|rt
operator|=
name|rtalloc1
argument_list|(
name|S
argument_list|(
name|dst
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_SNPA
argument_list|)
name|printf
argument_list|(
literal|"snpac_add: rtalloc1 returns %x\n"
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|netmask
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|add
label|:
if|if
condition|(
name|nsellength
condition|)
block|{
name|netmask
operator|=
name|S
argument_list|(
name|msk
argument_list|)
expr_stmt|;
name|flags
operator|=
name|RTF_UP
expr_stmt|;
name|snpac_fixdstandmask
argument_list|(
name|nsellength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|netmask
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|RTF_UP
operator||
name|RTF_HOST
expr_stmt|;
block|}
name|new_entry
operator|=
literal|1
expr_stmt|;
name|zap_linkaddr
argument_list|(
operator|(
operator|&
name|gte_dl
operator|)
argument_list|,
name|snpa
argument_list|,
name|snpalen
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtrequest
argument_list|(
name|RTM_ADD
argument_list|,
name|S
argument_list|(
name|dst
argument_list|)
argument_list|,
name|S
argument_list|(
name|gte_dl
argument_list|)
argument_list|,
name|netmask
argument_list|,
name|flags
argument_list|,
operator|&
name|mrt
argument_list|)
operator|||
name|mrt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rt
operator|=
name|mrt
expr_stmt|;
name|rt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|sockaddr_dl
modifier|*
name|sdl
init|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
decl_stmt|;
name|rt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
operator|)
operator|==
literal|0
condition|)
goto|goto
name|add
goto|;
if|if
condition|(
name|nsellength
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_HOST
operator|)
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_refcnt
operator|==
literal|0
condition|)
block|{
name|rtrequest
argument_list|(
name|RTM_DELETE
argument_list|,
name|S
argument_list|(
name|dst
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
goto|goto
name|add
goto|;
block|}
else|else
block|{
specifier|static
name|struct
name|iso_addr
name|nsap2
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|nsap2
operator|=
operator|*
name|nsap
expr_stmt|;
name|cp
operator|=
name|nsap2
operator|.
name|isoa_genaddr
operator|+
name|nsap
operator|->
name|isoa_len
operator|-
name|nsellength
expr_stmt|;
while|while
condition|(
name|cp
operator|<
operator|(
name|char
operator|*
operator|)
operator|(
literal|1
operator|+
operator|&
name|nsap2
operator|)
condition|)
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|snpac_add
argument_list|(
name|ifp
argument_list|,
operator|&
name|nsap2
argument_list|,
name|snpa
argument_list|,
name|type
argument_list|,
name|ht
argument_list|,
name|nsellength
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sdl
operator|->
name|sdl_family
operator|!=
name|AF_LINK
operator|||
name|sdl
operator|->
name|sdl_alen
operator|==
literal|0
condition|)
block|{
name|int
name|old_sdl_len
init|=
name|sdl
operator|->
name|sdl_len
decl_stmt|;
if|if
condition|(
name|old_sdl_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sdl
argument_list|)
condition|)
block|{
name|log
argument_list|(
literal|"snpac_add: cant make room for lladdr\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zap_linkaddr
argument_list|(
name|sdl
argument_list|,
name|snpa
argument_list|,
name|snpalen
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|sdl
operator|->
name|sdl_len
operator|=
name|old_sdl_len
expr_stmt|;
name|new_entry
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|lc
operator|=
operator|(
expr|struct
name|llinfo_llc
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"snpac_rtrequest"
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_idle
operator|=
name|ht
expr_stmt|;
name|lc
operator|->
name|lc_flags
operator|=
name|SNPA_VALID
operator||
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|SNPA_IS
condition|)
name|snpac_logdefis
argument_list|(
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_entry
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|snpac_fixdstandmask
argument_list|(
argument|nsellength
argument_list|)
block|{
specifier|register
name|char
operator|*
name|cp
operator|=
name|msk
operator|.
name|siso_data
block|,
operator|*
name|cplim
block|;
name|cplim
operator|=
name|cp
operator|+
operator|(
name|dst
operator|.
name|siso_nlen
operator|-=
name|nsellength
operator|)
block|;
name|msk
operator|.
name|siso_len
operator|=
name|cplim
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|msk
block|;
name|msk
operator|.
name|siso_nlen
operator|=
literal|0
block|;
while|while
condition|(
name|cp
operator|<
name|cplim
condition|)
operator|*
name|cp
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|cp
operator|<
operator|(
name|char
operator|*
operator|)
name|msk
operator|.
name|siso_pad
condition|)
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
end_while

begin_for
for|for
control|(
name|cp
operator|=
name|dst
operator|.
name|siso_data
operator|+
name|dst
operator|.
name|siso_nlen
init|;
name|cp
operator|<
operator|(
name|char
operator|*
operator|)
name|dst
operator|.
name|siso_pad
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
end_for

begin_comment
unit|}
comment|/*  * FUNCTION:		snpac_ioctl  *  * PURPOSE:			Set/Get the system type and esis parameters  *  * RETURNS:			0 on success, or unix error code  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_expr_stmt
unit|snpac_ioctl
operator|(
name|cmd
operator|,
name|data
operator|)
name|int
name|cmd
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ioctl to process */
end_comment

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data for the cmd */
end_comment

begin_block
block|{
specifier|register
name|struct
name|systype_req
modifier|*
name|rq
init|=
operator|(
expr|struct
name|systype_req
operator|*
operator|)
name|data
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_IOCTL
argument_list|)
if|if
condition|(
name|cmd
operator|==
name|SIOCSSTYPE
condition|)
name|printf
argument_list|(
literal|"snpac_ioctl: cmd set, type x%x, ht %d, ct %d\n"
argument_list|,
name|rq
operator|->
name|sr_type
argument_list|,
name|rq
operator|->
name|sr_holdt
argument_list|,
name|rq
operator|->
name|sr_configt
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"snpac_ioctl: cmd get\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cmd
operator|==
name|SIOCSSTYPE
condition|)
block|{
if|if
condition|(
name|suser
argument_list|(
name|u
operator|.
name|u_cred
argument_list|,
operator|&
name|u
operator|.
name|u_acflag
argument_list|)
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
if|if
condition|(
operator|(
name|rq
operator|->
name|sr_type
operator|&
operator|(
name|SNPA_ES
operator||
name|SNPA_IS
operator|)
operator|)
operator|==
operator|(
name|SNPA_ES
operator||
name|SNPA_IS
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|rq
operator|->
name|sr_type
operator|&
name|SNPA_ES
condition|)
block|{
name|iso_systype
operator|=
name|SNPA_ES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|->
name|sr_type
operator|&
name|SNPA_IS
condition|)
block|{
name|iso_systype
operator|=
name|SNPA_IS
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|esis_holding_time
operator|=
name|rq
operator|->
name|sr_holdt
expr_stmt|;
name|esis_config_time
operator|=
name|rq
operator|->
name|sr_configt
expr_stmt|;
if|if
condition|(
name|esis_esconfig_time
operator|!=
name|rq
operator|->
name|sr_esconfigt
condition|)
block|{
name|untimeout
argument_list|(
name|esis_config
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|esis_esconfig_time
operator|=
name|rq
operator|->
name|sr_esconfigt
expr_stmt|;
name|esis_config
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|SIOCGSTYPE
condition|)
block|{
name|rq
operator|->
name|sr_type
operator|=
name|iso_systype
expr_stmt|;
name|rq
operator|->
name|sr_holdt
operator|=
name|esis_holding_time
expr_stmt|;
name|rq
operator|->
name|sr_configt
operator|=
name|esis_config_time
expr_stmt|;
name|rq
operator|->
name|sr_esconfigt
operator|=
name|esis_esconfig_time
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_logdefis  *  * PURPOSE:			Mark the IS passed as the default IS  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_expr_stmt
name|snpac_logdefis
argument_list|(
name|sc
argument_list|)
specifier|register
expr|struct
name|rtentry
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|iso_addr
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|sockaddr_dl
modifier|*
name|sdl
init|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|sc
operator|->
name|rt_gateway
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|zsi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|zap_linkaddr
argument_list|(
operator|(
operator|&
name|gte_dl
operator|)
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|sdl
operator|->
name|sdl_alen
argument_list|,
name|sdl
operator|->
name|sdl_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|known_is
operator|==
literal|0
condition|)
name|known_is
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|known_is
operator|!=
name|sc
condition|)
block|{
name|rtfree
argument_list|(
name|known_is
argument_list|)
expr_stmt|;
name|known_is
operator|=
name|sc
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
block|{
name|rtrequest
argument_list|(
name|RTM_ADD
argument_list|,
name|S
argument_list|(
name|zsi
argument_list|)
argument_list|,
name|S
argument_list|(
name|gte_dl
argument_list|)
argument_list|,
name|S
argument_list|(
name|zmk
argument_list|)
argument_list|,
name|RTF_DYNAMIC
operator||
name|RTF_GATEWAY
operator||
name|RTF_CLONING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|rt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_DYNAMIC
operator||
name|RTF_MODIFIED
operator|)
condition|)
block|{
operator|*
operator|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
operator|)
operator|=
name|gte_dl
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_age  *  * PURPOSE:			Time out snpac entries  *  * RETURNS:			  *  * SIDE EFFECTS:	  *  * NOTES:			When encountering an entry for the first time, snpac_age  *					may delete up to SNPAC_AGE too many seconds. Ie.  *					if the entry is added a moment before snpac_age is  *					called, the entry will immediately have SNPAC_AGE  *					seconds taken off the holding time, even though  *					it has only been held a brief moment.  *  *					The proper way to do this is set an expiry timeval  *					equal to current time + holding time. Then snpac_age  *					would time out entries where expiry date is older  *					than the current time.  */
end_comment

begin_macro
name|snpac_age
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|llinfo_llc
modifier|*
name|lc
decl_stmt|;
name|timeout
argument_list|(
name|snpac_age
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|SNPAC_AGE
operator|*
name|hz
argument_list|)
expr_stmt|;
for|for
control|(
name|lc
operator|=
name|llinfo_llc
operator|.
name|lc_next
init|;
name|lc
operator|!=
operator|&
name|llinfo_llc
condition|;
name|lc
operator|=
name|lc
operator|->
name|lc_next
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|lc
operator|->
name|lc_flags
operator|&
name|SNPA_PERM
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lc
operator|->
name|lc_flags
operator|&
name|SNPA_VALID
operator|)
condition|)
block|{
name|lc
operator|->
name|lc_rt
operator|->
name|rt_idle
operator|-=
name|SNPAC_AGE
expr_stmt|;
if|if
condition|(
name|lc
operator|->
name|lc_rt
operator|->
name|rt_idle
operator|>
literal|0
condition|)
continue|continue;
else|else
name|snpac_free
argument_list|(
name|lc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_ownmulti  *  * PURPOSE:			Determine if the snpa address is a multicast address  *					of the same type as the system.  *  * RETURNS:			true or false  *  * SIDE EFFECTS:	  *  * NOTES:			Used by interface drivers when not in eavesdrop mode   *					as interm kludge until  *					real multicast addresses can be configured  */
end_comment

begin_macro
name|snpac_ownmulti
argument_list|(
argument|snpa
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|snpa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
operator|(
name|iso_systype
operator|&
name|SNPA_ES
operator|)
operator|&&
operator|(
operator|!
name|bcmp
argument_list|(
name|snpa
argument_list|,
operator|(
name|caddr_t
operator|)
name|all_es_snpa
argument_list|,
name|len
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|iso_systype
operator|&
name|SNPA_IS
operator|)
operator|&&
operator|(
operator|!
name|bcmp
argument_list|(
name|snpa
argument_list|,
operator|(
name|caddr_t
operator|)
name|all_is_snpa
argument_list|,
name|len
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_flushifp  *  * PURPOSE:			Flush entries associated with specific ifp  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|snpac_flushifp
argument_list|(
argument|ifp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|llinfo_llc
modifier|*
name|lc
decl_stmt|;
for|for
control|(
name|lc
operator|=
name|llinfo_llc
operator|.
name|lc_next
init|;
name|lc
operator|!=
operator|&
name|llinfo_llc
condition|;
name|lc
operator|=
name|lc
operator|->
name|lc_next
control|)
block|{
if|if
condition|(
name|lc
operator|->
name|lc_rt
operator|->
name|rt_ifp
operator|==
name|ifp
operator|&&
operator|(
name|lc
operator|->
name|lc_flags
operator|&
name|SNPA_VALID
operator|)
condition|)
name|snpac_free
argument_list|(
name|lc
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_rtrequest  *  * PURPOSE:			Make a routing request  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			In the future, this should make a request of a user  *					level routing daemon.  */
end_comment

begin_macro
name|snpac_rtrequest
argument_list|(
argument|req
argument_list|,
argument|host
argument_list|,
argument|gateway
argument_list|,
argument|netmask
argument_list|,
argument|flags
argument_list|,
argument|ret_nrt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|gateway
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|netmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtentry
modifier|*
modifier|*
name|ret_nrt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iso_addr
modifier|*
name|r
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_SNPA
argument_list|)
name|printf
argument_list|(
literal|"snpac_rtrequest: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|RTM_ADD
condition|)
name|printf
argument_list|(
literal|"add"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|req
operator|==
name|RTM_DELETE
condition|)
name|printf
argument_list|(
literal|"delete"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"unknown command"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" dst: %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|host
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tgateway: %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|gateway
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|zap_isoaddr
parameter_list|(
name|dst
parameter_list|,
name|host
parameter_list|)
function_decl|;
name|zap_isoaddr
argument_list|(
name|gte
argument_list|,
name|gateway
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmask
condition|)
block|{
name|zap_isoaddr
argument_list|(
name|msk
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
name|msk
operator|.
name|siso_nlen
operator|=
literal|0
expr_stmt|;
name|msk
operator|.
name|siso_len
operator|=
name|msk
operator|.
name|siso_pad
operator|-
operator|(
name|u_char
operator|*
operator|)
operator|&
name|msk
expr_stmt|;
block|}
name|rtrequest
argument_list|(
name|req
argument_list|,
name|S
argument_list|(
name|dst
argument_list|)
argument_list|,
name|S
argument_list|(
name|gte
argument_list|)
argument_list|,
operator|(
name|netmask
condition|?
name|S
argument_list|(
name|msk
argument_list|)
else|:
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
operator|)
argument_list|,
name|flags
argument_list|,
name|ret_nrt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_addrt  *  * PURPOSE:			Associate a routing entry with an snpac entry  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			If a cache entry exists for gateway, then  *					make a routing entry (host, gateway) and associate  *					with gateway.  *  *					If a route already exists and is different, first delete  *					it.  *  *					This could be made more efficient by checking   *					the existing route before adding a new one.  */
end_comment

begin_macro
name|snpac_addrt
argument_list|(
argument|ifp
argument_list|,
argument|host
argument_list|,
argument|gateway
argument_list|,
argument|netmask
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|host
decl_stmt|,
modifier|*
name|gateway
decl_stmt|,
modifier|*
name|netmask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iso_addr
modifier|*
name|r
decl_stmt|;
name|zap_isoaddr
argument_list|(
name|dst
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|zap_isoaddr
argument_list|(
name|gte
argument_list|,
name|gateway
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmask
condition|)
block|{
name|zap_isoaddr
argument_list|(
name|msk
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
name|msk
operator|.
name|siso_nlen
operator|=
literal|0
expr_stmt|;
name|msk
operator|.
name|siso_len
operator|=
name|msk
operator|.
name|siso_pad
operator|-
operator|(
name|u_char
operator|*
operator|)
operator|&
name|msk
expr_stmt|;
name|rtredirect
argument_list|(
name|S
argument_list|(
name|dst
argument_list|)
argument_list|,
name|S
argument_list|(
name|gte
argument_list|)
argument_list|,
name|S
argument_list|(
name|msk
argument_list|)
argument_list|,
name|RTF_DONE
argument_list|,
name|S
argument_list|(
name|gte
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|rtredirect
argument_list|(
name|S
argument_list|(
name|dst
argument_list|)
argument_list|,
name|S
argument_list|(
name|gte
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
name|RTF_DONE
operator||
name|RTF_HOST
argument_list|,
name|S
argument_list|(
name|gte
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|ISO
end_endif

end_unit

