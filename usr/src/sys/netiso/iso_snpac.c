begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/* $Header: iso_snpac.c,v 1.8 88/09/19 13:51:36 hagens Exp $ */
end_comment

begin_comment
comment|/* $Source: /usr/argo/sys/netiso/RCS/iso_snpac.c,v $ */
end_comment

begin_comment
comment|/*	@(#)iso_snpac.c	7.6 (Berkeley) %G% */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: iso_snpac.c,v 1.8 88/09/19 13:51:36 hagens Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"iso_var.h"
end_include

begin_include
include|#
directive|include
file|"iso_snpac.h"
end_include

begin_include
include|#
directive|include
file|"clnp.h"
end_include

begin_include
include|#
directive|include
file|"clnp_stat.h"
end_include

begin_include
include|#
directive|include
file|"esis.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_define
define|#
directive|define
name|SNPAC_BSIZ
value|20
end_define

begin_comment
comment|/* bucket size */
end_comment

begin_define
define|#
directive|define
name|SNPAC_NB
value|13
end_define

begin_comment
comment|/* number of buckets */
end_comment

begin_define
define|#
directive|define
name|SNPAC_SIZE
value|(SNPAC_BSIZ * SNPAC_NB)
end_define

begin_decl_stmt
name|struct
name|snpa_cache
name|iso_snpac
index|[
name|SNPAC_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|iso_snpac_size
init|=
name|SNPAC_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for iso_map command */
end_comment

begin_decl_stmt
name|int
name|iso_systype
init|=
name|SNPA_ES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default to be an ES */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_iso
name|blank_siso
init|=
block|{
sizeof|sizeof
argument_list|(
name|blank_siso
argument_list|)
block|,
name|AF_ISO
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|u_long
name|iso_hashchar
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_iso
name|dst
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_ISO
block|}
decl_stmt|,
name|gte
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_ISO
block|}
decl_stmt|,
name|src
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_ISO
block|}
decl_stmt|,
name|msk
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_ISO
block|}
decl_stmt|,
name|zmk
init|=
block|{
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|zsi
value|blank_siso
end_define

begin_define
define|#
directive|define
name|zero_isoa
value|zsi.siso_addr
end_define

begin_define
define|#
directive|define
name|zap_isoaddr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(bzero((caddr_t)&a.siso_addr, sizeof(*r)), \ 	   ((r = b)&& bcopy((caddr_t)r, (caddr_t)&a.siso_addr, 1 + (r)->isoa_len)))
end_define

begin_define
define|#
directive|define
name|S
parameter_list|(
name|x
parameter_list|)
value|((struct sockaddr *)&(x))
end_define

begin_define
define|#
directive|define
name|SNPAC_HASH
parameter_list|(
name|addr
parameter_list|)
define|\
value|(((u_long) iso_hashchar((caddr_t)addr, (int)addr->isoa_len)) % SNPAC_NB)
end_define

begin_define
define|#
directive|define
name|SNPAC_LOOK
parameter_list|(
name|sc
parameter_list|,
name|addr
parameter_list|)
value|{ \ 	register n; \ 	sc =&iso_snpac[SNPAC_HASH(addr) * SNPAC_BSIZ]; \ 	for (n = 0 ; n< SNPAC_BSIZ ; n++,sc++) \ 		if ((sc->sc_flags& SNPA_VALID)&& \ 			(iso_addrmatch1(&sc->sc_nsap, addr))) \ 			break; \ 	if (n>= SNPAC_BSIZ) \ 		sc = 0; \ }
end_define

begin_function_decl
name|struct
name|snpa_cache
modifier|*
name|snpac_new
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *	We only keep track of a single IS at a time.  */
end_comment

begin_decl_stmt
name|struct
name|snpa_cache
modifier|*
name|known_is
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Addresses taken from NBS agreements, December 1987.  *  *	These addresses assume on-the-wire transmission of least significant  *	bit first. This is the method used by 802.3. When these  *	addresses are passed to the token ring driver, (802.5), they  *	must be bit-swaped because 802.5 transmission order is MSb first.  *  *	Furthermore, according to IBM Austin, these addresses are not  *	true token ring multicast addresses. More work is necessary  *	to get multicast to work right on token ring.  *  *	Currently, the token ring driver does not handle multicast, so  *	these addresses are converted into the broadcast address in  *	lan_output() That means that if these multicast addresses change  *	the token ring driver must be altered.  */
end_comment

begin_decl_stmt
name|struct
name|snpa_cache
name|all_es
init|=
block|{
block|{
block|{
literal|0x0
block|}
block|,
comment|/* sc_nsap */
literal|6
block|,
comment|/* sc_len */
block|{
literal|0x09
block|,
literal|0x00
block|,
literal|0x2b
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x04
block|}
block|,
comment|/* sc_snpa */
name|SNPA_VALID
block|,
comment|/* sc_flags */
literal|0
block|}
comment|/* sc_ht */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|snpa_cache
name|all_is
init|=
block|{
block|{
block|{
literal|0x0
block|}
block|,
comment|/* sc_nsap */
literal|6
block|,
comment|/* sc_len */
block|{
literal|0x09
block|,
literal|0x00
block|,
literal|0x2b
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x05
block|}
block|,
comment|/* sc_snpa */
name|SNPA_VALID
block|,
comment|/* sc_flags */
literal|0
block|}
comment|/* sc_ht */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FUNCTION:		iso_snparesolve  *  * PURPOSE:			Resolve an iso address into snpa address  *  * RETURNS:			0 if addr is resolved  *					errno if addr is unknown  *  * SIDE EFFECTS:	  *  * NOTES:			If an entry is found that matches the address, that   *					snpa is returned. If no entry is found, but an IS is  *					known, then the address of the IS is returned. If  *					neither an address is found that matches or an IS is  *					known, then the multi-cast address for "all ES" for  *					this interface is returned.  *  *					NB: the last case described above constitutes the  *					query configuration function 9542, sec 6.5  *					A mechanism is needed to prevent this function from  *					being invoked if the system is an IS.  */
end_comment

begin_macro
name|iso_snparesolve
argument_list|(
argument|ifp
argument_list|,
argument|dest
argument_list|,
argument|snpa
argument_list|,
argument|snpa_len
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* outgoing interface */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|dest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* destination */
end_comment

begin_decl_stmt
name|char
modifier|*
name|snpa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RESULT: snpa to be used */
end_comment

begin_decl_stmt
name|int
modifier|*
name|snpa_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RESULT: length of snpa */
end_comment

begin_block
block|{
specifier|extern
name|struct
name|ifnet
name|loif
decl_stmt|;
comment|/* loopback interface */
name|struct
name|snpa_cache
modifier|*
name|sc
decl_stmt|;
comment|/* ptr to snpa table entry */
name|struct
name|iso_addr
modifier|*
name|destiso
decl_stmt|;
comment|/* destination iso addr */
name|destiso
operator|=
operator|&
name|dest
operator|->
name|siso_addr
expr_stmt|;
comment|/* 	 *	This hack allows us to send esis packets that have the destination snpa 	 *	addresss embedded in the destination nsap address  	 */
if|if
condition|(
name|destiso
operator|->
name|isoa_genaddr
index|[
literal|0
index|]
operator|==
name|AFI_SNA
condition|)
block|{
comment|/* 		 *	This is a subnetwork address. Return it immediately 		 */
name|IFDEBUG
argument_list|(
argument|D_SNPA
argument_list|)
name|printf
argument_list|(
literal|"iso_snparesolve: return SN address\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
modifier|*
name|snpa_len
init|=
name|destiso
operator|->
name|isoa_len
operator|-
literal|1
decl_stmt|;
comment|/* subtract size of AFI */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|destiso
operator|->
name|isoa_genaddr
operator|+
literal|1
argument_list|,
operator|(
name|caddr_t
operator|)
name|snpa
argument_list|,
operator|(
name|unsigned
operator|)
operator|*
name|snpa_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|IFDEBUG
argument_list|(
argument|D_SNPA
argument_list|)
name|printf
argument_list|(
literal|"iso_snparesolve: resolving %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|destiso
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/*  	 *	packet is not for us, check cache for an entry  	 */
name|SNPAC_LOOK
parameter_list|(
name|sc
parameter_list|,
name|destiso
parameter_list|)
function_decl|;
if|if
condition|(
name|sc
operator|==
literal|0
condition|)
block|{
comment|/* not found */
comment|/* If we are an IS, we can't do much with the packet */
if|if
condition|(
name|iso_systype
operator|==
name|SNPA_IS
condition|)
goto|goto
name|bad
goto|;
comment|/* 		 *	Check if we know about an IS 		 */
if|if
condition|(
operator|(
name|known_is
operator|)
operator|&&
operator|(
name|known_is
operator|->
name|sc_flags
operator|&
name|SNPA_VALID
operator|)
condition|)
block|{
name|sc
operator|=
name|known_is
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
comment|/*  			 *	no IS, no match. Return "all es" multicast address for this 			 *	interface, as per Query Configuration Function (9542 sec 6.5) 			 * 			 *	Note: there is a potential problem here. If the destination 			 *	is on the subnet and it does not respond with a ESH, but 			 *	does send back a TP CC, a connection could be established 			 *	where we always transmit the CLNP packet to "all es" 			 */
name|sc
operator|=
operator|&
name|all_es
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|bad
goto|;
block|}
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_snpa
argument_list|,
operator|(
name|caddr_t
operator|)
name|snpa
argument_list|,
name|sc
operator|->
name|sc_len
argument_list|)
expr_stmt|;
operator|*
name|snpa_len
operator|=
name|sc
operator|->
name|sc_len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
return|return
operator|(
name|ENETUNREACH
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_look  *  * PURPOSE:			Look up an entry in the snpa cache  *  * RETURNS:			Pointer to snpa_cache structure, or null  *  * SIDE EFFECTS:	  *  * NOTES:			This is simply SNPAC_LOOK as a procedure.  */
end_comment

begin_function
name|struct
name|snpa_cache
modifier|*
name|snpac_look
parameter_list|(
name|isoa
parameter_list|)
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
comment|/* destination nsap */
block|{
name|struct
name|snpa_cache
modifier|*
name|sc
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|SNPAC_LOOK
argument_list|(
name|sc
argument_list|,
name|isoa
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		iso_8208snparesolve  *  * PURPOSE:			Find the X.121 address that corresponds to an NSAP addr  *  * RETURNS:			0 or unix errno  *  * SIDE EFFECTS:	  *  * NOTES:			This ought to invoke the 8208 ES-IS function  */
end_comment

begin_macro
name|iso_8208snparesolve
argument_list|(
argument|dest
argument_list|,
argument|snpa
argument_list|,
argument|snpa_len
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|dest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* destination */
end_comment

begin_decl_stmt
name|char
modifier|*
name|snpa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RESULT: snpa to be used */
end_comment

begin_decl_stmt
name|int
modifier|*
name|snpa_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RESULT: length of snpa */
end_comment

begin_block
block|{
name|struct
name|snpa_cache
modifier|*
name|sc
decl_stmt|;
comment|/* ptr to snpa table entry */
name|struct
name|iso_addr
modifier|*
name|destiso
decl_stmt|;
comment|/* destination iso addr */
name|int
name|s
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|destiso
operator|=
operator|&
name|dest
operator|->
name|siso_addr
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|SNPAC_LOOK
argument_list|(
name|sc
argument_list|,
name|destiso
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_snpa
argument_list|,
operator|(
name|caddr_t
operator|)
name|snpa
argument_list|,
name|sc
operator|->
name|sc_len
argument_list|)
expr_stmt|;
operator|*
name|snpa_len
operator|=
name|sc
operator|->
name|sc_len
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|ENETUNREACH
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_8208snpaadd  *  * PURPOSE:			Add an entry to the snpa cache  *  * RETURNS:			  *  * SIDE EFFECTS:	  *  * NOTES:			used by cons  */
end_comment

begin_macro
name|iso_8208snpaadd
argument_list|(
argument|ifp
argument_list|,
argument|nsap
argument_list|,
argument|snpa
argument_list|,
argument|snpalen
argument_list|,
argument|ht
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interface info is related to */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|nsap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nsap to add */
end_comment

begin_decl_stmt
name|caddr_t
name|snpa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* translation */
end_comment

begin_decl_stmt
name|int
name|snpalen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length in bytes */
end_comment

begin_decl_stmt
name|short
name|ht
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holding time (in seconds) */
end_comment

begin_block
block|{
name|snpac_add
argument_list|(
name|ifp
argument_list|,
name|nsap
argument_list|,
name|snpa
argument_list|,
name|snpalen
argument_list|,
name|SNPA_ES
argument_list|,
operator|(
name|u_short
operator|)
name|ht
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_8208snpadelete  *  * PURPOSE:			Delete an entry from the snpa cache  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			used by CONS  */
end_comment

begin_macro
name|iso_8208snpadelete
argument_list|(
argument|nsap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|nsap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|snpa_cache
modifier|*
name|sc
init|=
name|snpac_look
argument_list|(
name|nsap
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
name|snpac_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_new  *  * PURPOSE:			create a new entry in the iso address to ethernet  *					address table  *  * RETURNS:			pointer to newest entry  *  * SIDE EFFECTS:	times out old entries if no new entries are found  *  * NOTES:			If the bucket is full, then timeout the oldest entry  *					(ie. the one with the youngest holding time)  */
end_comment

begin_function
name|struct
name|snpa_cache
modifier|*
name|snpac_new
parameter_list|(
name|isoa
parameter_list|)
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
comment|/* iso address to enter into table */
block|{
specifier|register
name|struct
name|snpa_cache
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|smallest_ht
init|=
literal|1000000
decl_stmt|;
name|struct
name|snpa_cache
modifier|*
name|maybe
decl_stmt|;
name|sc
operator|=
operator|&
name|iso_snpac
index|[
name|SNPAC_HASH
argument_list|(
name|isoa
argument_list|)
operator|*
name|SNPAC_BSIZ
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SNPAC_BSIZ
condition|;
name|n
operator|++
operator|,
name|sc
operator|++
control|)
block|{
name|IFDEBUG
argument_list|(
argument|D_IOCTL
argument_list|)
name|printf
argument_list|(
literal|"snpac_new: sc x%x "
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SNPA_VALID
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"(valid) %s "
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|sc
operator|->
name|sc_nsap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
name|sc
operator|->
name|sc_snpa
index|[
name|i
index|]
argument_list|,
name|i
operator|<
operator|(
name|sc
operator|->
name|sc_len
operator|-
literal|1
operator|)
condition|?
literal|':'
else|:
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"invalid\n"
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SNPA_VALID
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ht
operator|<
name|smallest_ht
condition|)
block|{
name|smallest_ht
operator|=
name|sc
operator|->
name|sc_ht
expr_stmt|;
name|maybe
operator|=
name|sc
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
name|sc
return|;
comment|/* found unused slot */
block|}
block|}
name|snpac_free
argument_list|(
name|maybe
argument_list|)
expr_stmt|;
return|return
name|maybe
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		snpac_free  *  * PURPOSE:			free an entry in the iso address map table  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			If there is a route entry associated with cache  *					entry, then delete that as well  */
end_comment

begin_expr_stmt
name|snpac_free
argument_list|(
name|sc
argument_list|)
specifier|register
expr|struct
name|snpa_cache
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* entry to free */
end_comment

begin_block
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
specifier|register
name|struct
name|iso_addr
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|known_is
operator|==
name|sc
condition|)
block|{
name|known_is
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rt
condition|)
block|{
name|zap_isoaddr
argument_list|(
name|dst
argument_list|,
operator|(
operator|&
operator|(
name|sc
operator|->
name|sc_da
operator|)
operator|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_rt
operator|==
name|rt
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_DYNAMIC
operator||
name|RTF_MODIFIED
operator|)
operator|)
condition|)
block|{
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rtrequest
argument_list|(
name|RTM_DELETE
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt
operator|->
name|rt_gateway
argument_list|,
name|rt_mask
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt
operator|->
name|rt_flags
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|snpa_cache
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_add  *  * PURPOSE:			Add an entry to the snpa cache  *  * RETURNS:			  *  * SIDE EFFECTS:	  *  * NOTES:			If entry already exists, then update holding time.  */
end_comment

begin_macro
name|snpac_add
argument_list|(
argument|ifp
argument_list|,
argument|nsap
argument_list|,
argument|snpa
argument_list|,
argument|snpalen
argument_list|,
argument|type
argument_list|,
argument|ht
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interface info is related to */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|nsap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nsap to add */
end_comment

begin_decl_stmt
name|caddr_t
name|snpa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* translation */
end_comment

begin_decl_stmt
name|int
name|snpalen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* translation length */
end_comment

begin_decl_stmt
name|char
name|type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SNPA_IS or SNPA_ES */
end_comment

begin_decl_stmt
name|u_short
name|ht
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holding time (in seconds) */
end_comment

begin_block
block|{
name|struct
name|snpa_cache
modifier|*
name|sc
decl_stmt|;
name|SNPAC_LOOK
argument_list|(
name|sc
argument_list|,
name|nsap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|sc
operator|=
name|snpac_new
argument_list|(
name|nsap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nsap
operator|=
operator|*
name|nsap
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ht
operator|=
name|ht
expr_stmt|;
name|sc
operator|->
name|sc_len
operator|=
name|min
argument_list|(
name|snpalen
argument_list|,
name|MAX_SNPALEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|snpa
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_snpa
argument_list|,
name|sc
operator|->
name|sc_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|SNPA_VALID
operator||
name|type
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|SNPA_IS
condition|)
name|snpac_logdefis
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_ioctl  *  * PURPOSE:			handle ioctls to change the iso address map  *  * RETURNS:			unix error code  *  * SIDE EFFECTS:	changes the snpa_cache table declared above.  *  * NOTES:			  */
end_comment

begin_macro
name|snpac_ioctl
argument_list|(
argument|cmd
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ioctl to process */
end_comment

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data for the cmd */
end_comment

begin_block
block|{
specifier|register
name|struct
name|snpa_req
modifier|*
name|rq
init|=
operator|(
expr|struct
name|snpa_req
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|snpa_cache
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
name|int
name|s
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSISOMAP
case|:
name|type
operator|=
literal|"set"
expr_stmt|;
break|break;
case|case
name|SIOCDISOMAP
case|:
name|type
operator|=
literal|"delete"
expr_stmt|;
break|break;
case|case
name|SIOCGISOMAP
case|:
name|type
operator|=
literal|"get"
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|snpac_systype
argument_list|(
name|cmd
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
comment|/* sanity check */
if|if
condition|(
name|rq
operator|->
name|sr_len
operator|>
name|MAX_SNPALEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|IFDEBUG
argument_list|(
argument|D_IOCTL
argument_list|)
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"snpac_ioctl: %s %s to "
argument_list|,
name|type
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|isoa
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rq
operator|->
name|sr_len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
name|rq
operator|->
name|sr_snpa
index|[
name|i
index|]
argument_list|,
name|i
operator|<
operator|(
name|rq
operator|->
name|sr_len
operator|-
literal|1
operator|)
condition|?
literal|':'
else|:
literal|'\n'
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* look up this address in table */
name|isoa
init|=
operator|&
name|rq
operator|->
name|sr_isoa
decl_stmt|;
name|SNPAC_LOOK
argument_list|(
name|sc
argument_list|,
name|isoa
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
comment|/* not found */
if|if
condition|(
name|cmd
operator|!=
name|SIOCSISOMAP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSISOMAP
case|:
comment|/* set entry */
name|snpac_add
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|NULL
argument_list|,
name|isoa
argument_list|,
operator|(
name|caddr_t
operator|)
name|rq
operator|->
name|sr_snpa
argument_list|,
operator|(
name|int
operator|)
name|rq
operator|->
name|sr_len
argument_list|,
call|(
name|char
call|)
argument_list|(
name|rq
operator|->
name|sr_flags
operator|&
operator|(
name|SNPA_ES
operator||
name|SNPA_IS
operator||
name|SNPA_PERM
operator|)
argument_list|)
argument_list|,
name|rq
operator|->
name|sr_ht
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCDISOMAP
case|:
comment|/* delete entry */
name|snpac_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGISOMAP
case|:
comment|/* get entry */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_sr
argument_list|,
operator|(
name|caddr_t
operator|)
name|rq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|snpa_req
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_tryloopback  *  * PURPOSE:			Attempt to use the software loopback interface for pkt  *  * RETURNS:			0		if packet was sent successfully  *					errno	if there was a problem sending the packet  *							Ie. the return value of looutput  *					-1 		if software loopback is not appropriate  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|iso_tryloopback
argument_list|(
argument|m
argument_list|,
argument|dest
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pkt */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|dest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* destination */
end_comment

begin_block
block|{
name|struct
name|iso_addr
modifier|*
name|destiso
decl_stmt|;
comment|/* destination iso addr */
name|destiso
operator|=
operator|&
name|dest
operator|->
name|siso_addr
expr_stmt|;
if|if
condition|(
name|clnp_ours
argument_list|(
name|destiso
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_SNPA
argument_list|)
name|printf
argument_list|(
literal|"iso_tryloopback: local destination\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|loif
operator|.
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_SNPA
argument_list|)
name|printf
argument_list|(
literal|"iso_tryloopback: calling looutput\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
name|looutput
argument_list|(
operator|&
name|loif
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dest
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_systype  *  * PURPOSE:			Set/Get the system type and esis parameters  *  * RETURNS:			0 on success, or unix error code  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|snpac_systype
argument_list|(
argument|cmd
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ioctl to process */
end_comment

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data for the cmd */
end_comment

begin_block
block|{
specifier|register
name|struct
name|systype_req
modifier|*
name|rq
init|=
operator|(
expr|struct
name|systype_req
operator|*
operator|)
name|data
decl_stmt|;
specifier|extern
name|short
name|esis_holding_time
decl_stmt|,
name|esis_config_time
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_IOCTL
argument_list|)
if|if
condition|(
name|cmd
operator|==
name|SIOCSSTYPE
condition|)
name|printf
argument_list|(
literal|"snpac_systype: cmd set, type x%x, ht %d, ct %d\n"
argument_list|,
name|rq
operator|->
name|sr_type
argument_list|,
name|rq
operator|->
name|sr_holdt
argument_list|,
name|rq
operator|->
name|sr_configt
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"snpac_systype: cmd get\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cmd
operator|==
name|SIOCSSTYPE
condition|)
block|{
if|if
condition|(
name|suser
argument_list|(
name|u
operator|.
name|u_cred
argument_list|,
operator|&
name|u
operator|.
name|u_acflag
argument_list|)
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
if|if
condition|(
operator|(
name|rq
operator|->
name|sr_type
operator|&
operator|(
name|SNPA_ES
operator||
name|SNPA_IS
operator|)
operator|)
operator|==
operator|(
name|SNPA_ES
operator||
name|SNPA_IS
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|rq
operator|->
name|sr_type
operator|&
name|SNPA_ES
condition|)
block|{
name|iso_systype
operator|=
name|SNPA_ES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|->
name|sr_type
operator|&
name|SNPA_IS
condition|)
block|{
name|iso_systype
operator|=
name|SNPA_IS
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|esis_holding_time
operator|=
name|rq
operator|->
name|sr_holdt
expr_stmt|;
name|esis_config_time
operator|=
name|rq
operator|->
name|sr_configt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|SIOCGSTYPE
condition|)
block|{
name|rq
operator|->
name|sr_type
operator|=
name|iso_systype
expr_stmt|;
name|rq
operator|->
name|sr_holdt
operator|=
name|esis_holding_time
expr_stmt|;
name|rq
operator|->
name|sr_configt
operator|=
name|esis_config_time
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_logdefis  *  * PURPOSE:			Mark the IS passed as the default IS  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_expr_stmt
name|snpac_logdefis
argument_list|(
name|sc
argument_list|)
specifier|register
expr|struct
name|snpa_cache
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|iso_addr
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|zsi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|known_is
operator|==
literal|0
condition|)
name|known_is
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|known_is
operator|!=
name|sc
condition|)
block|{
if|if
condition|(
name|known_is
operator|->
name|sc_rt
condition|)
block|{
name|rtfree
argument_list|(
name|known_is
operator|->
name|sc_rt
argument_list|)
expr_stmt|;
name|known_is
operator|->
name|sc_rt
operator|=
literal|0
expr_stmt|;
block|}
name|known_is
operator|=
name|sc
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
block|{
name|zap_isoaddr
argument_list|(
name|dst
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|sc_nsap
operator|)
argument_list|)
expr_stmt|;
name|rtrequest
argument_list|(
name|RTM_ADD
argument_list|,
name|S
argument_list|(
name|zsi
argument_list|)
argument_list|,
name|S
argument_list|(
name|dst
argument_list|)
argument_list|,
name|S
argument_list|(
name|zmk
argument_list|)
argument_list|,
name|RTF_DYNAMIC
operator||
name|RTF_GATEWAY
argument_list|,
operator|&
name|sc
operator|->
name|sc_rt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_DYNAMIC
operator||
name|RTF_MODIFIED
operator|)
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
operator|)
operator|->
name|siso_addr
operator|=
name|sc
operator|->
name|sc_nsap
expr_stmt|;
name|known_is
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_rt
operator|=
name|rt
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_age  *  * PURPOSE:			Time out snpac entries  *  * RETURNS:			  *  * SIDE EFFECTS:	  *  * NOTES:			When encountering an entry for the first time, snpac_age  *					may delete up to SNPAC_AGE too many seconds. Ie.  *					if the entry is added a moment before snpac_age is  *					called, the entry will immediately have SNPAC_AGE  *					seconds taken off the holding time, even though  *					it has only been held a brief moment.  *  *					The proper way to do this is set an expiry timeval  *					equal to current time + holding time. Then snpac_age  *					would time out entries where expiry date is older  *					than the current time.  */
end_comment

begin_macro
name|snpac_age
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|snpa_cache
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|timeout
argument_list|(
name|snpac_age
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|SNPAC_AGE
operator|*
name|hz
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|iso_snpac
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SNPAC_SIZE
condition|;
name|i
operator|++
operator|,
name|sc
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SNPA_PERM
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SNPA_VALID
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_ht
operator|-=
name|SNPAC_AGE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ht
operator|>
literal|0
condition|)
continue|continue;
else|else
name|snpac_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_ownmulti  *  * PURPOSE:			Determine if the snpa address is a multicast address  *					of the same type as the system.  *  * RETURNS:			true or false  *  * SIDE EFFECTS:	  *  * NOTES:			Used by interface drivers when not in eavesdrop mode   *					as interm kludge until  *					real multicast addresses can be configured  */
end_comment

begin_macro
name|snpac_ownmulti
argument_list|(
argument|snpa
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|snpa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
operator|(
name|iso_systype
operator|&
name|SNPA_ES
operator|)
operator|&&
operator|(
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|snpa
argument_list|,
operator|(
name|caddr_t
operator|)
name|all_es
operator|.
name|sc_snpa
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|iso_systype
operator|&
name|SNPA_IS
operator|)
operator|&&
operator|(
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|snpa
argument_list|,
operator|(
name|caddr_t
operator|)
name|all_is
operator|.
name|sc_snpa
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_flushifp  *  * PURPOSE:			Flush entries associated with specific ifp  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|snpac_flushifp
argument_list|(
argument|ifp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|snpa_cache
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|sc
operator|=
operator|&
name|iso_snpac
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SNPAC_SIZE
condition|;
name|i
operator|++
operator|,
name|sc
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ifp
operator|==
name|ifp
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SNPA_VALID
operator|)
condition|)
block|{
name|snpac_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_rtrequest  *  * PURPOSE:			Make a routing request  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			In the future, this should make a request of a user  *					level routing daemon.  */
end_comment

begin_macro
name|snpac_rtrequest
argument_list|(
argument|req
argument_list|,
argument|host
argument_list|,
argument|gateway
argument_list|,
argument|netmask
argument_list|,
argument|flags
argument_list|,
argument|ret_nrt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|gateway
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|netmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtentry
modifier|*
modifier|*
name|ret_nrt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iso_addr
modifier|*
name|r
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_SNPA
argument_list|)
name|printf
argument_list|(
literal|"snpac_rtrequest: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|RTM_ADD
condition|)
name|printf
argument_list|(
literal|"add"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|req
operator|==
name|RTM_DELETE
condition|)
name|printf
argument_list|(
literal|"delete"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"unknown command"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" dst: %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|host
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tgateway: %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|gateway
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|zap_isoaddr
parameter_list|(
name|dst
parameter_list|,
name|host
parameter_list|)
function_decl|;
name|zap_isoaddr
argument_list|(
name|gte
argument_list|,
name|gateway
argument_list|)
expr_stmt|;
name|zap_isoaddr
argument_list|(
name|msk
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
name|rtrequest
argument_list|(
name|req
argument_list|,
name|S
argument_list|(
name|dst
argument_list|)
argument_list|,
name|S
argument_list|(
name|gte
argument_list|)
argument_list|,
operator|(
name|netmask
condition|?
name|S
argument_list|(
name|msk
argument_list|)
else|:
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
operator|)
argument_list|,
name|flags
argument_list|,
name|ret_nrt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		snpac_addrt  *  * PURPOSE:			Associate a routing entry with an snpac entry  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			If a cache entry exists for gateway, then  *					make a routing entry (host, gateway) and associate  *					with gateway.  *  *					If a route already exists and is different, first delete  *					it.  *  *					This could be made more efficient by checking   *					the existing route before adding a new one.  */
end_comment

begin_macro
name|snpac_addrt
argument_list|(
argument|ifp
argument_list|,
argument|host
argument_list|,
argument|gateway
argument_list|,
argument|netmask
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|host
decl_stmt|,
modifier|*
name|gateway
decl_stmt|,
modifier|*
name|netmask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|snpa_cache
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|iso_addr
modifier|*
name|r
decl_stmt|;
name|SNPAC_LOOK
argument_list|(
name|sc
argument_list|,
name|gateway
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|host
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_da
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|zap_isoaddr
argument_list|(
name|dst
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|zap_isoaddr
argument_list|(
name|gte
argument_list|,
name|gateway
argument_list|)
expr_stmt|;
name|zap_isoaddr
argument_list|(
name|msk
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmask
condition|)
block|{
name|rtredirect
argument_list|(
name|S
argument_list|(
name|dst
argument_list|)
argument_list|,
name|S
argument_list|(
name|gte
argument_list|)
argument_list|,
name|S
argument_list|(
name|msk
argument_list|)
argument_list|,
name|RTF_DONE
argument_list|,
name|S
argument_list|(
name|gte
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_rt
argument_list|)
expr_stmt|;
block|}
else|else
name|rtredirect
argument_list|(
name|S
argument_list|(
name|dst
argument_list|)
argument_list|,
name|S
argument_list|(
name|gte
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
name|RTF_DONE
operator||
name|RTF_HOST
argument_list|,
name|S
argument_list|(
name|gte
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_rt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|ISO
end_endif

end_unit

