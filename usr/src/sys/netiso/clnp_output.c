begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)clnp_output.c	8.1 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/* $Header: /var/src/sys/netiso/RCS/clnp_output.c,v 5.0 89/02/08 12:00:15 hagens Exp $ */
end_comment

begin_comment
comment|/* $Source: /var/src/sys/netiso/RCS/clnp_output.c,v $ */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_var.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/clnp.h>
end_include

begin_include
include|#
directive|include
file|<netiso/clnp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|clnp_fixed
name|dt_template
init|=
block|{
name|ISO8473_CLNP
block|,
comment|/* network identifier */
literal|0
block|,
comment|/* length */
name|ISO8473_V1
block|,
comment|/* version */
name|CLNP_TTL
block|,
comment|/* ttl */
name|CLNP_DT
operator||
name|CNF_SEG_OK
operator||
name|CNF_ERR_OK
block|,
comment|/* type */
literal|0
block|,
comment|/* segment length */
literal|0
comment|/* checksum */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|clnp_fixed
name|raw_template
init|=
block|{
name|ISO8473_CLNP
block|,
comment|/* network identifier */
literal|0
block|,
comment|/* length */
name|ISO8473_V1
block|,
comment|/* version */
name|CLNP_TTL
block|,
comment|/* ttl */
name|CLNP_RAW
operator||
name|CNF_SEG_OK
operator||
name|CNF_ERR_OK
block|,
comment|/* type */
literal|0
block|,
comment|/* segment length */
literal|0
comment|/* checksum */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|clnp_fixed
name|echo_template
init|=
block|{
name|ISO8473_CLNP
block|,
comment|/* network identifier */
literal|0
block|,
comment|/* length */
name|ISO8473_V1
block|,
comment|/* version */
name|CLNP_TTL
block|,
comment|/* ttl */
name|CLNP_EC
operator||
name|CNF_SEG_OK
operator||
name|CNF_ERR_OK
block|,
comment|/* type */
literal|0
block|,
comment|/* segment length */
literal|0
comment|/* checksum */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|clnp_fixed
name|echor_template
init|=
block|{
name|ISO8473_CLNP
block|,
comment|/* network identifier */
literal|0
block|,
comment|/* length */
name|ISO8473_V1
block|,
comment|/* version */
name|CLNP_TTL
block|,
comment|/* ttl */
name|CLNP_ECR
operator||
name|CNF_SEG_OK
operator||
name|CNF_ERR_OK
block|,
comment|/* type */
literal|0
block|,
comment|/* segment length */
literal|0
comment|/* checksum */
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DECBIT
end_ifdef

begin_decl_stmt
name|u_char
name|qos_option
index|[]
init|=
block|{
name|CLNPOVAL_QOS
block|,
literal|1
block|,
name|CLNPOVAL_GLOBAL
operator||
name|CLNPOVAL_SEQUENCING
operator||
name|CLNPOVAL_LOWDELAY
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DECBIT */
end_comment

begin_decl_stmt
name|int
name|clnp_id
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* id for segmented dgrams */
end_comment

begin_comment
comment|/*  * FUNCTION:		clnp_output  *  * PURPOSE:			output the data in the mbuf as a clnp datagram  *  *					The data specified by m0 is sent as a clnp datagram.   *					The mbuf chain m0 will be freed when this routine has  *					returned.  *  *					If options is non-null, it points to an mbuf which contains  *					options to be sent with the datagram. The options must  *					be formatted in the mbuf according to clnp rules. Options  *					will not be freed.  *  *					Datalen specifies the length of the data in m0.   *  *					Src and dst are the addresses for the packet.   *  *					If route is non-null, it is used as the route for   *					the packet.   *  *					By default, a DT is sent. However, if flags& CNLP_SEND_ER  *					then an ER will be sent. If flags& CLNP_SEND_RAW, then  *					the packet will be send as raw clnp.  *  * RETURNS:			0	success  *					appropriate error code  *  * SIDE EFFECTS:	none  *  * NOTES:			  *					Flags are interpretated as follows:  *						CLNP_NO_SEG - do not allow this pkt to be segmented.  *						CLNP_NO_ER  - have pkt request ER suppression.  *						CLNP_SEND_RAW - send pkt as RAW DT rather than TP DT  *						CLNP_NO_CKSUM - don't compute clnp checksum  *						CLNP_ECHO - send as ECHO packet  *  *					When checking for a cached packet, clnp checks  *					that the route taken is still up. It does not  *					check that the route is still to the same destination.  *					This means that any entity that alters an existing  *					route for an isopcb (such as when a redirect arrives)  *					must invalidate the clnp cache. It might be perferable  *					to have clnp check that the route has the same dest, but  *					by avoiding this check, we save a call to iso_addrmatch1.  */
end_comment

begin_macro
name|clnp_output
argument_list|(
argument|m0
argument_list|,
argument|isop
argument_list|,
argument|datalen
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data for the packet */
end_comment

begin_decl_stmt
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* iso pcb */
end_comment

begin_decl_stmt
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bytes of data in m0 */
end_comment

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flags */
end_comment

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* return value of function */
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
comment|/* mbuf for clnp header chain */
specifier|register
name|struct
name|clnp_fixed
modifier|*
name|clnp
decl_stmt|;
comment|/* ptr to fixed part of hdr */
specifier|register
name|caddr_t
name|hoff
decl_stmt|;
comment|/* offset into header */
name|int
name|total_len
decl_stmt|;
comment|/* total length of packet */
name|struct
name|iso_addr
modifier|*
name|src
decl_stmt|;
comment|/* ptr to source address */
name|struct
name|iso_addr
modifier|*
name|dst
decl_stmt|;
comment|/* ptr to destination address */
name|struct
name|clnp_cache
name|clc
decl_stmt|;
comment|/* storage for cache information */
name|struct
name|clnp_cache
modifier|*
name|clcp
init|=
name|NULL
decl_stmt|;
comment|/* ptr to clc */
name|int
name|hdrlen
init|=
literal|0
decl_stmt|;
name|dst
operator|=
operator|&
name|isop
operator|->
name|isop_faddr
operator|->
name|siso_addr
expr_stmt|;
if|if
condition|(
name|isop
operator|->
name|isop_laddr
operator|==
literal|0
condition|)
block|{
name|struct
name|iso_ifaddr
modifier|*
name|ia
init|=
literal|0
decl_stmt|;
name|clnp_route
argument_list|(
name|dst
argument_list|,
operator|&
name|isop
operator|->
name|isop_route
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
operator|&
name|ia
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
literal|0
operator|||
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_ISO
condition|)
return|return
operator|(
name|ENETUNREACH
operator|)
return|;
name|src
operator|=
operator|&
name|ia
operator|->
name|ia_addr
operator|.
name|siso_addr
expr_stmt|;
block|}
else|else
name|src
operator|=
operator|&
name|isop
operator|->
name|isop_laddr
operator|->
name|siso_addr
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: to %s"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" from %s of %d bytes\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|src
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\toptions x%x, flags x%x, isop_clnpcache x%x\n"
argument_list|,
name|isop
operator|->
name|isop_options
argument_list|,
name|flags
argument_list|,
name|isop
operator|->
name|isop_clnpcache
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|isop
operator|->
name|isop_clnpcache
operator|!=
name|NULL
condition|)
block|{
name|clcp
operator|=
name|mtod
argument_list|(
name|isop
operator|->
name|isop_clnpcache
argument_list|,
expr|struct
name|clnp_cache
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Check if cache is valid ... 	 */
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: ck cache: clcp %x\n"
argument_list|,
name|clcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clcp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\tclc_dst %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|clcp
operator|->
name|clc_dst
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tisop_opts x%x, clc_opts x%x\n"
argument_list|,
name|isop
operator|->
name|isop_options
argument_list|,
name|clcp
operator|->
name|clc_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
condition|)
name|printf
argument_list|(
literal|"\tro_rt x%x, rt_flags x%x\n"
argument_list|,
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
argument_list|,
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
operator|->
name|rt_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tflags x%x, clc_flags x%x\n"
argument_list|,
name|flags
argument_list|,
name|clcp
operator|->
name|clc_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tclc_hdr x%x\n"
argument_list|,
name|clcp
operator|->
name|clc_hdr
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
if|if
condition|(
operator|(
name|clcp
operator|!=
name|NULL
operator|)
operator|&&
comment|/* cache exists */
operator|(
name|isop
operator|->
name|isop_options
operator|==
name|clcp
operator|->
name|clc_options
operator|)
operator|&&
comment|/* same options */
operator|(
name|iso_addrmatch1
argument_list|(
name|dst
argument_list|,
operator|&
name|clcp
operator|->
name|clc_dst
argument_list|)
operator|)
operator|&&
comment|/* dst still same */
operator|(
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
operator|!=
name|NULL
operator|)
operator|&&
comment|/* route exists */
operator|(
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
operator|==
name|clcp
operator|->
name|clc_rt
operator|)
operator|&&
comment|/* and is cached */
operator|(
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|&&
comment|/* route still up */
operator|(
name|flags
operator|==
name|clcp
operator|->
name|clc_flags
operator|)
operator|&&
comment|/* same flags */
operator|(
name|clcp
operator|->
name|clc_hdr
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* hdr mbuf exists */
comment|/* 		 *	The cache is valid 		 */
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: using cache\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|m
init|=
name|m_copy
argument_list|(
name|clcp
operator|->
name|clc_hdr
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 			 *	No buffers left to copy cached packet header. Use 			 *	the cached packet header this time, and 			 *	mark the hdr as vacant 			 */
name|m
operator|=
name|clcp
operator|->
name|clc_hdr
expr_stmt|;
name|clcp
operator|->
name|clc_hdr
operator|=
name|NULL
expr_stmt|;
block|}
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
comment|/* ASSUMES pkt hdr is 1 mbuf long */
name|clnp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnp_fixed
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|clnp_optidx
modifier|*
name|oidx
init|=
name|NULL
decl_stmt|;
comment|/* index to clnp options */
comment|/* 		 *	The cache is not valid. Allocate an mbuf (if necessary) 		 *	to hold cached info. If one is not available, then 		 *	don't bother with the cache 		 */
name|INCSTAT
argument_list|(
name|cns_cachemiss
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CLNP_NOCACHE
condition|)
block|{
name|clcp
operator|=
operator|&
name|clc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isop
operator|->
name|isop_clnpcache
operator|==
name|NULL
condition|)
block|{
comment|/* 				 *	There is no clnpcache. Allocate an mbuf to hold one 				 */
if|if
condition|(
operator|(
name|isop
operator|->
name|isop_clnpcache
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 					 *	No mbufs available. Pretend that we don't want 					 *	caching this time. 					 */
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: no mbufs to allocate to cache\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|flags
operator||=
name|CLNP_NOCACHE
expr_stmt|;
name|clcp
operator|=
operator|&
name|clc
expr_stmt|;
block|}
else|else
block|{
name|clcp
operator|=
name|mtod
argument_list|(
name|isop
operator|->
name|isop_clnpcache
argument_list|,
expr|struct
name|clnp_cache
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 *	A clnpcache mbuf exists. If the clc_hdr is not null, 				 *	we must free it, as a new one is about to be created. 				 */
name|clcp
operator|=
name|mtod
argument_list|(
name|isop
operator|->
name|isop_clnpcache
argument_list|,
expr|struct
name|clnp_cache
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|clcp
operator|->
name|clc_hdr
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 *	The clc_hdr is not null but a clnpcache mbuf exists. 					 *	This means that there was a cache, but the existing 					 *	copy of the hdr is no longer valid. Free it now 					 *	before we lose the pointer to it. 					 */
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: freeing old clc_hdr 0x%x\n"
argument_list|,
name|clcp
operator|->
name|clc_hdr
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|m_free
parameter_list|(
name|clcp
operator|->
name|clc_hdr
parameter_list|)
function_decl|;
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: freed old clc_hdr (done)\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: NEW clcp x%x\n"
argument_list|,
name|clcp
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|clcp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_cache
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|isop
operator|->
name|isop_optindex
condition|)
name|oidx
operator|=
name|mtod
argument_list|(
name|isop
operator|->
name|isop_optindex
argument_list|,
expr|struct
name|clnp_optidx
operator|*
argument_list|)
expr_stmt|;
comment|/* 		 *	Don't allow packets with security, quality of service, 		 *	priority, or error report options to be sent. 		 */
if|if
condition|(
operator|(
name|isop
operator|->
name|isop_options
operator|)
operator|&&
operator|(
name|oidx
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|oidx
operator|->
name|cni_securep
operator|)
operator|||
operator|(
name|oidx
operator|->
name|cni_priorp
operator|)
operator|||
operator|(
name|oidx
operator|->
name|cni_qos_formatp
operator|)
operator|||
operator|(
name|oidx
operator|->
name|cni_er_reason
operator|!=
name|ER_INVALREAS
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: pkt dropped - option unsupported\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|m_freem
parameter_list|(
name|m0
parameter_list|)
function_decl|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* 		 *	Don't allow any invalid flags to be set 		 */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|CLNP_VFLAGS
operator|)
operator|)
operator|!=
name|flags
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: packet dropped - flags unsupported\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|INCSTAT
parameter_list|(
name|cns_odropped
parameter_list|)
function_decl|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 *	Don't allow funny lengths on dst; src may be zero in which 		 *	case we insert the source address based upon the interface 		 */
if|if
condition|(
operator|(
name|src
operator|->
name|isoa_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
operator|)
operator|||
operator|(
name|dst
operator|->
name|isoa_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|dst
operator|->
name|isoa_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|INCSTAT
argument_list|(
name|cns_odropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
block|}
comment|/* 		 *	Grab mbuf to contain header 		 */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|INCSTAT
argument_list|(
name|cns_odropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|INCSTAT
argument_list|(
name|cns_sent
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|clnp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnp_fixed
operator|*
argument_list|)
expr_stmt|;
name|clcp
operator|->
name|clc_segoff
operator|=
literal|0
expr_stmt|;
comment|/* 		 *	Fill in all of fixed hdr except lengths and checksum 		 */
if|if
condition|(
name|flags
operator|&
name|CLNP_SEND_RAW
condition|)
block|{
operator|*
name|clnp
operator|=
name|raw_template
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|CLNP_ECHO
condition|)
block|{
operator|*
name|clnp
operator|=
name|echo_template
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|CLNP_ECHOR
condition|)
block|{
operator|*
name|clnp
operator|=
name|echor_template
expr_stmt|;
block|}
else|else
block|{
operator|*
name|clnp
operator|=
name|dt_template
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CLNP_NO_SEG
condition|)
name|clnp
operator|->
name|cnf_type
operator|&=
operator|~
name|CNF_SEG_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CLNP_NO_ER
condition|)
name|clnp
operator|->
name|cnf_type
operator|&=
operator|~
name|CNF_ERR_OK
expr_stmt|;
comment|/* 		 *	Route packet; special case for source rt 		 */
if|if
condition|(
operator|(
name|isop
operator|->
name|isop_options
operator|)
operator|&&
name|CLNPSRCRT_VALID
argument_list|(
name|oidx
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: calling clnp_srcroute\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|error
init|=
name|clnp_srcroute
argument_list|(
name|isop
operator|->
name|isop_options
argument_list|,
name|oidx
argument_list|,
operator|&
name|isop
operator|->
name|isop_route
argument_list|,
operator|&
name|clcp
operator|->
name|clc_firsthop
argument_list|,
operator|&
name|clcp
operator|->
name|clc_ifa
argument_list|,
name|dst
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|ENDDEBUG
name|error
init|=
name|clnp_route
argument_list|(
name|dst
argument_list|,
operator|&
name|isop
operator|->
name|isop_route
argument_list|,
name|flags
argument_list|,
operator|&
name|clcp
operator|->
name|clc_firsthop
argument_list|,
operator|&
name|clcp
operator|->
name|clc_ifa
argument_list|)
decl_stmt|;
block|}
if|if
condition|(
name|error
operator|||
operator|(
name|clcp
operator|->
name|clc_ifa
operator|==
literal|0
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: route failed, errno %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"@clcp:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|clcp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_cache
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
goto|goto
name|bad
goto|;
block|}
name|clcp
operator|->
name|clc_rt
operator|=
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
expr_stmt|;
comment|/* XXX */
name|clcp
operator|->
name|clc_ifp
operator|=
name|clcp
operator|->
name|clc_ifa
operator|->
name|ia_ifp
expr_stmt|;
comment|/* XXX */
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: packet routed to %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|clcp
operator|->
name|clc_firsthop
operator|)
operator|->
name|siso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 		 *	If src address is not yet specified, use address of  		 *	interface. NOTE: this will now update the laddr field in 		 *	the isopcb. Is this desirable? RAH? 		 */
if|if
condition|(
name|src
operator|->
name|isoa_len
operator|==
literal|0
condition|)
block|{
name|src
operator|=
operator|&
operator|(
name|clcp
operator|->
name|clc_ifa
operator|->
name|ia_addr
operator|.
name|siso_addr
operator|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_OUTPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_output: new src %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
comment|/* 		 *	Insert the source and destination address, 		 */
name|hoff
operator|=
operator|(
name|caddr_t
operator|)
name|clnp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_fixed
argument_list|)
expr_stmt|;
name|CLNP_INSERT_ADDR
argument_list|(
name|hoff
argument_list|,
operator|*
name|dst
argument_list|)
expr_stmt|;
name|CLNP_INSERT_ADDR
argument_list|(
name|hoff
argument_list|,
operator|*
name|src
argument_list|)
expr_stmt|;
comment|/* 		 *	Leave room for the segment part, if segmenting is selected 		 */
if|if
condition|(
name|clnp
operator|->
name|cnf_type
operator|&
name|CNF_SEG_OK
condition|)
block|{
name|clcp
operator|->
name|clc_segoff
operator|=
name|hoff
operator|-
operator|(
name|caddr_t
operator|)
name|clnp
expr_stmt|;
name|hoff
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_segment
argument_list|)
expr_stmt|;
block|}
name|clnp
operator|->
name|cnf_hdr_len
operator|=
name|m
operator|->
name|m_len
operator|=
call|(
name|u_char
call|)
argument_list|(
name|hoff
operator|-
operator|(
name|caddr_t
operator|)
name|clnp
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|clnp
operator|->
name|cnf_hdr_len
expr_stmt|;
ifdef|#
directive|ifdef
name|DECBIT
comment|/* 		 *	Add the globally unique QOS (with room for congestion experienced 		 *	bit). I can safely assume that this option is not in the options 		 *	mbuf below because I checked that the option was not specified 		 *	previously 		 */
if|if
condition|(
operator|(
name|m
operator|->
name|m_len
operator|+
sizeof|sizeof
argument_list|(
name|qos_option
argument_list|)
operator|)
operator|<
name|MLEN
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|qos_option
argument_list|,
name|hoff
argument_list|,
sizeof|sizeof
argument_list|(
name|qos_option
argument_list|)
argument_list|)
expr_stmt|;
name|clnp
operator|->
name|cnf_hdr_len
operator|+=
sizeof|sizeof
argument_list|(
name|qos_option
argument_list|)
expr_stmt|;
name|hdrlen
operator|+=
sizeof|sizeof
argument_list|(
name|qos_option
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
name|qos_option
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DECBIT */
comment|/* 		 *	If an options mbuf is present, concatenate a copy to the hdr mbuf. 		 */
if|if
condition|(
name|isop
operator|->
name|isop_options
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|opt_copy
init|=
name|m_copy
argument_list|(
name|isop
operator|->
name|isop_options
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt_copy
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Link in place */
name|opt_copy
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|opt_copy
expr_stmt|;
comment|/* update size of header */
name|clnp
operator|->
name|cnf_hdr_len
operator|+=
name|opt_copy
operator|->
name|m_len
expr_stmt|;
name|hdrlen
operator|+=
name|opt_copy
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|hdrlen
operator|>
name|CLNP_HDR_MAX
condition|)
block|{
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 *	Now set up the cache entry in the pcb 		 */
if|if
condition|(
operator|(
name|flags
operator|&
name|CLNP_NOCACHE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|clcp
operator|->
name|clc_hdr
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|clnp
operator|->
name|cnf_hdr_len
argument_list|)
condition|)
block|{
name|clcp
operator|->
name|clc_dst
operator|=
operator|*
name|dst
expr_stmt|;
name|clcp
operator|->
name|clc_flags
operator|=
name|flags
expr_stmt|;
name|clcp
operator|->
name|clc_options
operator|=
name|isop
operator|->
name|isop_options
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 *	If small enough for interface, send directly 	 *	Fill in segmentation part of hdr if using the full protocol 	 */
name|total_len
operator|=
name|clnp
operator|->
name|cnf_hdr_len
operator|+
name|datalen
expr_stmt|;
if|if
condition|(
name|clnp
operator|->
name|cnf_type
operator|&
name|CNF_SEG_OK
condition|)
block|{
name|struct
name|clnp_segment
name|seg_part
decl_stmt|;
comment|/* segment part of hdr */
name|seg_part
operator|.
name|cng_id
operator|=
name|htons
argument_list|(
name|clnp_id
operator|++
argument_list|)
expr_stmt|;
name|seg_part
operator|.
name|cng_off
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|seg_part
operator|.
name|cng_tot_len
operator|=
name|htons
argument_list|(
name|total_len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|seg_part
argument_list|,
operator|(
name|caddr_t
operator|)
name|clnp
operator|+
name|clcp
operator|->
name|clc_segoff
argument_list|,
sizeof|sizeof
argument_list|(
name|seg_part
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|total_len
operator|<=
name|SN_MTU
argument_list|(
name|clcp
operator|->
name|clc_ifp
argument_list|,
name|clcp
operator|->
name|clc_rt
argument_list|)
condition|)
block|{
name|HTOC
argument_list|(
name|clnp
operator|->
name|cnf_seglen_msb
argument_list|,
name|clnp
operator|->
name|cnf_seglen_lsb
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|total_len
expr_stmt|;
comment|/* 		 *	Compute clnp checksum (on header only) 		 */
if|if
condition|(
name|flags
operator|&
name|CLNP_NO_CKSUM
condition|)
block|{
name|HTOC
argument_list|(
name|clnp
operator|->
name|cnf_cksum_msb
argument_list|,
name|clnp
operator|->
name|cnf_cksum_lsb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iso_gen_csum
argument_list|(
name|m
argument_list|,
name|CLNP_CKSUM_OFF
argument_list|,
operator|(
name|int
operator|)
name|clnp
operator|->
name|cnf_hdr_len
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_DUMPOUT
argument_list|)
name|struct
name|mbuf
modifier|*
name|mdump
init|=
name|m
decl_stmt|;
name|printf
argument_list|(
literal|"clnp_output: sending dg:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|mdump
operator|!=
name|NULL
condition|)
block|{
name|dump_buf
argument_list|(
name|mtod
argument_list|(
name|mdump
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mdump
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|mdump
operator|=
name|mdump
operator|->
name|m_next
expr_stmt|;
block|}
name|ENDDEBUG
name|error
init|=
name|SN_OUTPUT
argument_list|(
name|clcp
argument_list|,
name|m
argument_list|)
decl_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
comment|/* 		 * Too large for interface; fragment if possible. 		 */
name|error
operator|=
name|clnp_fragment
argument_list|(
name|clcp
operator|->
name|clc_ifp
argument_list|,
name|m
argument_list|,
name|clcp
operator|->
name|clc_firsthop
argument_list|,
name|total_len
argument_list|,
name|clcp
operator|->
name|clc_segoff
argument_list|,
name|flags
argument_list|,
name|clcp
operator|->
name|clc_rt
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|error
condition|)
block|{
name|clnp_stat
operator|.
name|cns_sent
operator|--
expr_stmt|;
name|clnp_stat
operator|.
name|cns_odropped
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_function
name|int
name|clnp_ctloutput
parameter_list|()
block|{ }
end_function

end_unit

