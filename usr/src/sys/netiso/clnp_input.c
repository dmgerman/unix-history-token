begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/* $Header: /var/src/sys/netiso/RCS/clnp_input.c,v 5.1 89/02/09 16:20:32 hagens Exp $ */
end_comment

begin_comment
comment|/* $Source: /var/src/sys/netiso/RCS/clnp_input.c,v $ */
end_comment

begin_comment
comment|/*	@(#)clnp_input.c	7.9 (Berkeley) %G% */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /var/src/sys/netiso/RCS/clnp_input.c,v 5.1 89/02/09 16:20:32 hagens Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/if_types.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"iso_var.h"
end_include

begin_include
include|#
directive|include
file|"iso_snpac.h"
end_include

begin_include
include|#
directive|include
file|"clnp.h"
end_include

begin_include
include|#
directive|include
file|"clnl.h"
end_include

begin_include
include|#
directive|include
file|"esis.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/if_ether.h"
end_include

begin_include
include|#
directive|include
file|"eonvar.h"
end_include

begin_include
include|#
directive|include
file|"clnp_stat.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_decl_stmt
name|u_char
name|clnp_protox
index|[
name|ISOPROTO_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|clnl_protosw
name|clnl_protox
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clnpqmaxlen
init|=
name|IFQ_MAXLEN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RAH? why is this a variable */
end_comment

begin_function_decl
name|struct
name|mbuf
modifier|*
name|clnp_data_ck
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|clnp_input
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esis_input
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ISO_X25ESIS
end_ifdef

begin_function_decl
name|int
name|x25esis_input
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|ISO_X25ESIS
end_endif

begin_comment
comment|/*  * FUNCTION:		clnp_init  *  * PURPOSE:			clnp initialization. Fill in clnp switch tables.  *  * RETURNS:			none  *  * SIDE EFFECTS:	fills in clnp_protox table with correct offsets into  *					the isosw table.  *  * NOTES:			  */
end_comment

begin_macro
name|clnp_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|protosw
modifier|*
name|pr
decl_stmt|;
comment|/* 	 *	CLNP protox initialization 	 */
if|if
condition|(
operator|(
name|pr
operator|=
name|pffindproto
argument_list|(
name|PF_ISO
argument_list|,
name|ISOPROTO_RAW
argument_list|,
name|SOCK_RAW
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"clnl_init: no raw CLNP\n"
argument_list|)
expr_stmt|;
else|else
name|clnp_protox
index|[
name|ISOPROTO_RAW
index|]
operator|=
name|pr
operator|-
name|isosw
expr_stmt|;
if|if
condition|(
operator|(
name|pr
operator|=
name|pffindproto
argument_list|(
name|PF_ISO
argument_list|,
name|ISOPROTO_TP
argument_list|,
name|SOCK_SEQPACKET
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"clnl_init: no tp/clnp\n"
argument_list|)
expr_stmt|;
else|else
name|clnp_protox
index|[
name|ISOPROTO_TP
index|]
operator|=
name|pr
operator|-
name|isosw
expr_stmt|;
comment|/* 	 *	CLNL protox initialization 	 */
name|clnl_protox
index|[
name|ISO8473_CLNP
index|]
operator|.
name|clnl_input
operator|=
name|clnp_input
expr_stmt|;
name|clnlintrq
operator|.
name|ifq_maxlen
operator|=
name|clnpqmaxlen
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		clnlintr  *  * PURPOSE:			Process a packet on the clnl input queue  *  * RETURNS:			nothing.  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|clnlintr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* ptr to first mbuf of pkt */
specifier|register
name|struct
name|clnl_fixed
modifier|*
name|clnl
decl_stmt|;
comment|/* ptr to fixed part of clnl hdr */
name|int
name|s
decl_stmt|;
comment|/* save and restore priority */
name|struct
name|clnl_protosw
modifier|*
name|clnlsw
decl_stmt|;
comment|/* ptr to protocol switch */
name|struct
name|snpa_hdr
name|sh
decl_stmt|;
comment|/* subnetwork hdr */
comment|/* 	 *	Get next datagram off clnl input queue 	 */
name|next
label|:
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* IF_DEQUEUESNPAHDR(&clnlintrq, m, sh);*/
name|IF_DEQUEUE
argument_list|(
operator|&
name|clnlintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
comment|/* nothing to do */
return|return;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sh
argument_list|,
sizeof|sizeof
argument_list|(
name|sh
argument_list|)
argument_list|)
expr_stmt|;
name|sh
operator|.
name|snh_flags
operator|=
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_MCAST
operator||
name|M_BCAST
operator|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|sh
operator|.
name|snh_ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|)
operator|->
name|if_type
condition|)
block|{
specifier|extern
name|int
name|ether_output
parameter_list|()
function_decl|;
case|case
name|IFT_EON
case|:
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|sh
operator|.
name|snh_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|+
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|sh
operator|.
name|snh_shost
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|sh
operator|.
name|snh_dhost
index|[
literal|4
index|]
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|_offsetof
argument_list|(
expr|struct
name|eon_hdr
argument_list|,
name|eonh_class
argument_list|)
index|]
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|EONIPLEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|EONIPLEN
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|EONIPLEN
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|sh
operator|.
name|snh_ifp
operator|->
name|if_output
operator|==
name|ether_output
condition|)
block|{
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
operator|->
name|ether_dhost
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|sh
operator|.
name|snh_dhost
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sh
operator|.
name|snh_dhost
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_INPUT
argument_list|)
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"clnlintr: src:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
name|sh
operator|.
name|snh_shost
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|,
operator|(
name|i
operator|<
literal|5
operator|)
condition|?
literal|':'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" dst:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
name|sh
operator|.
name|snh_dhost
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|,
operator|(
name|i
operator|<
literal|5
operator|)
condition|?
literal|':'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	Get the fixed part of the clnl header into the first mbuf. 	 *	Drop the packet if this fails. 	 *	Do not call m_pullup if we have a cluster mbuf or the 	 *	data is not there. 	 */
if|if
condition|(
operator|(
name|IS_CLUSTER
argument_list|(
name|m
argument_list|)
operator|||
operator|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|clnl_fixed
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|clnl_fixed
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|INCSTAT
argument_list|(
name|cns_toosmall
argument_list|)
expr_stmt|;
comment|/* TODO: use clnl stats */
goto|goto
name|next
goto|;
comment|/* m_pullup discards mbuf */
block|}
name|clnl
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnl_fixed
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 *	Drop packet if the length of the header is not reasonable. 	 */
if|if
condition|(
operator|(
name|clnl
operator|->
name|cnf_hdr_len
operator|<
name|CLNP_HDR_MIN
operator|)
operator|||
operator|(
name|clnl
operator|->
name|cnf_hdr_len
operator|>
name|CLNP_HDR_MAX
operator|)
condition|)
block|{
name|INCSTAT
argument_list|(
name|cns_badhlen
argument_list|)
expr_stmt|;
comment|/* TODO: use clnl stats */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 	 *	If the header is not contained in this mbuf, make it so. 	 *	Drop packet if this fails. 	 *	Note: m_pullup will allocate a cluster mbuf if necessary 	 */
if|if
condition|(
name|clnl
operator|->
name|cnf_hdr_len
operator|>
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
operator|(
name|int
operator|)
name|clnl
operator|->
name|cnf_hdr_len
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|INCSTAT
argument_list|(
name|cns_badhlen
argument_list|)
expr_stmt|;
comment|/* TODO: use clnl stats */
goto|goto
name|next
goto|;
comment|/* m_pullup discards mbuf */
block|}
name|clnl
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnl_fixed
operator|*
argument_list|)
expr_stmt|;
block|}
name|clnlsw
operator|=
operator|&
name|clnl_protox
index|[
name|clnl
operator|->
name|cnf_proto_id
index|]
expr_stmt|;
if|if
condition|(
name|clnlsw
operator|->
name|clnl_input
condition|)
call|(
modifier|*
name|clnlsw
operator|->
name|clnl_input
call|)
argument_list|(
name|m
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		clnp_input  *  * PURPOSE:			process an incoming clnp packet  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	increments fields of clnp_stat structure.  *					  * NOTES:  *	TODO: I would like to make seg_part a pointer into the mbuf, but   *	will it be correctly aligned?  */
end_comment

begin_macro
name|clnp_input
argument_list|(
argument|m
argument_list|,
argument|shp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to first mbuf of pkt */
end_comment

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subnetwork header */
end_comment

begin_block
block|{
specifier|register
name|struct
name|clnp_fixed
modifier|*
name|clnp
decl_stmt|;
comment|/* ptr to fixed part of header */
name|struct
name|sockaddr_iso
name|source
decl_stmt|;
comment|/* source address of pkt */
name|struct
name|sockaddr_iso
name|target
decl_stmt|;
comment|/* destination address of pkt */
define|#
directive|define
name|src
value|source.siso_addr
define|#
directive|define
name|dst
value|target.siso_addr
name|caddr_t
name|hoff
decl_stmt|;
comment|/* current offset in packet */
name|caddr_t
name|hend
decl_stmt|;
comment|/* address of end of header info */
name|struct
name|clnp_segment
name|seg_part
decl_stmt|;
comment|/* segment part of hdr */
name|int
name|seg_off
init|=
literal|0
decl_stmt|;
comment|/* offset of segment part of hdr */
name|int
name|seg_len
decl_stmt|;
comment|/* length of packet data&hdr in bytes */
name|struct
name|clnp_optidx
name|oidx
decl_stmt|,
modifier|*
name|oidxp
init|=
name|NULL
decl_stmt|;
comment|/* option index */
specifier|extern
name|int
name|iso_systype
decl_stmt|;
comment|/* used by ESIS config resp */
specifier|extern
name|struct
name|sockaddr_iso
name|blank_siso
decl_stmt|;
comment|/* used for initializing */
name|int
name|need_afrin
init|=
literal|0
decl_stmt|;
comment|/* true if congestion experienced */
comment|/* which means you need afrin nose */
comment|/* spray. How clever! */
name|IFDEBUG
argument_list|(
argument|D_INPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_input: proccessing dg; First mbuf m_len %d, m_type x%x, %s\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_type
argument_list|,
name|IS_CLUSTER
argument_list|(
name|m
argument_list|)
condition|?
literal|"cluster"
else|:
literal|"normal"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|need_afrin
init|=
literal|0
decl_stmt|;
comment|/* 	 *	If no iso addresses have been set, there is nothing 	 *	to do with the packet. 	 */
if|if
condition|(
name|iso_ifaddr
operator|==
name|NULL
condition|)
block|{
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|ADDR_DESTUNREACH
argument_list|)
expr_stmt|;
return|return;
block|}
name|INCSTAT
argument_list|(
name|cns_total
argument_list|)
expr_stmt|;
name|clnp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnp_fixed
operator|*
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_DUMPIN
argument_list|)
name|struct
name|mbuf
modifier|*
name|mhead
decl_stmt|;
name|int
name|total_len
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"clnp_input: clnp header:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|clnp
operator|->
name|cnf_hdr_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clnp_input: mbuf chain:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|mhead
operator|=
name|m
init|;
name|mhead
operator|!=
name|NULL
condition|;
name|mhead
operator|=
name|mhead
operator|->
name|m_next
control|)
block|{
name|printf
argument_list|(
literal|"m x%x, len %d\n"
argument_list|,
name|mhead
argument_list|,
name|mhead
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|total_len
operator|+=
name|mhead
operator|->
name|m_len
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"clnp_input: total length of mbuf chain %d:\n"
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	Compute checksum (if necessary) and drop packet if 	 *	checksum does not match 	 */
if|if
condition|(
name|CKSUM_REQUIRED
argument_list|(
name|clnp
argument_list|)
operator|&&
name|iso_check_csum
argument_list|(
name|m
argument_list|,
operator|(
name|int
operator|)
name|clnp
operator|->
name|cnf_hdr_len
argument_list|)
condition|)
block|{
name|INCSTAT
argument_list|(
name|cns_badcsum
argument_list|)
expr_stmt|;
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|GEN_BADCSUM
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|clnp
operator|->
name|cnf_vers
operator|!=
name|ISO8473_V1
condition|)
block|{
name|INCSTAT
argument_list|(
name|cns_badvers
argument_list|)
expr_stmt|;
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|DISC_UNSUPPVERS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* check mbuf data length: clnp_data_ck will free mbuf upon error */
name|CTOH
argument_list|(
name|clnp
operator|->
name|cnf_seglen_msb
argument_list|,
name|clnp
operator|->
name|cnf_seglen_lsb
argument_list|,
name|seg_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|clnp_data_ck
argument_list|(
name|m
argument_list|,
name|seg_len
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|clnp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnp_fixed
operator|*
argument_list|)
expr_stmt|;
name|hend
operator|=
operator|(
name|caddr_t
operator|)
name|clnp
operator|+
name|clnp
operator|->
name|cnf_hdr_len
expr_stmt|;
comment|/*  	 *	extract the source and destination address 	 *	drop packet on failure 	 */
name|source
operator|=
name|target
operator|=
name|blank_siso
expr_stmt|;
name|hoff
operator|=
operator|(
name|caddr_t
operator|)
name|clnp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_fixed
argument_list|)
expr_stmt|;
name|CLNP_EXTRACT_ADDR
argument_list|(
name|dst
argument_list|,
name|hoff
argument_list|,
name|hend
argument_list|)
expr_stmt|;
if|if
condition|(
name|hoff
operator|==
operator|(
name|caddr_t
operator|)
literal|0
condition|)
block|{
name|INCSTAT
argument_list|(
name|cns_badaddr
argument_list|)
expr_stmt|;
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|GEN_INCOMPLETE
argument_list|)
expr_stmt|;
return|return;
block|}
name|CLNP_EXTRACT_ADDR
argument_list|(
name|src
argument_list|,
name|hoff
argument_list|,
name|hend
argument_list|)
expr_stmt|;
if|if
condition|(
name|hoff
operator|==
operator|(
name|caddr_t
operator|)
literal|0
condition|)
block|{
name|INCSTAT
argument_list|(
name|cns_badaddr
argument_list|)
expr_stmt|;
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|GEN_INCOMPLETE
argument_list|)
expr_stmt|;
return|return;
block|}
name|IFDEBUG
argument_list|(
argument|D_INPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_input: from %s"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" to %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	extract the segmentation information, if it is present. 	 *	drop packet on failure 	 */
if|if
condition|(
operator|(
operator|(
name|clnp
operator|->
name|cnf_type
operator|&
name|CNF_TYPE
operator|)
operator|!=
name|CLNP_ER
operator|)
operator|&&
operator|(
name|clnp
operator|->
name|cnf_type
operator|&
name|CNF_SEG_OK
operator|)
condition|)
block|{
if|if
condition|(
name|hoff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_segment
argument_list|)
operator|>
name|hend
condition|)
block|{
name|INCSTAT
argument_list|(
name|cns_noseg
argument_list|)
expr_stmt|;
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|GEN_INCOMPLETE
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|hoff
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|seg_part
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_segment
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure segmentation fields are in host order */
name|seg_part
operator|.
name|cng_id
operator|=
name|ntohs
argument_list|(
name|seg_part
operator|.
name|cng_id
argument_list|)
expr_stmt|;
name|seg_part
operator|.
name|cng_off
operator|=
name|ntohs
argument_list|(
name|seg_part
operator|.
name|cng_off
argument_list|)
expr_stmt|;
name|seg_part
operator|.
name|cng_tot_len
operator|=
name|ntohs
argument_list|(
name|seg_part
operator|.
name|cng_tot_len
argument_list|)
expr_stmt|;
name|seg_off
operator|=
name|hoff
operator|-
operator|(
name|caddr_t
operator|)
name|clnp
expr_stmt|;
name|hoff
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_segment
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 *	process options if present. If clnp_opt_sanity returns 	 *	false (indicating an error was found in the options) or 	 *	an unsupported option was found 	 *	then drop packet and emit an ER. 	 */
if|if
condition|(
name|hoff
operator|<
name|hend
condition|)
block|{
name|int
name|errcode
decl_stmt|;
name|oidxp
operator|=
operator|&
name|oidx
expr_stmt|;
name|errcode
operator|=
name|clnp_opt_sanity
argument_list|(
name|m
argument_list|,
name|hoff
argument_list|,
name|hend
operator|-
name|hoff
argument_list|,
name|oidxp
argument_list|)
expr_stmt|;
comment|/* we do not support security */
if|if
condition|(
operator|(
name|errcode
operator|==
literal|0
operator|)
operator|&&
operator|(
name|oidxp
operator|->
name|cni_securep
operator|)
condition|)
name|errcode
operator|=
name|DISC_UNSUPPSECURE
expr_stmt|;
comment|/* the er option is valid with ER pdus only */
if|if
condition|(
operator|(
name|errcode
operator|==
literal|0
operator|)
operator|&&
operator|(
name|oidxp
operator|->
name|cni_er_reason
operator|!=
name|ER_INVALREAS
operator|)
operator|&&
operator|(
operator|(
name|clnp
operator|->
name|cnf_type
operator|&
name|CNF_TYPE
operator|)
operator|!=
name|CLNP_ER
operator|)
condition|)
name|errcode
operator|=
name|DISC_UNSUPPOPT
expr_stmt|;
ifdef|#
directive|ifdef
name|DECBIT
comment|/* check if the congestion experienced bit is set */
if|if
condition|(
name|oidxp
operator|->
name|cni_qos_formatp
condition|)
block|{
name|caddr_t
name|qosp
init|=
name|CLNP_OFFTOOPT
argument_list|(
name|m
argument_list|,
name|oidxp
operator|->
name|cni_qos_formatp
argument_list|)
decl_stmt|;
name|u_char
name|qos
init|=
operator|*
name|qosp
decl_stmt|;
name|need_afrin
operator|=
operator|(
operator|(
name|qos
operator|&
operator|(
name|CLNPOVAL_GLOBAL
operator||
name|CLNPOVAL_CONGESTED
operator|)
operator|)
operator|==
operator|(
name|CLNPOVAL_GLOBAL
operator||
name|CLNPOVAL_CONGESTED
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|need_afrin
condition|)
name|INCSTAT
argument_list|(
name|cns_congest_rcvd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DECBIT
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
name|clnp_discard
argument_list|(
name|m
argument_list|,
operator|(
name|char
operator|)
name|errcode
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_INPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_input: dropped (err x%x) due to bad options\n"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return;
block|}
block|}
comment|/* 	 *	check if this packet is for us. if not, then forward 	 */
if|if
condition|(
name|clnp_ours
argument_list|(
operator|&
name|dst
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_INPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_input: forwarding packet not for us\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|clnp_forward
argument_list|(
name|m
argument_list|,
name|seg_len
argument_list|,
operator|&
name|dst
argument_list|,
name|oidxp
argument_list|,
name|seg_off
argument_list|,
name|shp
argument_list|)
decl_stmt|;
return|return;
block|}
comment|/* 	 *	ESIS Configuration Response Function 	 * 	 *	If the packet received was sent to the multicast address 	 *	all end systems, then send an esh to the source 	 */
if|if
condition|(
operator|(
name|shp
operator|->
name|snh_flags
operator|&
name|M_MCAST
operator|)
operator|&&
operator|(
name|iso_systype
operator|==
name|SNPA_ES
operator|)
condition|)
block|{
specifier|extern
name|short
name|esis_holding_time
decl_stmt|;
name|esis_shoutput
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|ESIS_ESH
argument_list|,
name|esis_holding_time
argument_list|,
name|shp
operator|->
name|snh_shost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	If this is a fragment, then try to reassemble it. If clnp_reass 	 *	returns non NULL, the packet has been reassembled, and should 	 *	be give to TP. Otherwise the fragment has been delt with 	 *	by the reassembly code (either stored or deleted). In either case 	 *	we should have nothing more to do with it. 	 */
if|if
condition|(
operator|(
operator|(
name|clnp
operator|->
name|cnf_type
operator|&
name|CNF_TYPE
operator|)
operator|!=
name|CLNP_ER
operator|)
operator|&&
operator|(
name|clnp
operator|->
name|cnf_type
operator|&
name|CNF_SEG_OK
operator|)
operator|&&
operator|(
name|seg_len
operator|!=
name|seg_part
operator|.
name|cng_tot_len
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
if|if
condition|(
operator|(
name|m0
operator|=
name|clnp_reass
argument_list|(
name|m
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|seg_part
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|m0
expr_stmt|;
name|clnp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnp_fixed
operator|*
argument_list|)
expr_stmt|;
name|INCSTAT
argument_list|(
name|cns_reassembled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
block|}
comment|/* 	 *	give the packet to the higher layer 	 * 	 *	Note: the total length of packet 	 *	is the total length field of the segmentation part, 	 *	or, if absent, the segment length field of the 	 *	header. 	 */
name|INCSTAT
argument_list|(
name|cns_delivered
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|clnp
operator|->
name|cnf_type
operator|&
name|CNF_TYPE
condition|)
block|{
case|case
name|CLNP_ER
case|:
comment|/* 		 *	This ER must have the er option. 		 *	If the option is not present, discard datagram. 		 */
if|if
condition|(
name|oidxp
operator|==
name|NULL
operator|||
name|oidxp
operator|->
name|cni_er_reason
operator|==
name|ER_INVALREAS
condition|)
block|{
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|GEN_HDRSYNTAX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clnp_er_input
argument_list|(
name|m
argument_list|,
operator|&
name|src
argument_list|,
name|oidxp
operator|->
name|cni_er_reason
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLNP_DT
case|:
if|if
condition|(
name|need_afrin
condition|)
block|{
comment|/* NOTE: do this before TP gets the packet so tp ack can use info*/
name|IFDEBUG
argument_list|(
argument|D_INPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_input: Calling tpclnp_ctlinput(%s)\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tpclnp_ctlinput1
argument_list|(
name|PRC_QUENCH2
argument_list|,
operator|&
name|src
argument_list|)
decl_stmt|;
block|}
operator|(
operator|*
name|isosw
index|[
name|clnp_protox
index|[
name|ISOPROTO_TP
index|]
index|]
operator|.
name|pr_input
operator|)
operator|(
name|m
operator|,
operator|&
name|source
operator|,
operator|&
name|target
operator|,
name|clnp
operator|->
name|cnf_hdr_len
operator|)
expr_stmt|;
break|break;
case|case
name|CLNP_RAW
case|:
case|case
name|CLNP_ECR
case|:
name|IFDEBUG
argument_list|(
argument|D_INPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_input: raw input of %d bytes\n"
argument_list|,
name|clnp
operator|->
name|cnf_type
operator|&
name|CNF_SEG_OK
condition|?
name|seg_part
operator|.
name|cng_tot_len
else|:
name|seg_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
argument_list|(
operator|*
name|isosw
index|[
name|clnp_protox
index|[
name|ISOPROTO_RAW
index|]
index|]
operator|.
name|pr_input
argument_list|)
argument_list|(
name|m
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|clnp
operator|->
name|cnf_hdr_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLNP_EC
case|:
name|IFDEBUG
argument_list|(
argument|D_INPUT
argument_list|)
name|printf
argument_list|(
literal|"clnp_input: echoing packet\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 		 *	Switch the source and destination address, 		 */
name|hoff
init|=
operator|(
name|caddr_t
operator|)
name|clnp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_fixed
argument_list|)
decl_stmt|;
name|CLNP_INSERT_ADDR
argument_list|(
name|hoff
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|CLNP_INSERT_ADDR
argument_list|(
name|hoff
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|clnp
operator|->
name|cnf_type
operator|&=
operator|~
name|CNF_TYPE
expr_stmt|;
name|clnp
operator|->
name|cnf_type
operator||=
name|CLNP_ECR
expr_stmt|;
comment|/* 		 *	Forward back to sender 		 */
name|clnp_forward
argument_list|(
name|m
argument_list|,
call|(
name|int
call|)
argument_list|(
name|clnp
operator|->
name|cnf_type
operator|&
name|CNF_SEG_OK
condition|?
name|seg_part
operator|.
name|cng_tot_len
else|:
name|seg_len
argument_list|)
argument_list|,
operator|&
name|src
argument_list|,
name|oidxp
argument_list|,
name|seg_off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"clnp_input: unknown clnp pkt type %d\n"
argument_list|,
name|clnp
operator|->
name|cnf_type
operator|&
name|CNF_TYPE
argument_list|)
expr_stmt|;
name|clnp_stat
operator|.
name|cns_delivered
operator|--
expr_stmt|;
name|clnp_stat
operator|.
name|cns_noproto
operator|++
expr_stmt|;
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|GEN_HDRSYNTAX
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|ISO
end_endif

end_unit

