begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)sun_misc.c	8.3 (Berkeley) %G%  *  * from: $Header: sun_misc.c,v 1.16 93/04/07 02:46:27 torek Exp $  */
end_comment

begin_comment
comment|/*  * SunOS compatibility module.  *  * SunOS system calls that are implemented differently in BSD are  * handled here.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_struct
struct|struct
name|sun_wait4_args
block|{
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|options
decl_stmt|;
name|struct
name|rusage
modifier|*
name|rusage
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|sun_wait4
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sun_wait4_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
name|uap
operator|->
name|pid
operator|=
name|WAIT_ANY
expr_stmt|;
return|return
operator|(
name|wait4
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|sun_creat_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|fmode
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|sun_creat
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sun_creat_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
struct|struct
name|args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|crtmode
decl_stmt|;
block|}
name|openuap
struct|;
name|openuap
operator|.
name|fname
operator|=
name|uap
operator|->
name|fname
expr_stmt|;
name|openuap
operator|.
name|crtmode
operator|=
name|uap
operator|->
name|fmode
expr_stmt|;
name|openuap
operator|.
name|mode
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
return|return
operator|(
name|open
argument_list|(
name|p
argument_list|,
operator|&
name|openuap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|sun_execv_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
comment|/* pseudo */
block|}
struct|;
end_struct

begin_macro
name|sun_execv
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sun_execv_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|uap
operator|->
name|envp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|execve
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|sun_omsync_args
block|{
name|caddr_t
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|sun_omsync
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sun_omsync_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|uap
operator|->
name|flags
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|msync
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|sun_unmount_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* pseudo */
block|}
struct|;
end_struct

begin_macro
name|sun_unmount
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sun_unmount_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|uap
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|unmount
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|gettype
parameter_list|(
name|tptr
parameter_list|)
name|int
modifier|*
name|tptr
decl_stmt|;
block|{
name|int
name|type
decl_stmt|,
name|error
decl_stmt|;
name|char
name|in
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|copyinstr
argument_list|(
operator|(
name|caddr_t
operator|)
operator|*
name|tptr
argument_list|,
name|in
argument_list|,
sizeof|sizeof
name|in
argument_list|,
operator|(
name|u_int
operator|*
operator|)
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|in
argument_list|,
literal|"4.2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|in
argument_list|,
literal|"ufs"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|MOUNT_UFS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|in
argument_list|,
literal|"nfs"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|MOUNT_NFS
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|tptr
operator|=
name|type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SUNM_RDONLY
value|0x01
end_define

begin_comment
comment|/* mount fs read-only */
end_comment

begin_define
define|#
directive|define
name|SUNM_NOSUID
value|0x02
end_define

begin_comment
comment|/* mount fs with setuid disallowed */
end_comment

begin_define
define|#
directive|define
name|SUNM_NEWTYPE
value|0x04
end_define

begin_comment
comment|/* type is string (char *), not int */
end_comment

begin_define
define|#
directive|define
name|SUNM_GRPID
value|0x08
end_define

begin_comment
comment|/* (bsd semantics; ignored) */
end_comment

begin_define
define|#
directive|define
name|SUNM_REMOUNT
value|0x10
end_define

begin_comment
comment|/* update existing mount */
end_comment

begin_define
define|#
directive|define
name|SUNM_NOSUB
value|0x20
end_define

begin_comment
comment|/* prevent submounts (rejected) */
end_comment

begin_define
define|#
directive|define
name|SUNM_MULTI
value|0x40
end_define

begin_comment
comment|/* (ignored) */
end_comment

begin_define
define|#
directive|define
name|SUNM_SYS5
value|0x80
end_define

begin_comment
comment|/* Sys 5-specific semantics (rejected) */
end_comment

begin_struct
struct|struct
name|sun_mount_args
block|{
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|sun_mount
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sun_mount_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|oflags
init|=
name|uap
operator|->
name|flags
decl_stmt|,
name|nflags
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|oflags
operator|&
operator|(
name|SUNM_NOSUB
operator||
name|SUNM_SYS5
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|oflags
operator|&
name|SUNM_NEWTYPE
operator|&&
operator|(
name|error
operator|=
name|gettype
argument_list|(
operator|&
name|uap
operator|->
name|type
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oflags
operator|&
name|SUNM_RDONLY
condition|)
name|nflags
operator||=
name|MNT_RDONLY
expr_stmt|;
if|if
condition|(
name|oflags
operator|&
name|SUNM_NOSUID
condition|)
name|nflags
operator||=
name|MNT_NOSUID
expr_stmt|;
if|if
condition|(
name|oflags
operator|&
name|SUNM_REMOUNT
condition|)
name|nflags
operator||=
name|MNT_UPDATE
expr_stmt|;
name|uap
operator|->
name|flags
operator|=
name|nflags
expr_stmt|;
return|return
operator|(
name|mount
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|sun_sigpending_args
block|{
name|int
modifier|*
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|sun_sigpending
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sun_sigpending_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mask
decl_stmt|;
name|mask
operator|=
name|p
operator|->
name|p_siglist
operator|&
name|p
operator|->
name|p_sigmask
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|mask
argument_list|,
name|uap
operator|->
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Here is the sun layout.  (Compare the BSD layout in<sys/dirent.h>.)  * We can assume big-endian, so the BSD d_type field is just the high  * byte of the SunOS d_namlen field, after adjusting for the extra "long".  */
end_comment

begin_struct
struct|struct
name|sun_dirent
block|{
name|long
name|d_off
decl_stmt|;
name|u_long
name|d_fileno
decl_stmt|;
name|u_short
name|d_reclen
decl_stmt|;
name|u_short
name|d_namlen
decl_stmt|;
name|char
name|d_name
index|[
literal|256
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Read Sun-style directory entries.  We suck them into kernel space so  * that they can be massaged before being copied out to user code.  Like  * SunOS, we squish out `empty' entries.  *  * This is quite ugly, but what do you expect from compatibility code?  */
end_comment

begin_struct
struct|struct
name|sun_getdents_args
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|sun_getdents
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|sun_getdents_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|caddr_t
name|inp
decl_stmt|,
name|buf
decl_stmt|;
comment|/* BSD-format */
specifier|register
name|int
name|len
decl_stmt|,
name|reclen
decl_stmt|;
comment|/* BSD-format */
specifier|register
name|caddr_t
name|outp
decl_stmt|;
comment|/* Sun-format */
specifier|register
name|int
name|resid
decl_stmt|;
comment|/* Sun-format */
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|off_t
name|off
decl_stmt|;
comment|/* true file offset */
name|long
name|soff
decl_stmt|;
comment|/* Sun file offset */
name|int
name|buflen
decl_stmt|,
name|error
decl_stmt|,
name|eofflag
decl_stmt|;
define|#
directive|define
name|BSD_DIRENT
parameter_list|(
name|cp
parameter_list|)
value|((struct dirent *)(cp))
define|#
directive|define
name|SUN_RECLEN
parameter_list|(
name|reclen
parameter_list|)
value|(reclen + sizeof(long))
if|if
condition|(
operator|(
name|error
operator|=
name|getvnode
argument_list|(
name|p
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
comment|/* XXX  vnode readdir op should do this */
return|return
operator|(
name|EINVAL
operator|)
return|;
name|buflen
operator|=
name|min
argument_list|(
name|MAXBSIZE
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|off
operator|=
name|fp
operator|->
name|f_offset
expr_stmt|;
name|again
label|:
name|aiov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|off
expr_stmt|;
comment|/* 	 * First we read into the malloc'ed buffer, then 	 * we massage it into user space, one record at a time. 	 */
if|if
condition|(
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
operator|&
name|eofflag
argument_list|,
operator|(
name|u_long
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|inp
operator|=
name|buf
expr_stmt|;
name|outp
operator|=
name|uap
operator|->
name|buf
expr_stmt|;
name|resid
operator|=
name|uap
operator|->
name|nbytes
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|buflen
operator|-
name|auio
operator|.
name|uio_resid
operator|)
operator|==
literal|0
condition|)
goto|goto
name|eof
goto|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|reclen
control|)
block|{
name|reclen
operator|=
operator|(
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|inp
operator|)
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|reclen
operator|&
literal|3
condition|)
name|panic
argument_list|(
literal|"sun_getdents"
argument_list|)
expr_stmt|;
name|off
operator|+=
name|reclen
expr_stmt|;
comment|/* each entry points to next */
if|if
condition|(
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_fileno
operator|==
literal|0
condition|)
block|{
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* it is a hole; squish it out */
continue|continue;
block|}
if|if
condition|(
name|reclen
operator|>
name|len
operator|||
name|resid
operator|<
name|SUN_RECLEN
argument_list|(
name|reclen
argument_list|)
condition|)
block|{
comment|/* entry too big for buffer, so just stop */
name|outp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 		 * Massage in place to make a Sun-shaped dirent (otherwise 		 * we have to worry about touching user memory outside of 		 * the copyout() call). 		 */
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_reclen
operator|=
name|SUN_RECLEN
argument_list|(
name|reclen
argument_list|)
expr_stmt|;
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_type
operator|=
literal|0
expr_stmt|;
name|soff
operator|=
name|off
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|soff
argument_list|,
name|outp
argument_list|,
sizeof|sizeof
name|soff
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|inp
argument_list|,
name|outp
operator|+
sizeof|sizeof
name|soff
argument_list|,
name|reclen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* advance past this real entry */
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* advance output past Sun-shaped entry */
name|outp
operator|+=
name|SUN_RECLEN
argument_list|(
name|reclen
argument_list|)
expr_stmt|;
name|resid
operator|-=
name|SUN_RECLEN
argument_list|(
name|reclen
argument_list|)
expr_stmt|;
block|}
comment|/* if we squished out the whole block, try again */
if|if
condition|(
name|outp
operator|==
name|uap
operator|->
name|buf
condition|)
goto|goto
name|again
goto|;
name|fp
operator|->
name|f_offset
operator|=
name|off
expr_stmt|;
comment|/* update the vnode offset */
name|eof
label|:
operator|*
name|retval
operator|=
name|uap
operator|->
name|nbytes
operator|-
name|resid
expr_stmt|;
name|out
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MAXDOMAINNAME
value|64
end_define

begin_decl_stmt
name|char
name|sun_domainname
index|[
name|MAXDOMAINNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sun_domainnamelen
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|sun_getdomainname_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|sun_getdomainname
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sun_getdomainname_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|l
init|=
name|min
argument_list|(
name|uap
operator|->
name|namelen
argument_list|,
name|sun_domainnamelen
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
name|copyout
argument_list|(
name|sun_domainname
argument_list|,
name|uap
operator|->
name|name
argument_list|,
name|l
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|sun_setdomainname_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|sun_setdomainname
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sun_setdomainname_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|l
init|=
name|uap
operator|->
name|namelen
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|l
operator|>=
name|MAXDOMAINNAME
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* ??? ENAMETOOLONG? */
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|name
argument_list|,
name|sun_domainname
argument_list|,
name|l
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sun_domainname
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|SUN_MMAP_MASK
value|0xf
end_define

begin_comment
comment|/* mask for SHARED/PRIVATE */
end_comment

begin_define
define|#
directive|define
name|SUN_MMAP_CANDO
value|0x80000000
end_define

begin_comment
comment|/* if not, old mmap& cannot handle */
end_comment

begin_define
define|#
directive|define
name|DEVZERO
value|makedev(3, 12)
end_define

begin_comment
comment|/* major,minor of /dev/zero */
end_comment

begin_define
define|#
directive|define
name|SUN_MMAP_SAME
value|(MAP_SHARED|MAP_PRIVATE|MAP_FIXED|MAP_INHERIT)
end_define

begin_struct
struct|struct
name|sun_mmap_args
block|{
name|caddr_t
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|prot
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|off
decl_stmt|;
comment|/* not off_t! */
name|quad_t
name|qoff
decl_stmt|;
comment|/* created here and fed to mmap() */
block|}
struct|;
end_struct

begin_expr_stmt
name|sun_mmap
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|sun_mmap_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|flags
decl_stmt|;
specifier|register
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
comment|/* 	 * Verify the arguments. 	 */
name|flags
operator|=
name|uap
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SUN_MMAP_CANDO
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SUN_MMAP_MASK
operator|)
operator|!=
name|MAP_SHARED
operator|&&
operator|(
name|flags
operator|&
name|SUN_MMAP_MASK
operator|)
operator|!=
name|MAP_PRIVATE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|flags
operator|&=
operator|~
name|SUN_MMAP_CANDO
expr_stmt|;
comment|/* 	 * Special case: if fd refers to /dev/zero, map as MAP_ANON.  (XXX) 	 */
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|fd
operator|<
name|fdp
operator|->
name|fd_nfiles
operator|&&
comment|/*XXX*/
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fd
index|]
operator|)
operator|!=
name|NULL
operator|&&
comment|/*XXX*/
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
operator|&&
comment|/*XXX*/
operator|(
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
operator|)
operator|->
name|v_type
operator|==
name|VCHR
operator|&&
comment|/*XXX*/
name|vp
operator|->
name|v_rdev
operator|==
name|DEVZERO
condition|)
block|{
comment|/*XXX*/
name|flags
operator||=
name|MAP_ANON
expr_stmt|;
name|uap
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* All done, fix up fields and go. */
name|uap
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|uap
operator|->
name|qoff
operator|=
operator|(
name|quad_t
operator|)
name|uap
operator|->
name|off
expr_stmt|;
return|return
operator|(
name|mmap
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MC_SYNC
value|1
end_define

begin_define
define|#
directive|define
name|MC_LOCK
value|2
end_define

begin_define
define|#
directive|define
name|MC_UNLOCK
value|3
end_define

begin_define
define|#
directive|define
name|MC_ADVISE
value|4
end_define

begin_define
define|#
directive|define
name|MC_LOCKAS
value|5
end_define

begin_define
define|#
directive|define
name|MC_UNLOCKAS
value|6
end_define

begin_struct
struct|struct
name|sun_mctl_args
block|{
name|caddr_t
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|func
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|sun_mctl
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|sun_mctl_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|uap
operator|->
name|func
condition|)
block|{
case|case
name|MC_ADVISE
case|:
comment|/* ignore for now */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MC_SYNC
case|:
comment|/* translate to msync */
return|return
operator|(
name|msync
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_block

begin_struct
struct|struct
name|sun_setsockopt_args
block|{
name|int
name|s
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|name
decl_stmt|;
name|caddr_t
name|val
decl_stmt|;
name|int
name|valsize
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|sun_setsockopt
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|sun_setsockopt_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|getsock
argument_list|(
name|p
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|s
argument_list|,
operator|&
name|fp
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
define|#
directive|define
name|SO_DONTLINGER
value|(~SO_LINGER)
if|if
condition|(
name|uap
operator|->
name|name
operator|==
name|SO_DONTLINGER
condition|)
block|{
name|m
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|linger
operator|*
argument_list|)
operator|->
name|l_onoff
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|linger
argument_list|)
expr_stmt|;
return|return
operator|(
name|sosetopt
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
name|fp
operator|->
name|f_data
argument_list|,
name|uap
operator|->
name|level
argument_list|,
name|SO_LINGER
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|uap
operator|->
name|valsize
operator|>
name|MLEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|val
condition|)
block|{
name|m
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|val
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
name|uap
operator|->
name|valsize
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|uap
operator|->
name|valsize
expr_stmt|;
block|}
return|return
operator|(
name|sosetopt
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
name|fp
operator|->
name|f_data
argument_list|,
name|uap
operator|->
name|level
argument_list|,
name|uap
operator|->
name|name
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|sun_fchroot_args
block|{
name|int
name|fdes
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|sun_fchroot
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|sun_fchroot_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|getvnode
argument_list|(
name|fdp
argument_list|,
name|uap
operator|->
name|fdes
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
name|error
operator|=
name|ENOTDIR
expr_stmt|;
else|else
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VEXEC
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_rdir
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|fdp
operator|->
name|fd_rdir
argument_list|)
expr_stmt|;
name|fdp
operator|->
name|fd_rdir
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

