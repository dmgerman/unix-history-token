begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to the Computer Systems  * Engineering Group at Lawrence Berkeley Laboratory and to the University  * of California at Berkeley by Jef Poskanzer.  *  * %sccs.include.redist.c%  *  *	@(#)raster_op.c	7.1 (Berkeley) %G%  *  * from: $Header: raster_op.c,v 1.22 92/06/17 08:14:44 torek Exp $  */
end_comment

begin_comment
comment|/*  * Bitblit routine for raster library.  *  * This raster-op is machined to exacting tolerances by skilled native  * craftsmen with pride in their work.  *  * The various cases are broken down like this:  *  *   src required  *       1-bit to 1-bit  *       1-bit to 8-bits  *       8-bits to 8-bits  *   no src required  *       1-bit no-src  *       8-bits no-src  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|"sys/types.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"raster.h"
end_include

begin_comment
comment|/* CONFIGURE: To save on executable size, you can configure out the seldom-used ** logical operations.  With this variable set, the only operations implemented ** are: RAS_SRC, RAS_CLEAR, RAS_SET, RAS_INVERT, RAS_XOR, RAS_INVERTSRC. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_define
define|#
directive|define
name|PARTIAL_LOGICAL_OPS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIGURE: bcopy() is supposed to be the ultimately fastest way to move ** bytes, overlapping or not, ignoring the startup cost.  Unfortunately ** this is not true on some systems.  For example, on a Sun 3 running ** SunOS 3.5, bcopy() is about five times slower than a simple for loop ** on overlapping copies.  And on a 4.1.1 SPARC, bcopy() is about 2/3rds ** as fast on backwards overlaps.  So, only define this if your bcopy is ok. */
end_comment

begin_undef
undef|#
directive|undef
name|BCOPY_FASTER
end_undef

begin_comment
comment|/* End of configurable definitions. */
end_comment

begin_comment
comment|/* Definitions. */
end_comment

begin_comment
comment|/* Raster-op macros.  These encapsulate the switch statements and so make ** the source code 16 times smaller.  The pre and pst args are code ** fragments to put before and after the assignment in each case.  They ** can be the beginning and end of a loop.  If the pst fragment includes a ** masked assignment, for example to handle the left or right edge cases, ** a good optimizing compiler will simplify the boolean expressions very ** nicely - both cc and gcc on the SPARC will do this. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PARTIAL_LOGICAL_OPS
end_ifndef

begin_define
define|#
directive|define
name|ROP_DST
parameter_list|(
name|op
parameter_list|,
name|pre
parameter_list|,
name|d
parameter_list|,
name|pst
parameter_list|)
define|\
value|switch ( op ) \ 	{ \ 	case RAS_CLEAR: \ 	pre \ 	(d) = 0; \ 	pst \ 	break; \ 	case RAS_INVERT: \ 	pre \ 	(d) = ~(d); \ 	pst \ 	break; \ 	case RAS_DST: \
comment|/* noop */
value|\ 	break; \ 	case RAS_SET: \ 	pre \ 	(d) = ~0; \ 	pst \ 	break; \ 	default: \ 	return -1; \ 	}
end_define

begin_define
define|#
directive|define
name|ROP_DSTCOLOR
parameter_list|(
name|op
parameter_list|,
name|pre
parameter_list|,
name|d
parameter_list|,
name|c
parameter_list|,
name|pst
parameter_list|)
define|\
value|switch ( op ) \ 	{ \ 	case RAS_CLEAR: \ 	pre \ 	(d) = 0; \ 	pst \ 	break; \ 	case RAS_INVERT: \ 	pre \ 	(d) = ~(d); \ 	pst \ 	break; \ 	case RAS_DST: \
comment|/* noop */
value|\ 	break; \ 	case RAS_SET: \ 	pre \ 	(d) = (c); \ 	pst \ 	break; \ 	default: \ 	return -1; \ 	}
end_define

begin_define
define|#
directive|define
name|ROP_SRCDST
parameter_list|(
name|op
parameter_list|,
name|pre
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|pst
parameter_list|)
define|\
value|switch ( op ) \ 	{ \ 	case RAS_NOTOR: \ 	pre \ 	(d) = ~( (s) | (d) ); \ 	pst \ 	break; \ 	case RAS_NOTSRC_AND_DST: \ 	pre \ 	(d) = ~(s)& (d); \ 	pst \ 	break; \ 	case RAS_INVERTSRC: \ 	pre \ 	(d) = ~(s); \ 	pst \ 	break; \ 	case RAS_SRC_AND_NOTDST: \ 	pre \ 	(d) = (s)& ~(d); \ 	pst \ 	break; \ 	case RAS_XOR: \ 	pre \ 	(d) = (s) ^ (d); \ 	pst \ 	break; \ 	case RAS_NOTAND: \ 	pre \ 	(d) = ~( (s)& (d) ); \ 	pst \ 	break; \ 	case RAS_AND: \ 	pre \ 	(d) = (s)& (d); \ 	pst \ 	break; \ 	case RAS_NOTXOR: \ 	pre \ 	(d) = ~( (s) ^ (d) ); \ 	pst \ 	break; \ 	case RAS_NOTSRC_OR_DST: \ 	pre \ 	(d) = ~(s) | (d); \ 	pst \ 	break; \ 	case RAS_SRC: \ 	pre \ 	(d) = (s); \ 	pst \ 	break; \ 	case RAS_SRC_OR_NOTDST: \ 	pre \ 	(d) = (s) | ~(d); \ 	pst \ 	break; \ 	case RAS_OR: \ 	pre \ 	(d) = (s) | (d); \ 	pst \ 	break; \ 	default: \ 	return -1; \ 	}
end_define

begin_define
define|#
directive|define
name|ROP_SRCDSTCOLOR
parameter_list|(
name|op
parameter_list|,
name|pre
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|c
parameter_list|,
name|pst
parameter_list|)
define|\
value|switch ( op ) \ 	{ \ 	case RAS_NOTOR: \ 	pre \ 	if ( s ) \ 	    (d) = ~( (c) | (d) ); \ 	else \ 	    (d) = ~(d); \ 	pst \ 	break; \ 	case RAS_NOTSRC_AND_DST: \ 	pre \ 	if ( s ) \ 	    (d) = ~(c)& (d); \ 	pst \ 	break; \ 	case RAS_INVERTSRC: \ 	pre \ 	if ( s ) \ 	    (d) = ~(c); \ 	else \ 	    (d) = ~0; \ 	pst \ 	break; \ 	case RAS_SRC_AND_NOTDST: \ 	pre \ 	if ( s ) \ 	    (d) = (c)& ~(d); \ 	else \ 	    (d) = 0; \ 	pst \ 	break; \ 	case RAS_XOR: \ 	pre \ 	if ( s ) \ 	    (d) = (c) ^ (d); \ 	pst \ 	break; \ 	case RAS_NOTAND: \ 	pre \ 	if ( s ) \ 	    (d) = ~( (c)& (d) ); \ 	else \ 	    (d) = ~0; \ 	pst \ 	break; \ 	case RAS_AND: \ 	pre \ 	if ( s ) \ 	    (d) = (c)& (d); \ 	else \ 	    (d) = 0; \ 	pst \ 	break; \ 	case RAS_NOTXOR: \ 	pre \ 	if ( s ) \ 	    (d) = ~( (c) ^ (d) ); \ 	else \ 	    (d) = ~(d); \ 	pst \ 	break; \ 	case RAS_NOTSRC_OR_DST: \ 	pre \ 	if ( s ) \ 	    (d) = ~(c) | (d); \ 	else \ 	    (d) = ~0; \ 	pst \ 	break; \ 	case RAS_SRC: \ 	pre \ 	if ( s ) \ 	    (d) = (c); \ 	else \ 	    (d) = 0; \ 	pst \ 	break; \ 	case RAS_SRC_OR_NOTDST: \ 	pre \ 	if ( s ) \ 	    (d) = (c) | ~(d); \ 	else \ 	    (d) = ~(d); \ 	pst \ 	break; \ 	case RAS_OR: \ 	pre \ 	if ( s ) \ 	    (d) = (c) | (d); \ 	pst \ 	break; \ 	default: \ 	return -1; \ 	}
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*PARTIAL_LOGICAL_OPS*/
end_comment

begin_define
define|#
directive|define
name|ROP_DST
parameter_list|(
name|op
parameter_list|,
name|pre
parameter_list|,
name|d
parameter_list|,
name|pst
parameter_list|)
define|\
value|switch ( op ) \ 	{ \ 	case RAS_CLEAR: \ 	pre \ 	(d) = 0; \ 	pst \ 	break; \ 	case RAS_INVERT: \ 	pre \ 	(d) = ~(d); \ 	pst \ 	break; \ 	case RAS_SET: \ 	pre \ 	(d) = ~0; \ 	pst \ 	break; \ 	default: \ 	return -1; \ 	}
end_define

begin_define
define|#
directive|define
name|ROP_DSTCOLOR
parameter_list|(
name|op
parameter_list|,
name|pre
parameter_list|,
name|d
parameter_list|,
name|c
parameter_list|,
name|pst
parameter_list|)
define|\
value|switch ( op ) \ 	{ \ 	case RAS_CLEAR: \ 	pre \ 	(d) = 0; \ 	pst \ 	break; \ 	case RAS_INVERT: \ 	pre \ 	(d) = ~(d); \ 	pst \ 	break; \ 	case RAS_SET: \ 	pre \ 	(d) = (c); \ 	pst \ 	break; \ 	default: \ 	return -1; \ 	}
end_define

begin_define
define|#
directive|define
name|ROP_SRCDST
parameter_list|(
name|op
parameter_list|,
name|pre
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|pst
parameter_list|)
define|\
value|switch ( op ) \ 	{ \ 	case RAS_INVERTSRC: \ 	pre \ 	(d) = ~(s); \ 	pst \ 	break; \ 	case RAS_XOR: \ 	pre \ 	(d) = (s) ^ (d); \ 	pst \ 	break; \ 	case RAS_SRC: \ 	pre \ 	(d) = (s); \ 	pst \ 	break; \ 	default: \ 	return -1; \ 	}
end_define

begin_define
define|#
directive|define
name|ROP_SRCDSTCOLOR
parameter_list|(
name|op
parameter_list|,
name|pre
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|c
parameter_list|,
name|pst
parameter_list|)
define|\
value|switch ( op ) \ 	{ \ 	case RAS_INVERTSRC: \ 	pre \ 	if ( s ) \ 	    (d) = ~(c); \ 	else \ 	    (d) = ~0; \ 	pst \ 	break; \ 	case RAS_XOR: \ 	pre \ 	if ( s ) \ 	    (d) = (c) ^ (d); \ 	pst \ 	break; \ 	case RAS_SRC: \ 	pre \ 	if ( s ) \ 	    (d) = (c); \ 	else \ 	    (d) = 0; \ 	pst \ 	break; \ 	default: \ 	return -1; \ 	}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*PARTIAL_LOGICAL_OPS*/
end_comment

begin_comment
comment|/* Variables. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|needsrc
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*                       CLEAR          INVERT          DST            SET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MSBIT_FIRST
end_ifdef

begin_decl_stmt
name|u_long
name|raster_bitmask
index|[
literal|32
index|]
init|=
block|{
literal|0x80000000
block|,
literal|0x40000000
block|,
literal|0x20000000
block|,
literal|0x10000000
block|,
literal|0x08000000
block|,
literal|0x04000000
block|,
literal|0x02000000
block|,
literal|0x01000000
block|,
literal|0x00800000
block|,
literal|0x00400000
block|,
literal|0x00200000
block|,
literal|0x00100000
block|,
literal|0x00080000
block|,
literal|0x00040000
block|,
literal|0x00020000
block|,
literal|0x00010000
block|,
literal|0x00008000
block|,
literal|0x00004000
block|,
literal|0x00002000
block|,
literal|0x00001000
block|,
literal|0x00000800
block|,
literal|0x00000400
block|,
literal|0x00000200
block|,
literal|0x00000100
block|,
literal|0x00000080
block|,
literal|0x00000040
block|,
literal|0x00000020
block|,
literal|0x00000010
block|,
literal|0x00000008
block|,
literal|0x00000004
block|,
literal|0x00000002
block|,
literal|0x00000001
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MSBYTE_FIRST
end_ifdef

begin_decl_stmt
specifier|static
name|u_long
name|leftmask
index|[
literal|32
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x80000000
block|,
literal|0xc0000000
block|,
literal|0xe0000000
block|,
literal|0xf0000000
block|,
literal|0xf8000000
block|,
literal|0xfc000000
block|,
literal|0xfe000000
block|,
literal|0xff000000
block|,
literal|0xff800000
block|,
literal|0xffc00000
block|,
literal|0xffe00000
block|,
literal|0xfff00000
block|,
literal|0xfff80000
block|,
literal|0xfffc0000
block|,
literal|0xfffe0000
block|,
literal|0xffff0000
block|,
literal|0xffff8000
block|,
literal|0xffffc000
block|,
literal|0xffffe000
block|,
literal|0xfffff000
block|,
literal|0xfffff800
block|,
literal|0xfffffc00
block|,
literal|0xfffffe00
block|,
literal|0xffffff00
block|,
literal|0xffffff80
block|,
literal|0xffffffc0
block|,
literal|0xffffffe0
block|,
literal|0xfffffff0
block|,
literal|0xfffffff8
block|,
literal|0xfffffffc
block|,
literal|0xfffffffe
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|rightmask
index|[
literal|32
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x00000001
block|,
literal|0x00000003
block|,
literal|0x00000007
block|,
literal|0x0000000f
block|,
literal|0x0000001f
block|,
literal|0x0000003f
block|,
literal|0x0000007f
block|,
literal|0x000000ff
block|,
literal|0x000001ff
block|,
literal|0x000003ff
block|,
literal|0x000007ff
block|,
literal|0x00000fff
block|,
literal|0x00001fff
block|,
literal|0x00003fff
block|,
literal|0x00007fff
block|,
literal|0x0000ffff
block|,
literal|0x0001ffff
block|,
literal|0x0003ffff
block|,
literal|0x0007ffff
block|,
literal|0x000fffff
block|,
literal|0x001fffff
block|,
literal|0x003fffff
block|,
literal|0x007fffff
block|,
literal|0x00ffffff
block|,
literal|0x01ffffff
block|,
literal|0x03ffffff
block|,
literal|0x07ffffff
block|,
literal|0x0fffffff
block|,
literal|0x1fffffff
block|,
literal|0x3fffffff
block|,
literal|0x7fffffff
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*MSBYTE_FIRST*/
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*MSBIT_FIRST*/
end_comment

begin_decl_stmt
name|u_long
name|raster_bitmask
index|[
literal|32
index|]
init|=
block|{
literal|0x00000001
block|,
literal|0x00000002
block|,
literal|0x00000004
block|,
literal|0x00000008
block|,
literal|0x00000010
block|,
literal|0x00000020
block|,
literal|0x00000040
block|,
literal|0x00000080
block|,
literal|0x00000100
block|,
literal|0x00000200
block|,
literal|0x00000400
block|,
literal|0x00000800
block|,
literal|0x00001000
block|,
literal|0x00002000
block|,
literal|0x00004000
block|,
literal|0x00008000
block|,
literal|0x00010000
block|,
literal|0x00020000
block|,
literal|0x00040000
block|,
literal|0x00080000
block|,
literal|0x00100000
block|,
literal|0x00200000
block|,
literal|0x00400000
block|,
literal|0x00800000
block|,
literal|0x01000000
block|,
literal|0x02000000
block|,
literal|0x04000000
block|,
literal|0x08000000
block|,
literal|0x10000000
block|,
literal|0x20000000
block|,
literal|0x40000000
block|,
literal|0x80000000
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MSBYTE_FIRST
end_ifndef

begin_decl_stmt
specifier|static
name|u_long
name|leftmask
index|[
literal|32
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x00000001
block|,
literal|0x00000003
block|,
literal|0x00000007
block|,
literal|0x0000000f
block|,
literal|0x0000001f
block|,
literal|0x0000003f
block|,
literal|0x0000007f
block|,
literal|0x000000ff
block|,
literal|0x000001ff
block|,
literal|0x000003ff
block|,
literal|0x000007ff
block|,
literal|0x00000fff
block|,
literal|0x00001fff
block|,
literal|0x00003fff
block|,
literal|0x00007fff
block|,
literal|0x0000ffff
block|,
literal|0x0001ffff
block|,
literal|0x0003ffff
block|,
literal|0x0007ffff
block|,
literal|0x000fffff
block|,
literal|0x001fffff
block|,
literal|0x003fffff
block|,
literal|0x007fffff
block|,
literal|0x00ffffff
block|,
literal|0x01ffffff
block|,
literal|0x03ffffff
block|,
literal|0x07ffffff
block|,
literal|0x0fffffff
block|,
literal|0x1fffffff
block|,
literal|0x3fffffff
block|,
literal|0x7fffffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|rightmask
index|[
literal|32
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x80000000
block|,
literal|0xc0000000
block|,
literal|0xe0000000
block|,
literal|0xf0000000
block|,
literal|0xf8000000
block|,
literal|0xfc000000
block|,
literal|0xfe000000
block|,
literal|0xff000000
block|,
literal|0xff800000
block|,
literal|0xffc00000
block|,
literal|0xffe00000
block|,
literal|0xfff00000
block|,
literal|0xfff80000
block|,
literal|0xfffc0000
block|,
literal|0xfffe0000
block|,
literal|0xffff0000
block|,
literal|0xffff8000
block|,
literal|0xffffc000
block|,
literal|0xffffe000
block|,
literal|0xfffff000
block|,
literal|0xfffff800
block|,
literal|0xfffffc00
block|,
literal|0xfffffe00
block|,
literal|0xffffff00
block|,
literal|0xffffff80
block|,
literal|0xffffffc0
block|,
literal|0xffffffe0
block|,
literal|0xfffffff0
block|,
literal|0xfffffff8
block|,
literal|0xfffffffc
block|,
literal|0xfffffffe
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*not MSBYTE_FIRST*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*MSBIT_FIRST*/
end_comment

begin_comment
comment|/* (The odd combinations MSBIT+~MSBYTE and ~MSBIT+MSBYTE could be added.) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MSBYTE_FIRST
end_ifdef

begin_decl_stmt
specifier|static
name|u_long
name|bytemask
index|[
literal|4
index|]
init|=
block|{
literal|0xff000000
block|,
literal|0x00ff0000
block|,
literal|0x0000ff00
block|,
literal|0x000000ff
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*MSBYTE_FIRST*/
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|bytemask
index|[
literal|4
index|]
init|=
block|{
literal|0x000000ff
block|,
literal|0x0000ff00
block|,
literal|0x00ff0000
block|,
literal|0xff000000
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*MSBYTE_FIRST*/
end_comment

begin_comment
comment|/* Forward routines. */
end_comment

begin_function_decl
specifier|static
name|int
name|raster_blit
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Raster operations.  */
end_comment

begin_comment
comment|/* Performs a bitblit.  Returns 0 on success, -1 on failure. */
end_comment

begin_function
name|int
name|raster_op
parameter_list|(
name|dst
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|rop
parameter_list|,
name|src
parameter_list|,
name|sx
parameter_list|,
name|sy
parameter_list|)
name|struct
name|raster
modifier|*
name|dst
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|,
name|rop
decl_stmt|;
name|struct
name|raster
modifier|*
name|src
decl_stmt|;
name|int
name|sx
decl_stmt|,
name|sy
decl_stmt|;
block|{
if|if
condition|(
name|dst
operator|==
operator|(
expr|struct
name|raster
operator|*
operator|)
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* no destination */
if|if
condition|(
name|needsrc
index|[
name|RAS_GETOP
argument_list|(
name|rop
argument_list|)
index|]
condition|)
block|{
comment|/* Two-operand blit. */
if|if
condition|(
name|src
operator|==
operator|(
expr|struct
name|raster
operator|*
operator|)
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* no source */
comment|/* Clip against source. */
if|if
condition|(
name|sx
operator|<
literal|0
condition|)
block|{
name|w
operator|+=
name|sx
expr_stmt|;
name|sx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sy
operator|<
literal|0
condition|)
block|{
name|h
operator|+=
name|sy
expr_stmt|;
name|sy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sx
operator|+
name|w
operator|>
name|src
operator|->
name|width
condition|)
name|w
operator|=
name|src
operator|->
name|width
operator|-
name|sx
expr_stmt|;
if|if
condition|(
name|sy
operator|+
name|h
operator|>
name|src
operator|->
name|height
condition|)
name|h
operator|=
name|src
operator|->
name|height
operator|-
name|sy
expr_stmt|;
comment|/* Clip against dest. */
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|w
operator|+=
name|dx
expr_stmt|;
name|sx
operator|-=
name|dx
expr_stmt|;
name|dx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
block|{
name|h
operator|+=
name|dy
expr_stmt|;
name|sy
operator|-=
name|dy
expr_stmt|;
name|dy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dx
operator|+
name|w
operator|>
name|dst
operator|->
name|width
condition|)
name|w
operator|=
name|dst
operator|->
name|width
operator|-
name|dx
expr_stmt|;
if|if
condition|(
name|dy
operator|+
name|h
operator|>
name|dst
operator|->
name|height
condition|)
name|h
operator|=
name|dst
operator|->
name|height
operator|-
name|dy
expr_stmt|;
if|if
condition|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* nothing to do */
return|return
name|raster_op_noclip
argument_list|(
name|dst
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|rop
argument_list|,
name|src
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|)
return|;
block|}
comment|/* No source necessary - one-operand blit. */
if|if
condition|(
name|src
operator|!=
operator|(
expr|struct
name|raster
operator|*
operator|)
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* unwanted source */
comment|/* Clip against dest. */
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|w
operator|+=
name|dx
expr_stmt|;
name|dx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
block|{
name|h
operator|+=
name|dy
expr_stmt|;
name|dy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dx
operator|+
name|w
operator|>
name|dst
operator|->
name|width
condition|)
name|w
operator|=
name|dst
operator|->
name|width
operator|-
name|dx
expr_stmt|;
if|if
condition|(
name|dy
operator|+
name|h
operator|>
name|dst
operator|->
name|height
condition|)
name|h
operator|=
name|dst
operator|->
name|height
operator|-
name|dy
expr_stmt|;
if|if
condition|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* nothing to do */
return|return
name|raster_op_nosrc_noclip
argument_list|(
name|dst
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|rop
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Semi-public routine to do a bitblit without clipping.  Returns 0 on ** success, -1 on failure. */
end_comment

begin_function
name|int
name|raster_op_noclip
parameter_list|(
name|dst
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|rop
parameter_list|,
name|src
parameter_list|,
name|sx
parameter_list|,
name|sy
parameter_list|)
name|struct
name|raster
modifier|*
name|dst
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|,
name|rop
decl_stmt|;
name|struct
name|raster
modifier|*
name|src
decl_stmt|;
name|int
name|sx
decl_stmt|,
name|sy
decl_stmt|;
block|{
name|int
name|op
decl_stmt|;
name|op
operator|=
name|RAS_GETOP
argument_list|(
name|rop
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|depth
operator|==
literal|1
condition|)
block|{
comment|/* One-bit to ? blit. */
if|if
condition|(
name|dst
operator|->
name|depth
operator|==
literal|1
condition|)
block|{
comment|/* One to one blit. */
name|u_long
modifier|*
name|srclin1
decl_stmt|;
name|u_long
modifier|*
name|dstlin1
decl_stmt|;
name|int
name|srcleftignore
decl_stmt|,
name|srcrightignore
decl_stmt|,
name|srclongs
decl_stmt|;
name|int
name|dstleftignore
decl_stmt|,
name|dstrightignore
decl_stmt|,
name|dstlongs
decl_stmt|;
name|srclin1
operator|=
name|RAS_ADDR
argument_list|(
name|src
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
name|dstlin1
operator|=
name|RAS_ADDR
argument_list|(
name|dst
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCOPY_FASTER
comment|/* Special-case full-width to full-width copies. */
if|if
condition|(
name|op
operator|==
name|RAS_SRC
operator|&&
name|src
operator|->
name|width
operator|==
name|w
operator|&&
name|dst
operator|->
name|width
operator|==
name|w
operator|&&
name|src
operator|->
name|linelongs
operator|==
name|dst
operator|->
name|linelongs
operator|&&
name|src
operator|->
name|linelongs
operator|==
name|w
operator|>>
literal|5
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|srclin1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dstlin1
argument_list|,
name|h
operator|*
name|src
operator|->
name|linelongs
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*BCOPY_FASTER*/
name|srcleftignore
operator|=
operator|(
name|sx
operator|&
literal|31
operator|)
expr_stmt|;
name|srclongs
operator|=
operator|(
name|srcleftignore
operator|+
name|w
operator|+
literal|31
operator|)
operator|>>
literal|5
expr_stmt|;
name|srcrightignore
operator|=
operator|(
name|srclongs
operator|*
literal|32
operator|-
name|w
operator|-
name|srcleftignore
operator|)
operator|&
literal|31
expr_stmt|;
name|dstleftignore
operator|=
operator|(
name|dx
operator|&
literal|31
operator|)
expr_stmt|;
name|dstlongs
operator|=
operator|(
name|dstleftignore
operator|+
name|w
operator|+
literal|31
operator|)
operator|>>
literal|5
expr_stmt|;
name|dstrightignore
operator|=
operator|(
name|dstlongs
operator|*
literal|32
operator|-
name|w
operator|-
name|dstleftignore
operator|)
operator|&
literal|31
expr_stmt|;
return|return
name|raster_blit
argument_list|(
name|src
argument_list|,
name|srclin1
argument_list|,
name|srcleftignore
argument_list|,
name|srcrightignore
argument_list|,
name|srclongs
argument_list|,
name|dst
argument_list|,
name|dstlin1
argument_list|,
name|dstleftignore
argument_list|,
name|dstrightignore
argument_list|,
name|dstlongs
argument_list|,
name|h
argument_list|,
name|op
argument_list|)
return|;
block|}
else|else
block|{
comment|/* One to eight, using the color in the rop.  This could 	    ** probably be sped up by handling each four-bit source nybble 	    ** as a group, indexing into a 16-element runtime-constructed 	    ** table of longwords. 	    */
name|u_long
modifier|*
name|srclin1
decl_stmt|;
name|u_long
modifier|*
name|dstlin1
decl_stmt|;
name|u_long
modifier|*
name|srclin2
decl_stmt|;
name|u_long
modifier|*
name|srclin
decl_stmt|;
name|u_long
modifier|*
name|dstlin
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|srclong
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|dstlong
decl_stmt|;
specifier|register
name|u_long
name|color
decl_stmt|,
name|dl
decl_stmt|;
specifier|register
name|int
name|srcbit
decl_stmt|,
name|dstbyte
decl_stmt|,
name|i
decl_stmt|;
name|color
operator|=
name|RAS_GETCOLOR
argument_list|(
name|rop
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
operator|==
literal|0
condition|)
name|color
operator|=
literal|255
expr_stmt|;
comment|/* Make 32 bits of color so we can do the ROP without shifting. */
name|color
operator||=
operator|(
name|color
operator|<<
literal|24
operator|)
operator||
operator|(
name|color
operator|<<
literal|16
operator|)
operator||
operator|(
name|color
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Don't have to worry about overlapping blits here. */
name|srclin1
operator|=
name|RAS_ADDR
argument_list|(
name|src
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
name|srclin2
operator|=
name|srclin1
operator|+
name|h
operator|*
name|src
operator|->
name|linelongs
expr_stmt|;
name|dstlin1
operator|=
name|RAS_ADDR
argument_list|(
name|dst
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|srclin
operator|=
name|srclin1
expr_stmt|;
name|dstlin
operator|=
name|dstlin1
expr_stmt|;
while|while
condition|(
name|srclin
operator|!=
name|srclin2
condition|)
block|{
name|srclong
operator|=
name|srclin
expr_stmt|;
name|srcbit
operator|=
name|sx
operator|&
literal|31
expr_stmt|;
name|dstlong
operator|=
name|dstlin
expr_stmt|;
name|dstbyte
operator|=
name|dx
operator|&
literal|3
expr_stmt|;
name|i
operator|=
name|w
expr_stmt|;
comment|/* WARNING: this code is KNOWN TO FAIL on Sun 3's / CG2's. */
name|ROP_SRCDSTCOLOR
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|while ( i>
literal|0
argument|) 			    { 			    dl = *dstlong;
argument_list|,
comment|/*s*/
argument|*srclong& raster_bitmask[srcbit]
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*c*/
argument|color
argument_list|,
comment|/*pst*/
argument|*dstlong = ( *dstlong& ~bytemask[dstbyte] ) | 				       ( dl& bytemask[dstbyte] ); 			    if ( srcbit ==
literal|31
argument|) 				{ 				srcbit =
literal|0
argument|; 				++srclong; 				} 			    else 				++srcbit; 			    if ( dstbyte ==
literal|3
argument|) 				{ 				dstbyte =
literal|0
argument|; 				++dstlong; 				} 			    else 				++dstbyte; 			    --i; 			    }
argument_list|)
name|srclin
operator|+=
name|src
operator|->
name|linelongs
expr_stmt|;
name|dstlin
operator|+=
name|dst
operator|->
name|linelongs
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Eight to eight blit. */
name|u_long
modifier|*
name|srclin1
decl_stmt|;
name|u_long
modifier|*
name|dstlin1
decl_stmt|;
name|int
name|srcleftignore
decl_stmt|,
name|srcrightignore
decl_stmt|,
name|srclongs
decl_stmt|;
name|int
name|dstleftignore
decl_stmt|,
name|dstrightignore
decl_stmt|,
name|dstlongs
decl_stmt|;
if|if
condition|(
name|dst
operator|->
name|depth
operator|!=
literal|8
condition|)
return|return
operator|-
literal|1
return|;
comment|/* depth mismatch */
name|srclin1
operator|=
name|RAS_ADDR
argument_list|(
name|src
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
name|dstlin1
operator|=
name|RAS_ADDR
argument_list|(
name|dst
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCOPY_FASTER
comment|/* Special-case full-width to full-width copies. */
if|if
condition|(
name|op
operator|==
name|RAS_SRC
operator|&&
name|src
operator|->
name|width
operator|==
name|w
operator|&&
name|dst
operator|->
name|width
operator|==
name|w
operator|&&
name|src
operator|->
name|linelongs
operator|==
name|dst
operator|->
name|linelongs
operator|&&
name|src
operator|->
name|linelongs
operator|==
name|w
operator|>>
literal|2
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|srclin1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dstlin1
argument_list|,
name|h
operator|*
name|src
operator|->
name|linelongs
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*BCOPY_FASTER*/
name|srcleftignore
operator|=
operator|(
name|sx
operator|&
literal|3
operator|)
operator|*
literal|8
expr_stmt|;
name|srclongs
operator|=
operator|(
name|srcleftignore
operator|+
name|w
operator|*
literal|8
operator|+
literal|31
operator|)
operator|>>
literal|5
expr_stmt|;
name|srcrightignore
operator|=
operator|(
name|srclongs
operator|*
literal|32
operator|-
name|w
operator|*
literal|8
operator|-
name|srcleftignore
operator|)
operator|&
literal|31
expr_stmt|;
name|dstleftignore
operator|=
operator|(
name|dx
operator|&
literal|3
operator|)
operator|*
literal|8
expr_stmt|;
name|dstlongs
operator|=
operator|(
name|dstleftignore
operator|+
name|w
operator|*
literal|8
operator|+
literal|31
operator|)
operator|>>
literal|5
expr_stmt|;
name|dstrightignore
operator|=
operator|(
name|dstlongs
operator|*
literal|32
operator|-
name|w
operator|*
literal|8
operator|-
name|dstleftignore
operator|)
operator|&
literal|31
expr_stmt|;
return|return
name|raster_blit
argument_list|(
name|src
argument_list|,
name|srclin1
argument_list|,
name|srcleftignore
argument_list|,
name|srcrightignore
argument_list|,
name|srclongs
argument_list|,
name|dst
argument_list|,
name|dstlin1
argument_list|,
name|dstleftignore
argument_list|,
name|dstrightignore
argument_list|,
name|dstlongs
argument_list|,
name|h
argument_list|,
name|op
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Semi-public routine to do a no-src bitblit without clipping.  Returns 0 ** on success, -1 on failure. */
end_comment

begin_function
name|int
name|raster_op_nosrc_noclip
parameter_list|(
name|dst
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|rop
parameter_list|)
name|struct
name|raster
modifier|*
name|dst
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|,
name|rop
decl_stmt|;
block|{
name|int
name|op
decl_stmt|;
name|op
operator|=
name|RAS_GETOP
argument_list|(
name|rop
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|depth
operator|==
literal|1
condition|)
block|{
comment|/* One-bit no-src blit. */
name|u_long
modifier|*
name|dstlin1
decl_stmt|;
name|u_long
modifier|*
name|dstlin2
decl_stmt|;
name|u_long
modifier|*
name|dstlin
decl_stmt|;
name|int
name|dstleftignore
decl_stmt|,
name|dstrightignore
decl_stmt|,
name|dstlongs
decl_stmt|;
name|u_long
name|dl
decl_stmt|,
name|lm
decl_stmt|,
name|nlm
decl_stmt|,
name|rm
decl_stmt|,
name|nrm
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|dstlong2
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|dstlong
decl_stmt|;
name|dstlin1
operator|=
name|RAS_ADDR
argument_list|(
name|dst
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCOPY_FASTER
comment|/* Special-case full-width clears. */
if|if
condition|(
name|op
operator|==
name|RAS_CLEAR
operator|&&
name|dst
operator|->
name|width
operator|==
name|w
operator|&&
name|dst
operator|->
name|linelongs
operator|==
name|w
operator|>>
literal|5
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dstlin1
argument_list|,
name|h
operator|*
name|dst
operator|->
name|linelongs
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*BCOPY_FASTER*/
name|dstleftignore
operator|=
operator|(
name|dx
operator|&
literal|31
operator|)
expr_stmt|;
name|dstlongs
operator|=
operator|(
name|dstleftignore
operator|+
name|w
operator|+
literal|31
operator|)
operator|>>
literal|5
expr_stmt|;
name|dstrightignore
operator|=
operator|(
name|dstlongs
operator|*
literal|32
operator|-
name|w
operator|-
name|dstleftignore
operator|)
operator|&
literal|31
expr_stmt|;
name|dstlin2
operator|=
name|dstlin1
operator|+
name|h
operator|*
name|dst
operator|->
name|linelongs
expr_stmt|;
name|dstlin
operator|=
name|dstlin1
expr_stmt|;
if|if
condition|(
name|dstlongs
operator|==
literal|1
condition|)
block|{
comment|/* It fits into a single longword. */
name|lm
operator|=
name|leftmask
index|[
name|dstleftignore
index|]
operator||
name|rightmask
index|[
name|dstrightignore
index|]
expr_stmt|;
name|nlm
operator|=
operator|~
name|lm
expr_stmt|;
while|while
condition|(
name|dstlin
operator|!=
name|dstlin2
condition|)
block|{
name|ROP_DST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlin;
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlin = ( *dstlin& lm ) | ( dl& nlm );
argument_list|)
name|dstlin
operator|+=
name|dst
operator|->
name|linelongs
expr_stmt|;
block|}
block|}
else|else
block|{
name|lm
operator|=
name|leftmask
index|[
name|dstleftignore
index|]
expr_stmt|;
name|rm
operator|=
name|rightmask
index|[
name|dstrightignore
index|]
expr_stmt|;
name|nrm
operator|=
operator|~
name|rm
expr_stmt|;
name|nlm
operator|=
operator|~
name|lm
expr_stmt|;
while|while
condition|(
name|dstlin
operator|!=
name|dstlin2
condition|)
block|{
name|dstlong
operator|=
name|dstlin
expr_stmt|;
name|dstlong2
operator|=
name|dstlong
operator|+
name|dstlongs
expr_stmt|;
if|if
condition|(
name|dstrightignore
operator|!=
literal|0
condition|)
operator|--
name|dstlong2
expr_stmt|;
comment|/* Leading edge. */
if|if
condition|(
name|dstleftignore
operator|!=
literal|0
condition|)
block|{
name|ROP_DST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlong;
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlong = ( *dstlong& lm ) | ( dl& nlm );
argument_list|)
operator|++
name|dstlong
expr_stmt|;
block|}
comment|/* Main rop. */
name|ROP_DST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|while ( dstlong != dstlong2 ) 			    {
argument_list|,
comment|/*d*/
argument|*dstlong
argument_list|,
comment|/*pst*/
argument|++dstlong; 			    }
argument_list|)
comment|/* Trailing edge. */
if|if
condition|(
name|dstrightignore
operator|!=
literal|0
condition|)
block|{
name|ROP_DST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlong;
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlong = ( dl& nrm ) | ( *dstlong& rm );
argument_list|)
block|}
name|dstlin
operator|+=
name|dst
operator|->
name|linelongs
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Eight-bit no-src blit. */
specifier|register
name|u_long
name|color
decl_stmt|;
name|u_long
modifier|*
name|dstlin1
decl_stmt|;
name|u_long
modifier|*
name|dstlin2
decl_stmt|;
name|u_long
modifier|*
name|dstlin
decl_stmt|;
name|int
name|dstleftignore
decl_stmt|,
name|dstrightignore
decl_stmt|,
name|dstlongs
decl_stmt|;
name|u_long
name|dl
decl_stmt|,
name|lm
decl_stmt|,
name|nlm
decl_stmt|,
name|rm
decl_stmt|,
name|nrm
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|dstlong2
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|dstlong
decl_stmt|;
name|dstlin1
operator|=
name|RAS_ADDR
argument_list|(
name|dst
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCOPY_FASTER
comment|/* Special-case full-width clears. */
if|if
condition|(
name|op
operator|==
name|RAS_CLEAR
operator|&&
name|dst
operator|->
name|width
operator|==
name|w
operator|&&
name|dst
operator|->
name|linelongs
operator|==
name|w
operator|>>
literal|2
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dstlin1
argument_list|,
name|h
operator|*
name|dst
operator|->
name|linelongs
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*BCOPY_FASTER*/
name|color
operator|=
name|RAS_GETCOLOR
argument_list|(
name|rop
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
operator|==
literal|0
condition|)
name|color
operator|=
literal|255
expr_stmt|;
comment|/* Make 32 bits of color so we can do the ROP without shifting. */
name|color
operator||=
operator|(
name|color
operator|<<
literal|24
operator|)
operator||
operator|(
name|color
operator|<<
literal|16
operator|)
operator||
operator|(
name|color
operator|<<
literal|8
operator|)
expr_stmt|;
name|dstleftignore
operator|=
operator|(
name|dx
operator|&
literal|3
operator|)
operator|*
literal|8
expr_stmt|;
name|dstlongs
operator|=
operator|(
name|dstleftignore
operator|+
name|w
operator|*
literal|8
operator|+
literal|31
operator|)
operator|>>
literal|5
expr_stmt|;
name|dstrightignore
operator|=
operator|(
name|dstlongs
operator|*
literal|32
operator|-
name|w
operator|*
literal|8
operator|-
name|dstleftignore
operator|)
operator|&
literal|31
expr_stmt|;
name|dstlin2
operator|=
name|dstlin1
operator|+
name|h
operator|*
name|dst
operator|->
name|linelongs
expr_stmt|;
name|dstlin
operator|=
name|dstlin1
expr_stmt|;
if|if
condition|(
name|dstlongs
operator|==
literal|1
condition|)
block|{
comment|/* It fits into a single longword. */
name|lm
operator|=
name|leftmask
index|[
name|dstleftignore
index|]
operator||
name|rightmask
index|[
name|dstrightignore
index|]
expr_stmt|;
name|nlm
operator|=
operator|~
name|lm
expr_stmt|;
while|while
condition|(
name|dstlin
operator|!=
name|dstlin2
condition|)
block|{
name|ROP_DSTCOLOR
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlin;
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*c*/
argument|color
argument_list|,
comment|/*pst*/
argument|*dstlin = ( *dstlin& lm ) | ( dl& nlm );
argument_list|)
name|dstlin
operator|+=
name|dst
operator|->
name|linelongs
expr_stmt|;
block|}
block|}
else|else
block|{
name|lm
operator|=
name|leftmask
index|[
name|dstleftignore
index|]
expr_stmt|;
name|rm
operator|=
name|rightmask
index|[
name|dstrightignore
index|]
expr_stmt|;
name|nrm
operator|=
operator|~
name|rm
expr_stmt|;
name|nlm
operator|=
operator|~
name|lm
expr_stmt|;
while|while
condition|(
name|dstlin
operator|!=
name|dstlin2
condition|)
block|{
name|dstlong
operator|=
name|dstlin
expr_stmt|;
name|dstlong2
operator|=
name|dstlong
operator|+
name|dstlongs
expr_stmt|;
if|if
condition|(
name|dstrightignore
operator|!=
literal|0
condition|)
operator|--
name|dstlong2
expr_stmt|;
comment|/* Leading edge. */
if|if
condition|(
name|dstleftignore
operator|!=
literal|0
condition|)
block|{
name|ROP_DSTCOLOR
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlong;
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*c*/
argument|color
argument_list|,
comment|/*pst*/
argument|*dstlong = ( *dstlong& lm ) | ( dl& nlm );
argument_list|)
operator|++
name|dstlong
expr_stmt|;
block|}
comment|/* Main rop. */
name|ROP_DSTCOLOR
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|while ( dstlong != dstlong2 ) 			    {
argument_list|,
comment|/*d*/
argument|*dstlong
argument_list|,
comment|/*c*/
argument|color
argument_list|,
comment|/*pst*/
argument|++dstlong; 			    }
argument_list|)
comment|/* Trailing edge. */
if|if
condition|(
name|dstrightignore
operator|!=
literal|0
condition|)
block|{
name|ROP_DSTCOLOR
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlong;
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*c*/
argument|color
argument_list|,
comment|/*pst*/
argument|*dstlong = ( dl& nrm ) | ( *dstlong& rm );
argument_list|)
block|}
name|dstlin
operator|+=
name|dst
operator|->
name|linelongs
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is a general bitblit routine, handling overlapping source and ** destination.  It's used for both the 1-to-1 and 8-to-8 cases. */
end_comment

begin_function
specifier|static
name|int
name|raster_blit
parameter_list|(
name|src
parameter_list|,
name|srclin1
parameter_list|,
name|srcleftignore
parameter_list|,
name|srcrightignore
parameter_list|,
name|srclongs
parameter_list|,
name|dst
parameter_list|,
name|dstlin1
parameter_list|,
name|dstleftignore
parameter_list|,
name|dstrightignore
parameter_list|,
name|dstlongs
parameter_list|,
name|h
parameter_list|,
name|op
parameter_list|)
name|struct
name|raster
modifier|*
name|src
decl_stmt|;
name|u_long
modifier|*
name|srclin1
decl_stmt|;
name|int
name|srcleftignore
decl_stmt|,
name|srcrightignore
decl_stmt|,
name|srclongs
decl_stmt|;
name|struct
name|raster
modifier|*
name|dst
decl_stmt|;
name|u_long
modifier|*
name|dstlin1
decl_stmt|;
name|int
name|dstleftignore
decl_stmt|,
name|dstrightignore
decl_stmt|,
name|dstlongs
decl_stmt|;
name|int
name|h
decl_stmt|,
name|op
decl_stmt|;
block|{
name|u_long
modifier|*
name|srclin2
decl_stmt|;
name|u_long
modifier|*
name|dstlin2
decl_stmt|;
name|int
name|srclininc
decl_stmt|,
name|dstlininc
decl_stmt|;
name|u_long
modifier|*
name|srclin
decl_stmt|;
name|u_long
modifier|*
name|dstlin
decl_stmt|;
specifier|register
name|int
name|prevleftshift
decl_stmt|,
name|currrightshift
decl_stmt|;
name|int
name|longinc
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|srclong
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|dstlong
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|dstlong2
decl_stmt|;
specifier|register
name|u_long
name|dl
decl_stmt|,
name|lm
decl_stmt|,
name|nlm
decl_stmt|,
name|rm
decl_stmt|,
name|nrm
decl_stmt|;
name|prevleftshift
operator|=
operator|(
name|srcleftignore
operator|-
name|dstleftignore
operator|)
operator|&
literal|31
expr_stmt|;
name|srclin2
operator|=
name|srclin1
operator|+
name|h
operator|*
name|src
operator|->
name|linelongs
expr_stmt|;
name|dstlin2
operator|=
name|dstlin1
operator|+
name|h
operator|*
name|dst
operator|->
name|linelongs
expr_stmt|;
name|srclininc
operator|=
name|src
operator|->
name|linelongs
expr_stmt|;
name|dstlininc
operator|=
name|dst
operator|->
name|linelongs
expr_stmt|;
name|longinc
operator|=
literal|1
expr_stmt|;
comment|/* Check for overlaps. */
if|if
condition|(
operator|(
name|dstlin1
operator|>=
name|srclin1
operator|&&
name|dstlin1
operator|<
name|srclin1
operator|+
name|srclongs
operator|)
operator|||
operator|(
name|srclin1
operator|>=
name|dstlin1
operator|&&
name|srclin1
operator|<
name|dstlin1
operator|+
name|dstlongs
operator|)
condition|)
block|{
comment|/* Horizontal overlap.  Should we reverse? */
if|if
condition|(
name|srclin1
operator|<
name|dstlin1
condition|)
block|{
name|longinc
operator|=
operator|-
literal|1
expr_stmt|;
name|srclin1
operator|+=
name|srclongs
operator|-
literal|1
expr_stmt|;
name|srclin2
operator|+=
name|srclongs
operator|-
literal|1
expr_stmt|;
name|dstlin1
operator|+=
name|dstlongs
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|dstlin1
operator|>=
name|srclin1
operator|&&
name|dstlin1
operator|<
name|srclin2
operator|)
operator|||
operator|(
name|srclin1
operator|>=
name|dstlin1
operator|&&
name|srclin1
operator|<
name|dstlin2
operator|)
condition|)
block|{
comment|/* Vertical overlap.  Should we reverse? */
if|if
condition|(
name|srclin1
operator|<
name|dstlin1
condition|)
block|{
name|srclin2
operator|=
name|srclin1
operator|-
name|srclininc
expr_stmt|;
name|srclin1
operator|+=
operator|(
name|h
operator|-
literal|1
operator|)
operator|*
name|srclininc
expr_stmt|;
name|dstlin1
operator|+=
operator|(
name|h
operator|-
literal|1
operator|)
operator|*
name|dstlininc
expr_stmt|;
name|srclininc
operator|=
operator|-
name|srclininc
expr_stmt|;
name|dstlininc
operator|=
operator|-
name|dstlininc
expr_stmt|;
block|}
block|}
name|srclin
operator|=
name|srclin1
expr_stmt|;
name|dstlin
operator|=
name|dstlin1
expr_stmt|;
if|if
condition|(
name|prevleftshift
operator|==
literal|0
condition|)
block|{
comment|/* The bits line up, no shifting necessary. */
if|if
condition|(
name|dstlongs
operator|==
literal|1
condition|)
block|{
comment|/* It all fits into a single longword. */
name|lm
operator|=
name|leftmask
index|[
name|dstleftignore
index|]
operator||
name|rightmask
index|[
name|dstrightignore
index|]
expr_stmt|;
name|nlm
operator|=
operator|~
name|lm
expr_stmt|;
while|while
condition|(
name|srclin
operator|!=
name|srclin2
condition|)
block|{
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlin;
argument_list|,
comment|/*s*/
argument|*srclin
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlin = ( *dstlin& lm ) | ( dl& nlm );
argument_list|)
name|srclin
operator|+=
name|srclininc
expr_stmt|;
name|dstlin
operator|+=
name|dstlininc
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Multiple longwords. */
name|lm
operator|=
name|leftmask
index|[
name|dstleftignore
index|]
expr_stmt|;
name|rm
operator|=
name|rightmask
index|[
name|dstrightignore
index|]
expr_stmt|;
name|nrm
operator|=
operator|~
name|rm
expr_stmt|;
name|nlm
operator|=
operator|~
name|lm
expr_stmt|;
if|if
condition|(
name|longinc
operator|==
literal|1
condition|)
block|{
comment|/* Left to right. */
while|while
condition|(
name|srclin
operator|!=
name|srclin2
condition|)
block|{
name|srclong
operator|=
name|srclin
expr_stmt|;
name|dstlong
operator|=
name|dstlin
expr_stmt|;
name|dstlong2
operator|=
name|dstlong
operator|+
name|dstlongs
expr_stmt|;
if|if
condition|(
name|dstrightignore
operator|!=
literal|0
condition|)
operator|--
name|dstlong2
expr_stmt|;
comment|/* Leading edge. */
if|if
condition|(
name|dstleftignore
operator|!=
literal|0
condition|)
block|{
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlong;
argument_list|,
comment|/*s*/
argument|*srclong
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlong = ( *dstlong& lm ) | ( dl& nlm );
argument_list|)
operator|++
name|srclong
expr_stmt|;
operator|++
name|dstlong
expr_stmt|;
block|}
comment|/* Main rop. */
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|while ( dstlong != dstlong2 ) 				{
argument_list|,
comment|/*s*/
argument|*srclong
argument_list|,
comment|/*d*/
argument|*dstlong
argument_list|,
comment|/*pst*/
argument|++srclong; 				++dstlong; 				}
argument_list|)
comment|/* Trailing edge. */
if|if
condition|(
name|dstrightignore
operator|!=
literal|0
condition|)
block|{
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlong;
argument_list|,
comment|/*s*/
argument|*srclong
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlong = ( dl& nrm ) | ( *dstlong& rm );
argument_list|)
block|}
name|srclin
operator|+=
name|srclininc
expr_stmt|;
name|dstlin
operator|+=
name|dstlininc
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Right to left. */
while|while
condition|(
name|srclin
operator|!=
name|srclin2
condition|)
block|{
name|srclong
operator|=
name|srclin
expr_stmt|;
name|dstlong
operator|=
name|dstlin
expr_stmt|;
name|dstlong2
operator|=
name|dstlong
operator|-
name|dstlongs
expr_stmt|;
if|if
condition|(
name|dstleftignore
operator|!=
literal|0
condition|)
operator|++
name|dstlong2
expr_stmt|;
comment|/* Leading edge. */
if|if
condition|(
name|dstrightignore
operator|!=
literal|0
condition|)
block|{
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlong;
argument_list|,
comment|/*s*/
argument|*srclong
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlong = ( dl& nrm ) | ( *dstlong& rm );
argument_list|)
operator|--
name|srclong
expr_stmt|;
operator|--
name|dstlong
expr_stmt|;
block|}
comment|/* Main rop. */
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|while ( dstlong != dstlong2 ) 				{
argument_list|,
comment|/*s*/
argument|*srclong
argument_list|,
comment|/*d*/
argument|*dstlong
argument_list|,
comment|/*pst*/
argument|--srclong; 				--dstlong; 				}
argument_list|)
comment|/* Trailing edge. */
if|if
condition|(
name|dstleftignore
operator|!=
literal|0
condition|)
block|{
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlong;
argument_list|,
comment|/*s*/
argument|*srclong
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlong = ( *dstlong& lm ) | ( dl& nlm );
argument_list|)
block|}
name|srclin
operator|+=
name|srclininc
expr_stmt|;
name|dstlin
operator|+=
name|dstlininc
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* General case, with shifting and everything. */
specifier|register
name|u_long
name|sl
decl_stmt|,
name|prevsl
decl_stmt|;
name|currrightshift
operator|=
literal|32
operator|-
name|prevleftshift
expr_stmt|;
if|if
condition|(
name|srclongs
operator|==
literal|1
operator|&&
name|dstlongs
operator|==
literal|1
condition|)
block|{
comment|/* It fits into a single longword, with a shift. */
name|lm
operator|=
name|leftmask
index|[
name|dstleftignore
index|]
operator||
name|rightmask
index|[
name|dstrightignore
index|]
expr_stmt|;
name|nlm
operator|=
operator|~
name|lm
expr_stmt|;
if|if
condition|(
name|srcleftignore
operator|>
name|dstleftignore
condition|)
block|{
while|while
condition|(
name|srclin
operator|!=
name|srclin2
condition|)
block|{
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlin;
argument_list|,
comment|/*s*/
argument|*srclin<< prevleftshift
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlin = ( *dstlin& lm ) | ( dl& nlm );
argument_list|)
name|srclin
operator|+=
name|srclininc
expr_stmt|;
name|dstlin
operator|+=
name|dstlininc
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|srclin
operator|!=
name|srclin2
condition|)
block|{
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlin;
argument_list|,
comment|/*s*/
argument|*srclin>> currrightshift
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlin = ( *dstlin& lm ) | ( dl& nlm );
argument_list|)
name|srclin
operator|+=
name|srclininc
expr_stmt|;
name|dstlin
operator|+=
name|dstlininc
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Multiple longwords. */
name|lm
operator|=
name|leftmask
index|[
name|dstleftignore
index|]
expr_stmt|;
name|rm
operator|=
name|rightmask
index|[
name|dstrightignore
index|]
expr_stmt|;
name|nrm
operator|=
operator|~
name|rm
expr_stmt|;
name|nlm
operator|=
operator|~
name|lm
expr_stmt|;
if|if
condition|(
name|longinc
operator|==
literal|1
condition|)
block|{
comment|/* Left to right. */
while|while
condition|(
name|srclin
operator|!=
name|srclin2
condition|)
block|{
name|srclong
operator|=
name|srclin
expr_stmt|;
name|dstlong
operator|=
name|dstlin
expr_stmt|;
name|dstlong2
operator|=
name|dstlong
operator|+
name|dstlongs
expr_stmt|;
if|if
condition|(
name|srcleftignore
operator|>
name|dstleftignore
condition|)
name|prevsl
operator|=
operator|*
name|srclong
operator|++
operator|<<
name|prevleftshift
expr_stmt|;
else|else
name|prevsl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dstrightignore
operator|!=
literal|0
condition|)
operator|--
name|dstlong2
expr_stmt|;
comment|/* Leading edge. */
if|if
condition|(
name|dstleftignore
operator|!=
literal|0
condition|)
block|{
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|sl = *srclong; 				dl = *dstlong;
argument_list|,
comment|/*s*/
argument|prevsl | ( sl>> currrightshift )
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlong = ( *dstlong& lm ) | ( dl& nlm );
argument_list|)
name|prevsl
operator|=
name|sl
operator|<<
name|prevleftshift
expr_stmt|;
operator|++
name|srclong
expr_stmt|;
operator|++
name|dstlong
expr_stmt|;
block|}
comment|/* Main rop. */
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|while ( dstlong != dstlong2 ) 				{ 				sl = *srclong;
argument_list|,
comment|/*s*/
argument|prevsl | ( sl>> currrightshift )
argument_list|,
comment|/*d*/
argument|*dstlong
argument_list|,
comment|/*pst*/
argument|prevsl = sl<< prevleftshift; 				++srclong; 				++dstlong; 				}
argument_list|)
comment|/* Trailing edge. */
if|if
condition|(
name|dstrightignore
operator|!=
literal|0
condition|)
block|{
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlong;
argument_list|,
comment|/*s*/
argument|prevsl | ( *srclong>> currrightshift )
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlong = ( dl& nrm ) | ( *dstlong& rm );
argument_list|)
block|}
name|srclin
operator|+=
name|srclininc
expr_stmt|;
name|dstlin
operator|+=
name|dstlininc
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Right to left. */
while|while
condition|(
name|srclin
operator|!=
name|srclin2
condition|)
block|{
name|srclong
operator|=
name|srclin
expr_stmt|;
name|dstlong
operator|=
name|dstlin
expr_stmt|;
name|dstlong2
operator|=
name|dstlong
operator|-
name|dstlongs
expr_stmt|;
if|if
condition|(
name|srcrightignore
operator|>
name|dstrightignore
condition|)
name|prevsl
operator|=
operator|*
name|srclong
operator|--
operator|>>
name|currrightshift
expr_stmt|;
else|else
name|prevsl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dstleftignore
operator|!=
literal|0
condition|)
operator|++
name|dstlong2
expr_stmt|;
comment|/* Leading edge. */
if|if
condition|(
name|dstrightignore
operator|!=
literal|0
condition|)
block|{
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|sl = *srclong; 				dl = *dstlong;
argument_list|,
comment|/*s*/
argument|prevsl | ( sl<< prevleftshift )
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlong = ( dl& nrm ) | ( *dstlong& rm );
argument_list|)
name|prevsl
operator|=
name|sl
operator|>>
name|currrightshift
expr_stmt|;
operator|--
name|srclong
expr_stmt|;
operator|--
name|dstlong
expr_stmt|;
block|}
comment|/* Main rop. */
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|while ( dstlong != dstlong2 ) 				{ 				sl = *srclong;
argument_list|,
comment|/*s*/
argument|prevsl | ( sl<< prevleftshift )
argument_list|,
comment|/*d*/
argument|*dstlong
argument_list|,
comment|/*pst*/
argument|prevsl = sl>> currrightshift; 				--srclong; 				--dstlong; 				}
argument_list|)
comment|/* Trailing edge. */
if|if
condition|(
name|dstleftignore
operator|!=
literal|0
condition|)
block|{
name|ROP_SRCDST
argument_list|(
comment|/*op*/
argument|op
argument_list|,
comment|/*pre*/
argument|dl = *dstlong;
argument_list|,
comment|/*s*/
argument|prevsl | ( *srclong<< prevleftshift )
argument_list|,
comment|/*d*/
argument|dl
argument_list|,
comment|/*pst*/
argument|*dstlong = ( *dstlong& lm ) | ( dl& nlm );
argument_list|)
block|}
name|srclin
operator|+=
name|srclininc
expr_stmt|;
name|dstlin
operator|+=
name|dstlininc
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

