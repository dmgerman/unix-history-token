begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to the Computer Systems  * Engineering Group at Lawrence Berkeley Laboratory and to the University  * of California at Berkeley by Jef Poskanzer.  *  * %sccs.include.redist.c%  *  *	@(#)raster_text.c	8.1 (Berkeley) %G%  *  * from: $Header: raster_text.c,v 1.15 92/06/17 08:14:45 torek Exp $  */
end_comment

begin_comment
comment|/*  * Text routines for raster library.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sparc/rcons/raster.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COLORFONT_CACHE
end_ifdef

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_define
define|#
directive|define
name|NEW
parameter_list|(
name|size
parameter_list|)
value|malloc(size, M_DEVBUF, M_NOWAIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sparc/rcons/raster.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COLORFONT_CACHE
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_define
define|#
directive|define
name|NEW
parameter_list|(
name|size
parameter_list|)
value|malloc(size)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Draws text.  Returns 0 on success, -1 on failure. */
end_comment

begin_function
name|int
name|raster_text
parameter_list|(
name|r
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|rop
parameter_list|,
name|rf
parameter_list|,
name|text
parameter_list|)
specifier|register
name|struct
name|raster
modifier|*
name|r
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|rop
decl_stmt|;
name|struct
name|raster_font
modifier|*
name|rf
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
return|return
name|raster_textn
argument_list|(
name|r
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|rop
argument_list|,
name|rf
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Draws n characters of text.  Returns 0 on success, -1 on failure. */
end_comment

begin_function
name|int
name|raster_textn
parameter_list|(
name|r
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|rop
parameter_list|,
name|rf
parameter_list|,
name|text
parameter_list|,
name|n
parameter_list|)
specifier|register
name|struct
name|raster
modifier|*
name|r
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|rop
decl_stmt|;
name|struct
name|raster_font
modifier|*
name|rf
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|clip
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|struct
name|raster_char
modifier|*
name|c
decl_stmt|;
name|struct
name|raster
modifier|*
name|charrast
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
name|int
name|thisx
decl_stmt|,
name|thisy
decl_stmt|;
name|int
name|phase
decl_stmt|;
comment|/* Check whether we can avoid clipping. */
name|clip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|flags
operator|&
name|RASFONT_FIXEDWIDTH
operator|&&
name|rf
operator|->
name|flags
operator|&
name|RASFONT_NOVERTICALMOVEMENT
condition|)
block|{
comment|/* This font is well-behaved, we can compute the extent cheaply. */
name|c
operator|=
operator|&
operator|(
name|rf
operator|->
name|chars
index|[
literal|'@'
index|]
operator|)
expr_stmt|;
name|charrast
operator|=
name|c
operator|->
name|r
expr_stmt|;
if|if
condition|(
name|x
operator|+
name|c
operator|->
name|homex
operator|<
literal|0
operator|||
name|y
operator|+
name|c
operator|->
name|homey
operator|<
literal|0
operator|||
name|x
operator|+
name|c
operator|->
name|homex
operator|+
name|n
operator|*
name|c
operator|->
name|nextx
operator|>
name|r
operator|->
name|width
operator|||
name|y
operator|+
name|c
operator|->
name|homey
operator|+
name|charrast
operator|->
name|height
operator|>
name|r
operator|->
name|height
condition|)
name|clip
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Got to step through the string to compute the extent. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|x1
operator|=
name|x
operator|,
name|y1
operator|=
name|y
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
operator|,
name|x1
operator|+=
name|c
operator|->
name|nextx
operator|,
name|y1
operator|+=
name|c
operator|->
name|nexty
control|)
block|{
name|c
operator|=
operator|&
operator|(
name|rf
operator|->
name|chars
index|[
name|text
index|[
name|i
index|]
index|]
operator|)
expr_stmt|;
name|charrast
operator|=
name|c
operator|->
name|r
expr_stmt|;
if|if
condition|(
name|charrast
operator|!=
operator|(
expr|struct
name|raster
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|x1
operator|+
name|c
operator|->
name|homex
operator|<
literal|0
operator|||
name|y1
operator|+
name|c
operator|->
name|homey
operator|<
literal|0
operator|||
name|x1
operator|+
name|c
operator|->
name|homex
operator|+
name|charrast
operator|->
name|width
operator|>
name|r
operator|->
name|width
operator|||
name|y1
operator|+
name|c
operator|->
name|homey
operator|+
name|charrast
operator|->
name|height
operator|>
name|r
operator|->
name|height
condition|)
block|{
name|clip
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Now display the text. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|x1
operator|=
name|x
operator|,
name|y1
operator|=
name|y
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
operator|,
name|x1
operator|+=
name|c
operator|->
name|nextx
operator|,
name|y1
operator|+=
name|c
operator|->
name|nexty
control|)
block|{
name|ch
operator|=
name|text
index|[
name|i
index|]
expr_stmt|;
name|c
operator|=
operator|&
operator|(
name|rf
operator|->
name|chars
index|[
name|ch
index|]
operator|)
expr_stmt|;
name|charrast
operator|=
name|c
operator|->
name|r
expr_stmt|;
if|if
condition|(
name|charrast
operator|!=
operator|(
expr|struct
name|raster
operator|*
operator|)
literal|0
condition|)
block|{
name|thisx
operator|=
name|x1
operator|+
name|c
operator|->
name|homex
expr_stmt|;
name|thisy
operator|=
name|y1
operator|+
name|c
operator|->
name|homey
expr_stmt|;
name|phase
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|COLORFONT_CACHE
if|if
condition|(
name|r
operator|->
name|depth
operator|==
literal|8
condition|)
block|{
comment|/* Initialize color font cache if necessary. */
if|if
condition|(
name|rf
operator|->
name|cache
operator|==
operator|(
expr|struct
name|raster_fontcache
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|int
name|c
decl_stmt|;
name|rf
operator|->
name|cache
operator|=
operator|(
expr|struct
name|raster_fontcache
operator|*
operator|)
name|NEW
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|raster_fontcache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|cache
operator|!=
operator|(
expr|struct
name|raster_fontcache
operator|*
operator|)
literal|0
condition|)
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
operator|++
name|c
control|)
name|rf
operator|->
name|cache
operator|->
name|cr
index|[
name|c
index|]
operator|=
operator|(
expr|struct
name|raster
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rf
operator|->
name|cache
operator|!=
operator|(
expr|struct
name|raster_fontcache
operator|*
operator|)
literal|0
condition|)
block|{
name|int
name|color
decl_stmt|;
name|struct
name|raster
modifier|*
name|cr
decl_stmt|;
name|color
operator|=
name|RAS_GETCOLOR
argument_list|(
name|rop
argument_list|)
expr_stmt|;
name|cr
operator|=
name|rf
operator|->
name|cache
operator|->
name|cr
index|[
name|ch
index|]
expr_stmt|;
comment|/* Is this character cached yet? */
if|if
condition|(
name|cr
operator|!=
operator|(
expr|struct
name|raster
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* Yes, but is it the right color? */
if|if
condition|(
name|rf
operator|->
name|cache
operator|->
name|color
index|[
name|ch
index|]
operator|==
name|color
condition|)
block|{
comment|/* Yes - switch rasters. */
name|charrast
operator|=
name|cr
expr_stmt|;
block|}
else|else
block|{
comment|/* No, re-draw it. */
if|if
condition|(
name|raster_op_noclip
argument_list|(
name|cr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|charrast
operator|->
name|width
argument_list|,
name|charrast
operator|->
name|height
argument_list|,
name|rop
argument_list|,
name|charrast
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rf
operator|->
name|cache
operator|->
name|color
index|[
name|ch
index|]
operator|=
name|color
expr_stmt|;
name|charrast
operator|=
name|cr
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* It's not cached, so cache it. */
name|cr
operator|=
name|raster_alloc
argument_list|(
name|charrast
operator|->
name|width
argument_list|,
name|charrast
operator|->
name|height
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|!=
operator|(
expr|struct
name|raster
operator|*
operator|)
literal|0
condition|)
if|if
condition|(
name|raster_op_noclip
argument_list|(
name|cr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|charrast
operator|->
name|width
argument_list|,
name|charrast
operator|->
name|height
argument_list|,
name|rop
argument_list|,
name|charrast
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rf
operator|->
name|cache
operator|->
name|color
index|[
name|ch
index|]
operator|=
name|color
expr_stmt|;
name|charrast
operator|=
name|rf
operator|->
name|cache
operator|->
name|cr
index|[
name|ch
index|]
operator|=
name|cr
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/*COLORFONT_CACHE*/
if|if
condition|(
name|clip
condition|)
block|{
if|if
condition|(
name|raster_op
argument_list|(
name|r
argument_list|,
name|thisx
argument_list|,
name|thisy
argument_list|,
name|charrast
operator|->
name|width
argument_list|,
name|charrast
operator|->
name|height
argument_list|,
name|rop
argument_list|,
name|charrast
argument_list|,
name|phase
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|raster_op_noclip
argument_list|(
name|r
argument_list|,
name|thisx
argument_list|,
name|thisy
argument_list|,
name|charrast
operator|->
name|width
argument_list|,
name|charrast
operator|->
name|height
argument_list|,
name|rop
argument_list|,
name|charrast
argument_list|,
name|phase
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COLORFONT_CACHE
end_ifdef

begin_comment
comment|/* Allocates a raster.  Returns (struct raster*) 0 on failure. */
end_comment

begin_function
name|struct
name|raster
modifier|*
name|raster_alloc
parameter_list|(
name|width
parameter_list|,
name|height
parameter_list|,
name|depth
parameter_list|)
name|int
name|width
decl_stmt|,
name|height
decl_stmt|,
name|depth
decl_stmt|;
block|{
name|struct
name|raster
modifier|*
name|r
decl_stmt|;
name|int
name|linelongs
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|||
operator|(
name|depth
operator|!=
literal|1
operator|&&
name|depth
operator|!=
literal|8
operator|)
condition|)
return|return
operator|(
expr|struct
name|raster
operator|*
operator|)
literal|0
return|;
name|linelongs
operator|=
operator|(
operator|(
name|width
operator|*
name|depth
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
expr_stmt|;
name|r
operator|=
operator|(
expr|struct
name|raster
operator|*
operator|)
name|NEW
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|raster
argument_list|)
operator|+
name|height
operator|*
name|linelongs
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|(
expr|struct
name|raster
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
expr|struct
name|raster
operator|*
operator|)
literal|0
return|;
name|r
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|r
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|r
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|r
operator|->
name|linelongs
operator|=
name|linelongs
expr_stmt|;
name|r
operator|->
name|pixels
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|(
name|r
operator|+
literal|1
operator|)
expr_stmt|;
name|r
operator|->
name|data
operator|=
operator|(
name|caddr_t
operator|)
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

