begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)machdep.c	8.6 (Berkeley) %G%  *  * from: $Header: machdep.c,v 1.44 93/10/31 05:28:36 torek Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/map.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/clist.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVSHM
end_ifdef

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sparc/asm.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sparc/cache.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sparc/vaddrs.h>
end_include

begin_decl_stmt
name|vm_map_t
name|buffer_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|vm_offset_t
name|avail_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Declare these as initialized data so we can patch them.  */
end_comment

begin_decl_stmt
name|int
name|nswbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NBUF
end_ifdef

begin_decl_stmt
name|int
name|nbuf
init|=
name|NBUF
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|nbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BUFPAGES
end_ifdef

begin_decl_stmt
name|int
name|bufpages
init|=
name|BUFPAGES
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|bufpages
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|physmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|msgbuf
name|msgbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
init|=
operator|&
name|msgbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msgbufmapped
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* message buffer is always mapped */
end_comment

begin_comment
comment|/*  * safepri is a safe priority for sleep to set for a spin-wait  * during autoconfiguration or after a panic.  */
end_comment

begin_decl_stmt
name|int
name|safepri
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|caddr_t
name|allocsys
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Machine-dependent startup code  */
end_comment

begin_macro
name|cpu_startup
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|unsigned
name|i
decl_stmt|;
specifier|register
name|caddr_t
name|v
decl_stmt|;
specifier|register
name|int
name|sz
decl_stmt|;
name|int
name|base
decl_stmt|,
name|residual
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
specifier|extern
name|int
name|pmapdebug
decl_stmt|;
name|int
name|opmapdebug
init|=
name|pmapdebug
decl_stmt|;
endif|#
directive|endif
name|vm_offset_t
name|minaddr
decl_stmt|,
name|maxaddr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|pmapdebug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Good {morning,afternoon,evening,night}. 	 */
name|printf
argument_list|(
name|version
argument_list|)
expr_stmt|;
comment|/*identifycpu();*/
name|physmem
operator|=
name|btoc
argument_list|(
name|avail_end
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"real mem = %d\n"
argument_list|,
name|avail_end
argument_list|)
expr_stmt|;
comment|/* 	 * Find out how much space we need, allocate it, 	 * and then give everything true virtual addresses. 	 */
name|sz
operator|=
operator|(
name|int
operator|)
name|allocsys
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
operator|(
name|caddr_t
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|round_page
argument_list|(
name|sz
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"startup: no room for tables"
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocsys
argument_list|(
name|v
argument_list|)
operator|-
name|v
operator|!=
name|sz
condition|)
name|panic
argument_list|(
literal|"startup: table size inconsistency"
argument_list|)
expr_stmt|;
comment|/* 	 * Now allocate buffers proper.  They are different than the above 	 * in that they usually occupy more virtual memory than physical. 	 */
name|size
operator|=
name|MAXBSIZE
operator|*
name|nbuf
expr_stmt|;
name|buffer_map
operator|=
name|kmem_suballoc
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|buffers
argument_list|,
operator|&
name|maxaddr
argument_list|,
name|size
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|minaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|buffers
expr_stmt|;
if|if
condition|(
name|vm_map_find
argument_list|(
name|buffer_map
argument_list|,
name|vm_object_allocate
argument_list|(
name|size
argument_list|)
argument_list|,
operator|(
name|vm_offset_t
operator|)
literal|0
argument_list|,
operator|&
name|minaddr
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
name|panic
argument_list|(
literal|"startup: cannot allocate buffers"
argument_list|)
expr_stmt|;
name|base
operator|=
name|bufpages
operator|/
name|nbuf
expr_stmt|;
name|residual
operator|=
name|bufpages
operator|%
name|nbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
block|{
name|vm_size_t
name|curbufsize
decl_stmt|;
name|vm_offset_t
name|curbuf
decl_stmt|;
comment|/* 		 * First<residual> buffers get (base+1) physical pages 		 * allocated for them.  The rest get (base) physical pages. 		 * 		 * The rest of each buffer occupies virtual space, 		 * but has no physical memory allocated for it. 		 */
name|curbuf
operator|=
operator|(
name|vm_offset_t
operator|)
name|buffers
operator|+
name|i
operator|*
name|MAXBSIZE
expr_stmt|;
name|curbufsize
operator|=
name|CLBYTES
operator|*
operator|(
name|i
operator|<
name|residual
condition|?
name|base
operator|+
literal|1
else|:
name|base
operator|)
expr_stmt|;
name|vm_map_pageable
argument_list|(
name|buffer_map
argument_list|,
name|curbuf
argument_list|,
name|curbuf
operator|+
name|curbufsize
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|vm_map_simplify
argument_list|(
name|buffer_map
argument_list|,
name|curbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate a submap for exec arguments.  This map effectively 	 * limits the number of processes exec'ing at any time. 	 */
name|exec_map
operator|=
name|kmem_suballoc
argument_list|(
name|kernel_map
argument_list|,
operator|&
name|minaddr
argument_list|,
operator|&
name|maxaddr
argument_list|,
literal|16
operator|*
name|NCARGS
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a map for physio.  Others use a submap of the kernel 	 * map, but we want one completely separate, even though it uses 	 * the same pmap. 	 */
name|phys_map
operator|=
name|vm_map_create
argument_list|(
name|kernel_pmap
argument_list|,
name|DVMA_BASE
argument_list|,
name|DVMA_END
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|phys_map
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"unable to create DVMA map"
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size 	 * we use the more space efficient malloc in place of kmem_alloc. 	 */
name|mclrefcnt
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|NMBCLUSTERS
operator|+
name|CLBYTES
operator|/
name|MCLBYTES
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mclrefcnt
argument_list|,
name|NMBCLUSTERS
operator|+
name|CLBYTES
operator|/
name|MCLBYTES
argument_list|)
expr_stmt|;
name|mb_map
operator|=
name|kmem_suballoc
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|mbutl
argument_list|,
operator|&
name|maxaddr
argument_list|,
name|VM_MBUF_SIZE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize callouts 	 */
name|callfree
operator|=
name|callout
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ncallout
condition|;
name|i
operator|++
control|)
name|callout
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|c_next
operator|=
operator|&
name|callout
index|[
name|i
index|]
expr_stmt|;
name|callout
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|c_next
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|pmapdebug
operator|=
name|opmapdebug
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"avail mem = %d\n"
argument_list|,
name|ptoa
argument_list|(
name|cnt
operator|.
name|v_free_count
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"using %d buffers containing %d bytes of memory\n"
argument_list|,
name|nbuf
argument_list|,
name|bufpages
operator|*
name|CLBYTES
argument_list|)
expr_stmt|;
comment|/* 	 * Set up buffers, so they can be used to read disk labels. 	 */
name|bufinit
argument_list|()
expr_stmt|;
comment|/* 	 * Configure the system, then turn on the cache.  Should be able 	 * to do this earlier, but then esp.c fails on SS1+ boxes (??). 	 */
name|configure
argument_list|()
expr_stmt|;
name|cache_enable
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Allocate space for system data structures.  We are given  * a starting virtual address and we return a final virtual  * address; along the way we set each data structure pointer.  *  * You call allocsys() with 0 to find out how much space we want,  * allocate that much and fill it with zeroes, and then call  * allocsys() again with the correct base virtual address.  */
end_comment

begin_function
name|caddr_t
name|allocsys
parameter_list|(
name|v
parameter_list|)
specifier|register
name|caddr_t
name|v
decl_stmt|;
block|{
define|#
directive|define
name|valloc
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|num
parameter_list|)
define|\
value|v = (caddr_t)(((name) = (type *)v) + (num))
name|valloc
argument_list|(
name|cfree
argument_list|,
expr|struct
name|cblock
argument_list|,
name|nclist
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|callout
argument_list|,
expr|struct
name|callout
argument_list|,
name|ncallout
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|swapmap
argument_list|,
expr|struct
name|map
argument_list|,
name|nswapmap
operator|=
name|maxproc
operator|*
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSVSHM
name|valloc
argument_list|(
name|shmsegs
argument_list|,
expr|struct
name|shmid_ds
argument_list|,
name|shminfo
operator|.
name|shmmni
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Determine how many buffers to allocate (enough to 	 * hold 5% of total physical memory, but at least 16). 	 * Allocate 1/2 as many swap buffer headers as file i/o buffers. 	 */
if|if
condition|(
name|bufpages
operator|==
literal|0
condition|)
name|bufpages
operator|=
operator|(
name|physmem
operator|/
literal|20
operator|)
operator|/
name|CLSIZE
expr_stmt|;
if|if
condition|(
name|nbuf
operator|==
literal|0
condition|)
block|{
name|nbuf
operator|=
name|bufpages
expr_stmt|;
if|if
condition|(
name|nbuf
operator|<
literal|16
condition|)
name|nbuf
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|nswbuf
operator|==
literal|0
condition|)
block|{
name|nswbuf
operator|=
operator|(
name|nbuf
operator|/
literal|2
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
comment|/* force even */
if|if
condition|(
name|nswbuf
operator|>
literal|256
condition|)
name|nswbuf
operator|=
literal|256
expr_stmt|;
comment|/* sanity */
block|}
name|valloc
argument_list|(
name|swbuf
argument_list|,
expr|struct
name|buf
argument_list|,
name|nswbuf
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|buf
argument_list|,
expr|struct
name|buf
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up registers on exec.  *  * XXX this entire mess must be fixed  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|setregs
argument_list|(
name|p
argument_list|,
name|entry
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_long
name|entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|retval
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|trapframe
modifier|*
name|tf
init|=
name|p
operator|->
name|p_md
operator|.
name|md_tf
decl_stmt|;
specifier|register
name|struct
name|fpstate
modifier|*
name|fs
decl_stmt|;
specifier|register
name|int
name|psr
decl_stmt|,
name|sp
decl_stmt|;
comment|/* 	 * The syscall will ``return'' to npc or %g7 or %g2; set them all. 	 * Set the rest of the registers to 0 except for %o6 (stack pointer, 	 * built in exec()) and psr (retain CWP and PSR_S bits). 	 */
name|psr
operator|=
name|tf
operator|->
name|tf_psr
operator|&
operator|(
name|PSR_S
operator||
name|PSR_CWP
operator|)
expr_stmt|;
name|sp
operator|=
name|tf
operator|->
name|tf_out
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fs
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_fpstate
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We hold an FPU state.  If we own *the* FPU chip state 		 * we must get rid of it, and the only way to do that is 		 * to save it.  In any case, get rid of our FPU state. 		 */
if|if
condition|(
name|p
operator|==
name|fpproc
condition|)
block|{
name|savefpstate
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|fpproc
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fs
argument_list|,
name|M_SUBPROC
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_fpstate
operator|=
name|NULL
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|tf
argument_list|,
sizeof|sizeof
expr|*
name|tf
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_psr
operator|=
name|psr
expr_stmt|;
name|tf
operator|->
name|tf_global
index|[
literal|2
index|]
operator|=
name|tf
operator|->
name|tf_global
index|[
literal|7
index|]
operator|=
name|tf
operator|->
name|tf_npc
operator|=
name|entry
operator|&
operator|~
literal|3
expr_stmt|;
name|tf
operator|->
name|tf_out
index|[
literal|6
index|]
operator|=
name|sp
expr_stmt|;
name|retval
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|sigdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sigpid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SDB_FOLLOW
value|0x01
end_define

begin_define
define|#
directive|define
name|SDB_KSTACK
value|0x02
end_define

begin_define
define|#
directive|define
name|SDB_FPSTATE
value|0x04
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|sigframe
block|{
name|int
name|sf_signo
decl_stmt|;
comment|/* signal number */
name|int
name|sf_code
decl_stmt|;
comment|/* code */
ifdef|#
directive|ifdef
name|COMPAT_SUNOS
name|struct
name|sigcontext
modifier|*
name|sf_scp
decl_stmt|;
comment|/* points to user addr of sigcontext */
else|#
directive|else
name|int
name|sf_xxx
decl_stmt|;
comment|/* placeholder */
endif|#
directive|endif
name|int
name|sf_addr
decl_stmt|;
comment|/* SunOS compat, always 0 for now */
name|struct
name|sigcontext
name|sf_sc
decl_stmt|;
comment|/* actual sigcontext */
block|}
struct|;
end_struct

begin_comment
comment|/*  * machine dependent system variables.  */
end_comment

begin_macro
name|cpu_sysctl
argument_list|(
argument|name
argument_list|,
argument|namelen
argument_list|,
argument|oldp
argument_list|,
argument|oldlenp
argument_list|,
argument|newp
argument_list|,
argument|newlen
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|namelen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|oldp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
modifier|*
name|oldlenp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|newp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|newlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* all sysctl names are this level are terminal */
if|if
condition|(
name|namelen
operator|!=
literal|1
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
comment|/* overloaded */
switch|switch
condition|(
name|name
index|[
literal|0
index|]
condition|)
block|{
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * Send an interrupt to process.  */
end_comment

begin_function
name|void
name|sendsig
parameter_list|(
name|catcher
parameter_list|,
name|sig
parameter_list|,
name|mask
parameter_list|,
name|code
parameter_list|)
name|sig_t
name|catcher
decl_stmt|;
name|int
name|sig
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|code
decl_stmt|;
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
specifier|register
name|struct
name|sigacts
modifier|*
name|psp
init|=
name|p
operator|->
name|p_sigacts
decl_stmt|;
specifier|register
name|struct
name|sigframe
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|trapframe
modifier|*
name|tf
decl_stmt|;
specifier|register
name|int
name|addr
decl_stmt|,
name|oonstack
decl_stmt|,
name|oldsp
decl_stmt|,
name|newsp
decl_stmt|;
name|struct
name|sigframe
name|sf
decl_stmt|;
specifier|extern
name|char
name|sigcode
index|[]
decl_stmt|,
name|esigcode
index|[]
decl_stmt|;
define|#
directive|define
name|szsigcode
value|(esigcode - sigcode)
name|tf
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_tf
expr_stmt|;
name|oldsp
operator|=
name|tf
operator|->
name|tf_out
index|[
literal|6
index|]
expr_stmt|;
name|oonstack
operator|=
name|psp
operator|->
name|ps_sigstk
operator|.
name|ss_flags
operator|&
name|SA_ONSTACK
expr_stmt|;
comment|/* 	 * Compute new user stack addresses, subtract off 	 * one signal frame, and align. 	 */
if|if
condition|(
operator|(
name|psp
operator|->
name|ps_flags
operator|&
name|SAS_ALTSTACK
operator|)
operator|&&
operator|!
name|oonstack
operator|&&
operator|(
name|psp
operator|->
name|ps_sigonstack
operator|&
name|sigmask
argument_list|(
name|sig
argument_list|)
operator|)
condition|)
block|{
name|fp
operator|=
operator|(
expr|struct
name|sigframe
operator|*
operator|)
operator|(
name|psp
operator|->
name|ps_sigstk
operator|.
name|ss_base
operator|+
name|psp
operator|->
name|ps_sigstk
operator|.
name|ss_size
operator|)
expr_stmt|;
name|psp
operator|->
name|ps_sigstk
operator|.
name|ss_flags
operator||=
name|SA_ONSTACK
expr_stmt|;
block|}
else|else
name|fp
operator|=
operator|(
expr|struct
name|sigframe
operator|*
operator|)
name|oldsp
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|sigframe
operator|*
operator|)
operator|(
call|(
name|int
call|)
argument_list|(
name|fp
operator|-
literal|1
argument_list|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|sigdebug
operator|&
name|SDB_KSTACK
operator|)
operator|&&
name|p
operator|->
name|p_pid
operator|==
name|sigpid
condition|)
name|printf
argument_list|(
literal|"sendsig: %s[%d] sig %d newusp %x scp %x\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|sig
argument_list|,
name|fp
argument_list|,
operator|&
name|fp
operator|->
name|sf_sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  	 * Now set up the signal frame.  We build it in kernel space 	 * and then copy it out.  We probably ought to just build it 	 * directly in user space.... 	 */
name|sf
operator|.
name|sf_signo
operator|=
name|sig
expr_stmt|;
name|sf
operator|.
name|sf_code
operator|=
name|code
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_SUNOS
name|sf
operator|.
name|sf_scp
operator|=
operator|&
name|fp
operator|->
name|sf_sc
expr_stmt|;
endif|#
directive|endif
name|sf
operator|.
name|sf_addr
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
comment|/* 	 * Build the signal context to be used by sigreturn. 	 */
name|sf
operator|.
name|sf_sc
operator|.
name|sc_onstack
operator|=
name|oonstack
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|sc_mask
operator|=
name|mask
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|sc_sp
operator|=
name|oldsp
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|sc_pc
operator|=
name|tf
operator|->
name|tf_pc
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|sc_npc
operator|=
name|tf
operator|->
name|tf_npc
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|sc_psr
operator|=
name|tf
operator|->
name|tf_psr
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|sc_g1
operator|=
name|tf
operator|->
name|tf_global
index|[
literal|1
index|]
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|sc_o0
operator|=
name|tf
operator|->
name|tf_out
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Put the stack in a consistent state before we whack away 	 * at it.  Note that write_user_windows may just dump the 	 * registers into the pcb; we need them in the process's memory. 	 * We also need to make sure that when we start the signal handler, 	 * its %i6 (%fp), which is loaded from the newly allocated stack area, 	 * joins seamlessly with the frame it was in when the signal occurred, 	 * so that the debugger and _longjmp code can back up through it. 	 */
name|newsp
operator|=
operator|(
name|int
operator|)
name|fp
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rwindow
argument_list|)
expr_stmt|;
name|write_user_windows
argument_list|()
expr_stmt|;
if|if
condition|(
name|rwindow_save
argument_list|(
name|p
argument_list|)
operator|||
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sf
argument_list|,
operator|(
name|caddr_t
operator|)
name|fp
argument_list|,
sizeof|sizeof
name|sf
argument_list|)
operator|||
name|suword
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|rwindow
operator|*
operator|)
name|newsp
operator|)
operator|->
name|rw_in
index|[
literal|6
index|]
argument_list|,
name|oldsp
argument_list|)
condition|)
block|{
comment|/* 		 * Process has trashed its stack; give it an illegal 		 * instruction to halt it in its tracks. 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|sigdebug
operator|&
name|SDB_KSTACK
operator|)
operator|&&
name|p
operator|->
name|p_pid
operator|==
name|sigpid
condition|)
name|printf
argument_list|(
literal|"sendsig: window save or copyout error\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigexit
argument_list|(
name|p
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sigdebug
operator|&
name|SDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"sendsig: %s[%d] sig %d scp %x\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|sig
argument_list|,
operator|&
name|fp
operator|->
name|sf_sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Arrange to continue execution at the code copied out in exec(). 	 * It needs the function to call in %g1, and a new stack pointer. 	 */
ifdef|#
directive|ifdef
name|COMPAT_SUNOS
if|if
condition|(
name|psp
operator|->
name|ps_usertramp
operator|&
name|sigmask
argument_list|(
name|sig
argument_list|)
condition|)
block|{
name|addr
operator|=
operator|(
name|int
operator|)
name|catcher
expr_stmt|;
comment|/* user does his own trampolining */
block|}
else|else
endif|#
directive|endif
block|{
name|addr
operator|=
name|USRSTACK
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ps_strings
argument_list|)
operator|-
name|szsigcode
expr_stmt|;
name|tf
operator|->
name|tf_global
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|catcher
expr_stmt|;
block|}
name|tf
operator|->
name|tf_pc
operator|=
name|addr
expr_stmt|;
name|tf
operator|->
name|tf_npc
operator|=
name|addr
operator|+
literal|4
expr_stmt|;
name|tf
operator|->
name|tf_out
index|[
literal|6
index|]
operator|=
name|newsp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|sigdebug
operator|&
name|SDB_KSTACK
operator|)
operator|&&
name|p
operator|->
name|p_pid
operator|==
name|sigpid
condition|)
name|printf
argument_list|(
literal|"sendsig: about to return to catcher\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * System call to cleanup state after a signal  * has been taken.  Reset signal mask and  * stack state from context left by sendsig (above),  * and return to the given trap frame (if there is one).  * Check carefully to make sure that the user has not  * modified the state to gain improper privileges or to cause  * a machine fault.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_struct
struct|struct
name|sigreturn_args
block|{
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|sigreturn
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|sigreturn_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
specifier|register
name|struct
name|trapframe
modifier|*
name|tf
decl_stmt|;
comment|/* First ensure consistent stack state (see sendsig). */
name|write_user_windows
argument_list|()
expr_stmt|;
if|if
condition|(
name|rwindow_save
argument_list|(
name|p
argument_list|)
condition|)
name|sigexit
argument_list|(
name|p
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sigdebug
operator|&
name|SDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"sigreturn: %s[%d], scp %x\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|uap
operator|->
name|scp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|=
name|uap
operator|->
name|scp
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|scp
operator|&
literal|3
operator|||
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|scp
argument_list|,
sizeof|sizeof
expr|*
name|scp
argument_list|,
name|B_WRITE
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tf
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_tf
expr_stmt|;
comment|/* 	 * Only the icc bits in the psr are used, so it need not be 	 * verified.  pc and npc must be multiples of 4.  This is all 	 * that is required; if it holds, just do it. 	 */
if|if
condition|(
operator|(
operator|(
name|scp
operator|->
name|sc_pc
operator||
name|scp
operator|->
name|sc_npc
operator|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* take only psr ICC field */
name|tf
operator|->
name|tf_psr
operator|=
operator|(
name|tf
operator|->
name|tf_psr
operator|&
operator|~
name|PSR_ICC
operator|)
operator||
operator|(
name|scp
operator|->
name|sc_psr
operator|&
name|PSR_ICC
operator|)
expr_stmt|;
name|tf
operator|->
name|tf_pc
operator|=
name|scp
operator|->
name|sc_pc
expr_stmt|;
name|tf
operator|->
name|tf_npc
operator|=
name|scp
operator|->
name|sc_npc
expr_stmt|;
name|tf
operator|->
name|tf_global
index|[
literal|1
index|]
operator|=
name|scp
operator|->
name|sc_g1
expr_stmt|;
name|tf
operator|->
name|tf_out
index|[
literal|0
index|]
operator|=
name|scp
operator|->
name|sc_o0
expr_stmt|;
name|tf
operator|->
name|tf_out
index|[
literal|6
index|]
operator|=
name|scp
operator|->
name|sc_sp
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|sc_onstack
operator|&
literal|1
condition|)
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigstk
operator|.
name|ss_flags
operator||=
name|SA_ONSTACK
expr_stmt|;
else|else
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigstk
operator|.
name|ss_flags
operator|&=
operator|~
name|SA_ONSTACK
expr_stmt|;
name|p
operator|->
name|p_sigmask
operator|=
name|scp
operator|->
name|sc_mask
operator|&
operator|~
name|sigcantmask
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|waittime
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|boot
argument_list|(
name|howto
argument_list|)
specifier|register
name|int
name|howto
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|str
index|[
literal|4
index|]
decl_stmt|;
comment|/* room for "-sd\0" */
specifier|extern
specifier|volatile
name|void
name|romhalt
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
specifier|volatile
name|void
name|romboot
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
name|fb_unblank
argument_list|()
expr_stmt|;
name|boothowto
operator|=
name|howto
expr_stmt|;
if|if
condition|(
operator|(
name|howto
operator|&
name|RB_NOSYNC
operator|)
operator|==
literal|0
operator|&&
name|waittime
operator|<
literal|0
condition|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|iter
decl_stmt|,
name|nbusy
decl_stmt|;
if|#
directive|if
literal|1
specifier|extern
name|struct
name|proc
name|proc0
decl_stmt|;
comment|/* protect against curproc->p_stats.foo refs in sync()   XXX */
if|if
condition|(
name|curproc
operator|==
name|NULL
condition|)
name|curproc
operator|=
operator|&
name|proc0
expr_stmt|;
endif|#
directive|endif
name|waittime
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"syncing disks... "
argument_list|)
expr_stmt|;
comment|/* 		 * Release vnodes held by texts before sync. 		 */
if|if
condition|(
name|panicstr
operator|==
literal|0
condition|)
name|vnode_pager_umount
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sync
argument_list|(
operator|&
name|proc0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
literal|0
init|;
name|iter
operator|<
literal|20
condition|;
name|iter
operator|++
control|)
block|{
name|nbusy
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bp
operator|=
operator|&
name|buf
index|[
name|nbuf
index|]
init|;
operator|--
name|bp
operator|>=
name|buf
condition|;
control|)
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_BUSY
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_BUSY
condition|)
name|nbusy
operator|++
expr_stmt|;
if|if
condition|(
name|nbusy
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|nbusy
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
operator|*
name|iter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbusy
condition|)
name|printf
argument_list|(
literal|"giving up\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
comment|/* 		 * If we've been adjusting the clock, the todr 		 * will be out of synch; adjust it now. 		 */
name|resettodr
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splhigh
argument_list|()
expr_stmt|;
comment|/* ??? */
if|if
condition|(
name|howto
operator|&
name|RB_HALT
condition|)
block|{
name|printf
argument_list|(
literal|"halted\n\n"
argument_list|)
expr_stmt|;
name|romhalt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|howto
operator|&
name|RB_DUMP
condition|)
name|dumpsys
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"rebooting\n\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|howto
operator|&
name|RB_SINGLE
condition|)
name|str
index|[
name|i
operator|++
index|]
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|howto
operator|&
name|RB_KDB
condition|)
name|str
index|[
name|i
operator|++
index|]
operator|=
literal|'d'
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|str
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|str
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|str
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|romboot
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_block

begin_decl_stmt
name|int
name|dumpmag
init|=
literal|0x8fca0101
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* magic number for savecore */
end_comment

begin_decl_stmt
name|int
name|dumpsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* also for savecore */
end_comment

begin_decl_stmt
name|long
name|dumplo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|dumpconf
argument_list|()
end_macro

begin_block
block|{
name|int
name|nblks
decl_stmt|;
name|dumpsize
operator|=
name|physmem
expr_stmt|;
define|#
directive|define
name|DUMPMMU
ifdef|#
directive|ifdef
name|DUMPMMU
define|#
directive|define
name|NPMEG
value|128
comment|/* 	 * savecore views the image in units of pages (i.e., dumpsize is in 	 * pages) so we round the two mmu entities into page-sized chunks. 	 * The PMEGs (32kB) and the segment table (512 bytes plus padding) 	 * are appending to the end of the crash dump. 	 */
name|dumpsize
operator|+=
name|btoc
argument_list|(
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|kpmap
operator|*
operator|)
literal|0
operator|)
operator|->
name|pm_rsegmap
argument_list|)
argument_list|)
operator|+
name|btoc
argument_list|(
name|NPMEG
operator|*
name|NPTESG
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dumpdev
operator|!=
name|NODEV
operator|&&
name|bdevsw
index|[
name|major
argument_list|(
name|dumpdev
argument_list|)
index|]
operator|.
name|d_psize
condition|)
block|{
name|nblks
operator|=
operator|(
operator|*
name|bdevsw
index|[
name|major
argument_list|(
name|dumpdev
argument_list|)
index|]
operator|.
name|d_psize
operator|)
operator|(
name|dumpdev
operator|)
expr_stmt|;
comment|/* 		 * Don't dump on the first CLBYTES (why CLBYTES?) 		 * in case the dump device includes a disk label. 		 */
if|if
condition|(
name|dumplo
operator|<
name|btodb
argument_list|(
name|CLBYTES
argument_list|)
condition|)
name|dumplo
operator|=
name|btodb
argument_list|(
name|CLBYTES
argument_list|)
expr_stmt|;
comment|/* 		 * If dumpsize is too big for the partition, truncate it. 		 * Otherwise, put the dump at the end of the partition 		 * by making dumplo as large as possible. 		 */
if|if
condition|(
name|dumpsize
operator|>
name|btoc
argument_list|(
name|dbtob
argument_list|(
name|nblks
operator|-
name|dumplo
argument_list|)
argument_list|)
condition|)
name|dumpsize
operator|=
name|btoc
argument_list|(
name|dbtob
argument_list|(
name|nblks
operator|-
name|dumplo
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dumplo
operator|+
name|ctod
argument_list|(
name|dumpsize
argument_list|)
operator|>
name|nblks
condition|)
name|dumplo
operator|=
name|nblks
operator|-
name|ctod
argument_list|(
name|dumpsize
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DUMPMMU
end_ifdef

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<machine/ctlreg.h>
end_include

begin_define
define|#
directive|define
name|getpte
parameter_list|(
name|va
parameter_list|)
value|lda(va, ASI_PTE)
end_define

begin_define
define|#
directive|define
name|setsegmap
parameter_list|(
name|va
parameter_list|,
name|pmeg
parameter_list|)
value|stba(va, ASI_SEGMAP, pmeg)
end_define

begin_comment
comment|/*  * Write the mmu contents to the dump device.  * This gets appended to the end of a crash dump since  * there is no in-core copy of kernel memory mappings.  */
end_comment

begin_function
name|int
name|dumpmmu
parameter_list|(
name|blkno
parameter_list|)
specifier|register
name|daddr_t
name|blkno
decl_stmt|;
block|{
specifier|register
name|int
function_decl|(
modifier|*
name|dump
function_decl|)
parameter_list|(
comment|/*dev_t, daddr_t, caddr_t, int*/
parameter_list|)
function_decl|;
specifier|register
name|int
name|pmeg
decl_stmt|;
specifier|register
name|int
name|addr
decl_stmt|;
comment|/* unused kernel virtual address */
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
modifier|*
name|pte
decl_stmt|,
modifier|*
name|ptend
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
specifier|register
name|struct
name|kpmap
modifier|*
name|kpmap
init|=
operator|&
name|kernel_pmap_store
decl_stmt|;
name|int
name|buffer
index|[
name|dbtob
argument_list|(
literal|1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
specifier|extern
name|int
name|seginval
decl_stmt|;
comment|/* from pmap.c */
name|dump
operator|=
name|bdevsw
index|[
name|major
argument_list|(
name|dumpdev
argument_list|)
index|]
operator|.
name|d_dump
expr_stmt|;
comment|/* 	 * dump page table entries 	 * 	 * We dump each pmeg in order (by segment number).  Since the MMU 	 * automatically maps the given virtual segment to a pmeg we must 	 * iterate over the segments by incrementing an unused segment slot 	 * in the MMU.  This fixed segment number is used in the virtual 	 * address argument to getpte(). 	 */
comment|/* First find an unused virtual segment. */
name|i
operator|=
name|NKSEG
expr_stmt|;
while|while
condition|(
name|kpmap
operator|->
name|pm_rsegmap
index|[
operator|--
name|i
index|]
operator|!=
name|seginval
condition|)
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Compute the base address corresponding to the unused segment. 	 * Note that the kernel segments start after all the user segments 	 * so we must account for this offset. 	 */
name|addr
operator|=
name|VSTOVA
argument_list|(
name|i
operator|+
name|NUSEG
argument_list|)
expr_stmt|;
comment|/* 	 * Go through the pmegs and dump each one. 	 */
name|pte
operator|=
name|buffer
expr_stmt|;
name|ptend
operator|=
operator|&
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|pmeg
operator|=
literal|0
init|;
name|pmeg
operator|<
name|NPMEG
condition|;
operator|++
name|pmeg
control|)
block|{
specifier|register
name|int
name|va
init|=
name|addr
decl_stmt|;
name|setsegmap
argument_list|(
name|addr
argument_list|,
name|pmeg
argument_list|)
expr_stmt|;
name|i
operator|=
name|NPTESG
expr_stmt|;
do|do
block|{
operator|*
name|pte
operator|++
operator|=
name|getpte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|>=
name|ptend
condition|)
block|{
comment|/* 				 * Note that we'll dump the last block 				 * the last time through the loops because 				 * all the PMEGs occupy 32KB which is  				 * a multiple of the block size. 				 */
name|error
operator|=
call|(
modifier|*
name|dump
call|)
argument_list|(
name|dumpdev
argument_list|,
name|blkno
argument_list|,
operator|(
name|caddr_t
operator|)
name|buffer
argument_list|,
name|dbtob
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|++
name|blkno
expr_stmt|;
name|pte
operator|=
name|buffer
expr_stmt|;
block|}
name|va
operator|+=
name|NBPG
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
block|}
name|setsegmap
argument_list|(
name|addr
argument_list|,
name|seginval
argument_list|)
expr_stmt|;
comment|/* 	 * dump (512 byte) segment map  	 * XXX assume it's a multiple of the block size 	 */
name|error
operator|=
call|(
modifier|*
name|dump
call|)
argument_list|(
name|dumpdev
argument_list|,
name|blkno
argument_list|,
operator|(
name|caddr_t
operator|)
name|kpmap
operator|->
name|pm_rsegmap
argument_list|,
sizeof|sizeof
argument_list|(
name|kpmap
operator|->
name|pm_rsegmap
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BYTES_PER_DUMP
value|(32 * 1024)
end_define

begin_comment
comment|/* must be a multiple of pagesize */
end_comment

begin_decl_stmt
specifier|static
name|vm_offset_t
name|dumpspace
decl_stmt|;
end_decl_stmt

begin_function
name|caddr_t
name|reserve_dumppages
parameter_list|(
name|p
parameter_list|)
name|caddr_t
name|p
decl_stmt|;
block|{
name|dumpspace
operator|=
operator|(
name|vm_offset_t
operator|)
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|+
name|BYTES_PER_DUMP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write a crash dump.  */
end_comment

begin_macro
name|dumpsys
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|unsigned
name|bytes
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|int
name|maddr
decl_stmt|,
name|psize
decl_stmt|;
specifier|register
name|daddr_t
name|blkno
decl_stmt|;
specifier|register
name|int
function_decl|(
modifier|*
name|dump
function_decl|)
parameter_list|(
comment|/*dev_t, daddr_t, caddr_t, int, int*/
parameter_list|)
function_decl|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dumpdev
operator|==
name|NODEV
condition|)
return|return;
comment|/* copy registers to memory */
name|snapshot
argument_list|(
name|cpcb
argument_list|)
expr_stmt|;
comment|/* 	 * For dumps during autoconfiguration, 	 * if dump device has already configured... 	 */
if|if
condition|(
name|dumpsize
operator|==
literal|0
condition|)
name|dumpconf
argument_list|()
expr_stmt|;
if|if
condition|(
name|dumplo
operator|<
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"\ndumping to dev %x, offset %d\n"
argument_list|,
name|dumpdev
argument_list|,
name|dumplo
argument_list|)
expr_stmt|;
name|psize
operator|=
operator|(
operator|*
name|bdevsw
index|[
name|major
argument_list|(
name|dumpdev
argument_list|)
index|]
operator|.
name|d_psize
operator|)
operator|(
name|dumpdev
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"dump "
argument_list|)
expr_stmt|;
if|if
condition|(
name|psize
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"area unavailable\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bytes
operator|=
name|physmem
operator|<<
name|PGSHIFT
expr_stmt|;
name|maddr
operator|=
literal|0
expr_stmt|;
name|blkno
operator|=
name|dumplo
expr_stmt|;
name|dump
operator|=
name|bdevsw
index|[
name|major
argument_list|(
name|dumpdev
argument_list|)
index|]
operator|.
name|d_dump
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bytes
condition|;
name|i
operator|+=
name|n
control|)
block|{
name|n
operator|=
name|bytes
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|BYTES_PER_DUMP
condition|)
name|n
operator|=
name|BYTES_PER_DUMP
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* print out how many MBs we have dumped */
if|if
condition|(
name|i
operator|&&
operator|(
name|i
operator|%
operator|(
literal|1024
operator|*
literal|1024
operator|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|i
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|pmap_map
argument_list|(
name|dumpspace
argument_list|,
name|maddr
argument_list|,
name|maddr
operator|+
name|n
argument_list|,
name|VM_PROT_READ
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|dump
call|)
argument_list|(
name|dumpdev
argument_list|,
name|blkno
argument_list|,
operator|(
name|caddr_t
operator|)
name|dumpspace
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|maddr
operator|+=
name|n
expr_stmt|;
name|blkno
operator|+=
name|btodb
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DUMPMMU
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|dumpmmu
argument_list|(
name|blkno
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|ENXIO
case|:
name|printf
argument_list|(
literal|"device bad\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFAULT
case|:
name|printf
argument_list|(
literal|"device not ready\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
name|printf
argument_list|(
literal|"area improper\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EIO
case|:
name|printf
argument_list|(
literal|"i/o error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"succeeded\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * Map an I/O device given physical address and size in bytes, e.g.,  *  *	mydev = (struct mydev *)mapdev(myioaddr, 0, sizeof(struct mydev));  *  * See also machine/autoconf.h.  */
end_comment

begin_function
name|void
modifier|*
name|mapdev
parameter_list|(
name|phys
parameter_list|,
name|virt
parameter_list|,
name|size
parameter_list|)
specifier|register
name|void
modifier|*
name|phys
decl_stmt|;
specifier|register
name|int
name|virt
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|v
decl_stmt|;
specifier|register
name|void
modifier|*
name|ret
decl_stmt|;
specifier|static
name|vm_offset_t
name|iobase
init|=
name|IODEV_BASE
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|virt
condition|)
name|v
operator|=
name|trunc_page
argument_list|(
name|virt
argument_list|)
expr_stmt|;
else|else
block|{
name|v
operator|=
name|iobase
expr_stmt|;
name|iobase
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|iobase
operator|>
name|IODEV_END
condition|)
comment|/* unlikely */
name|panic
argument_list|(
literal|"mapiodev"
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
name|v
expr_stmt|;
name|phys
operator|=
operator|(
name|void
operator|*
operator|)
name|trunc_page
argument_list|(
name|phys
argument_list|)
expr_stmt|;
do|do
block|{
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|v
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|phys
operator||
name|PMAP_OBIO
operator||
name|PMAP_NC
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|v
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|phys
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|size
operator|-=
name|PAGE_SIZE
operator|)
operator|>
literal|0
condition|)
do|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

