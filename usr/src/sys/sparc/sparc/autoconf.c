begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratories.  *  * %sccs.include.redist.c%  *  *	@(#)autoconf.c	7.3 (Berkeley) %G%  *  * from: $Header: autoconf.c,v 1.23 92/07/10 22:35:23 torek Exp $ (LBL)  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/map.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bsd_openprom.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FS_NFS
end_ifndef

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|FS_NFS
value|100
end_define

begin_comment
comment|/* XXX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/*  * The following several variables are related to  * the configuration process, and are used in initializing  * the machine.  */
end_comment

begin_decl_stmt
name|int
name|cold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if 1, still working on cold-start */
end_comment

begin_decl_stmt
name|int
name|dkn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of iostat dk numbers assigned so far */
end_comment

begin_decl_stmt
name|int
name|cpuspeed
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* relative cpu speed */
end_comment

begin_decl_stmt
name|int
name|fbnode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* node ID of ROM's console frame buffer */
end_comment

begin_decl_stmt
name|int
name|optionsnode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* node ID of ROM's options */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|promvec
modifier|*
name|promvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rootnode
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|findroot
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bootinfo
modifier|*
name|findbootdev
parameter_list|()
function_decl|;
end_function_decl

begin_struct
specifier|static
struct|struct
name|bootinfo
block|{
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
comment|/* device name */
name|int
name|val
index|[
literal|3
index|]
decl_stmt|;
comment|/* up to 3 values */
name|int
name|type
decl_stmt|;
comment|/* FS type */
name|caddr_t
name|data
decl_stmt|;
comment|/* FS dependant info */
block|}
name|bootinfo
struct|;
end_struct

begin_comment
comment|/*  * Most configuration on the SPARC is done by matching OPENPROM Forth  * device names with our internal names.  */
end_comment

begin_function
name|int
name|matchbyname
parameter_list|(
name|parent
parameter_list|,
name|cf
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cf
decl_stmt|;
name|void
modifier|*
name|aux
decl_stmt|;
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|cf
operator|->
name|cf_driver
operator|->
name|cd_name
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|aux
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert hex ASCII string to a value.  Returns updated pointer.  * Depends on ASCII order (this *is* machine-dependent code, you know).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|str2hex
parameter_list|(
name|str
parameter_list|,
name|vp
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|int
modifier|*
name|vp
decl_stmt|;
block|{
specifier|register
name|int
name|v
decl_stmt|,
name|c
decl_stmt|;
for|for
control|(
name|v
operator|=
literal|0
init|;
condition|;
name|v
operator|=
name|v
operator|*
literal|16
operator|+
name|c
operator|,
name|str
operator|++
control|)
block|{
name|c
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|str
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|-=
literal|'0'
operator|)
operator|<
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|<=
literal|'F'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|-=
literal|'A'
operator|-
literal|10
operator|)
operator|<
literal|10
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|<=
literal|'f'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|-=
literal|'a'
operator|-
literal|10
operator|)
operator|<
literal|10
condition|)
break|break;
block|}
else|else
break|break;
block|}
operator|*
name|vp
operator|=
name|v
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * locore.s code calls bootstrap() just before calling main(), after double  * mapping the kernel to high memory and setting up the trap base register.  * We must finish mapping the kernel properly and glean any bootstrap info.  */
end_comment

begin_function
name|void
name|bootstrap
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|nmmu
decl_stmt|,
name|ncontext
decl_stmt|,
name|node
decl_stmt|;
ifdef|#
directive|ifdef
name|KGDB
specifier|extern
name|int
name|kgdb_debug_panic
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|char
modifier|*
name|rindex
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|node
operator|=
name|findroot
argument_list|()
expr_stmt|;
name|nmmu
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"mmu-npmg"
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|ncontext
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"mmu-nctx"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|pmap_bootstrap
argument_list|(
name|nmmu
argument_list|,
name|ncontext
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KGDB
name|zs_kgdb_init
argument_list|()
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
comment|/* 	 * On SS1s, promvec->pv_v0bootargs->ba_argv[1] contains the flags 	 * that were given after the boot command.  On SS2s, pv_v0bootargs 	 * is NULL but *promvec->pv_v2bootargs.v2_bootargs points to 	 * "vmunix -s" or whatever. 	 * ###	DO THIS BEFORE pmap_boostrap? 	 */
if|if
condition|(
name|promvec
operator|->
name|pv_romvec_vers
operator|<
literal|2
condition|)
block|{
comment|/* Grab boot device name and values. */
name|cp
operator|=
operator|(
operator|*
name|promvec
operator|->
name|pv_v0bootargs
operator|)
operator|->
name|ba_argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|=
name|bootinfo
operator|.
name|name
expr_stmt|;
name|ep
operator|=
operator|&
name|bootinfo
operator|.
name|name
index|[
sizeof|sizeof
argument_list|(
name|bootinfo
operator|.
name|name
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'('
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|bp
operator|<
name|ep
operator|-
literal|1
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|&&
operator|*
operator|(
name|cp
operator|=
name|str2hex
argument_list|(
operator|++
name|cp
argument_list|,
operator|&
name|bootinfo
operator|.
name|val
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
literal|','
operator|&&
operator|*
operator|(
name|cp
operator|=
name|str2hex
argument_list|(
operator|++
name|cp
argument_list|,
operator|&
name|bootinfo
operator|.
name|val
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
literal|','
condition|)
operator|(
name|void
operator|)
name|str2hex
argument_list|(
operator|++
name|cp
argument_list|,
operator|&
name|bootinfo
operator|.
name|val
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Setup pointer to boot flags */
name|cp
operator|=
operator|(
operator|*
name|promvec
operator|->
name|pv_v0bootargs
operator|)
operator|->
name|ba_argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|!=
literal|'-'
condition|)
return|return;
block|}
else|else
block|{
comment|/* Grab boot device name and values. */
name|cp
operator|=
operator|*
name|promvec
operator|->
name|pv_v2bootargs
operator|.
name|v2_bootpath
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
operator|&&
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|++
name|cp
expr_stmt|;
name|bp
operator|=
name|bootinfo
operator|.
name|name
expr_stmt|;
name|ep
operator|=
operator|&
name|bootinfo
operator|.
name|name
index|[
sizeof|sizeof
argument_list|(
name|bootinfo
operator|.
name|name
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'@'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|bp
operator|<
name|ep
operator|-
literal|1
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'@'
operator|&&
operator|*
operator|(
name|cp
operator|=
name|str2hex
argument_list|(
operator|++
name|cp
argument_list|,
operator|&
name|bootinfo
operator|.
name|val
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
literal|','
operator|&&
operator|*
operator|(
name|cp
operator|=
name|str2hex
argument_list|(
operator|++
name|cp
argument_list|,
operator|&
name|bootinfo
operator|.
name|val
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
literal|','
condition|)
operator|(
name|void
operator|)
name|str2hex
argument_list|(
operator|++
name|cp
argument_list|,
operator|&
name|bootinfo
operator|.
name|val
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Setup pointer to boot flags */
name|cp
operator|=
operator|*
name|promvec
operator|->
name|pv_v2bootargs
operator|.
name|v2_bootargs
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'-'
condition|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'\0'
condition|)
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
case|case
literal|'\0'
case|:
return|return;
case|case
literal|'a'
case|:
name|boothowto
operator||=
name|RB_ASKNAME
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|boothowto
operator||=
name|RB_DFLTROOT
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* kgdb - always on zs	XXX */
ifdef|#
directive|ifdef
name|KGDB
name|boothowto
operator||=
name|RB_KDB
expr_stmt|;
comment|/* XXX unused */
name|kgdb_debug_panic
operator|=
literal|1
expr_stmt|;
name|kgdb_connect
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"kernel not compiled with KGDB\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'s'
case|:
name|boothowto
operator||=
name|RB_SINGLE
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Determine mass storage and memory configuration for a machine.  * We get the PROM's root device and make sure we understand it, then  * attach it as `mainbus0'.  We also set up to handle the PROM `sync'  * command.  */
end_comment

begin_macro
name|configure
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|node
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|romaux
name|ra
decl_stmt|;
name|void
name|sync_crash
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|NFS
specifier|register
name|struct
name|bootinfo
modifier|*
name|bi
decl_stmt|;
specifier|extern
name|int
argument_list|(
operator|*
name|mountroot
argument_list|)
argument_list|()
decl_stmt|,
name|nfs_mountroot
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|node
operator|=
name|findroot
argument_list|()
expr_stmt|;
name|cp
operator|=
name|getpropstring
argument_list|(
name|node
argument_list|,
literal|"device_type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"cpu"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"PROM root device type = %s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"need CPU as root"
argument_list|)
expr_stmt|;
block|}
operator|*
name|promvec
operator|->
name|pv_synchook
operator|=
name|sync_crash
expr_stmt|;
name|ra
operator|.
name|ra_node
operator|=
name|node
expr_stmt|;
name|ra
operator|.
name|ra_name
operator|=
name|cp
operator|=
literal|"mainbus"
expr_stmt|;
if|if
condition|(
operator|!
name|config_rootfound
argument_list|(
name|cp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ra
argument_list|)
condition|)
name|panic
argument_list|(
literal|"mainbus not configured"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
name|cold
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NFS
if|if
condition|(
name|boothowto
operator|&
name|RB_ASKNAME
condition|)
block|{
name|char
name|ans
index|[
literal|100
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"nfs root? (y/n) [n] "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|ans
argument_list|)
expr_stmt|;
if|if
condition|(
name|ans
index|[
literal|0
index|]
operator|==
literal|'y'
condition|)
name|mountroot
operator|=
name|nfs_mountroot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bi
operator|=
name|findbootdev
argument_list|()
operator|)
operator|!=
name|NULL
operator|&&
name|bi
operator|->
name|type
operator|==
name|FS_NFS
condition|)
block|{
name|mountroot
operator|=
name|nfs_mountroot
expr_stmt|;
ifdef|#
directive|ifdef
name|LBL
name|lbl_diskless_setup
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* LBL */
block|}
endif|#
directive|endif
comment|/* NFS */
if|#
directive|if
name|GENERIC
if|if
condition|(
operator|(
name|boothowto
operator|&
name|RB_ASKNAME
operator|)
operator|==
literal|0
condition|)
name|setroot
argument_list|()
expr_stmt|;
name|setconf
argument_list|()
expr_stmt|;
else|#
directive|else
name|setroot
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|swapconf
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Console `sync' command.  SunOS just does a `panic: zero' so I guess  * no one really wants anything fancy...  */
end_comment

begin_function
name|void
name|sync_crash
parameter_list|()
block|{
name|panic
argument_list|(
literal|"PROM sync command"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|clockfreq
parameter_list|(
name|freq
parameter_list|)
specifier|register
name|int
name|freq
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|freq
operator|/=
literal|1000
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|freq
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|freq
operator|%=
literal|1000
expr_stmt|;
if|if
condition|(
name|freq
condition|)
block|{
name|freq
operator|+=
literal|1000
expr_stmt|;
comment|/* now in 1000..1999 */
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
name|freq
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
comment|/* now buf = %d.%3d */
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|mbprint
parameter_list|(
name|aux
parameter_list|,
name|name
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|romaux
modifier|*
name|ra
init|=
name|aux
decl_stmt|;
if|if
condition|(
name|name
condition|)
name|printf
argument_list|(
literal|"%s at %s"
argument_list|,
name|ra
operator|->
name|ra_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ra
operator|->
name|ra_paddr
condition|)
name|printf
argument_list|(
literal|" %saddr 0x%x"
argument_list|,
name|ra
operator|->
name|ra_iospace
condition|?
literal|"io"
else|:
literal|""
argument_list|,
operator|(
name|int
operator|)
name|ra
operator|->
name|ra_paddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|UNCONF
operator|)
return|;
block|}
end_function

begin_function
name|int
name|findroot
parameter_list|()
block|{
specifier|register
name|int
name|node
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|=
name|rootnode
operator|)
operator|==
literal|0
operator|&&
operator|(
name|node
operator|=
name|nextsibling
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no PROM root device"
argument_list|)
expr_stmt|;
name|rootnode
operator|=
name|node
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a `first child' node number, locate the node with the given name.  * Return the node number, or 0 if not found.  */
end_comment

begin_function
name|int
name|findnode
parameter_list|(
name|first
parameter_list|,
name|name
parameter_list|)
name|int
name|first
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|first
init|;
name|node
condition|;
name|node
operator|=
name|nextsibling
argument_list|(
name|node
argument_list|)
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|getpropstring
argument_list|(
name|node
argument_list|,
literal|"name"
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|node
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in a romaux.  Returns 1 on success, 0 if the register property  * was not the right size.  */
end_comment

begin_function
name|int
name|romprop
parameter_list|(
name|rp
parameter_list|,
name|cp
parameter_list|,
name|node
parameter_list|)
specifier|register
name|struct
name|romaux
modifier|*
name|rp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|node
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
union|union
block|{
name|char
name|regbuf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|ireg
index|[
literal|3
index|]
decl_stmt|;
block|}
name|u
union|;
specifier|static
specifier|const
name|char
name|pl
index|[]
init|=
literal|"property length"
decl_stmt|;
name|len
operator|=
name|getprop
argument_list|(
name|node
argument_list|,
literal|"reg"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|u
operator|.
name|regbuf
argument_list|,
sizeof|sizeof
name|u
operator|.
name|regbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|12
condition|)
block|{
name|printf
argument_list|(
literal|"%s \"reg\" %s = %d (need 12)\n"
argument_list|,
name|cp
argument_list|,
name|pl
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|>
literal|12
condition|)
name|printf
argument_list|(
literal|"warning: %s \"reg\" %s %d> 12, excess ignored\n"
argument_list|,
name|cp
argument_list|,
name|pl
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rp
operator|->
name|ra_node
operator|=
name|node
expr_stmt|;
name|rp
operator|->
name|ra_name
operator|=
name|cp
expr_stmt|;
name|rp
operator|->
name|ra_iospace
operator|=
name|u
operator|.
name|ireg
index|[
literal|0
index|]
expr_stmt|;
name|rp
operator|->
name|ra_paddr
operator|=
operator|(
name|caddr_t
operator|)
name|u
operator|.
name|ireg
index|[
literal|1
index|]
expr_stmt|;
name|rp
operator|->
name|ra_len
operator|=
name|u
operator|.
name|ireg
index|[
literal|2
index|]
expr_stmt|;
name|rp
operator|->
name|ra_vaddr
operator|=
operator|(
name|caddr_t
operator|)
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"address"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|getprop
argument_list|(
name|node
argument_list|,
literal|"intr"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|rp
operator|->
name|ra_intr
argument_list|,
sizeof|sizeof
name|rp
operator|->
name|ra_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"%s \"intr\" %s = %d (need multiple of 8)\n"
argument_list|,
name|cp
argument_list|,
name|pl
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|rp
operator|->
name|ra_nintr
operator|=
name|len
operator|>>=
literal|3
expr_stmt|;
comment|/* SPARCstation interrupts are not hardware-vectored */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|ra_intr
index|[
name|len
index|]
operator|.
name|int_vec
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: %s interrupt %d has nonzero vector\n"
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach the mainbus.  *  * Our main job is to attach the CPU (the root node we got in configure())  * and iterate down the list of `mainbus devices' (children of that node).  * We also record the `node id' of the default frame buffer, if any.  */
end_comment

begin_function
specifier|static
name|void
name|mainbus_attach
parameter_list|(
name|parent
parameter_list|,
name|dev
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|,
decl|*
name|dev
decl_stmt|;
end_function

begin_decl_stmt
name|void
modifier|*
name|aux
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|node0
decl_stmt|,
name|node
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
decl_stmt|const
modifier|*
name|ssp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
define|#
directive|define
name|L1A_HACK
comment|/* XXX hack to allow L1-A during autoconf */
ifdef|#
directive|ifdef
name|L1A_HACK
name|int
name|nzs
init|=
literal|0
decl_stmt|,
name|audio
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|struct
name|romaux
name|ra
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|special
index|[]
init|=
block|{
comment|/* find these first (end with empty string) */
literal|"memory-error"
block|,
literal|"eeprom"
block|,
literal|"counter-timer"
block|,
literal|""
block|,
comment|/* ignore these (end with NULL) */
literal|"options"
block|,
literal|"packages"
block|,
literal|"openprom"
block|,
literal|"memory"
block|,
literal|"virtual-memory"
block|,
literal|"interrupt-enable"
block|,
name|NULL
block|}
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* configure the cpu */
name|node
operator|=
operator|(
operator|(
expr|struct
name|romaux
operator|*
operator|)
name|aux
operator|)
operator|->
name|ra_node
expr_stmt|;
name|ra
operator|.
name|ra_node
operator|=
name|node
expr_stmt|;
name|ra
operator|.
name|ra_name
operator|=
name|cp
operator|=
literal|"cpu"
expr_stmt|;
name|ra
operator|.
name|ra_paddr
operator|=
literal|0
expr_stmt|;
name|config_found
argument_list|(
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ra
argument_list|,
name|mbprint
argument_list|)
expr_stmt|;
comment|/* remember which frame buffer, if any, is to be /dev/fb */
name|fbnode
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"fb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Find the "options" node */
name|node0
operator|=
name|firstchild
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|optionsnode
operator|=
name|findnode
argument_list|(
name|node0
argument_list|,
literal|"options"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optionsnode
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no options in OPENPROM"
argument_list|)
expr_stmt|;
comment|/* 	 * Locate and configure the ``early'' devices.  These must be 	 * configured before we can do the rest.  For instance, the 	 * EEPROM contains the Ethernet address for the LANCE chip. 	 * If the device cannot be located or configured, panic. 	 */
for|for
control|(
name|ssp
operator|=
name|special
init|;
operator|*
operator|(
name|sp
operator|=
operator|*
name|ssp
operator|)
operator|!=
literal|0
condition|;
name|ssp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|node
operator|=
name|findnode
argument_list|(
name|node0
argument_list|,
name|sp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"could not find %s in OPENPROM\n"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|panic
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|romprop
argument_list|(
operator|&
name|ra
argument_list|,
name|sp
argument_list|,
name|node
argument_list|)
operator|||
operator|!
name|config_found
argument_list|(
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ra
argument_list|,
name|mbprint
argument_list|)
condition|)
name|panic
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Configure the rest of the devices, in PROM order.  Skip 	 * PROM entries that are not for devices, or which must be 	 * done before we get here. 	 */
for|for
control|(
name|node
operator|=
name|node0
init|;
name|node
condition|;
name|node
operator|=
name|nextsibling
argument_list|(
name|node
argument_list|)
control|)
block|{
name|cp
operator|=
name|getpropstring
argument_list|(
name|node
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
for|for
control|(
name|ssp
operator|=
name|special
init|;
operator|(
name|sp
operator|=
operator|*
name|ssp
operator|)
operator|!=
name|NULL
condition|;
name|ssp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|sp
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|sp
operator|==
name|NULL
operator|&&
name|romprop
argument_list|(
operator|&
name|ra
argument_list|,
name|cp
argument_list|,
name|node
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|L1A_HACK
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"audio"
argument_list|)
operator|==
literal|0
condition|)
name|audio
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"zs"
argument_list|)
operator|==
literal|0
condition|)
name|nzs
operator|++
expr_stmt|;
if|if
condition|(
name|audio
operator|&&
name|nzs
operator|>=
literal|2
condition|)
operator|(
name|void
operator|)
name|splx
argument_list|(
literal|11
operator|<<
literal|8
argument_list|)
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
operator|(
name|void
operator|)
name|config_found
argument_list|(
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ra
argument_list|,
name|mbprint
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
name|struct
name|cfdriver
name|mainbuscd
init|=
block|{
name|NULL
block|,
literal|"mainbus"
block|,
name|matchbyname
block|,
name|mainbus_attach
block|,
name|DV_DULL
block|,
expr|sizeof
operator|(
expr|struct
name|device
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * findzs() is called from the zs driver (which is, at least in theory,  * generic to any machine with a Zilog ZSCC chip).  It should return the  * address of the corresponding zs channel.  It may not fail, and it  * may be called before the VM code can be used.  Here we count on the  * FORTH PROM to map in the required zs chips.  */
end_comment

begin_function
name|void
modifier|*
name|findzs
parameter_list|(
name|zs
parameter_list|)
name|int
name|zs
decl_stmt|;
block|{
specifier|register
name|int
name|node
decl_stmt|,
name|addr
decl_stmt|;
name|node
operator|=
name|firstchild
argument_list|(
name|findroot
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|node
operator|=
name|findnode
argument_list|(
name|node
argument_list|,
literal|"zs"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"slave"
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|zs
condition|)
block|{
if|if
condition|(
operator|(
name|addr
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"address"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"findzs: zs%d not mapped by PROM"
argument_list|,
name|zs
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|addr
operator|)
return|;
block|}
name|node
operator|=
name|nextsibling
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"findzs: cannot find zs%d"
argument_list|,
name|zs
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|makememarr
parameter_list|(
name|ap
parameter_list|,
name|max
parameter_list|,
name|which
parameter_list|)
specifier|register
name|struct
name|memarr
modifier|*
name|ap
decl_stmt|;
name|int
name|max
decl_stmt|,
name|which
decl_stmt|;
block|{
struct|struct
name|v2rmi
block|{
name|int
name|zero
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
name|v2rmi
index|[
literal|200
index|]
struct|;
comment|/* version 2 rom meminfo layout */
define|#
directive|define
name|MAXMEMINFO
value|(sizeof(v2rmi) / sizeof(*v2rmi))
specifier|register
name|struct
name|v0mlist
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|node
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|prop
decl_stmt|;
switch|switch
condition|(
name|i
operator|=
name|promvec
operator|->
name|pv_romvec_vers
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * Version 0 PROMs use a linked list to describe these 		 * guys. 		 */
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|MEMARR_AVAILPHYS
case|:
name|mp
operator|=
operator|*
name|promvec
operator|->
name|pv_v0mem
operator|.
name|v0_physavail
expr_stmt|;
break|break;
case|case
name|MEMARR_TOTALPHYS
case|:
name|mp
operator|=
operator|*
name|promvec
operator|->
name|pv_v0mem
operator|.
name|v0_phystot
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"makememarr"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|max
condition|)
goto|goto
name|overflow
goto|;
name|ap
operator|->
name|addr
operator|=
operator|(
name|u_int
operator|)
name|mp
operator|->
name|addr
expr_stmt|;
name|ap
operator|->
name|len
operator|=
name|mp
operator|->
name|nbytes
expr_stmt|;
name|ap
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"makememarr: hope version %d PROM is like version 2\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
comment|/* 		 * Version 2 PROMs use a property array to describe them. 		 */
if|if
condition|(
name|max
operator|>
name|MAXMEMINFO
condition|)
block|{
name|printf
argument_list|(
literal|"makememarr: limited to %d\n"
argument_list|,
name|MAXMEMINFO
argument_list|)
expr_stmt|;
name|max
operator|=
name|MAXMEMINFO
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|node
operator|=
name|findnode
argument_list|(
name|firstchild
argument_list|(
name|findroot
argument_list|()
argument_list|)
argument_list|,
literal|"memory"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"makememarr: cannot find \"memory\" node"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|MEMARR_AVAILPHYS
case|:
name|prop
operator|=
literal|"available"
expr_stmt|;
break|break;
case|case
name|MEMARR_TOTALPHYS
case|:
name|prop
operator|=
literal|"reg"
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"makememarr"
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|getprop
argument_list|(
name|node
argument_list|,
name|prop
argument_list|,
operator|(
name|void
operator|*
operator|)
name|v2rmi
argument_list|,
sizeof|sizeof
name|v2rmi
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|v2rmi
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|max
condition|)
goto|goto
name|overflow
goto|;
name|ap
operator|->
name|addr
operator|=
name|v2rmi
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|ap
operator|->
name|len
operator|=
name|v2rmi
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|ap
operator|++
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	 * Success!  (Hooray) 	 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"makememarr: no memory found"
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
name|overflow
label|:
comment|/* 	 * Oops, there are more things in the PROM than our caller 	 * provided space for.  Truncate any extras. 	 */
name|printf
argument_list|(
literal|"makememarr: WARNING: lost some memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal form of getprop().  Returns the actual length.  */
end_comment

begin_function
name|int
name|getprop
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|buf
parameter_list|,
name|bufsiz
parameter_list|)
name|int
name|node
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|bufsiz
decl_stmt|;
block|{
specifier|register
name|struct
name|nodeops
modifier|*
name|no
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|no
operator|=
name|promvec
operator|->
name|pv_nodeops
expr_stmt|;
name|len
operator|=
name|no
operator|->
name|no_proplen
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|bufsiz
condition|)
block|{
name|printf
argument_list|(
literal|"node %x property %s length %d> %d\n"
argument_list|,
name|node
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|panic
argument_list|(
literal|"getprop"
argument_list|)
expr_stmt|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
name|no
operator|->
name|no_getprop
argument_list|(
name|node
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a string property.  There is a (small) limit on the length;  * the string is fetched into a static buffer which is overwritten on  * subsequent calls.  */
end_comment

begin_function
name|char
modifier|*
name|getpropstring
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|)
name|int
name|node
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|static
name|char
name|stringbuf
index|[
literal|32
index|]
decl_stmt|;
name|len
operator|=
name|getprop
argument_list|(
name|node
argument_list|,
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stringbuf
argument_list|,
sizeof|sizeof
name|stringbuf
operator|-
literal|1
argument_list|)
expr_stmt|;
name|stringbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* usually unnecessary */
return|return
operator|(
name|stringbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch an integer (or pointer) property.  * The return value is the property, or the default if there was none.  */
end_comment

begin_function
name|int
name|getpropint
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|deflt
parameter_list|)
name|int
name|node
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|deflt
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|char
name|intbuf
index|[
literal|16
index|]
decl_stmt|;
name|len
operator|=
name|getprop
argument_list|(
name|node
argument_list|,
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|intbuf
argument_list|,
sizeof|sizeof
name|intbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
return|return
operator|(
name|deflt
operator|)
return|;
return|return
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|intbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * OPENPROM functions.  These are here mainly to hide the OPENPROM interface  * from the rest of the kernel.  */
end_comment

begin_function
name|int
name|firstchild
parameter_list|(
name|node
parameter_list|)
name|int
name|node
decl_stmt|;
block|{
return|return
operator|(
name|promvec
operator|->
name|pv_nodeops
operator|->
name|no_child
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nextsibling
parameter_list|(
name|node
parameter_list|)
name|int
name|node
decl_stmt|;
block|{
return|return
operator|(
name|promvec
operator|->
name|pv_nodeops
operator|->
name|no_nextnode
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass a string to the FORTH PROM to be interpreted */
end_comment

begin_function
name|void
name|rominterpret
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|promvec
operator|->
name|pv_romvec_vers
operator|<
literal|2
condition|)
name|promvec
operator|->
name|pv_fortheval
operator|.
name|v0_eval
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|promvec
operator|->
name|pv_fortheval
operator|.
name|v2_eval
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|volatile
name|void
name|romhalt
parameter_list|()
block|{
name|promvec
operator|->
name|pv_halt
argument_list|()
expr_stmt|;
name|panic
argument_list|(
literal|"PROM exit failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|volatile
name|void
name|romboot
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|promvec
operator|->
name|pv_reboot
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"PROM boot failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|callrom
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|notdef
comment|/* sun4c FORTH PROMs do this for us */
name|fb_unblank
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|promvec
operator|->
name|pv_abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Configure swap space and related parameters.  */
end_comment

begin_macro
name|swapconf
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|swdevt
modifier|*
name|swp
decl_stmt|;
specifier|register
name|int
name|nblks
decl_stmt|;
for|for
control|(
name|swp
operator|=
name|swdevt
init|;
name|swp
operator|->
name|sw_dev
condition|;
name|swp
operator|++
control|)
if|if
condition|(
name|bdevsw
index|[
name|major
argument_list|(
name|swp
operator|->
name|sw_dev
argument_list|)
index|]
operator|.
name|d_psize
condition|)
block|{
name|nblks
operator|=
operator|(
operator|*
name|bdevsw
index|[
name|major
argument_list|(
name|swp
operator|->
name|sw_dev
argument_list|)
index|]
operator|.
name|d_psize
operator|)
operator|(
name|swp
operator|->
name|sw_dev
operator|)
expr_stmt|;
if|if
condition|(
name|nblks
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|swp
operator|->
name|sw_nblks
operator|==
literal|0
operator|||
name|swp
operator|->
name|sw_nblks
operator|>
name|nblks
operator|)
condition|)
name|swp
operator|->
name|sw_nblks
operator|=
name|nblks
expr_stmt|;
block|}
name|dumpconf
argument_list|()
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|DOSWAP
end_define

begin_comment
comment|/* Change swdevt, argdev, and dumpdev too */
end_comment

begin_decl_stmt
name|u_long
name|bootdev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should be dev_t, but not until 32 bits */
end_comment

begin_decl_stmt
specifier|static
name|char
name|devname
index|[]
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
comment|/* 0 = xx */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PARTITIONMASK
value|0x7
end_define

begin_define
define|#
directive|define
name|PARTITIONSHIFT
value|3
end_define

begin_comment
comment|/*  * Attempt to find the device from which we were booted.  * If we can do so, and not instructed not to do so,  * change rootdev to correspond to the load device.  */
end_comment

begin_macro
name|setroot
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|notyet
name|struct
name|swdevt
modifier|*
name|swp
decl_stmt|;
if|if
condition|(
name|boothowto
operator|&
name|RB_DFLTROOT
operator|||
operator|(
name|bootdev
operator|&
name|B_MAGICMASK
operator|)
operator|!=
operator|(
name|u_long
operator|)
name|B_DEVMAGIC
condition|)
return|return;
name|majdev
operator|=
operator|(
name|bootdev
operator|>>
name|B_TYPESHIFT
operator|)
operator|&
name|B_TYPEMASK
expr_stmt|;
if|if
condition|(
name|majdev
operator|>
sizeof|sizeof
argument_list|(
name|devname
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|devname
index|[
literal|0
index|]
argument_list|)
condition|)
return|return;
name|adaptor
operator|=
operator|(
name|bootdev
operator|>>
name|B_ADAPTORSHIFT
operator|)
operator|&
name|B_ADAPTORMASK
expr_stmt|;
name|part
operator|=
operator|(
name|bootdev
operator|>>
name|B_PARTITIONSHIFT
operator|)
operator|&
name|B_PARTITIONMASK
expr_stmt|;
name|unit
operator|=
operator|(
name|bootdev
operator|>>
name|B_UNITSHIFT
operator|)
operator|&
name|B_UNITMASK
expr_stmt|;
comment|/* 	 * First, find the controller type which support this device. 	 */
for|for
control|(
name|hd
operator|=
name|hp_dinit
init|;
name|hd
operator|->
name|hp_driver
condition|;
name|hd
operator|++
control|)
if|if
condition|(
name|hd
operator|->
name|hp_driver
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|devname
index|[
name|majdev
index|]
index|[
literal|0
index|]
operator|&&
name|hd
operator|->
name|hp_driver
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
name|devname
index|[
name|majdev
index|]
index|[
literal|1
index|]
condition|)
break|break;
if|if
condition|(
name|hd
operator|->
name|hp_driver
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Next, find the controller of that type corresponding to 	 * the adaptor number. 	 */
for|for
control|(
name|hc
operator|=
name|hp_cinit
init|;
name|hc
operator|->
name|hp_driver
condition|;
name|hc
operator|++
control|)
if|if
condition|(
name|hc
operator|->
name|hp_alive
operator|&&
name|hc
operator|->
name|hp_unit
operator|==
name|adaptor
operator|&&
name|hc
operator|->
name|hp_driver
operator|==
name|hd
operator|->
name|hp_cdriver
condition|)
break|break;
if|if
condition|(
name|hc
operator|->
name|hp_driver
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Finally, find the device in question attached to that controller. 	 */
for|for
control|(
name|hd
operator|=
name|hp_dinit
init|;
name|hd
operator|->
name|hp_driver
condition|;
name|hd
operator|++
control|)
if|if
condition|(
name|hd
operator|->
name|hp_alive
operator|&&
name|hd
operator|->
name|hp_slave
operator|==
name|unit
operator|&&
name|hd
operator|->
name|hp_cdriver
operator|==
name|hc
operator|->
name|hp_driver
operator|&&
name|hd
operator|->
name|hp_ctlr
operator|==
name|hc
operator|->
name|hp_unit
condition|)
break|break;
if|if
condition|(
name|hd
operator|->
name|hp_driver
operator|==
literal|0
condition|)
return|return;
name|mindev
operator|=
name|hd
operator|->
name|hp_unit
expr_stmt|;
comment|/* 	 * Form a new rootdev 	 */
name|mindev
operator|=
operator|(
name|mindev
operator|<<
name|PARTITIONSHIFT
operator|)
operator|+
name|part
expr_stmt|;
name|orootdev
operator|=
name|rootdev
expr_stmt|;
name|rootdev
operator|=
name|makedev
argument_list|(
name|majdev
argument_list|,
name|mindev
argument_list|)
expr_stmt|;
comment|/* 	 * If the original rootdev is the same as the one 	 * just calculated, don't need to adjust the swap configuration. 	 */
if|if
condition|(
name|rootdev
operator|==
name|orootdev
condition|)
return|return;
name|printf
argument_list|(
literal|"Changing root device to %c%c%d%c\n"
argument_list|,
name|devname
index|[
name|majdev
index|]
index|[
literal|0
index|]
argument_list|,
name|devname
index|[
name|majdev
index|]
index|[
literal|1
index|]
argument_list|,
name|mindev
operator|>>
name|PARTITIONSHIFT
argument_list|,
name|part
operator|+
literal|'a'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOSWAP
name|mindev
operator|&=
operator|~
name|PARTITIONMASK
expr_stmt|;
for|for
control|(
name|swp
operator|=
name|swdevt
init|;
name|swp
operator|->
name|sw_dev
condition|;
name|swp
operator|++
control|)
block|{
if|if
condition|(
name|majdev
operator|==
name|major
argument_list|(
name|swp
operator|->
name|sw_dev
argument_list|)
operator|&&
name|mindev
operator|==
operator|(
name|minor
argument_list|(
name|swp
operator|->
name|sw_dev
argument_list|)
operator|&
operator|~
name|PARTITIONMASK
operator|)
condition|)
block|{
name|temp
operator|=
name|swdevt
index|[
literal|0
index|]
operator|.
name|sw_dev
expr_stmt|;
name|swdevt
index|[
literal|0
index|]
operator|.
name|sw_dev
operator|=
name|swp
operator|->
name|sw_dev
expr_stmt|;
name|swp
operator|->
name|sw_dev
operator|=
name|temp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|swp
operator|->
name|sw_dev
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * If argdev and dumpdev were the same as the old primary swap 	 * device, move them to the new primary swap device. 	 */
if|if
condition|(
name|temp
operator|==
name|dumpdev
condition|)
name|dumpdev
operator|=
name|swdevt
index|[
literal|0
index|]
operator|.
name|sw_dev
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|argdev
condition|)
name|argdev
operator|=
name|swdevt
index|[
literal|0
index|]
operator|.
name|sw_dev
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Return pointer to device we booted from. Return NULL if we can't  * figure this out.  * XXX currently only works for network devices.  */
end_comment

begin_function
specifier|static
name|struct
name|bootinfo
modifier|*
name|findbootdev
parameter_list|()
block|{
specifier|register
name|struct
name|bootinfo
modifier|*
name|bi
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|,
name|controller
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|bi
operator|=
operator|&
name|bootinfo
expr_stmt|;
name|bp
operator|=
name|bi
operator|->
name|name
expr_stmt|;
name|printf
argument_list|(
literal|"findbootdev: (v%d rom) trying \"%s(%x,%x,%x)\"... "
argument_list|,
name|promvec
operator|->
name|pv_romvec_vers
argument_list|,
name|bp
argument_list|,
name|bi
operator|->
name|val
index|[
literal|0
index|]
argument_list|,
name|bi
operator|->
name|val
index|[
literal|1
index|]
argument_list|,
name|bi
operator|->
name|val
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Try network devices first */
name|unit
operator|=
name|bi
operator|->
name|val
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|if_next
control|)
if|if
condition|(
name|unit
operator|==
name|ifp
operator|->
name|if_unit
operator|&&
name|strcmp
argument_list|(
name|bp
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"found \"%s%d\"\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|bi
operator|->
name|type
operator|=
name|FS_NFS
expr_stmt|;
name|bi
operator|->
name|data
operator|=
operator|(
name|caddr_t
operator|)
name|ifp
expr_stmt|;
return|return
operator|(
name|bi
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"not found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|gets
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|lp
operator|=
name|cp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|cngetc
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return;
case|case
literal|'\b'
case|:
case|case
literal|'\177'
case|:
case|case
literal|'#'
case|:
if|if
condition|(
name|lp
operator|>
name|cp
condition|)
block|{
name|lp
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|" \b "
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
literal|'@'
case|:
case|case
literal|'u'
operator|&
literal|037
case|:
name|lp
operator|=
name|cp
expr_stmt|;
name|cnputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|c
operator|<
literal|' '
condition|)
continue|continue;
name|cnputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

