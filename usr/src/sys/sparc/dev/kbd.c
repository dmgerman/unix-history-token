begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)kbd.c	7.4 (Berkeley) %G%  *  * from: $Header: kbd.c,v 1.16 92/11/26 01:28:44 torek Exp $ (LBL)  */
end_comment

begin_comment
comment|/*  * Keyboard driver (/dev/kbd -- note that we do not have minor numbers  * [yet?]).  Translates incoming bytes to ASCII or to `firm_events' and  * passes them up to the appropriate reader.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<machine/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<sparc/dev/vuid_event.h>
end_include

begin_include
include|#
directive|include
file|<sparc/dev/event_var.h>
end_include

begin_include
include|#
directive|include
file|<sparc/dev/kbd.h>
end_include

begin_include
include|#
directive|include
file|<sparc/dev/kbio.h>
end_include

begin_comment
comment|/*  * Sun keyboard definitions (from Sprite).  * These apply to type 2, 3 and 4 keyboards.  */
end_comment

begin_define
define|#
directive|define
name|KEY_CODE
parameter_list|(
name|c
parameter_list|)
value|((c)& KBD_KEYMASK)
end_define

begin_comment
comment|/* keyboard code index */
end_comment

begin_define
define|#
directive|define
name|KEY_UP
parameter_list|(
name|c
parameter_list|)
value|((c)& KBD_UP)
end_define

begin_comment
comment|/* true => key went up */
end_comment

begin_comment
comment|/*  * Each KEY_CODE(x) can be translated via the tables below.  * The result is either a valid ASCII value in [0..0x7f] or is one  * of the following `magic' values saying something interesting  * happened.  If LSHIFT or RSHIFT has changed state the next  * lookup should come from the appropriate table; if ALLUP is  * sent all keys (including both shifts and the control key) are  * now up, and the next byte is the keyboard ID code.  *  * These tables ignore all function keys (on the theory that if you  * want these keys, you should use a window system).  Note that  * `caps lock' is just mapped as `ignore' (so there!). (Only the  * type 3 and 4 keyboards have a caps lock key anyway.)  */
end_comment

begin_define
define|#
directive|define
name|KEY_MAGIC
value|0x80
end_define

begin_comment
comment|/* flag => magic value */
end_comment

begin_define
define|#
directive|define
name|KEY_IGNORE
value|0x80
end_define

begin_define
define|#
directive|define
name|KEY_L1
value|KEY_IGNORE
end_define

begin_define
define|#
directive|define
name|KEY_CAPSLOCK
value|KEY_IGNORE
end_define

begin_define
define|#
directive|define
name|KEY_LSHIFT
value|0x81
end_define

begin_define
define|#
directive|define
name|KEY_RSHIFT
value|0x82
end_define

begin_define
define|#
directive|define
name|KEY_CONTROL
value|0x83
end_define

begin_define
define|#
directive|define
name|KEY_ALLUP
value|0x84
end_define

begin_comment
comment|/* all keys are now up; also reset */
end_comment

begin_comment
comment|/*  * Decode tables for type 2, 3, and 4 keyboards  * (stolen from Sprite; see also kbd.h).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|kbd_unshifted
index|[]
init|=
block|{
comment|/*   0 */
name|KEY_IGNORE
block|,
name|KEY_L1
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*   4 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*   8 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  12 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  16 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  20 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  24 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  28 */
name|KEY_IGNORE
block|,
literal|'\033'
block|,
literal|'1'
block|,
literal|'2'
block|,
comment|/*  32 */
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
comment|/*  36 */
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'0'
block|,
comment|/*  40 */
literal|'-'
block|,
literal|'='
block|,
literal|'`'
block|,
literal|'\b'
block|,
comment|/*  44 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  48 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  52 */
name|KEY_IGNORE
block|,
literal|'\t'
block|,
literal|'q'
block|,
literal|'w'
block|,
comment|/*  56 */
literal|'e'
block|,
literal|'r'
block|,
literal|'t'
block|,
literal|'y'
block|,
comment|/*  60 */
literal|'u'
block|,
literal|'i'
block|,
literal|'o'
block|,
literal|'p'
block|,
comment|/*  64 */
literal|'['
block|,
literal|']'
block|,
literal|'\177'
block|,
name|KEY_IGNORE
block|,
comment|/*  68 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  72 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  76 */
name|KEY_CONTROL
block|,
literal|'a'
block|,
literal|'s'
block|,
literal|'d'
block|,
comment|/*  80 */
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'j'
block|,
comment|/*  84 */
literal|'k'
block|,
literal|'l'
block|,
literal|';'
block|,
literal|'\''
block|,
comment|/*  88 */
literal|'\\'
block|,
literal|'\r'
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  92 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  96 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_LSHIFT
block|,
comment|/* 100 */
literal|'z'
block|,
literal|'x'
block|,
literal|'c'
block|,
literal|'v'
block|,
comment|/* 104 */
literal|'b'
block|,
literal|'n'
block|,
literal|'m'
block|,
literal|','
block|,
comment|/* 108 */
literal|'.'
block|,
literal|'/'
block|,
name|KEY_RSHIFT
block|,
literal|'\n'
block|,
comment|/* 112 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/* 116 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_CAPSLOCK
block|,
comment|/* 120 */
name|KEY_IGNORE
block|,
literal|' '
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/* 124 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_ALLUP
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|kbd_shifted
index|[]
init|=
block|{
comment|/*   0 */
name|KEY_IGNORE
block|,
name|KEY_L1
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*   4 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*   8 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  12 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  16 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  20 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  24 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  28 */
name|KEY_IGNORE
block|,
literal|'\033'
block|,
literal|'!'
block|,
literal|'@'
block|,
comment|/*  32 */
literal|'#'
block|,
literal|'$'
block|,
literal|'%'
block|,
literal|'^'
block|,
comment|/*  36 */
literal|'&'
block|,
literal|'*'
block|,
literal|'('
block|,
literal|')'
block|,
comment|/*  40 */
literal|'_'
block|,
literal|'+'
block|,
literal|'~'
block|,
literal|'\b'
block|,
comment|/*  44 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  48 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  52 */
name|KEY_IGNORE
block|,
literal|'\t'
block|,
literal|'Q'
block|,
literal|'W'
block|,
comment|/*  56 */
literal|'E'
block|,
literal|'R'
block|,
literal|'T'
block|,
literal|'Y'
block|,
comment|/*  60 */
literal|'U'
block|,
literal|'I'
block|,
literal|'O'
block|,
literal|'P'
block|,
comment|/*  64 */
literal|'{'
block|,
literal|'}'
block|,
literal|'\177'
block|,
name|KEY_IGNORE
block|,
comment|/*  68 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  72 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  76 */
name|KEY_CONTROL
block|,
literal|'A'
block|,
literal|'S'
block|,
literal|'D'
block|,
comment|/*  80 */
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'J'
block|,
comment|/*  84 */
literal|'K'
block|,
literal|'L'
block|,
literal|':'
block|,
literal|'"'
block|,
comment|/*  88 */
literal|'|'
block|,
literal|'\r'
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  92 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/*  96 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_LSHIFT
block|,
comment|/* 100 */
literal|'Z'
block|,
literal|'X'
block|,
literal|'C'
block|,
literal|'V'
block|,
comment|/* 104 */
literal|'B'
block|,
literal|'N'
block|,
literal|'M'
block|,
literal|'<'
block|,
comment|/* 108 */
literal|'>'
block|,
literal|'?'
block|,
name|KEY_RSHIFT
block|,
literal|'\n'
block|,
comment|/* 112 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/* 116 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_CAPSLOCK
block|,
comment|/* 120 */
name|KEY_IGNORE
block|,
literal|' '
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
comment|/* 124 */
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_IGNORE
block|,
name|KEY_ALLUP
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We need to remember the state of the keyboard's shift and control  * keys, and we need a per-type translation table.  */
end_comment

begin_struct
struct|struct
name|kbd_state
block|{
specifier|const
name|u_char
modifier|*
name|kbd_unshifted
decl_stmt|;
comment|/* unshifted keys */
specifier|const
name|u_char
modifier|*
name|kbd_shifted
decl_stmt|;
comment|/* shifted keys */
specifier|const
name|u_char
modifier|*
name|kbd_cur
decl_stmt|;
comment|/* current keys (either of the preceding) */
union|union
block|{
name|char
name|c
index|[
literal|2
index|]
decl_stmt|;
comment|/* left and right shift keys */
name|short
name|s
decl_stmt|;
comment|/* true => either shift key */
block|}
name|kbd_shift
union|;
define|#
directive|define
name|kbd_lshift
value|kbd_shift.c[0]
define|#
directive|define
name|kbd_rshift
value|kbd_shift.c[1]
define|#
directive|define
name|kbd_anyshift
value|kbd_shift.s
name|char
name|kbd_control
decl_stmt|;
comment|/* true => ctrl down */
name|char
name|kbd_click
decl_stmt|;
comment|/* true => keyclick enabled */
name|char
name|kbd_takeid
decl_stmt|;
comment|/* take next byte as ID */
name|u_char
name|kbd_id
decl_stmt|;
comment|/* a place to store the ID */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Keyboard driver state.  The ascii and kbd links go up and down and  * we just sit in the middle doing translation.  Note that it is possible  * to get just one of the two links, in which case /dev/kbd is unavailable.  * The downlink supplies us with `internal' open and close routines which  * will enable dataflow across the downlink.  We promise to call open when  * we are willing to take keystrokes, and to call close when we are not.  * If /dev/kbd is not the console tty input source, we do this whenever  * /dev/kbd is in use; otherwise we just leave it open forever.  */
end_comment

begin_struct
struct|struct
name|kbd_softc
block|{
name|struct
name|tty
modifier|*
name|k_cons
decl_stmt|;
comment|/* uplink for ASCII data to console */
name|struct
name|tty
modifier|*
name|k_kbd
decl_stmt|;
comment|/* downlink for output to keyboard */
name|void
argument_list|(
argument|*k_open
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* enable dataflow */
name|void
argument_list|(
argument|*k_close
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* disable dataflow */
name|int
name|k_evmode
decl_stmt|;
comment|/* set if we should produce events */
name|struct
name|kbd_state
name|k_state
decl_stmt|;
comment|/* ASCII decode state */
name|struct
name|evvar
name|k_events
decl_stmt|;
comment|/* event queue state */
block|}
name|kbd_softc
struct|;
end_struct

begin_comment
comment|/* Prototypes */
end_comment

begin_function_decl
name|void
name|kbd_ascii
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|kbd_serial
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|()
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kbd_getid
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|kbd_reset
parameter_list|(
name|struct
name|kbd_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kbd_translate
parameter_list|(
name|int
parameter_list|,
name|struct
name|kbd_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|kbd_rint
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|kbdopen
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|kbdclose
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|kbdread
parameter_list|(
name|dev_t
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|kbdwrite
parameter_list|(
name|dev_t
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|kbdioctl
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|kbdselect
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|kbd_docmd
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Attach the console keyboard ASCII (up-link) interface.  * This happens before kbd_serial.  */
end_comment

begin_function
name|void
name|kbd_ascii
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|kbd_softc
operator|.
name|k_cons
operator|=
name|tp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach the console keyboard serial (down-link) interface.  * We pick up the initial keyboard clock state here as well.  */
end_comment

begin_function
name|void
name|kbd_serial
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|void
function_decl|(
modifier|*
name|iopen
function_decl|)
parameter_list|()
parameter_list|,
name|void
function_decl|(
modifier|*
name|iclose
function_decl|)
parameter_list|()
parameter_list|)
block|{
specifier|register
name|struct
name|kbd_softc
modifier|*
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|k
operator|=
operator|&
name|kbd_softc
expr_stmt|;
name|k
operator|->
name|k_kbd
operator|=
name|tp
expr_stmt|;
name|k
operator|->
name|k_open
operator|=
name|iopen
expr_stmt|;
name|k
operator|->
name|k_close
operator|=
name|iclose
expr_stmt|;
name|cp
operator|=
name|getpropstring
argument_list|(
name|optionsnode
argument_list|,
literal|"keyboard-click?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
condition|)
name|k
operator|->
name|k_state
operator|.
name|kbd_click
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|k_cons
condition|)
block|{
comment|/* 		 * We supply keys for /dev/console.  Before we can 		 * do so, we have to ``open'' the line.  We also need 		 * the type, got by sending a RESET down the line ... 		 * but clists are not yet set up, so we use a timeout 		 * to try constantly until we can get the ID.  (gag) 		 */
call|(
modifier|*
name|iopen
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* never to be closed */
name|kbd_getid
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initial keyboard reset, to obtain ID and thus a translation table.  * We have to try again and again until the tty subsystem works.  */
end_comment

begin_function
specifier|static
name|void
name|kbd_getid
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|register
name|struct
name|kbd_softc
modifier|*
name|k
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|retry
decl_stmt|;
specifier|extern
name|int
name|cold
decl_stmt|;
comment|/* XXX */
name|k
operator|=
operator|&
name|kbd_softc
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|k_state
operator|.
name|kbd_cur
operator|!=
name|NULL
condition|)
return|return;
name|tp
operator|=
name|k
operator|->
name|k_kbd
expr_stmt|;
if|if
condition|(
name|cold
operator|||
name|ttyoutput
argument_list|(
name|KBD_CMD_RESET
argument_list|,
name|tp
argument_list|)
operator|>=
literal|0
condition|)
name|retry
operator|=
literal|1
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|retry
operator|=
literal|2
operator|*
name|hz
expr_stmt|;
block|}
name|timeout
argument_list|(
name|kbd_getid
argument_list|,
name|NULL
argument_list|,
name|retry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kbd_reset
parameter_list|(
specifier|register
name|struct
name|kbd_state
modifier|*
name|ks
parameter_list|)
block|{
comment|/* 	 * On first identification, wake up anyone waiting for type 	 * and set up the table pointers. 	 */
if|if
condition|(
name|ks
operator|->
name|kbd_unshifted
operator|==
name|NULL
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|ks
argument_list|)
expr_stmt|;
name|ks
operator|->
name|kbd_unshifted
operator|=
name|kbd_unshifted
expr_stmt|;
name|ks
operator|->
name|kbd_shifted
operator|=
name|kbd_shifted
expr_stmt|;
name|ks
operator|->
name|kbd_cur
operator|=
name|ks
operator|->
name|kbd_unshifted
expr_stmt|;
block|}
comment|/* Restore keyclick, if necessary */
switch|switch
condition|(
name|ks
operator|->
name|kbd_id
condition|)
block|{
case|case
name|KB_SUN2
case|:
comment|/* Type 2 keyboards don't support keyclick */
break|break;
case|case
name|KB_SUN3
case|:
comment|/* Type 3 keyboards come up with keyclick on */
if|if
condition|(
operator|!
name|ks
operator|->
name|kbd_click
condition|)
operator|(
name|void
operator|)
name|kbd_docmd
argument_list|(
name|KBD_CMD_NOCLICK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|KB_SUN4
case|:
comment|/* Type 4 keyboards come up with keyclick off */
if|if
condition|(
name|ks
operator|->
name|kbd_click
condition|)
operator|(
name|void
operator|)
name|kbd_docmd
argument_list|(
name|KBD_CMD_CLICK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Turn keyboard up/down codes into ASCII.  */
end_comment

begin_function
specifier|static
name|int
name|kbd_translate
parameter_list|(
specifier|register
name|int
name|c
parameter_list|,
specifier|register
name|struct
name|kbd_state
modifier|*
name|ks
parameter_list|)
block|{
specifier|register
name|int
name|down
decl_stmt|;
if|if
condition|(
name|ks
operator|->
name|kbd_cur
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Do not know how to translate yet. 		 * We will find out when a RESET comes along. 		 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|down
operator|=
operator|!
name|KEY_UP
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|ks
operator|->
name|kbd_cur
index|[
name|KEY_CODE
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|KEY_MAGIC
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|KEY_LSHIFT
case|:
name|ks
operator|->
name|kbd_lshift
operator|=
name|down
expr_stmt|;
break|break;
case|case
name|KEY_RSHIFT
case|:
name|ks
operator|->
name|kbd_rshift
operator|=
name|down
expr_stmt|;
break|break;
case|case
name|KEY_ALLUP
case|:
name|ks
operator|->
name|kbd_anyshift
operator|=
literal|0
expr_stmt|;
name|ks
operator|->
name|kbd_control
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_CONTROL
case|:
name|ks
operator|->
name|kbd_control
operator|=
name|down
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|KEY_IGNORE
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"kbd_translate"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ks
operator|->
name|kbd_anyshift
condition|)
name|ks
operator|->
name|kbd_cur
operator|=
name|ks
operator|->
name|kbd_shifted
expr_stmt|;
else|else
name|ks
operator|->
name|kbd_cur
operator|=
name|ks
operator|->
name|kbd_unshifted
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|down
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ks
operator|->
name|kbd_control
condition|)
block|{
comment|/* control space and unshifted control atsign return null */
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'2'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* unshifted control hat */
if|if
condition|(
name|c
operator|==
literal|'6'
condition|)
return|return
operator|(
literal|'^'
operator|&
literal|0x1f
operator|)
return|;
comment|/* standard controls */
if|if
condition|(
name|c
operator|>=
literal|'@'
operator|&&
name|c
operator|<
literal|0x7f
condition|)
return|return
operator|(
name|c
operator|&
literal|0x1f
operator|)
return|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|void
name|kbd_rint
parameter_list|(
specifier|register
name|int
name|c
parameter_list|)
block|{
specifier|register
name|struct
name|kbd_softc
modifier|*
name|k
init|=
operator|&
name|kbd_softc
decl_stmt|;
specifier|register
name|struct
name|firm_event
modifier|*
name|fe
decl_stmt|;
specifier|register
name|int
name|put
decl_stmt|;
comment|/* 	 * Reset keyboard after serial port overrun, so we can resynch. 	 * The printf below should be shortened and/or replaced with a 	 * call to log() after this is tested (and how will we test it?!). 	 */
if|if
condition|(
name|c
operator|&
operator|(
name|TTY_FE
operator||
name|TTY_PE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"keyboard input parity or framing error (0x%x)\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ttyoutput
argument_list|(
name|KBD_CMD_RESET
argument_list|,
name|k
operator|->
name|k_kbd
argument_list|)
expr_stmt|;
call|(
modifier|*
name|k
operator|->
name|k_kbd
operator|->
name|t_oproc
call|)
argument_list|(
name|k
operator|->
name|k_kbd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read the keyboard id if we read a KBD_RESET last time */
if|if
condition|(
name|k
operator|->
name|k_state
operator|.
name|kbd_takeid
condition|)
block|{
name|k
operator|->
name|k_state
operator|.
name|kbd_takeid
operator|=
literal|0
expr_stmt|;
name|k
operator|->
name|k_state
operator|.
name|kbd_id
operator|=
name|c
expr_stmt|;
name|kbd_reset
argument_list|(
operator|&
name|k
operator|->
name|k_state
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have been reset, setup to grab the keyboard id next time */
if|if
condition|(
name|c
operator|==
name|KBD_RESET
condition|)
block|{
name|k
operator|->
name|k_state
operator|.
name|kbd_takeid
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 	 * If /dev/kbd is not connected in event mode, but we are sending 	 * data to /dev/console, translate and send upstream.  Note that 	 * we will get this while opening /dev/kbd if it is not already 	 * open and we do not know its type. 	 */
if|if
condition|(
operator|!
name|k
operator|->
name|k_evmode
condition|)
block|{
name|c
operator|=
name|kbd_translate
argument_list|(
name|c
argument_list|,
operator|&
name|k
operator|->
name|k_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
operator|&&
name|k
operator|->
name|k_cons
operator|!=
name|NULL
condition|)
name|ttyinput
argument_list|(
name|c
argument_list|,
name|k
operator|->
name|k_cons
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * IDLEs confuse the MIT X11R4 server badly, so we must drop them. 	 * This is bad as it means the server will not automatically resync 	 * on all-up IDLEs, but I did not drop them before, and the server 	 * goes crazy when it comes time to blank the screen.... 	 */
if|if
condition|(
name|c
operator|==
name|KBD_IDLE
condition|)
return|return;
comment|/* 	 * Keyboard is generating events.  Turn this keystroke into an 	 * event and put it in the queue.  If the queue is full, the 	 * keystroke is lost (sorry!). 	 */
name|put
operator|=
name|k
operator|->
name|k_events
operator|.
name|ev_put
expr_stmt|;
name|fe
operator|=
operator|&
name|k
operator|->
name|k_events
operator|.
name|ev_q
index|[
name|put
index|]
expr_stmt|;
name|put
operator|=
operator|(
name|put
operator|+
literal|1
operator|)
operator|%
name|EV_QSIZE
expr_stmt|;
if|if
condition|(
name|put
operator|==
name|k
operator|->
name|k_events
operator|.
name|ev_get
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"keyboard event queue overflow\n"
argument_list|)
expr_stmt|;
comment|/* ??? */
return|return;
block|}
name|fe
operator|->
name|id
operator|=
name|KEY_CODE
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fe
operator|->
name|value
operator|=
name|KEY_UP
argument_list|(
name|c
argument_list|)
condition|?
name|VKEY_UP
else|:
name|VKEY_DOWN
expr_stmt|;
name|fe
operator|->
name|time
operator|=
name|time
expr_stmt|;
name|k
operator|->
name|k_events
operator|.
name|ev_put
operator|=
name|put
expr_stmt|;
name|EV_WAKEUP
argument_list|(
operator|&
name|k
operator|->
name|k_events
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|kbdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|kbd_softc
operator|.
name|k_events
operator|.
name|ev_io
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|kbd_softc
operator|.
name|k_events
operator|.
name|ev_io
operator|=
name|p
expr_stmt|;
comment|/* 	 * If no console keyboard, tell the device to open up, maybe for 	 * the first time.  Then make sure we know what kind of keyboard 	 * it is. 	 */
if|if
condition|(
name|kbd_softc
operator|.
name|k_cons
operator|==
name|NULL
condition|)
call|(
modifier|*
name|kbd_softc
operator|.
name|k_open
call|)
argument_list|(
name|kbd_softc
operator|.
name|k_kbd
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|kbd_softc
operator|.
name|k_state
operator|.
name|kbd_cur
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ttyoutput
argument_list|(
name|KBD_CMD_RESET
argument_list|,
name|kbd_softc
operator|.
name|k_kbd
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|kbd_softc
operator|.
name|k_state
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
name|devopn
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
comment|/* no response */
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|kbd_softc
operator|.
name|k_events
operator|.
name|ev_io
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ev_init
argument_list|(
operator|&
name|kbd_softc
operator|.
name|k_events
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kbdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * Turn off event mode, dump the queue, and close the keyboard 	 * unless it is supplying console input. 	 */
name|kbd_softc
operator|.
name|k_evmode
operator|=
literal|0
expr_stmt|;
name|ev_fini
argument_list|(
operator|&
name|kbd_softc
operator|.
name|k_events
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbd_softc
operator|.
name|k_cons
operator|==
name|NULL
condition|)
call|(
modifier|*
name|kbd_softc
operator|.
name|k_close
call|)
argument_list|(
name|kbd_softc
operator|.
name|k_kbd
argument_list|)
expr_stmt|;
name|kbd_softc
operator|.
name|k_events
operator|.
name|ev_io
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kbdread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
operator|(
name|ev_read
argument_list|(
operator|&
name|kbd_softc
operator|.
name|k_events
argument_list|,
name|uio
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this routine should not exist, but is convenient to write here for now */
end_comment

begin_function
name|int
name|kbdwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kbdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
specifier|register
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|kbd_softc
modifier|*
name|k
init|=
operator|&
name|kbd_softc
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|KIOCTRANS
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
name|TR_UNTRANS_EVENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|KIOCGTRANS
case|:
comment|/* 		 * Get translation mode 		 */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TR_UNTRANS_EVENT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|KIOCGETKEY
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|kiockey
operator|*
operator|)
name|data
operator|)
operator|->
name|kio_station
operator|==
literal|118
condition|)
block|{
comment|/* 			 * This is X11 asking if a type 3 keyboard is 			 * really a type 3 keyboard.  Say yes. 			 */
operator|(
operator|(
expr|struct
name|kiockey
operator|*
operator|)
name|data
operator|)
operator|->
name|kio_entry
operator|=
name|HOLE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|KIOCCMD
case|:
comment|/* 		 * ``unimplemented commands are ignored'' (blech) 		 * so cannot check return value from kbd_docmd 		 */
ifdef|#
directive|ifdef
name|notyet
while|while
condition|(
name|kbd_docmd
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
literal|1
argument_list|)
operator|==
name|ENOSPC
condition|)
comment|/*ERESTART?*/
operator|(
name|void
operator|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|TTOPRI
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|kbd_docmd
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|KIOCTYPE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|k
operator|->
name|k_state
operator|.
name|kbd_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|KIOCSDIRECT
case|:
name|k
operator|->
name|k_evmode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIONBIO
case|:
comment|/* we will remove this someday (soon???) */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIOASYNC
case|:
name|k
operator|->
name|k_events
operator|.
name|ev_async
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|!=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCSPGRP
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|!=
name|k
operator|->
name|k_events
operator|.
name|ev_io
operator|->
name|p_pgid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
comment|/* 	 * We identified the ioctl, but we do not handle it. 	 */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* misuse, but what the heck */
block|}
end_function

begin_function
name|int
name|kbdselect
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|rw
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|ev_select
argument_list|(
operator|&
name|kbd_softc
operator|.
name|k_events
argument_list|,
name|rw
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Execute a keyboard command; return 0 on success.  * If `isuser', force a small delay before output if output queue  * is flooding.  (The keyboard runs at 1200 baud, or 120 cps.)  */
end_comment

begin_function
name|int
name|kbd_docmd
parameter_list|(
name|int
name|cmd
parameter_list|,
name|int
name|isuser
parameter_list|)
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
name|kbd_softc
operator|.
name|k_kbd
decl_stmt|;
specifier|register
name|struct
name|kbd_softc
modifier|*
name|k
init|=
operator|&
name|kbd_softc
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* ??? */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|KBD_CMD_BELL
case|:
case|case
name|KBD_CMD_NOBELL
case|:
comment|/* Supported by type 2, 3, and 4 keyboards */
break|break;
case|case
name|KBD_CMD_CLICK
case|:
comment|/* Unsupported by type 2 keyboards */
if|if
condition|(
name|k
operator|->
name|k_state
operator|.
name|kbd_id
operator|!=
name|KB_SUN2
condition|)
block|{
name|k
operator|->
name|k_state
operator|.
name|kbd_click
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|KBD_CMD_NOCLICK
case|:
comment|/* Unsupported by type 2 keyboards */
if|if
condition|(
name|k
operator|->
name|k_state
operator|.
name|kbd_id
operator|!=
name|KB_SUN2
condition|)
block|{
name|k
operator|->
name|k_state
operator|.
name|kbd_click
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* ENOTTY? EOPNOTSUPP? */
block|}
if|if
condition|(
name|isuser
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
literal|120
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|TTIPRI
argument_list|,
name|ttyout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ttyoutput
argument_list|(
name|cmd
argument_list|,
name|tp
argument_list|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* ERESTART? */
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

