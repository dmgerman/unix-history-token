begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)zs.c	8.1 (Berkeley) %G%  *  * from: $Header: zs.c,v 1.29 93/07/15 02:57:07 torek Exp $  */
end_comment

begin_comment
comment|/*  * Zilog Z8530 (ZSCC) driver.  *  * Runs two tty ports (ttya and ttyb) on zs0,  * and runs a keyboard and mouse on zs1.  *  * This driver knows far too much about chip to usage mappings.  */
end_comment

begin_define
define|#
directive|define
name|NZS
value|2
end_define

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sparc/vaddrs.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sparc/auxreg.h>
end_include

begin_include
include|#
directive|include
file|<sparc/dev/kbd.h>
end_include

begin_include
include|#
directive|include
file|<sparc/dev/zsreg.h>
end_include

begin_include
include|#
directive|include
file|<sparc/dev/zsvar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KGDB
end_ifdef

begin_include
include|#
directive|include
file|<machine/remote-sl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ZSMAJOR
value|12
end_define

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|ZS_KBD
value|2
end_define

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|ZS_MOUSE
value|3
end_define

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/* the magic number below was stolen from the Sprite source. */
end_comment

begin_define
define|#
directive|define
name|PCLK
value|(19660800/4)
end_define

begin_comment
comment|/* PCLK pin input clock rate */
end_comment

begin_comment
comment|/*  * Select software interrupt bit based on TTY ipl.  */
end_comment

begin_if
if|#
directive|if
name|PIL_TTY
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|IE_ZSSOFT
value|IE_L1
end_define

begin_elif
elif|#
directive|elif
name|PIL_TTY
operator|==
literal|4
end_elif

begin_define
define|#
directive|define
name|IE_ZSSOFT
value|IE_L4
end_define

begin_elif
elif|#
directive|elif
name|PIL_TTY
operator|==
literal|6
end_elif

begin_define
define|#
directive|define
name|IE_ZSSOFT
value|IE_L6
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"no suitable software interrupt bit"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Software state per found chip.  This would be called `zs_softc',  * but the previous driver had a rather different zs_softc....  */
end_comment

begin_struct
struct|struct
name|zsinfo
block|{
name|struct
name|device
name|zi_dev
decl_stmt|;
comment|/* base device */
specifier|volatile
name|struct
name|zsdevice
modifier|*
name|zi_zs
decl_stmt|;
comment|/* chip registers */
name|struct
name|zs_chanstate
name|zi_cs
index|[
literal|2
index|]
decl_stmt|;
comment|/* channel A and B software state */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|tty
name|zs_tty
index|[
name|NZS
operator|*
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX should be dynamic */
end_comment

begin_comment
comment|/* Definition of the driver for autoconfig. */
end_comment

begin_function_decl
specifier|static
name|int
name|zsmatch
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|cfdata
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zsattach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfdriver
name|zscd
init|=
block|{
name|NULL
block|,
literal|"zs"
block|,
name|zsmatch
block|,
name|zsattach
block|,
name|DV_TTY
block|,
expr|sizeof
operator|(
expr|struct
name|zsinfo
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interrupt handlers. */
end_comment

begin_function_decl
specifier|static
name|int
name|zshard
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|intrhand
name|levelhard
init|=
block|{
name|zshard
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|zssoft
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|intrhand
name|levelsoft
init|=
block|{
name|zssoft
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|zs_chanstate
modifier|*
name|zslist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Routines called from other code. */
end_comment

begin_function_decl
specifier|static
name|void
name|zsiopen
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zsiclose
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zsstart
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zsstop
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zsparam
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|struct
name|termios
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Routines purely local to this driver. */
end_comment

begin_function_decl
specifier|static
name|int
name|zs_getspeed
parameter_list|(
specifier|volatile
name|struct
name|zschan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zs_reset
parameter_list|(
specifier|volatile
name|struct
name|zschan
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zs_modem
parameter_list|(
name|struct
name|zs_chanstate
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zs_loadchannelregs
parameter_list|(
specifier|volatile
name|struct
name|zschan
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Console stuff. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tty
modifier|*
name|zs_ctty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* console `struct tty *' */
end_comment

begin_decl_stmt
specifier|static
name|int
name|zs_consin
init|=
operator|-
literal|1
decl_stmt|,
name|zs_consout
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|zscnputc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* console putc function */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|struct
name|zschan
modifier|*
name|zs_conschan
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|tty
modifier|*
name|zs_checkcons
parameter_list|(
name|struct
name|zsinfo
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|zs_chanstate
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|KGDB
end_ifdef

begin_comment
comment|/* KGDB stuff.  Must reboot to change zs_kgdbunit. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|kgdb_dev
decl_stmt|,
name|kgdb_rate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zs_kgdb_savedspeed
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|zs_checkkgdb
parameter_list|(
name|int
parameter_list|,
name|struct
name|zs_chanstate
modifier|*
parameter_list|,
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
specifier|volatile
name|struct
name|zsdevice
modifier|*
name|findzs
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|volatile
name|struct
name|zsdevice
modifier|*
name|zsaddr
index|[
name|NZS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX, but saves work */
end_comment

begin_comment
comment|/*  * Console keyboard L1-A processing is done in the hardware interrupt code,  * so we need to duplicate some of the console keyboard decode state.  (We  * must not use the regular state as the hardware code keeps ahead of the  * software state: the software state tracks the most recent ring input but  * the hardware state tracks the most recent ZSCC input.)  See also kbd.h.  */
end_comment

begin_struct
specifier|static
struct|struct
name|conk_state
block|{
comment|/* console keyboard state */
name|char
name|conk_id
decl_stmt|;
comment|/* true => ID coming up (console only) */
name|char
name|conk_l1
decl_stmt|;
comment|/* true => L1 pressed (console only) */
block|}
name|zsconk_state
struct|;
end_struct

begin_decl_stmt
name|int
name|zshardscope
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zsshortcuts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of "shortcut" software interrupts */
end_comment

begin_comment
comment|/*  * Match slave number to zs unit number, so that misconfiguration will  * not set up the keyboard as ttya, etc.  */
end_comment

begin_function
specifier|static
name|int
name|zsmatch
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|struct
name|cfdata
modifier|*
name|cf
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
name|struct
name|romaux
modifier|*
name|ra
init|=
name|aux
decl_stmt|;
return|return
operator|(
name|getpropint
argument_list|(
name|ra
operator|->
name|ra_node
argument_list|,
literal|"slave"
argument_list|,
operator|-
literal|2
argument_list|)
operator|==
name|cf
operator|->
name|cf_unit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a found zs.  *  * USE ROM PROPERTIES port-a-ignore-cd AND port-b-ignore-cd FOR  * SOFT CARRIER, AND keyboard PROPERTY FOR KEYBOARD/MOUSE?  */
end_comment

begin_function
specifier|static
name|void
name|zsattach
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
specifier|register
name|int
name|zs
init|=
name|dev
operator|->
name|dv_unit
decl_stmt|,
name|unit
decl_stmt|;
specifier|register
name|struct
name|zsinfo
modifier|*
name|zi
decl_stmt|;
specifier|register
name|struct
name|zs_chanstate
modifier|*
name|cs
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|zsdevice
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|ctp
decl_stmt|;
specifier|register
name|struct
name|romaux
modifier|*
name|ra
init|=
name|aux
decl_stmt|;
name|int
name|pri
decl_stmt|,
name|softcar
decl_stmt|;
specifier|static
name|int
name|didintr
decl_stmt|,
name|prevpri
decl_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
name|zsaddr
index|[
name|zs
index|]
operator|)
operator|==
name|NULL
condition|)
name|addr
operator|=
name|zsaddr
index|[
name|zs
index|]
operator|=
name|findzs
argument_list|(
name|zs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|addr
operator|!=
name|ra
operator|->
name|ra_vaddr
condition|)
name|panic
argument_list|(
literal|"zsattach"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ra
operator|->
name|ra_nintr
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|": expected 1 interrupt, got %d\n"
argument_list|,
name|ra
operator|->
name|ra_nintr
argument_list|)
expr_stmt|;
return|return;
block|}
name|pri
operator|=
name|ra
operator|->
name|ra_intr
index|[
literal|0
index|]
operator|.
name|int_pri
expr_stmt|;
name|printf
argument_list|(
literal|" pri %d, softpri %d\n"
argument_list|,
name|pri
argument_list|,
name|PIL_TTY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|didintr
condition|)
block|{
name|didintr
operator|=
literal|1
expr_stmt|;
name|prevpri
operator|=
name|pri
expr_stmt|;
name|intr_establish
argument_list|(
name|pri
argument_list|,
operator|&
name|levelhard
argument_list|)
expr_stmt|;
name|intr_establish
argument_list|(
name|PIL_TTY
argument_list|,
operator|&
name|levelsoft
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pri
operator|!=
name|prevpri
condition|)
name|panic
argument_list|(
literal|"broken zs interrupt scheme"
argument_list|)
expr_stmt|;
name|zi
operator|=
operator|(
expr|struct
name|zsinfo
operator|*
operator|)
name|dev
expr_stmt|;
name|zi
operator|->
name|zi_zs
operator|=
name|addr
expr_stmt|;
name|unit
operator|=
name|zs
operator|*
literal|2
expr_stmt|;
name|cs
operator|=
name|zi
operator|->
name|zi_cs
expr_stmt|;
name|tp
operator|=
operator|&
name|zs_tty
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
comment|/* Get software carrier flags from options node in OPENPROM. */
specifier|extern
name|int
name|optionsnode
decl_stmt|;
name|softcar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|getpropstring
argument_list|(
name|optionsnode
argument_list|,
literal|"ttya-ignore-cd"
argument_list|)
operator|==
literal|'t'
condition|)
name|softcar
operator||=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|getpropstring
argument_list|(
name|optionsnode
argument_list|,
literal|"ttyb-ignore-cd"
argument_list|)
operator|==
literal|'t'
condition|)
name|softcar
operator||=
literal|2
expr_stmt|;
block|}
else|else
name|softcar
operator|=
name|dev
operator|->
name|dv_cfdata
operator|->
name|cf_flags
expr_stmt|;
comment|/* link into interrupt list with order (A,B) (B=A+1) */
name|cs
index|[
literal|0
index|]
operator|.
name|cs_next
operator|=
operator|&
name|cs
index|[
literal|1
index|]
expr_stmt|;
name|cs
index|[
literal|1
index|]
operator|.
name|cs_next
operator|=
name|zslist
expr_stmt|;
name|zslist
operator|=
name|cs
expr_stmt|;
name|cs
operator|->
name|cs_unit
operator|=
name|unit
expr_stmt|;
name|cs
operator|->
name|cs_speed
operator|=
name|zs_getspeed
argument_list|(
operator|&
name|addr
operator|->
name|zs_chan
index|[
name|CHAN_A
index|]
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_softcar
operator|=
name|softcar
operator|&
literal|1
expr_stmt|;
name|cs
operator|->
name|cs_zc
operator|=
operator|&
name|addr
operator|->
name|zs_chan
index|[
name|CHAN_A
index|]
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|makedev
argument_list|(
name|ZSMAJOR
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|zsstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|zsparam
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|zsstop
expr_stmt|;
if|if
condition|(
operator|(
name|ctp
operator|=
name|zs_checkcons
argument_list|(
name|zi
argument_list|,
name|unit
argument_list|,
name|cs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|tp
operator|=
name|ctp
expr_stmt|;
name|cs
operator|->
name|cs_ttyp
operator|=
name|tp
expr_stmt|;
ifdef|#
directive|ifdef
name|KGDB
if|if
condition|(
name|ctp
operator|==
name|NULL
condition|)
name|zs_checkkgdb
argument_list|(
name|unit
argument_list|,
name|cs
argument_list|,
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unit
operator|==
name|ZS_KBD
condition|)
block|{
comment|/* 		 * Keyboard: tell /dev/kbd driver how to talk to us. 		 */
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|cs
operator|->
name|cs_speed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|CS8
expr_stmt|;
name|kbd_serial
argument_list|(
name|tp
argument_list|,
name|zsiopen
argument_list|,
name|zsiclose
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_conk
operator|=
literal|1
expr_stmt|;
comment|/* do L1-A processing */
block|}
name|unit
operator|++
expr_stmt|;
name|cs
operator|++
expr_stmt|;
name|tp
operator|++
expr_stmt|;
name|cs
operator|->
name|cs_unit
operator|=
name|unit
expr_stmt|;
name|cs
operator|->
name|cs_speed
operator|=
name|zs_getspeed
argument_list|(
operator|&
name|addr
operator|->
name|zs_chan
index|[
name|CHAN_B
index|]
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_softcar
operator|=
name|softcar
operator|&
literal|2
expr_stmt|;
name|cs
operator|->
name|cs_zc
operator|=
operator|&
name|addr
operator|->
name|zs_chan
index|[
name|CHAN_B
index|]
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|makedev
argument_list|(
name|ZSMAJOR
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|zsstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|zsparam
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|zsstop
expr_stmt|;
if|if
condition|(
operator|(
name|ctp
operator|=
name|zs_checkcons
argument_list|(
name|zi
argument_list|,
name|unit
argument_list|,
name|cs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|tp
operator|=
name|ctp
expr_stmt|;
name|cs
operator|->
name|cs_ttyp
operator|=
name|tp
expr_stmt|;
ifdef|#
directive|ifdef
name|KGDB
if|if
condition|(
name|ctp
operator|==
name|NULL
condition|)
name|zs_checkkgdb
argument_list|(
name|unit
argument_list|,
name|cs
argument_list|,
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unit
operator|==
name|ZS_MOUSE
condition|)
block|{
comment|/* 		 * Mouse: tell /dev/mouse driver how to talk to us. 		 */
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|cs
operator|->
name|cs_speed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|CS8
expr_stmt|;
name|ms_serial
argument_list|(
name|tp
argument_list|,
name|zsiopen
argument_list|,
name|zsiclose
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Put a channel in a known state.  Interrupts may be left disabled  * or enabled, as desired.  */
end_comment

begin_function
specifier|static
name|void
name|zs_reset
parameter_list|(
name|zc
parameter_list|,
name|inten
parameter_list|,
name|speed
parameter_list|)
specifier|volatile
name|struct
name|zschan
modifier|*
name|zc
decl_stmt|;
name|int
name|inten
decl_stmt|,
name|speed
decl_stmt|;
block|{
name|int
name|tconst
decl_stmt|;
specifier|static
name|u_char
name|reg
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ZSWR3_RX_8
operator||
name|ZSWR3_RX_ENABLE
block|,
name|ZSWR4_CLK_X16
operator||
name|ZSWR4_ONESB
operator||
name|ZSWR4_EVENP
block|,
name|ZSWR5_TX_8
operator||
name|ZSWR5_TX_ENABLE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ZSWR10_NRZ
block|,
name|ZSWR11_TXCLK_BAUD
operator||
name|ZSWR11_RXCLK_BAUD
block|,
literal|0
block|,
literal|0
block|,
name|ZSWR14_BAUD_FROM_PCLK
operator||
name|ZSWR14_BAUD_ENA
block|,
name|ZSWR15_BREAK_IE
operator||
name|ZSWR15_DCD_IE
block|, 	}
decl_stmt|;
name|reg
index|[
literal|9
index|]
operator|=
name|inten
condition|?
name|ZSWR9_MASTER_IE
operator||
name|ZSWR9_NO_VECTOR
else|:
name|ZSWR9_NO_VECTOR
expr_stmt|;
name|tconst
operator|=
name|BPS_TO_TCONST
argument_list|(
name|PCLK
operator|/
literal|16
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|reg
index|[
literal|12
index|]
operator|=
name|tconst
expr_stmt|;
name|reg
index|[
literal|13
index|]
operator|=
name|tconst
operator|>>
literal|8
expr_stmt|;
name|zs_loadchannelregs
argument_list|(
name|zc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Declare the given tty (which is in fact&cons) as a console input  * or output.  This happens before the zs chip is attached; the hookup  * is finished later, in zs_setcons() below.  *  * This is used only for ports a and b.  The console keyboard is decoded  * independently (we always send unit-2 input to /dev/kbd, which will  * direct it to /dev/console if appropriate).  */
end_comment

begin_function
name|void
name|zsconsole
parameter_list|(
name|tp
parameter_list|,
name|unit
parameter_list|,
name|out
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|int
name|out
decl_stmt|;
block|{
specifier|extern
name|int
function_decl|(
modifier|*
name|v_putc
function_decl|)
parameter_list|()
function_decl|;
name|int
name|zs
decl_stmt|;
specifier|volatile
name|struct
name|zsdevice
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|ZS_KBD
condition|)
name|panic
argument_list|(
literal|"zsconsole"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
condition|)
block|{
name|zs_consout
operator|=
name|unit
expr_stmt|;
name|zs
operator|=
name|unit
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
name|zsaddr
index|[
name|zs
index|]
operator|)
operator|==
name|NULL
condition|)
name|addr
operator|=
name|zsaddr
index|[
name|zs
index|]
operator|=
name|findzs
argument_list|(
name|zs
argument_list|)
expr_stmt|;
name|zs_conschan
operator|=
operator|(
name|unit
operator|&
literal|1
operator|)
operator|==
literal|0
condition|?
operator|&
name|addr
operator|->
name|zs_chan
index|[
name|CHAN_A
index|]
else|:
operator|&
name|addr
operator|->
name|zs_chan
index|[
name|CHAN_B
index|]
expr_stmt|;
name|v_putc
operator|=
name|zscnputc
expr_stmt|;
block|}
else|else
name|zs_consin
operator|=
name|unit
expr_stmt|;
name|zs_ctty
operator|=
name|tp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Polled console output putchar.  */
end_comment

begin_function
specifier|static
name|int
name|zscnputc
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|zschan
modifier|*
name|zc
init|=
name|zs_conschan
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|zscnputc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
comment|/* 	 * Must block output interrupts (i.e., raise to>= splzs) without 	 * lowering current ipl.  Need a better way. 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|sun4c
comment|/* XXX */
if|if
condition|(
name|s
operator|<=
operator|(
literal|12
operator|<<
literal|8
operator|)
condition|)
operator|(
name|void
operator|)
name|splzs
argument_list|()
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|zc
operator|->
name|zc_csr
operator|&
name|ZSRR0_TX_READY
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|zc
operator|->
name|zc_data
operator|=
name|c
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up the given unit as console input, output, both, or neither, as  * needed.  Return console tty if it is to receive console input.  */
end_comment

begin_function
specifier|static
name|struct
name|tty
modifier|*
name|zs_checkcons
parameter_list|(
name|struct
name|zsinfo
modifier|*
name|zi
parameter_list|,
name|int
name|unit
parameter_list|,
name|struct
name|zs_chanstate
modifier|*
name|cs
parameter_list|)
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|i
decl_stmt|,
modifier|*
name|o
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|zs_ctty
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i
operator|=
name|zs_consin
operator|==
name|unit
condition|?
literal|"input"
else|:
name|NULL
expr_stmt|;
name|o
operator|=
name|zs_consout
operator|==
name|unit
condition|?
literal|"output"
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
operator|&&
name|o
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* rewire the minor device (gack) */
name|tp
operator|->
name|t_dev
operator|=
name|makedev
argument_list|(
name|major
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* 	 * Rewire input and/or output.  Note that baud rate reflects 	 * input settings, not output settings, but we can do no better 	 * if the console is split across two ports. 	 * 	 * XXX	split consoles don't work anyway -- this needs to be 	 *	thrown away and redone 	 */
if|if
condition|(
name|i
condition|)
block|{
name|tp
operator|->
name|t_param
operator|=
name|zsparam
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|cs
operator|->
name|cs_speed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|CS8
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
condition|)
block|{
name|tp
operator|->
name|t_oproc
operator|=
name|zsstart
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|zsstop
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s%c: console %s\n"
argument_list|,
name|zi
operator|->
name|zi_dev
operator|.
name|dv_xname
argument_list|,
operator|(
name|unit
operator|&
literal|1
operator|)
operator|+
literal|'a'
argument_list|,
name|i
condition|?
operator|(
name|o
condition|?
literal|"i/o"
else|:
name|i
operator|)
else|:
name|o
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_consio
operator|=
literal|1
expr_stmt|;
name|cs
operator|->
name|cs_brkabort
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KGDB
end_ifdef

begin_comment
comment|/*  * The kgdb zs port, if any, was altered at boot time (see zs_kgdb_init).  * Pick up the current speed and character size and restore the original  * speed.  */
end_comment

begin_function
specifier|static
name|void
name|zs_checkkgdb
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|zs_chanstate
modifier|*
name|cs
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
if|if
condition|(
name|kgdb_dev
operator|==
name|makedev
argument_list|(
name|ZSMAJOR
argument_list|,
name|unit
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|kgdb_rate
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|CS8
expr_stmt|;
name|cs
operator|->
name|cs_kgdb
operator|=
literal|1
expr_stmt|;
name|cs
operator|->
name|cs_speed
operator|=
name|zs_kgdb_savedspeed
expr_stmt|;
operator|(
name|void
operator|)
name|zsparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Compute the current baud rate given a ZSCC channel.  */
end_comment

begin_function
specifier|static
name|int
name|zs_getspeed
parameter_list|(
name|zc
parameter_list|)
specifier|register
specifier|volatile
name|struct
name|zschan
modifier|*
name|zc
decl_stmt|;
block|{
specifier|register
name|int
name|tconst
decl_stmt|;
name|tconst
operator|=
name|ZS_READ
argument_list|(
name|zc
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|tconst
operator||=
name|ZS_READ
argument_list|(
name|zc
argument_list|,
literal|13
argument_list|)
operator|<<
literal|8
expr_stmt|;
return|return
operator|(
name|TCONST_TO_BPS
argument_list|(
name|PCLK
operator|/
literal|16
argument_list|,
name|tconst
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do an internal open.  */
end_comment

begin_function
specifier|static
name|void
name|zsiopen
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|zsparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TS_ISOPEN
operator||
name|TS_CARR_ON
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do an internal close.  Eventually we should shut off the chip when both  * ports on it are closed.  */
end_comment

begin_function
specifier|static
name|void
name|zsiclose
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|ttylclose
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? */
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* ??? */
name|tp
operator|->
name|t_state
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open a zs serial port.  This interface may not be used to open  * the keyboard and mouse ports. (XXX)  */
end_comment

begin_function
name|int
name|zsopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|zs_chanstate
modifier|*
name|cs
decl_stmt|;
name|struct
name|zsinfo
modifier|*
name|zi
decl_stmt|;
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|zs
init|=
name|unit
operator|>>
literal|1
decl_stmt|,
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|zs
operator|>=
name|zscd
operator|.
name|cd_ndevs
operator|||
operator|(
name|zi
operator|=
name|zscd
operator|.
name|cd_devs
index|[
name|zs
index|]
operator|)
operator|==
name|NULL
operator|||
name|unit
operator|==
name|ZS_KBD
operator|||
name|unit
operator|==
name|ZS_MOUSE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|cs
operator|=
operator|&
name|zi
operator|->
name|zi_cs
index|[
name|unit
operator|&
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_consio
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* ??? */
name|tp
operator|=
name|cs
operator|->
name|cs_ttyp
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|cs
operator|->
name|cs_speed
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zsparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* loop, turning on the device, until carrier present */
name|zs_modem
argument_list|(
name|cs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_softcar
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
operator|||
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|||
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
condition|)
break|break;
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|ttysleep
argument_list|(
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
name|ttopen
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
argument_list|(
name|dev
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|zs_modem
argument_list|(
name|cs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a zs serial port.  */
end_comment

begin_function
name|int
name|zsclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|zs_chanstate
modifier|*
name|cs
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|zsinfo
modifier|*
name|zi
decl_stmt|;
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|s
decl_stmt|;
name|zi
operator|=
name|zscd
operator|.
name|cd_devs
index|[
name|unit
operator|>>
literal|1
index|]
expr_stmt|;
name|cs
operator|=
operator|&
name|zi
operator|->
name|zi_cs
index|[
name|unit
operator|&
literal|1
index|]
expr_stmt|;
name|tp
operator|=
name|cs
operator|->
name|cs_ttyp
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
argument_list|(
name|tp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|||
name|tp
operator|->
name|t_state
operator|&
name|TS_WOPEN
operator|||
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|zs_modem
argument_list|(
name|cs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* hold low for 1 second */
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|cs
argument_list|,
name|TTIPRI
argument_list|,
name|ttclos
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KGDB
comment|/* Reset the speed if we're doing kgdb on this port */
if|if
condition|(
name|cs
operator|->
name|cs_kgdb
condition|)
block|{
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|kgdb_rate
expr_stmt|;
operator|(
name|void
operator|)
name|zsparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read/write zs serial port.  */
end_comment

begin_function
name|int
name|zsread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|zs_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
return|return
operator|(
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zswrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|zs_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
return|return
operator|(
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ZS hardware interrupt.  Scan all ZS channels.  NB: we know here that  * channels are kept in (A,B) pairs.  *  * Do just a little, then get out; set a software interrupt if more  * work is needed.  *  * We deliberately ignore the vectoring Zilog gives us, and match up  * only the number of `reset interrupt under service' operations, not  * the order.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zshard
parameter_list|(
name|void
modifier|*
name|intrarg
parameter_list|)
block|{
specifier|register
name|struct
name|zs_chanstate
modifier|*
name|a
decl_stmt|;
define|#
directive|define
name|b
value|(a + 1)
specifier|register
specifier|volatile
name|struct
name|zschan
modifier|*
name|zc
decl_stmt|;
specifier|register
name|int
name|rr3
decl_stmt|,
name|intflags
init|=
literal|0
decl_stmt|,
name|v
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|int
name|zsrint
argument_list|(
expr|struct
name|zs_chanstate
operator|*
argument_list|,
specifier|volatile
expr|struct
name|zschan
operator|*
argument_list|)
decl_stmt|;
specifier|static
name|int
name|zsxint
argument_list|(
expr|struct
name|zs_chanstate
operator|*
argument_list|,
specifier|volatile
expr|struct
name|zschan
operator|*
argument_list|)
decl_stmt|;
specifier|static
name|int
name|zssint
argument_list|(
expr|struct
name|zs_chanstate
operator|*
argument_list|,
specifier|volatile
expr|struct
name|zschan
operator|*
argument_list|)
decl_stmt|;
for|for
control|(
name|a
operator|=
name|zslist
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|b
operator|->
name|cs_next
control|)
block|{
name|rr3
operator|=
name|ZS_READ
argument_list|(
name|a
operator|->
name|cs_zc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|rr3
operator|&
operator|(
name|ZSRR3_IP_A_RX
operator||
name|ZSRR3_IP_A_TX
operator||
name|ZSRR3_IP_A_STAT
operator|)
condition|)
block|{
name|intflags
operator||=
literal|2
expr_stmt|;
name|zc
operator|=
name|a
operator|->
name|cs_zc
expr_stmt|;
name|i
operator|=
name|a
operator|->
name|cs_rbput
expr_stmt|;
if|if
condition|(
name|rr3
operator|&
name|ZSRR3_IP_A_RX
operator|&&
operator|(
name|v
operator|=
name|zsrint
argument_list|(
name|a
argument_list|,
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|a
operator|->
name|cs_rbuf
index|[
name|i
operator|++
operator|&
name|ZLRB_RING_MASK
index|]
operator|=
name|v
expr_stmt|;
name|intflags
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rr3
operator|&
name|ZSRR3_IP_A_TX
operator|&&
operator|(
name|v
operator|=
name|zsxint
argument_list|(
name|a
argument_list|,
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|a
operator|->
name|cs_rbuf
index|[
name|i
operator|++
operator|&
name|ZLRB_RING_MASK
index|]
operator|=
name|v
expr_stmt|;
name|intflags
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rr3
operator|&
name|ZSRR3_IP_A_STAT
operator|&&
operator|(
name|v
operator|=
name|zssint
argument_list|(
name|a
argument_list|,
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|a
operator|->
name|cs_rbuf
index|[
name|i
operator|++
operator|&
name|ZLRB_RING_MASK
index|]
operator|=
name|v
expr_stmt|;
name|intflags
operator||=
literal|1
expr_stmt|;
block|}
name|a
operator|->
name|cs_rbput
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|rr3
operator|&
operator|(
name|ZSRR3_IP_B_RX
operator||
name|ZSRR3_IP_B_TX
operator||
name|ZSRR3_IP_B_STAT
operator|)
condition|)
block|{
name|intflags
operator||=
literal|2
expr_stmt|;
name|zc
operator|=
name|b
operator|->
name|cs_zc
expr_stmt|;
name|i
operator|=
name|b
operator|->
name|cs_rbput
expr_stmt|;
if|if
condition|(
name|rr3
operator|&
name|ZSRR3_IP_B_RX
operator|&&
operator|(
name|v
operator|=
name|zsrint
argument_list|(
name|b
argument_list|,
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|b
operator|->
name|cs_rbuf
index|[
name|i
operator|++
operator|&
name|ZLRB_RING_MASK
index|]
operator|=
name|v
expr_stmt|;
name|intflags
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rr3
operator|&
name|ZSRR3_IP_B_TX
operator|&&
operator|(
name|v
operator|=
name|zsxint
argument_list|(
name|b
argument_list|,
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|b
operator|->
name|cs_rbuf
index|[
name|i
operator|++
operator|&
name|ZLRB_RING_MASK
index|]
operator|=
name|v
expr_stmt|;
name|intflags
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rr3
operator|&
name|ZSRR3_IP_B_STAT
operator|&&
operator|(
name|v
operator|=
name|zssint
argument_list|(
name|b
argument_list|,
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|b
operator|->
name|cs_rbuf
index|[
name|i
operator|++
operator|&
name|ZLRB_RING_MASK
index|]
operator|=
name|v
expr_stmt|;
name|intflags
operator||=
literal|1
expr_stmt|;
block|}
name|b
operator|->
name|cs_rbput
operator|=
name|i
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|b
if|if
condition|(
name|intflags
operator|&
literal|1
condition|)
block|{
if|#
directive|if
name|sun4c
comment|/* XXX -- but this will go away when zshard moves to locore.s */
name|struct
name|clockframe
modifier|*
name|p
init|=
name|intrarg
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|psr
operator|&
name|PSR_PIL
operator|)
operator|<
operator|(
name|PIL_TTY
operator|<<
literal|8
operator|)
condition|)
block|{
name|zsshortcuts
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|zshardscope
condition|)
block|{
name|LED_ON
expr_stmt|;
name|LED_OFF
expr_stmt|;
block|}
return|return
operator|(
name|zssoft
argument_list|(
name|intrarg
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
name|ienab_bis
argument_list|(
name|IE_ZSSOFT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|intflags
operator|&
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zsrint
parameter_list|(
specifier|register
name|struct
name|zs_chanstate
modifier|*
name|cs
parameter_list|,
specifier|register
specifier|volatile
name|struct
name|zschan
modifier|*
name|zc
parameter_list|)
block|{
specifier|register
name|int
name|c
init|=
name|zc
operator|->
name|zc_data
decl_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_conk
condition|)
block|{
specifier|register
name|struct
name|conk_state
modifier|*
name|conk
init|=
operator|&
name|zsconk_state
decl_stmt|;
comment|/* 		 * Check here for console abort function, so that we 		 * can abort even when interrupts are locking up the 		 * machine. 		 */
if|if
condition|(
name|c
operator|==
name|KBD_RESET
condition|)
block|{
name|conk
operator|->
name|conk_id
operator|=
literal|1
expr_stmt|;
comment|/* ignore next byte */
name|conk
operator|->
name|conk_l1
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conk
operator|->
name|conk_id
condition|)
name|conk
operator|->
name|conk_id
operator|=
literal|0
expr_stmt|;
comment|/* stop ignoring bytes */
elseif|else
if|if
condition|(
name|c
operator|==
name|KBD_L1
condition|)
name|conk
operator|->
name|conk_l1
operator|=
literal|1
expr_stmt|;
comment|/* L1 went down */
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
name|KBD_L1
operator||
name|KBD_UP
operator|)
condition|)
name|conk
operator|->
name|conk_l1
operator|=
literal|0
expr_stmt|;
comment|/* L1 went up */
elseif|else
if|if
condition|(
name|c
operator|==
name|KBD_A
operator|&&
name|conk
operator|->
name|conk_l1
condition|)
block|{
name|zsabort
argument_list|()
expr_stmt|;
name|conk
operator|->
name|conk_l1
operator|=
literal|0
expr_stmt|;
comment|/* we never see the up */
goto|goto
name|clearit
goto|;
comment|/* eat the A after L1-A */
block|}
block|}
ifdef|#
directive|ifdef
name|KGDB
if|if
condition|(
name|c
operator|==
name|FRAME_START
operator|&&
name|cs
operator|->
name|cs_kgdb
operator|&&
operator|(
name|cs
operator|->
name|cs_ttyp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|zskgdb
argument_list|(
name|cs
operator|->
name|cs_unit
argument_list|)
expr_stmt|;
goto|goto
name|clearit
goto|;
block|}
endif|#
directive|endif
comment|/* compose receive character and status */
name|c
operator|<<=
literal|8
expr_stmt|;
name|c
operator||=
name|ZS_READ
argument_list|(
name|zc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* clear receive error& interrupt condition */
name|zc
operator|->
name|zc_csr
operator|=
name|ZSWR0_RESET_ERRORS
expr_stmt|;
name|zc
operator|->
name|zc_csr
operator|=
name|ZSWR0_CLR_INTR
expr_stmt|;
return|return
operator|(
name|ZRING_MAKE
argument_list|(
name|ZRING_RINT
argument_list|,
name|c
argument_list|)
operator|)
return|;
name|clearit
label|:
name|zc
operator|->
name|zc_csr
operator|=
name|ZSWR0_RESET_ERRORS
expr_stmt|;
name|zc
operator|->
name|zc_csr
operator|=
name|ZSWR0_CLR_INTR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zsxint
parameter_list|(
specifier|register
name|struct
name|zs_chanstate
modifier|*
name|cs
parameter_list|,
specifier|register
specifier|volatile
name|struct
name|zschan
modifier|*
name|zc
parameter_list|)
block|{
specifier|register
name|int
name|i
init|=
name|cs
operator|->
name|cs_tbc
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|zc
operator|->
name|zc_csr
operator|=
name|ZSWR0_RESET_TXINT
expr_stmt|;
name|zc
operator|->
name|zc_csr
operator|=
name|ZSWR0_CLR_INTR
expr_stmt|;
return|return
operator|(
name|ZRING_MAKE
argument_list|(
name|ZRING_XINT
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
name|cs
operator|->
name|cs_tbc
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|zc
operator|->
name|zc_data
operator|=
operator|*
name|cs
operator|->
name|cs_tba
operator|++
expr_stmt|;
name|zc
operator|->
name|zc_csr
operator|=
name|ZSWR0_CLR_INTR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zssint
parameter_list|(
specifier|register
name|struct
name|zs_chanstate
modifier|*
name|cs
parameter_list|,
specifier|register
specifier|volatile
name|struct
name|zschan
modifier|*
name|zc
parameter_list|)
block|{
specifier|register
name|int
name|rr0
decl_stmt|;
name|rr0
operator|=
name|zc
operator|->
name|zc_csr
expr_stmt|;
name|zc
operator|->
name|zc_csr
operator|=
name|ZSWR0_RESET_STATUS
expr_stmt|;
name|zc
operator|->
name|zc_csr
operator|=
name|ZSWR0_CLR_INTR
expr_stmt|;
comment|/* 	 * The chip's hardware flow control is, as noted in zsreg.h, 	 * busted---if the DCD line goes low the chip shuts off the 	 * receiver (!).  If we want hardware CTS flow control but do 	 * not have it, and carrier is now on, turn HFC on; if we have 	 * HFC now but carrier has gone low, turn it off. 	 */
if|if
condition|(
name|rr0
operator|&
name|ZSRR0_DCD
condition|)
block|{
if|if
condition|(
name|cs
operator|->
name|cs_ttyp
operator|->
name|t_cflag
operator|&
name|CCTS_OFLOW
operator|&&
operator|(
name|cs
operator|->
name|cs_creg
index|[
literal|3
index|]
operator|&
name|ZSWR3_HFC
operator|)
operator|==
literal|0
condition|)
block|{
name|cs
operator|->
name|cs_creg
index|[
literal|3
index|]
operator||=
name|ZSWR3_HFC
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|3
argument_list|,
name|cs
operator|->
name|cs_creg
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cs
operator|->
name|cs_creg
index|[
literal|3
index|]
operator|&
name|ZSWR3_HFC
condition|)
block|{
name|cs
operator|->
name|cs_creg
index|[
literal|3
index|]
operator|&=
operator|~
name|ZSWR3_HFC
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|3
argument_list|,
name|cs
operator|->
name|cs_creg
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|rr0
operator|&
name|ZSRR0_BREAK
operator|)
operator|&&
name|cs
operator|->
name|cs_brkabort
condition|)
block|{
name|zsabort
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ZRING_MAKE
argument_list|(
name|ZRING_SINT
argument_list|,
name|rr0
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|zsabort
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"stopping on keyboard abort\n"
argument_list|)
expr_stmt|;
name|callrom
argument_list|()
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|KGDB
end_ifdef

begin_comment
comment|/*  * KGDB framing character received: enter kernel debugger.  This probably  * should time out after a few seconds to avoid hanging on spurious input.  */
end_comment

begin_macro
name|zskgdb
argument_list|(
argument|int unit
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"zs%d%c: kgdb interrupt\n"
argument_list|,
name|unit
operator|>>
literal|1
argument_list|,
operator|(
name|unit
operator|&
literal|1
operator|)
operator|+
literal|'a'
argument_list|)
expr_stmt|;
name|kgdb_connect
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Print out a ring or fifo overrun error message.  */
end_comment

begin_function
specifier|static
name|void
name|zsoverrun
parameter_list|(
name|int
name|unit
parameter_list|,
name|long
modifier|*
name|ptime
parameter_list|,
name|char
modifier|*
name|what
parameter_list|)
block|{
if|if
condition|(
operator|*
name|ptime
operator|!=
name|time
operator|.
name|tv_sec
condition|)
block|{
operator|*
name|ptime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"zs%d%c: %s overrun\n"
argument_list|,
name|unit
operator|>>
literal|1
argument_list|,
operator|(
name|unit
operator|&
literal|1
operator|)
operator|+
literal|'a'
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ZS software interrupt.  Scan all channels for deferred interrupts.  */
end_comment

begin_function
name|int
name|zssoft
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|register
name|struct
name|zs_chanstate
modifier|*
name|cs
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|zschan
modifier|*
name|zc
decl_stmt|;
specifier|register
name|struct
name|linesw
modifier|*
name|line
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|get
decl_stmt|,
name|n
decl_stmt|,
name|c
decl_stmt|,
name|cc
decl_stmt|,
name|unit
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|cs
operator|=
name|zslist
init|;
name|cs
operator|!=
name|NULL
condition|;
name|cs
operator|=
name|cs
operator|->
name|cs_next
control|)
block|{
name|get
operator|=
name|cs
operator|->
name|cs_rbget
expr_stmt|;
name|again
label|:
name|n
operator|=
name|cs
operator|->
name|cs_rbput
expr_stmt|;
comment|/* atomic */
if|if
condition|(
name|get
operator|==
name|n
condition|)
comment|/* nothing more on this line */
continue|continue;
name|unit
operator|=
name|cs
operator|->
name|cs_unit
expr_stmt|;
comment|/* set up to handle interrupts */
name|zc
operator|=
name|cs
operator|->
name|cs_zc
expr_stmt|;
name|tp
operator|=
name|cs
operator|->
name|cs_ttyp
expr_stmt|;
name|line
operator|=
operator|&
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
expr_stmt|;
comment|/* 		 * Compute the number of interrupts in the receive ring. 		 * If the count is overlarge, we lost some events, and 		 * must advance to the first valid one.  It may get 		 * overwritten if more data are arriving, but this is 		 * too expensive to check and gains nothing (we already 		 * lost out; all we can do at this point is trade one 		 * kind of loss for another). 		 */
name|n
operator|-=
name|get
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|ZLRB_RING_SIZE
condition|)
block|{
name|zsoverrun
argument_list|(
name|unit
argument_list|,
operator|&
name|cs
operator|->
name|cs_rotime
argument_list|,
literal|"ring"
argument_list|)
expr_stmt|;
name|get
operator|+=
name|n
operator|-
name|ZLRB_RING_SIZE
expr_stmt|;
name|n
operator|=
name|ZLRB_RING_SIZE
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* race to keep ahead of incoming interrupts */
name|c
operator|=
name|cs
operator|->
name|cs_rbuf
index|[
name|get
operator|++
operator|&
name|ZLRB_RING_MASK
index|]
expr_stmt|;
switch|switch
condition|(
name|ZRING_TYPE
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|ZRING_RINT
case|:
name|c
operator|=
name|ZRING_VALUE
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|ZSRR1_DO
condition|)
name|zsoverrun
argument_list|(
name|unit
argument_list|,
operator|&
name|cs
operator|->
name|cs_fotime
argument_list|,
literal|"fifo"
argument_list|)
expr_stmt|;
name|cc
operator|=
name|c
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|ZSRR1_FE
condition|)
name|cc
operator||=
name|TTY_FE
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|ZSRR1_PE
condition|)
name|cc
operator||=
name|TTY_PE
expr_stmt|;
comment|/* 				 * this should be done through 				 * bstreams	XXX gag choke 				 */
if|if
condition|(
name|unit
operator|==
name|ZS_KBD
condition|)
name|kbd_rint
argument_list|(
name|cc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unit
operator|==
name|ZS_MOUSE
condition|)
name|ms_rint
argument_list|(
name|cc
argument_list|)
expr_stmt|;
else|else
name|line
operator|->
name|l_rint
argument_list|(
name|cc
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZRING_XINT
case|:
comment|/* 				 * Transmit done: change registers and resume, 				 * or clear BUSY. 				 */
if|if
condition|(
name|cs
operator|->
name|cs_heldchange
condition|)
block|{
name|s
operator|=
name|splzs
argument_list|()
expr_stmt|;
name|c
operator|=
name|zc
operator|->
name|zc_csr
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
name|ZSRR0_DCD
operator|)
operator|==
literal|0
condition|)
name|cs
operator|->
name|cs_preg
index|[
literal|3
index|]
operator|&=
operator|~
name|ZSWR3_HFC
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|cs
operator|->
name|cs_preg
argument_list|,
operator|(
name|caddr_t
operator|)
name|cs
operator|->
name|cs_creg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|zs_loadchannelregs
argument_list|(
name|zc
argument_list|,
name|cs
operator|->
name|cs_creg
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_heldchange
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_heldtbc
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
block|{
name|cs
operator|->
name|cs_tbc
operator|=
name|cs
operator|->
name|cs_heldtbc
operator|-
literal|1
expr_stmt|;
name|zc
operator|->
name|zc_data
operator|=
operator|*
name|cs
operator|->
name|cs_tba
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_FLUSH
expr_stmt|;
else|else
name|ndflush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|cs
operator|->
name|cs_tba
operator|-
name|tp
operator|->
name|t_outq
operator|.
name|c_cf
argument_list|)
expr_stmt|;
name|line
operator|->
name|l_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZRING_SINT
case|:
comment|/* 				 * Status line change.  HFC bit is run in 				 * hardware interrupt, to avoid locking 				 * at splzs here. 				 */
name|c
operator|=
name|ZRING_VALUE
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|^
name|cs
operator|->
name|cs_rr0
operator|)
operator|&
name|ZSRR0_DCD
condition|)
block|{
name|cc
operator|=
operator|(
name|c
operator|&
name|ZSRR0_DCD
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|line
operator|->
name|l_modem
argument_list|(
name|tp
argument_list|,
name|cc
argument_list|)
operator|==
literal|0
condition|)
name|zs_modem
argument_list|(
name|cs
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
name|cs
operator|->
name|cs_rr0
operator|=
name|c
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"zs%d%c: bad ZRING_TYPE (%x)\n"
argument_list|,
name|unit
operator|>>
literal|1
argument_list|,
operator|(
name|unit
operator|&
literal|1
operator|)
operator|+
literal|'a'
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|cs
operator|->
name|cs_rbget
operator|=
name|get
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zsioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|zsinfo
modifier|*
name|zi
init|=
name|zscd
operator|.
name|cd_devs
index|[
name|unit
operator|>>
literal|1
index|]
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
name|zi
operator|->
name|zi_cs
index|[
name|unit
operator|&
literal|1
index|]
operator|.
name|cs_ttyp
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
name|error
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
comment|/* FINISH ME ... need implicit TIOCCBRK in zsclose as well */
case|case
name|TIOCCBRK
case|:
case|case
name|TIOCSDTR
case|:
case|case
name|TIOCCDTR
case|:
case|case
name|TIOCMSET
case|:
case|case
name|TIOCMBIS
case|:
case|case
name|TIOCMBIC
case|:
case|case
name|TIOCMGET
case|:
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start or restart transmission.  */
end_comment

begin_function
specifier|static
name|void
name|zsstart
parameter_list|(
specifier|register
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
specifier|register
name|struct
name|zs_chanstate
modifier|*
name|cs
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|nch
decl_stmt|;
name|int
name|unit
init|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
name|struct
name|zsinfo
modifier|*
name|zi
init|=
name|zscd
operator|.
name|cd_devs
index|[
name|unit
operator|>>
literal|1
index|]
decl_stmt|;
name|cs
operator|=
operator|&
name|zi
operator|->
name|zi_cs
index|[
name|unit
operator|&
literal|1
index|]
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* 	 * If currently active or delaying, no need to do anything. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * If there are sleepers, and output has drained below low 	 * water mark, awaken. 	 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
name|nch
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|nch
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|tp
operator|->
name|t_outq
operator|.
name|c_cf
decl_stmt|;
comment|/* mark busy, enable tx done interrupts,& send first byte */
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
operator|(
name|void
operator|)
name|splzs
argument_list|()
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|1
index|]
operator||=
name|ZSWR1_TIE
expr_stmt|;
name|cs
operator|->
name|cs_creg
index|[
literal|1
index|]
operator||=
name|ZSWR1_TIE
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|cs
operator|->
name|cs_zc
argument_list|,
literal|1
argument_list|,
name|cs
operator|->
name|cs_creg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_zc
operator|->
name|zc_data
operator|=
operator|*
name|p
expr_stmt|;
name|cs
operator|->
name|cs_tba
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|cs
operator|->
name|cs_tbc
operator|=
name|nch
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Nothing to send, turn off transmit done interrupts. 		 * This is useful if something is doing polled output. 		 */
operator|(
name|void
operator|)
name|splzs
argument_list|()
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|1
index|]
operator|&=
operator|~
name|ZSWR1_TIE
expr_stmt|;
name|cs
operator|->
name|cs_creg
index|[
literal|1
index|]
operator|&=
operator|~
name|ZSWR1_TIE
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|cs
operator|->
name|cs_zc
argument_list|,
literal|1
argument_list|,
name|cs
operator|->
name|cs_creg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop output, e.g., for ^S or output flush.  */
end_comment

begin_function
specifier|static
name|void
name|zsstop
parameter_list|(
specifier|register
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|struct
name|zs_chanstate
modifier|*
name|cs
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|unit
init|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
name|struct
name|zsinfo
modifier|*
name|zi
init|=
name|zscd
operator|.
name|cd_devs
index|[
name|unit
operator|>>
literal|1
index|]
decl_stmt|;
name|cs
operator|=
operator|&
name|zi
operator|->
name|zi_cs
index|[
name|unit
operator|&
literal|1
index|]
expr_stmt|;
name|s
operator|=
name|splzs
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
comment|/* 		 * Device is transmitting; must stop it. 		 */
name|cs
operator|->
name|cs_tbc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set ZS tty parameters from termios.  *  * This routine makes use of the fact that only registers  * 1, 3, 4, 5, 9, 10, 11, 12, 13, 14, and 15 are written.  */
end_comment

begin_function
specifier|static
name|int
name|zsparam
parameter_list|(
specifier|register
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
specifier|register
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
name|struct
name|zsinfo
modifier|*
name|zi
init|=
name|zscd
operator|.
name|cd_devs
index|[
name|unit
operator|>>
literal|1
index|]
decl_stmt|;
specifier|register
name|struct
name|zs_chanstate
modifier|*
name|cs
init|=
operator|&
name|zi
operator|->
name|zi_cs
index|[
name|unit
operator|&
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|tmp
decl_stmt|,
name|tmp5
decl_stmt|,
name|cflag
decl_stmt|,
name|s
decl_stmt|;
comment|/* 	 * Because PCLK is only run at 4.9 MHz, the fastest we 	 * can go is 51200 baud (this corresponds to TC=1). 	 * This is somewhat unfortunate as there is no real 	 * reason we should not be able to handle higher rates. 	 */
name|tmp
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0
operator|||
operator|(
name|t
operator|->
name|c_ispeed
operator|&&
name|t
operator|->
name|c_ispeed
operator|!=
name|tmp
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
block|{
comment|/* stty 0 => drop DTR and RTS */
name|zs_modem
argument_list|(
name|cs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tmp
operator|=
name|BPS_TO_TCONST
argument_list|(
name|PCLK
operator|/
literal|16
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|TCONST_TO_BPS
argument_list|(
name|PCLK
operator|/
literal|16
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|cflag
expr_stmt|;
comment|/* 	 * Block interrupts so that state will not 	 * be altered until we are done setting it up. 	 */
name|s
operator|=
name|splzs
argument_list|()
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|12
index|]
operator|=
name|tmp
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|13
index|]
operator|=
name|tmp
operator|>>
literal|8
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|1
index|]
operator|=
name|ZSWR1_RIE
operator||
name|ZSWR1_TIE
operator||
name|ZSWR1_SIE
expr_stmt|;
switch|switch
condition|(
name|cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|tmp
operator|=
name|ZSWR3_RX_5
expr_stmt|;
name|tmp5
operator|=
name|ZSWR5_TX_5
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|tmp
operator|=
name|ZSWR3_RX_6
expr_stmt|;
name|tmp5
operator|=
name|ZSWR5_TX_6
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|tmp
operator|=
name|ZSWR3_RX_7
expr_stmt|;
name|tmp5
operator|=
name|ZSWR5_TX_7
expr_stmt|;
break|break;
case|case
name|CS8
case|:
default|default:
name|tmp
operator|=
name|ZSWR3_RX_8
expr_stmt|;
name|tmp5
operator|=
name|ZSWR5_TX_8
expr_stmt|;
break|break;
block|}
comment|/* 	 * Output hardware flow control on the chip is horrendous: if 	 * carrier detect drops, the receiver is disabled.  Hence we 	 * can only do this when the carrier is on. 	 */
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
operator|&&
name|cs
operator|->
name|cs_zc
operator|->
name|zc_csr
operator|&
name|ZSRR0_DCD
condition|)
name|tmp
operator||=
name|ZSWR3_HFC
operator||
name|ZSWR3_RX_ENABLE
expr_stmt|;
else|else
name|tmp
operator||=
name|ZSWR3_RX_ENABLE
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|3
index|]
operator|=
name|tmp
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|5
index|]
operator|=
name|tmp5
operator||
name|ZSWR5_TX_ENABLE
operator||
name|ZSWR5_DTR
operator||
name|ZSWR5_RTS
expr_stmt|;
name|tmp
operator|=
name|ZSWR4_CLK_X16
operator||
operator|(
name|cflag
operator|&
name|CSTOPB
condition|?
name|ZSWR4_TWOSB
else|:
name|ZSWR4_ONESB
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|PARODD
operator|)
operator|==
literal|0
condition|)
name|tmp
operator||=
name|ZSWR4_EVENP
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
name|tmp
operator||=
name|ZSWR4_PARENB
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|4
index|]
operator|=
name|tmp
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|9
index|]
operator|=
name|ZSWR9_MASTER_IE
operator||
name|ZSWR9_NO_VECTOR
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|10
index|]
operator|=
name|ZSWR10_NRZ
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|11
index|]
operator|=
name|ZSWR11_TXCLK_BAUD
operator||
name|ZSWR11_RXCLK_BAUD
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|14
index|]
operator|=
name|ZSWR14_BAUD_FROM_PCLK
operator||
name|ZSWR14_BAUD_ENA
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|15
index|]
operator|=
name|ZSWR15_BREAK_IE
operator||
name|ZSWR15_DCD_IE
expr_stmt|;
comment|/* 	 * If nothing is being transmitted, set up new current values, 	 * else mark them as pending. 	 */
if|if
condition|(
name|cs
operator|->
name|cs_heldchange
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cs
operator|->
name|cs_ttyp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|cs
operator|->
name|cs_heldtbc
operator|=
name|cs
operator|->
name|cs_tbc
expr_stmt|;
name|cs
operator|->
name|cs_tbc
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|cs_heldchange
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|cs
operator|->
name|cs_preg
argument_list|,
operator|(
name|caddr_t
operator|)
name|cs
operator|->
name|cs_creg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|zs_loadchannelregs
argument_list|(
name|cs
operator|->
name|cs_zc
argument_list|,
name|cs
operator|->
name|cs_creg
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Raise or lower modem control (DTR/RTS) signals.  If a character is  * in transmission, the change is deferred.  */
end_comment

begin_function
specifier|static
name|void
name|zs_modem
parameter_list|(
name|struct
name|zs_chanstate
modifier|*
name|cs
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|bis
decl_stmt|,
name|and
decl_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|bis
operator|=
name|ZSWR5_DTR
operator||
name|ZSWR5_RTS
expr_stmt|;
name|and
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bis
operator|=
literal|0
expr_stmt|;
name|and
operator|=
operator|~
operator|(
name|ZSWR5_DTR
operator||
name|ZSWR5_RTS
operator|)
expr_stmt|;
block|}
name|s
operator|=
name|splzs
argument_list|()
expr_stmt|;
name|cs
operator|->
name|cs_preg
index|[
literal|5
index|]
operator|=
operator|(
name|cs
operator|->
name|cs_preg
index|[
literal|5
index|]
operator||
name|bis
operator|)
operator|&
name|and
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_heldchange
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cs
operator|->
name|cs_ttyp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|cs
operator|->
name|cs_heldtbc
operator|=
name|cs
operator|->
name|cs_tbc
expr_stmt|;
name|cs
operator|->
name|cs_tbc
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|cs_heldchange
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cs
operator|->
name|cs_creg
index|[
literal|5
index|]
operator|=
operator|(
name|cs
operator|->
name|cs_creg
index|[
literal|5
index|]
operator||
name|bis
operator|)
operator|&
name|and
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|cs
operator|->
name|cs_zc
argument_list|,
literal|5
argument_list|,
name|cs
operator|->
name|cs_creg
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the given register set to the given zs channel in the proper order.  * The channel must not be transmitting at the time.  The receiver will  * be disabled for the time it takes to write all the registers.  */
end_comment

begin_function
specifier|static
name|void
name|zs_loadchannelregs
parameter_list|(
specifier|volatile
name|struct
name|zschan
modifier|*
name|zc
parameter_list|,
name|u_char
modifier|*
name|reg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|zc
operator|->
name|zc_csr
operator|=
name|ZSM_RESET_ERR
expr_stmt|;
comment|/* reset error condition */
name|i
operator|=
name|zc
operator|->
name|zc_data
expr_stmt|;
comment|/* drain fifo */
name|i
operator|=
name|zc
operator|->
name|zc_data
expr_stmt|;
name|i
operator|=
name|zc
operator|->
name|zc_data
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|4
argument_list|,
name|reg
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|10
argument_list|,
name|reg
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|3
argument_list|,
name|reg
index|[
literal|3
index|]
operator|&
operator|~
name|ZSWR3_RX_ENABLE
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|5
argument_list|,
name|reg
index|[
literal|5
index|]
operator|&
operator|~
name|ZSWR5_TX_ENABLE
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|1
argument_list|,
name|reg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|9
argument_list|,
name|reg
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|11
argument_list|,
name|reg
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|12
argument_list|,
name|reg
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|13
argument_list|,
name|reg
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|14
argument_list|,
name|reg
index|[
literal|14
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|15
argument_list|,
name|reg
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|3
argument_list|,
name|reg
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|zc
argument_list|,
literal|5
argument_list|,
name|reg
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KGDB
end_ifdef

begin_comment
comment|/*  * Get a character from the given kgdb channel.  Called at splhigh().  */
end_comment

begin_function
specifier|static
name|int
name|zs_kgdb_getc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|register
specifier|volatile
name|struct
name|zschan
modifier|*
name|zc
init|=
operator|(
specifier|volatile
expr|struct
name|zschan
operator|*
operator|)
name|arg
decl_stmt|;
while|while
condition|(
operator|(
name|zc
operator|->
name|zc_csr
operator|&
name|ZSRR0_RX_READY
operator|)
operator|==
literal|0
condition|)
continue|continue;
return|return
operator|(
name|zc
operator|->
name|zc_data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put a character to the given kgdb channel.  Called at splhigh().  */
end_comment

begin_function
specifier|static
name|void
name|zs_kgdb_putc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|c
parameter_list|)
block|{
specifier|register
specifier|volatile
name|struct
name|zschan
modifier|*
name|zc
init|=
operator|(
specifier|volatile
expr|struct
name|zschan
operator|*
operator|)
name|arg
decl_stmt|;
while|while
condition|(
operator|(
name|zc
operator|->
name|zc_csr
operator|&
name|ZSRR0_TX_READY
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|zc
operator|->
name|zc_data
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up for kgdb; called at boot time before configuration.  * KGDB interrupts will be enabled later when zs0 is configured.  */
end_comment

begin_function
name|void
name|zs_kgdb_init
parameter_list|()
block|{
specifier|volatile
name|struct
name|zsdevice
modifier|*
name|addr
decl_stmt|;
specifier|volatile
name|struct
name|zschan
modifier|*
name|zc
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|zs
decl_stmt|;
if|if
condition|(
name|major
argument_list|(
name|kgdb_dev
argument_list|)
operator|!=
name|ZSMAJOR
condition|)
return|return;
name|unit
operator|=
name|minor
argument_list|(
name|kgdb_dev
argument_list|)
expr_stmt|;
comment|/* 	 * Unit must be 0 or 1 (zs0). 	 */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|unit
operator|>=
name|ZS_KBD
condition|)
block|{
name|printf
argument_list|(
literal|"zs_kgdb_init: bad minor dev %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|zs
operator|=
name|unit
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
name|zsaddr
index|[
name|zs
index|]
operator|)
operator|==
name|NULL
condition|)
name|addr
operator|=
name|zsaddr
index|[
name|zs
index|]
operator|=
name|findzs
argument_list|(
name|zs
argument_list|)
expr_stmt|;
name|unit
operator|&=
literal|1
expr_stmt|;
name|zc
operator|=
name|unit
operator|==
literal|0
condition|?
operator|&
name|addr
operator|->
name|zs_chan
index|[
name|CHAN_A
index|]
else|:
operator|&
name|addr
operator|->
name|zs_chan
index|[
name|CHAN_B
index|]
expr_stmt|;
name|zs_kgdb_savedspeed
operator|=
name|zs_getspeed
argument_list|(
name|zc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"zs_kgdb_init: attaching zs%d%c at %d baud\n"
argument_list|,
name|zs
argument_list|,
name|unit
operator|+
literal|'a'
argument_list|,
name|kgdb_rate
argument_list|)
expr_stmt|;
name|zs_reset
argument_list|(
name|zc
argument_list|,
literal|1
argument_list|,
name|kgdb_rate
argument_list|)
expr_stmt|;
name|kgdb_attach
argument_list|(
name|zs_kgdb_getc
argument_list|,
name|zs_kgdb_putc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|zc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KGDB */
end_comment

end_unit

