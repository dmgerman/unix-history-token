begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991, 1992 The Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)bsd_audio.c	7.4 (Berkeley) %G%  *  * from: $Header: bsd_audio.c,v 1.17 93/04/20 05:31:28 torek Exp $ (LBL)  */
end_comment

begin_include
include|#
directive|include
file|"bsdaudio.h"
end_include

begin_if
if|#
directive|if
name|NBSDAUDIO
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|BSD
operator|<
literal|199103
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|SUNOS
end_ifndef

begin_define
define|#
directive|define
name|SUNOS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SUNOS
end_ifndef

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS
end_ifdef

begin_include
include|#
directive|include
file|<sundev/mbvar.h>
end_include

begin_include
include|#
directive|include
file|<sun4c/intreg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<machine/autoconf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/*  * Avoid name clashes with SunOS so we can config either the bsd or sun  * streams driver in a SunOS kernel.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS
end_ifdef

begin_include
include|#
directive|include
file|<sbusdev/bsd_audioreg.h>
end_include

begin_include
include|#
directive|include
file|<sbusdev/bsd_audiovar.h>
end_include

begin_include
include|#
directive|include
file|<sbusdev/bsd_audioio.h>
end_include

begin_struct
struct|struct
name|selinfo
block|{
name|struct
name|proc
modifier|*
name|si_proc
decl_stmt|;
name|int
name|si_coll
decl_stmt|;
block|}
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sparc/dev/bsd_audioreg.h>
end_include

begin_include
include|#
directive|include
file|<sparc/dev/bsd_audiovar.h>
end_include

begin_include
include|#
directive|include
file|<machine/bsd_audioio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS
end_ifdef

begin_include
include|#
directive|include
file|"bsd_audiocompat.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initial/default block size is patchable.  */
end_comment

begin_decl_stmt
name|int
name|audio_blocksize
init|=
name|DEFBLKSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|audio_backlog
init|=
literal|400
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 50ms in samples */
end_comment

begin_comment
comment|/*  * Software state, per AMD79C30 audio chip.  */
end_comment

begin_struct
struct|struct
name|audio_softc
block|{
ifndef|#
directive|ifndef
name|SUNOS
name|struct
name|device
name|sc_dev
decl_stmt|;
comment|/* base device */
name|struct
name|intrhand
name|sc_hwih
decl_stmt|;
comment|/* hardware interrupt vector */
name|struct
name|intrhand
name|sc_swih
decl_stmt|;
comment|/* software interrupt vector */
endif|#
directive|endif
name|int
name|sc_interrupts
decl_stmt|;
comment|/* number of interrupts taken */
name|int
name|sc_open
decl_stmt|;
comment|/* single use device */
name|u_long
name|sc_wseek
decl_stmt|;
comment|/* timestamp of last frame written */
name|u_long
name|sc_rseek
decl_stmt|;
comment|/* timestamp of last frame read */
name|struct
name|mapreg
name|sc_map
decl_stmt|;
comment|/* current contents of map registers */
name|struct
name|selinfo
name|sc_wsel
decl_stmt|;
comment|/* write selector */
name|struct
name|selinfo
name|sc_rsel
decl_stmt|;
comment|/* read selector */
comment|/* 	 * keep track of levels so we don't have to convert back from 	 * MAP gain constants 	 */
name|int
name|sc_rlevel
decl_stmt|;
comment|/* record level */
name|int
name|sc_plevel
decl_stmt|;
comment|/* play level */
name|int
name|sc_mlevel
decl_stmt|;
comment|/* monitor level */
comment|/* sc_au is special in that the hardware interrupt handler uses it */
name|struct
name|auio
name|sc_au
decl_stmt|;
comment|/* recv and xmit buffers, etc */
block|}
struct|;
end_struct

begin_comment
comment|/* interrupt interfaces */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AUDIO_C_HANDLER
end_ifndef

begin_decl_stmt
name|int
name|audiohwintr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|audioswintr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward declarations */
end_comment

begin_decl_stmt
name|int
name|audio_sleep
name|__P
argument_list|(
operator|(
expr|struct
name|aucb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|audio_setmap
name|__P
argument_list|(
operator|(
specifier|volatile
expr|struct
name|amd7930
operator|*
operator|,
expr|struct
name|mapreg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|init_amd
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|AUDIO_C_HANDLER
argument_list|)
operator|||
name|defined
argument_list|(
name|SUNOS
argument_list|)
end_if

begin_decl_stmt
name|struct
name|auio
modifier|*
name|audio_au
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|audio_trap
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS
end_ifdef

begin_decl_stmt
name|struct
name|audio_softc
name|audio_softc
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SOFTC
parameter_list|(
name|dev
parameter_list|)
value|&audio_softc
end_define

begin_define
define|#
directive|define
name|UIOMOVE
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|,
name|code
parameter_list|,
name|uio
parameter_list|)
value|uiomove(cp, len, code, uio)
end_define

begin_define
define|#
directive|define
name|AUDIOOPEN
parameter_list|(
name|d
parameter_list|,
name|f
parameter_list|,
name|i
parameter_list|,
name|p
parameter_list|)
define|\
value|audioopen(d, f, i)\ 	dev_t d; int f, i;
end_define

begin_define
define|#
directive|define
name|AUDIOCLOSE
parameter_list|(
name|d
parameter_list|,
name|f
parameter_list|,
name|i
parameter_list|,
name|p
parameter_list|)
define|\
value|audioclose(d, f, i)\ 	dev_t d; int f, i;
end_define

begin_define
define|#
directive|define
name|AUDIOREAD
parameter_list|(
name|d
parameter_list|,
name|u
parameter_list|,
name|f
parameter_list|)
define|\
value|audioread(d, u) dev_t d; struct uio *u;
end_define

begin_define
define|#
directive|define
name|AUDIOWRITE
parameter_list|(
name|d
parameter_list|,
name|u
parameter_list|,
name|f
parameter_list|)
define|\
value|audiowrite(d, u) dev_t d; struct uio *u;
end_define

begin_define
define|#
directive|define
name|AUDIOIOCTL
parameter_list|(
name|d
parameter_list|,
name|c
parameter_list|,
name|a
parameter_list|,
name|f
parameter_list|,
name|o
parameter_list|)
define|\
value|audioioctl(d, c, a, f)\ 	dev_t d; int c; caddr_t a; int f;
end_define

begin_define
define|#
directive|define
name|AUDIOSELECT
parameter_list|(
name|d
parameter_list|,
name|r
parameter_list|,
name|p
parameter_list|)
define|\
value|audio_select(d, r, p)\ 	dev_t d; int r; struct proc *p;
end_define

begin_define
define|#
directive|define
name|AUDIO_SET_SWINTR
value|set_intreg(IR_SOFT_INT4, 1)
end_define

begin_function
name|int
name|audioselect
parameter_list|(
name|dev
parameter_list|,
name|rw
parameter_list|)
specifier|register
name|dev_t
name|dev
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{
return|return
operator|(
name|audio_select
argument_list|(
name|dev
argument_list|,
name|rw
argument_list|,
name|u
operator|.
name|u_procp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|selrecord
parameter_list|(
name|p
parameter_list|,
name|si
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|selinfo
modifier|*
name|si
decl_stmt|;
block|{
if|if
condition|(
name|si
operator|->
name|si_proc
operator|!=
literal|0
condition|)
name|si
operator|->
name|si_coll
operator|=
literal|1
expr_stmt|;
else|else
name|si
operator|->
name|si_proc
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SELWAKEUP
parameter_list|(
name|si
parameter_list|)
define|\
value|{\ 	 if ((si)->si_proc != 0) {\ 		selwakeup((si)->si_proc, (si)->si_coll); \ 		(si)->si_proc = 0;\ 		(si)->si_coll = 0;\ 	}\ }
end_define

begin_function_decl
specifier|static
name|int
name|audioattach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|audioidentify
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|dev_ops
name|bsdaudio_ops
init|=
block|{
literal|0
block|,
name|audioidentify
block|,
name|audioattach
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|audioidentify
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"audio"
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|audioattach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|dev_info
modifier|*
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
name|struct
name|dev_reg
modifier|*
name|reg
decl_stmt|;
name|sc
operator|=
operator|&
name|audio_softc
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|devi_nreg
operator|!=
literal|1
operator|||
name|dev
operator|->
name|devi_nintr
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"audio: bad config\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|reg
operator|=
name|dev
operator|->
name|devi_reg
expr_stmt|;
name|amd
operator|=
operator|(
expr|struct
name|amd7930
operator|*
operator|)
name|map_regs
argument_list|(
name|reg
operator|->
name|reg_addr
argument_list|,
name|reg
operator|->
name|reg_size
argument_list|,
name|reg
operator|->
name|reg_bustype
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
operator|=
name|amd
expr_stmt|;
name|init_amd
argument_list|(
name|amd
argument_list|)
expr_stmt|;
name|audio_au
operator|=
operator|&
name|sc
operator|->
name|sc_au
expr_stmt|;
ifndef|#
directive|ifndef
name|AUDIO_C_HANDLER
name|settrap
argument_list|(
name|dev
operator|->
name|devi_intr
operator|->
name|int_pri
argument_list|,
name|audio_trap
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* XXX */
name|addintr
argument_list|(
name|dev
operator|->
name|devi_intr
operator|->
name|int_pri
argument_list|,
name|audiohwintr
argument_list|,
name|dev
operator|->
name|devi_name
argument_list|,
name|dev
operator|->
name|devi_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addintr
argument_list|(
literal|4
argument_list|,
name|audioswintr
argument_list|,
name|dev
operator|->
name|devi_name
argument_list|,
name|dev
operator|->
name|devi_unit
argument_list|)
expr_stmt|;
name|report_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AUDIOOPEN
parameter_list|(
name|d
parameter_list|,
name|f
parameter_list|,
name|i
parameter_list|,
name|p
parameter_list|)
value|audioopen(dev_t d, int f, int i, struct proc *p)
end_define

begin_define
define|#
directive|define
name|AUDIOCLOSE
parameter_list|(
name|d
parameter_list|,
name|f
parameter_list|,
name|i
parameter_list|,
name|p
parameter_list|)
value|audioclose(dev_t d, int f, int i, \ 					  struct proc *p)
end_define

begin_define
define|#
directive|define
name|AUDIOREAD
parameter_list|(
name|d
parameter_list|,
name|u
parameter_list|,
name|f
parameter_list|)
value|audioread(dev_t d, struct uio *u, int f)
end_define

begin_define
define|#
directive|define
name|AUDIOWRITE
parameter_list|(
name|d
parameter_list|,
name|u
parameter_list|,
name|f
parameter_list|)
value|audiowrite(dev_t d, struct uio *u, int f)
end_define

begin_define
define|#
directive|define
name|AUDIOIOCTL
parameter_list|(
name|d
parameter_list|,
name|c
parameter_list|,
name|a
parameter_list|,
name|f
parameter_list|,
name|o
parameter_list|)
define|\
value|audioioctl(dev_t dev, int c, caddr_t a, int f, struct proc *p)
end_define

begin_define
define|#
directive|define
name|AUDIOSELECT
parameter_list|(
name|d
parameter_list|,
name|r
parameter_list|,
name|p
parameter_list|)
value|audioselect(dev_t dev, int rw, struct proc *p)
end_define

begin_define
define|#
directive|define
name|SELWAKEUP
value|selwakeup
end_define

begin_define
define|#
directive|define
name|AUDIO_SET_SWINTR
value|ienab_bis(IE_L6)
end_define

begin_comment
comment|/* autoconfiguration driver */
end_comment

begin_function_decl
name|void
name|audioattach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfdriver
name|audiocd
init|=
block|{
name|NULL
block|,
literal|"audio"
block|,
name|matchbyname
block|,
name|audioattach
block|,
name|DV_DULL
block|,
expr|sizeof
operator|(
expr|struct
name|audio_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SOFTC
parameter_list|(
name|dev
parameter_list|)
value|audiocd.cd_devs[minor(dev)]
end_define

begin_define
define|#
directive|define
name|UIOMOVE
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|,
name|code
parameter_list|,
name|uio
parameter_list|)
value|uiomove(cp, len, uio)
end_define

begin_comment
comment|/*  * Audio chip found.  */
end_comment

begin_function
name|void
name|audioattach
parameter_list|(
name|parent
parameter_list|,
name|self
parameter_list|,
name|args
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|,
decl|*
name|self
decl_stmt|;
end_function

begin_decl_stmt
name|void
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|audio_softc
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|romaux
modifier|*
name|ra
init|=
name|args
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
specifier|register
name|int
name|pri
decl_stmt|;
if|if
condition|(
name|ra
operator|->
name|ra_nintr
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|": expected 1 interrupt, got %d\n"
argument_list|,
name|ra
operator|->
name|ra_nintr
argument_list|)
expr_stmt|;
return|return;
block|}
name|pri
operator|=
name|ra
operator|->
name|ra_intr
index|[
literal|0
index|]
operator|.
name|int_pri
expr_stmt|;
name|printf
argument_list|(
literal|" pri %d, softpri %d\n"
argument_list|,
name|pri
argument_list|,
name|PIL_AUSOFT
argument_list|)
expr_stmt|;
name|amd
operator|=
operator|(
specifier|volatile
expr|struct
name|amd7930
operator|*
operator|)
operator|(
name|ra
operator|->
name|ra_vaddr
condition|?
name|ra
operator|->
name|ra_vaddr
else|:
name|mapiodev
argument_list|(
name|ra
operator|->
name|ra_paddr
argument_list|,
sizeof|sizeof
expr|*
name|amd
argument_list|)
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
operator|=
name|amd
expr_stmt|;
name|init_amd
argument_list|(
name|amd
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|AUDIO_C_HANDLER
name|audio_au
operator|=
operator|&
name|sc
operator|->
name|sc_au
expr_stmt|;
name|intr_fasttrap
argument_list|(
name|pri
argument_list|,
name|audio_trap
argument_list|)
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|sc_hwih
operator|.
name|ih_fun
operator|=
name|audiohwintr
expr_stmt|;
name|sc
operator|->
name|sc_hwih
operator|.
name|ih_arg
operator|=
operator|&
name|sc
operator|->
name|sc_au
expr_stmt|;
name|intr_establish
argument_list|(
name|pri
argument_list|,
operator|&
name|sc
operator|->
name|sc_hwih
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_swih
operator|.
name|ih_fun
operator|=
name|audioswintr
expr_stmt|;
name|sc
operator|->
name|sc_swih
operator|.
name|ih_arg
operator|=
name|sc
expr_stmt|;
name|intr_establish
argument_list|(
name|PIL_AUSOFT
argument_list|,
operator|&
name|sc
operator|->
name|sc_swih
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|init_amd
parameter_list|(
name|amd
parameter_list|)
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
block|{
comment|/* disable interrupts */
name|amd
operator|->
name|cr
operator|=
name|AMDR_INIT
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|AMD_INIT_PMS_ACTIVE
operator||
name|AMD_INIT_INT_DISABLE
expr_stmt|;
comment|/* 	 * Initialize the mux unit.  We use MCR3 to route audio (MAP) 	 * through channel Bb.  MCR1 and MCR2 are unused. 	 * Setting the INT enable bit in MCR4 will generate an interrupt 	 * on each converted audio sample. 	 */
name|amd
operator|->
name|cr
operator|=
name|AMDR_MUX_1_4
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
literal|0
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
literal|0
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
operator|(
name|AMD_MCRCHAN_BB
operator|<<
literal|4
operator|)
operator||
name|AMD_MCRCHAN_BA
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|AMD_MCR4_INT_ENABLE
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|audio_default_level
init|=
literal|150
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ausetrgain
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ausetpgain
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ausetmgain
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|audiosetinfo
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
expr|struct
name|audio_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|audiogetinfo
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
expr|struct
name|audio_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|sun_audio_info
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|int
name|sunaudiosetinfo
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
expr|struct
name|sun_audio_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sunaudiogetinfo
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
expr|struct
name|sun_audio_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|audio_setmmr2
name|__P
argument_list|(
operator|(
specifier|volatile
expr|struct
name|amd7930
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|AUDIOOPEN
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|ifmt
parameter_list|,
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|error
decl_stmt|,
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|SUNOS
if|if
condition|(
name|unit
operator|>
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
operator|&
name|audio_softc
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|unit
operator|>=
name|audiocd
operator|.
name|cd_ndevs
operator|||
operator|(
name|sc
operator|=
name|audiocd
operator|.
name|cd_devs
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_open
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|->
name|sc_open
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
operator|=
name|audio_blocksize
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_hiwat
operator|=
name|AUCB_SIZE
operator|-
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
operator|=
name|audio_blocksize
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_backlog
operator|=
name|audio_backlog
expr_stmt|;
comment|/* set up read and write blocks and `dead sound' zero value. */
name|AUCB_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_thresh
operator|=
name|AUCB_SIZE
expr_stmt|;
name|AUCB_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_thresh
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* nothing read or written yet */
name|sc
operator|->
name|sc_rseek
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_wseek
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_map
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|sc_map
argument_list|)
expr_stmt|;
comment|/* default to speaker */
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator|=
name|AMD_MMR2_AINB
operator||
name|AMD_MMR2_LS
expr_stmt|;
comment|/* enable interrupts and set parameters established above */
name|amd
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
expr_stmt|;
name|audio_setmmr2
argument_list|(
name|amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
argument_list|)
expr_stmt|;
name|ausetrgain
argument_list|(
name|sc
argument_list|,
name|audio_default_level
argument_list|)
expr_stmt|;
name|ausetpgain
argument_list|(
name|sc
argument_list|,
name|audio_default_level
argument_list|)
expr_stmt|;
name|ausetmgain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_INIT
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|AMD_INIT_PMS_ACTIVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|audio_drain
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|int
name|error
decl_stmt|;
while|while
condition|(
operator|!
name|AUCB_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
argument_list|)
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|audio_sleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close an audio chip.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|AUDIOCLOSE
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|ifmt
parameter_list|,
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
init|=
name|SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
specifier|register
name|struct
name|aucb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
comment|/* 	 * Block until output drains, but allow ^C interrupt. 	 */
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
operator|=
literal|0
expr_stmt|;
comment|/* avoid excessive wakeups */
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
comment|/* 	 * If there is pending output, let it drain (unless 	 * the output is paused). 	 */
name|cb
operator|=
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
expr_stmt|;
if|if
condition|(
operator|!
name|AUCB_EMPTY
argument_list|(
name|cb
argument_list|)
operator|&&
operator|!
name|cb
operator|->
name|cb_pause
condition|)
operator|(
name|void
operator|)
name|audio_drain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Disable interrupts, clear open flag, and done. 	 */
name|amd
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
expr_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_INIT
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|AMD_INIT_PMS_ACTIVE
operator||
name|AMD_INIT_INT_DISABLE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_open
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|audio_sleep
parameter_list|(
name|cb
parameter_list|,
name|thresh
parameter_list|)
specifier|register
name|struct
name|aucb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|int
name|thresh
decl_stmt|;
block|{
specifier|register
name|int
name|error
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splaudio
argument_list|()
decl_stmt|;
name|cb
operator|->
name|cb_thresh
operator|=
name|thresh
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
argument_list|,
operator|(
name|PZERO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
literal|"audio"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|AUDIOREAD
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|)
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
init|=
name|SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|aucb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|head
decl_stmt|,
name|taildata
decl_stmt|,
name|error
decl_stmt|;
specifier|register
name|int
name|blocksize
init|=
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cb
operator|=
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|cb_drops
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rseek
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|-
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
expr_stmt|;
do|do
block|{
while|while
condition|(
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|<
name|blocksize
condition|)
block|{
ifndef|#
directive|ifndef
name|SUNOS
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|audio_sleep
argument_list|(
name|cb
argument_list|,
name|blocksize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * The space calculation can only err on the short 		 * side if an interrupt occurs during processing: 		 * only cb_tail is altered in the interrupt code. 		 */
name|head
operator|=
name|cb
operator|->
name|cb_head
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|)
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|n
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|taildata
operator|=
name|AUCB_SIZE
operator|-
name|head
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|taildata
condition|)
block|{
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
operator|->
name|cb_data
operator|+
name|head
argument_list|,
name|taildata
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
operator|->
name|cb_data
argument_list|,
name|n
operator|-
name|taildata
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
operator|->
name|cb_data
operator|+
name|head
argument_list|,
name|n
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|head
operator|=
name|AUCB_MOD
argument_list|(
name|head
operator|+
name|n
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_head
operator|=
name|head
expr_stmt|;
block|}
do|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>=
name|blocksize
condition|)
do|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|AUDIOWRITE
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|)
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
init|=
name|SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|aucb
modifier|*
name|cb
init|=
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|tail
decl_stmt|,
name|tailspace
decl_stmt|,
name|error
decl_stmt|,
name|first
decl_stmt|,
name|watermark
decl_stmt|,
name|drops
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|watermark
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_hiwat
expr_stmt|;
while|while
condition|(
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|>
name|watermark
condition|)
block|{
ifndef|#
directive|ifndef
name|SUNOS
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|audio_sleep
argument_list|(
name|cb
argument_list|,
name|watermark
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|watermark
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
expr_stmt|;
block|}
comment|/* 		 * The only value that can change on an interrupt is 		 * cb->cb_head.  We only pull that out once to decide 		 * how much to write into cb_data; if we lose a race 		 * and cb_head changes, we will merely be overly 		 * conservative.  For a legitimate time stamp, 		 * however, we need to synchronize the accesses to 		 * au_stamp and cb_head at a high ipl below. 		 */
name|tail
operator|=
name|cb
operator|->
name|cb_tail
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
operator|(
name|AUCB_SIZE
operator|-
literal|1
operator|)
operator|-
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|)
operator|>
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|n
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_head
operator|==
name|tail
operator|&&
name|n
operator|<=
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
operator|&&
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|-
name|sc
operator|->
name|sc_wseek
operator|>
literal|400
condition|)
block|{
comment|/* 				 * the write is 'small', the buffer is empty 				 * and we have been silent for at least 50ms 				 * so we might be dealing with an application 				 * that writes frames synchronously with 				 * reading them.  If so, we need an output 				 * backlog to cover scheduling delays or 				 * there will be gaps in the sound output. 				 * Also take this opportunity to reset the 				 * buffer pointers in case we ended up on 				 * a bad boundary (odd byte, blksize bytes 				 * from end, etc.). 				 */
specifier|register
name|u_int
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|muzero
init|=
literal|0x7f7f7f7f
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|splaudio
argument_list|()
decl_stmt|;
name|cb
operator|->
name|cb_head
operator|=
name|cb
operator|->
name|cb_tail
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tail
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_backlog
expr_stmt|;
name|ip
operator|=
operator|(
name|u_int
operator|*
operator|)
name|cb
operator|->
name|cb_data
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tail
operator|>>
literal|2
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|ip
operator|++
operator|=
name|muzero
expr_stmt|;
block|}
block|}
name|tailspace
operator|=
name|AUCB_SIZE
operator|-
name|tail
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|tailspace
condition|)
block|{
comment|/* write first part at tail and rest at head */
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
operator|->
name|cb_data
operator|+
name|tail
argument_list|,
name|tailspace
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
operator|->
name|cb_data
argument_list|,
name|n
operator|-
name|tailspace
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
operator|->
name|cb_data
operator|+
name|tail
argument_list|,
name|n
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|tail
operator|=
name|AUCB_MOD
argument_list|(
name|tail
operator|+
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
specifier|register
name|int
name|s
init|=
name|splaudio
argument_list|()
decl_stmt|;
name|sc
operator|->
name|sc_wseek
operator|=
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|+
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|+
literal|1
expr_stmt|;
comment|/*  			 * To guarantee that a write is contiguous in the 			 * sample space, we clear the drop count the first 			 * time through.  If we later get drops, we will 			 * break out of the loop below, before writing 			 * a new frame. 			 */
name|cb
operator|->
name|cb_drops
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|cb_tail
operator|=
name|tail
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cb
operator|->
name|cb_drops
operator|!=
literal|0
condition|)
break|break;
name|cb
operator|->
name|cb_tail
operator|=
name|tail
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Sun audio compatibility */
end_comment

begin_struct
struct|struct
name|sun_audio_prinfo
block|{
name|u_int
name|sample_rate
decl_stmt|;
name|u_int
name|channels
decl_stmt|;
name|u_int
name|precision
decl_stmt|;
name|u_int
name|encoding
decl_stmt|;
name|u_int
name|gain
decl_stmt|;
name|u_int
name|port
decl_stmt|;
name|u_int
name|reserved0
index|[
literal|4
index|]
decl_stmt|;
name|u_int
name|samples
decl_stmt|;
name|u_int
name|eof
decl_stmt|;
name|u_char
name|pause
decl_stmt|;
name|u_char
name|error
decl_stmt|;
name|u_char
name|waiting
decl_stmt|;
name|u_char
name|reserved1
index|[
literal|3
index|]
decl_stmt|;
name|u_char
name|open
decl_stmt|;
name|u_char
name|active
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sun_audio_info
block|{
name|struct
name|sun_audio_prinfo
name|play
decl_stmt|;
name|struct
name|sun_audio_prinfo
name|record
decl_stmt|;
name|u_int
name|monitor_gain
decl_stmt|;
name|u_int
name|reserved
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|SUNOS
end_ifndef

begin_define
define|#
directive|define
name|SUNAUDIO_GETINFO
value|_IOR('A', 1, struct sun_audio_info)
end_define

begin_define
define|#
directive|define
name|SUNAUDIO_SETINFO
value|_IOWR('A', 2, struct sun_audio_info)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SUNAUDIO_GETINFO
value|_IOR(A, 1, struct sun_audio_info)
end_define

begin_define
define|#
directive|define
name|SUNAUDIO_SETINFO
value|_IOWR(A, 2, struct sun_audio_info)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|AUDIOIOCTL
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|addr
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
init|=
name|SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AUDIO_GETMAP
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_map
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_map
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIO_SETMAP
case|:
name|bcopy
argument_list|(
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_map
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_map
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator|&=
literal|0x7f
expr_stmt|;
name|audio_setmap
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
operator|&
name|sc
operator|->
name|sc_map
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIO_FLUSH
case|:
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
name|AUCB_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
argument_list|)
expr_stmt|;
name|AUCB_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_wseek
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rseek
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 	 * Number of read samples dropped.  We don't know where or 	 * when they were dropped. 	 */
case|case
name|AUDIO_RERROR
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_drops
operator|!=
literal|0
expr_stmt|;
break|break;
comment|/* 	 * How many samples will elapse until mike hears the first 	 * sample of what we last wrote? 	 */
case|case
name|AUDIO_WSEEK
case|:
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|sc_wseek
operator|-
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|+
name|AUCB_LEN
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIO_SETINFO
case|:
name|error
operator|=
name|audiosetinfo
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|audio_info
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIO_GETINFO
case|:
name|error
operator|=
name|audiogetinfo
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|audio_info
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUNAUDIO_GETINFO
case|:
name|error
operator|=
name|sunaudiogetinfo
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|sun_audio_info
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUNAUDIO_SETINFO
case|:
name|error
operator|=
name|sunaudiosetinfo
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|sun_audio_info
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIO_DRAIN
case|:
name|error
operator|=
name|audio_drain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|AUDIOSELECT
parameter_list|(
name|dev
parameter_list|,
name|rw
parameter_list|,
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
init|=
name|SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|aucb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splaudio
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
name|FREAD
case|:
name|cb
operator|=
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
expr_stmt|;
if|if
condition|(
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|>=
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|sc_rsel
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_thresh
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
expr_stmt|;
break|break;
case|case
name|FWRITE
case|:
name|cb
operator|=
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
expr_stmt|;
if|if
condition|(
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|<=
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|sc_wsel
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_thresh
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AUDIO_C_HANDLER
end_ifdef

begin_function
name|int
name|audiohwintr
parameter_list|(
name|au0
parameter_list|)
name|void
modifier|*
name|au0
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SUNOS
specifier|register
name|struct
name|auio
modifier|*
name|au
init|=
name|audio_au
decl_stmt|;
else|#
directive|else
specifier|register
name|struct
name|auio
modifier|*
name|au
init|=
name|au0
decl_stmt|;
endif|#
directive|endif
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
init|=
name|au
operator|->
name|au_amd
decl_stmt|;
specifier|register
name|struct
name|aucb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|int
name|h
decl_stmt|,
name|t
decl_stmt|,
name|k
decl_stmt|;
name|k
operator|=
name|amd
operator|->
name|ir
expr_stmt|;
comment|/* clear interrupt */
operator|++
name|au
operator|->
name|au_stamp
expr_stmt|;
comment|/* receive incoming data */
name|cb
operator|=
operator|&
name|au
operator|->
name|au_rb
expr_stmt|;
name|h
operator|=
name|cb
operator|->
name|cb_head
expr_stmt|;
name|t
operator|=
name|cb
operator|->
name|cb_tail
expr_stmt|;
name|k
operator|=
name|AUCB_MOD
argument_list|(
name|t
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|k
condition|)
name|cb
operator|->
name|cb_drops
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|cb
operator|->
name|cb_pause
operator|!=
literal|0
condition|)
name|cb
operator|->
name|cb_pdrops
operator|++
expr_stmt|;
else|else
block|{
name|cb
operator|->
name|cb_data
index|[
name|t
index|]
operator|=
name|amd
operator|->
name|bbrb
expr_stmt|;
name|cb
operator|->
name|cb_tail
operator|=
name|t
operator|=
name|k
expr_stmt|;
block|}
if|if
condition|(
name|AUCB_MOD
argument_list|(
name|t
operator|-
name|h
argument_list|)
operator|>=
name|cb
operator|->
name|cb_thresh
condition|)
block|{
name|cb
operator|->
name|cb_thresh
operator|=
name|AUCB_SIZE
expr_stmt|;
name|cb
operator|->
name|cb_waking
operator|=
literal|1
expr_stmt|;
name|AUDIO_SET_SWINTR
expr_stmt|;
block|}
comment|/* send outgoing data */
name|cb
operator|=
operator|&
name|au
operator|->
name|au_wb
expr_stmt|;
name|h
operator|=
name|cb
operator|->
name|cb_head
expr_stmt|;
name|t
operator|=
name|cb
operator|->
name|cb_tail
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|t
condition|)
name|cb
operator|->
name|cb_drops
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|cb
operator|->
name|cb_pause
operator|!=
literal|0
condition|)
name|cb
operator|->
name|cb_pdrops
operator|++
expr_stmt|;
else|else
block|{
name|cb
operator|->
name|cb_head
operator|=
name|h
operator|=
name|AUCB_MOD
argument_list|(
name|h
operator|+
literal|1
argument_list|)
expr_stmt|;
name|amd
operator|->
name|bbtb
operator|=
name|cb
operator|->
name|cb_data
index|[
name|h
index|]
expr_stmt|;
block|}
if|if
condition|(
name|AUCB_MOD
argument_list|(
name|t
operator|-
name|h
argument_list|)
operator|<=
name|cb
operator|->
name|cb_thresh
condition|)
block|{
name|cb
operator|->
name|cb_thresh
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|->
name|cb_waking
operator|=
literal|1
expr_stmt|;
name|AUDIO_SET_SWINTR
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|audioswintr
parameter_list|(
name|sc0
parameter_list|)
name|void
modifier|*
name|sc0
decl_stmt|;
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SUNOS
name|sc
operator|=
operator|&
name|audio_softc
expr_stmt|;
else|#
directive|else
name|sc
operator|=
name|sc0
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_waking
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_waking
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
argument_list|)
expr_stmt|;
name|SELWAKEUP
argument_list|(
operator|&
name|sc
operator|->
name|sc_rsel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_waking
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_waking
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
argument_list|)
expr_stmt|;
name|SELWAKEUP
argument_list|(
operator|&
name|sc
operator|->
name|sc_wsel
argument_list|)
expr_stmt|;
block|}
else|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write 16 bits of data from variable v to the data port of the audio chip */
end_comment

begin_define
define|#
directive|define
name|WAMD16
parameter_list|(
name|amd
parameter_list|,
name|v
parameter_list|)
value|((amd)->dr = (v), (amd)->dr = (v)>> 8)
end_define

begin_function
name|void
name|audio_setmap
parameter_list|(
name|amd
parameter_list|,
name|map
parameter_list|)
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
specifier|register
name|struct
name|mapreg
modifier|*
name|map
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|v
decl_stmt|;
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_MAP_1_10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|map
operator|->
name|mr_x
index|[
name|i
index|]
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
name|v
operator|=
name|map
operator|->
name|mr_r
index|[
name|i
index|]
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|map
operator|->
name|mr_gx
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|map
operator|->
name|mr_gr
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|map
operator|->
name|mr_ger
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|map
operator|->
name|mr_stgr
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|map
operator|->
name|mr_ftgr
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|map
operator|->
name|mr_atgr
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|map
operator|->
name|mr_mmr1
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|map
operator|->
name|mr_mmr2
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the mmr1 register and one other 16 bit register in the audio chip.  * The other register is indicated by op and val.  */
end_comment

begin_function
name|void
name|audio_setmmr1
parameter_list|(
name|amd
parameter_list|,
name|mmr1
parameter_list|,
name|op
parameter_list|,
name|val
parameter_list|)
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
specifier|register
name|int
name|mmr1
decl_stmt|;
specifier|register
name|int
name|op
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
block|{
specifier|register
name|int
name|s
init|=
name|splaudio
argument_list|()
decl_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_MAP_MMR1
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|mmr1
expr_stmt|;
name|amd
operator|->
name|cr
operator|=
name|op
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the mmr2 register.  */
end_comment

begin_function
specifier|static
name|void
name|audio_setmmr2
parameter_list|(
name|amd
parameter_list|,
name|mmr2
parameter_list|)
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
specifier|register
name|int
name|mmr2
decl_stmt|;
block|{
specifier|register
name|int
name|s
init|=
name|splaudio
argument_list|()
decl_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_MAP_MMR2
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|mmr2
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * gx, gr& stg gains.  this table must contain 256 elements with  * the 0th being "infinity" (the magic value 9008).  The remaining  * elements match sun's gain curve (but with higher resolution):  * -18 to 0dB in .16dB steps then 0 to 12dB in .08dB steps.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_short
name|gx_coeff
index|[
literal|256
index|]
init|=
block|{
literal|0x9008
block|,
literal|0x8b7c
block|,
literal|0x8b51
block|,
literal|0x8b45
block|,
literal|0x8b42
block|,
literal|0x8b3b
block|,
literal|0x8b36
block|,
literal|0x8b33
block|,
literal|0x8b32
block|,
literal|0x8b2a
block|,
literal|0x8b2b
block|,
literal|0x8b2c
block|,
literal|0x8b25
block|,
literal|0x8b23
block|,
literal|0x8b22
block|,
literal|0x8b22
block|,
literal|0x9122
block|,
literal|0x8b1a
block|,
literal|0x8aa3
block|,
literal|0x8aa3
block|,
literal|0x8b1c
block|,
literal|0x8aa6
block|,
literal|0x912d
block|,
literal|0x912b
block|,
literal|0x8aab
block|,
literal|0x8b12
block|,
literal|0x8aaa
block|,
literal|0x8ab2
block|,
literal|0x9132
block|,
literal|0x8ab4
block|,
literal|0x913c
block|,
literal|0x8abb
block|,
literal|0x9142
block|,
literal|0x9144
block|,
literal|0x9151
block|,
literal|0x8ad5
block|,
literal|0x8aeb
block|,
literal|0x8a79
block|,
literal|0x8a5a
block|,
literal|0x8a4a
block|,
literal|0x8b03
block|,
literal|0x91c2
block|,
literal|0x91bb
block|,
literal|0x8a3f
block|,
literal|0x8a33
block|,
literal|0x91b2
block|,
literal|0x9212
block|,
literal|0x9213
block|,
literal|0x8a2c
block|,
literal|0x921d
block|,
literal|0x8a23
block|,
literal|0x921a
block|,
literal|0x9222
block|,
literal|0x9223
block|,
literal|0x922d
block|,
literal|0x9231
block|,
literal|0x9234
block|,
literal|0x9242
block|,
literal|0x925b
block|,
literal|0x92dd
block|,
literal|0x92c1
block|,
literal|0x92b3
block|,
literal|0x92ab
block|,
literal|0x92a4
block|,
literal|0x92a2
block|,
literal|0x932b
block|,
literal|0x9341
block|,
literal|0x93d3
block|,
literal|0x93b2
block|,
literal|0x93a2
block|,
literal|0x943c
block|,
literal|0x94b2
block|,
literal|0x953a
block|,
literal|0x9653
block|,
literal|0x9782
block|,
literal|0x9e21
block|,
literal|0x9d23
block|,
literal|0x9cd2
block|,
literal|0x9c23
block|,
literal|0x9baa
block|,
literal|0x9bde
block|,
literal|0x9b33
block|,
literal|0x9b22
block|,
literal|0x9b1d
block|,
literal|0x9ab2
block|,
literal|0xa142
block|,
literal|0xa1e5
block|,
literal|0x9a3b
block|,
literal|0xa213
block|,
literal|0xa1a2
block|,
literal|0xa231
block|,
literal|0xa2eb
block|,
literal|0xa313
block|,
literal|0xa334
block|,
literal|0xa421
block|,
literal|0xa54b
block|,
literal|0xada4
block|,
literal|0xac23
block|,
literal|0xab3b
block|,
literal|0xaaab
block|,
literal|0xaa5c
block|,
literal|0xb1a3
block|,
literal|0xb2ca
block|,
literal|0xb3bd
block|,
literal|0xbe24
block|,
literal|0xbb2b
block|,
literal|0xba33
block|,
literal|0xc32b
block|,
literal|0xcb5a
block|,
literal|0xd2a2
block|,
literal|0xe31d
block|,
literal|0x0808
block|,
literal|0x72ba
block|,
literal|0x62c2
block|,
literal|0x5c32
block|,
literal|0x52db
block|,
literal|0x513e
block|,
literal|0x4cce
block|,
literal|0x43b2
block|,
literal|0x4243
block|,
literal|0x41b4
block|,
literal|0x3b12
block|,
literal|0x3bc3
block|,
literal|0x3df2
block|,
literal|0x34bd
block|,
literal|0x3334
block|,
literal|0x32c2
block|,
literal|0x3224
block|,
literal|0x31aa
block|,
literal|0x2a7b
block|,
literal|0x2aaa
block|,
literal|0x2b23
block|,
literal|0x2bba
block|,
literal|0x2c42
block|,
literal|0x2e23
block|,
literal|0x25bb
block|,
literal|0x242b
block|,
literal|0x240f
block|,
literal|0x231a
block|,
literal|0x22bb
block|,
literal|0x2241
block|,
literal|0x2223
block|,
literal|0x221f
block|,
literal|0x1a33
block|,
literal|0x1a4a
block|,
literal|0x1acd
block|,
literal|0x2132
block|,
literal|0x1b1b
block|,
literal|0x1b2c
block|,
literal|0x1b62
block|,
literal|0x1c12
block|,
literal|0x1c32
block|,
literal|0x1d1b
block|,
literal|0x1e71
block|,
literal|0x16b1
block|,
literal|0x1522
block|,
literal|0x1434
block|,
literal|0x1412
block|,
literal|0x1352
block|,
literal|0x1323
block|,
literal|0x1315
block|,
literal|0x12bc
block|,
literal|0x127a
block|,
literal|0x1235
block|,
literal|0x1226
block|,
literal|0x11a2
block|,
literal|0x1216
block|,
literal|0x0a2a
block|,
literal|0x11bc
block|,
literal|0x11d1
block|,
literal|0x1163
block|,
literal|0x0ac2
block|,
literal|0x0ab2
block|,
literal|0x0aab
block|,
literal|0x0b1b
block|,
literal|0x0b23
block|,
literal|0x0b33
block|,
literal|0x0c0f
block|,
literal|0x0bb3
block|,
literal|0x0c1b
block|,
literal|0x0c3e
block|,
literal|0x0cb1
block|,
literal|0x0d4c
block|,
literal|0x0ec1
block|,
literal|0x079a
block|,
literal|0x0614
block|,
literal|0x0521
block|,
literal|0x047c
block|,
literal|0x0422
block|,
literal|0x03b1
block|,
literal|0x03e3
block|,
literal|0x0333
block|,
literal|0x0322
block|,
literal|0x031c
block|,
literal|0x02aa
block|,
literal|0x02ba
block|,
literal|0x02f2
block|,
literal|0x0242
block|,
literal|0x0232
block|,
literal|0x0227
block|,
literal|0x0222
block|,
literal|0x021b
block|,
literal|0x01ad
block|,
literal|0x0212
block|,
literal|0x01b2
block|,
literal|0x01bb
block|,
literal|0x01cb
block|,
literal|0x01f6
block|,
literal|0x0152
block|,
literal|0x013a
block|,
literal|0x0133
block|,
literal|0x0131
block|,
literal|0x012c
block|,
literal|0x0123
block|,
literal|0x0122
block|,
literal|0x00a2
block|,
literal|0x011b
block|,
literal|0x011e
block|,
literal|0x0114
block|,
literal|0x00b1
block|,
literal|0x00aa
block|,
literal|0x00b3
block|,
literal|0x00bd
block|,
literal|0x00ba
block|,
literal|0x00c5
block|,
literal|0x00d3
block|,
literal|0x00f3
block|,
literal|0x0062
block|,
literal|0x0051
block|,
literal|0x0042
block|,
literal|0x003b
block|,
literal|0x0033
block|,
literal|0x0032
block|,
literal|0x002a
block|,
literal|0x002c
block|,
literal|0x0025
block|,
literal|0x0023
block|,
literal|0x0022
block|,
literal|0x001a
block|,
literal|0x0021
block|,
literal|0x001b
block|,
literal|0x001b
block|,
literal|0x001d
block|,
literal|0x0015
block|,
literal|0x0013
block|,
literal|0x0013
block|,
literal|0x0012
block|,
literal|0x0012
block|,
literal|0x000a
block|,
literal|0x000a
block|,
literal|0x0011
block|,
literal|0x0011
block|,
literal|0x000b
block|,
literal|0x000b
block|,
literal|0x000c
block|,
literal|0x000e
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * second stage play gain.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_short
name|ger_coeff
index|[]
init|=
block|{
literal|0x431f
block|,
comment|/* 5. dB */
literal|0x331f
block|,
comment|/* 5.5 dB */
literal|0x40dd
block|,
comment|/* 6. dB */
literal|0x11dd
block|,
comment|/* 6.5 dB */
literal|0x440f
block|,
comment|/* 7. dB */
literal|0x411f
block|,
comment|/* 7.5 dB */
literal|0x311f
block|,
comment|/* 8. dB */
literal|0x5520
block|,
comment|/* 8.5 dB */
literal|0x10dd
block|,
comment|/* 9. dB */
literal|0x4211
block|,
comment|/* 9.5 dB */
literal|0x410f
block|,
comment|/* 10. dB */
literal|0x111f
block|,
comment|/* 10.5 dB */
literal|0x600b
block|,
comment|/* 11. dB */
literal|0x00dd
block|,
comment|/* 11.5 dB */
literal|0x4210
block|,
comment|/* 12. dB */
literal|0x110f
block|,
comment|/* 13. dB */
literal|0x7200
block|,
comment|/* 14. dB */
literal|0x2110
block|,
comment|/* 15. dB */
literal|0x2200
block|,
comment|/* 15.9 dB */
literal|0x000b
block|,
comment|/* 16.9 dB */
literal|0x000f
comment|/* 18. dB */
define|#
directive|define
name|NGER
value|(sizeof(ger_coeff) / sizeof(ger_coeff[0]))
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ausetrgain
parameter_list|(
name|sc
parameter_list|,
name|level
parameter_list|)
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
block|{
name|level
operator|&=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|sc_rlevel
operator|=
name|level
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
operator||=
name|AMD_MMR1_GX
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|.
name|mr_gx
operator|=
name|gx_coeff
index|[
name|level
index|]
expr_stmt|;
name|audio_setmmr1
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
argument_list|,
name|AMDR_MAP_GX
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_gx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ausetpgain
parameter_list|(
name|sc
parameter_list|,
name|level
parameter_list|)
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|int
name|gi
decl_stmt|,
name|s
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
name|level
operator|&=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|sc_plevel
operator|=
name|level
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
operator||=
name|AMD_MMR1_GER
operator||
name|AMD_MMR1_GR
expr_stmt|;
name|level
operator|*=
literal|256
operator|+
name|NGER
expr_stmt|;
name|level
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
name|level
operator|>=
literal|256
condition|)
block|{
name|gi
operator|=
name|level
operator|-
literal|256
expr_stmt|;
name|level
operator|=
literal|255
expr_stmt|;
block|}
else|else
name|gi
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|.
name|mr_ger
operator|=
name|ger_coeff
index|[
name|gi
index|]
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|.
name|mr_gr
operator|=
name|gx_coeff
index|[
name|level
index|]
expr_stmt|;
name|amd
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
expr_stmt|;
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_MAP_MMR1
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
expr_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_MAP_GR
expr_stmt|;
name|gi
operator|=
name|sc
operator|->
name|sc_map
operator|.
name|mr_gr
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|gi
argument_list|)
expr_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_MAP_GER
expr_stmt|;
name|gi
operator|=
name|sc
operator|->
name|sc_map
operator|.
name|mr_ger
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|gi
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ausetmgain
parameter_list|(
name|sc
parameter_list|,
name|level
parameter_list|)
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
block|{
name|level
operator|&=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|sc_mlevel
operator|=
name|level
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
operator||=
name|AMD_MMR1_STG
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|.
name|mr_stgr
operator|=
name|gx_coeff
index|[
name|level
index|]
expr_stmt|;
name|audio_setmmr1
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
argument_list|,
name|AMDR_MAP_STG
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_stgr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|audiosetinfo
parameter_list|(
name|sc
parameter_list|,
name|ai
parameter_list|)
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|audio_info
modifier|*
name|ai
decl_stmt|;
block|{
name|struct
name|audio_prinfo
modifier|*
name|r
init|=
operator|&
name|ai
operator|->
name|record
decl_stmt|,
modifier|*
name|p
init|=
operator|&
name|ai
operator|->
name|play
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|bsize
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|gain
operator|!=
operator|~
literal|0
condition|)
name|ausetpgain
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|gain
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|gain
operator|!=
operator|~
literal|0
condition|)
name|ausetrgain
argument_list|(
name|sc
argument_list|,
name|r
operator|->
name|gain
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|monitor_gain
operator|!=
operator|~
literal|0
condition|)
name|ausetmgain
argument_list|(
name|sc
argument_list|,
name|ai
operator|->
name|monitor_gain
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|port
operator|==
name|AUDIO_SPEAKER
condition|)
block|{
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator||=
name|AMD_MMR2_LS
expr_stmt|;
name|audio_setmmr2
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|port
operator|==
name|AUDIO_HEADPHONE
condition|)
block|{
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator|&=
operator|~
name|AMD_MMR2_LS
expr_stmt|;
name|audio_setmmr2
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|pause
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pause
operator|=
name|p
operator|->
name|pause
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|pause
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pause
operator|=
name|r
operator|->
name|pause
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|blocksize
operator|!=
operator|~
literal|0
condition|)
block|{
if|if
condition|(
name|ai
operator|->
name|blocksize
operator|==
literal|0
condition|)
name|bsize
operator|=
name|ai
operator|->
name|blocksize
operator|=
name|DEFBLKSIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|ai
operator|->
name|blocksize
operator|>
name|MAXBLKSIZE
condition|)
name|bsize
operator|=
name|ai
operator|->
name|blocksize
operator|=
name|MAXBLKSIZE
expr_stmt|;
else|else
name|bsize
operator|=
name|ai
operator|->
name|blocksize
expr_stmt|;
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
operator|=
name|bsize
expr_stmt|;
comment|/* AUDIO_FLUSH */
name|AUCB_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
argument_list|)
expr_stmt|;
name|AUCB_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ai
operator|->
name|hiwat
operator|!=
operator|~
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|ai
operator|->
name|hiwat
operator|<
name|AUCB_SIZE
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_hiwat
operator|=
name|ai
operator|->
name|hiwat
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|lowat
operator|!=
operator|~
literal|0
operator|&&
name|ai
operator|->
name|lowat
operator|<
name|AUCB_SIZE
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
operator|=
name|ai
operator|->
name|lowat
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|backlog
operator|!=
operator|~
literal|0
operator|&&
name|ai
operator|->
name|backlog
operator|<
operator|(
name|AUCB_SIZE
operator|/
literal|2
operator|)
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_backlog
operator|=
name|ai
operator|->
name|backlog
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sunaudiosetinfo
parameter_list|(
name|sc
parameter_list|,
name|ai
parameter_list|)
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sun_audio_info
modifier|*
name|ai
decl_stmt|;
block|{
name|struct
name|sun_audio_prinfo
modifier|*
name|r
init|=
operator|&
name|ai
operator|->
name|record
decl_stmt|,
modifier|*
name|p
init|=
operator|&
name|ai
operator|->
name|play
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|gain
operator|!=
operator|~
literal|0
condition|)
name|ausetpgain
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|gain
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|gain
operator|!=
operator|~
literal|0
condition|)
name|ausetrgain
argument_list|(
name|sc
argument_list|,
name|r
operator|->
name|gain
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|monitor_gain
operator|!=
operator|~
literal|0
condition|)
name|ausetmgain
argument_list|(
name|sc
argument_list|,
name|ai
operator|->
name|monitor_gain
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|port
operator|==
name|AUDIO_SPEAKER
condition|)
block|{
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator||=
name|AMD_MMR2_LS
expr_stmt|;
name|audio_setmmr2
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|port
operator|==
name|AUDIO_HEADPHONE
condition|)
block|{
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator|&=
operator|~
name|AMD_MMR2_LS
expr_stmt|;
name|audio_setmmr2
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The bsd driver does not distinguish between paused and active. 	 * (In the sun driver, not active means samples are not ouput 	 * at all, but paused means the last streams buffer is drained 	 * and then output stops.)  If either are 0, then when stop output. 	 * Otherwise, if either are non-zero, we resume. 	 */
if|if
condition|(
name|p
operator|->
name|pause
operator|==
literal|0
operator|||
name|p
operator|->
name|active
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pause
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|pause
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
operator|||
name|p
operator|->
name|active
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pause
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|pause
operator|==
literal|0
operator|||
name|r
operator|->
name|active
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pause
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|pause
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
operator|||
name|r
operator|->
name|active
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pause
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|audiogetinfo
parameter_list|(
name|sc
parameter_list|,
name|ai
parameter_list|)
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|audio_info
modifier|*
name|ai
decl_stmt|;
block|{
name|struct
name|audio_prinfo
modifier|*
name|r
init|=
operator|&
name|ai
operator|->
name|record
decl_stmt|,
modifier|*
name|p
init|=
operator|&
name|ai
operator|->
name|play
decl_stmt|;
name|p
operator|->
name|sample_rate
operator|=
name|r
operator|->
name|sample_rate
operator|=
literal|8000
expr_stmt|;
name|p
operator|->
name|channels
operator|=
name|r
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|precision
operator|=
name|r
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
name|p
operator|->
name|encoding
operator|=
name|r
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ULAW
expr_stmt|;
name|ai
operator|->
name|monitor_gain
operator|=
name|sc
operator|->
name|sc_mlevel
expr_stmt|;
name|r
operator|->
name|gain
operator|=
name|sc
operator|->
name|sc_rlevel
expr_stmt|;
name|p
operator|->
name|gain
operator|=
name|sc
operator|->
name|sc_plevel
expr_stmt|;
name|r
operator|->
name|port
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|port
operator|=
operator|(
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator|&
name|AMD_MMR2_LS
operator|)
condition|?
name|AUDIO_SPEAKER
else|:
name|AUDIO_HEADPHONE
expr_stmt|;
name|p
operator|->
name|pause
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pause
expr_stmt|;
name|r
operator|->
name|pause
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pause
expr_stmt|;
name|p
operator|->
name|error
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_drops
operator|!=
literal|0
expr_stmt|;
name|r
operator|->
name|error
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_drops
operator|!=
literal|0
expr_stmt|;
name|p
operator|->
name|open
operator|=
name|sc
operator|->
name|sc_open
expr_stmt|;
name|r
operator|->
name|open
operator|=
name|sc
operator|->
name|sc_open
expr_stmt|;
name|p
operator|->
name|samples
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|-
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pdrops
expr_stmt|;
name|r
operator|->
name|samples
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|-
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pdrops
expr_stmt|;
name|p
operator|->
name|seek
operator|=
name|sc
operator|->
name|sc_wseek
expr_stmt|;
name|r
operator|->
name|seek
operator|=
name|sc
operator|->
name|sc_rseek
expr_stmt|;
name|ai
operator|->
name|blocksize
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
expr_stmt|;
name|ai
operator|->
name|hiwat
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_hiwat
expr_stmt|;
name|ai
operator|->
name|lowat
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
expr_stmt|;
name|ai
operator|->
name|backlog
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_backlog
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sunaudiogetinfo
parameter_list|(
name|sc
parameter_list|,
name|ai
parameter_list|)
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sun_audio_info
modifier|*
name|ai
decl_stmt|;
block|{
name|struct
name|sun_audio_prinfo
modifier|*
name|r
init|=
operator|&
name|ai
operator|->
name|record
decl_stmt|,
modifier|*
name|p
init|=
operator|&
name|ai
operator|->
name|play
decl_stmt|;
name|p
operator|->
name|sample_rate
operator|=
name|r
operator|->
name|sample_rate
operator|=
literal|8000
expr_stmt|;
name|p
operator|->
name|channels
operator|=
name|r
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|precision
operator|=
name|r
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
name|p
operator|->
name|encoding
operator|=
name|r
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ULAW
expr_stmt|;
name|ai
operator|->
name|monitor_gain
operator|=
name|sc
operator|->
name|sc_mlevel
expr_stmt|;
name|r
operator|->
name|gain
operator|=
name|sc
operator|->
name|sc_rlevel
expr_stmt|;
name|p
operator|->
name|gain
operator|=
name|sc
operator|->
name|sc_plevel
expr_stmt|;
name|r
operator|->
name|port
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|port
operator|=
operator|(
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator|&
name|AMD_MMR2_LS
operator|)
condition|?
name|AUDIO_SPEAKER
else|:
name|AUDIO_HEADPHONE
expr_stmt|;
name|p
operator|->
name|active
operator|=
name|p
operator|->
name|pause
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pause
expr_stmt|;
name|r
operator|->
name|active
operator|=
name|r
operator|->
name|pause
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pause
expr_stmt|;
name|p
operator|->
name|error
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_drops
operator|!=
literal|0
expr_stmt|;
name|r
operator|->
name|error
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_drops
operator|!=
literal|0
expr_stmt|;
name|p
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|eof
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|eof
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|open
operator|=
name|sc
operator|->
name|sc_open
expr_stmt|;
name|r
operator|->
name|open
operator|=
name|sc
operator|->
name|sc_open
expr_stmt|;
name|p
operator|->
name|samples
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|-
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pdrops
expr_stmt|;
name|r
operator|->
name|samples
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|-
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pdrops
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

