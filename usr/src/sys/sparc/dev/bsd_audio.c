begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991, 1992 The Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratories.  *  * %sccs.include.redist.c%  *  *	@(#)bsd_audio.c	7.3 (Berkeley) %G%  *  * from: $Header: bsd_audio.c,v 1.14 92/07/03 23:21:23 mccanne Exp $ (LBL)  */
end_comment

begin_include
include|#
directive|include
file|"bsdaudio.h"
end_include

begin_if
if|#
directive|if
name|NBSDAUDIO
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|BSD
operator|<
literal|199103
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|SUNOS
end_ifndef

begin_define
define|#
directive|define
name|SUNOS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SUNOS
end_ifndef

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS
end_ifdef

begin_include
include|#
directive|include
file|<sundev/mbvar.h>
end_include

begin_include
include|#
directive|include
file|<sun4c/intreg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<machine/autoconf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/*  * Avoid name clashes with SunOS so we can config either the bsd or sun  * streams driver in a SunOS kernel.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS
end_ifdef

begin_include
include|#
directive|include
file|"sbusdev/bsd_audioreg.h"
end_include

begin_include
include|#
directive|include
file|"sbusdev/bsd_audiovar.h"
end_include

begin_include
include|#
directive|include
file|"sbusdev/bsd_audioio.h"
end_include

begin_struct
struct|struct
name|selinfo
block|{
name|struct
name|proc
modifier|*
name|si_proc
decl_stmt|;
name|int
name|si_coll
decl_stmt|;
block|}
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sparc/dev/bsd_audioreg.h>
end_include

begin_include
include|#
directive|include
file|<sparc/dev/bsd_audiovar.h>
end_include

begin_include
include|#
directive|include
file|<machine/bsd_audioio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS
end_ifdef

begin_include
include|#
directive|include
file|"bsd_audiocompat.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initial/default block size is patchable.  */
end_comment

begin_decl_stmt
name|int
name|audio_blocksize
init|=
name|DEFBLKSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Software state, per AMD79C30 audio chip.  */
end_comment

begin_struct
struct|struct
name|audio_softc
block|{
ifndef|#
directive|ifndef
name|SUNOS
name|struct
name|device
name|sc_dev
decl_stmt|;
comment|/* base device */
name|struct
name|intrhand
name|sc_hwih
decl_stmt|;
comment|/* hardware interrupt vector */
name|struct
name|intrhand
name|sc_swih
decl_stmt|;
comment|/* software interrupt vector */
endif|#
directive|endif
name|int
name|sc_interrupts
decl_stmt|;
comment|/* number of interrupts taken */
name|int
name|sc_open
decl_stmt|;
comment|/* single use device */
name|u_long
name|sc_wseek
decl_stmt|;
comment|/* timestamp of last frame written */
name|u_long
name|sc_rseek
decl_stmt|;
comment|/* timestamp of last frame read */
name|struct
name|mapreg
name|sc_map
decl_stmt|;
comment|/* current contents of map registers */
name|struct
name|selinfo
name|sc_wsel
decl_stmt|;
comment|/* write selector */
name|struct
name|selinfo
name|sc_rsel
decl_stmt|;
comment|/* read selector */
comment|/* 	 * keep track of levels so we don't have to convert back from 	 * MAP gain constants 	 */
name|int
name|sc_rlevel
decl_stmt|;
comment|/* record level */
name|int
name|sc_plevel
decl_stmt|;
comment|/* play level */
name|int
name|sc_mlevel
decl_stmt|;
comment|/* monitor level */
comment|/* sc_au is special in that the hardware interrupt handler uses it */
name|struct
name|auio
name|sc_au
decl_stmt|;
comment|/* recv and xmit buffers, etc */
block|}
struct|;
end_struct

begin_comment
comment|/* interrupt interfaces */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AUDIO_C_HANDLER
end_ifndef

begin_decl_stmt
name|int
name|audiohwintr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|audioswintr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward declarations */
end_comment

begin_decl_stmt
name|int
name|audio_sleep
name|__P
argument_list|(
operator|(
expr|struct
name|aucb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|audio_setmap
name|__P
argument_list|(
operator|(
specifier|volatile
expr|struct
name|amd7930
operator|*
operator|,
expr|struct
name|mapreg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|init_amd
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|AUDIO_C_HANDLER
argument_list|)
operator|||
name|defined
argument_list|(
name|SUNOS
argument_list|)
end_if

begin_decl_stmt
name|struct
name|auio
modifier|*
name|audio_au
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|audio_trap
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS
end_ifdef

begin_decl_stmt
name|struct
name|audio_softc
name|audio_softc
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SOFTC
parameter_list|(
name|dev
parameter_list|)
value|&audio_softc
end_define

begin_define
define|#
directive|define
name|UIOMOVE
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|,
name|code
parameter_list|,
name|uio
parameter_list|)
value|uiomove(cp, len, code, uio)
end_define

begin_define
define|#
directive|define
name|AUDIOOPEN
parameter_list|(
name|d
parameter_list|,
name|f
parameter_list|,
name|i
parameter_list|,
name|p
parameter_list|)
define|\
value|audioopen(d, f, i)\ 	dev_t d; int f, i;
end_define

begin_define
define|#
directive|define
name|AUDIOCLOSE
parameter_list|(
name|d
parameter_list|,
name|f
parameter_list|,
name|i
parameter_list|,
name|p
parameter_list|)
define|\
value|audioclose(d, f, i)\ 	dev_t d; int f, i;
end_define

begin_define
define|#
directive|define
name|AUDIOREAD
parameter_list|(
name|d
parameter_list|,
name|u
parameter_list|,
name|f
parameter_list|)
define|\
value|audioread(d, u) dev_t d; struct uio *u;
end_define

begin_define
define|#
directive|define
name|AUDIOWRITE
parameter_list|(
name|d
parameter_list|,
name|u
parameter_list|,
name|f
parameter_list|)
define|\
value|audiowrite(d, u) dev_t d; struct uio *u;
end_define

begin_define
define|#
directive|define
name|AUDIOIOCTL
parameter_list|(
name|d
parameter_list|,
name|c
parameter_list|,
name|a
parameter_list|,
name|f
parameter_list|,
name|o
parameter_list|)
define|\
value|audioioctl(d, c, a, f)\ 	dev_t d; int c; caddr_t a; int f;
end_define

begin_define
define|#
directive|define
name|AUDIOSELECT
parameter_list|(
name|d
parameter_list|,
name|r
parameter_list|,
name|p
parameter_list|)
define|\
value|audio_select(d, r, p)\ 	dev_t d; int r; struct proc *p;
end_define

begin_define
define|#
directive|define
name|AUDIO_SET_SWINTR
value|set_intreg(IR_SOFT_INT4, 1)
end_define

begin_function
name|int
name|audioselect
parameter_list|(
name|dev
parameter_list|,
name|rw
parameter_list|)
specifier|register
name|dev_t
name|dev
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{
return|return
operator|(
name|audio_select
argument_list|(
name|dev
argument_list|,
name|rw
argument_list|,
name|u
operator|.
name|u_procp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|selrecord
parameter_list|(
name|p
parameter_list|,
name|si
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|selinfo
modifier|*
name|si
decl_stmt|;
block|{
if|if
condition|(
name|si
operator|->
name|si_proc
operator|!=
literal|0
condition|)
name|si
operator|->
name|si_coll
operator|=
literal|1
expr_stmt|;
else|else
name|si
operator|->
name|si_proc
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SELWAKEUP
parameter_list|(
name|si
parameter_list|)
define|\
value|{\ 	 if ((si)->si_proc != 0) {\ 		selwakeup((si)->si_proc, (si)->si_coll); \ 		(si)->si_proc = 0;\ 		(si)->si_coll = 0;\ 	}\ }
end_define

begin_function_decl
specifier|static
name|int
name|audioattach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|audioidentify
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|dev_ops
name|bsdaudio_ops
init|=
block|{
literal|0
block|,
name|audioidentify
block|,
name|audioattach
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|audioidentify
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"audio"
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|audioattach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|dev_info
modifier|*
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
name|struct
name|dev_reg
modifier|*
name|reg
decl_stmt|;
name|sc
operator|=
operator|&
name|audio_softc
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|devi_nreg
operator|!=
literal|1
operator|||
name|dev
operator|->
name|devi_nintr
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"audio: bad config\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|reg
operator|=
name|dev
operator|->
name|devi_reg
expr_stmt|;
name|amd
operator|=
operator|(
expr|struct
name|amd7930
operator|*
operator|)
name|map_regs
argument_list|(
name|reg
operator|->
name|reg_addr
argument_list|,
name|reg
operator|->
name|reg_size
argument_list|,
name|reg
operator|->
name|reg_bustype
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
operator|=
name|amd
expr_stmt|;
name|init_amd
argument_list|(
name|amd
argument_list|)
expr_stmt|;
name|audio_au
operator|=
operator|&
name|sc
operator|->
name|sc_au
expr_stmt|;
ifndef|#
directive|ifndef
name|AUDIO_C_HANDLER
name|settrap
argument_list|(
name|dev
operator|->
name|devi_intr
operator|->
name|int_pri
argument_list|,
name|audio_trap
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* XXX */
name|addintr
argument_list|(
name|dev
operator|->
name|devi_intr
operator|->
name|int_pri
argument_list|,
name|audiohwintr
argument_list|,
name|dev
operator|->
name|devi_name
argument_list|,
name|dev
operator|->
name|devi_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addintr
argument_list|(
literal|4
argument_list|,
name|audioswintr
argument_list|,
name|dev
operator|->
name|devi_name
argument_list|,
name|dev
operator|->
name|devi_unit
argument_list|)
expr_stmt|;
name|report_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AUDIOOPEN
parameter_list|(
name|d
parameter_list|,
name|f
parameter_list|,
name|i
parameter_list|,
name|p
parameter_list|)
value|audioopen(dev_t d, int f, int i, struct proc *p)
end_define

begin_define
define|#
directive|define
name|AUDIOCLOSE
parameter_list|(
name|d
parameter_list|,
name|f
parameter_list|,
name|i
parameter_list|,
name|p
parameter_list|)
value|audioclose(dev_t d, int f, int i, \ 					  struct proc *p)
end_define

begin_define
define|#
directive|define
name|AUDIOREAD
parameter_list|(
name|d
parameter_list|,
name|u
parameter_list|,
name|f
parameter_list|)
value|audioread(dev_t d, struct uio *u, int f)
end_define

begin_define
define|#
directive|define
name|AUDIOWRITE
parameter_list|(
name|d
parameter_list|,
name|u
parameter_list|,
name|f
parameter_list|)
value|audiowrite(dev_t d, struct uio *u, int f)
end_define

begin_define
define|#
directive|define
name|AUDIOIOCTL
parameter_list|(
name|d
parameter_list|,
name|c
parameter_list|,
name|a
parameter_list|,
name|f
parameter_list|,
name|o
parameter_list|)
define|\
value|audioioctl(dev_t dev, int c, caddr_t a, int f, struct proc *p)
end_define

begin_define
define|#
directive|define
name|AUDIOSELECT
parameter_list|(
name|d
parameter_list|,
name|r
parameter_list|,
name|p
parameter_list|)
value|audioselect(dev_t dev, int rw, struct proc *p)
end_define

begin_define
define|#
directive|define
name|SELWAKEUP
value|selwakeup
end_define

begin_define
define|#
directive|define
name|AUDIO_SET_SWINTR
value|ienab_bis(IE_L6)
end_define

begin_comment
comment|/* autoconfiguration driver */
end_comment

begin_function_decl
name|void
name|audioattach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfdriver
name|audiocd
init|=
block|{
name|NULL
block|,
literal|"audio"
block|,
name|matchbyname
block|,
name|audioattach
block|,
name|DV_DULL
block|,
expr|sizeof
operator|(
expr|struct
name|audio_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SOFTC
parameter_list|(
name|dev
parameter_list|)
value|audiocd.cd_devs[minor(dev)]
end_define

begin_define
define|#
directive|define
name|UIOMOVE
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|,
name|code
parameter_list|,
name|uio
parameter_list|)
value|uiomove(cp, len, uio)
end_define

begin_comment
comment|/*  * Audio chip found.  */
end_comment

begin_function
name|void
name|audioattach
parameter_list|(
name|parent
parameter_list|,
name|self
parameter_list|,
name|args
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|,
decl|*
name|self
decl_stmt|;
end_function

begin_decl_stmt
name|void
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|audio_softc
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|romaux
modifier|*
name|ra
init|=
name|args
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
specifier|register
name|int
name|pri
decl_stmt|;
if|if
condition|(
name|ra
operator|->
name|ra_nintr
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|": expected 1 interrupt, got %d\n"
argument_list|,
name|ra
operator|->
name|ra_nintr
argument_list|)
expr_stmt|;
return|return;
block|}
name|pri
operator|=
name|ra
operator|->
name|ra_intr
index|[
literal|0
index|]
operator|.
name|int_pri
expr_stmt|;
name|printf
argument_list|(
literal|" pri %d, softpri %d\n"
argument_list|,
name|pri
argument_list|,
name|PIL_AUSOFT
argument_list|)
expr_stmt|;
name|amd
operator|=
operator|(
specifier|volatile
expr|struct
name|amd7930
operator|*
operator|)
operator|(
name|ra
operator|->
name|ra_vaddr
condition|?
name|ra
operator|->
name|ra_vaddr
else|:
name|mapiodev
argument_list|(
name|ra
operator|->
name|ra_paddr
argument_list|,
sizeof|sizeof
expr|*
name|amd
argument_list|)
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
operator|=
name|amd
expr_stmt|;
name|init_amd
argument_list|(
name|amd
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|AUDIO_C_HANDLER
name|audio_au
operator|=
operator|&
name|sc
operator|->
name|sc_au
expr_stmt|;
name|intr_fasttrap
argument_list|(
name|pri
argument_list|,
name|audio_trap
argument_list|)
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|sc_hwih
operator|.
name|ih_fun
operator|=
name|audiohwintr
expr_stmt|;
name|sc
operator|->
name|sc_hwih
operator|.
name|ih_arg
operator|=
operator|&
name|sc
operator|->
name|sc_au
expr_stmt|;
name|intr_establish
argument_list|(
name|pri
argument_list|,
operator|&
name|sc
operator|->
name|sc_hwih
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_swih
operator|.
name|ih_fun
operator|=
name|audioswintr
expr_stmt|;
name|sc
operator|->
name|sc_swih
operator|.
name|ih_arg
operator|=
name|sc
expr_stmt|;
name|intr_establish
argument_list|(
name|PIL_AUSOFT
argument_list|,
operator|&
name|sc
operator|->
name|sc_swih
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|init_amd
parameter_list|(
name|amd
parameter_list|)
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
block|{
comment|/* disable interrupts */
name|amd
operator|->
name|cr
operator|=
name|AMDR_INIT
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|AMD_INIT_PMS_ACTIVE
operator||
name|AMD_INIT_INT_DISABLE
expr_stmt|;
comment|/* 	 * Initialize the mux unit.  We use MCR3 to route audio (MAP) 	 * through channel Bb.  MCR1 and MCR2 are unused. 	 * Setting the INT enable bit in MCR4 will generate an interrupt 	 * on each converted audio sample. 	 */
name|amd
operator|->
name|cr
operator|=
name|AMDR_MUX_1_4
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
literal|0
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
literal|0
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
operator|(
name|AMD_MCRCHAN_BB
operator|<<
literal|4
operator|)
operator||
name|AMD_MCRCHAN_BA
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|AMD_MCR4_INT_ENABLE
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|audio_default_level
init|=
literal|150
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ausetrgain
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ausetpgain
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|audiosetinfo
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
expr|struct
name|audio_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|audiogetinfo
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
expr|struct
name|audio_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|sun_audio_info
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|int
name|sunaudiosetinfo
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
expr|struct
name|sun_audio_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sunaudiogetinfo
name|__P
argument_list|(
operator|(
expr|struct
name|audio_softc
operator|*
operator|,
expr|struct
name|sun_audio_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|audio_setmmr2
name|__P
argument_list|(
operator|(
specifier|volatile
expr|struct
name|amd7930
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|AUDIOOPEN
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|ifmt
parameter_list|,
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|error
decl_stmt|,
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|SUNOS
if|if
condition|(
name|unit
operator|>
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
operator|&
name|audio_softc
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|unit
operator|>=
name|audiocd
operator|.
name|cd_ndevs
operator|||
operator|(
name|sc
operator|=
name|audiocd
operator|.
name|cd_devs
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_open
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|->
name|sc_open
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
operator|=
name|audio_blocksize
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_hiwat
operator|=
name|AUCB_SIZE
operator|-
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
operator|=
name|audio_blocksize
expr_stmt|;
comment|/* set up read and write blocks and `dead sound' zero value. */
name|AUCB_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_thresh
operator|=
name|AUCB_SIZE
expr_stmt|;
name|AUCB_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_thresh
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* nothing read or written yet */
name|sc
operator|->
name|sc_rseek
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_wseek
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_map
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|sc_map
argument_list|)
expr_stmt|;
comment|/* default to speaker */
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator|=
name|AMD_MMR2_AINB
operator||
name|AMD_MMR2_LS
expr_stmt|;
comment|/* enable interrupts and set parameters established above */
name|amd
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
expr_stmt|;
name|audio_setmmr2
argument_list|(
name|amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
argument_list|)
expr_stmt|;
name|ausetrgain
argument_list|(
name|sc
argument_list|,
name|audio_default_level
argument_list|)
expr_stmt|;
name|ausetpgain
argument_list|(
name|sc
argument_list|,
name|audio_default_level
argument_list|)
expr_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_INIT
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|AMD_INIT_PMS_ACTIVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|audio_drain
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|int
name|error
decl_stmt|;
while|while
condition|(
operator|!
name|AUCB_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
argument_list|)
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|audio_sleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close an audio chip.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|AUDIOCLOSE
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|ifmt
parameter_list|,
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
init|=
name|SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
specifier|register
name|struct
name|aucb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
comment|/* 	 * Block until output drains, but allow ^C interrupt. 	 */
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
operator|=
literal|0
expr_stmt|;
comment|/* avoid excessive wakeups */
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
comment|/* 	 * If there is pending output, let it drain (unless 	 * the output is paused). 	 */
name|cb
operator|=
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
expr_stmt|;
if|if
condition|(
operator|!
name|AUCB_EMPTY
argument_list|(
name|cb
argument_list|)
operator|&&
operator|!
name|cb
operator|->
name|cb_pause
condition|)
operator|(
name|void
operator|)
name|audio_drain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Disable interrupts, clear open flag, and done. 	 */
name|amd
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
expr_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_INIT
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|AMD_INIT_PMS_ACTIVE
operator||
name|AMD_INIT_INT_DISABLE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_open
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|audio_sleep
parameter_list|(
name|cb
parameter_list|,
name|thresh
parameter_list|)
specifier|register
name|struct
name|aucb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|int
name|thresh
decl_stmt|;
block|{
specifier|register
name|int
name|error
decl_stmt|;
name|cb
operator|->
name|cb_thresh
operator|=
name|thresh
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
argument_list|,
operator|(
name|PZERO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
literal|"audio"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|AUDIOREAD
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|)
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
init|=
name|SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|aucb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|n
decl_stmt|,
name|head
decl_stmt|,
name|taildata
decl_stmt|,
name|error
decl_stmt|;
specifier|register
name|int
name|blocksize
init|=
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cb
operator|=
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
name|cb
operator|->
name|cb_drops
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rseek
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|-
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
expr_stmt|;
do|do
block|{
while|while
condition|(
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|<
name|blocksize
condition|)
block|{
ifndef|#
directive|ifndef
name|SUNOS
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|audio_sleep
argument_list|(
name|cb
argument_list|,
name|blocksize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * The space calculation can only err on the short 		 * side if an interrupt occurs during processing: 		 * only cb_tail is altered in the interrupt code. 		 */
name|head
operator|=
name|cb
operator|->
name|cb_head
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|)
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|n
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|taildata
operator|=
name|AUCB_SIZE
operator|-
name|head
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|taildata
condition|)
block|{
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
operator|->
name|cb_data
operator|+
name|head
argument_list|,
name|taildata
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
operator|->
name|cb_data
argument_list|,
name|n
operator|-
name|taildata
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
operator|->
name|cb_data
operator|+
name|head
argument_list|,
name|n
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|head
operator|=
name|AUCB_MOD
argument_list|(
name|head
operator|+
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splaudio
argument_list|()
expr_stmt|;
name|cb
operator|->
name|cb_head
operator|=
name|head
expr_stmt|;
block|}
do|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>=
name|blocksize
condition|)
do|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|AUDIOWRITE
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|)
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
init|=
name|SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|aucb
modifier|*
name|cb
init|=
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|n
decl_stmt|,
name|tail
decl_stmt|,
name|tailspace
decl_stmt|,
name|error
decl_stmt|,
name|first
decl_stmt|,
name|watermark
decl_stmt|,
name|drops
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|watermark
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_hiwat
expr_stmt|;
while|while
condition|(
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|>
name|watermark
condition|)
block|{
ifndef|#
directive|ifndef
name|SUNOS
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|audio_sleep
argument_list|(
name|cb
argument_list|,
name|watermark
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|watermark
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * The only value that can change on an interrupt is 		 * cb->cb_head.  We only pull that out once to decide 		 * how much to write into cb_data; if we lose a race 		 * and cb_head changes, we will merely be overly 		 * conservative.  For a legitimate time stamp, 		 * however, we need to synchronize the accesses to 		 * au_stamp and cb_head at a high ipl below. 		 */
if|if
condition|(
operator|(
name|n
operator|=
name|AUCB_SIZE
operator|-
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|-
literal|1
operator|)
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|n
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|tail
operator|=
name|cb
operator|->
name|cb_tail
expr_stmt|;
name|tailspace
operator|=
name|AUCB_SIZE
operator|-
name|tail
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|tailspace
condition|)
block|{
comment|/* write first part at tail and rest at head */
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
operator|->
name|cb_data
operator|+
name|tail
argument_list|,
name|tailspace
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
operator|->
name|cb_data
argument_list|,
name|n
operator|-
name|tailspace
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb
operator|->
name|cb_data
operator|+
name|tail
argument_list|,
name|n
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * We cannot do this outside the loop because if the 		 * buffer is empty, an indeterminate amount of time 		 * will pass before the output starts to drain. 		 */
operator|(
name|void
operator|)
name|splaudio
argument_list|()
expr_stmt|;
name|tail
operator|=
name|AUCB_MOD
argument_list|(
name|tail
operator|+
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_wseek
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|+
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/*  			 * To guarantee that a write is contiguous in the 			 * sample space, we clear the drop count the first 			 * time through.  If we later get drops, we will 			 * break out of the loop below, before writing 			 * a new frame. 			 * XXX I think we're one iteration too late! 			 */
name|cb
operator|->
name|cb_drops
operator|=
literal|0
expr_stmt|;
block|}
name|cb
operator|->
name|cb_tail
operator|=
name|tail
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_drops
operator|!=
literal|0
condition|)
break|break;
block|}
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Sun audio compatibility */
end_comment

begin_struct
struct|struct
name|sun_audio_prinfo
block|{
name|u_int
name|sample_rate
decl_stmt|;
name|u_int
name|channels
decl_stmt|;
name|u_int
name|precision
decl_stmt|;
name|u_int
name|encoding
decl_stmt|;
name|u_int
name|gain
decl_stmt|;
name|u_int
name|port
decl_stmt|;
name|u_int
name|reserved0
index|[
literal|4
index|]
decl_stmt|;
name|u_int
name|samples
decl_stmt|;
name|u_int
name|eof
decl_stmt|;
name|u_char
name|pause
decl_stmt|;
name|u_char
name|error
decl_stmt|;
name|u_char
name|waiting
decl_stmt|;
name|u_char
name|reserved1
index|[
literal|3
index|]
decl_stmt|;
name|u_char
name|open
decl_stmt|;
name|u_char
name|active
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sun_audio_info
block|{
name|struct
name|sun_audio_prinfo
name|play
decl_stmt|;
name|struct
name|sun_audio_prinfo
name|record
decl_stmt|;
name|u_int
name|monitor_gain
decl_stmt|;
name|u_int
name|reserved
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|SUNOS
end_ifndef

begin_define
define|#
directive|define
name|SUNAUDIO_GETINFO
value|_IOR('A', 1, struct sun_audio_info)
end_define

begin_define
define|#
directive|define
name|SUNAUDIO_SETINFO
value|_IOWR('A', 2, struct sun_audio_info)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SUNAUDIO_GETINFO
value|_IOR(A, 1, struct sun_audio_info)
end_define

begin_define
define|#
directive|define
name|SUNAUDIO_SETINFO
value|_IOWR(A, 2, struct sun_audio_info)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|AUDIOIOCTL
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|addr
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
init|=
name|SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AUDIO_GETMAP
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_map
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_map
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIO_SETMAP
case|:
name|bcopy
argument_list|(
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_map
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_map
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator|&=
literal|0x7f
expr_stmt|;
name|audio_setmap
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
operator|&
name|sc
operator|->
name|sc_map
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIO_FLUSH
case|:
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
name|AUCB_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
argument_list|)
expr_stmt|;
name|AUCB_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_wseek
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rseek
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 	 * Number of read samples dropped.  We don't know where or 	 * when they were dropped. 	 */
case|case
name|AUDIO_RERROR
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_drops
operator|!=
literal|0
expr_stmt|;
break|break;
comment|/* 	 * Timestamp of last frame written. 	 */
case|case
name|AUDIO_WSEEK
case|:
operator|*
operator|(
name|u_long
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|sc_wseek
expr_stmt|;
break|break;
case|case
name|AUDIO_SETINFO
case|:
name|error
operator|=
name|audiosetinfo
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|audio_info
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIO_GETINFO
case|:
name|error
operator|=
name|audiogetinfo
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|audio_info
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUNAUDIO_GETINFO
case|:
name|error
operator|=
name|sunaudiogetinfo
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|sun_audio_info
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUNAUDIO_SETINFO
case|:
name|error
operator|=
name|sunaudiosetinfo
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|sun_audio_info
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIO_DRAIN
case|:
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
name|error
operator|=
name|audio_drain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|AUDIOSELECT
parameter_list|(
name|dev
parameter_list|,
name|rw
parameter_list|,
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
init|=
name|SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|aucb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splaudio
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
name|FREAD
case|:
name|cb
operator|=
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
expr_stmt|;
if|if
condition|(
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|>=
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|sc_rsel
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_thresh
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
expr_stmt|;
break|break;
case|case
name|FWRITE
case|:
name|cb
operator|=
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
expr_stmt|;
if|if
condition|(
name|AUCB_LEN
argument_list|(
name|cb
argument_list|)
operator|<=
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|sc_wsel
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_thresh
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AUDIO_C_HANDLER
end_ifdef

begin_function
name|int
name|audiohwintr
parameter_list|(
name|au0
parameter_list|)
name|void
modifier|*
name|au0
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SUNOS
specifier|register
name|struct
name|auio
modifier|*
name|au
init|=
name|audio_au
decl_stmt|;
else|#
directive|else
specifier|register
name|struct
name|auio
modifier|*
name|au
init|=
name|au0
decl_stmt|;
endif|#
directive|endif
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
init|=
name|au
operator|->
name|au_amd
decl_stmt|;
specifier|register
name|struct
name|aucb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|int
name|h
decl_stmt|,
name|t
decl_stmt|,
name|k
decl_stmt|;
name|k
operator|=
name|amd
operator|->
name|ir
expr_stmt|;
comment|/* clear interrupt */
operator|++
name|au
operator|->
name|au_stamp
expr_stmt|;
comment|/* receive incoming data */
name|cb
operator|=
operator|&
name|au
operator|->
name|au_rb
expr_stmt|;
name|h
operator|=
name|cb
operator|->
name|cb_head
expr_stmt|;
name|t
operator|=
name|cb
operator|->
name|cb_tail
expr_stmt|;
name|k
operator|=
name|AUCB_MOD
argument_list|(
name|t
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|k
condition|)
name|cb
operator|->
name|cb_drops
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|cb
operator|->
name|cb_pause
operator|!=
literal|0
condition|)
name|cb
operator|->
name|cb_pdrops
operator|++
expr_stmt|;
else|else
block|{
name|cb
operator|->
name|cb_data
index|[
name|t
index|]
operator|=
name|amd
operator|->
name|bbrb
expr_stmt|;
name|cb
operator|->
name|cb_tail
operator|=
name|t
operator|=
name|k
expr_stmt|;
block|}
if|if
condition|(
name|AUCB_MOD
argument_list|(
name|t
operator|-
name|h
argument_list|)
operator|>=
name|cb
operator|->
name|cb_thresh
condition|)
block|{
name|cb
operator|->
name|cb_thresh
operator|=
name|AUCB_SIZE
expr_stmt|;
name|cb
operator|->
name|cb_waking
operator|=
literal|1
expr_stmt|;
name|AUDIO_SET_SWINTR
expr_stmt|;
block|}
comment|/* send outgoing data */
name|cb
operator|=
operator|&
name|au
operator|->
name|au_wb
expr_stmt|;
name|h
operator|=
name|cb
operator|->
name|cb_head
expr_stmt|;
name|t
operator|=
name|cb
operator|->
name|cb_tail
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|t
condition|)
name|cb
operator|->
name|cb_drops
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|cb
operator|->
name|cb_pause
operator|!=
literal|0
condition|)
name|cb
operator|->
name|cb_pdrops
operator|++
expr_stmt|;
else|else
block|{
name|cb
operator|->
name|cb_head
operator|=
name|h
operator|=
name|AUCB_MOD
argument_list|(
name|h
operator|+
literal|1
argument_list|)
expr_stmt|;
name|amd
operator|->
name|bbtb
operator|=
name|cb
operator|->
name|cb_data
index|[
name|h
index|]
expr_stmt|;
block|}
if|if
condition|(
name|AUCB_MOD
argument_list|(
name|t
operator|-
name|h
argument_list|)
operator|<=
name|cb
operator|->
name|cb_thresh
condition|)
block|{
name|cb
operator|->
name|cb_thresh
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|->
name|cb_waking
operator|=
literal|1
expr_stmt|;
name|AUDIO_SET_SWINTR
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|audioswintr
parameter_list|(
name|sc0
parameter_list|)
name|void
modifier|*
name|sc0
decl_stmt|;
block|{
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SUNOS
name|sc
operator|=
operator|&
name|audio_softc
expr_stmt|;
else|#
directive|else
name|sc
operator|=
name|sc0
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_waking
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_waking
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
argument_list|)
expr_stmt|;
name|SELWAKEUP
argument_list|(
operator|&
name|sc
operator|->
name|sc_rsel
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splaudio
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_waking
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_waking
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
argument_list|)
expr_stmt|;
name|SELWAKEUP
argument_list|(
operator|&
name|sc
operator|->
name|sc_wsel
argument_list|)
expr_stmt|;
block|}
else|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write 16 bits of data from variable v to the data port of the audio chip */
end_comment

begin_define
define|#
directive|define
name|WAMD16
parameter_list|(
name|amd
parameter_list|,
name|v
parameter_list|)
value|((amd)->dr = v, (amd)->dr = v>> 8)
end_define

begin_function
name|void
name|audio_setmap
parameter_list|(
name|amd
parameter_list|,
name|map
parameter_list|)
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
specifier|register
name|struct
name|mapreg
modifier|*
name|map
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|v
decl_stmt|;
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_MAP_1_10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|map
operator|->
name|mr_x
index|[
name|i
index|]
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
name|v
operator|=
name|map
operator|->
name|mr_r
index|[
name|i
index|]
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|map
operator|->
name|mr_gx
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|map
operator|->
name|mr_gr
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|map
operator|->
name|mr_ger
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|map
operator|->
name|mr_stgr
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|map
operator|->
name|mr_ftgr
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|map
operator|->
name|mr_atgr
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|map
operator|->
name|mr_mmr1
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|map
operator|->
name|mr_mmr2
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the mmr1 register and one other 16 bit register in the audio chip.  * The other register is indicated by op and val.  */
end_comment

begin_function
name|void
name|audio_setmmr1
parameter_list|(
name|amd
parameter_list|,
name|mmr1
parameter_list|,
name|op
parameter_list|,
name|val
parameter_list|)
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
specifier|register
name|int
name|mmr1
decl_stmt|;
specifier|register
name|int
name|op
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
block|{
specifier|register
name|int
name|s
init|=
name|splaudio
argument_list|()
decl_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_MAP_MMR1
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|mmr1
expr_stmt|;
name|amd
operator|->
name|cr
operator|=
name|op
expr_stmt|;
name|WAMD16
argument_list|(
name|amd
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set only the mmr1 regsiter, and one other.  */
end_comment

begin_function
specifier|static
name|void
name|audio_setmmr2
parameter_list|(
name|amd
parameter_list|,
name|mmr2
parameter_list|)
specifier|register
specifier|volatile
name|struct
name|amd7930
modifier|*
name|amd
decl_stmt|;
specifier|register
name|int
name|mmr2
decl_stmt|;
block|{
specifier|register
name|int
name|s
init|=
name|splaudio
argument_list|()
decl_stmt|;
name|amd
operator|->
name|cr
operator|=
name|AMDR_MAP_MMR2
expr_stmt|;
name|amd
operator|->
name|dr
operator|=
name|mmr2
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_short
name|ger_coeff
index|[]
init|=
block|{
literal|0xaaaa
block|,
literal|0x9bbb
block|,
literal|0x79ac
block|,
literal|0x099a
block|,
literal|0x4199
block|,
literal|0x3199
block|,
literal|0x9cde
block|,
literal|0x9def
block|,
literal|0x749c
block|,
literal|0x549d
block|,
literal|0x6aae
block|,
literal|0xabcd
block|,
literal|0xabdf
block|,
literal|0x7429
block|,
literal|0x64ab
block|,
literal|0x6aff
block|,
literal|0x2abd
block|,
literal|0xbeef
block|,
literal|0x5cce
block|,
literal|0x75cd
block|,
literal|0x0099
block|,
literal|0x554c
block|,
literal|0x43dd
block|,
literal|0x33dd
block|,
literal|0x52ef
block|,
literal|0x771b
block|,
literal|0x5542
block|,
literal|0x41dd
block|,
literal|0x31dd
block|,
literal|0x441f
block|,
literal|0x431f
block|,
literal|0x331f
block|,
literal|0x40dd
block|,
literal|0x11dd
block|,
literal|0x440f
block|,
literal|0x411f
block|,
literal|0x311f
block|,
literal|0x5520
block|,
literal|0x10dd
block|,
literal|0x4211
block|,
literal|0x410f
block|,
literal|0x111f
block|,
literal|0x600b
block|,
literal|0x00dd
block|,
literal|0x4210
block|,
literal|0x400f
block|,
literal|0x110f
block|,
literal|0x2210
block|,
literal|0x7200
block|,
literal|0x4200
block|,
literal|0x2110
block|,
literal|0x100f
block|,
literal|0x2200
block|,
literal|0x1110
block|,
literal|0x000b
block|,
literal|0x2100
block|,
literal|0x000f
block|,
define|#
directive|define
name|NGER
value|(sizeof(ger_coeff) / sizeof(ger_coeff[0]))
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|gx_coeff
index|[]
init|=
block|{
literal|0x0808
block|,
literal|0x4cb2
block|,
literal|0x3dac
block|,
literal|0x2ae5
block|,
literal|0x2533
block|,
literal|0x2222
block|,
literal|0x2122
block|,
literal|0x1fd3
block|,
literal|0x12a2
block|,
literal|0x121b
block|,
literal|0x113b
block|,
literal|0x0bc3
block|,
literal|0x10f2
block|,
literal|0x03ba
block|,
literal|0x02ca
block|,
literal|0x021d
block|,
literal|0x015a
block|,
literal|0x0122
block|,
literal|0x0112
block|,
literal|0x00ec
block|,
literal|0x0032
block|,
literal|0x0021
block|,
literal|0x0013
block|,
literal|0x0011
block|,
literal|0x000e
block|,
define|#
directive|define
name|NGX
value|(sizeof(gx_coeff) / sizeof(gx_coeff[0]))
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|stg_coeff
index|[]
init|=
block|{
literal|0x8b7c
block|,
literal|0x8b44
block|,
literal|0x8b35
block|,
literal|0x8b2a
block|,
literal|0x8b24
block|,
literal|0x8b22
block|,
literal|0x9123
block|,
literal|0x912e
block|,
literal|0x912a
block|,
literal|0x9132
block|,
literal|0x913b
block|,
literal|0x914b
block|,
literal|0x91f9
block|,
literal|0x91c5
block|,
literal|0x91b6
block|,
literal|0x9212
block|,
literal|0x91a4
block|,
literal|0x9222
block|,
literal|0x9232
block|,
literal|0x92fb
block|,
literal|0x92aa
block|,
literal|0x9327
block|,
literal|0x93b3
block|,
literal|0x94b3
block|,
literal|0x9f91
block|,
literal|0x9cea
block|,
literal|0x9bf9
block|,
literal|0x9aac
block|,
literal|0x9a4a
block|,
literal|0xa222
block|,
literal|0xa2a2
block|,
literal|0xa68d
block|,
literal|0xaaa3
block|,
literal|0xb242
block|,
literal|0xbb52
block|,
literal|0xcbb2
block|,
literal|0x0808
block|,
define|#
directive|define
name|NSTG
value|(sizeof(stg_coeff) / sizeof(stg_coeff[0]))
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ausetrgain
parameter_list|(
name|sc
parameter_list|,
name|level
parameter_list|)
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
block|{
name|level
operator|&=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|sc_rlevel
operator|=
name|level
expr_stmt|;
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
operator||=
name|AMD_MMR1_GX
expr_stmt|;
else|else
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
operator|&=
operator|~
name|AMD_MMR1_GX
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|.
name|mr_gx
operator|=
name|gx_coeff
index|[
operator|(
name|level
operator|*
name|NGX
operator|)
operator|/
literal|256
index|]
expr_stmt|;
name|audio_setmmr1
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
argument_list|,
name|AMDR_MAP_GX
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_gx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ausetpgain
parameter_list|(
name|sc
parameter_list|,
name|level
parameter_list|)
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
block|{
name|level
operator|&=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|sc_plevel
operator|=
name|level
expr_stmt|;
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
operator||=
name|AMD_MMR1_GER
expr_stmt|;
else|else
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
operator|&=
operator|~
name|AMD_MMR1_GER
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|.
name|mr_ger
operator|=
name|ger_coeff
index|[
operator|(
name|level
operator|*
name|NGER
operator|)
operator|/
literal|256
index|]
expr_stmt|;
name|audio_setmmr1
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
argument_list|,
name|AMDR_MAP_GER
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_ger
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ausetmgain
parameter_list|(
name|sc
parameter_list|,
name|level
parameter_list|)
specifier|register
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
block|{
name|level
operator|&=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|sc_mlevel
operator|=
name|level
expr_stmt|;
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
operator||=
name|AMD_MMR1_STG
expr_stmt|;
else|else
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
operator|&=
operator|~
name|AMD_MMR1_STG
expr_stmt|;
name|sc
operator|->
name|sc_map
operator|.
name|mr_stgr
operator|=
name|stg_coeff
index|[
operator|(
name|level
operator|*
name|NSTG
operator|)
operator|/
literal|256
index|]
expr_stmt|;
name|audio_setmmr1
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr1
argument_list|,
name|AMDR_MAP_STG
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_stgr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|audiosetinfo
parameter_list|(
name|sc
parameter_list|,
name|ai
parameter_list|)
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|audio_info
modifier|*
name|ai
decl_stmt|;
block|{
name|struct
name|audio_prinfo
modifier|*
name|r
init|=
operator|&
name|ai
operator|->
name|record
decl_stmt|,
modifier|*
name|p
init|=
operator|&
name|ai
operator|->
name|play
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|bsize
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|gain
operator|!=
operator|~
literal|0
condition|)
name|ausetpgain
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|gain
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|gain
operator|!=
operator|~
literal|0
condition|)
name|ausetrgain
argument_list|(
name|sc
argument_list|,
name|r
operator|->
name|gain
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|monitor_gain
operator|!=
operator|~
literal|0
condition|)
name|ausetmgain
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|gain
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|port
operator|==
name|AUDIO_SPEAKER
condition|)
block|{
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator||=
name|AMD_MMR2_LS
expr_stmt|;
name|audio_setmmr2
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|port
operator|==
name|AUDIO_HEADPHONE
condition|)
block|{
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator|&=
operator|~
name|AMD_MMR2_LS
expr_stmt|;
name|audio_setmmr2
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|pause
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pause
operator|=
name|p
operator|->
name|pause
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|pause
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pause
operator|=
name|r
operator|->
name|pause
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|blocksize
operator|!=
operator|~
literal|0
condition|)
block|{
if|if
condition|(
name|ai
operator|->
name|blocksize
operator|==
literal|0
condition|)
name|bsize
operator|=
name|ai
operator|->
name|blocksize
operator|=
name|DEFBLKSIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|ai
operator|->
name|blocksize
operator|>
name|MAXBLKSIZE
condition|)
name|bsize
operator|=
name|ai
operator|->
name|blocksize
operator|=
name|MAXBLKSIZE
expr_stmt|;
else|else
name|bsize
operator|=
name|ai
operator|->
name|blocksize
expr_stmt|;
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
operator|=
name|bsize
expr_stmt|;
comment|/* AUDIO_FLUSH */
name|AUCB_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
argument_list|)
expr_stmt|;
name|AUCB_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ai
operator|->
name|hiwat
operator|!=
operator|~
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|ai
operator|->
name|hiwat
operator|<
name|AUCB_SIZE
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_hiwat
operator|=
name|ai
operator|->
name|hiwat
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|lowat
operator|!=
operator|~
literal|0
operator|&&
name|ai
operator|->
name|lowat
operator|<
name|AUCB_SIZE
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
operator|=
name|ai
operator|->
name|lowat
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sunaudiosetinfo
parameter_list|(
name|sc
parameter_list|,
name|ai
parameter_list|)
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sun_audio_info
modifier|*
name|ai
decl_stmt|;
block|{
name|struct
name|sun_audio_prinfo
modifier|*
name|r
init|=
operator|&
name|ai
operator|->
name|record
decl_stmt|,
modifier|*
name|p
init|=
operator|&
name|ai
operator|->
name|play
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|gain
operator|!=
operator|~
literal|0
condition|)
name|ausetpgain
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|gain
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|gain
operator|!=
operator|~
literal|0
condition|)
name|ausetrgain
argument_list|(
name|sc
argument_list|,
name|r
operator|->
name|gain
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|monitor_gain
operator|!=
operator|~
literal|0
condition|)
name|ausetmgain
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|gain
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|port
operator|==
name|AUDIO_SPEAKER
condition|)
block|{
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator||=
name|AMD_MMR2_LS
expr_stmt|;
name|audio_setmmr2
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|port
operator|==
name|AUDIO_HEADPHONE
condition|)
block|{
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator|&=
operator|~
name|AMD_MMR2_LS
expr_stmt|;
name|audio_setmmr2
argument_list|(
name|sc
operator|->
name|sc_au
operator|.
name|au_amd
argument_list|,
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The bsd driver does not distinguish between paused and active. 	 * (In the sun driver, not active means samples are not ouput 	 * at all, but paused means the last streams buffer is drained 	 * and then output stops.)  If either are 0, then when stop output. 	 * Otherwise, if either are non-zero, we resume. 	 */
if|if
condition|(
name|p
operator|->
name|pause
operator|==
literal|0
operator|||
name|p
operator|->
name|active
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pause
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|pause
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
operator|||
name|p
operator|->
name|active
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pause
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|pause
operator|==
literal|0
operator|||
name|r
operator|->
name|active
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pause
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|pause
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
operator|||
name|r
operator|->
name|active
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
condition|)
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pause
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|audiogetinfo
parameter_list|(
name|sc
parameter_list|,
name|ai
parameter_list|)
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|audio_info
modifier|*
name|ai
decl_stmt|;
block|{
name|struct
name|audio_prinfo
modifier|*
name|r
init|=
operator|&
name|ai
operator|->
name|record
decl_stmt|,
modifier|*
name|p
init|=
operator|&
name|ai
operator|->
name|play
decl_stmt|;
name|p
operator|->
name|sample_rate
operator|=
name|r
operator|->
name|sample_rate
operator|=
literal|8000
expr_stmt|;
name|p
operator|->
name|channels
operator|=
name|r
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|precision
operator|=
name|r
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
name|p
operator|->
name|encoding
operator|=
name|r
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ULAW
expr_stmt|;
name|ai
operator|->
name|monitor_gain
operator|=
name|sc
operator|->
name|sc_mlevel
expr_stmt|;
name|r
operator|->
name|gain
operator|=
name|sc
operator|->
name|sc_rlevel
expr_stmt|;
name|p
operator|->
name|gain
operator|=
name|sc
operator|->
name|sc_plevel
expr_stmt|;
name|r
operator|->
name|port
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|port
operator|=
operator|(
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator|&
name|AMD_MMR2_LS
operator|)
condition|?
name|AUDIO_SPEAKER
else|:
name|AUDIO_HEADPHONE
expr_stmt|;
name|p
operator|->
name|pause
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pause
expr_stmt|;
name|r
operator|->
name|pause
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pause
expr_stmt|;
name|p
operator|->
name|error
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_drops
operator|!=
literal|0
expr_stmt|;
name|r
operator|->
name|error
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_drops
operator|!=
literal|0
expr_stmt|;
name|p
operator|->
name|open
operator|=
name|sc
operator|->
name|sc_open
expr_stmt|;
name|r
operator|->
name|open
operator|=
name|sc
operator|->
name|sc_open
expr_stmt|;
name|p
operator|->
name|samples
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|-
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pdrops
expr_stmt|;
name|r
operator|->
name|samples
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|-
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pdrops
expr_stmt|;
name|p
operator|->
name|seek
operator|=
name|sc
operator|->
name|sc_wseek
expr_stmt|;
name|r
operator|->
name|seek
operator|=
name|sc
operator|->
name|sc_rseek
expr_stmt|;
name|ai
operator|->
name|blocksize
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_blksize
expr_stmt|;
name|ai
operator|->
name|hiwat
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_hiwat
expr_stmt|;
name|ai
operator|->
name|lowat
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_lowat
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sunaudiogetinfo
parameter_list|(
name|sc
parameter_list|,
name|ai
parameter_list|)
name|struct
name|audio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sun_audio_info
modifier|*
name|ai
decl_stmt|;
block|{
name|struct
name|sun_audio_prinfo
modifier|*
name|r
init|=
operator|&
name|ai
operator|->
name|record
decl_stmt|,
modifier|*
name|p
init|=
operator|&
name|ai
operator|->
name|play
decl_stmt|;
name|p
operator|->
name|sample_rate
operator|=
name|r
operator|->
name|sample_rate
operator|=
literal|8000
expr_stmt|;
name|p
operator|->
name|channels
operator|=
name|r
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|precision
operator|=
name|r
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
name|p
operator|->
name|encoding
operator|=
name|r
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ULAW
expr_stmt|;
name|ai
operator|->
name|monitor_gain
operator|=
name|sc
operator|->
name|sc_mlevel
expr_stmt|;
name|r
operator|->
name|gain
operator|=
name|sc
operator|->
name|sc_rlevel
expr_stmt|;
name|p
operator|->
name|gain
operator|=
name|sc
operator|->
name|sc_plevel
expr_stmt|;
name|r
operator|->
name|port
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|port
operator|=
operator|(
name|sc
operator|->
name|sc_map
operator|.
name|mr_mmr2
operator|&
name|AMD_MMR2_LS
operator|)
condition|?
name|AUDIO_SPEAKER
else|:
name|AUDIO_HEADPHONE
expr_stmt|;
name|p
operator|->
name|active
operator|=
name|p
operator|->
name|pause
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pause
expr_stmt|;
name|r
operator|->
name|active
operator|=
name|r
operator|->
name|pause
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pause
expr_stmt|;
name|p
operator|->
name|error
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_drops
operator|!=
literal|0
expr_stmt|;
name|r
operator|->
name|error
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_drops
operator|!=
literal|0
expr_stmt|;
name|p
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|eof
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|eof
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|open
operator|=
name|sc
operator|->
name|sc_open
expr_stmt|;
name|r
operator|->
name|open
operator|=
name|sc
operator|->
name|sc_open
expr_stmt|;
name|p
operator|->
name|samples
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|-
name|sc
operator|->
name|sc_au
operator|.
name|au_wb
operator|.
name|cb_pdrops
expr_stmt|;
name|r
operator|->
name|samples
operator|=
name|sc
operator|->
name|sc_au
operator|.
name|au_stamp
operator|-
name|sc
operator|->
name|sc_au
operator|.
name|au_rb
operator|.
name|cb_pdrops
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

