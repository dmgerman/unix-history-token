begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)cgsix.c	8.4 (Berkeley) %G%  *  * from: $Header: cgsix.c,v 1.2 93/10/18 00:01:51 torek Exp $  */
end_comment

begin_comment
comment|/*  * color display (cgsix) driver.  *  * Does not handle interrupts, even though they can occur.  *  * XXX should defer colormap updates to vertical retrace interrupts  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/fbio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/fbvar.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sbus/btreg.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sbus/btvar.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sbus/cgsixreg.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sbus/sbusvar.h>
end_include

begin_union
union|union
name|cursor_cmap
block|{
comment|/* colormap, like bt_cmap, but tiny */
name|u_char
name|cm_map
index|[
literal|2
index|]
index|[
literal|3
index|]
decl_stmt|;
comment|/* 2 R/G/B entries */
name|u_int
name|cm_chip
index|[
literal|2
index|]
decl_stmt|;
comment|/* 2 chip equivalents */
block|}
union|;
end_union

begin_struct
struct|struct
name|cg6_cursor
block|{
comment|/* cg6 hardware cursor status */
name|short
name|cc_enable
decl_stmt|;
comment|/* cursor is enabled */
name|struct
name|fbcurpos
name|cc_pos
decl_stmt|;
comment|/* position */
name|struct
name|fbcurpos
name|cc_hot
decl_stmt|;
comment|/* hot-spot */
name|struct
name|fbcurpos
name|cc_size
decl_stmt|;
comment|/* size of mask& image fields */
name|u_int
name|cc_bits
index|[
literal|2
index|]
index|[
literal|32
index|]
decl_stmt|;
comment|/* space for mask& image bits */
name|union
name|cursor_cmap
name|cc_color
decl_stmt|;
comment|/* cursor colormap */
block|}
struct|;
end_struct

begin_comment
comment|/* per-display variables */
end_comment

begin_struct
struct|struct
name|cgsix_softc
block|{
name|struct
name|device
name|sc_dev
decl_stmt|;
comment|/* base device */
name|struct
name|sbusdev
name|sc_sd
decl_stmt|;
comment|/* sbus device */
name|struct
name|fbdevice
name|sc_fb
decl_stmt|;
comment|/* frame buffer device */
specifier|volatile
name|struct
name|cg6_layout
modifier|*
name|sc_physadr
decl_stmt|;
comment|/* phys addr of h/w */
specifier|volatile
name|struct
name|bt_regs
modifier|*
name|sc_bt
decl_stmt|;
comment|/* Brooktree registers */
specifier|volatile
name|int
modifier|*
name|sc_fhc
decl_stmt|;
comment|/* FHC register */
specifier|volatile
name|struct
name|cg6_thc
modifier|*
name|sc_thc
decl_stmt|;
comment|/* THC registers */
specifier|volatile
name|struct
name|cg6_tec_xxx
modifier|*
name|sc_tec
decl_stmt|;
comment|/* TEC registers */
name|short
name|sc_fhcrev
decl_stmt|;
comment|/* hardware rev */
name|short
name|sc_blanked
decl_stmt|;
comment|/* true if blanked */
name|struct
name|cg6_cursor
name|sc_cursor
decl_stmt|;
comment|/* software cursor info */
name|union
name|bt_cmap
name|sc_cmap
decl_stmt|;
comment|/* Brooktree color map */
block|}
struct|;
end_struct

begin_comment
comment|/* autoconfiguration driver */
end_comment

begin_function_decl
specifier|static
name|void
name|cgsixattach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfdriver
name|cgsixcd
init|=
block|{
name|NULL
block|,
literal|"cgsix"
block|,
name|matchbyname
block|,
name|cgsixattach
block|,
name|DV_DULL
block|,
expr|sizeof
operator|(
expr|struct
name|cgsix_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frame buffer generic driver */
end_comment

begin_function_decl
specifier|static
name|void
name|cg6_unblank
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|fbdriver
name|cg6_fbdriver
init|=
block|{
name|cg6_unblank
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Unlike the bw2 and cg3 drivers, we do not need to provide an rconsole  * interface, as the cg6 is fast enough.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fbnode
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CGSIX_MAJOR
value|67
end_define

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|static
name|void
name|cg6_reset
name|__P
argument_list|(
operator|(
expr|struct
name|cgsix_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cg6_loadcmap
name|__P
argument_list|(
operator|(
expr|struct
name|cgsix_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cg6_loadomap
name|__P
argument_list|(
operator|(
expr|struct
name|cgsix_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cg6_setcursor
name|__P
argument_list|(
operator|(
expr|struct
name|cgsix_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set position */
end_comment

begin_decl_stmt
specifier|static
name|void
name|cg6_loadcursor
name|__P
argument_list|(
operator|(
expr|struct
name|cgsix_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set shape */
end_comment

begin_comment
comment|/*  * Attach a display.  */
end_comment

begin_function
name|void
name|cgsixattach
parameter_list|(
name|parent
parameter_list|,
name|self
parameter_list|,
name|args
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|,
decl|*
name|self
decl_stmt|;
end_function

begin_decl_stmt
name|void
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cgsix_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cgsix_softc
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|sbus_attach_args
modifier|*
name|sa
init|=
name|args
decl_stmt|;
specifier|register
name|int
name|node
init|=
name|sa
operator|->
name|sa_ra
operator|.
name|ra_node
decl_stmt|,
name|ramsize
decl_stmt|,
name|i
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|bt_regs
modifier|*
name|bt
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|cg6_layout
modifier|*
name|p
decl_stmt|;
name|sc
operator|->
name|sc_fb
operator|.
name|fb_major
operator|=
name|CGSIX_MAJOR
expr_stmt|;
comment|/* XXX to be removed */
name|sc
operator|->
name|sc_fb
operator|.
name|fb_driver
operator|=
operator|&
name|cg6_fbdriver
expr_stmt|;
name|sc
operator|->
name|sc_fb
operator|.
name|fb_device
operator|=
operator|&
name|sc
operator|->
name|sc_dev
expr_stmt|;
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_type
operator|=
name|FBTYPE_SUNFAST_COLOR
expr_stmt|;
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_width
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"width"
argument_list|,
literal|1152
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_height
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"height"
argument_list|,
literal|900
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fb
operator|.
name|fb_linebytes
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"linebytes"
argument_list|,
literal|1152
argument_list|)
expr_stmt|;
name|ramsize
operator|=
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_height
operator|*
name|sc
operator|->
name|sc_fb
operator|.
name|fb_linebytes
expr_stmt|;
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_depth
operator|=
literal|8
expr_stmt|;
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_cmsize
operator|=
literal|256
expr_stmt|;
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_size
operator|=
name|ramsize
expr_stmt|;
name|printf
argument_list|(
literal|": %s, %d x %d"
argument_list|,
name|getpropstring
argument_list|(
name|node
argument_list|,
literal|"model"
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_width
argument_list|,
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_height
argument_list|)
expr_stmt|;
comment|/* 	 * Dunno what the PROM has mapped, though obviously it must have 	 * the video RAM mapped.  Just map what we care about for ourselves 	 * (the FHC, THC, and Brooktree registers). 	 */
name|sc
operator|->
name|sc_physadr
operator|=
name|p
operator|=
operator|(
expr|struct
name|cg6_layout
operator|*
operator|)
name|sa
operator|->
name|sa_ra
operator|.
name|ra_paddr
expr_stmt|;
name|sc
operator|->
name|sc_bt
operator|=
name|bt
operator|=
operator|(
specifier|volatile
expr|struct
name|bt_regs
operator|*
operator|)
name|mapiodev
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|p
operator|->
name|cg6_bt_un
operator|.
name|un_btregs
argument_list|,
sizeof|sizeof
expr|*
name|sc
operator|->
name|sc_bt
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fhc
operator|=
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|mapiodev
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|p
operator|->
name|cg6_fhc_un
operator|.
name|un_fhc
argument_list|,
sizeof|sizeof
expr|*
name|sc
operator|->
name|sc_fhc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_thc
operator|=
operator|(
specifier|volatile
expr|struct
name|cg6_thc
operator|*
operator|)
name|mapiodev
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|p
operator|->
name|cg6_thc_un
operator|.
name|un_thc
argument_list|,
sizeof|sizeof
expr|*
name|sc
operator|->
name|sc_thc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tec
operator|=
operator|(
specifier|volatile
expr|struct
name|cg6_tec_xxx
operator|*
operator|)
name|mapiodev
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|p
operator|->
name|cg6_tec_un
operator|.
name|un_tec
argument_list|,
sizeof|sizeof
expr|*
name|sc
operator|->
name|sc_tec
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fhcrev
operator|=
operator|(
operator|*
name|sc
operator|->
name|sc_fhc
operator|>>
name|FHC_REV_SHIFT
operator|)
operator|&
operator|(
name|FHC_REV_MASK
operator|>>
name|FHC_REV_SHIFT
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|", rev %d"
argument_list|,
name|sc
operator|->
name|sc_fhcrev
argument_list|)
expr_stmt|;
comment|/* reset cursor& frame buffer controls */
name|cg6_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* grab initial (current) color map (DOES THIS WORK?) */
name|bt
operator|->
name|bt_addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
operator|*
literal|3
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_cmap
operator|)
index|[
name|i
index|]
operator|=
name|bt
operator|->
name|bt_cmap
operator|>>
literal|24
expr_stmt|;
comment|/* enable video */
name|sc
operator|->
name|sc_thc
operator|->
name|thc_misc
operator||=
name|THC_MISC_VIDEN
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sbus_establish
argument_list|(
operator|&
name|sc
operator|->
name|sc_sd
argument_list|,
operator|&
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|fbnode
condition|)
name|fb_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_fb
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|cgsixopen
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|cgsixcd
operator|.
name|cd_ndevs
operator|||
name|cgsixcd
operator|.
name|cd_devs
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cgsixclose
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|cgsix_softc
modifier|*
name|sc
init|=
name|cgsixcd
operator|.
name|cd_devs
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|cg6_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cgsixioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flags
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
specifier|register
name|caddr_t
name|data
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|cgsix_softc
modifier|*
name|sc
init|=
name|cgsixcd
operator|.
name|cd_devs
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|,
name|v
decl_stmt|,
name|error
decl_stmt|;
name|union
name|cursor_cmap
name|tcm
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FBIOGTYPE
case|:
operator|*
operator|(
expr|struct
name|fbtype
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
expr_stmt|;
break|break;
case|case
name|FBIOGATTR
case|:
define|#
directive|define
name|fba
value|((struct fbgattr *)data)
name|fba
operator|->
name|real_type
operator|=
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_type
expr_stmt|;
name|fba
operator|->
name|owner
operator|=
literal|0
expr_stmt|;
comment|/* XXX ??? */
name|fba
operator|->
name|fbtype
operator|=
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
expr_stmt|;
name|fba
operator|->
name|sattr
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|fba
operator|->
name|sattr
operator|.
name|emu_type
operator|=
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_type
expr_stmt|;
name|fba
operator|->
name|sattr
operator|.
name|dev_specific
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|fba
operator|->
name|emu_types
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_type
expr_stmt|;
name|fba
operator|->
name|emu_types
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
undef|#
directive|undef
name|fba
break|break;
case|case
name|FBIOGETCMAP
case|:
return|return
operator|(
name|bt_getcmap
argument_list|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|sc_cmap
argument_list|,
literal|256
argument_list|)
operator|)
return|;
case|case
name|FBIOPUTCMAP
case|:
comment|/* copy to software map */
define|#
directive|define
name|p
value|((struct fbcmap *)data)
name|error
operator|=
name|bt_putcmap
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|sc_cmap
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* now blast them into the chip */
comment|/* XXX should use retrace interrupt */
name|cg6_loadcmap
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|index
argument_list|,
name|p
operator|->
name|count
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|p
break|break;
case|case
name|FBIOGVIDEO
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_blanked
expr_stmt|;
break|break;
case|case
name|FBIOSVIDEO
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|cg6_unblank
argument_list|(
operator|&
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_blanked
condition|)
block|{
name|sc
operator|->
name|sc_blanked
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_thc
operator|->
name|thc_misc
operator|&=
operator|~
name|THC_MISC_VIDEN
expr_stmt|;
block|}
break|break;
comment|/* these are for both FBIOSCURSOR and FBIOGCURSOR */
define|#
directive|define
name|p
value|((struct fbcursor *)data)
define|#
directive|define
name|cc
value|(&sc->sc_cursor)
case|case
name|FBIOGCURSOR
case|:
comment|/* do not quite want everything here... */
name|p
operator|->
name|set
operator|=
name|FB_CUR_SETALL
expr_stmt|;
comment|/* close enough, anyway */
name|p
operator|->
name|enable
operator|=
name|cc
operator|->
name|cc_enable
expr_stmt|;
name|p
operator|->
name|pos
operator|=
name|cc
operator|->
name|cc_pos
expr_stmt|;
name|p
operator|->
name|hot
operator|=
name|cc
operator|->
name|cc_hot
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|cc
operator|->
name|cc_size
expr_stmt|;
comment|/* begin ugh ... can we lose some of this crap?? */
if|if
condition|(
name|p
operator|->
name|image
operator|!=
name|NULL
condition|)
block|{
name|count
operator|=
name|cc
operator|->
name|cc_size
operator|.
name|y
operator|*
literal|32
operator|/
name|NBBY
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|cc
operator|->
name|cc_bits
index|[
literal|1
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|image
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|cc
operator|->
name|cc_bits
index|[
literal|0
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|mask
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|cmap
operator|.
name|red
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bt_getcmap
argument_list|(
operator|&
name|p
operator|->
name|cmap
argument_list|,
operator|(
expr|union
name|bt_cmap
operator|*
operator|)
operator|&
name|cc
operator|->
name|cc_color
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|p
operator|->
name|cmap
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|cmap
operator|.
name|count
operator|=
literal|2
expr_stmt|;
block|}
comment|/* end ugh */
break|break;
case|case
name|FBIOSCURSOR
case|:
comment|/* 		 * For setcmap and setshape, verify parameters, so that 		 * we do not get halfway through an update and then crap 		 * out with the software state screwed up. 		 */
name|v
operator|=
name|p
operator|->
name|set
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|FB_CUR_SETCMAP
condition|)
block|{
comment|/* 			 * This use of a temporary copy of the cursor 			 * colormap is not terribly efficient, but these 			 * copies are small (8 bytes)... 			 */
name|tcm
operator|=
name|cc
operator|->
name|cc_color
expr_stmt|;
name|error
operator|=
name|bt_putcmap
argument_list|(
operator|&
name|p
operator|->
name|cmap
argument_list|,
operator|(
expr|union
name|bt_cmap
operator|*
operator|)
operator|&
name|tcm
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|v
operator|&
name|FB_CUR_SETSHAPE
condition|)
block|{
if|if
condition|(
operator|(
name|u_int
operator|)
name|p
operator|->
name|size
operator|.
name|x
operator|>
literal|32
operator|||
operator|(
name|u_int
operator|)
name|p
operator|->
name|size
operator|.
name|y
operator|>
literal|32
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|count
operator|=
name|p
operator|->
name|size
operator|.
name|y
operator|*
literal|32
operator|/
name|NBBY
expr_stmt|;
if|if
condition|(
operator|!
name|useracc
argument_list|(
name|p
operator|->
name|image
argument_list|,
name|count
argument_list|,
name|B_READ
argument_list|)
operator|||
operator|!
name|useracc
argument_list|(
name|p
operator|->
name|mask
argument_list|,
name|count
argument_list|,
name|B_READ
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* parameters are OK; do it */
if|if
condition|(
name|v
operator|&
operator|(
name|FB_CUR_SETCUR
operator||
name|FB_CUR_SETPOS
operator||
name|FB_CUR_SETHOT
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|&
name|FB_CUR_SETCUR
condition|)
name|cc
operator|->
name|cc_enable
operator|=
name|p
operator|->
name|enable
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|FB_CUR_SETPOS
condition|)
name|cc
operator|->
name|cc_pos
operator|=
name|p
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|FB_CUR_SETHOT
condition|)
name|cc
operator|->
name|cc_hot
operator|=
name|p
operator|->
name|hot
expr_stmt|;
name|cg6_setcursor
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|&
name|FB_CUR_SETCMAP
condition|)
block|{
name|cc
operator|->
name|cc_color
operator|=
name|tcm
expr_stmt|;
name|cg6_loadomap
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX defer to vertical retrace */
block|}
if|if
condition|(
name|v
operator|&
name|FB_CUR_SETSHAPE
condition|)
block|{
name|cc
operator|->
name|cc_size
operator|=
name|p
operator|->
name|size
expr_stmt|;
name|count
operator|=
name|p
operator|->
name|size
operator|.
name|y
operator|*
literal|32
operator|/
name|NBBY
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|cc
operator|->
name|cc_bits
argument_list|,
sizeof|sizeof
name|cc
operator|->
name|cc_bits
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|->
name|mask
argument_list|,
operator|(
name|caddr_t
operator|)
name|cc
operator|->
name|cc_bits
index|[
literal|0
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|->
name|image
argument_list|,
operator|(
name|caddr_t
operator|)
name|cc
operator|->
name|cc_bits
index|[
literal|1
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|cg6_loadcursor
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|p
undef|#
directive|undef
name|cc
case|case
name|FBIOGCURPOS
case|:
operator|*
operator|(
expr|struct
name|fbcurpos
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_cursor
operator|.
name|cc_pos
expr_stmt|;
break|break;
case|case
name|FBIOSCURPOS
case|:
name|sc
operator|->
name|sc_cursor
operator|.
name|cc_pos
operator|=
operator|*
operator|(
expr|struct
name|fbcurpos
operator|*
operator|)
name|data
expr_stmt|;
name|cg6_setcursor
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|FBIOGCURMAX
case|:
comment|/* max cursor size is 32x32 */
operator|(
operator|(
expr|struct
name|fbcurpos
operator|*
operator|)
name|data
operator|)
operator|->
name|x
operator|=
literal|32
expr_stmt|;
operator|(
operator|(
expr|struct
name|fbcurpos
operator|*
operator|)
name|data
operator|)
operator|->
name|y
operator|=
literal|32
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"cgsixioctl(%x) (%s[%d])\n"
argument_list|,
name|cmd
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up hardware state (e.g., after bootup or after X crashes).  */
end_comment

begin_function
specifier|static
name|void
name|cg6_reset
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|cgsix_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|cg6_tec_xxx
modifier|*
name|tec
decl_stmt|;
specifier|register
name|int
name|fhc
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|bt_regs
modifier|*
name|bt
decl_stmt|;
comment|/* hide the cursor, just in case */
name|sc
operator|->
name|sc_thc
operator|->
name|thc_cursxy
operator|=
operator|(
name|THC_CURSOFF
operator|<<
literal|16
operator|)
operator||
name|THC_CURSOFF
expr_stmt|;
comment|/* turn off frobs in transform engine (makes X11 work) */
name|tec
operator|=
name|sc
operator|->
name|sc_tec
expr_stmt|;
name|tec
operator|->
name|tec_mv
operator|=
literal|0
expr_stmt|;
name|tec
operator|->
name|tec_clip
operator|=
literal|0
expr_stmt|;
name|tec
operator|->
name|tec_vdc
operator|=
literal|0
expr_stmt|;
comment|/* take care of hardware bugs in old revisions */
if|if
condition|(
name|sc
operator|->
name|sc_fhcrev
operator|<
literal|5
condition|)
block|{
comment|/* 		 * Keep current resolution; set cpu to 68020, set test 		 * window (size 1Kx1K), and for rev 1, disable dest cache. 		 */
name|fhc
operator|=
operator|(
operator|*
name|sc
operator|->
name|sc_fhc
operator|&
name|FHC_RES_MASK
operator|)
operator||
name|FHC_CPU_68020
operator||
name|FHC_TEST
operator||
operator|(
literal|11
operator|<<
name|FHC_TESTX_SHIFT
operator|)
operator||
operator|(
literal|11
operator|<<
name|FHC_TESTY_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_fhcrev
operator|<
literal|2
condition|)
name|fhc
operator||=
name|FHC_DST_DISABLE
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_fhc
operator|=
name|fhc
expr_stmt|;
block|}
comment|/* Enable cursor in Brooktree DAC. */
name|bt
operator|=
name|sc
operator|->
name|sc_bt
expr_stmt|;
name|bt
operator|->
name|bt_addr
operator|=
literal|0x06
operator|<<
literal|24
expr_stmt|;
name|bt
operator|->
name|bt_ctrl
operator||=
literal|0x03
operator|<<
literal|24
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cg6_setcursor
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|cgsix_softc
modifier|*
name|sc
decl_stmt|;
block|{
comment|/* we need to subtract the hot-spot value here */
define|#
directive|define
name|COORD
parameter_list|(
name|f
parameter_list|)
value|(sc->sc_cursor.cc_pos.f - sc->sc_cursor.cc_hot.f)
name|sc
operator|->
name|sc_thc
operator|->
name|thc_cursxy
operator|=
name|sc
operator|->
name|sc_cursor
operator|.
name|cc_enable
condition|?
operator|(
operator|(
name|COORD
argument_list|(
name|x
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|COORD
argument_list|(
name|y
argument_list|)
operator|&
literal|0xffff
operator|)
operator|)
else|:
operator|(
name|THC_CURSOFF
operator|<<
literal|16
operator|)
operator||
name|THC_CURSOFF
expr_stmt|;
undef|#
directive|undef
name|COORD
block|}
end_function

begin_function
specifier|static
name|void
name|cg6_loadcursor
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|cgsix_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|cg6_thc
modifier|*
name|thc
decl_stmt|;
specifier|register
name|u_int
name|edgemask
decl_stmt|,
name|m
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Keep the top size.x bits.  Here we *throw out* the top 	 * size.x bits from an all-one-bits word, introducing zeros in 	 * the top size.x bits, then invert all the bits to get what 	 * we really wanted as our mask.  But this fails if size.x is 	 * 32---a sparc uses only the low 5 bits of the shift count--- 	 * so we have to special case that. 	 */
name|edgemask
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cursor
operator|.
name|cc_size
operator|.
name|x
operator|<
literal|32
condition|)
name|edgemask
operator|=
operator|~
operator|(
name|edgemask
operator|>>
name|sc
operator|->
name|sc_cursor
operator|.
name|cc_size
operator|.
name|x
operator|)
expr_stmt|;
name|thc
operator|=
name|sc
operator|->
name|sc_thc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|sc
operator|->
name|sc_cursor
operator|.
name|cc_bits
index|[
literal|0
index|]
index|[
name|i
index|]
operator|&
name|edgemask
expr_stmt|;
name|thc
operator|->
name|thc_cursmask
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
name|thc
operator|->
name|thc_cursbits
index|[
name|i
index|]
operator|=
name|m
operator|&
name|sc
operator|->
name|sc_cursor
operator|.
name|cc_bits
index|[
literal|1
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Load a subset of the current (new) colormap into the color DAC.  */
end_comment

begin_function
specifier|static
name|void
name|cg6_loadcmap
parameter_list|(
name|sc
parameter_list|,
name|start
parameter_list|,
name|ncolors
parameter_list|)
specifier|register
name|struct
name|cgsix_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|start
decl_stmt|,
name|ncolors
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|bt_regs
modifier|*
name|bt
decl_stmt|;
specifier|register
name|u_int
modifier|*
name|ip
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
name|ip
operator|=
operator|&
name|sc
operator|->
name|sc_cmap
operator|.
name|cm_chip
index|[
name|BT_D4M3
argument_list|(
name|start
argument_list|)
index|]
expr_stmt|;
comment|/* start/4 * 3 */
name|count
operator|=
name|BT_D4M3
argument_list|(
name|start
operator|+
name|ncolors
operator|-
literal|1
argument_list|)
operator|-
name|BT_D4M3
argument_list|(
name|start
argument_list|)
operator|+
literal|3
expr_stmt|;
name|bt
operator|=
name|sc
operator|->
name|sc_bt
expr_stmt|;
name|bt
operator|->
name|bt_addr
operator|=
name|BT_D4M4
argument_list|(
name|start
argument_list|)
operator|<<
literal|24
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|i
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
comment|/* hardware that makes one want to pound boards with hammers */
name|bt
operator|->
name|bt_cmap
operator|=
name|i
expr_stmt|;
name|bt
operator|->
name|bt_cmap
operator|=
name|i
operator|<<
literal|8
expr_stmt|;
name|bt
operator|->
name|bt_cmap
operator|=
name|i
operator|<<
literal|16
expr_stmt|;
name|bt
operator|->
name|bt_cmap
operator|=
name|i
operator|<<
literal|24
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Load the cursor (overlay `foreground' and `background') colors.  */
end_comment

begin_function
specifier|static
name|void
name|cg6_loadomap
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|cgsix_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|bt_regs
modifier|*
name|bt
decl_stmt|;
specifier|register
name|u_int
name|i
decl_stmt|;
name|bt
operator|=
name|sc
operator|->
name|sc_bt
expr_stmt|;
name|bt
operator|->
name|bt_addr
operator|=
literal|0x01
operator|<<
literal|24
expr_stmt|;
comment|/* set background color */
name|i
operator|=
name|sc
operator|->
name|sc_cursor
operator|.
name|cc_color
operator|.
name|cm_chip
index|[
literal|0
index|]
expr_stmt|;
name|bt
operator|->
name|bt_omap
operator|=
name|i
expr_stmt|;
comment|/* R */
name|bt
operator|->
name|bt_omap
operator|=
name|i
operator|<<
literal|8
expr_stmt|;
comment|/* G */
name|bt
operator|->
name|bt_omap
operator|=
name|i
operator|<<
literal|16
expr_stmt|;
comment|/* B */
name|bt
operator|->
name|bt_addr
operator|=
literal|0x03
operator|<<
literal|24
expr_stmt|;
comment|/* set foreground color */
name|bt
operator|->
name|bt_omap
operator|=
name|i
operator|<<
literal|24
expr_stmt|;
comment|/* R */
name|i
operator|=
name|sc
operator|->
name|sc_cursor
operator|.
name|cc_color
operator|.
name|cm_chip
index|[
literal|1
index|]
expr_stmt|;
name|bt
operator|->
name|bt_omap
operator|=
name|i
expr_stmt|;
comment|/* G */
name|bt
operator|->
name|bt_omap
operator|=
name|i
operator|<<
literal|8
expr_stmt|;
comment|/* B */
block|}
end_function

begin_function
specifier|static
name|void
name|cg6_unblank
parameter_list|(
name|dev
parameter_list|)
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
block|{
name|struct
name|cgsix_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cgsix_softc
operator|*
operator|)
name|dev
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_blanked
condition|)
block|{
name|sc
operator|->
name|sc_blanked
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_thc
operator|->
name|thc_misc
operator||=
name|THC_MISC_VIDEN
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* XXX the following should be moved to a "user interface" header */
end_comment

begin_comment
comment|/*  * Base addresses at which users can mmap() the various pieces of a cg6.  * Note that although the Brooktree color registers do not occupy 8K,  * the X server dies if we do not allow it to map 8K there (it just maps  * from 0x70000000 forwards, as a contiguous chunk).  */
end_comment

begin_define
define|#
directive|define
name|CG6_USER_FBC
value|0x70000000
end_define

begin_define
define|#
directive|define
name|CG6_USER_TEC
value|0x70001000
end_define

begin_define
define|#
directive|define
name|CG6_USER_BTREGS
value|0x70002000
end_define

begin_define
define|#
directive|define
name|CG6_USER_FHC
value|0x70004000
end_define

begin_define
define|#
directive|define
name|CG6_USER_THC
value|0x70005000
end_define

begin_define
define|#
directive|define
name|CG6_USER_ROM
value|0x70006000
end_define

begin_define
define|#
directive|define
name|CG6_USER_RAM
value|0x70016000
end_define

begin_define
define|#
directive|define
name|CG6_USER_DHC
value|0x80000000
end_define

begin_struct
struct|struct
name|mmo
block|{
name|u_int
name|mo_uaddr
decl_stmt|;
comment|/* user (virtual) address */
name|u_int
name|mo_size
decl_stmt|;
comment|/* size, or 0 for video ram size */
name|u_int
name|mo_physoff
decl_stmt|;
comment|/* offset from sc_physadr */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Return the address that would map the given device at the given  * offset, allowing for the given protection, or return -1 for error.  *  * XXX	needs testing against `demanding' applications (e.g., aviator)  */
end_comment

begin_function
name|int
name|cgsixmap
parameter_list|(
name|dev
parameter_list|,
name|off
parameter_list|,
name|prot
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|off
decl_stmt|,
name|prot
decl_stmt|;
block|{
specifier|register
name|struct
name|cgsix_softc
modifier|*
name|sc
init|=
name|cgsixcd
operator|.
name|cd_devs
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|mmo
modifier|*
name|mo
decl_stmt|;
specifier|register
name|u_int
name|u
decl_stmt|,
name|sz
decl_stmt|;
define|#
directive|define
name|O
parameter_list|(
name|memb
parameter_list|)
value|((u_int)(&((struct cg6_layout *)0)->memb))
specifier|static
name|struct
name|mmo
name|mmo
index|[]
init|=
block|{
block|{
name|CG6_USER_RAM
block|,
literal|0
block|,
name|O
argument_list|(
argument|cg6_ram
argument_list|)
block|}
block|,
comment|/* do not actually know how big most of these are! */
block|{
name|CG6_USER_FBC
block|,
literal|1
block|,
name|O
argument_list|(
argument|cg6_fbc_un
argument_list|)
block|}
block|,
block|{
name|CG6_USER_TEC
block|,
literal|1
block|,
name|O
argument_list|(
argument|cg6_tec_un
argument_list|)
block|}
block|,
block|{
name|CG6_USER_BTREGS
block|,
literal|8192
comment|/* XXX */
block|,
name|O
argument_list|(
argument|cg6_bt_un
argument_list|)
block|}
block|,
block|{
name|CG6_USER_FHC
block|,
literal|1
block|,
name|O
argument_list|(
argument|cg6_fhc_un
argument_list|)
block|}
block|,
block|{
name|CG6_USER_THC
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|cg6_thc
argument_list|)
block|,
name|O
argument_list|(
argument|cg6_thc_un
argument_list|)
block|}
block|,
block|{
name|CG6_USER_ROM
block|,
literal|65536
block|,
name|O
argument_list|(
argument|cg6_rom_un
argument_list|)
block|}
block|,
block|{
name|CG6_USER_DHC
block|,
literal|1
block|,
name|O
argument_list|(
argument|cg6_dhc_un
argument_list|)
block|}
block|, 	}
decl_stmt|;
define|#
directive|define
name|NMMO
value|(sizeof mmo / sizeof *mmo)
if|if
condition|(
name|off
operator|&
name|PGOFSET
condition|)
name|panic
argument_list|(
literal|"cgsixmap"
argument_list|)
expr_stmt|;
comment|/* 	 * Entries with size 0 map video RAM (i.e., the size in fb data). 	 * 	 * Since we work in pages, the fact that the map offset table's 	 * sizes are sometimes bizarre (e.g., 1) is effectively ignored: 	 * one byte is as good as one page. 	 */
for|for
control|(
name|mo
operator|=
name|mmo
init|;
name|mo
operator|<
operator|&
name|mmo
index|[
name|NMMO
index|]
condition|;
name|mo
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|u_int
operator|)
name|off
operator|<
name|mo
operator|->
name|mo_uaddr
condition|)
continue|continue;
name|u
operator|=
name|off
operator|-
name|mo
operator|->
name|mo_uaddr
expr_stmt|;
name|sz
operator|=
name|mo
operator|->
name|mo_size
condition|?
name|mo
operator|->
name|mo_size
else|:
name|sc
operator|->
name|sc_fb
operator|.
name|fb_type
operator|.
name|fb_size
expr_stmt|;
if|if
condition|(
name|u
operator|<
name|sz
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|sc
operator|->
name|sc_physadr
operator|+
name|u
operator|+
name|mo
operator|->
name|mo_physoff
operator|+
name|PMAP_OBIO
operator|+
name|PMAP_NC
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"cgsixmap(%x) (%s[%d])\n"
argument_list|,
name|off
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* not a user-map offset */
block|}
end_function

end_unit

