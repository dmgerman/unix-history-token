begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1992 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)if_le.c	7.2 (Berkeley) %G%  *  * from: $Header: if_le.c,v 1.17 92/07/10 06:45:17 torek Exp $  */
end_comment

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_comment
comment|/*  * AMD 7990 LANCE  *  * This driver will generate and accept tailer encapsulated packets even  * though it buys us nothing.  The motivation was to avoid incompatibilities  * with VAXen, SUNs, and others that handle and benefit from them.  * This reasoning is dubious.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|APPLETALK
end_ifdef

begin_include
include|#
directive|include
file|<netddp/atalk.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sbus/if_lereg.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sbus/sbusvar.h>
end_include

begin_comment
comment|/* DVMA address to LANCE address -- the Sbus/MMU will resupply the 0xff */
end_comment

begin_define
define|#
directive|define
name|LANCE_ADDR
parameter_list|(
name|x
parameter_list|)
value|((int)(x)& ~0xff000000)
end_define

begin_decl_stmt
name|int
name|ledebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* console error messages */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PACKETSTATS
end_ifdef

begin_decl_stmt
name|long
name|lexpacketsizes
index|[
name|LEMTU
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|lerpacketsizes
index|[
name|LEMTU
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Per interface statistics */
end_comment

begin_comment
comment|/* XXX this should go in something like if_levar.h */
end_comment

begin_struct
struct|struct
name|lestats
block|{
name|long
name|lexints
decl_stmt|;
comment|/* transmitter interrupts */
name|long
name|lerints
decl_stmt|;
comment|/* receiver interrupts */
name|long
name|lerbufs
decl_stmt|;
comment|/* total buffers received during interrupts */
name|long
name|lerhits
decl_stmt|;
comment|/* times current rbuf was full */
name|long
name|lerscans
decl_stmt|;
comment|/* rbufs scanned before finding first full */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Ethernet software status per interface.  *  * Each interface is referenced by a network interface structure,  * le_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  */
end_comment

begin_struct
struct|struct
name|le_softc
block|{
name|struct
name|device
name|sc_dev
decl_stmt|;
comment|/* base device */
name|struct
name|sbusdev
name|sc_sd
decl_stmt|;
comment|/* sbus device */
name|struct
name|intrhand
name|sc_ih
decl_stmt|;
comment|/* interrupt vectoring */
name|int
name|sc_interrupts
decl_stmt|;
comment|/* number of interrupts taken */
name|struct
name|arpcom
name|sc_ac
decl_stmt|;
comment|/* common Ethernet structures */
define|#
directive|define
name|sc_if
value|sc_ac.ac_if
comment|/* network-visible interface */
define|#
directive|define
name|sc_addr
value|sc_ac.ac_enaddr
comment|/* hardware Ethernet address */
specifier|volatile
name|struct
name|lereg1
modifier|*
name|sc_r1
decl_stmt|;
comment|/* LANCE registers */
specifier|volatile
name|struct
name|lereg2
modifier|*
name|sc_r2
decl_stmt|;
comment|/* dual-port RAM */
name|int
name|sc_rmd
decl_stmt|;
comment|/* predicted next rmd to process */
name|int
name|sc_runt
decl_stmt|;
name|int
name|sc_jab
decl_stmt|;
name|int
name|sc_merr
decl_stmt|;
name|int
name|sc_babl
decl_stmt|;
name|int
name|sc_cerr
decl_stmt|;
name|int
name|sc_miss
decl_stmt|;
name|int
name|sc_xint
decl_stmt|;
name|int
name|sc_xown
decl_stmt|;
name|int
name|sc_uflo
decl_stmt|;
name|int
name|sc_rxlen
decl_stmt|;
name|int
name|sc_rxoff
decl_stmt|;
name|int
name|sc_txoff
decl_stmt|;
name|int
name|sc_busy
decl_stmt|;
name|short
name|sc_iflags
decl_stmt|;
name|struct
name|lestats
name|sc_lestats
decl_stmt|;
comment|/* per interface statistics */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|caddr_t
name|sc_bpf
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* autoconfiguration driver */
end_comment

begin_function_decl
name|void
name|leattach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfdriver
name|lecd
init|=
block|{
name|NULL
block|,
literal|"le"
block|,
name|matchbyname
block|,
name|leattach
block|,
name|DV_IFNET
block|,
expr|sizeof
operator|(
expr|struct
name|le_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forwards */
end_comment

begin_function_decl
name|void
name|leattach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MULTICAST
end_ifdef

begin_function_decl
name|void
name|lesetladrf
parameter_list|(
name|struct
name|le_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|lereset
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|leinit
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lestart
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|leintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lexint
parameter_list|(
name|struct
name|le_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lerint
parameter_list|(
name|struct
name|le_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|leread
parameter_list|(
name|struct
name|le_softc
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|leput
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mbuf
modifier|*
name|leget
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|leioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|leerror
parameter_list|(
name|struct
name|le_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lererror
parameter_list|(
name|struct
name|le_softc
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lexerror
parameter_list|(
name|struct
name|le_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_function
name|void
name|leattach
parameter_list|(
name|parent
parameter_list|,
name|self
parameter_list|,
name|args
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|struct
name|device
modifier|*
name|self
decl_stmt|;
name|void
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|le_softc
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|sbus_attach_args
modifier|*
name|sa
init|=
name|args
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lereg2
modifier|*
name|ler2
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
specifier|register
name|int
name|a
decl_stmt|,
name|pri
decl_stmt|;
define|#
directive|define
name|ISQUADALIGN
parameter_list|(
name|a
parameter_list|)
value|((((long) a)& 0x3) == 0)
comment|/* XXX the following declarations should be elsewhere */
specifier|extern
name|void
name|myetheraddr
argument_list|(
name|u_char
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|caddr_t
name|dvma_malloc
argument_list|(
name|size_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_ra
operator|.
name|ra_nintr
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|": expected 1 interrupt, got %d\n"
argument_list|,
name|sa
operator|->
name|sa_ra
operator|.
name|ra_nintr
argument_list|)
expr_stmt|;
return|return;
block|}
name|pri
operator|=
name|sa
operator|->
name|sa_ra
operator|.
name|ra_intr
index|[
literal|0
index|]
operator|.
name|int_pri
expr_stmt|;
name|printf
argument_list|(
literal|" pri %d"
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_r1
operator|=
operator|(
specifier|volatile
expr|struct
name|lereg1
operator|*
operator|)
name|mapiodev
argument_list|(
name|sa
operator|->
name|sa_ra
operator|.
name|ra_paddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lereg1
argument_list|)
argument_list|)
expr_stmt|;
name|ler2
operator|=
name|sc
operator|->
name|sc_r2
operator|=
operator|(
specifier|volatile
expr|struct
name|lereg2
operator|*
operator|)
name|dvma_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lereg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISQUADALIGN
argument_list|(
name|ler2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"? not quad aligned (0x%x)\n"
argument_list|,
name|ler2
argument_list|)
expr_stmt|;
name|myetheraddr
argument_list|(
name|sc
operator|->
name|sc_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": hardware address %s\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Setup for transmit/receive 	 * 	 * According to Van, some versions of the Lance only use this 	 * address to receive packets; it doesn't put them in 	 * output packets. We'll want to make sure that lestart() 	 * installs the address. 	 */
name|ler2
operator|->
name|ler2_padr
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_addr
index|[
literal|1
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_padr
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sc_addr
index|[
literal|0
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_padr
index|[
literal|2
index|]
operator|=
name|sc
operator|->
name|sc_addr
index|[
literal|3
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_padr
index|[
literal|3
index|]
operator|=
name|sc
operator|->
name|sc_addr
index|[
literal|2
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_padr
index|[
literal|4
index|]
operator|=
name|sc
operator|->
name|sc_addr
index|[
literal|5
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_padr
index|[
literal|5
index|]
operator|=
name|sc
operator|->
name|sc_addr
index|[
literal|4
index|]
expr_stmt|;
name|a
operator|=
name|LANCE_ADDR
argument_list|(
operator|&
name|ler2
operator|->
name|ler2_rmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISQUADALIGN
argument_list|(
name|a
argument_list|)
condition|)
name|printf
argument_list|(
literal|"rdra not quad aligned (0x%x)\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|ler2
operator|->
name|ler2_rlen
operator|=
name|LE_RLEN
operator||
operator|(
name|a
operator|>>
literal|16
operator|)
expr_stmt|;
name|ler2
operator|->
name|ler2_rdra
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|LANCE_ADDR
argument_list|(
operator|&
name|ler2
operator|->
name|ler2_tmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISQUADALIGN
argument_list|(
name|a
argument_list|)
condition|)
name|printf
argument_list|(
literal|"tdra not quad aligned (0x%x)\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|ler2
operator|->
name|ler2_tlen
operator|=
name|LE_TLEN
operator||
operator|(
name|a
operator|>>
literal|16
operator|)
expr_stmt|;
name|ler2
operator|->
name|ler2_tdra
operator|=
name|a
expr_stmt|;
comment|/* 	 * Link into sbus, and establish interrupt handler. 	 */
name|sc
operator|->
name|sc_sd
operator|.
name|sd_reset
operator|=
name|lereset
expr_stmt|;
name|sbus_establish
argument_list|(
operator|&
name|sc
operator|->
name|sc_sd
argument_list|,
operator|&
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ih
operator|.
name|ih_fun
operator|=
name|leintr
expr_stmt|;
name|sc
operator|->
name|sc_ih
operator|.
name|ih_arg
operator|=
name|sc
expr_stmt|;
name|intr_establish
argument_list|(
name|pri
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|sc_dev
operator|.
name|dv_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"le"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|leinit
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|leioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|lestart
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTICAST
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IFF_NOTRAILERS
comment|/* XXX still compile when the blasted things are gone... */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_NOTRAILERS
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MULTICAST
end_ifdef

begin_comment
comment|/*  * Setup the logical address filter  */
end_comment

begin_function
name|void
name|lesetladrf
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|lereg2
modifier|*
name|ler2
init|=
name|sc
operator|->
name|sc_r2
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
specifier|register
name|struct
name|ether_multi
modifier|*
name|enm
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|u_long
name|crc
decl_stmt|;
specifier|register
name|u_long
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|ether_multistep
name|step
decl_stmt|;
comment|/* 	 * Set up multicast address filter by passing all multicast 	 * addresses through a crc generator, and then using the high 	 * order 6 bits as a index into the 64 bit logical address 	 * filter. The high order two bits select the word, while the 	 * rest of the bits select the bit within the word. 	 */
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_ALLMULTI
expr_stmt|;
name|ETHER_FIRST_MULTI
argument_list|(
name|step
argument_list|,
operator|&
name|sc
operator|->
name|sc_ac
argument_list|,
name|enm
argument_list|)
expr_stmt|;
while|while
condition|(
name|enm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|enm
operator|->
name|enm_addrlo
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|enm
operator|->
name|enm_addrhi
argument_list|,
sizeof|sizeof
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We must listen to a range of multicast 			 * addresses. For now, just accept all 			 * multicasts, rather than trying to set only 			 * those filter bits needed to match the range. 			 * (At this time, the only use of address 			 * ranges is for IP multicast routing, for 			 * which the range is big enough to require all 			 * bits set.) 			 */
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|0
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|1
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
return|return;
block|}
name|cp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|enm
operator|->
name|enm_addrlo
expr_stmt|;
name|c
operator|=
operator|*
name|cp
expr_stmt|;
name|crc
operator|=
literal|0xffffffff
expr_stmt|;
name|len
operator|=
literal|6
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|cp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|&
literal|0x01
operator|)
operator|^
operator|(
name|crc
operator|&
literal|0x01
operator|)
condition|)
block|{
name|crc
operator|>>=
literal|1
expr_stmt|;
name|crc
operator|=
name|crc
operator|^
literal|0xedb88320
expr_stmt|;
block|}
else|else
name|crc
operator|>>=
literal|1
expr_stmt|;
name|c
operator|>>=
literal|1
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
comment|/* Just want the 6 most significant bits. */
name|crc
operator|=
name|crc
operator|>>
literal|26
expr_stmt|;
comment|/* Turn on the corresponding bit in the filter. */
name|ler2
operator|->
name|ler2_ladrf
index|[
name|crc
operator|>>
literal|5
index|]
operator||=
literal|1
operator|<<
operator|(
name|crc
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|ETHER_NEXT_MULTI
argument_list|(
name|step
argument_list|,
name|enm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|lereset
parameter_list|(
name|dev
parameter_list|)
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|le_softc
operator|*
operator|)
name|dev
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lereg1
modifier|*
name|ler1
init|=
name|sc
operator|->
name|sc_r1
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lereg2
modifier|*
name|ler2
init|=
name|sc
operator|->
name|sc_r2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|a
decl_stmt|,
name|timo
decl_stmt|,
name|stat
decl_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|ler2
operator|->
name|ler2_mode
operator|=
name|LE_MODE_NORMAL
operator||
name|LE_MODE_PROM
expr_stmt|;
else|else
endif|#
directive|endif
name|ler2
operator|->
name|ler2_mode
operator|=
name|LE_MODE_NORMAL
expr_stmt|;
name|ler1
operator|->
name|ler1_rap
operator|=
name|LE_CSR0
expr_stmt|;
name|ler1
operator|->
name|ler1_rdp
operator|=
name|LE_C0_STOP
expr_stmt|;
comment|/* Setup the logical address filter */
ifdef|#
directive|ifdef
name|MULTICAST
name|lesetladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|#
directive|else
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* init receive and transmit rings */
name|a
operator|=
name|LANCE_ADDR
argument_list|(
operator|&
name|ler2
operator|->
name|ler2_rbuf
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISQUADALIGN
argument_list|(
name|a
argument_list|)
condition|)
name|printf
argument_list|(
literal|"rbuf not quad aligned (0x%x)\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LERBUF
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
name|LANCE_ADDR
argument_list|(
operator|&
name|ler2
operator|->
name|ler2_rbuf
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd0
operator|=
name|a
expr_stmt|;
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd1_hadr
operator|=
name|a
operator|>>
literal|16
expr_stmt|;
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd1_bits
operator|=
name|LE_R1_OWN
expr_stmt|;
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd2
operator|=
operator|-
name|LEMTU
expr_stmt|;
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd3
operator|=
literal|0
expr_stmt|;
block|}
name|a
operator|=
name|LANCE_ADDR
argument_list|(
operator|&
name|ler2
operator|->
name|ler2_tbuf
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISQUADALIGN
argument_list|(
name|a
argument_list|)
condition|)
name|printf
argument_list|(
literal|"tbuf not quad aligned (0x%x)\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LETBUF
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
name|LANCE_ADDR
argument_list|(
operator|&
name|ler2
operator|->
name|ler2_tbuf
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd0
operator|=
name|a
expr_stmt|;
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd1_hadr
operator|=
name|a
operator|>>
literal|16
expr_stmt|;
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd1_bits
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd2
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd3
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|ler2
operator|->
name|ler2_rbuf
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
operator|(
name|LERBUF
operator|+
name|LETBUF
operator|)
operator|*
name|LEMTU
argument_list|)
expr_stmt|;
comment|/* lance will stuff packet into receive buffer 0 next */
name|sc
operator|->
name|sc_rmd
operator|=
literal|0
expr_stmt|;
comment|/* tell the chip where to find the initialization block */
name|a
operator|=
name|LANCE_ADDR
argument_list|(
operator|&
name|ler2
operator|->
name|ler2_mode
argument_list|)
expr_stmt|;
name|ler1
operator|->
name|ler1_rap
operator|=
name|LE_CSR1
expr_stmt|;
name|ler1
operator|->
name|ler1_rdp
operator|=
name|a
expr_stmt|;
name|ler1
operator|->
name|ler1_rap
operator|=
name|LE_CSR2
expr_stmt|;
name|ler1
operator|->
name|ler1_rdp
operator|=
name|a
operator|>>
literal|16
expr_stmt|;
name|ler1
operator|->
name|ler1_rap
operator|=
name|LE_CSR3
expr_stmt|;
name|ler1
operator|->
name|ler1_rdp
operator|=
name|LE_C3_BSWP
operator||
name|LE_C3_ACON
operator||
name|LE_C3_BCON
expr_stmt|;
name|ler1
operator|->
name|ler1_rap
operator|=
name|LE_CSR0
expr_stmt|;
name|ler1
operator|->
name|ler1_rdp
operator|=
name|LE_C0_INIT
expr_stmt|;
name|timo
operator|=
literal|100000
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|stat
operator|=
name|ler1
operator|->
name|ler1_rdp
operator|)
operator|&
operator|(
name|LE_C0_ERR
operator||
name|LE_C0_IDON
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|timo
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: init timeout, stat=%b\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|stat
argument_list|,
name|LE_C0_BITS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stat
operator|&
name|LE_C0_ERR
condition|)
name|printf
argument_list|(
literal|"%s: init failed, stat=%b\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|stat
argument_list|,
name|LE_C0_BITS
argument_list|)
expr_stmt|;
else|else
name|ler1
operator|->
name|ler1_rdp
operator|=
name|LE_C0_IDON
expr_stmt|;
comment|/* clear IDON */
name|ler1
operator|->
name|ler1_rdp
operator|=
name|LE_C0_STRT
operator||
name|LE_C0_INEA
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialization of interface  */
end_comment

begin_function
name|int
name|leinit
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
init|=
name|lecd
operator|.
name|cd_devs
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
comment|/* not yet, if address still unknown */
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|lereset
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
name|lestart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  Get another datagram to send  * off of the interface queue, and copy it to the interface  * before starting the output.  */
end_comment

begin_function
name|int
name|lestart
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
init|=
name|lecd
operator|.
name|cd_devs
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|letmd
modifier|*
name|tmd
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|len
operator|=
name|leput
argument_list|(
name|sc
operator|->
name|sc_r2
operator|->
name|ler2_tbuf
index|[
literal|0
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * If bpf is listening on this interface, let it 	 * see the packet before we commit it to the wire. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_bpf
condition|)
name|bpf_tap
argument_list|(
name|sc
operator|->
name|sc_bpf
argument_list|,
name|sc
operator|->
name|sc_r2
operator|->
name|ler2_tbuf
index|[
literal|0
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PACKETSTATS
if|if
condition|(
name|len
operator|<=
name|LEMTU
condition|)
name|lexpacketsizes
index|[
name|len
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|tmd
operator|=
name|sc
operator|->
name|sc_r2
operator|->
name|ler2_tmd
expr_stmt|;
name|tmd
operator|->
name|tmd3
operator|=
literal|0
expr_stmt|;
name|tmd
operator|->
name|tmd2
operator|=
operator|-
name|len
expr_stmt|;
name|tmd
operator|->
name|tmd1_bits
operator|=
name|LE_T1_OWN
operator||
name|LE_T1_STP
operator||
name|LE_T1_ENP
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|leintr
parameter_list|(
name|dev
parameter_list|)
specifier|register
name|void
modifier|*
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
init|=
name|dev
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lereg1
modifier|*
name|ler1
init|=
name|sc
operator|->
name|sc_r1
decl_stmt|;
specifier|register
name|int
name|csr0
decl_stmt|;
name|csr0
operator|=
name|ler1
operator|->
name|ler1_rdp
expr_stmt|;
if|if
condition|(
operator|(
name|csr0
operator|&
name|LE_C0_INTR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_interrupts
operator|++
expr_stmt|;
if|if
condition|(
name|csr0
operator|&
name|LE_C0_ERR
condition|)
block|{
name|leerror
argument_list|(
name|sc
argument_list|,
name|csr0
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr0
operator|&
name|LE_C0_MERR
condition|)
block|{
name|sc
operator|->
name|sc_merr
operator|++
expr_stmt|;
name|lereset
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|csr0
operator|&
name|LE_C0_BABL
condition|)
name|sc
operator|->
name|sc_babl
operator|++
expr_stmt|;
if|if
condition|(
name|csr0
operator|&
name|LE_C0_CERR
condition|)
name|sc
operator|->
name|sc_cerr
operator|++
expr_stmt|;
if|if
condition|(
name|csr0
operator|&
name|LE_C0_MISS
condition|)
name|sc
operator|->
name|sc_miss
operator|++
expr_stmt|;
name|ler1
operator|->
name|ler1_rdp
operator|=
name|LE_C0_BABL
operator||
name|LE_C0_CERR
operator||
name|LE_C0_MISS
operator||
name|LE_C0_INEA
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|csr0
operator|&
name|LE_C0_RXON
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_rxoff
operator|++
expr_stmt|;
name|lereset
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|csr0
operator|&
name|LE_C0_TXON
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_txoff
operator|++
expr_stmt|;
name|lereset
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|csr0
operator|&
name|LE_C0_RINT
condition|)
block|{
comment|/* interrupt is cleared in lerint */
name|lerint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csr0
operator|&
name|LE_C0_TINT
condition|)
block|{
name|ler1
operator|->
name|ler1_rdp
operator|=
name|LE_C0_TINT
operator||
name|LE_C0_INEA
expr_stmt|;
name|lexint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ethernet interface transmitter interrupt.  * Start another output if more data to send.  */
end_comment

begin_function
name|void
name|lexint
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|letmd
modifier|*
name|tmd
init|=
name|sc
operator|->
name|sc_r2
operator|->
name|ler2_tmd
decl_stmt|;
name|sc
operator|->
name|sc_lestats
operator|.
name|lexints
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_xint
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tmd
operator|->
name|tmd1_bits
operator|&
name|LE_T1_OWN
condition|)
block|{
name|sc
operator|->
name|sc_xown
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tmd
operator|->
name|tmd1_bits
operator|&
name|LE_T1_ERR
condition|)
block|{
name|err
label|:
name|lexerror
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|tmd
operator|->
name|tmd3
operator|&
operator|(
name|LE_T3_BUFF
operator||
name|LE_T3_UFLO
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_uflo
operator|++
expr_stmt|;
name|lereset
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd3
operator|&
name|LE_T3_LCOL
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd3
operator|&
name|LE_T3_RTRY
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd3
operator|&
name|LE_T3_BUFF
condition|)
comment|/* XXX documentation says BUFF not included in ERR */
goto|goto
name|err
goto|;
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd1_bits
operator|&
name|LE_T1_ONE
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd1_bits
operator|&
name|LE_T1_MORE
condition|)
comment|/* what is the real number? */
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
literal|2
expr_stmt|;
else|else
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|lestart
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|LENEXTRMP
define|\
value|if (++bix == LERBUF) bix = 0, rmd = sc->sc_r2->ler2_rmd; else ++rmd
end_define

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  * If input error just drop packet.  * Decapsulate packet based on type and pass to type specific  * higher-level input routine.  */
end_comment

begin_function
name|void
name|lerint
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|int
name|bix
init|=
name|sc
operator|->
name|sc_rmd
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lermd
modifier|*
name|rmd
init|=
operator|&
name|sc
operator|->
name|sc_r2
operator|->
name|ler2_rmd
index|[
name|bix
index|]
decl_stmt|;
name|sc
operator|->
name|sc_lestats
operator|.
name|lerints
operator|++
expr_stmt|;
comment|/* 	 * Out of sync with hardware, should never happen? 	 */
if|if
condition|(
name|rmd
operator|->
name|rmd1_bits
operator|&
name|LE_R1_OWN
condition|)
block|{
do|do
block|{
name|sc
operator|->
name|sc_lestats
operator|.
name|lerscans
operator|++
expr_stmt|;
name|LENEXTRMP
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|rmd
operator|->
name|rmd1_bits
operator|&
name|LE_R1_OWN
operator|)
operator|&&
name|bix
operator|!=
name|sc
operator|->
name|sc_rmd
condition|)
do|;
if|if
condition|(
name|bix
operator|==
name|sc
operator|->
name|sc_rmd
condition|)
name|printf
argument_list|(
literal|"%s: RINT with no buffer\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_lestats
operator|.
name|lerhits
operator|++
expr_stmt|;
comment|/* 	 * Process all buffers with valid data 	 */
while|while
condition|(
operator|(
name|rmd
operator|->
name|rmd1_bits
operator|&
name|LE_R1_OWN
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
init|=
name|rmd
operator|->
name|rmd3
decl_stmt|;
comment|/* Clear interrupt to avoid race condition */
name|sc
operator|->
name|sc_r1
operator|->
name|ler1_rdp
operator|=
name|LE_C0_RINT
operator||
name|LE_C0_INEA
expr_stmt|;
if|if
condition|(
name|rmd
operator|->
name|rmd1_bits
operator|&
name|LE_R1_ERR
condition|)
block|{
name|sc
operator|->
name|sc_rmd
operator|=
name|bix
expr_stmt|;
name|lererror
argument_list|(
name|sc
argument_list|,
literal|"bad packet"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rmd
operator|->
name|rmd1_bits
operator|&
operator|(
name|LE_R1_STP
operator||
name|LE_R1_ENP
operator|)
operator|)
operator|!=
operator|(
name|LE_R1_STP
operator||
name|LE_R1_ENP
operator|)
condition|)
block|{
comment|/* XXX make a define for LE_R1_STP|LE_R1_ENP? */
comment|/* 			 * Find the end of the packet so we can see how long 			 * it was.  We still throw it away. 			 */
do|do
block|{
name|sc
operator|->
name|sc_r1
operator|->
name|ler1_rdp
operator|=
name|LE_C0_RINT
operator||
name|LE_C0_INEA
expr_stmt|;
name|rmd
operator|->
name|rmd3
operator|=
literal|0
expr_stmt|;
name|rmd
operator|->
name|rmd1_bits
operator|=
name|LE_R1_OWN
expr_stmt|;
name|LENEXTRMP
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|rmd
operator|->
name|rmd1_bits
operator|&
operator|(
name|LE_R1_OWN
operator||
name|LE_R1_ERR
operator||
name|LE_R1_STP
operator||
name|LE_R1_ENP
operator|)
operator|)
condition|)
do|;
name|sc
operator|->
name|sc_rmd
operator|=
name|bix
expr_stmt|;
name|lererror
argument_list|(
name|sc
argument_list|,
literal|"chained buffer"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxlen
operator|++
expr_stmt|;
comment|/* 			 * If search terminated without successful completion 			 * we reset the hardware (conservative). 			 */
if|if
condition|(
operator|(
name|rmd
operator|->
name|rmd1_bits
operator|&
operator|(
name|LE_R1_OWN
operator||
name|LE_R1_ERR
operator||
name|LE_R1_STP
operator||
name|LE_R1_ENP
operator|)
operator|)
operator|!=
name|LE_R1_ENP
condition|)
block|{
name|lereset
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|leread
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_r2
operator|->
name|ler2_rbuf
index|[
name|bix
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PACKETSTATS
name|lerpacketsizes
index|[
name|len
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_lestats
operator|.
name|lerbufs
operator|++
expr_stmt|;
block|}
name|rmd
operator|->
name|rmd3
operator|=
literal|0
expr_stmt|;
name|rmd
operator|->
name|rmd1_bits
operator|=
name|LE_R1_OWN
expr_stmt|;
name|LENEXTRMP
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rmd
operator|=
name|bix
expr_stmt|;
block|}
end_function

begin_function
name|void
name|leread
parameter_list|(
name|sc
parameter_list|,
name|pkt
parameter_list|,
name|len
parameter_list|)
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|pkt
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|ether_header
modifier|*
name|et
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|et
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|pkt
expr_stmt|;
name|et
operator|->
name|ether_type
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|et
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* adjust input length to account for header and CRC */
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|ledebug
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: ierror(runt packet): from %s: len=%d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|ether_sprintf
argument_list|(
name|et
operator|->
name|ether_shost
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_runt
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Setup mbuf flags we'll need later */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|etherbroadcastaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|et
operator|->
name|ether_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|etherbroadcastaddr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|M_BCAST
expr_stmt|;
if|if
condition|(
name|et
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
condition|)
name|flags
operator||=
name|M_MCAST
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Check if there's a bpf filter listening on this interface. 	 * If so, hand off the raw packet to enet. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_bpf
condition|)
block|{
name|bpf_tap
argument_list|(
name|sc
operator|->
name|sc_bpf
argument_list|,
name|pkt
argument_list|,
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Keep the packet if it's a broadcast or has our 		 * physical ethernet address (or if we support 		 * multicast and it's one). 		 */
if|if
condition|(
ifdef|#
directive|ifdef
name|MULTICAST
operator|(
name|flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
operator|&&
else|#
directive|else
operator|(
name|flags
operator|&
name|M_BCAST
operator|)
operator|==
literal|0
operator|&&
endif|#
directive|endif
name|bcmp
argument_list|(
name|et
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|sc_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|et
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
name|m
operator|=
name|leget
argument_list|(
name|pkt
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
comment|/* XXX this code comes from ether_input() */
name|ifp
operator|->
name|if_lastchange
operator|=
name|time
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|et
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
condition|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|flags
expr_stmt|;
name|ifp
operator|->
name|if_imcasts
operator|++
expr_stmt|;
block|}
comment|/* XXX end of code from ether_input() */
switch|switch
condition|(
name|et
operator|->
name|ether_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_ARP
case|:
name|schednetisr
argument_list|(
name|NETISR_ARP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|arpintrq
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|ETHERTYPE_NS
case|:
name|schednetisr
argument_list|(
name|NETISR_NS
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|nsintrq
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UTAHONLY
ifdef|#
directive|ifdef
name|APPLETALK
case|case
name|ETHERTYPE_APPLETALK
case|:
name|schednetisr
argument_list|(
name|NETISR_DDP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ddpintq
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_AARP
case|:
name|aarpinput
argument_list|(
operator|&
name|sc
operator|->
name|sc_ac
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
endif|#
directive|endif
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to copy from mbuf chain to transmit  * buffer in board local memory.  *  * ### this can be done by remapping in some cases  */
end_comment

begin_function
name|int
name|leput
parameter_list|(
name|lebuf
parameter_list|,
name|m
parameter_list|)
specifier|register
name|char
modifier|*
name|lebuf
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|tlen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
name|tlen
operator|+=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|mp
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|lebuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lebuf
operator|+=
name|len
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|<
name|LEMINSIZE
condition|)
block|{
name|bzero
argument_list|(
name|lebuf
argument_list|,
name|LEMINSIZE
operator|-
name|tlen
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|LEMINSIZE
expr_stmt|;
block|}
return|return
operator|(
name|tlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routine to copy from board local memory into mbufs.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|leget
parameter_list|(
name|lebuf
parameter_list|,
name|totlen
parameter_list|,
name|off0
parameter_list|,
name|ifp
parameter_list|)
name|char
modifier|*
name|lebuf
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|off0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
init|=
literal|0
decl_stmt|,
modifier|*
modifier|*
name|mp
init|=
operator|&
name|top
decl_stmt|;
specifier|register
name|int
name|off
init|=
name|off0
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|epkt
decl_stmt|;
name|lebuf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|cp
operator|=
name|lebuf
expr_stmt|;
name|epkt
operator|=
name|cp
operator|+
name|totlen
expr_stmt|;
if|if
condition|(
name|off
condition|)
block|{
name|cp
operator|+=
name|off
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|totlen
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|epkt
operator|-
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m
operator|->
name|m_len
operator|=
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Place initial small packet/header at end of mbuf. 			 */
if|if
condition|(
name|len
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
name|top
operator|==
literal|0
operator|&&
name|len
operator|+
name|max_linkhdr
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
else|else
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|epkt
condition|)
name|cp
operator|=
name|lebuf
expr_stmt|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
name|int
name|leioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
init|=
name|lecd
operator|.
name|cd_devs
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|lereg1
modifier|*
name|ler1
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifa
operator|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
operator|(
name|void
operator|)
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_addr
operator|)
expr_stmt|;
else|else
block|{
comment|/* 				 * The manual says we can't change the address 				 * while the receiver is armed, 				 * so reset everything 				 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* does le_setaddr() */
break|break;
block|}
endif|#
directive|endif
default|default:
operator|(
name|void
operator|)
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|ler1
operator|=
name|sc
operator|->
name|sc_r1
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|ler1
operator|->
name|ler1_rdp
operator|=
name|LE_C0_STOP
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* 		 * If the state of the promiscuous bit changes, the interface 		 * must be reset to effect the change. 		 */
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|sc_iflags
operator|)
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_iflags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|lereset
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
name|lestart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|MULTICAST
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* Update our multicast list  */
name|error
operator|=
operator|(
name|cmd
operator|==
name|SIOCADDMULTI
operator|)
condition|?
name|ether_addmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|sc_ac
argument_list|)
else|:
name|ether_delmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|sc_ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
comment|/* 			 * Multicast list has changed; set the hardware 			 * filter accordingly. 			 */
name|lereset
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|leerror
parameter_list|(
name|sc
parameter_list|,
name|stat
parameter_list|)
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|stat
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ledebug
condition|)
return|return;
comment|/* 	 * Not all transceivers implement heartbeat 	 * so we only log CERR once. 	 */
if|if
condition|(
operator|(
name|stat
operator|&
name|LE_C0_CERR
operator|)
operator|&&
name|sc
operator|->
name|sc_cerr
condition|)
return|return;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: error: stat=%b\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|stat
argument_list|,
name|LE_C0_BITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lererror
parameter_list|(
name|sc
parameter_list|,
name|msg
parameter_list|)
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|lermd
modifier|*
name|rmd
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ledebug
condition|)
return|return;
name|rmd
operator|=
operator|&
name|sc
operator|->
name|sc_r2
operator|->
name|ler2_rmd
index|[
name|sc
operator|->
name|sc_rmd
index|]
expr_stmt|;
name|len
operator|=
name|rmd
operator|->
name|rmd3
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: ierror(%s): from %s: buf=%d, len=%d, rmd1=%b\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|msg
argument_list|,
name|len
operator|>
literal|11
condition|?
name|ether_sprintf
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_r2
operator|->
name|ler2_rbuf
index|[
name|sc
operator|->
name|sc_rmd
index|]
index|[
literal|6
index|]
argument_list|)
else|:
literal|"unknown"
argument_list|,
name|sc
operator|->
name|sc_rmd
argument_list|,
name|len
argument_list|,
name|rmd
operator|->
name|rmd1_bits
argument_list|,
name|LE_R1_BITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lexerror
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|letmd
modifier|*
name|tmd
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|tmd3
decl_stmt|,
name|tdr
decl_stmt|;
if|if
condition|(
operator|!
name|ledebug
condition|)
return|return;
name|tmd
operator|=
name|sc
operator|->
name|sc_r2
operator|->
name|ler2_tmd
expr_stmt|;
name|tmd3
operator|=
name|tmd
operator|->
name|tmd3
expr_stmt|;
name|tdr
operator|=
name|tmd3
operator|&
name|LE_T3_TDR_MASK
expr_stmt|;
name|len
operator|=
operator|-
name|tmd
operator|->
name|tmd2
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: oerror: to %s: buf=%d, len=%d, tmd1=%b, tmd3=%b, tdr=%d (%d nsecs)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|len
operator|>
literal|5
condition|?
name|ether_sprintf
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_r2
operator|->
name|ler2_tbuf
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
else|:
literal|"unknown"
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|tmd
operator|->
name|tmd1_bits
argument_list|,
name|LE_T1_BITS
argument_list|,
name|tmd3
argument_list|,
name|LE_T3_BITS
argument_list|,
name|tdr
argument_list|,
name|tdr
operator|*
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

