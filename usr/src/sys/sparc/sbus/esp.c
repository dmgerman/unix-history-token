begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)esp.c	8.2 (Berkeley) 12/14/93  *  * from: $Header: esp.c,v 1.28 93/04/27 14:40:44 torek Exp $ (LBL)  *  * Loosely derived from Mary Baker's devSCSIC90.c from the Berkeley  * Sprite project, which is:  *  * Copyright 1988 Regents of the University of California  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies.  The University of California  * makes no representations about the suitability of this  * software for any purpose.  It is provided "as is" without  * express or implied warranty.  *  * from /sprite/src/kernel/dev/sun4c.md/RCS/devSCSIC90.c,v 1.4  * 90/12/19 12:37:58 mgbaker Exp $ SPRITE (Berkeley)  */
end_comment

begin_comment
comment|/*  * Sbus ESP/DMA driver.  A single driver must be used for both devices  * as they are physically tied to each other:  The DMA chip can only  * be used to assist ESP SCSI transactions; the ESP interrupt enable is  * in the DMA chip csr.  *  * Since DMA and SCSI interrupts are handled in the same routine, the  * DMA device does not declare itself as an sbus device.  This saves  * some space.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/scsi.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/scsivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sbus/dmareg.h>
end_include

begin_define
define|#
directive|define
name|ESP_PHASE_NAMES
end_define

begin_include
include|#
directive|include
file|<sparc/sbus/espreg.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sbus/sbusvar.h>
end_include

begin_include
include|#
directive|include
file|<libkern/libkern.h>
end_include

begin_comment
comment|/*  * This driver is largely a giant state machine:  *  *	Given some previous SCSI state (as set up or tracked by us  *	earlier) and the interrupt registers provided on the chips  *	(dmacsr, espstat, espstep, and espintr), derive an action.  *	In many cases this is just a matter of reading the target's  *	phase and following its orders, which sets a new state.  *  * This sequencing is done in espact(); the state is primed in espselect().  *  * Data transfer is always done via DMA.  Unfortunately, there are  * limits in the DMA and ESP chips on how much data can be moved  * in a single operation.  The ESP chip has a 16-bit counter, so  * it is limited to 65536 bytes.  More insidiously, while the DMA  * chip has a 32-bit address, this is composed of a 24-bit counter  * with an 8-bit latch, so it cannot cross a 16 MB boundary.  To  * handle these, we program a smaller count than our caller requests;  * when this shorter transfer is done, if the target is still up  * for data transfer, we simply keep going (updating the DMA address)  * as needed.  *  * Another state bit is used to recover from bus resets:  *  *	A single TEST UNIT READY is attempted on each target before any  *	real communication begins; this TEST UNIT READY is allowed to  *	fail in any way.  This is required for the Quantum ProDrive 100  *	MB disks, for instance, which respond to their first selection  *	with status phase, and for anything that insists on implementing  *	the broken SCSI-2 synch transfer initial message.  *  * This is done in espclear() (which calls espselect(); functions that  * call espselect() must check for clearing first).  *  * The state machines actually intermingle, as some SCSI sequences are  * only allowed during clearing.  */
end_comment

begin_comment
comment|/* per-DMA variables */
end_comment

begin_struct
struct|struct
name|dma_softc
block|{
name|struct
name|device
name|dc_dev
decl_stmt|;
comment|/* base device */
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dc_dma
decl_stmt|;
comment|/* register virtual address */
name|int
name|dc_dmarev
decl_stmt|;
comment|/* revision */
name|char
modifier|*
name|dc_dmafmt
decl_stmt|;
comment|/* format for error messages */
block|}
struct|;
end_struct

begin_function_decl
name|void
name|dmaattach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfdriver
name|dmacd
init|=
block|{
name|NULL
block|,
literal|"dma"
block|,
name|matchbyname
block|,
name|dmaattach
block|,
name|DV_DULL
block|,
expr|sizeof
operator|(
expr|struct
name|dma_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per-ESP variables */
end_comment

begin_struct
struct|struct
name|esp_softc
block|{
comment|/* 	 * External interfaces. 	 */
name|struct
name|hba_softc
name|sc_hba
decl_stmt|;
comment|/* base device + hba, must be first */
define|#
directive|define
name|sc_dev
value|sc_hba.hba_dev
name|struct
name|sbusdev
name|sc_sd
decl_stmt|;
comment|/* sbus device */
name|struct
name|intrhand
name|sc_ih
decl_stmt|;
comment|/* interrupt entry */
name|struct
name|evcnt
name|sc_intrcnt
decl_stmt|;
comment|/* interrupt counter */
name|struct
name|dma_softc
modifier|*
name|sc_dc
decl_stmt|;
comment|/* pointer to corresponding dma sc */
comment|/* 	 * Addresses mapped to hardware registers. 	 */
specifier|volatile
name|struct
name|espreg
modifier|*
name|sc_esp
decl_stmt|;
specifier|volatile
name|struct
name|dmareg
modifier|*
name|sc_dma
decl_stmt|;
comment|/* 	 * Copies of registers cleared/unlatched by reading. 	 * (FIFO flags is not cleared, but we want it for debugging.) 	 */
name|u_long
name|sc_dmacsr
decl_stmt|;
name|u_char
name|sc_espstat
decl_stmt|;
name|u_char
name|sc_espstep
decl_stmt|;
name|u_char
name|sc_espintr
decl_stmt|;
name|u_char
name|sc_espfflags
decl_stmt|;
comment|/* miscellaneous */
name|int
name|sc_clockfreq
decl_stmt|;
comment|/* clock frequency */
name|u_char
name|sc_sel_timeout
decl_stmt|;
comment|/* select timeout */
name|u_char
name|sc_id
decl_stmt|;
comment|/* initiator ID (default = 7) */
name|u_char
name|sc_needclear
decl_stmt|;
comment|/* uncleared targets (1 bit each) */
name|u_char
name|sc_esptype
decl_stmt|;
comment|/* 100, 100A, 2xx (see below) */
name|u_char
name|sc_ccf
decl_stmt|;
comment|/* clock conversion factor */
name|u_char
name|sc_conf1
decl_stmt|;
comment|/* value for config reg 1 */
name|u_char
name|sc_conf2
decl_stmt|;
comment|/* value for config reg 2 */
name|u_char
name|sc_conf3
decl_stmt|;
comment|/* value for config reg 3 */
name|struct
name|bootpath
modifier|*
name|sc_bp
decl_stmt|;
comment|/* esp bootpath so far */
comment|/* 	 * Information pertaining to the current transfer, 	 * including sequencing. 	 * 	 * The size of sc_msg is the size of the ESP fifo, 	 * since we do message-in simply by allowing the fifo to fill. 	 */
name|char
name|sc_probing
decl_stmt|;
comment|/* used during autoconf; see below */
name|char
name|sc_clearing
decl_stmt|;
comment|/* true => cmd is just to clear targ */
name|char
name|sc_state
decl_stmt|;
comment|/* SCSI protocol state; see below */
name|char
name|sc_sentcmd
decl_stmt|;
comment|/* set once we get cmd out */
name|char
name|sc_dmaactive
decl_stmt|;
comment|/* true => doing dma */
ifdef|#
directive|ifdef
name|notyet
name|u_char
name|sc_sync
decl_stmt|;
comment|/* synchronous transfer stuff (?) */
endif|#
directive|endif
name|u_char
name|sc_stat
index|[
literal|2
index|]
decl_stmt|;
comment|/* status from last `status' phase */
name|u_char
name|sc_msg
index|[
literal|16
index|]
decl_stmt|;
comment|/* message from device */
name|u_short
name|sc_dmactl
decl_stmt|;
comment|/* control to load into dma csr */
name|u_long
name|sc_dmaaddr
decl_stmt|;
comment|/* address for next xfer */
name|int
name|sc_dmasize
decl_stmt|;
comment|/* size of current xfer */
name|int
name|sc_resid
decl_stmt|;
comment|/* count of bytes not yet xferred */
name|int
name|sc_targ
decl_stmt|;
comment|/* the target involved */
name|struct
name|scsi_cdb
modifier|*
name|sc_curcdb
decl_stmt|;
comment|/* ptr to current command */
comment|/* might cdbspace eventually be per-target? */
name|struct
name|scsi_cdb
name|sc_cdbspace
decl_stmt|;
comment|/* space for one command */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Values for sc_esptype (used to control configuration reset, and for  * workarounds for chip bugs).  The order is important; see espreset().  */
end_comment

begin_define
define|#
directive|define
name|ESP100
value|0
end_define

begin_define
define|#
directive|define
name|ESP100A
value|1
end_define

begin_define
define|#
directive|define
name|ESP2XX
value|2
end_define

begin_comment
comment|/*  * Probe state.  0 means not probing.  While looking for each target  * we set this to PROBE_TESTING and do a TEST UNIT READY on unit 0.  * If selection fails, this is changed to PROBE_NO_TARGET; otherwise  * we assume the target exists, regardless of the result of the test.  */
end_comment

begin_define
define|#
directive|define
name|PROBE_TESTING
value|1
end_define

begin_define
define|#
directive|define
name|PROBE_NO_TARGET
value|2
end_define

begin_comment
comment|/*  * States in sc_state.  *  * Note that S_SVC is rare: normally we load the SCSI command into the  * ESP fifo and get interrupted only when the device has gone to data  * or status phase.  If the device wants to play games, though, we end  * up doing things differently.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|espstates
index|[]
init|=
block|{
define|#
directive|define
name|S_IDLE
value|0
comment|/* not doing anything */
literal|"idle"
block|,
define|#
directive|define
name|S_SEL
value|1
comment|/* expecting select done interrupt */
literal|"selecting"
block|,
define|#
directive|define
name|S_SVC
value|2
comment|/* expecting service req interrupt */
literal|"waiting for svc req"
block|,
define|#
directive|define
name|S_DI
value|3
comment|/* expecting data-in done interrupt */
literal|"receiving data"
block|,
define|#
directive|define
name|S_DO
value|4
comment|/* expecting data-out done interrupt */
literal|"sending data"
block|,
define|#
directive|define
name|S_STAT
value|5
comment|/* expecting status done interrupt */
literal|"receiving status"
block|,
define|#
directive|define
name|S_MI
value|6
comment|/* expecting message-in done interrupt */
literal|"receiving message"
block|,
define|#
directive|define
name|S_FI
value|7
comment|/* expecting final disconnect interrupt */
literal|"waiting for disconnect"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hardware limits on transfer sizes (see comments at top).  */
end_comment

begin_define
define|#
directive|define
name|ESPMAX
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|DMAMAX
parameter_list|(
name|a
parameter_list|)
value|(0x01000000 - ((a)& 0x00ffffff))
end_define

begin_comment
comment|/*  * Return values from espact().  */
end_comment

begin_define
define|#
directive|define
name|ACT_CONT
value|0
end_define

begin_comment
comment|/* espact() handled everything */
end_comment

begin_define
define|#
directive|define
name|ACT_IO
value|1
end_define

begin_comment
comment|/* espact() is xferring data */
end_comment

begin_define
define|#
directive|define
name|ACT_DONE
value|2
end_define

begin_comment
comment|/* handled everything, and op is now done */
end_comment

begin_define
define|#
directive|define
name|ACT_ERROR
value|3
end_define

begin_comment
comment|/* an error occurred, op has been trashed */
end_comment

begin_define
define|#
directive|define
name|ACT_RESET
value|4
end_define

begin_comment
comment|/* please reset ESP, then do ACT_ERROR */
end_comment

begin_define
define|#
directive|define
name|ACT_QUICKINTR
value|5
end_define

begin_comment
comment|/* another interrupt is expected immediately */
end_comment

begin_comment
comment|/* autoconfiguration driver */
end_comment

begin_function_decl
name|void
name|espattach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfdriver
name|espcd
init|=
block|{
name|NULL
block|,
literal|"esp"
block|,
name|matchbyname
block|,
name|espattach
block|,
name|DV_DULL
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|esp_softc
argument_list|)
block|,
literal|"intr"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sbus driver */
end_comment

begin_function_decl
name|void
name|espsbreset
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* interrupt interface */
end_comment

begin_function_decl
name|int
name|espintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* SCSI HBA driver */
end_comment

begin_function_decl
name|int
name|espicmd
parameter_list|(
name|struct
name|hba_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|scsi_cdb
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|espdump
parameter_list|(
name|struct
name|hba_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|scsi_cdb
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|espstart
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|sq
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|scdgo_fn
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|espgo
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|int
parameter_list|,
name|scintr_fn
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|esprel
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|esphbareset
parameter_list|(
name|struct
name|hba_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|hbadriver
name|esphbadriver
init|=
block|{
name|espicmd
block|,
name|espdump
block|,
name|espstart
block|,
name|espgo
block|,
name|esprel
block|,
name|esphbareset
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* other prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|espdoattach
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dmareset
parameter_list|(
name|struct
name|esp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|espreset
parameter_list|(
name|struct
name|esp_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|esperror
parameter_list|(
name|struct
name|esp_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|espact
parameter_list|(
name|struct
name|esp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|espselect
parameter_list|(
name|struct
name|esp_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|scsi_cdb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* second arg to espreset() */
end_comment

begin_define
define|#
directive|define
name|RESET_ESPCHIP
value|0x1
end_define

begin_define
define|#
directive|define
name|RESET_SCSIBUS
value|0x2
end_define

begin_define
define|#
directive|define
name|RESET_BOTH
value|(RESET_ESPCHIP | RESET_SCSIBUS)
end_define

begin_comment
comment|/*  * Attach a found DMA chip.  * The second argument is really a pointer to an sbus_attach_args.  */
end_comment

begin_function
name|void
name|dmaattach
parameter_list|(
name|parent
parameter_list|,
name|dev
parameter_list|,
name|args
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
name|void
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
init|=
operator|(
expr|struct
name|dma_softc
operator|*
operator|)
name|dev
decl_stmt|;
specifier|register
name|struct
name|sbus_attach_args
modifier|*
name|sa
init|=
name|args
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dma
decl_stmt|;
specifier|register
name|int
name|rev
decl_stmt|;
name|struct
name|esp_softc
modifier|*
name|esc
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_ra
operator|.
name|ra_vaddr
condition|)
name|dma
operator|=
operator|(
specifier|volatile
expr|struct
name|dmareg
operator|*
operator|)
name|sa
operator|->
name|sa_ra
operator|.
name|ra_vaddr
expr_stmt|;
else|else
name|dma
operator|=
operator|(
specifier|volatile
expr|struct
name|dmareg
operator|*
operator|)
name|mapiodev
argument_list|(
name|sa
operator|->
name|sa_ra
operator|.
name|ra_paddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dmareg
argument_list|)
argument_list|)
expr_stmt|;
name|dc
operator|->
name|dc_dma
operator|=
name|dma
expr_stmt|;
switch|switch
condition|(
name|rev
operator|=
name|DMA_REV
argument_list|(
name|dma
operator|->
name|dma_csr
argument_list|)
condition|)
block|{
case|case
name|DMAREV_1
case|:
name|printf
argument_list|(
literal|": rev 1\n"
argument_list|)
expr_stmt|;
name|dc
operator|->
name|dc_dmafmt
operator|=
name|DMA_REV1_BITS
expr_stmt|;
break|break;
case|case
name|DMAREV_2
case|:
name|printf
argument_list|(
literal|": rev 2\n"
argument_list|)
expr_stmt|;
name|dc
operator|->
name|dc_dmafmt
operator|=
name|DMA_REV2_BITS
expr_stmt|;
break|break;
case|case
name|DMAREV_3
case|:
name|printf
argument_list|(
literal|": rev 3\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"WARNING: esp.c not yet updated for rev 3\n"
argument_list|)
expr_stmt|;
name|dc
operator|->
name|dc_dmafmt
operator|=
name|DMA_REV3_BITS
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|": unknown revision code 0x%x\n"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|dc
operator|->
name|dc_dmafmt
operator|=
name|DMA_REV3_BITS
expr_stmt|;
comment|/* cross fingers */
break|break;
block|}
name|dc
operator|->
name|dc_dmarev
operator|=
name|rev
expr_stmt|;
name|espdoattach
argument_list|(
name|dc
operator|->
name|dc_dev
operator|.
name|dv_unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach a found ESP chip.  Search for targets; attach each one found.  * The latter must be deferred if the corresponding dma chip has not yet  * been configured.  */
end_comment

begin_function
name|void
name|espattach
parameter_list|(
name|parent
parameter_list|,
name|self
parameter_list|,
name|args
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|struct
name|device
modifier|*
name|self
decl_stmt|;
name|void
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|sbus_attach_args
modifier|*
name|sa
init|=
name|args
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
decl_stmt|;
specifier|register
name|struct
name|bootpath
modifier|*
name|bp
decl_stmt|;
name|int
name|node
decl_stmt|,
name|pri
decl_stmt|,
name|freq
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_ra
operator|.
name|ra_nintr
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|": expected 1 interrupt, got %d\n"
argument_list|,
name|sa
operator|->
name|sa_ra
operator|.
name|ra_nintr
argument_list|)
expr_stmt|;
return|return;
block|}
name|pri
operator|=
name|sa
operator|->
name|sa_ra
operator|.
name|ra_intr
index|[
literal|0
index|]
operator|.
name|int_pri
expr_stmt|;
name|printf
argument_list|(
literal|" pri %d"
argument_list|,
name|pri
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_ra
operator|.
name|ra_vaddr
condition|)
name|esp
operator|=
operator|(
specifier|volatile
expr|struct
name|espreg
operator|*
operator|)
name|sa
operator|->
name|sa_ra
operator|.
name|ra_vaddr
expr_stmt|;
else|else
name|esp
operator|=
operator|(
specifier|volatile
expr|struct
name|espreg
operator|*
operator|)
name|mapiodev
argument_list|(
name|sa
operator|->
name|sa_ra
operator|.
name|ra_paddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|espreg
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_esp
operator|=
name|esp
expr_stmt|;
name|node
operator|=
name|sa
operator|->
name|sa_ra
operator|.
name|ra_node
expr_stmt|;
name|sc
operator|->
name|sc_id
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"initiator-id"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|freq
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"clock-frequency"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|0
condition|)
name|freq
operator|=
operator|(
operator|(
expr|struct
name|sbus_softc
operator|*
operator|)
name|sc
operator|->
name|sc_dev
operator|.
name|dv_parent
operator|)
operator|->
name|sc_clockfreq
expr_stmt|;
comment|/* MIGHT NEED TO RESET ESP CHIP HERE ...? */
comment|/* 	 * Find out whether we have a -100, -100A, or -2xx, 	 * and what speed it runs at. 	 */
name|sc
operator|->
name|sc_conf1
operator|=
name|sc
operator|->
name|sc_id
operator||
name|ESPCONF1_PARENB
expr_stmt|;
comment|/* sc->sc_conf2 = 0; */
comment|/* sc->sc_conf3 = 0; */
name|esp
operator|->
name|esp_conf1
operator|=
name|sc
operator|->
name|sc_conf1
expr_stmt|;
name|esp
operator|->
name|esp_conf2
operator|=
literal|0
expr_stmt|;
name|esp
operator|->
name|esp_conf2
operator|=
name|ESPCONF2_SCSI2
operator||
name|ESPCONF2_RPE
expr_stmt|;
if|if
condition|(
operator|(
name|esp
operator|->
name|esp_conf2
operator|&
operator|~
name|ESPCONF2_RSVD
operator|)
operator|!=
operator|(
name|ESPCONF2_SCSI2
operator||
name|ESPCONF2_RPE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|": ESP100"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_esptype
operator|=
name|ESP100
expr_stmt|;
block|}
else|else
block|{
name|esp
operator|->
name|esp_conf2
operator|=
literal|0
expr_stmt|;
name|esp
operator|->
name|esp_conf3
operator|=
literal|0
expr_stmt|;
name|esp
operator|->
name|esp_conf3
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|esp
operator|->
name|esp_conf3
operator|!=
literal|5
condition|)
block|{
comment|/* XXX def bits */
name|printf
argument_list|(
literal|": ESP100A"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_esptype
operator|=
name|ESP100A
expr_stmt|;
block|}
else|else
block|{
name|esp
operator|->
name|esp_conf3
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|": ESP2XX"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_esptype
operator|=
name|ESP2XX
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|", clock = %s MHz, ID = %d\n"
argument_list|,
name|clockfreq
argument_list|(
name|freq
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
comment|/* 	 * Set clock conversion factor and select timeout. 	 * N.B.: clock frequency is not actually used in the rest 	 * of the driver; I calculate it here for completeness only 	 * (so I can see it when debugging). 	 */
name|sc
operator|->
name|sc_clockfreq
operator|=
name|freq
expr_stmt|;
name|freq
operator|=
name|howmany
argument_list|(
name|freq
argument_list|,
literal|1000
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* convert to MHz */
name|t
operator|=
name|ESPCCF_FROMMHZ
argument_list|(
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|ESPCCF_MIN
condition|)
name|t
operator|=
name|ESPCCF_MIN
expr_stmt|;
name|sc
operator|->
name|sc_ccf
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|ESPTIMO_REGVAL
argument_list|(
literal|250
argument_list|,
name|t
argument_list|,
name|freq
argument_list|)
expr_stmt|;
comment|/* timeout = 250 ms. */
if|if
condition|(
name|t
operator|>=
literal|256
condition|)
name|t
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_sel_timeout
operator|=
name|t
expr_stmt|;
comment|/* 	 * Link into sbus; set interrupt handler. 	 */
name|sc
operator|->
name|sc_sd
operator|.
name|sd_reset
operator|=
name|espsbreset
expr_stmt|;
name|sbus_establish
argument_list|(
operator|&
name|sc
operator|->
name|sc_sd
argument_list|,
operator|&
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ih
operator|.
name|ih_fun
operator|=
name|espintr
expr_stmt|;
name|sc
operator|->
name|sc_ih
operator|.
name|ih_arg
operator|=
name|sc
expr_stmt|;
name|intr_establish
argument_list|(
name|pri
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|evcnt_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"intr"
argument_list|,
operator|&
name|sc
operator|->
name|sc_intrcnt
argument_list|)
expr_stmt|;
define|#
directive|define
name|SAME_ESP
parameter_list|(
name|bp
parameter_list|,
name|sa
parameter_list|)
define|\
value|((bp->val[0] == sa->sa_slot&& bp->val[1] == sa->sa_offset) || \ 	 (bp->val[0] == -1&& bp->val[1] == sc->sc_dev.dv_unit))
name|bp
operator|=
name|sa
operator|->
name|sa_ra
operator|.
name|ra_bp
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|bp
operator|->
name|name
argument_list|,
literal|"esp"
argument_list|)
operator|==
literal|0
operator|&&
name|SAME_ESP
argument_list|(
name|bp
argument_list|,
name|sa
argument_list|)
condition|)
name|sc
operator|->
name|sc_bp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|espdoattach
argument_list|(
name|sc
operator|->
name|sc_dev
operator|.
name|dv_unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * `Final' attach of esp occurs once esp and dma chips have been found  * and assigned virtual addresses.  Set up the ESP SCSI data structures  * and probe the SCSI bus.  */
end_comment

begin_function
specifier|static
name|void
name|espdoattach
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
decl_stmt|;
specifier|register
name|struct
name|bootpath
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|targ
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|targ
decl_stmt|,
name|u
decl_stmt|;
comment|/* make sure we have both */
if|if
condition|(
name|espcd
operator|.
name|cd_ndevs
operator|<=
name|unit
operator|||
name|dmacd
operator|.
name|cd_ndevs
operator|<=
name|unit
operator|||
operator|(
name|sc
operator|=
name|espcd
operator|.
name|cd_devs
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
operator|||
operator|(
name|dc
operator|=
name|dmacd
operator|.
name|cd_devs
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|->
name|sc_dc
operator|=
name|dc
expr_stmt|;
name|sc
operator|->
name|sc_dma
operator|=
name|dc
operator|->
name|dc_dma
expr_stmt|;
name|sc
operator|->
name|sc_hba
operator|.
name|hba_driver
operator|=
operator|&
name|esphbadriver
expr_stmt|;
name|sc
operator|->
name|sc_dma
operator|->
name|dma_csr
operator|=
literal|0
expr_stmt|;
comment|/* ??? */
name|espreset
argument_list|(
name|sc
argument_list|,
name|RESET_ESPCHIP
argument_list|)
expr_stmt|;
comment|/* MAYBE THIS SHOULD BE MOVED TO scsi_subr.c? */
for|for
control|(
name|targ
operator|=
literal|0
init|;
name|targ
operator|<
literal|8
condition|;
name|targ
operator|++
control|)
block|{
if|if
condition|(
name|targ
operator|==
name|sc
operator|->
name|sc_id
condition|)
continue|continue;
name|sc
operator|->
name|sc_probing
operator|=
name|PROBE_TESTING
expr_stmt|;
name|sc
operator|->
name|sc_clearing
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|scsi_test_unit_ready
argument_list|(
operator|&
name|sc
operator|->
name|sc_hba
argument_list|,
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_probing
operator|!=
name|PROBE_NO_TARGET
condition|)
block|{
name|sc
operator|->
name|sc_probing
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_clearing
operator|=
literal|0
expr_stmt|;
name|SCSI_FOUNDTARGET
argument_list|(
operator|&
name|sc
operator|->
name|sc_hba
argument_list|,
name|targ
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_probing
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_clearing
operator|=
literal|0
expr_stmt|;
comment|/* 	 * See if we booted from a unit on this target.  We could 	 * compare bp->name against the unit's name but there's no 	 * real need since a target and unit uniquely specify a 	 * scsi device. 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|sc
operator|->
name|sc_bp
operator|)
operator|!=
name|NULL
operator|&&
call|(
name|u_int
call|)
argument_list|(
name|targ
operator|=
name|bp
operator|->
name|val
index|[
literal|0
index|]
argument_list|)
operator|<
literal|8
operator|&&
call|(
name|u_int
call|)
argument_list|(
name|u
operator|=
name|bp
operator|->
name|val
index|[
literal|1
index|]
argument_list|)
operator|<
literal|8
operator|&&
operator|(
name|t
operator|=
name|sc
operator|->
name|sc_hba
operator|.
name|hba_targets
index|[
name|targ
index|]
operator|)
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|t_units
index|[
name|u
index|]
operator|!=
name|NULL
condition|)
name|bootdv
operator|=
name|t
operator|->
name|t_units
index|[
name|u
index|]
operator|->
name|u_dev
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We are not allowed to touch the DMA "flush" and "drain" bits  * while it is still thinking about a request (DMA_RP).  */
end_comment

begin_define
define|#
directive|define
name|DMAWAIT
parameter_list|(
name|dma
parameter_list|)
value|while ((dma)->dma_csr& DMA_RP) DELAY(1)
end_define

begin_comment
comment|/*  * Reset the DMA chip.  */
end_comment

begin_function
specifier|static
name|void
name|dmareset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
name|DMAWAIT
argument_list|(
name|dma
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_csr
operator||=
name|DMA_RESET
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_csr
operator|&=
operator|~
name|DMA_RESET
expr_stmt|;
comment|/* ??? */
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
name|sc
operator|->
name|sc_dmaactive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dc
operator|->
name|dc_dmarev
operator|==
name|DMAREV_2
operator|&&
name|sc
operator|->
name|sc_esptype
operator|!=
name|ESP100
condition|)
name|dma
operator|->
name|dma_csr
operator||=
name|DMA_TURBO
expr_stmt|;
name|dma
operator|->
name|dma_csr
operator||=
name|DMA_IE
expr_stmt|;
comment|/* enable interrupts */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the chip and/or SCSI bus (always resets DMA).  */
end_comment

begin_function
specifier|static
name|void
name|espreset
parameter_list|(
name|sc
parameter_list|,
name|how
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|how
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
init|=
name|sc
operator|->
name|sc_esp
decl_stmt|;
name|dmareset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
operator|&
name|RESET_ESPCHIP
condition|)
block|{
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_RESET_CHIP
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_NOP
expr_stmt|;
comment|/* 		 * Reload configuration registers (cleared by 		 * RESET_CHIP command).  Reloading conf2 on an 		 * ESP100 goofs it up, so out of paranoia we load 		 * only the registers that exist. 		 */
name|esp
operator|->
name|esp_conf1
operator|=
name|sc
operator|->
name|sc_conf1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_esptype
operator|>
name|ESP100
condition|)
block|{
comment|/* 100A, 2XX */
name|esp
operator|->
name|esp_conf2
operator|=
name|sc
operator|->
name|sc_conf2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_esptype
operator|>
name|ESP100A
condition|)
comment|/* 2XX only */
name|esp
operator|->
name|esp_conf3
operator|=
name|sc
operator|->
name|sc_conf3
expr_stmt|;
block|}
name|esp
operator|->
name|esp_ccf
operator|=
name|sc
operator|->
name|sc_ccf
expr_stmt|;
name|esp
operator|->
name|esp_timeout
operator|=
name|sc
operator|->
name|sc_sel_timeout
expr_stmt|;
comment|/* We set synch offset later. */
block|}
if|if
condition|(
name|how
operator|&
name|RESET_SCSIBUS
condition|)
block|{
comment|/* 		 * The chip should retain most of its parameters 		 * (including esp_ccf) across this kind of reset 		 * (see section 3.5 of Emulex documentation). 		 */
comment|/* turn off scsi bus reset interrupts and reset scsi bus */
name|esp
operator|->
name|esp_conf1
operator|=
name|sc
operator|->
name|sc_conf1
operator||
name|ESPCONF1_REPORT
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_RESET_BUS
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_NOP
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* ??? */
operator|(
name|void
operator|)
name|esp
operator|->
name|esp_intr
expr_stmt|;
name|esp
operator|->
name|esp_conf1
operator|=
name|sc
operator|->
name|sc_conf1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_needclear
operator|=
literal|0xff
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the SCSI bus and, optionally, all attached targets.  */
end_comment

begin_function
name|void
name|esphbareset
parameter_list|(
name|hba
parameter_list|,
name|resetunits
parameter_list|)
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
name|int
name|resetunits
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|hba
decl_stmt|;
name|espreset
argument_list|(
name|sc
argument_list|,
name|RESET_SCSIBUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|resetunits
condition|)
name|scsi_reset_units
argument_list|(
operator|&
name|sc
operator|->
name|sc_hba
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the esp, after an Sbus reset.  * Also resets corresponding dma chip.  *  * THIS ROUTINE MIGHT GO AWAY  */
end_comment

begin_function
name|void
name|espsbreset
parameter_list|(
name|dev
parameter_list|)
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
block|{
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|dev
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dc
condition|)
block|{
name|printf
argument_list|(
literal|" %s %s"
argument_list|,
name|sc
operator|->
name|sc_dc
operator|->
name|dc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|esphbareset
argument_list|(
operator|&
name|sc
operator|->
name|sc_hba
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Log an error.  */
end_comment

begin_function
specifier|static
name|void
name|esperror
parameter_list|(
name|sc
parameter_list|,
name|err
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
block|{
name|int
name|stat
decl_stmt|;
name|stat
operator|=
name|sc
operator|->
name|sc_espstat
expr_stmt|;
name|printf
argument_list|(
literal|"%s target %d cmd 0x%x (%s): %s:\n\ \tstat=%b (%s) step=%x dmacsr=%b fflags=%x intr=%b\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|,
name|sc
operator|->
name|sc_curcdb
operator|->
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|espstates
index|[
name|sc
operator|->
name|sc_state
index|]
argument_list|,
name|err
argument_list|,
name|stat
argument_list|,
name|ESPSTAT_BITS
argument_list|,
name|espphases
index|[
name|stat
operator|&
name|ESPSTAT_PHASE
index|]
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|,
name|sc
operator|->
name|sc_dmacsr
argument_list|,
name|sc
operator|->
name|sc_dc
operator|->
name|dc_dmafmt
argument_list|,
name|sc
operator|->
name|sc_espfflags
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|ESPINTR_BITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Issue a select, loading command into the FIFO.  * Return nonzero on error, 0 if OK.  * Sets state to `selecting'; espact() will sequence state FSM.  */
end_comment

begin_function
name|void
name|espselect
parameter_list|(
name|sc
parameter_list|,
name|targ
parameter_list|,
name|cdb
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|targ
decl_stmt|;
specifier|register
name|struct
name|scsi_cdb
modifier|*
name|cdb
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|cmdlen
decl_stmt|;
name|sc
operator|->
name|sc_targ
operator|=
name|targ
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_SEL
expr_stmt|;
name|sc
operator|->
name|sc_curcdb
operator|=
name|cdb
expr_stmt|;
name|sc
operator|->
name|sc_sentcmd
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_stat
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* ??? */
name|sc
operator|->
name|sc_msg
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* ??? */
comment|/* 	 * Try to talk to target. 	 * Synch offset 0 => asynchronous transfer. 	 */
name|esp
operator|=
name|sc
operator|->
name|sc_esp
expr_stmt|;
name|esp
operator|->
name|esp_id
operator|=
name|targ
expr_stmt|;
name|esp
operator|->
name|esp_syncoff
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Stuff the command bytes into the fifo. 	 * Select without attention since we do not do disconnect yet. 	 */
name|cmdlen
operator|=
name|SCSICMDLEN
argument_list|(
name|cdb
operator|->
name|cdb_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmdlen
condition|;
name|i
operator|++
control|)
name|esp
operator|->
name|esp_fifo
operator|=
name|cdb
operator|->
name|cdb_bytes
index|[
name|i
index|]
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_SEL_NATN
expr_stmt|;
comment|/* the rest is done elsewhere */
block|}
end_function

begin_comment
comment|/*  * Sequence through the SCSI state machine.  Return the action to take.  *  * Most of the work happens here.  *  * There are three interrupt sources:  *   -- ESP interrupt request (typically, some device wants something).  *   -- DMA memory error.  *   -- DMA byte count has reached 0 (we do not often want this one but  *	can only turn it off in rev 2 DMA chips, it seems).  *	DOES THIS OCCUR AT ALL HERE?  THERE IS NOTHING TO HANDLE IT!  */
end_comment

begin_function
specifier|static
name|int
name|espact
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dma
decl_stmt|;
specifier|register
name|int
name|reg
decl_stmt|,
name|i
decl_stmt|,
name|resid
decl_stmt|,
name|newstate
decl_stmt|;
specifier|register
name|struct
name|scsi_cdb
modifier|*
name|cdb
decl_stmt|;
name|dma
operator|=
name|sc
operator|->
name|sc_dma
expr_stmt|;
comment|/* check various error conditions, using as little code as possible */
if|if
condition|(
name|sc
operator|->
name|sc_dmacsr
operator|&
name|DMA_EP
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DMA error"
argument_list|)
expr_stmt|;
name|DMAWAIT
argument_list|(
name|dma
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_csr
operator||=
name|DMA_FLUSH
expr_stmt|;
return|return
operator|(
name|ACT_ERROR
operator|)
return|;
block|}
name|reg
operator|=
name|sc
operator|->
name|sc_espstat
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|ESPSTAT_GE
condition|)
block|{
comment|/* 		 * This often occurs when there is no target. 		 * (See DSC code below.) 		 */
if|if
condition|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_DSC
operator|&&
name|sc
operator|->
name|sc_state
operator|==
name|S_SEL
operator|&&
name|sc
operator|->
name|sc_probing
condition|)
block|{
name|sc
operator|->
name|sc_probing
operator|=
name|PROBE_NO_TARGET
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DIAG: gross error (ignored)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|ESPSTAT_PE
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"parity error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
name|reg
operator|=
name|sc
operator|->
name|sc_espintr
expr_stmt|;
define|#
directive|define
name|ERR
value|(ESPINTR_SBR|ESPINTR_ILC|ESPINTR_RSL|ESPINTR_SAT|ESPINTR_SEL)
if|if
condition|(
name|reg
operator|&
name|ERR
condition|)
block|{
if|if
condition|(
name|reg
operator|&
name|ESPINTR_SBR
condition|)
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"scsi bus reset"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|&
name|ESPINTR_ILC
condition|)
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"illegal command (driver bug)"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s: target %d"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|ESPINTR_RSL
condition|)
name|printf
argument_list|(
literal|" tried to reselect;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|ESPINTR_SAT
condition|)
name|printf
argument_list|(
literal|" selected with ATN;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|ESPINTR_SEL
condition|)
name|printf
argument_list|(
literal|" selected us as target;"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"we do not allow this yet\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ACT_ERROR
operator|)
return|;
block|}
undef|#
directive|undef
name|ERR
name|esp
operator|=
name|sc
operator|->
name|sc_esp
expr_stmt|;
comment|/* 	 * Disconnect currently only allowed in `final interrupt' states. 	 */
if|if
condition|(
name|reg
operator|&
name|ESPINTR_DSC
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|S_FI
condition|)
return|return
operator|(
name|ACT_DONE
operator|)
return|;
comment|/* 		 * If we were doing a select just to test the existence 		 * of the target, note that it did not respond; otherwise 		 * gripe. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|S_SEL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_probing
condition|)
block|{
name|sc
operator|->
name|sc_probing
operator|=
name|PROBE_NO_TARGET
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
block|}
comment|/* flush fifo, in case we were selecting or sending data */
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_FLUSH_FIFO
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: target %d not responding\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_ERROR
operator|)
return|;
block|}
comment|/* 	 * Okay, things are moving along. 	 * What were we doing the last time we did something, 	 * and did it complete normally? 	 */
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|S_SEL
case|:
comment|/* 		 * We were selecting.  Arbitration and select are 		 * complete (because ESPINTR_DSC was not set), but 		 * there is no guarantee the command went out. 		 */
if|if
condition|(
operator|(
name|reg
operator|&
operator|(
name|ESPINTR_SVC
operator||
name|ESPINTR_CMP
operator|)
operator|)
operator|!=
operator|(
name|ESPINTR_SVC
operator||
name|ESPINTR_CMP
operator|)
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"selection failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_espstep
operator|==
name|ESPSTEP_DONE
condition|)
block|{
name|sc
operator|->
name|sc_sentcmd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_espstep
operator|==
literal|2
condition|)
block|{
comment|/* 			 * We got something other than command phase. 			 * Just pretend things are normal; the 			 * device will ask for the command later. 			 */
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DIAG: esp step 2"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_espstep
operator|==
literal|3
condition|)
block|{
comment|/* 			 * Device entered command phase and then exited it 			 * before we finished handing out the command. 			 * Let this happen iff we are trying to clear the 			 * target state. 			 */
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DIAG: esp step 3"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_clearing
condition|)
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: mysterious esp step %d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
comment|/* 		 * Part of the command may still be lodged in the FIFO. 		 */
if|if
condition|(
name|ESP_NFIFO
argument_list|(
name|sc
operator|->
name|sc_espfflags
argument_list|)
condition|)
block|{
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_FLUSH_FIFO
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|S_SVC
case|:
comment|/* 		 * We were waiting for phase change after stuffing the command 		 * into the FIFO.  Make sure it got out. 		 */
if|if
condition|(
name|ESP_NFIFO
argument_list|(
name|sc
operator|->
name|sc_espfflags
argument_list|)
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DIAG: CMDSVC, fifo not empty"
argument_list|)
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_FLUSH_FIFO
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_sentcmd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|S_DI
case|:
comment|/* 		 * We were doing DMA data in, and expecting a 		 * transfer-count-zero interrupt or a phase change. 		 * We got that; drain the pack register and handle 		 * as for data out -- but ignore FIFO (it should be 		 * empty, except for sync mode which we are not 		 * using anyway). 		 */
name|DMAWAIT
argument_list|(
name|dma
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_csr
operator||=
name|DMA_DRAIN
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|resid
operator|=
literal|0
expr_stmt|;
goto|goto
name|dma_data_done
goto|;
case|case
name|S_DO
case|:
comment|/* 		 * We were doing DMA data out.  If there is data in the 		 * FIFO, it is stuff that got DMAed out but never made 		 * it to the device, so it counts as residual. 		 */
if|if
condition|(
operator|(
name|resid
operator|=
name|ESP_NFIFO
argument_list|(
name|sc
operator|->
name|sc_espfflags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_FLUSH_FIFO
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dma_data_done
label|:
if|if
condition|(
name|sc
operator|->
name|sc_dmaactive
operator|==
literal|0
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"dma done w/o dmaactive"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"espact"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_dmaactive
operator|=
literal|0
expr_stmt|;
comment|/* Finish computing residual count. */
name|reg
operator|=
name|esp
operator|->
name|esp_tcl
operator||
operator|(
name|esp
operator|->
name|esp_tch
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_TC
operator|)
operator|==
literal|0
condition|)
name|reg
operator|=
literal|65536
expr_stmt|;
name|resid
operator|+=
name|reg
expr_stmt|;
comment|/* Compute xfer count (requested - resid). */
name|i
operator|=
name|sc
operator|->
name|sc_dmasize
operator|-
name|resid
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: xfer resid (%d)> xfer req (%d)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|resid
argument_list|,
name|sc
operator|->
name|sc_dmasize
argument_list|)
expr_stmt|;
name|i
operator|=
name|sc
operator|->
name|sc_dmasize
expr_stmt|;
comment|/* forgiving... */
block|}
comment|/* If data came in we must flush cache. */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|S_DI
condition|)
name|cache_flush
argument_list|(
name|sc
operator|->
name|sc_dmaaddr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dmaaddr
operator|+=
name|i
expr_stmt|;
name|sc
operator|->
name|sc_resid
operator|-=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_SVC
operator|)
operator|==
literal|0
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"no bus service req"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
break|break;
case|case
name|S_STAT
case|:
comment|/* 		 * The last thing we did was tell it `initiator complete' 		 * and so we expect to have gotten both the status byte 		 * and the final message byte.  It is possible that we 		 * got something else.... 		 * 		 * Apparently, BUS SERVICE is set if we got just status, 		 * while FUNCTION COMPLETE is set if we got both. 		 */
if|if
condition|(
operator|(
name|reg
operator|&
operator|(
name|ESPINTR_SVC
operator||
name|ESPINTR_CMP
operator|)
operator|)
operator|!=
name|ESPINTR_CMP
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"bad status interrupt state"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
name|reg
operator|=
name|ESP_NFIFO
argument_list|(
name|sc
operator|->
name|sc_espfflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command done but fifo count = %d; must be>= 2\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
comment|/* 		 * Read the status and the first msg byte. 		 * It should be CMD_COMPLETE.  Eventually we 		 * may handle IDENTIFY, DISCONNECT, etc., as well. 		 */
name|sc
operator|->
name|sc_stat
index|[
literal|0
index|]
operator|=
name|esp
operator|->
name|esp_fifo
expr_stmt|;
name|sc
operator|->
name|sc_msg
index|[
literal|0
index|]
operator|=
name|reg
operator|=
name|esp
operator|->
name|esp_fifo
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_MSG_ACCEPT
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|MSG_CMD_COMPLETE
condition|)
block|{
name|sc
operator|->
name|sc_state
operator|=
name|S_FI
expr_stmt|;
return|return
operator|(
name|ACT_CONT
operator|)
return|;
block|}
if|if
condition|(
name|SCSIMSGLEN
argument_list|(
name|reg
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d is naughty\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"%s: warning: target %d returned msg 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_FI
expr_stmt|;
return|return
operator|(
name|ACT_CONT
operator|)
return|;
case|case
name|S_MI
case|:
if|if
condition|(
operator|(
name|reg
operator|&
name|ESPINTR_SVC
operator|)
operator|==
literal|0
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"missing phase after msg in"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
name|reg
operator|=
name|ESP_NFIFO
argument_list|(
name|sc
operator|->
name|sc_espfflags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_msg
index|[
name|i
index|]
operator|=
name|esp
operator|->
name|esp_fifo
expr_stmt|;
break|break;
case|case
name|S_FI
case|:
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"target did not disconnect"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
comment|/* 	 * Things are still moving along.  The phase tells us 	 * what the device wants next.  Do it. 	 */
switch|switch
condition|(
name|sc
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_PHASE
condition|)
block|{
case|case
name|ESPPHASE_DATA_OUT
case|:
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_sentcmd
condition|)
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DIAG: data out without command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dmactl
operator|&
name|DMA_READ
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"wrong phase (want to read)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
name|newstate
operator|=
name|S_DO
expr_stmt|;
goto|goto
name|do_data_xfer
goto|;
case|case
name|ESPPHASE_DATA_IN
case|:
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_sentcmd
condition|)
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DIAG: data in without command"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_dmactl
operator|&
name|DMA_READ
operator|)
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"wrong phase (want to write)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
name|newstate
operator|=
name|S_DI
expr_stmt|;
name|do_data_xfer
label|:
if|if
condition|(
name|sc
operator|->
name|sc_resid
operator|==
literal|0
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"data count error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
comment|/* 		 * Compute DMA count based on chip limits. 		 * Set DMA address and load transfer count into 		 * ESP via DMA NOP, then set DMA control, and 		 * then we can start the DMA. 		 */
name|sc
operator|->
name|sc_state
operator|=
name|newstate
expr_stmt|;
name|i
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_resid
argument_list|,
name|ESPMAX
argument_list|)
expr_stmt|;
name|i
operator|=
name|min
argument_list|(
name|i
argument_list|,
name|DMAMAX
argument_list|(
name|sc
operator|->
name|sc_dmaaddr
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dmasize
operator|=
name|i
expr_stmt|;
name|dma
operator|->
name|dma_addr
operator|=
name|sc
operator|->
name|sc_dmaaddr
expr_stmt|;
name|esp
operator|->
name|esp_tch
operator|=
name|i
operator|>>
literal|8
expr_stmt|;
name|esp
operator|->
name|esp_tcl
operator|=
name|i
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_DMA
operator||
name|ESPCMD_NOP
expr_stmt|;
name|dma
operator|->
name|dma_csr
operator|=
name|sc
operator|->
name|sc_dmactl
expr_stmt|;
name|sc
operator|->
name|sc_dmaactive
operator|=
literal|1
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_DMA
operator||
name|ESPCMD_XFER_INFO
expr_stmt|;
return|return
operator|(
name|ACT_IO
operator|)
return|;
case|case
name|ESPPHASE_CMD
case|:
comment|/* 		 * Silly thing wants the command again. 		 * Load it into the FIFO and go to SVC state. 		 */
name|printf
argument_list|(
literal|"%s: redoing command\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|cdb
operator|=
name|sc
operator|->
name|sc_curcdb
expr_stmt|;
name|reg
operator|=
name|SCSICMDLEN
argument_list|(
name|cdb
operator|->
name|cdb_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg
condition|;
name|i
operator|++
control|)
name|esp
operator|->
name|esp_fifo
operator|=
name|cdb
operator|->
name|cdb_bytes
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_SVC
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_XFER_INFO
expr_stmt|;
return|return
operator|(
name|ACT_CONT
operator|)
return|;
case|case
name|ESPPHASE_STATUS
case|:
name|sc
operator|->
name|sc_state
operator|=
name|S_STAT
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_INIT_COMP
expr_stmt|;
return|return
operator|(
name|ACT_CONT
operator|)
return|;
case|case
name|ESPPHASE_MSG_IN
case|:
name|printf
argument_list|(
literal|"%s: accepting (& ignoring) msg from target %d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_MI
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_MSG_ACCEPT
expr_stmt|;
return|return
operator|(
name|ACT_CONT
operator|)
return|;
default|default:
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"bad phase"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Clear out target state by doing a special TEST UNIT READY.  * Note that this calls espicmd (possibly recursively).  */
end_comment

begin_function
name|void
name|espclear
parameter_list|(
name|sc
parameter_list|,
name|targ
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|targ
decl_stmt|;
block|{
comment|/* turn off needclear immediately since this calls espicmd() again */
name|sc
operator|->
name|sc_needclear
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|targ
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_clearing
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|scsi_test_unit_ready
argument_list|(
operator|&
name|sc
operator|->
name|sc_hba
argument_list|,
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_clearing
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * THIS SHOULD BE ADJUSTABLE  */
end_comment

begin_comment
comment|/* name		howlong		purpose */
end_comment

begin_define
define|#
directive|define
name|SELECT_WAIT
value|300000
end_define

begin_comment
comment|/* wait for select to complete */
end_comment

begin_define
define|#
directive|define
name|CMD_WAIT
value|100000
end_define

begin_comment
comment|/* wait for next phase, generic */
end_comment

begin_define
define|#
directive|define
name|DATA_WAIT
value|100000
end_define

begin_comment
comment|/* time to xfer data in/out */
end_comment

begin_comment
comment|/*  * Send an `immediate' command, i.e., poll until the whole thing is done.  * Return the status byte from the device, or -1 if we timed out.  We use  * DMA to transfer the data as the fifo only moves one byte at a time.  */
end_comment

begin_function
name|int
name|espicmd
parameter_list|(
name|hba
parameter_list|,
name|targ
parameter_list|,
name|cdb
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|rw
parameter_list|)
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
name|int
name|targ
decl_stmt|;
name|struct
name|scsi_cdb
modifier|*
name|cdb
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|,
name|rw
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|hba
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
init|=
name|sc
operator|->
name|sc_esp
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|wait
decl_stmt|;
comment|/* 	 * Clear the target if necessary. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_needclear
operator|&
operator|(
literal|1
operator|<<
name|targ
operator|)
operator|&&
operator|!
name|sc
operator|->
name|sc_probing
condition|)
name|espclear
argument_list|(
name|sc
argument_list|,
name|targ
argument_list|)
expr_stmt|;
comment|/* 	 * Set up DMA transfer control (leaving interrupts disabled). 	 */
name|sc
operator|->
name|sc_dmactl
operator|=
name|rw
operator|&
name|B_READ
condition|?
name|DMA_ENA
operator||
name|DMA_READ
else|:
name|DMA_ENA
expr_stmt|;
name|sc
operator|->
name|sc_dmaaddr
operator|=
operator|(
name|u_long
operator|)
name|buf
expr_stmt|;
name|sc
operator|->
name|sc_resid
operator|=
name|len
expr_stmt|;
comment|/* 	 * Disable hardware interrupts and start select sequence, 	 * then loop, calling espact() after each ``interrupt''. 	 */
name|DMAWAIT
argument_list|(
name|dma
argument_list|)
expr_stmt|;
comment|/* ??? */
name|dma
operator|->
name|dma_csr
operator|=
literal|0
expr_stmt|;
name|espselect
argument_list|(
name|sc
argument_list|,
name|targ
argument_list|,
name|cdb
argument_list|)
expr_stmt|;
name|wait
operator|=
name|SELECT_WAIT
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|dma
operator|->
name|dma_csr
expr_stmt|;
if|if
condition|(
operator|!
name|DMA_INTR
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
operator|--
name|wait
operator|<
literal|0
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"timeout"
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_espstat
operator|=
name|esp
operator|->
name|esp_stat
expr_stmt|;
name|sc
operator|->
name|sc_espstep
operator|=
name|esp
operator|->
name|esp_step
operator|&
name|ESPSTEP_MASK
expr_stmt|;
name|sc
operator|->
name|sc_espintr
operator|=
name|esp
operator|->
name|esp_intr
expr_stmt|;
name|sc
operator|->
name|sc_espfflags
operator|=
name|esp
operator|->
name|esp_fflags
expr_stmt|;
name|sc
operator|->
name|sc_dmacsr
operator|=
name|r
expr_stmt|;
switch|switch
condition|(
name|r
operator|=
name|espact
argument_list|(
name|sc
argument_list|)
condition|)
block|{
case|case
name|ACT_CONT
case|:
case|case
name|ACT_QUICKINTR
case|:
name|wait
operator|=
name|CMD_WAIT
expr_stmt|;
break|break;
case|case
name|ACT_IO
case|:
name|wait
operator|=
name|DATA_WAIT
expr_stmt|;
break|break;
case|case
name|ACT_RESET
case|:
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
goto|goto
name|reset
goto|;
case|case
name|ACT_DONE
case|:
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_stat
index|[
literal|0
index|]
operator|)
return|;
case|case
name|ACT_ERROR
case|:
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"espicmd action"
argument_list|)
expr_stmt|;
block|}
block|}
name|reset
label|:
name|espreset
argument_list|(
name|sc
argument_list|,
name|RESET_ESPCHIP
argument_list|)
expr_stmt|;
comment|/* ??? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump (write memory, possibly physmem).  * SPARC higher-level dump code always provides virtual addresses,  * so we need not do any I/O mapping here.  */
end_comment

begin_function
name|int
name|espdump
parameter_list|(
name|hba
parameter_list|,
name|targ
parameter_list|,
name|cdb
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
specifier|register
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
name|int
name|targ
decl_stmt|;
name|struct
name|scsi_cdb
modifier|*
name|cdb
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
return|return
operator|(
name|espicmd
argument_list|(
name|hba
argument_list|,
name|targ
argument_list|,
name|cdb
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|B_WRITE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate resources (SCSI bus and DVMA space) for the given transfer.  * Must be called at splbio().  *  * THIS SHOULD RETURN SUCCESS/FAIL INDICATION  */
end_comment

begin_function
name|void
name|espstart
parameter_list|(
name|self
parameter_list|,
name|sq
parameter_list|,
name|bp
parameter_list|,
name|dgo
parameter_list|,
name|dev
parameter_list|)
name|struct
name|device
modifier|*
name|self
decl_stmt|;
specifier|register
name|struct
name|sq
modifier|*
name|sq
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|scdgo_fn
name|dgo
decl_stmt|;
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|self
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hba
operator|.
name|hba_busy
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Bus not busy, nothing to do here, just tell 		 * this target or unit that it has the SCSI bus. 		 */
name|sc
operator|->
name|sc_hba
operator|.
name|hba_busy
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|dgo
call|)
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdbspace
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Bus is busy; just enqueue. 		 */
name|sq
operator|->
name|sq_dgo
operator|=
name|dgo
expr_stmt|;
name|sq
operator|->
name|sq_dev
operator|=
name|dev
expr_stmt|;
name|sq
operator|->
name|sq_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hba
operator|.
name|hba_head
operator|==
name|NULL
condition|)
name|sc
operator|->
name|sc_hba
operator|.
name|hba_head
operator|=
name|sq
expr_stmt|;
else|else
name|sc
operator|->
name|sc_hba
operator|.
name|hba_tail
operator|->
name|sq_forw
operator|=
name|sq
expr_stmt|;
name|sc
operator|->
name|sc_hba
operator|.
name|hba_tail
operator|=
name|sq
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start buffered I/O.  * Return 0 on success, 1 on failure.  */
end_comment

begin_function
name|int
name|espgo
parameter_list|(
name|self
parameter_list|,
name|targ
parameter_list|,
name|intr
parameter_list|,
name|dev
parameter_list|,
name|bp
parameter_list|,
name|pad
parameter_list|)
name|struct
name|device
modifier|*
name|self
decl_stmt|;
name|int
name|targ
decl_stmt|;
name|scintr_fn
name|intr
decl_stmt|;
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|pad
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|self
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_needclear
operator|&
operator|(
literal|1
operator|<<
name|targ
operator|)
condition|)
name|espclear
argument_list|(
name|sc
argument_list|,
name|targ
argument_list|)
expr_stmt|;
comment|/* Set up dma control for espact(). */
name|sc
operator|->
name|sc_dmactl
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
name|DMA_ENA
operator||
name|DMA_READ
operator||
name|DMA_IE
else|:
name|DMA_ENA
operator||
name|DMA_IE
expr_stmt|;
name|sc
operator|->
name|sc_dmaaddr
operator|=
operator|(
name|u_long
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|sc
operator|->
name|sc_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
comment|/* 	 * Enable interrupts and start selection. 	 * The rest is done in espintr() and espact(). 	 */
name|sc
operator|->
name|sc_hba
operator|.
name|hba_intr
operator|=
name|intr
expr_stmt|;
comment|/* remember dev done function */
name|sc
operator|->
name|sc_hba
operator|.
name|hba_intrdev
operator|=
name|dev
expr_stmt|;
comment|/* and its first arg */
name|sc
operator|->
name|sc_dma
operator|->
name|dma_csr
operator|=
name|DMA_IE
expr_stmt|;
name|espselect
argument_list|(
name|sc
argument_list|,
name|targ
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdbspace
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle interrupt.  Return 1 if taken.  */
end_comment

begin_function
name|int
name|espintr
parameter_list|(
name|sc0
parameter_list|)
name|void
modifier|*
name|sc0
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|sc0
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
init|=
name|sc
operator|->
name|sc_esp
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|wait
decl_stmt|;
specifier|register
name|struct
name|sq
modifier|*
name|sq
decl_stmt|;
name|r
operator|=
name|dma
operator|->
name|dma_csr
expr_stmt|;
if|if
condition|(
operator|!
name|DMA_INTR
argument_list|(
name|r
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not ours */
name|sc
operator|->
name|sc_intrcnt
operator|.
name|ev_count
operator|++
expr_stmt|;
name|again
label|:
name|sc
operator|->
name|sc_espstat
operator|=
name|esp
operator|->
name|esp_stat
expr_stmt|;
name|sc
operator|->
name|sc_espstep
operator|=
name|esp
operator|->
name|esp_step
operator|&
name|ESPSTEP_MASK
expr_stmt|;
name|sc
operator|->
name|sc_espintr
operator|=
name|esp
operator|->
name|esp_intr
expr_stmt|;
name|sc
operator|->
name|sc_espfflags
operator|=
name|esp
operator|->
name|esp_fflags
expr_stmt|;
name|sc
operator|->
name|sc_dmacsr
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|S_IDLE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: stray interrupt\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
comment|/* ??? */
return|return
operator|(
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|r
operator|=
name|espact
argument_list|(
name|sc
argument_list|)
condition|)
block|{
case|case
name|ACT_CONT
case|:
comment|/* just return */
case|case
name|ACT_IO
case|:
break|break;
case|case
name|ACT_RESET
case|:
comment|/* please reset esp */
name|reset
label|:
name|espreset
argument_list|(
name|sc
argument_list|,
name|RESET_ESPCHIP
argument_list|)
expr_stmt|;
comment|/* ??? */
comment|/* FALLTHROUGH */
case|case
name|ACT_DONE
case|:
comment|/* this one is done, successfully */
case|case
name|ACT_ERROR
case|:
comment|/* this one is done due to `severe' error */
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_hba
operator|.
name|hba_busy
condition|)
name|panic
argument_list|(
literal|"espintr sq"
argument_list|)
expr_stmt|;
comment|/* 		 * This transaction is done. 		 * Call the driver's intr routine, 		 * then start the next guy if any. 		 */
call|(
modifier|*
name|sc
operator|->
name|sc_hba
operator|.
name|hba_intr
call|)
argument_list|(
name|sc
operator|->
name|sc_hba
operator|.
name|hba_intrdev
argument_list|,
name|r
operator|==
name|ACT_DONE
condition|?
name|sc
operator|->
name|sc_stat
index|[
literal|0
index|]
else|:
operator|-
literal|1
argument_list|,
name|sc
operator|->
name|sc_resid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sq
operator|=
name|sc
operator|->
name|sc_hba
operator|.
name|hba_head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_hba
operator|.
name|hba_head
operator|=
name|sq
operator|->
name|sq_forw
expr_stmt|;
call|(
modifier|*
name|sq
operator|->
name|sq_dgo
call|)
argument_list|(
name|sq
operator|->
name|sq_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdbspace
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_hba
operator|.
name|hba_busy
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ACT_QUICKINTR
case|:
comment|/* wait a short while for another interrupt */
name|printf
argument_list|(
literal|"%s: quickintr: "
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|wait
operator|=
literal|100
expr_stmt|;
do|do
block|{
name|r
operator|=
name|dma
operator|->
name|dma_csr
expr_stmt|;
if|if
condition|(
name|DMA_INTR
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"got one, wait=%d\n"
argument_list|,
name|wait
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
do|while
condition|(
operator|--
name|wait
operator|>
literal|0
condition|)
do|;
name|printf
argument_list|(
literal|"did not get one\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"espintr action"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Target or unit decided to let go of the bus early.  */
end_comment

begin_function
name|void
name|esprel
parameter_list|(
name|self
parameter_list|)
name|struct
name|device
modifier|*
name|self
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|sq
modifier|*
name|sq
decl_stmt|;
comment|/* if there is someone else waiting, give them a crack at it */
if|if
condition|(
operator|(
name|sq
operator|=
name|sc
operator|->
name|sc_hba
operator|.
name|hba_head
operator|)
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sq
operator|->
name|sq_dgo
call|)
argument_list|(
name|sq
operator|->
name|sq_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdbspace
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|sc_hba
operator|.
name|hba_busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

