begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)esp.c	8.1 (Berkeley) %G%  *  * from: $Header: esp.c,v 1.28 93/04/27 14:40:44 torek Exp $ (LBL)  *  * Loosely derived from Mary Baker's devSCSIC90.c from the Berkeley  * Sprite project, which is:  *  * Copyright 1988 Regents of the University of California  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies.  The University of California  * makes no representations about the suitability of this  * software for any purpose.  It is provided "as is" without  * express or implied warranty.  *  * from /sprite/src/kernel/dev/sun4c.md/RCS/devSCSIC90.c,v 1.4  * 90/12/19 12:37:58 mgbaker Exp $ SPRITE (Berkeley)  */
end_comment

begin_comment
comment|/*  * Sbus ESP/DMA driver.  A single driver must be used for both devices  * as they are physically tied to each other:  The DMA chip can only  * be used to assist ESP SCSI transactions; the ESP interrupt enable is  * in the DMA chip csr.  *  * Since DMA and SCSI interrupts are handled in the same routine, the  * DMA device does not declare itself as an sbus device.  This saves  * some space.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/scsi.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/scsivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sbus/dmareg.h>
end_include

begin_define
define|#
directive|define
name|ESP_PHASE_NAMES
end_define

begin_include
include|#
directive|include
file|<sparc/sbus/espreg.h>
end_include

begin_include
include|#
directive|include
file|<sparc/sbus/sbusvar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|espdebug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This driver is organized as a collection of state machines.  The  * primary machine is the SCSI sequencer:  *  *	Given some previous SCSI state (as set up or tracked by us earlier)  *	and the interrupt registers provided on the chips (dmacsr, espstat,  *	espstep, and espintr), derive an action.  In many cases this is  *	just a matter of reading the target's phase and following its orders,  *	which sets a new state.  *  * This sequencing is done in espact(); the state is primed in espselect().  *  * There will be (update this comment when there is) another state machine  * used to handle transfers that fall afoul of chip limits (16 bit DMA  * counter; 24 bit address counter in 32 bit address field).  *  * Another state bit is used to recover from bus resets:  *  *	A single TEST UNIT READY is attempted on each target before any  *	real communication begins; this TEST UNIT READY is allowed to  *	fail in any way.  This is required for the Quantum ProDrive 100  *	MB disks, for instance, which respond to their first selection  *	with status phase, and for anything that insists on implementing  *	the broken SCSI-2 synch transfer initial message.  *  * This is done in espclear() (which calls espselect(); functions that  * call espselect() must check for clearing first).  *  * The state machines actually intermingle, as some SCSI sequences are  * only allowed during clearing.  */
end_comment

begin_comment
comment|/* per-DMA variables */
end_comment

begin_struct
struct|struct
name|dma_softc
block|{
name|struct
name|device
name|sc_dev
decl_stmt|;
comment|/* base device */
specifier|volatile
name|struct
name|dmareg
modifier|*
name|sc_dma
decl_stmt|;
comment|/* register virtual address */
name|int
name|sc_dmarev
decl_stmt|;
comment|/* revision */
name|char
modifier|*
name|sc_dmafmt
decl_stmt|;
comment|/* format for error messages */
block|}
struct|;
end_struct

begin_function_decl
name|void
name|dmaattach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfdriver
name|dmacd
init|=
block|{
name|NULL
block|,
literal|"dma"
block|,
name|matchbyname
block|,
name|dmaattach
block|,
name|DV_DULL
block|,
expr|sizeof
operator|(
expr|struct
name|dma_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per-ESP variables */
end_comment

begin_struct
struct|struct
name|esp_softc
block|{
comment|/* 	 * External interfaces. 	 */
name|struct
name|hba_softc
name|sc_hba
decl_stmt|;
comment|/* base device + hba, must be first */
name|struct
name|sbusdev
name|sc_sd
decl_stmt|;
comment|/* sbus device */
name|struct
name|intrhand
name|sc_ih
decl_stmt|;
comment|/* interrupt entry */
name|struct
name|evcnt
name|sc_intrcnt
decl_stmt|;
comment|/* interrupt counter */
name|struct
name|dma_softc
modifier|*
name|sc_dsc
decl_stmt|;
comment|/* pointer to corresponding dma sc */
comment|/* 	 * Addresses mapped to hardware registers. 	 */
specifier|volatile
name|struct
name|espreg
modifier|*
name|sc_esp
decl_stmt|;
specifier|volatile
name|struct
name|dmareg
modifier|*
name|sc_dma
decl_stmt|;
comment|/* 	 * Copies of registers cleared/unlatched by reading. 	 */
name|u_long
name|sc_dmacsr
decl_stmt|;
name|u_char
name|sc_espstat
decl_stmt|;
name|u_char
name|sc_espstep
decl_stmt|;
name|u_char
name|sc_espintr
decl_stmt|;
comment|/* miscellaneous */
name|int
name|sc_clockfreq
decl_stmt|;
comment|/* clock frequency */
name|u_char
name|sc_sel_timeout
decl_stmt|;
comment|/* select timeout */
name|u_char
name|sc_id
decl_stmt|;
comment|/* initiator ID (default = 7) */
name|u_char
name|sc_needclear
decl_stmt|;
comment|/* uncleared targets (1 bit each) */
name|u_char
name|sc_esptype
decl_stmt|;
comment|/* 100, 100A, 2xx (see below) */
name|u_char
name|sc_ccf
decl_stmt|;
comment|/* clock conversion factor */
name|u_char
name|sc_conf1
decl_stmt|;
comment|/* value for config reg 1 */
name|u_char
name|sc_conf2
decl_stmt|;
comment|/* value for config reg 2 */
name|u_char
name|sc_conf3
decl_stmt|;
comment|/* value for config reg 3 */
name|struct
name|bootpath
modifier|*
name|sc_bp
decl_stmt|;
comment|/* esp bootpath so far */
comment|/* 	 * Information pertaining to the current transfer, 	 * including sequencing. 	 * 	 * The size of sc_msg is the size of the ESP fifo, 	 * since we do message-in simply by allowing the fifo to fill. 	 */
name|char
name|sc_probing
decl_stmt|;
comment|/* used during autoconf; see below */
name|char
name|sc_clearing
decl_stmt|;
comment|/* true => cmd is just to clear targ */
name|char
name|sc_state
decl_stmt|;
comment|/* SCSI protocol state; see below */
name|char
name|sc_sentcmd
decl_stmt|;
comment|/* set once we get cmd out */
name|char
name|sc_dmaactive
decl_stmt|;
comment|/* true => doing dma */
ifdef|#
directive|ifdef
name|notyet
name|u_char
name|sc_sync
decl_stmt|;
comment|/* synchronous transfer stuff (?) */
endif|#
directive|endif
name|u_char
name|sc_stat
index|[
literal|2
index|]
decl_stmt|;
comment|/* status from last `status' phase */
name|u_char
name|sc_msg
index|[
literal|16
index|]
decl_stmt|;
comment|/* message from device */
name|u_short
name|sc_dmactl
decl_stmt|;
comment|/* control to load into dma csr */
name|u_long
name|sc_dmaaddr
decl_stmt|;
comment|/* addr to load into dma addr */
name|int
name|sc_targ
decl_stmt|;
comment|/* the target involved */
name|int
name|sc_resid
decl_stmt|;
comment|/* count of bytes not xferred */
name|struct
name|scsi_cdb
name|sc_cdb
decl_stmt|;
comment|/* current command (not in dvma) */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Values for sc_esptype (used to control configuration reset).  * The order is important; see espreset().  */
end_comment

begin_define
define|#
directive|define
name|ESP100
value|0
end_define

begin_define
define|#
directive|define
name|ESP100A
value|1
end_define

begin_define
define|#
directive|define
name|ESP2XX
value|2
end_define

begin_comment
comment|/*  * Probe state.  0 means not probing.  While looking for each target  * we set this to PROBE_TESTING and do a TEST UNIT READY on unit 0.  * If selection fails, this is changed to PROBE_NO_TARGET; otherwise  * we assume the target exists, regardless of the result of the test.  */
end_comment

begin_define
define|#
directive|define
name|PROBE_TESTING
value|1
end_define

begin_define
define|#
directive|define
name|PROBE_NO_TARGET
value|2
end_define

begin_comment
comment|/*  * States in sc_state.  *  * Note that S_CMDSVC is rare: normally we load the SCSI command into the  * ESP fifo and get interrupted only when the device has gone to data  * or status phase.  If the device wants to play games, though, we end  * up doing things differently.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|espstates
index|[]
init|=
block|{
define|#
directive|define
name|S_IDLE
value|0
comment|/* not doing anything */
literal|"idle"
block|,
define|#
directive|define
name|S_SEL
value|1
comment|/* expecting select done interrupt */
literal|"selecting"
block|,
define|#
directive|define
name|S_CMDSVC
value|2
comment|/* expecting service req interrupt */
literal|"waiting for service request after command"
block|,
define|#
directive|define
name|S_IOSVC
value|3
comment|/* expecting service req interrupt */
literal|"waiting for service request after io"
block|,
define|#
directive|define
name|S_DI
value|4
comment|/* expecting data-in done interrupt */
literal|"receiving data"
block|,
define|#
directive|define
name|S_DO
value|5
comment|/* expecting data-out done interrupt */
literal|"sending data"
block|,
define|#
directive|define
name|S_STAT
value|6
comment|/* expecting status done interrupt */
literal|"receiving status"
block|,
define|#
directive|define
name|S_MI
value|7
comment|/* expecting message-in done interrupt */
literal|"receiving message"
block|,
define|#
directive|define
name|S_FI
value|8
comment|/* expecting final disconnect interrupt */
literal|"waiting for disconnect"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return values from espact().  */
end_comment

begin_define
define|#
directive|define
name|ACT_CONT
value|0
end_define

begin_comment
comment|/* espact() handled everything */
end_comment

begin_define
define|#
directive|define
name|ACT_READ
value|1
end_define

begin_comment
comment|/* target said it is sending us data */
end_comment

begin_define
define|#
directive|define
name|ACT_WRITE
value|2
end_define

begin_comment
comment|/* target said it is expecting data */
end_comment

begin_define
define|#
directive|define
name|ACT_DONE
value|3
end_define

begin_comment
comment|/* handled everything, and op is now done */
end_comment

begin_define
define|#
directive|define
name|ACT_ERROR
value|4
end_define

begin_comment
comment|/* an error occurred, op has been trashed */
end_comment

begin_define
define|#
directive|define
name|ACT_RESET
value|5
end_define

begin_comment
comment|/* please reset ESP, then do ACT_ERROR */
end_comment

begin_define
define|#
directive|define
name|ACT_QUICKINTR
value|6
end_define

begin_comment
comment|/* another interrupt is expected immediately */
end_comment

begin_comment
comment|/* autoconfiguration driver */
end_comment

begin_function_decl
name|void
name|espattach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfdriver
name|espcd
init|=
block|{
name|NULL
block|,
literal|"esp"
block|,
name|matchbyname
block|,
name|espattach
block|,
name|DV_DULL
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|esp_softc
argument_list|)
block|,
literal|"intr"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sbus driver */
end_comment

begin_function_decl
name|void
name|espsbreset
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* interrupt interface */
end_comment

begin_function_decl
name|int
name|espintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* SCSI HBA driver */
end_comment

begin_function_decl
name|int
name|espicmd
parameter_list|(
name|struct
name|hba_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|scsi_cdb
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|espdump
parameter_list|(
name|struct
name|hba_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|scsi_cdb
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|espstart
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|sq
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|scdgo_fn
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|espgo
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|int
parameter_list|,
name|scintr_fn
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|esprel
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|esphbareset
parameter_list|(
name|struct
name|hba_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|hbadriver
name|esphbadriver
init|=
block|{
name|espicmd
block|,
name|espdump
block|,
name|espstart
block|,
name|espgo
block|,
name|esprel
block|,
name|esphbareset
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward declarations */
end_comment

begin_function_decl
specifier|static
name|void
name|espdoattach
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|espreset
parameter_list|(
name|struct
name|esp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The transfer size is limited to 16 bits since the scsi ctrl transfer  * counter is only 2 bytes.  A 0 value means the biggest transfer size  * (2 ** 16) == 64k.  */
end_comment

begin_define
define|#
directive|define
name|MAX_TRANSFER_SIZE
value|(64 * 1024)
end_define

begin_comment
comment|/* Return true if this transfer will cross a dma boundary */
end_comment

begin_define
define|#
directive|define
name|CROSS_DMA
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|)
define|\
value|(((int)(addr)& 0xff000000) != (((int)(addr) + (len) - 1)& 0xff000000))
end_define

begin_comment
comment|/*  * Attach a found DMA chip.  * The second argument is really a pointer to an sbus_attach_args.  */
end_comment

begin_function
name|void
name|dmaattach
parameter_list|(
name|parent
parameter_list|,
name|dev
parameter_list|,
name|args
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
name|void
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|struct
name|dma_softc
modifier|*
name|dsc
init|=
operator|(
expr|struct
name|dma_softc
operator|*
operator|)
name|dev
decl_stmt|;
specifier|register
name|struct
name|sbus_attach_args
modifier|*
name|sa
init|=
name|args
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dma
decl_stmt|;
specifier|register
name|int
name|rev
decl_stmt|;
name|struct
name|esp_softc
modifier|*
name|esc
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_ra
operator|.
name|ra_vaddr
condition|)
name|dma
operator|=
operator|(
specifier|volatile
expr|struct
name|dmareg
operator|*
operator|)
name|sa
operator|->
name|sa_ra
operator|.
name|ra_vaddr
expr_stmt|;
else|else
name|dma
operator|=
operator|(
specifier|volatile
expr|struct
name|dmareg
operator|*
operator|)
name|mapiodev
argument_list|(
name|sa
operator|->
name|sa_ra
operator|.
name|ra_paddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dmareg
argument_list|)
argument_list|)
expr_stmt|;
name|dsc
operator|->
name|sc_dma
operator|=
name|dma
expr_stmt|;
switch|switch
condition|(
name|rev
operator|=
name|DMA_REV
argument_list|(
name|dma
operator|->
name|dma_csr
argument_list|)
condition|)
block|{
case|case
name|DMAREV_1
case|:
name|printf
argument_list|(
literal|": rev 1\n"
argument_list|)
expr_stmt|;
name|dsc
operator|->
name|sc_dmafmt
operator|=
name|DMA_REV1_BITS
expr_stmt|;
break|break;
case|case
name|DMAREV_2
case|:
name|printf
argument_list|(
literal|": rev 2\n"
argument_list|)
expr_stmt|;
name|dsc
operator|->
name|sc_dmafmt
operator|=
name|DMA_REV2_BITS
expr_stmt|;
break|break;
case|case
name|DMAREV_3
case|:
name|printf
argument_list|(
literal|": rev 3\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"WARNING: esp.c not yet updated for rev 3\n"
argument_list|)
expr_stmt|;
name|dsc
operator|->
name|sc_dmafmt
operator|=
name|DMA_REV3_BITS
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|": unknown revision code 0x%x\n"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|dsc
operator|->
name|sc_dmafmt
operator|=
name|DMA_REV3_BITS
expr_stmt|;
comment|/* cross fingers */
break|break;
block|}
name|dsc
operator|->
name|sc_dmarev
operator|=
name|rev
expr_stmt|;
name|espdoattach
argument_list|(
name|dsc
operator|->
name|sc_dev
operator|.
name|dv_unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach a found ESP chip.  Search for targets; attach each one found.  * The latter must be deferred if the corresponding dma chip has not yet  * been configured.  */
end_comment

begin_function
name|void
name|espattach
parameter_list|(
name|parent
parameter_list|,
name|self
parameter_list|,
name|args
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|struct
name|device
modifier|*
name|self
decl_stmt|;
name|void
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|sbus_attach_args
modifier|*
name|sa
init|=
name|args
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
decl_stmt|;
specifier|register
name|struct
name|bootpath
modifier|*
name|bp
decl_stmt|;
name|struct
name|dma_softc
modifier|*
name|dsc
decl_stmt|;
name|int
name|node
decl_stmt|,
name|pri
decl_stmt|,
name|freq
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_ra
operator|.
name|ra_nintr
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|": expected 1 interrupt, got %d\n"
argument_list|,
name|sa
operator|->
name|sa_ra
operator|.
name|ra_nintr
argument_list|)
expr_stmt|;
return|return;
block|}
name|pri
operator|=
name|sa
operator|->
name|sa_ra
operator|.
name|ra_intr
index|[
literal|0
index|]
operator|.
name|int_pri
expr_stmt|;
name|printf
argument_list|(
literal|" pri %d"
argument_list|,
name|pri
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_ra
operator|.
name|ra_vaddr
condition|)
name|esp
operator|=
operator|(
specifier|volatile
expr|struct
name|espreg
operator|*
operator|)
name|sa
operator|->
name|sa_ra
operator|.
name|ra_vaddr
expr_stmt|;
else|else
name|esp
operator|=
operator|(
specifier|volatile
expr|struct
name|espreg
operator|*
operator|)
name|mapiodev
argument_list|(
name|sa
operator|->
name|sa_ra
operator|.
name|ra_paddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|espreg
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_esp
operator|=
name|esp
expr_stmt|;
name|node
operator|=
name|sa
operator|->
name|sa_ra
operator|.
name|ra_node
expr_stmt|;
name|sc
operator|->
name|sc_id
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"initiator-id"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|freq
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"clock-frequency"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|0
condition|)
name|freq
operator|=
operator|(
operator|(
expr|struct
name|sbus_softc
operator|*
operator|)
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
operator|.
name|dv_parent
operator|)
operator|->
name|sc_clockfreq
expr_stmt|;
comment|/* MIGHT NEED TO RESET ESP CHIP HERE ...? */
comment|/* 	 * Find out whether we have a -100, -100A, or -2xx, 	 * and what speed it runs at. 	 */
name|sc
operator|->
name|sc_conf1
operator|=
name|sc
operator|->
name|sc_id
operator||
name|ESPCONF1_PARENB
expr_stmt|;
comment|/* sc->sc_conf2 = 0; */
comment|/* sc->sc_conf3 = 0; */
name|esp
operator|->
name|esp_conf1
operator|=
name|sc
operator|->
name|sc_conf1
expr_stmt|;
name|esp
operator|->
name|esp_conf2
operator|=
literal|0
expr_stmt|;
name|esp
operator|->
name|esp_conf2
operator|=
name|ESPCONF2_SCSI2
operator||
name|ESPCONF2_RPE
expr_stmt|;
if|if
condition|(
operator|(
name|esp
operator|->
name|esp_conf2
operator|&
operator|~
name|ESPCONF2_RSVD
operator|)
operator|!=
operator|(
name|ESPCONF2_SCSI2
operator||
name|ESPCONF2_RPE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|": ESP100"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_esptype
operator|=
name|ESP100
expr_stmt|;
block|}
else|else
block|{
name|esp
operator|->
name|esp_conf2
operator|=
literal|0
expr_stmt|;
name|esp
operator|->
name|esp_conf3
operator|=
literal|0
expr_stmt|;
name|esp
operator|->
name|esp_conf3
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|esp
operator|->
name|esp_conf3
operator|!=
literal|5
condition|)
block|{
comment|/* XXX def bits */
name|printf
argument_list|(
literal|": ESP100A"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_esptype
operator|=
name|ESP100A
expr_stmt|;
block|}
else|else
block|{
name|esp
operator|->
name|esp_conf3
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|": ESP2XX"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_esptype
operator|=
name|ESP2XX
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|", clock = %s MHz, ID = %d\n"
argument_list|,
name|clockfreq
argument_list|(
name|freq
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
comment|/* 	 * Set clock conversion factor and select timeout. 	 * N.B.: clock frequency is not actually used in the rest 	 * of the driver; I calculate it here for completeness only 	 * (so I can see it when debugging). 	 */
name|sc
operator|->
name|sc_clockfreq
operator|=
name|freq
expr_stmt|;
name|freq
operator|=
name|howmany
argument_list|(
name|freq
argument_list|,
literal|1000
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* convert to MHz */
name|t
operator|=
name|ESPCCF_FROMMHZ
argument_list|(
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|ESPCCF_MIN
condition|)
name|t
operator|=
name|ESPCCF_MIN
expr_stmt|;
name|sc
operator|->
name|sc_ccf
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|ESPTIMO_REGVAL
argument_list|(
literal|250
argument_list|,
name|t
argument_list|,
name|freq
argument_list|)
expr_stmt|;
comment|/* timeout = 250 ms. */
if|if
condition|(
name|t
operator|>=
literal|256
condition|)
name|t
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_sel_timeout
operator|=
name|t
expr_stmt|;
comment|/* 	 * Link into sbus; set interrupt handler. 	 */
name|sc
operator|->
name|sc_sd
operator|.
name|sd_reset
operator|=
name|espsbreset
expr_stmt|;
name|sbus_establish
argument_list|(
operator|&
name|sc
operator|->
name|sc_sd
argument_list|,
operator|&
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ih
operator|.
name|ih_fun
operator|=
name|espintr
expr_stmt|;
name|sc
operator|->
name|sc_ih
operator|.
name|ih_arg
operator|=
name|sc
expr_stmt|;
name|intr_establish
argument_list|(
name|pri
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|evcnt_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
argument_list|,
literal|"intr"
argument_list|,
operator|&
name|sc
operator|->
name|sc_intrcnt
argument_list|)
expr_stmt|;
define|#
directive|define
name|SAME_ESP
parameter_list|(
name|bp
parameter_list|,
name|sa
parameter_list|)
define|\
value|((bp->val[0] == sa->sa_slot&& bp->val[1] == sa->sa_offset) || \ 	 (bp->val[0] == -1&& bp->val[1] == sc->sc_hba.hba_dev.dv_unit))
name|bp
operator|=
name|sa
operator|->
name|sa_ra
operator|.
name|ra_bp
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|bp
operator|->
name|name
argument_list|,
literal|"esp"
argument_list|)
operator|==
literal|0
operator|&&
name|SAME_ESP
argument_list|(
name|bp
argument_list|,
name|sa
argument_list|)
condition|)
name|sc
operator|->
name|sc_bp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|espdoattach
argument_list|(
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
operator|.
name|dv_unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * `Final' attach of esp occurs once esp and dma chips have been found  * and assigned virtual addresses.  Set up the ESP SCSI data structures  * and probe the SCSI bus.  */
end_comment

begin_function
specifier|static
name|void
name|espdoattach
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|dma_softc
modifier|*
name|dsc
decl_stmt|;
specifier|register
name|struct
name|bootpath
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|targ
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|targ
decl_stmt|,
name|u
decl_stmt|;
comment|/* make sure we have both */
if|if
condition|(
name|espcd
operator|.
name|cd_ndevs
operator|<=
name|unit
operator|||
name|dmacd
operator|.
name|cd_ndevs
operator|<=
name|unit
operator|||
operator|(
name|sc
operator|=
name|espcd
operator|.
name|cd_devs
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
operator|||
operator|(
name|dsc
operator|=
name|dmacd
operator|.
name|cd_devs
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|->
name|sc_dsc
operator|=
name|dsc
expr_stmt|;
name|sc
operator|->
name|sc_dma
operator|=
name|dsc
operator|->
name|sc_dma
expr_stmt|;
name|sc
operator|->
name|sc_hba
operator|.
name|hba_driver
operator|=
operator|&
name|esphbadriver
expr_stmt|;
name|espreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* MAYBE THIS SHOULD BE MOVED TO scsi_subr.c? */
for|for
control|(
name|targ
operator|=
literal|0
init|;
name|targ
operator|<
literal|8
condition|;
name|targ
operator|++
control|)
block|{
if|if
condition|(
name|targ
operator|==
name|sc
operator|->
name|sc_id
condition|)
continue|continue;
name|sc
operator|->
name|sc_probing
operator|=
name|PROBE_TESTING
expr_stmt|;
name|sc
operator|->
name|sc_clearing
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|scsi_test_unit_ready
argument_list|(
operator|&
name|sc
operator|->
name|sc_hba
argument_list|,
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_probing
operator|!=
name|PROBE_NO_TARGET
condition|)
block|{
name|sc
operator|->
name|sc_probing
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_clearing
operator|=
literal|0
expr_stmt|;
name|SCSI_FOUNDTARGET
argument_list|(
operator|&
name|sc
operator|->
name|sc_hba
argument_list|,
name|targ
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_probing
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_clearing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|sc
operator|->
name|sc_bp
operator|)
operator|==
name|NULL
operator|||
call|(
name|u_int
call|)
argument_list|(
name|targ
operator|=
name|bp
operator|->
name|val
index|[
literal|0
index|]
argument_list|)
operator|>=
literal|8
operator|||
call|(
name|u_int
call|)
argument_list|(
name|u
operator|=
name|bp
operator|->
name|val
index|[
literal|1
index|]
argument_list|)
operator|>=
literal|8
condition|)
return|return;
comment|/* 	 * Did we find it? We could compare bp->name against the unit's 	 * name but there's no real need since a target and unit 	 * uniquely specify a scsi device. 	 */
if|if
condition|(
operator|(
name|t
operator|=
name|sc
operator|->
name|sc_hba
operator|.
name|hba_targets
index|[
name|targ
index|]
operator|)
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|t_units
index|[
name|u
index|]
operator|!=
name|NULL
condition|)
name|bootdv
operator|=
name|t
operator|->
name|t_units
index|[
name|u
index|]
operator|->
name|u_dev
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Internal DMA reset.  */
end_comment

begin_function
specifier|static
name|void
name|dmareset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
comment|/* reset DMA chip */
name|dma
operator|->
name|dma_csr
operator||=
name|DMA_RESET
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_csr
operator|&=
operator|~
name|DMA_RESET
expr_stmt|;
comment|/* ??? */
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
name|sc
operator|->
name|sc_dmaactive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dsc
operator|->
name|sc_dmarev
operator|==
name|DMAREV_2
operator|&&
name|sc
operator|->
name|sc_esptype
operator|!=
name|ESP100
condition|)
name|dma
operator|->
name|dma_csr
operator||=
name|DMA_TURBO
expr_stmt|;
name|dma
operator|->
name|dma_csr
operator||=
name|DMA_IE
expr_stmt|;
comment|/* enable interrupts */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the chip.  N.B.: this causes a SCSI bus reset!  */
end_comment

begin_function
specifier|static
name|void
name|espreset
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
init|=
name|sc
operator|->
name|sc_esp
decl_stmt|;
name|dmareset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_RESET_CHIP
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_NOP
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* 	 * Reload configuration registers (cleared by RESET_CHIP command). 	 * Reloading conf2 on an ESP100 goofs it up, so out of paranoia 	 * we load only the registers that exist. 	 */
name|esp
operator|->
name|esp_conf1
operator|=
name|sc
operator|->
name|sc_conf1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_esptype
operator|>
name|ESP100
condition|)
block|{
comment|/* 100A, 2XX */
name|esp
operator|->
name|esp_conf2
operator|=
name|sc
operator|->
name|sc_conf2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_esptype
operator|>
name|ESP100A
condition|)
comment|/* 2XX only */
name|esp
operator|->
name|esp_conf3
operator|=
name|sc
operator|->
name|sc_conf3
expr_stmt|;
block|}
name|esp
operator|->
name|esp_ccf
operator|=
name|sc
operator|->
name|sc_ccf
expr_stmt|;
name|esp
operator|->
name|esp_timeout
operator|=
name|sc
operator|->
name|sc_sel_timeout
expr_stmt|;
comment|/* We set synch offset later. */
name|sc
operator|->
name|sc_needclear
operator|=
literal|0xff
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the SCSI bus and, optionally, all attached targets.  * The chip should retain most of its parameters (including esp_ccf)  * across this kind of reset (see section 3.5 of Emulex documentation).  */
end_comment

begin_function
name|void
name|esphbareset
parameter_list|(
name|hba
parameter_list|,
name|resetunits
parameter_list|)
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
name|int
name|resetunits
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|hba
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
init|=
name|sc
operator|->
name|sc_esp
decl_stmt|;
name|dmareset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* BEGIN ??? */
comment|/* turn off scsi bus reset interrupts and reset scsi bus */
name|esp
operator|->
name|esp_conf1
operator|=
name|sc
operator|->
name|sc_conf1
operator||
name|ESPCONF1_REPORT
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_RESET_BUS
expr_stmt|;
name|DELAY
argument_list|(
literal|800
argument_list|)
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_NOP
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|esp
operator|->
name|esp_conf1
operator|=
name|sc
operator|->
name|sc_conf1
expr_stmt|;
comment|/* END ??? */
name|sc
operator|->
name|sc_needclear
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|resetunits
condition|)
name|scsi_reset_units
argument_list|(
operator|&
name|sc
operator|->
name|sc_hba
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the esp, after an Sbus reset.  * Also resets corresponding dma chip.  *  * THIS ROUTINE MIGHT GO AWAY  */
end_comment

begin_function
name|void
name|espsbreset
parameter_list|(
name|dev
parameter_list|)
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
block|{
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|dev
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dsc
condition|)
block|{
name|printf
argument_list|(
literal|" %s %s"
argument_list|,
name|sc
operator|->
name|sc_dsc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|esphbareset
argument_list|(
operator|&
name|sc
operator|->
name|sc_hba
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|esperror
parameter_list|(
name|sc
parameter_list|,
name|err
parameter_list|)
name|char
modifier|*
name|err
decl_stmt|;
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s: %s (target=%d): stat=%b step=%x dmacsr=%b intr=%b\n"
argument_list|,
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
operator|.
name|dv_xname
argument_list|,
name|err
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|ESPSTAT_BITS
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|,
name|sc
operator|->
name|sc_dmacsr
argument_list|,
name|sc
operator|->
name|sc_dsc
operator|->
name|sc_dmafmt
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|ESPINTR_BITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * An interrupt has occurred.  Sequence through the SCSI state machine.  * Return the action to take.  *  * Most of the work happens here.  *  * There are three interrupt sources:  *   -- ESP interrupt request (typically, some device wants something).  *   -- DMA memory error.  *   -- DMA byte count has reached 0 (we do not often want this one but  *	can only turn it off in rev 2 DMA chips, it seems).  *	DOES THIS OCCUR AT ALL HERE?  THERE IS NOTHING TO HANDLE IT!  */
end_comment

begin_function
specifier|static
name|int
name|espact
parameter_list|(
name|sc
parameter_list|,
name|esp
parameter_list|,
name|dma
parameter_list|,
name|cdb
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dma
decl_stmt|;
specifier|register
name|struct
name|scsi_cdb
modifier|*
name|cdb
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|xname
init|=
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
operator|.
name|dv_xname
decl_stmt|;
specifier|register
name|int
name|reg
decl_stmt|,
name|phase
decl_stmt|,
name|i
decl_stmt|;
comment|/* check various error conditions, using as little code as possible */
if|if
condition|(
name|sc
operator|->
name|sc_dmacsr
operator|&
name|DMA_EP
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DMA error"
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_csr
operator||=
name|DMA_FLUSH
expr_stmt|;
return|return
operator|(
name|ACT_ERROR
operator|)
return|;
block|}
name|reg
operator|=
name|sc
operator|->
name|sc_espstat
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|ESPSTAT_GE
condition|)
block|{
comment|/* 		 * This often occurs when there is no target. 		 * (See DSC code below.) 		 */
if|if
condition|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_DSC
operator|&&
name|sc
operator|->
name|sc_state
operator|==
name|S_SEL
operator|&&
name|sc
operator|->
name|sc_probing
condition|)
block|{
name|sc
operator|->
name|sc_probing
operator|=
name|PROBE_NO_TARGET
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DIAGNOSTIC: gross error (ignored)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|ESPSTAT_PE
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"parity error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
name|reg
operator|=
name|sc
operator|->
name|sc_espintr
expr_stmt|;
define|#
directive|define
name|ERR
value|(ESPINTR_SBR|ESPINTR_ILC|ESPINTR_RSL|ESPINTR_SAT|ESPINTR_SEL)
if|if
condition|(
name|reg
operator|&
name|ERR
condition|)
block|{
if|if
condition|(
name|reg
operator|&
name|ESPINTR_SBR
condition|)
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"scsi bus reset"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|&
name|ESPINTR_ILC
condition|)
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"illegal command (driver bug)"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s: target %d"
argument_list|,
name|xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|ESPINTR_RSL
condition|)
name|printf
argument_list|(
literal|" tried to reselect;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|ESPINTR_SAT
condition|)
name|printf
argument_list|(
literal|" selected with ATN;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|ESPINTR_SEL
condition|)
name|printf
argument_list|(
literal|" selected us as target;"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"we do not allow this yet\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ACT_ERROR
operator|)
return|;
block|}
undef|#
directive|undef
name|ERR
comment|/* 	 * Disconnect currently only allowed in `final interrupt' states. 	 */
if|if
condition|(
name|reg
operator|&
name|ESPINTR_DSC
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|S_FI
condition|)
return|return
operator|(
name|ACT_DONE
operator|)
return|;
comment|/* 		 * If we were doing a select just to test the existence 		 * of the target, note that it did not respond; otherwise 		 * gripe. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|S_SEL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_probing
condition|)
block|{
name|sc
operator|->
name|sc_probing
operator|=
name|PROBE_NO_TARGET
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
block|}
comment|/* flush fifo, in case we were selecting or sending data */
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_FLUSH_FIFO
expr_stmt|;
name|printf
argument_list|(
literal|"%s: target %d not responding\n"
argument_list|,
name|xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_ERROR
operator|)
return|;
block|}
comment|/* 	 * Okay, things are moving along. 	 * What were we doing the last time we did something, 	 * and did it complete normally? 	 */
name|phase
operator|=
name|sc
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_PHASE
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|S_SEL
case|:
comment|/* 		 * We were selecting.  Arbitration and select are 		 * complete (because ESPINTR_DSC was not set), but 		 * there is no guarantee the command went out. 		 */
if|if
condition|(
operator|(
name|reg
operator|&
operator|(
name|ESPINTR_SVC
operator||
name|ESPINTR_CMP
operator|)
operator|)
operator|!=
operator|(
name|ESPINTR_SVC
operator||
name|ESPINTR_CMP
operator|)
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"selection failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_espstep
operator|==
name|ESPSTEP_DONE
condition|)
block|{
name|sc
operator|->
name|sc_sentcmd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_espstep
operator|==
literal|2
condition|)
block|{
comment|/* 			 * We got something other than command phase. 			 * Just pretend things are normal; the 			 * device will ask for the command later. 			 */
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DIAGNOSTIC: esp step 2"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_espstep
operator|==
literal|3
condition|)
block|{
comment|/* 			 * Device entered command phase and then exited it 			 * before we finished handing out the command. 			 * Let this happen iff we are trying to clear the 			 * target state. 			 */
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DIAGNOSTIC: esp step 3"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_clearing
condition|)
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: mysterious esp step %d\n"
argument_list|,
name|xname
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
comment|/* 		 * Part of the command may still be lodged in the FIFO. 		 */
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_FLUSH_FIFO
expr_stmt|;
break|break;
case|case
name|S_CMDSVC
case|:
comment|/* 		 * We were waiting for phase change after stuffing the command 		 * into the FIFO.  Make sure it got out. 		 */
name|reg
operator|=
name|ESP_NFIFO
argument_list|(
name|esp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DIAGNOSTIC: CMDSVC, fifo not empty"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tfifo count = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_FLUSH_FIFO
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_sentcmd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|S_IOSVC
case|:
comment|/* 		 * We were waiting for phase change after I/O. 		 */
break|break;
case|case
name|S_DI
case|:
comment|/* 		 * We were doing DMA data in, and expecting a 		 * transfer-count-zero interrupt or a phase change. 		 * We got that; drain the pack register and 		 * handle as for data out. 		 */
name|dma
operator|->
name|dma_csr
operator||=
name|DMA_DRAIN
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
comment|/* FIFO auto flushed? */
goto|goto
name|dma_data_done
goto|;
case|case
name|S_DO
case|:
comment|/* 		 * We were doing DMA data out.  If there is data in the 		 * FIFO, it is stuff that got DMAed out but never made 		 * it to the device, so it counts as residual. 		 * 		 * XXX	handle DMA IO with large count or address 		 *	boundary condition by resuming here, or below? 		 */
if|if
condition|(
operator|(
name|reg
operator|=
name|ESP_NFIFO
argument_list|(
name|esp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_FLUSH_FIFO
expr_stmt|;
name|dma_data_done
label|:
if|if
condition|(
name|sc
operator|->
name|sc_dmaactive
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: dma done while %s, dmaactive==0\n"
argument_list|,
name|xname
argument_list|,
name|espstates
index|[
name|sc
operator|->
name|sc_state
index|]
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"espact"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_dmaactive
operator|=
literal|0
expr_stmt|;
name|reg
operator|+=
name|esp
operator|->
name|esp_tcl
operator||
operator|(
name|esp
operator|->
name|esp_tch
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_TC
operator|)
operator|==
literal|0
condition|)
name|reg
operator|=
literal|65536
expr_stmt|;
if|if
condition|(
name|reg
operator|>
name|sc
operator|->
name|sc_resid
condition|)
block|{
name|printf
argument_list|(
literal|"%s: xfer resid (%d)> xfer req (%d)\n"
argument_list|,
name|xname
argument_list|,
name|reg
argument_list|,
name|sc
operator|->
name|sc_resid
argument_list|)
expr_stmt|;
name|reg
operator|=
name|sc
operator|->
name|sc_resid
expr_stmt|;
block|}
comment|/* 		 * If data came in we must flush cache. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|S_DI
condition|)
name|cache_flush
argument_list|(
name|sc
operator|->
name|sc_dmaaddr
argument_list|,
name|sc
operator|->
name|sc_resid
operator|-
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_resid
operator|=
name|reg
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_SVC
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no bus service req\n"
argument_list|,
name|xname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
break|break;
case|case
name|S_STAT
case|:
comment|/* 		 * The last thing we did was tell it `initiator complete' 		 * and so we expect to have gotten both the status byte 		 * and the final message byte.  It is possible that we 		 * got something else.... 		 * 		 * Apparently, BUS SERVICE is set if we got just status, 		 * while FUNCTION COMPLETE is set if we got both. 		 */
if|if
condition|(
operator|(
name|reg
operator|&
operator|(
name|ESPINTR_SVC
operator||
name|ESPINTR_CMP
operator|)
operator|)
operator|!=
name|ESPINTR_CMP
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"bad status interrupt state"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
name|reg
operator|=
name|ESP_NFIFO
argument_list|(
name|esp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command done but fifo count = %d; must be>= 2\n"
argument_list|,
name|xname
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
comment|/* 		 * Read the status and the first msg byte. 		 * It should be CMD_COMPLETE.  Eventually we 		 * may handle IDENTIFY, DISCONNECT, etc., as well. 		 */
name|sc
operator|->
name|sc_stat
index|[
literal|0
index|]
operator|=
name|esp
operator|->
name|esp_fifo
expr_stmt|;
name|sc
operator|->
name|sc_msg
index|[
literal|0
index|]
operator|=
name|reg
operator|=
name|esp
operator|->
name|esp_fifo
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_MSG_ACCEPT
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|MSG_CMD_COMPLETE
condition|)
block|{
name|sc
operator|->
name|sc_state
operator|=
name|S_FI
expr_stmt|;
return|return
operator|(
name|ACT_CONT
operator|)
return|;
block|}
if|if
condition|(
name|SCSIMSGLEN
argument_list|(
name|reg
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d is naughty\n"
argument_list|,
name|xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"%s: warning: target %d returned msg 0x%x\n"
argument_list|,
name|xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_FI
expr_stmt|;
return|return
operator|(
name|ACT_CONT
operator|)
return|;
case|case
name|S_MI
case|:
if|if
condition|(
operator|(
name|reg
operator|&
name|ESPINTR_SVC
operator|)
operator|==
literal|0
condition|)
block|{
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"missing phase after msg in"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
name|reg
operator|=
name|ESP_NFIFO
argument_list|(
name|esp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_msg
index|[
name|i
index|]
operator|=
name|esp
operator|->
name|esp_fifo
expr_stmt|;
break|break;
case|case
name|S_FI
case|:
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"target did not disconnect"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
comment|/* 	 * Things are still moving along.  The phase tells us 	 * what the device wants next.  Do it. 	 */
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
name|ESPPHASE_DATA_OUT
case|:
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_sentcmd
condition|)
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DIAGNOSTIC: data out without command"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_DO
expr_stmt|;
return|return
operator|(
name|ACT_WRITE
operator|)
return|;
case|case
name|ESPPHASE_DATA_IN
case|:
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_sentcmd
condition|)
name|esperror
argument_list|(
name|sc
argument_list|,
literal|"DIAGNOSTIC: data in without command"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_DI
expr_stmt|;
return|return
operator|(
name|ACT_READ
operator|)
return|;
case|case
name|ESPPHASE_CMD
case|:
comment|/* 		 * Silly thing wants the command again. 		 * Load it into the FIFO and go to CMDSVC state. 		 */
name|printf
argument_list|(
literal|"%s: redoing command\n"
argument_list|,
name|xname
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SCSICMDLEN
argument_list|(
name|cdb
operator|->
name|cdb_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg
condition|;
name|i
operator|++
control|)
name|esp
operator|->
name|esp_fifo
operator|=
name|cdb
operator|->
name|cdb_bytes
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_CMDSVC
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_XFER_INFO
expr_stmt|;
return|return
operator|(
name|ACT_CONT
operator|)
return|;
case|case
name|ESPPHASE_STATUS
case|:
name|sc
operator|->
name|sc_state
operator|=
name|S_STAT
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_INIT_COMP
expr_stmt|;
return|return
operator|(
name|ACT_CONT
operator|)
return|;
case|case
name|ESPPHASE_MSG_IN
case|:
name|printf
argument_list|(
literal|"%s: accepting (& ignoring) msg from target %d\n"
argument_list|,
name|xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_MI
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_MSG_ACCEPT
expr_stmt|;
return|return
operator|(
name|ACT_CONT
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"%s: target %d asked for strange phase (%s)\n"
argument_list|,
name|xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|,
name|espphases
index|[
name|phase
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACT_RESET
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Issue a select, loading command into the FIFO.  * Return nonzero on error, 0 if OK.  * Sets state to `selecting'; espact() will sequence state FSM.  */
end_comment

begin_function
name|void
name|espselect
parameter_list|(
name|sc
parameter_list|,
name|esp
parameter_list|,
name|targ
parameter_list|,
name|cdb
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
decl_stmt|;
specifier|register
name|int
name|targ
decl_stmt|;
specifier|register
name|struct
name|scsi_cdb
modifier|*
name|cdb
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|cmdlen
init|=
name|SCSICMDLEN
argument_list|(
name|cdb
operator|->
name|cdb_bytes
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_targ
operator|=
name|targ
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_SEL
expr_stmt|;
name|sc
operator|->
name|sc_sentcmd
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_stat
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* ??? */
name|sc
operator|->
name|sc_msg
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* ??? */
comment|/* 	 * Try to talk to target. 	 * Synch offset 0 => asynchronous transfer. 	 */
name|esp
operator|->
name|esp_id
operator|=
name|targ
expr_stmt|;
name|esp
operator|->
name|esp_syncoff
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Stuff the command bytes into the fifo. 	 * Select without attention since we do not do disconnect yet. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmdlen
condition|;
name|i
operator|++
control|)
name|esp
operator|->
name|esp_fifo
operator|=
name|cdb
operator|->
name|cdb_bytes
index|[
name|i
index|]
expr_stmt|;
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_SEL_NATN
expr_stmt|;
comment|/* the rest is done elsewhere */
block|}
end_function

begin_comment
comment|/*  * THIS SHOULD BE ADJUSTABLE  */
end_comment

begin_comment
comment|/* name		howlong		purpose */
end_comment

begin_define
define|#
directive|define
name|SELECT_WAIT
value|300000
end_define

begin_comment
comment|/* wait for select to complete */
end_comment

begin_define
define|#
directive|define
name|CMD_WAIT
value|1000
end_define

begin_comment
comment|/* wait for next phase, generic */
end_comment

begin_define
define|#
directive|define
name|IO_WAIT
value|1000000
end_define

begin_comment
comment|/* time to xfer data in/out */
end_comment

begin_define
define|#
directive|define
name|POSTDATA_WAIT
value|10000000
end_define

begin_comment
comment|/* wait for next phase, after dataio */
end_comment

begin_comment
comment|/*  * Transfer data out via polling.  Return success (0) iff all  * the bytes were sent and we got an interrupt.  *  * This returns -1 on timeout, resid count on early interrupt,  * but no one really cares....  */
end_comment

begin_function
specifier|static
name|int
name|espixfer_out
parameter_list|(
name|sc
parameter_list|,
name|esp
parameter_list|,
name|dma
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dma
decl_stmt|;
specifier|register
name|caddr_t
name|buf
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|wait
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|CROSS_DMA
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
condition|)
name|panic
argument_list|(
literal|"espixfer_out: 16MB boundary"
argument_list|)
expr_stmt|;
comment|/* set dma address and transfer count */
name|dma
operator|->
name|dma_addr
operator|=
operator|(
name|int
operator|)
name|buf
expr_stmt|;
name|esp
operator|->
name|esp_tch
operator|=
name|len
operator|>>
literal|8
expr_stmt|;
name|esp
operator|->
name|esp_tcl
operator|=
name|len
expr_stmt|;
comment|/* load count into counter via DMA NOP */
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_DMA
operator||
name|ESPCMD_NOP
expr_stmt|;
comment|/* enable dma (but not interrupts) */
name|dma
operator|->
name|dma_csr
operator|=
name|DMA_ENA
expr_stmt|;
comment|/* and go */
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_DMA
operator||
name|ESPCMD_XFER_INFO
expr_stmt|;
comment|/* wait for completion */
for|for
control|(
name|wait
operator|=
name|IO_WAIT
init|;
name|wait
operator|>
literal|0
condition|;
operator|--
name|wait
control|)
block|{
name|n
operator|=
name|dma
operator|->
name|dma_csr
expr_stmt|;
if|if
condition|(
name|DMA_INTR
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_espstat
operator|=
name|esp
operator|->
name|esp_stat
expr_stmt|;
name|sc
operator|->
name|sc_espstep
operator|=
name|esp
operator|->
name|esp_step
operator|&
name|ESPSTEP_MASK
expr_stmt|;
name|sc
operator|->
name|sc_espintr
operator|=
name|esp
operator|->
name|esp_intr
expr_stmt|;
name|sc
operator|->
name|sc_dmacsr
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|esp
operator|->
name|esp_tcl
operator||
operator|(
name|esp
operator|->
name|esp_tch
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_TC
operator|)
operator|==
literal|0
condition|)
name|n
operator|=
literal|65536
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transfer data in via polling.  * Return resid count on interrupt, -1 if timed out.  */
end_comment

begin_function
specifier|static
name|int
name|espixfer_in
parameter_list|(
name|sc
parameter_list|,
name|esp
parameter_list|,
name|dma
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dma
decl_stmt|;
specifier|register
name|caddr_t
name|buf
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|wait
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|CROSS_DMA
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
condition|)
name|panic
argument_list|(
literal|"espixfer_in: 16MB boundary"
argument_list|)
expr_stmt|;
comment|/* set dma address and transfer count */
name|dma
operator|->
name|dma_addr
operator|=
operator|(
name|int
operator|)
name|buf
expr_stmt|;
name|esp
operator|->
name|esp_tch
operator|=
name|len
operator|>>
literal|8
expr_stmt|;
name|esp
operator|->
name|esp_tcl
operator|=
name|len
expr_stmt|;
comment|/* load count into counter via DMA NOP */
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_DMA
operator||
name|ESPCMD_NOP
expr_stmt|;
comment|/* enable dma (but not interrupts) */
name|dma
operator|->
name|dma_csr
operator|=
name|DMA_ENA
operator||
name|DMA_READ
expr_stmt|;
comment|/* and go */
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_DMA
operator||
name|ESPCMD_XFER_INFO
expr_stmt|;
comment|/* wait for completion */
for|for
control|(
name|wait
operator|=
name|IO_WAIT
init|;
name|wait
operator|>
literal|0
condition|;
operator|--
name|wait
control|)
block|{
name|n
operator|=
name|dma
operator|->
name|dma_csr
expr_stmt|;
if|if
condition|(
name|DMA_INTR
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_espstat
operator|=
name|esp
operator|->
name|esp_stat
expr_stmt|;
name|sc
operator|->
name|sc_espstep
operator|=
name|esp
operator|->
name|esp_step
operator|&
name|ESPSTEP_MASK
expr_stmt|;
name|sc
operator|->
name|sc_espintr
operator|=
name|esp
operator|->
name|esp_intr
expr_stmt|;
name|dma
operator|->
name|dma_csr
operator||=
name|DMA_DRAIN
expr_stmt|;
name|sc
operator|->
name|sc_dmacsr
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|esp
operator|->
name|esp_tcl
operator||
operator|(
name|esp
operator|->
name|esp_tch
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_TC
operator|)
operator|==
literal|0
condition|)
name|n
operator|=
literal|65536
expr_stmt|;
name|cache_flush
argument_list|(
name|buf
argument_list|,
operator|(
name|u_int
operator|)
name|len
operator|-
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear out target state by doing a special TEST UNIT READY.  * Note that this calls espicmd (possibly recursively).  */
end_comment

begin_function
name|void
name|espclear
parameter_list|(
name|sc
parameter_list|,
name|targ
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|targ
decl_stmt|;
block|{
comment|/* turn off needclear immediately since this calls espicmd() again */
name|sc
operator|->
name|sc_needclear
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|targ
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_clearing
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|scsi_test_unit_ready
argument_list|(
operator|&
name|sc
operator|->
name|sc_hba
argument_list|,
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_clearing
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send an `immediate' command, i.e., poll until the whole thing is done.  * Return the status byte from the device, or -1 if we timed out.  */
end_comment

begin_function
name|int
name|espicmd
parameter_list|(
name|hba
parameter_list|,
name|targ
parameter_list|,
name|cdb
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|rw
parameter_list|)
specifier|register
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
name|int
name|targ
decl_stmt|;
specifier|register
name|struct
name|scsi_cdb
modifier|*
name|cdb
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|hba
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
init|=
name|sc
operator|->
name|sc_esp
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|wait
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|len
operator|>
name|MAX_TRANSFER_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad length %d\n"
argument_list|,
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
operator|.
name|dv_xname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"espicmd"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear the target if necessary. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_needclear
operator|&
operator|(
literal|1
operator|<<
name|targ
operator|)
operator|&&
operator|!
name|sc
operator|->
name|sc_probing
condition|)
name|espclear
argument_list|(
name|sc
argument_list|,
name|targ
argument_list|)
expr_stmt|;
comment|/* 	 * Disable hardware interrupts, start select sequence. 	 * Wait for interrupt-pending bit, then call espact() to 	 * sequence the state machine.  When it tells us to do 	 * data transfer, we do programmed I/O. 	 * In any case, we loop calling espact() until done. 	 */
name|dma
operator|->
name|dma_csr
operator|=
literal|0
expr_stmt|;
comment|/* disable hardware interrupts */
name|espselect
argument_list|(
name|sc
argument_list|,
name|esp
argument_list|,
name|targ
argument_list|,
name|cdb
argument_list|)
expr_stmt|;
name|wait
operator|=
name|SELECT_WAIT
expr_stmt|;
name|loop
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|dma
operator|->
name|dma_csr
expr_stmt|;
if|if
condition|(
operator|!
name|DMA_INTR
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
operator|--
name|wait
operator|<
literal|0
condition|)
block|{
name|msg
operator|=
literal|"timeout waiting for phase change"
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|sc
operator|->
name|sc_espstat
operator|=
name|esp
operator|->
name|esp_stat
expr_stmt|;
name|sc
operator|->
name|sc_espstep
operator|=
name|esp
operator|->
name|esp_step
operator|&
name|ESPSTEP_MASK
expr_stmt|;
name|sc
operator|->
name|sc_espintr
operator|=
name|esp
operator|->
name|esp_intr
expr_stmt|;
name|sc
operator|->
name|sc_dmacsr
operator|=
name|r
expr_stmt|;
comment|/* 	 * The action happens `twice around' for read and write. 	 * All the rest `goto loop' or return or some such. 	 */
name|wait
operator|=
name|CMD_WAIT
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|r
operator|=
name|espact
argument_list|(
name|sc
argument_list|,
name|esp
argument_list|,
name|dma
argument_list|,
name|cdb
argument_list|)
condition|)
block|{
case|case
name|ACT_CONT
case|:
case|case
name|ACT_QUICKINTR
case|:
goto|goto
name|loop
goto|;
case|case
name|ACT_READ
case|:
if|if
condition|(
name|len
operator|==
literal|0
operator|||
operator|(
name|rw
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|msg
operator|=
literal|"wrong phase"
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|r
operator|=
name|espixfer_in
argument_list|(
name|sc
argument_list|,
name|esp
argument_list|,
name|dma
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|msg
operator|=
literal|"timeout reading from device"
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|buf
operator|+=
name|len
operator|-
name|r
expr_stmt|;
name|len
operator|=
name|r
expr_stmt|;
comment|/* we did the io, expecting `generic service' */
name|sc
operator|->
name|sc_state
operator|=
name|S_IOSVC
expr_stmt|;
name|wait
operator|=
name|POSTDATA_WAIT
expr_stmt|;
break|break;
case|case
name|ACT_WRITE
case|:
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|rw
operator|&
name|B_READ
condition|)
block|{
name|msg
operator|=
literal|"wrong phase"
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|espixfer_out
argument_list|(
name|sc
argument_list|,
name|esp
argument_list|,
name|dma
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|msg
operator|=
literal|"timeout writing to device"
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|sc
operator|->
name|sc_state
operator|=
name|S_IOSVC
expr_stmt|;
name|wait
operator|=
name|POSTDATA_WAIT
expr_stmt|;
break|break;
case|case
name|ACT_RESET
case|:
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
goto|goto
name|reset
goto|;
case|case
name|ACT_DONE
case|:
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_stat
index|[
literal|0
index|]
operator|)
return|;
case|case
name|ACT_ERROR
case|:
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"espicmd action"
argument_list|)
expr_stmt|;
block|}
block|}
name|err
label|:
name|printf
argument_list|(
literal|"%s: target %d: %s (phase = %s)\n"
argument_list|,
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
operator|.
name|dv_xname
argument_list|,
name|targ
argument_list|,
name|msg
argument_list|,
name|espphases
index|[
name|sc
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_PHASE
index|]
argument_list|)
expr_stmt|;
name|reset
label|:
name|espreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* ??? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump (write memory, possibly physmem).  * SPARC higher-level dump code always provides virtual addresses,  * so we need not do any I/O mapping here.  */
end_comment

begin_function
name|int
name|espdump
parameter_list|(
name|hba
parameter_list|,
name|targ
parameter_list|,
name|cdb
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
specifier|register
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
name|int
name|targ
decl_stmt|;
specifier|register
name|struct
name|scsi_cdb
modifier|*
name|cdb
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
return|return
operator|(
name|espicmd
argument_list|(
name|hba
argument_list|,
name|targ
argument_list|,
name|cdb
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|B_WRITE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate resources (SCSI bus and DVMA space) for the given transfer.  * Must be called at splbio().  *  * THIS SHOULD RETURN SUCCESS/FAIL INDICATION  */
end_comment

begin_function
name|void
name|espstart
parameter_list|(
name|self
parameter_list|,
name|sq
parameter_list|,
name|bp
parameter_list|,
name|dgo
parameter_list|,
name|dev
parameter_list|)
name|struct
name|device
modifier|*
name|self
decl_stmt|;
specifier|register
name|struct
name|sq
modifier|*
name|sq
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|scdgo_fn
name|dgo
decl_stmt|;
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|self
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hba
operator|.
name|hba_busy
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Bus not busy, nothing to do here, just tell 		 * this target or unit that it has the SCSI bus. 		 */
name|sc
operator|->
name|sc_hba
operator|.
name|hba_busy
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|dgo
call|)
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Bus is busy; just enqueue. 		 */
name|sq
operator|->
name|sq_dgo
operator|=
name|dgo
expr_stmt|;
name|sq
operator|->
name|sq_dev
operator|=
name|dev
expr_stmt|;
name|sq
operator|->
name|sq_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hba
operator|.
name|hba_head
operator|==
name|NULL
condition|)
name|sc
operator|->
name|sc_hba
operator|.
name|hba_head
operator|=
name|sq
expr_stmt|;
else|else
name|sc
operator|->
name|sc_hba
operator|.
name|hba_tail
operator|->
name|sq_forw
operator|=
name|sq
expr_stmt|;
name|sc
operator|->
name|sc_hba
operator|.
name|hba_tail
operator|=
name|sq
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send a `dma' command, i.e., send the cdb and use DMA to send the data.  * Return 0 on success, 1 on failure.  */
end_comment

begin_function
name|int
name|espgo
parameter_list|(
name|self
parameter_list|,
name|targ
parameter_list|,
name|intr
parameter_list|,
name|dev
parameter_list|,
name|bp
parameter_list|,
name|pad
parameter_list|)
name|struct
name|device
modifier|*
name|self
decl_stmt|;
name|int
name|targ
decl_stmt|;
name|scintr_fn
name|intr
decl_stmt|;
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|pad
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|bp
operator|->
name|b_bcount
decl_stmt|;
specifier|register
name|u_long
name|addr
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|len
operator|>
name|MAX_TRANSFER_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
operator|.
name|dv_xname
argument_list|,
name|len
operator|<
literal|0
condition|?
literal|"negative length"
else|:
literal|"transfer too big"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_needclear
operator|&
operator|(
literal|1
operator|<<
name|targ
operator|)
condition|)
name|espclear
argument_list|(
name|sc
argument_list|,
name|targ
argument_list|)
expr_stmt|;
comment|/* 	 * Set dma registers later, on data transfer, 	 * but compute the contents now. 	 * COULD JUST REMEMBER bp HERE...? 	 * 	 * The DMA chip cannot cross a 16 MB address boundary. 	 * We should do this as multiple DMA transactions on a 	 * single SCSI command, but I have not written that yet. 	 */
name|sc
operator|->
name|sc_dmactl
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
name|DMA_ENA
operator||
name|DMA_READ
operator||
name|DMA_IE
else|:
name|DMA_ENA
operator||
name|DMA_IE
expr_stmt|;
name|addr
operator|=
operator|(
name|u_long
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
comment|/* dma chip cannot cross 16MB boundary  XXX */
if|if
condition|(
name|CROSS_DMA
argument_list|(
name|addr
argument_list|,
name|len
argument_list|)
condition|)
name|panic
argument_list|(
literal|"dma crosses 16MB boundary: fix esp.c"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dmaaddr
operator|=
name|addr
expr_stmt|;
name|sc
operator|->
name|sc_resid
operator|=
name|len
expr_stmt|;
comment|/* 	 * Enable interrupts and start selection. 	 * The rest is done in our interrupt handler. 	 */
name|sc
operator|->
name|sc_hba
operator|.
name|hba_intr
operator|=
name|intr
expr_stmt|;
comment|/* remember dev done function */
name|sc
operator|->
name|sc_hba
operator|.
name|hba_intrdev
operator|=
name|dev
expr_stmt|;
comment|/* and its first arg */
name|sc
operator|->
name|sc_dma
operator|->
name|dma_csr
operator|=
name|DMA_IE
expr_stmt|;
name|espselect
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_esp
argument_list|,
name|targ
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle interrupt.  Return 1 if taken.  */
end_comment

begin_function
name|int
name|espintr
parameter_list|(
name|sc0
parameter_list|)
name|void
modifier|*
name|sc0
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|sc0
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|espreg
modifier|*
name|esp
init|=
name|sc
operator|->
name|sc_esp
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|dmareg
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|wait
decl_stmt|;
specifier|register
name|struct
name|sq
modifier|*
name|sq
decl_stmt|;
name|r
operator|=
name|dma
operator|->
name|dma_csr
expr_stmt|;
if|if
condition|(
operator|!
name|DMA_INTR
argument_list|(
name|r
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not ours */
name|sc
operator|->
name|sc_intrcnt
operator|.
name|ev_count
operator|++
expr_stmt|;
name|again
label|:
name|sc
operator|->
name|sc_espstat
operator|=
name|esp
operator|->
name|esp_stat
expr_stmt|;
name|sc
operator|->
name|sc_espstep
operator|=
name|esp
operator|->
name|esp_step
operator|&
name|ESPSTEP_MASK
expr_stmt|;
name|sc
operator|->
name|sc_espintr
operator|=
name|esp
operator|->
name|esp_intr
expr_stmt|;
name|sc
operator|->
name|sc_dmacsr
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|S_IDLE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: stray interrupt\n"
argument_list|,
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
comment|/* ??? */
return|return
operator|(
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|r
operator|=
name|espact
argument_list|(
name|sc
argument_list|,
name|esp
argument_list|,
name|dma
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdb
argument_list|)
condition|)
block|{
case|case
name|ACT_CONT
case|:
comment|/* just return */
break|break;
case|case
name|ACT_READ
case|:
case|case
name|ACT_WRITE
case|:
comment|/* 		 * We have to do this ourselves since another 		 * user of espact() wants to do programmed I/O. 		 * If we already did dma, and are done, stop. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_resid
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d sent too much data\n"
argument_list|,
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_targ
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
name|sc
operator|->
name|sc_dmaactive
operator|=
literal|1
expr_stmt|;
name|dma
operator|->
name|dma_addr
operator|=
name|sc
operator|->
name|sc_dmaaddr
expr_stmt|;
name|esp
operator|->
name|esp_tch
operator|=
name|sc
operator|->
name|sc_resid
operator|>>
literal|8
expr_stmt|;
name|esp
operator|->
name|esp_tcl
operator|=
name|sc
operator|->
name|sc_resid
expr_stmt|;
comment|/* load count into counter via DMA NOP */
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_DMA
operator||
name|ESPCMD_NOP
expr_stmt|;
comment|/* enable dma */
name|dma
operator|->
name|dma_csr
operator|=
name|sc
operator|->
name|sc_dmactl
expr_stmt|;
comment|/* and go */
name|esp
operator|->
name|esp_cmd
operator|=
name|ESPCMD_DMA
operator||
name|ESPCMD_XFER_INFO
expr_stmt|;
break|break;
case|case
name|ACT_RESET
case|:
comment|/* please reset esp */
name|reset
label|:
name|espreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* ??? */
comment|/* FALLTHROUGH */
case|case
name|ACT_DONE
case|:
comment|/* this one is done, successfully */
case|case
name|ACT_ERROR
case|:
comment|/* this one is done due to `severe' error */
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_hba
operator|.
name|hba_busy
condition|)
name|panic
argument_list|(
literal|"espintr sq"
argument_list|)
expr_stmt|;
comment|/* 		 * This transaction is done. 		 * Call the driver's intr routine, 		 * then start the next guy if any. 		 */
call|(
modifier|*
name|sc
operator|->
name|sc_hba
operator|.
name|hba_intr
call|)
argument_list|(
name|sc
operator|->
name|sc_hba
operator|.
name|hba_intrdev
argument_list|,
name|r
operator|==
name|ACT_DONE
condition|?
name|sc
operator|->
name|sc_stat
index|[
literal|0
index|]
else|:
operator|-
literal|1
argument_list|,
name|sc
operator|->
name|sc_resid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sq
operator|=
name|sc
operator|->
name|sc_hba
operator|.
name|hba_head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_hba
operator|.
name|hba_head
operator|=
name|sq
operator|->
name|sq_forw
expr_stmt|;
call|(
modifier|*
name|sq
operator|->
name|sq_dgo
call|)
argument_list|(
name|sq
operator|->
name|sq_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdb
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_hba
operator|.
name|hba_busy
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ACT_QUICKINTR
case|:
comment|/* wait a short while for another interrupt */
name|printf
argument_list|(
literal|"%s: quickintr: "
argument_list|,
name|sc
operator|->
name|sc_hba
operator|.
name|hba_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|wait
operator|=
literal|100
expr_stmt|;
do|do
block|{
name|r
operator|=
name|dma
operator|->
name|dma_csr
expr_stmt|;
if|if
condition|(
name|DMA_INTR
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"got one, wait=%d\n"
argument_list|,
name|wait
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
do|while
condition|(
operator|--
name|wait
operator|>
literal|0
condition|)
do|;
name|printf
argument_list|(
literal|"did not get one\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"espintr action"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Target or unit decided to let go of the bus early.  */
end_comment

begin_function
name|void
name|esprel
parameter_list|(
name|self
parameter_list|)
name|struct
name|device
modifier|*
name|self
decl_stmt|;
block|{
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|sq
modifier|*
name|sq
decl_stmt|;
comment|/* if there is someone else waiting, give them a crack at it */
if|if
condition|(
operator|(
name|sq
operator|=
name|sc
operator|->
name|sc_hba
operator|.
name|hba_head
operator|)
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sq
operator|->
name|sq_dgo
call|)
argument_list|(
name|sq
operator|->
name|sq_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdb
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|sc_hba
operator|.
name|hba_busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

