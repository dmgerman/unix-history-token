begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expands front end tree to back end RTL for GNU C-Compiler    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file handles the generation of rtl code from tree structure    above the level of expressions, using subroutines in exp*.c and emit-rtl.c.    It also creates the rtl expressions for parameters and auto variables    and has full responsibility for allocating stack slots.     The functions whose names start with `expand_' are called by the    parser to generate RTL instructions for various kinds of constructs.     Some control and binding constructs require calling several such    functions at different times.  For example, a simple if-then    is expanded by calling `expand_start_cond' (with the condition-expression    as argument) before parsing the then-clause and calling `expand_end_cond'    after parsing the then-clause.     `expand_function_start' is called at the beginning of a function,    before the function body is parsed, and `expand_function_end' is    called after parsing the body.     Call `assign_stack_local' to allocate a stack slot for a local variable.    This is usually done during the RTL generation for the function body,    but it can also be done in the reload pass when a pseudo-register does    not get a hard register.     Call `put_var_into_stack' when you learn, belatedly, that a variable    previously given a pseudo-register must in fact go in the stack.    This function changes the DECL_RTL to be a stack slot instead of a reg    then scans all the RTL instructions so far generated to correct them.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
name|struct
name|obstack
name|stmt_obstack
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)> (y)) ? (x) : (y))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)< (y)) ? (x) : (y))
end_define

begin_comment
comment|/* Nonzero if function being compiled pops its args on return.    May affect compilation of return insn or of function epilogue.  */
end_comment

begin_decl_stmt
name|int
name|current_function_pops_args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled needs to be given an address    where the value should be stored.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_struct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled needs to    return the address of where it has put a structure value.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_pcc_struct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled needs to be passed a static chain.  */
end_comment

begin_decl_stmt
name|int
name|current_function_needs_context
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled can call setjmp.  */
end_comment

begin_decl_stmt
name|int
name|current_function_calls_setjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled can call alloca,    either as a subroutine or builtin.  */
end_comment

begin_decl_stmt
name|int
name|current_function_calls_alloca
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the current function returns a pointer type */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If function's args have a fixed size, this is that size, in bytes.    Otherwise, it is -1.    May affect compilation of return insn or of function epilogue.  */
end_comment

begin_decl_stmt
name|int
name|current_function_args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # bytes the prologue should push and pretend that the caller pushed them.    The prologue must do this, but only if parms can be passed in registers.  */
end_comment

begin_decl_stmt
name|int
name|current_function_pretend_args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of function now being compiled.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_function_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label that will go on parm cleanup code, if any.    Jumping to this label runs cleanup code for parameters, if    such code must be run.  Following this code is the logical return label.  */
end_comment

begin_decl_stmt
name|rtx
name|cleanup_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label that will go on function epilogue.    Jumping to this label serves as a "return" instruction    on machines which require execution of the epilogue on all returns.  */
end_comment

begin_decl_stmt
name|rtx
name|return_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of EXPR_LISTs) of pseudo-regs of SAVE_EXPRs.    So we can mark them all live at the end of the function, if nonopt.  */
end_comment

begin_decl_stmt
name|rtx
name|save_expr_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of EXPR_LISTs) of all stack slots in this function.    Made for the sake of unshare_all_rtl.  */
end_comment

begin_decl_stmt
name|rtx
name|stack_slot_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filename and line number of last line-number note,    whether we actually emitted it or not.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|emit_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|emit_lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|parm_birth_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FUNCTION_DECL node for the function being compiled.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|this_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset to end of allocated area of stack frame.    If stack grows down, this is the address of the last stack slot allocated.    If stack grows up, this is the address for the next slot.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frame_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if a stack slot has been generated whose address is not    actually valid.  It means that the generated rtl must all be scanned    to detect and correct the invalid addresses where they occur.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|invalid_stack_slot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label to jump back to for tail recursion, or 0 if we have    not yet needed one for this function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|tail_recursion_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Place after which to insert the tail_recursion_label if we need one.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|tail_recursion_reentry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each time we expand an expression-statement,    record the expr's type and its RTL value here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_expr_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|last_expr_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of binding contours started so far in this function.  */
end_comment

begin_decl_stmt
name|int
name|block_start_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all RTL_EXPRs that have insns in them.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|rtl_expr_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last insn of those whose job was to put parms into their nominal homes.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_parm_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cleanup lists are required for binding levels regardless of whether    that binding level has cleanups or not.  This node satisfies that    need for all binding levels.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|empty_cleanup_list
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Functions and data structures for expanding case statements.  */
end_comment

begin_comment
comment|/* Case label structure, used to hold info on labels within case    statements.  We handle "range" labels; for a single-value label    as in C, the high and low limits are the same.  */
end_comment

begin_struct
struct|struct
name|case_node
block|{
name|struct
name|case_node
modifier|*
name|left
decl_stmt|;
name|struct
name|case_node
modifier|*
name|right
decl_stmt|;
name|struct
name|case_node
modifier|*
name|parent
decl_stmt|;
name|tree
name|low
decl_stmt|;
name|tree
name|high
decl_stmt|;
name|tree
name|test_label
decl_stmt|;
name|tree
name|code_label
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|case_node
name|case_node
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|case_node
modifier|*
name|case_node_ptr
typedef|;
end_typedef

begin_function_decl
specifier|extern
name|void
name|balance_case_nodes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|emit_case_nodes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|group_case_nodes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|emit_jump_if_reachable
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Stack of control and binding constructs we are currently inside.     These constructs begin when you call `expand_start_WHATEVER'    and end when you call `expand_end_WHATEVER'.  This stack records    info about how the construct began that tells the end-function    what to do.  It also may provide information about the construct    to alter the behavior of other constructs within the body.    For example, they may affect the behavior of C `break' and `continue'.     Each construct gets one `struct nesting' object.    All of these objects are chained through the `all' field.    `nesting_stack' points to the first object (innermost construct).    The position of an entry on `nesting_stack' is in its `depth' field.     Each type of construct has its own individual stack.    For example, loops have `loop_stack'.  Each object points to the    next object of the same type through the `next' field.     Some constructs are visible to `break' exit-statements and others    are not.  Which constructs are visible depends on the language.    Therefore, the data structure allows each construct to be visible    or not, according to the args given when the construct is started.    The construct is visible if the `exit_label' field is non-null.    In that case, the value should be a CODE_LABEL rtx.  */
end_comment

begin_struct
struct|struct
name|nesting
block|{
name|struct
name|nesting
modifier|*
name|all
decl_stmt|;
name|struct
name|nesting
modifier|*
name|next
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|rtx
name|exit_label
decl_stmt|;
union|union
block|{
comment|/* For conds (if-then and if-then-else statements).  */
struct|struct
block|{
comment|/* Label on the else-part, if any, else 0.  */
name|rtx
name|else_label
decl_stmt|;
comment|/* Label at the end of the whole construct.  */
name|rtx
name|after_label
decl_stmt|;
block|}
name|cond
struct|;
comment|/* For loops.  */
struct|struct
block|{
comment|/* Label at the top of the loop; place to loop back to.  */
name|rtx
name|start_label
decl_stmt|;
comment|/* Label at the end of the whole construct.  */
name|rtx
name|end_label
decl_stmt|;
comment|/* Label for `continue' statement to jump to; 	     this is in front of the stepper of the loop.  */
name|rtx
name|continue_label
decl_stmt|;
block|}
name|loop
struct|;
comment|/* For variable binding contours.  */
struct|struct
block|{
comment|/* Sequence number of this binding contour within the function, 	     in order of entry.  */
name|int
name|block_start_count
decl_stmt|;
comment|/* Nonzero => value to restore stack to on exit.  */
name|rtx
name|stack_level
decl_stmt|;
comment|/* The NOTE that starts this contour. 	     Used by expand_goto to check whether the destination 	     is within each contour or not.  */
name|rtx
name|first_insn
decl_stmt|;
comment|/* Innermost containing binding contour that has a stack level.  */
name|struct
name|nesting
modifier|*
name|innermost_stack_block
decl_stmt|;
comment|/* List of cleanups to be run on exit from this contour. 	     This is a list of expressions to be evaluated. 	     The TREE_PURPOSE of each link is the ..._DECL node 	     which the cleanup pertains to.  */
name|tree
name|cleanups
decl_stmt|;
comment|/* List of cleanup-lists of blocks containing this block, 	     as they were at the locus where this block appears. 	     There is an element for each containing block, 	     ordered innermost containing block first, once there are 	     any cleanups at all. 	     The element's TREE_VALUE is the cleanup-list of that block, 	     which may be null.  */
name|tree
name|outer_cleanups
decl_stmt|;
comment|/* Chain of labels defined inside this binding contour. 	     For contours that have stack levels or cleanups.  */
name|struct
name|label_chain
modifier|*
name|label_chain
decl_stmt|;
block|}
name|block
struct|;
comment|/* For switch (C) or case (Pascal) statements, 	 and also for dummies (see `expand_start_case_dummy').  */
struct|struct
block|{
comment|/* The insn after which the case dispatch should finally 	     be emitted.  Zero for a dummy.  */
name|rtx
name|start
decl_stmt|;
comment|/* A list of case labels, kept in ascending order by value 	     as the list is built. 	     During expand_end_case, this list may be rearranged into a 	     nearly balanced binary tree.  */
name|struct
name|case_node
modifier|*
name|case_list
decl_stmt|;
comment|/* Label to jump to if no case matches.  */
name|tree
name|default_label
decl_stmt|;
comment|/* The expression to be dispatched on.  */
name|tree
name|index_expr
decl_stmt|;
comment|/* Type that INDEX_EXPR should be converted to.  */
name|tree
name|nominal_type
decl_stmt|;
comment|/* Number of range exprs in case statement.  */
name|short
name|num_ranges
decl_stmt|;
block|}
name|case_stmt
struct|;
comment|/* For exception contours.  */
struct|struct
block|{
comment|/* List of exceptions raised.  This is a TREE_LIST 	     of whatever you want.  */
name|tree
name|raised
decl_stmt|;
comment|/* List of exceptions caught.  This is also a TREE_LIST 	     of whatever you want.  As a special case, it has the 	     value `void_type_node' if it handles default exceptions.  */
name|tree
name|handled
decl_stmt|;
comment|/* First insn of TRY block, in case resumptive model is needed.  */
name|rtx
name|first_insn
decl_stmt|;
comment|/* Label for the catch clauses.  */
name|rtx
name|except_label
decl_stmt|;
comment|/* Label for unhandled exceptions.  */
name|rtx
name|unhandled_label
decl_stmt|;
comment|/* Label at the end of whole construct.  */
name|rtx
name|after_label
decl_stmt|;
comment|/* Label which "escapes" the exception construct. 	     Like EXIT_LABEL for BREAK construct, but for exceptions.  */
name|rtx
name|escape_label
decl_stmt|;
block|}
name|except_stmt
struct|;
block|}
name|data
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Chain of all pending binding contours.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|block_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all pending binding contours that restore stack levels    or have cleanups.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|stack_block_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all pending conditional statements.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|cond_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all pending loops.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|loop_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all pending case or switch statements.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|case_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all pending exception contours.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|except_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Separate chain including all of the above,    chained through the `all' field.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|nesting_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of entries on nesting_stack now.  */
end_comment

begin_decl_stmt
name|int
name|nesting_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pop one of the sub-stacks, such as `loop_stack' or `cond_stack';    and pop off `nesting_stack' down to the same level.  */
end_comment

begin_define
define|#
directive|define
name|POPSTACK
parameter_list|(
name|STACK
parameter_list|)
define|\
value|do { int initial_depth = nesting_stack->depth;		\      do { struct nesting *this = STACK;			\ 	  STACK = this->next;				\ 	  nesting_stack = this->all;			\ 	  nesting_depth = this->depth;			\ 	  obstack_free (&stmt_obstack, this); }		\      while (nesting_depth> initial_depth); } while (0)
end_define

begin_escape
end_escape

begin_function_decl
specifier|static
name|int
name|warn_if_unused_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_goto_internal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|expand_fixup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_gotos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_cleanups
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_cleanups
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_null_return_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tail_recursion_args
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_stack_slots
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|fixup_stack_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|fixup_memory_subreg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|walk_fixup_memory_subreg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_var_refs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_var_refs_insns
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|fixup_var_refs_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|parm_stack_loc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|optimize_bit_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_jump_if_equal
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Emit a no-op instruction.  */
end_comment

begin_function
name|rtx
name|emit_nop
parameter_list|()
block|{
name|rtx
name|last_insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|prev_real_insn
argument_list|(
name|last_insn
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the rtx-label that corresponds to a LABEL_DECL,    creating it if necessary.  */
end_comment

begin_function
name|rtx
comment|/* @@ non-static for case.c.  */
name|label_rtx
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_RTL
argument_list|(
name|label
argument_list|)
condition|)
return|return
name|DECL_RTL
argument_list|(
name|label
argument_list|)
return|;
return|return
name|DECL_RTL
argument_list|(
name|label
argument_list|)
operator|=
name|gen_label_rtx
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Add an unconditional jump to LABEL as the next sequential instruction.  */
end_comment

begin_function
name|void
name|emit_jump
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle goto statements and the labels that they can go to.  */
end_comment

begin_comment
comment|/* In some cases it is impossible to generate code for a forward goto     until the label definition is seen.  This happens when it may be necessary    for the goto to reset the stack pointer: we don't yet know how to do that.    So expand_goto puts an entry on this fixup list.    Each time a binding contour that resets the stack is exited,    we check each fixup.    If the target label has now been defined, we can insert the proper code.  */
end_comment

begin_struct
struct|struct
name|goto_fixup
block|{
comment|/* Points to following fixup.  */
name|struct
name|goto_fixup
modifier|*
name|next
decl_stmt|;
comment|/* Points to the insn before the jump insn.      If more code must be inserted, it goes after this insn.  */
name|rtx
name|before_jump
decl_stmt|;
comment|/* The LABEL_DECL that this jump is jumping to, or 0      for break, continue or return.  */
name|tree
name|target
decl_stmt|;
comment|/* The CODE_LABEL rtx that this is jumping to.  */
name|rtx
name|target_rtl
decl_stmt|;
comment|/* Number of binding contours started in current function      before the label reference.  */
name|int
name|block_start_count
decl_stmt|;
comment|/* The outermost stack level that should be restored for this jump.      Each time a binding contour that resets the stack is exited,      if the target label is *not* yet defined, this slot is updated.  */
name|rtx
name|stack_level
decl_stmt|;
comment|/* List of lists of cleanup expressions to be run by this goto.      There is one element for each block that this goto is within,      once there are any cleanups at all.      The TREE_VALUE contains the cleanup list of that block as of the      time this goto was seen.      The TREE_ADDRESSABLE flag is 1 for a block that has been exited.  */
name|tree
name|cleanup_list_list
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|goto_fixup
modifier|*
name|goto_fixup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Within any binding contour that must restore a stack level,    all labels are recorded with a chain of these structures.  */
end_comment

begin_struct
struct|struct
name|label_chain
block|{
comment|/* Points to following fixup.  */
name|struct
name|label_chain
modifier|*
name|next
decl_stmt|;
name|tree
name|label
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Specify the location in the RTL code of a label BODY,    which is a LABEL_DECL tree node.     This is used for the kind of label that the user can jump to with a    goto statement, and for alternatives of a switch or case statement.    RTL labels generated for loops and conditionals don't go through here;    they are generated directly at the RTL level, by other functions below.     Note that this has nothing to do with defining label *names*.    Languages vary in how they do that and what that even means.  */
end_comment

begin_function
name|void
name|expand_label
parameter_list|(
name|body
parameter_list|)
name|tree
name|body
decl_stmt|;
block|{
name|struct
name|label_chain
modifier|*
name|p
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label_rtx
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_block_stack
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|label_chain
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|label_chain
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|stack_block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
expr_stmt|;
name|stack_block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|label
operator|=
name|body
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate RTL code for a `goto' statement with target label BODY.    BODY should be a LABEL_DECL tree node that was or will later be    defined with `expand_label'.  */
end_comment

begin_function
name|void
name|expand_goto
parameter_list|(
name|body
parameter_list|)
name|tree
name|body
decl_stmt|;
block|{
name|expand_goto_internal
argument_list|(
name|body
argument_list|,
name|label_rtx
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL code for a `goto' statement with target label BODY.    LABEL should be a LABEL_REF.    LAST_INSN, if non-0, is the rtx we should consider as the last    insn emitted (for the purposes of cleaning up a return).  */
end_comment

begin_function
specifier|static
name|void
name|expand_goto_internal
parameter_list|(
name|body
parameter_list|,
name|label
parameter_list|,
name|last_insn
parameter_list|)
name|tree
name|body
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|;
name|rtx
name|stack_level
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If label has already been defined, we can tell now      whether and how we must alter the stack level.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Find the innermost pending block that contains the label. 	 (Check containment by comparing insn-uids.) 	 Then restore the outermost stack level within that block, 	 and do cleanups of all blocks contained in it.  */
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
operator|<
name|INSN_UID
argument_list|(
name|label
argument_list|)
condition|)
break|break;
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
condition|)
name|stack_level
operator|=
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
expr_stmt|;
comment|/* Execute the cleanups for blocks we are exiting.  */
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
block|{
name|expand_cleanups
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stack_level
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|body
operator|!=
literal|0
operator|&&
name|TREE_PACKED
argument_list|(
name|body
argument_list|)
condition|)
name|error
argument_list|(
literal|"jump to `%s' invalidly jumps into binding contour"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Label not yet defined: may need to put this goto      on the fixup list.  */
elseif|else
if|if
condition|(
operator|!
name|expand_fixup
argument_list|(
name|body
argument_list|,
name|label
argument_list|,
name|last_insn
argument_list|)
condition|)
block|{
comment|/* No fixup needed.  Record that the label is the target 	 of at least one goto that has no fixup.  */
if|if
condition|(
name|body
operator|!=
literal|0
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|body
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return truth-value of whether there are any cleanups from    the current binding contour to the end of the current function's    binding contours.  */
end_comment

begin_function
name|int
name|any_pending_cleanups
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|;
if|if
condition|(
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
literal|0
operator|||
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|==
name|empty_cleanup_list
condition|)
return|return
literal|0
return|;
for|for
control|(
name|block
operator|=
name|block_stack
operator|->
name|next
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
break|break;
return|return
name|block
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate if necessary a fixup for a goto    whose target label in tree structure (if any) is TREE_LABEL    and whose target in rtl is RTL_LABEL.     If LAST_INSN is nonzero, we pretend that the jump appears    after insn LAST_INSN instead of at the current point in the insn stream.     The fixup will be used later to insert insns at this point    to restore the stack level as appropriate for the target label.     Value is nonzero if a fixup is made.  */
end_comment

begin_function
specifier|static
name|int
name|expand_fixup
parameter_list|(
name|tree_label
parameter_list|,
name|rtl_label
parameter_list|,
name|last_insn
parameter_list|)
name|tree
name|tree_label
decl_stmt|;
name|rtx
name|rtl_label
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|,
modifier|*
name|end_block
decl_stmt|;
comment|/* See if we can recognize which block the label will be output in.      This is possible in some very common cases.      If we succeed, set END_BLOCK to that block.      Otherwise, set it to 0.  */
if|if
condition|(
name|cond_stack
operator|&&
operator|(
name|rtl_label
operator|==
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|else_label
operator|||
name|rtl_label
operator|==
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|after_label
operator|)
condition|)
name|end_block
operator|=
name|cond_stack
expr_stmt|;
comment|/* If we are in a loop, recognize certain labels which      are likely targets.  This reduces the number of fixups      we need to create.  */
elseif|else
if|if
condition|(
name|loop_stack
operator|&&
operator|(
name|rtl_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
operator|||
name|rtl_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|||
name|rtl_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|)
condition|)
name|end_block
operator|=
name|loop_stack
expr_stmt|;
else|else
name|end_block
operator|=
literal|0
expr_stmt|;
comment|/* Now set END_BLOCK to the binding level to which we will return.  */
if|if
condition|(
name|end_block
condition|)
block|{
name|struct
name|nesting
modifier|*
name|next_block
init|=
name|end_block
operator|->
name|all
decl_stmt|;
name|block
operator|=
name|block_stack
expr_stmt|;
comment|/* First see if the END_BLOCK is inside the innermost binding level. 	 If so, then no cleanups or stack levels are relevant.  */
while|while
condition|(
name|next_block
operator|&&
name|next_block
operator|!=
name|block
condition|)
name|next_block
operator|=
name|next_block
operator|->
name|all
expr_stmt|;
if|if
condition|(
name|next_block
condition|)
return|return
literal|0
return|;
comment|/* Otherwise, set END_BLOCK to the innermost binding level 	 which is outside the relevant control-structure nesting.  */
name|next_block
operator|=
name|block_stack
operator|->
name|next
expr_stmt|;
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
operator|!=
name|end_block
condition|;
name|block
operator|=
name|block
operator|->
name|all
control|)
if|if
condition|(
name|block
operator|==
name|next_block
condition|)
name|next_block
operator|=
name|next_block
operator|->
name|next
expr_stmt|;
name|end_block
operator|=
name|next_block
expr_stmt|;
block|}
comment|/* Does any containing block have a stack level or cleanups?      If not, no fixup is needed, and that is the normal case      (the only case, for standard C).  */
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
operator|!=
name|end_block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|||
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|block
operator|!=
name|end_block
condition|)
block|{
comment|/* Ok, a fixup is needed.  Add a fixup to the list of such.  */
name|struct
name|goto_fixup
modifier|*
name|fixup
init|=
operator|(
expr|struct
name|goto_fixup
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|goto_fixup
argument_list|)
argument_list|)
decl_stmt|;
comment|/* In case an old stack level is restored, make sure that comes 	 after any pending stack adjust.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|fixup
operator|->
name|before_jump
operator|=
name|last_insn
condition|?
name|last_insn
else|:
name|get_last_insn
argument_list|()
expr_stmt|;
name|fixup
operator|->
name|target
operator|=
name|tree_label
expr_stmt|;
name|fixup
operator|->
name|target_rtl
operator|=
name|rtl_label
expr_stmt|;
name|fixup
operator|->
name|block_start_count
operator|=
name|block_start_count
expr_stmt|;
name|fixup
operator|->
name|stack_level
operator|=
literal|0
expr_stmt|;
name|fixup
operator|->
name|cleanup_list_list
operator|=
operator|(
operator|(
operator|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|&&
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|!=
name|empty_cleanup_list
operator|)
operator|||
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|)
condition|?
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|fixup
operator|->
name|next
operator|=
name|goto_fixup_chain
expr_stmt|;
name|goto_fixup_chain
operator|=
name|fixup
expr_stmt|;
block|}
return|return
name|block
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When exiting a binding contour, process all pending gotos requiring fixups.    THISBLOCK is the structure that describes the block being exited.    STACK_LEVEL is the rtx for the stack level to restore exiting this contour.    CLEANUP_LIST is a list of expressions to evaluate on exiting this contour.    FIRST_INSN is the insn that began this contour.     Gotos that jump out of this contour must restore the    stack level and do the cleanups before actually jumping.     DONT_JUMP_IN nonzero means report error there is a jump into this    contour from before the beginning of the contour.    This is also done if STACK_LEVEL is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_gotos
parameter_list|(
name|thisblock
parameter_list|,
name|stack_level
parameter_list|,
name|cleanup_list
parameter_list|,
name|first_insn
parameter_list|,
name|dont_jump_in
parameter_list|)
name|struct
name|nesting
modifier|*
name|thisblock
decl_stmt|;
name|rtx
name|stack_level
decl_stmt|;
name|tree
name|cleanup_list
decl_stmt|;
name|rtx
name|first_insn
decl_stmt|;
name|int
name|dont_jump_in
decl_stmt|;
block|{
specifier|register
name|struct
name|goto_fixup
modifier|*
name|f
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* F is the fixup we are considering; PREV is the previous one.  */
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|f
operator|=
name|goto_fixup_chain
init|;
name|f
condition|;
name|prev
operator|=
name|f
operator|,
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
comment|/* Test for a fixup that is inactive because it is already handled.  */
if|if
condition|(
name|f
operator|->
name|before_jump
operator|==
literal|0
condition|)
block|{
comment|/* Delete inactive fixup from the chain, if that is easy to do.  */
if|if
condition|(
name|prev
operator|!=
literal|0
condition|)
name|prev
operator|->
name|next
operator|=
name|f
operator|->
name|next
expr_stmt|;
block|}
comment|/* Has this fixup's target label been defined? 	 If so, we can finalize it.  */
elseif|else
if|if
condition|(
name|PREV_INSN
argument_list|(
name|f
operator|->
name|target_rtl
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* If this fixup jumped into this contour from before the beginning 	     of this contour, report an error.  */
comment|/* ??? Bug: this does not detect jumping in through intermediate 	     blocks that have stack levels or cleanups. 	     It detects only a problem with the innermost block 	     around the label.  */
if|if
condition|(
name|f
operator|->
name|target
operator|!=
literal|0
operator|&&
operator|(
name|dont_jump_in
operator|||
name|stack_level
operator|||
name|cleanup_list
operator|)
operator|&&
name|INSN_UID
argument_list|(
name|first_insn
argument_list|)
operator|>
name|INSN_UID
argument_list|(
name|f
operator|->
name|before_jump
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|f
operator|->
name|target
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|f
operator|->
name|target
argument_list|,
literal|"label `%s' used before containing binding contour"
argument_list|)
expr_stmt|;
comment|/* Prevent multiple errors for one label.  */
name|TREE_ADDRESSABLE
argument_list|(
name|f
operator|->
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Execute cleanups for blocks this jump exits.  */
if|if
condition|(
name|f
operator|->
name|cleanup_list_list
condition|)
block|{
name|tree
name|lists
decl_stmt|;
for|for
control|(
name|lists
operator|=
name|f
operator|->
name|cleanup_list_list
init|;
name|lists
condition|;
name|lists
operator|=
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
control|)
comment|/* Marked elements correspond to blocks that have been closed. 		   Do their cleanups.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|lists
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|lists
argument_list|)
operator|!=
literal|0
condition|)
name|fixup_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|lists
argument_list|)
argument_list|,
operator|&
name|f
operator|->
name|before_jump
argument_list|)
expr_stmt|;
block|}
comment|/* Restore stack level for the biggest contour that this 	     jump jumps out of.  */
if|if
condition|(
name|f
operator|->
name|stack_level
condition|)
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|f
operator|->
name|stack_level
argument_list|)
argument_list|,
name|f
operator|->
name|before_jump
argument_list|)
expr_stmt|;
name|f
operator|->
name|before_jump
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Label has still not appeared.  If we are exiting a block with 	 a stack level to restore, that started before the fixup, 	 mark this stack level as needing restoration 	 when the fixup is later finalized. 	 Also mark the cleanup_list_list element for F 	 that corresponds to this block, so that ultimately 	 this block's cleanups will be executed by the code above.  */
comment|/* Note: if THISBLOCK == 0 and we have a label that hasn't appeared, 	 it means the label is undefined.  That's erroneous, but possible.  */
elseif|else
if|if
condition|(
name|thisblock
operator|!=
literal|0
operator|&&
operator|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|block_start_count
operator|<
name|f
operator|->
name|block_start_count
operator|)
condition|)
block|{
name|tree
name|lists
init|=
name|f
operator|->
name|cleanup_list_list
decl_stmt|;
for|for
control|(
init|;
name|lists
condition|;
name|lists
operator|=
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
control|)
comment|/* If the following elt. corresponds to our containing block 	       then the elt. must be for this block.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
operator|==
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|lists
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stack_level
condition|)
name|f
operator|->
name|stack_level
operator|=
name|stack_level
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for an asm statement (explicit assembler code).    BODY is a STRING_CST node containing the assembler code text.  */
end_comment

begin_function
name|void
name|expand_asm
parameter_list|(
name|body
parameter_list|)
name|tree
name|body
decl_stmt|;
block|{
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|ASM_INPUT
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for an asm statement with arguments.    STRING is the instruction template.    OUTPUTS is a list of output arguments (lvalues); INPUTS a list of inputs.    Each output or input has an expression in the TREE_VALUE and    a constraint-string in the TREE_PURPOSE.    CLOBBERS is a list of STRING_CST nodes each naming a hard register    that is clobbered by this insn.     Not all kinds of lvalue that may appear in OUTPUTS can be stored directly.    Some elements of OUTPUTS may be replaced with trees representing temporary    values.  The caller should copy those temporary values to the originally    specified lvalues.     VOL nonzero means the insn is volatile; don't optimize it.  */
end_comment

begin_function
name|void
name|expand_asm_operands
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|,
name|vol
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|string
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|;
name|int
name|vol
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|rtvec
name|argvec
decl_stmt|,
name|constraints
decl_stmt|;
name|rtx
name|body
decl_stmt|;
name|int
name|ninputs
init|=
name|list_length
argument_list|(
name|inputs
argument_list|)
decl_stmt|;
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
name|int
name|nclobbers
init|=
name|list_length
argument_list|(
name|clobbers
argument_list|)
decl_stmt|;
name|tree
name|tail
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Vector of RTX's of evaluated output operands.  */
name|rtx
modifier|*
name|output_rtx
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The insn we have emitted.  */
name|rtx
name|insn
decl_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|found_equal
decl_stmt|;
comment|/* If there's an erroneous arg, emit no insn.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Make sure constraint has `=' and does not have `+'.  */
name|found_equal
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
index|[
name|j
index|]
operator|==
literal|'+'
condition|)
block|{
name|error
argument_list|(
literal|"output operand constraint contains `+'"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
index|[
name|j
index|]
operator|==
literal|'='
condition|)
name|found_equal
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_equal
condition|)
block|{
name|error
argument_list|(
literal|"output operand constraint lacks `='"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If an output operand is not a variable or indirect ref, 	 create a SAVE_EXPR which is a pseudo-reg 	 to act as an intermediate temporary. 	 Make the asm insn write into that, then copy it to 	 the real output operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* `build' isn't safe; it really expects args to be trees.  */
name|tree
name|t
init|=
name|build_nt
argument_list|(
name|SAVE_EXPR
argument_list|,
name|val
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|save_expr_regs
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|save_expr_regs
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|t
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|output_rtx
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ninputs
operator|+
name|noutputs
operator|>
name|MAX_RECOG_OPERANDS
condition|)
block|{
name|error
argument_list|(
literal|"more than %d operands in `asm'"
argument_list|,
name|MAX_RECOG_OPERANDS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make vectors for the expression-rtx and constraint strings.  */
name|argvec
operator|=
name|rtvec_alloc
argument_list|(
name|ninputs
argument_list|)
expr_stmt|;
name|constraints
operator|=
name|rtvec_alloc
argument_list|(
name|ninputs
argument_list|)
expr_stmt|;
name|body
operator|=
name|gen_rtx
argument_list|(
name|ASM_OPERANDS
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
name|argvec
argument_list|,
name|constraints
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|body
argument_list|)
operator|=
name|vol
expr_stmt|;
comment|/* Eval the inputs and put them into ARGVEC.      Put their constraints into ASM_INPUTs and store in CONSTRAINTS.  */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|inputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|int
name|j
decl_stmt|;
comment|/* If there's an erroneous arg, emit no insn, 	 because the ASM_INPUT would get VOIDmode 	 and that could cause a crash in reload.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"hard register `%s' listed as input operand to `asm'"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure constraint has neither `=' nor `+'.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
index|[
name|j
index|]
operator|==
literal|'='
operator|||
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
index|[
name|j
index|]
operator|==
literal|'+'
condition|)
block|{
name|error
argument_list|(
literal|"input operand constraint contains `%c'"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
comment|/* argvec */
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|4
argument_list|,
name|i
argument_list|)
comment|/* constraints */
operator|=
name|gen_rtx
argument_list|(
name|ASM_INPUT
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* Protect all the operands from the queue,      now that they have all been evaluated.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninputs
condition|;
name|i
operator|++
control|)
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
operator|=
name|protect_from_queue
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noutputs
condition|;
name|i
operator|++
control|)
name|output_rtx
index|[
name|i
index|]
operator|=
name|protect_from_queue
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now, for each output, construct an rtx      (set OUTPUT (asm_operands INSN OUTPUTNUMBER OUTPUTCONSTRAINT 			       ARGVEC CONSTRAINTS))      If there is more than one, put them inside a PARALLEL.  */
if|if
condition|(
name|noutputs
operator|==
literal|1
operator|&&
name|nclobbers
operator|==
literal|0
condition|)
block|{
name|XSTR
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|outputs
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|output_rtx
index|[
literal|0
index|]
argument_list|,
name|body
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noutputs
operator|==
literal|0
operator|&&
name|nclobbers
operator|==
literal|0
condition|)
block|{
comment|/* No output operands: put in a raw ASM_OPERANDS rtx.  */
name|insn
operator|=
name|emit_insn
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|obody
init|=
name|body
decl_stmt|;
name|int
name|num
init|=
name|noutputs
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|num
operator|=
literal|1
expr_stmt|;
name|body
operator|=
name|gen_rtx
argument_list|(
name|PARALLEL
argument_list|,
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num
operator|+
name|nclobbers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each output operand, store a SET.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|output_rtx
index|[
name|i
index|]
argument_list|,
name|gen_rtx
argument_list|(
name|ASM_OPERANDS
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|,
name|argvec
argument_list|,
name|constraints
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|=
name|vol
expr_stmt|;
block|}
comment|/* If there are no outputs (but there are some clobbers) 	 store the bare ASM_OPERANDS into the PARALLEL.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|obody
expr_stmt|;
comment|/* Store (clobber REG) for each clobbered register specified.  */
for|for
control|(
name|tail
operator|=
name|clobbers
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|regname
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|reg_names
index|[]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|regname
argument_list|,
name|reg_names
index|[
name|j
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|error
argument_list|(
literal|"unknown register name `%s' in `asm'"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Use QImode since that's guaranteed to clobber just one reg.  */
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|QImode
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if within a ({...}) grouping, in which case we must    always compute a value for each expr-stmt in case it is the last one.  */
end_comment

begin_decl_stmt
name|int
name|expr_stmts_for_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate RTL to evaluate the expression EXP    and remember it in case this is the VALUE in a ({... VALUE; }) constr.  */
end_comment

begin_function
name|void
name|expand_expr_stmt
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
comment|/* If -W, warn about statements with no side effects,      except for statements explicitly casted to void (e.g. for assert()), and      except inside a ({...}) where they may be useful.  */
if|if
condition|(
name|expr_stmts_for_value
operator|==
literal|0
operator|&&
name|exp
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|void_type_node
operator|)
operator|&&
operator|(
name|extra_warnings
operator|||
name|warn_unused
operator|)
condition|)
name|warning_with_file_and_line
argument_list|(
name|emit_filename
argument_list|,
name|emit_lineno
argument_list|,
literal|"statement with no effect"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_unused
condition|)
name|warn_if_unused_value
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
name|last_expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_syntax_only
condition|)
name|last_expr_value
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|expr_stmts_for_value
condition|?
literal|0
else|:
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Warn if EXP contains any computations whose results are not used.    Return 1 if a warning is printed; 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|warn_if_unused_value
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
case|case
name|NEW_EXPR
case|:
case|case
name|CALL_EXPR
case|:
case|case
name|METHOD_CALL_EXPR
case|:
case|case
name|RTL_EXPR
case|:
case|case
name|WRAPPER_EXPR
case|:
case|case
name|ANTI_WRAPPER_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
comment|/* We don't warn about COND_EXPR because it may be a useful 	 construct if either arm contains a side effect.  */
case|case
name|COND_EXPR
case|:
return|return
literal|0
return|;
comment|/* These kinds of exprs are really stmts.  What to do?  */
case|case
name|LOOP_STMT
case|:
case|case
name|LET_STMT
case|:
case|case
name|IF_STMT
case|:
return|return
literal|0
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
comment|/* In&& or ||, warn if 2nd operand has no side effect.  */
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
if|if
condition|(
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
comment|/* Don't warn about values cast to void.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
literal|0
return|;
comment|/* Assignment to a cast results in a cast of a modify. 	 Don't complain about that.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
return|return
literal|0
return|;
default|default:
name|warning_with_file_and_line
argument_list|(
name|emit_filename
argument_list|,
name|emit_lineno
argument_list|,
literal|"value computed is not used"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Clear out the memory of the last expression evaluated.  */
end_comment

begin_function
name|void
name|clear_last_expr
parameter_list|()
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a statement which will return a value.    Return the RTL_EXPR for this statement expr.    The caller must save that value and pass it to expand_end_stmt_expr.  */
end_comment

begin_function
name|tree
name|expand_start_stmt_expr
parameter_list|()
block|{
name|rtx
name|save
init|=
name|start_sequence
argument_list|()
decl_stmt|;
comment|/* Make the RTL_EXPR node temporary, not momentary,      so that rtl_expr_chain doesn't become garbage.  */
name|int
name|momentary
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
name|tree
name|t
init|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
decl_stmt|;
name|resume_momentary
argument_list|(
name|momentary
argument_list|)
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|save
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|expr_stmts_for_value
operator|++
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Restore the previous state at the end of a statement that returns a value.    Returns a tree node representing the statement's value and the    insns to compute the value.     The nodes of that expression have been freed by now, so we cannot use them.    But we don't want to do that anyway; the expression has already been    evaluated and now we just want to use the value.  So generate a RTL_EXPR    with the proper type and RTL value.     If the last substatement was not an expression,    return something with type `void'.  */
end_comment

begin_function
name|tree
name|expand_end_stmt_expr
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|rtx
name|saved
init|=
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|OK_DEFER_POP
expr_stmt|;
if|if
condition|(
name|last_expr_type
operator|==
literal|0
condition|)
block|{
name|last_expr_type
operator|=
name|void_type_node
expr_stmt|;
name|last_expr_value
operator|=
name|const0_rtx
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|last_expr_type
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|last_expr_value
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|t
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|rtl_expr_chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|rtl_expr_chain
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|(
name|saved
argument_list|)
expr_stmt|;
comment|/* Don't consider deleting this expr or containing exprs at tree level.  */
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Propagate volatility of the actual RTL expr.  */
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
name|volatile_refs_p
argument_list|(
name|last_expr_value
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
name|expr_stmts_for_value
operator|--
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|in_try_block
parameter_list|(
name|level
parameter_list|)
name|int
name|level
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|n
init|=
name|except_stack
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|n
operator|&&
name|n
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|after_label
operator|!=
literal|0
condition|)
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
return|return
name|n
operator|!=
literal|0
return|;
name|level
operator|--
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|in_except_block
parameter_list|(
name|level
parameter_list|)
name|int
name|level
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|n
init|=
name|except_stack
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|n
operator|&&
name|n
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|after_label
operator|==
literal|0
condition|)
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
return|return
name|n
operator|!=
literal|0
return|;
name|level
operator|--
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|in_exception_handler
parameter_list|(
name|level
parameter_list|)
name|int
name|level
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|n
init|=
name|except_stack
decl_stmt|;
while|while
condition|(
name|n
operator|&&
name|level
operator|--
condition|)
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
return|return
name|n
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|int
name|expand_raise
parameter_list|(
name|ex
parameter_list|)
name|tree
name|ex
decl_stmt|;
block|{
name|tree
modifier|*
name|raises_ptr
decl_stmt|;
if|if
condition|(
name|except_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|raises_ptr
operator|=
operator|&
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|raised
expr_stmt|;
if|if
condition|(
operator|!
name|value_member
argument_list|(
name|ex
argument_list|,
operator|*
name|raises_ptr
argument_list|)
condition|)
operator|*
name|raises_ptr
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ex
argument_list|,
operator|*
name|raises_ptr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the start of a try block.     TRY_CLAUSE is the condition to test to enter the try block.  */
end_comment

begin_function
name|void
name|expand_start_try
parameter_list|(
name|try_clause
parameter_list|,
name|exitflag
parameter_list|,
name|escapeflag
parameter_list|)
name|tree
name|try_clause
decl_stmt|;
name|int
name|exitflag
decl_stmt|;
name|int
name|escapeflag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thishandler
init|=
operator|(
expr|struct
name|nesting
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|stmt_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nesting
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make an entry on cond_stack for the cond we are entering.  */
name|thishandler
operator|->
name|next
operator|=
name|except_stack
expr_stmt|;
name|thishandler
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thishandler
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thishandler
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|raised
operator|=
literal|0
expr_stmt|;
name|thishandler
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|handled
operator|=
literal|0
expr_stmt|;
name|thishandler
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|first_insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|thishandler
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|except_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|thishandler
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|unhandled_label
operator|=
literal|0
expr_stmt|;
name|thishandler
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|after_label
operator|=
literal|0
expr_stmt|;
name|thishandler
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|escape_label
operator|=
name|escapeflag
condition|?
name|thishandler
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|except_label
else|:
literal|0
expr_stmt|;
name|thishandler
operator|->
name|exit_label
operator|=
name|exitflag
condition|?
name|gen_label_rtx
argument_list|()
else|:
literal|0
expr_stmt|;
name|except_stack
operator|=
name|thishandler
expr_stmt|;
name|nesting_stack
operator|=
name|thishandler
expr_stmt|;
name|do_jump
argument_list|(
name|try_clause
argument_list|,
name|thishandler
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|except_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End of a TRY block.  Nothing to do for now.  */
end_comment

begin_function
name|void
name|expand_end_try
parameter_list|()
block|{
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|after_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|expand_goto_internal
argument_list|(
name|NULL
argument_list|,
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|after_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_start_except
parameter_list|(
name|exitflag
parameter_list|,
name|escapeflag
parameter_list|)
name|int
name|exitflag
decl_stmt|;
name|int
name|escapeflag
decl_stmt|;
block|{
if|if
condition|(
name|exitflag
condition|)
block|{
name|struct
name|nesting
modifier|*
name|n
decl_stmt|;
comment|/* An `exit' from catch clauses goes out to next exit level, 	 if there is one.  Otherwise, it just goes to the end 	 of the construct.  */
for|for
control|(
name|n
operator|=
name|except_stack
operator|->
name|next
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
if|if
condition|(
name|n
operator|->
name|exit_label
operator|!=
literal|0
condition|)
block|{
name|except_stack
operator|->
name|exit_label
operator|=
name|n
operator|->
name|exit_label
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|except_stack
operator|->
name|exit_label
operator|=
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|after_label
expr_stmt|;
block|}
if|if
condition|(
name|escapeflag
condition|)
block|{
name|struct
name|nesting
modifier|*
name|n
decl_stmt|;
comment|/* An `escape' from catch clauses goes out to next escape level, 	 if there is one.  Otherwise, it just goes to the end 	 of the construct.  */
for|for
control|(
name|n
operator|=
name|except_stack
operator|->
name|next
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
if|if
condition|(
name|n
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|escape_label
operator|!=
literal|0
condition|)
block|{
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|escape_label
operator|=
name|n
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|escape_label
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|escape_label
operator|=
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|after_label
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|except_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|expand_escape_except
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|n
decl_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|except_stack
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
if|if
condition|(
name|n
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|escape_label
operator|!=
literal|0
condition|)
block|{
name|expand_goto_internal
argument_list|(
literal|0
argument_list|,
name|n
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|escape_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|tree
name|expand_end_except
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|n
decl_stmt|;
name|tree
name|raised
init|=
name|NULL_TREE
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|after_label
argument_list|)
expr_stmt|;
name|n
operator|=
name|except_stack
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* Propagate exceptions raised but not handled to next 	 highest level.  */
name|tree
name|handled
init|=
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|raised
decl_stmt|;
if|if
condition|(
name|handled
operator|!=
name|void_type_node
condition|)
block|{
name|tree
name|prev
init|=
name|NULL_TREE
decl_stmt|;
name|raised
operator|=
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|raised
expr_stmt|;
while|while
condition|(
name|handled
condition|)
block|{
name|tree
name|this_raise
decl_stmt|;
for|for
control|(
name|this_raise
operator|=
name|raised
operator|,
name|prev
operator|=
literal|0
init|;
name|this_raise
condition|;
name|this_raise
operator|=
name|TREE_CHAIN
argument_list|(
name|this_raise
argument_list|)
control|)
block|{
if|if
condition|(
name|value_member
argument_list|(
name|TREE_VALUE
argument_list|(
name|this_raise
argument_list|)
argument_list|,
name|handled
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|this_raise
argument_list|)
expr_stmt|;
else|else
block|{
name|raised
operator|=
name|TREE_CHAIN
argument_list|(
name|raised
argument_list|)
expr_stmt|;
if|if
condition|(
name|raised
operator|==
name|NULL_TREE
condition|)
goto|goto
name|nada
goto|;
block|}
block|}
else|else
name|prev
operator|=
name|this_raise
expr_stmt|;
block|}
name|handled
operator|=
name|TREE_CHAIN
argument_list|(
name|handled
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|==
name|NULL_TREE
condition|)
name|prev
operator|=
name|raised
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|n
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|raised
expr_stmt|;
name|nada
label|:
name|n
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|raised
operator|=
name|raised
expr_stmt|;
block|}
block|}
name|POPSTACK
argument_list|(
name|except_stack
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
return|return
name|raised
return|;
block|}
end_function

begin_function
name|int
name|expand_catch
parameter_list|(
name|ex
parameter_list|)
name|tree
name|ex
decl_stmt|;
block|{
name|tree
modifier|*
name|raises_ptr
decl_stmt|;
if|if
condition|(
name|except_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|raises_ptr
operator|=
operator|&
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|handled
expr_stmt|;
if|if
condition|(
operator|*
name|raises_ptr
operator|!=
name|void_type_node
operator|&&
name|ex
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|value_member
argument_list|(
name|ex
argument_list|,
operator|*
name|raises_ptr
argument_list|)
condition|)
operator|*
name|raises_ptr
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ex
argument_list|,
operator|*
name|raises_ptr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|expand_catch_default
parameter_list|()
block|{
if|if
condition|(
name|except_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|handled
operator|=
name|void_type_node
expr_stmt|;
block|}
end_function

begin_function
name|int
name|expand_end_catch
parameter_list|()
block|{
if|if
condition|(
name|except_stack
operator|==
literal|0
operator|||
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|after_label
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|expand_goto_internal
argument_list|(
literal|0
argument_list|,
name|except_stack
operator|->
name|data
operator|.
name|except_stmt
operator|.
name|after_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the start of an if-then.  COND is the expression    whose truth should be tested.     If EXITFLAG is nonzero, this conditional is visible to    `exit_something'.  */
end_comment

begin_function
name|void
name|expand_start_cond
parameter_list|(
name|cond
parameter_list|,
name|exitflag
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|int
name|exitflag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thiscond
init|=
operator|(
expr|struct
name|nesting
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|stmt_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nesting
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make an entry on cond_stack for the cond we are entering.  */
name|thiscond
operator|->
name|next
operator|=
name|cond_stack
expr_stmt|;
name|thiscond
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thiscond
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|after_label
operator|=
literal|0
expr_stmt|;
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|else_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|thiscond
operator|->
name|exit_label
operator|=
name|exitflag
condition|?
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|else_label
else|:
literal|0
expr_stmt|;
name|cond_stack
operator|=
name|thiscond
expr_stmt|;
name|nesting_stack
operator|=
name|thiscond
expr_stmt|;
name|do_jump
argument_list|(
name|cond
argument_list|,
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|else_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the end of an if-then with no else-clause.    Pop the record for it off of cond_stack.  */
end_comment

begin_function
name|void
name|expand_end_cond
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|thiscond
init|=
name|cond_stack
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|else_label
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|cond_stack
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL between the then-clause and the else-clause    of an if-then-else.  */
end_comment

begin_function
name|void
name|expand_start_else
parameter_list|()
block|{
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|after_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|cond_stack
operator|->
name|exit_label
operator|!=
literal|0
condition|)
name|cond_stack
operator|->
name|exit_label
operator|=
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|after_label
expr_stmt|;
name|emit_jump
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|after_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|else_label
condition|)
name|emit_label
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|else_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the end of an if-then-else.    Pop the record for it off of cond_stack.  */
end_comment

begin_function
name|void
name|expand_end_else
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|thiscond
init|=
name|cond_stack
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Note: a syntax error can cause this to be called      without first calling `expand_start_else'.  */
if|if
condition|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|after_label
condition|)
name|emit_label
argument_list|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|after_label
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|cond_stack
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the start of a loop.  EXIT_FLAG is nonzero if this    loop should be exited by `exit_something'.  This is a loop for which    `expand_continue' will jump to the top of the loop.     Make an entry on loop_stack to record the labels associated with    this loop.  */
end_comment

begin_function
name|void
name|expand_start_loop
parameter_list|(
name|exit_flag
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
block|{
specifier|register
name|struct
name|nesting
modifier|*
name|thisloop
init|=
operator|(
expr|struct
name|nesting
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|stmt_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nesting
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make an entry on loop_stack for the loop we are entering.  */
name|thisloop
operator|->
name|next
operator|=
name|loop_stack
expr_stmt|;
name|thisloop
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thisloop
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|=
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
expr_stmt|;
name|thisloop
operator|->
name|exit_label
operator|=
name|exit_flag
condition|?
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
else|:
literal|0
expr_stmt|;
name|loop_stack
operator|=
name|thisloop
expr_stmt|;
name|nesting_stack
operator|=
name|thisloop
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_LOOP_BEG
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like expand_start_loop but for a loop where the continuation point    (for expand_continue_loop) will be specified explicitly.  */
end_comment

begin_function
name|void
name|expand_start_loop_continue_elsewhere
parameter_list|(
name|exit_flag
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
block|{
name|expand_start_loop
argument_list|(
name|exit_flag
argument_list|)
expr_stmt|;
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specify the continuation point for a loop started with    expand_start_loop_continue_elsewhere.    Use this at the point in the code to which a continue statement    should jump.  */
end_comment

begin_function
name|void
name|expand_loop_continue_here
parameter_list|()
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_LOOP_CONT
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a loop.  Generate a jump back to the top and the loop-exit label.    Pop the block off of loop_stack.  */
end_comment

begin_function
name|void
name|expand_end_loop
parameter_list|()
block|{
specifier|register
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
specifier|register
name|rtx
name|start_label
init|=
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* If optimizing, perhaps reorder the loop.  If the loop      starts with a conditional exit, roll that to the end      where it will optimize together with the jump back.  */
if|if
condition|(
name|optimize
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|)
condition|)
block|{
comment|/* Scan insns from the top of the loop looking for a qualified 	 conditional exit.  */
for|for
control|(
name|insn
operator|=
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|)
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|insn
operator|!=
literal|0
condition|)
block|{
comment|/* We found one.  Move everything from there up 	     to the end of the loop, and add a jump into the loop 	     to jump to there.  */
specifier|register
name|rtx
name|newstart_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|emit_label_after
argument_list|(
name|newstart_label
argument_list|,
name|PREV_INSN
argument_list|(
name|start_label
argument_list|)
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|start_label
argument_list|,
name|insn
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|start_label
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|newstart_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|PREV_INSN
argument_list|(
name|newstart_label
argument_list|)
argument_list|)
expr_stmt|;
name|start_label
operator|=
name|newstart_label
expr_stmt|;
block|}
block|}
name|emit_jump
argument_list|(
name|start_label
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_LOOP_END
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|loop_stack
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a jump to the current loop's continue-point.    This is usually the top of the loop, but may be specified    explicitly elsewhere.  If not currently inside a loop,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_continue_loop
parameter_list|()
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loop_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|expand_goto_internal
argument_list|(
literal|0
argument_list|,
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a jump to exit the current loop.  If not currently inside a loop,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_exit_loop
parameter_list|()
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loop_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|expand_goto_internal
argument_list|(
literal|0
argument_list|,
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a conditional jump to exit the current loop if COND    evaluates to zero.  If not currently inside a loop,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_exit_loop_if_false
parameter_list|(
name|cond
parameter_list|)
name|tree
name|cond
decl_stmt|;
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loop_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|do_jump
argument_list|(
name|cond
argument_list|,
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if currently inside a loop.  */
end_comment

begin_function
name|int
name|inside_loop
parameter_list|()
block|{
return|return
name|loop_stack
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate a jump to exit the current loop, conditional, binding contour    or case statement.  Not all such constructs are visible to this function,    only those started with EXIT_FLAG nonzero.  Individual languages use    the EXIT_FLAG parameter to control which kinds of constructs you can    exit this way.     If not currently inside anything that can be exited,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_exit_something
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|n
decl_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|nesting_stack
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|all
control|)
if|if
condition|(
name|n
operator|->
name|exit_label
operator|!=
literal|0
condition|)
block|{
name|expand_goto_internal
argument_list|(
literal|0
argument_list|,
name|n
operator|->
name|exit_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to return from the current function, with no value.    (That is, we do not do anything about returning any value.)  */
end_comment

begin_function
name|void
name|expand_null_return
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|block
init|=
name|block_stack
decl_stmt|;
name|rtx
name|last_insn
init|=
literal|0
decl_stmt|;
comment|/* Does any pending block have cleanups?  */
while|while
condition|(
name|block
operator|&&
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
literal|0
condition|)
name|block
operator|=
name|block
operator|->
name|next
expr_stmt|;
comment|/* If yes, use a goto to return, since that runs cleanups.  */
name|expand_null_return_1
argument_list|(
name|last_insn
argument_list|,
name|block
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a return with no value.  If LAST_INSN is nonzero,    pretend that the return takes place after LAST_INSN.    If USE_GOTO is nonzero then don't use a return instruction;    go to the return label instead.  This causes any cleanups    of pending blocks to be executed normally.  */
end_comment

begin_function
specifier|static
name|void
name|expand_null_return_1
parameter_list|(
name|last_insn
parameter_list|,
name|use_goto
parameter_list|)
name|rtx
name|last_insn
decl_stmt|;
name|int
name|use_goto
decl_stmt|;
block|{
name|rtx
name|end_label
init|=
name|cleanup_label
condition|?
name|cleanup_label
else|:
name|return_label
decl_stmt|;
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
comment|/* PCC-struct return always uses an epilogue.  */
if|if
condition|(
name|current_function_returns_pcc_struct
operator|||
name|use_goto
condition|)
block|{
if|if
condition|(
name|end_label
operator|==
literal|0
condition|)
name|end_label
operator|=
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|expand_goto_internal
argument_list|(
literal|0
argument_list|,
name|end_label
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise output a simple return-insn if one is available,      unless it won't do the job.  */
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|HAVE_return
operator|&&
name|cleanup_label
operator|==
literal|0
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_return
argument_list|()
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Otherwise jump to the epilogue.  */
name|expand_goto_internal
argument_list|(
literal|0
argument_list|,
name|end_label
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL to evaluate the expression RETVAL and return it    from the current function.  */
end_comment

begin_function
name|void
name|expand_return
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
comment|/* If there are any cleanups to be performed, then they will      be inserted following LAST_INSN.  It is desirable      that the last_insn, for such purposes, should be the      last insn before computing the return value.  Otherwise, cleanups      which call functions can clobber the return value.  */
comment|/* ??? rms: I think that is erroneous, because in C++ it would      run destructors on variables that might be used in the subsequent      computation of the return value.  */
name|rtx
name|last_insn
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|;
name|tree
name|retval_rhs
decl_stmt|;
name|int
name|cleanups
decl_stmt|;
name|struct
name|nesting
modifier|*
name|block
decl_stmt|;
comment|/* Are any cleanups needed?  E.g. C++ destructors to be run?  */
name|cleanups
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
block|{
name|cleanups
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|retval_rhs
operator|=
name|retval
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|INIT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|retval_rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
operator|==
name|void_type_node
condition|)
comment|/* Recognize tail-recursive call to void function.  */
name|retval_rhs
operator|=
name|retval
expr_stmt|;
else|else
name|retval_rhs
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Only use `last_insn' if there are cleanups which must be run.  */
if|if
condition|(
name|cleanups
operator|||
name|cleanup_label
operator|!=
literal|0
condition|)
name|last_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* For tail-recursive call to current function,      just jump back to the beginning.      It's unsafe if any auto variable in this function      has its address taken; for simplicity,      require stack frame to be empty.  */
if|if
condition|(
name|optimize
operator|&&
name|retval_rhs
operator|!=
literal|0
operator|&&
name|frame_offset
operator|==
name|STARTING_FRAME_OFFSET
operator|&&
name|TREE_CODE
argument_list|(
name|retval_rhs
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|this_function
comment|/* Finish checking validity, and if valid emit code 	 to set the argument variables for the new call.  */
operator|&&
name|tail_recursion_args
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|this_function
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|tail_recursion_label
operator|==
literal|0
condition|)
block|{
name|tail_recursion_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|tail_recursion_label
argument_list|,
name|tail_recursion_reentry
argument_list|)
expr_stmt|;
block|}
name|expand_goto_internal
argument_list|(
literal|0
argument_list|,
name|tail_recursion_label
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_return
comment|/* This optimization is safe if there are local cleanups      because expand_null_return takes care of them.      ??? I think it should also be safe when there is a cleanup label,      because expand_null_return takes care of them, too.      Any reason why not?  */
if|if
condition|(
name|HAVE_return
operator|&&
name|cleanup_label
operator|==
literal|0
operator|&&
operator|!
name|current_function_returns_pcc_struct
condition|)
block|{
comment|/* If this is  return x == y;  then generate 	 if (x == y) return 1; else return 0; 	 if we can do it with explicit return insns.  */
if|if
condition|(
name|retval_rhs
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|retval_rhs
argument_list|)
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|val
operator|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|this_function
argument_list|)
argument_list|)
expr_stmt|;
name|jumpifnot
argument_list|(
name|retval_rhs
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|val
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|val
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_return */
if|if
condition|(
name|cleanups
operator|&&
name|retval_rhs
operator|!=
literal|0
operator|&&
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|this_function
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|last_insn
decl_stmt|;
comment|/* Calculate the return value into a pseudo reg.  */
name|val
operator|=
name|expand_expr
argument_list|(
name|retval_rhs
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Put the cleanups here.  */
name|last_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Copy the value into hard return reg.  */
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|this_function
argument_list|)
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|this_function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|REG
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|expand_null_return_1
argument_list|(
name|last_insn
argument_list|,
name|cleanups
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No cleanups or no hard reg used; 	 calculate value into hard return reg 	 and let cleanups come after.  */
name|val
operator|=
name|expand_expr
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|val
operator|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|this_function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|REG
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if the end of the generated RTX is not a barrier.    This means code already compiled can drop through.  */
end_comment

begin_function
name|int
name|drop_through_at_end_p
parameter_list|()
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to alter this function's formal parms for a tail-recursive call.    ACTUALS is a list of actual parameter expressions (chain of TREE_LISTs).    FORMALS is the chain of decls of formals.    Return 1 if this can be done;    otherwise return 0 and do not emit any code.  */
end_comment

begin_function
specifier|static
name|int
name|tail_recursion_args
parameter_list|(
name|actuals
parameter_list|,
name|formals
parameter_list|)
name|tree
name|actuals
decl_stmt|,
name|formals
decl_stmt|;
block|{
specifier|register
name|tree
name|a
init|=
name|actuals
decl_stmt|,
name|f
init|=
name|formals
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
modifier|*
name|argvec
decl_stmt|;
comment|/* Check that number and types of actuals are compatible      with the formals.  This is not always true in valid C code.      Also check that no formal needs to be addressable      and that all formals are scalars.  */
comment|/* Also count the args.  */
for|for
control|(
name|a
operator|=
name|actuals
operator|,
name|f
operator|=
name|formals
operator|,
name|i
operator|=
literal|0
init|;
name|a
operator|&&
name|f
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|DECL_MODE
argument_list|(
name|f
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|a
operator|!=
literal|0
operator|||
name|f
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute all the actuals.  */
name|argvec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|actuals
operator|,
name|i
operator|=
literal|0
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|i
operator|++
control|)
name|argvec
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Find which actual values refer to current values of previous formals.      Copy each of them now, before any formal is changed.  */
for|for
control|(
name|a
operator|=
name|actuals
operator|,
name|i
operator|=
literal|0
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|int
name|copy
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|f
operator|=
name|formals
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|,
name|j
operator|++
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|copy
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copy
condition|)
name|argvec
index|[
name|i
index|]
operator|=
name|copy_to_reg
argument_list|(
name|argvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Store the values of the actuals into the formals.  */
for|for
control|(
name|f
operator|=
name|formals
operator|,
name|a
operator|=
name|actuals
operator|,
name|i
operator|=
literal|0
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|,
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DECL_MODE
argument_list|(
name|f
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|argvec
index|[
name|i
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|convert_move
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate the RTL code for entering a binding contour.    The variables are declared one by one, by calls to `expand_decl'.     EXIT_FLAG is nonzero if this construct should be visible to    `exit_something'.  */
end_comment

begin_function
name|void
name|expand_start_bindings
parameter_list|(
name|exit_flag
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
operator|(
expr|struct
name|nesting
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|stmt_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nesting
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|note
init|=
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_BLOCK_BEG
argument_list|)
decl_stmt|;
comment|/* Make an entry on block_stack for the block we are entering.  */
name|thisblock
operator|->
name|next
operator|=
name|block_stack
expr_stmt|;
name|thisblock
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thisblock
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
literal|0
expr_stmt|;
comment|/* We build this even if the cleanups lists are empty      because we rely on having an element in the chain      for each block that is pending.  */
if|if
condition|(
name|block_stack
condition|)
block|{
if|if
condition|(
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
name|NULL_TREE
operator|&&
operator|(
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|==
name|NULL_TREE
operator|||
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|==
name|empty_cleanup_list
operator|)
condition|)
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|=
name|empty_cleanup_list
expr_stmt|;
else|else
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
argument_list|)
expr_stmt|;
block|}
else|else
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|innermost_stack_block
operator|=
name|stack_block_stack
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
operator|=
name|note
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|block_start_count
operator|=
operator|++
name|block_start_count
expr_stmt|;
name|thisblock
operator|->
name|exit_label
operator|=
name|exit_flag
condition|?
name|gen_label_rtx
argument_list|()
else|:
literal|0
expr_stmt|;
name|block_stack
operator|=
name|thisblock
expr_stmt|;
name|nesting_stack
operator|=
name|thisblock
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a USE for any register use in RTL.    This is used with -noreg to mark the extent of lifespan    of any registers used in a user-visible variable's DECL_RTL.  */
end_comment

begin_function
name|void
name|use_variable
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|REG
condition|)
comment|/* This is a register variable.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
operator|!=
name|frame_pointer_rtx
operator|&&
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
operator|!=
name|arg_pointer_rtx
condition|)
comment|/* This is a variable-sized structure.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like use_variable except that it outputs the USEs after INSN    instead of at the end of the insn-chain.  */
end_comment

begin_function
specifier|static
name|void
name|use_variable_after
parameter_list|(
name|rtl
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|rtl
decl_stmt|,
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|REG
condition|)
comment|/* This is a register variable.  */
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|rtl
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
operator|!=
name|frame_pointer_rtx
operator|&&
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
operator|!=
name|arg_pointer_rtx
condition|)
comment|/* This is a variable-sized structure.  */
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL code to terminate a binding contour.    VARS is the chain of VAR_DECL nodes    for the variables bound in this contour.    MARK_ENDS is nonzero if we should put a note at the beginning    and end of this binding contour.     DONT_JUMP_IN is nonzero if it is not valid to jump into this contour.    (That is true automatically if the contour has a saved stack level.)  */
end_comment

begin_function
name|void
name|expand_end_bindings
parameter_list|(
name|vars
parameter_list|,
name|mark_ends
parameter_list|,
name|dont_jump_in
parameter_list|)
name|tree
name|vars
decl_stmt|;
name|int
name|mark_ends
decl_stmt|;
name|int
name|dont_jump_in
decl_stmt|;
block|{
specifier|register
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
specifier|register
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|warn_unused
condition|)
for|for
control|(
name|decl
operator|=
name|vars
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"unused variable `%s'"
argument_list|)
expr_stmt|;
comment|/* Mark the beginning and end of the scope if requested.  */
if|if
condition|(
name|mark_ends
condition|)
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_BLOCK_END
argument_list|)
expr_stmt|;
else|else
comment|/* Get rid of the beginning-mark if we don't make an end-mark.  */
name|NOTE_LINE_NUMBER
argument_list|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
if|if
condition|(
name|thisblock
operator|->
name|exit_label
condition|)
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|thisblock
operator|->
name|exit_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dont_jump_in
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
block|{
name|struct
name|label_chain
modifier|*
name|chain
decl_stmt|;
comment|/* Any labels in this block are no longer valid to go to. 	 Mark them to cause an error message.  */
for|for
control|(
name|chain
operator|=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|TREE_PACKED
argument_list|(
name|chain
operator|->
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If any goto without a fixup came to this label, 	     that must be an error, because gotos without fixups 	     come from outside all saved stack-levels and all cleanups.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|chain
operator|->
name|label
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|chain
operator|->
name|label
argument_list|,
literal|"label `%s' used before containing binding contour"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore stack level in effect before the block      (only if variable-size objects allocated).  */
if|if
condition|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
block|{
comment|/* Perform any cleanups associated with the block.  */
name|int
name|old_expr_stmts_for_value
init|=
name|expr_stmts_for_value
decl_stmt|;
name|rtx
name|old_last_expr_value
init|=
name|last_expr_value
decl_stmt|;
name|tree
name|old_last_expr_type
init|=
name|last_expr_type
decl_stmt|;
comment|/* Don't let cleanups affect ({...}) constructs.  */
name|expr_stmts_for_value
operator|=
literal|0
expr_stmt|;
name|expand_cleanups
argument_list|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|expr_stmts_for_value
operator|=
name|old_expr_stmts_for_value
expr_stmt|;
name|last_expr_value
operator|=
name|old_last_expr_value
expr_stmt|;
name|last_expr_type
operator|=
name|old_last_expr_type
expr_stmt|;
comment|/* Restore the stack level.  */
if|if
condition|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
argument_list|)
expr_stmt|;
comment|/* Any gotos out of this block must also do these things. 	 Also report any gotos with fixups that came to labels in this level.  */
name|fixup_gotos
argument_list|(
name|thisblock
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|,
name|dont_jump_in
argument_list|)
expr_stmt|;
block|}
comment|/* If doing stupid register allocation, make sure lives of all      register variables declared here extend thru end of scope.  */
if|if
condition|(
name|obey_regdecls
condition|)
for|for
control|(
name|decl
operator|=
name|vars
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|rtx
name|rtl
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|rtl
operator|!=
literal|0
condition|)
name|use_variable
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
block|}
comment|/* Restore block_stack level for containing block.  */
name|stack_block_stack
operator|=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|innermost_stack_block
expr_stmt|;
name|POPSTACK
argument_list|(
name|block_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the automatic variable declaration DECL.    (Other kinds of declarations are simply ignored if seen here.)    There is no special support here for C++ constructors.    They should be handled by the proper code in DECL_INITIAL.  */
end_comment

begin_function
name|void
name|expand_decl
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Only automatic variables need any expansion done.      Static and external variables, and external functions,      will be handled by `assemble_variable' (called from finish_decl).      TYPE_DECL and CONST_DECL require nothing.      PARM_DECLs are handled in `assign_parms'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
return|return;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Create the RTL representation for the variable.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
comment|/* Variable with incomplete type.  */
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
comment|/* Error message was already done; now avoid a crash.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|assign_stack_local
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* An initializer is going to decide the size of this array. 	   Until we know the size, represent its address with a reg.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
comment|/* If -ffloat-store, don't put explicit float vars 	      into regs.  */
operator|&&
operator|!
operator|(
name|flag_float_store
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|!
name|TREE_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|obey_regdecls
operator|)
condition|)
block|{
comment|/* Automatic variable that can go in a register.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|mark_reg_pointer
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|oldaddr
init|=
literal|0
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* If we previously made RTL for this decl, it must be an array 	 whose size was determined by the initializer. 	 The old address was a register; set that register now 	 to the proper address.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|oldaddr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Variable of fixed size that goes on the stack.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|assign_stack_local
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldaddr
condition|)
block|{
name|addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|oldaddr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|oldaddr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a memory ref that contains aggregate components, 	 mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If this is in memory because of -ffloat-store, 	 set the volatile bit, to prevent optimizations from 	 undoing the effects.  */
block|if (flag_float_store&& TREE_CODE (type) == REAL_TYPE) 	MEM_VOLATILE_P (DECL_RTL (decl)) = 1;
endif|#
directive|endif
block|}
else|else
comment|/* Dynamic-size object: must push space on the stack.  */
block|{
name|rtx
name|address
decl_stmt|,
name|size
decl_stmt|;
name|frame_pointer_needed
operator|=
literal|1
expr_stmt|;
comment|/* Record the stack pointer on entry to block, if have 	 not already done so.  */
if|if
condition|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|==
literal|0
condition|)
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|=
name|copy_to_reg
argument_list|(
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|stack_block_stack
operator|=
name|thisblock
expr_stmt|;
block|}
comment|/* Compute the variable's size, in bytes.  */
name|size
operator|=
name|expand_expr
argument_list|(
name|convert_units
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Round it up to this machine's required stack boundary.  */
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
comment|/* Avoid extra code if we can prove it's a multiple already.  */
if|if
condition|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|%
name|STACK_BOUNDARY
condition|)
block|{
ifdef|#
directive|ifdef
name|STACK_POINTER_OFFSET
comment|/* Avoid extra code if we can prove that adding STACK_POINTER_OFFSET 	     will not give this address invalid alignment.  */
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|>
operator|(
operator|(
name|STACK_POINTER_OFFSET
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|STACK_BOUNDARY
operator|)
condition|)
name|size
operator|=
name|plus_constant
argument_list|(
name|size
argument_list|,
name|STACK_POINTER_OFFSET
operator|%
operator|(
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size
operator|=
name|round_push
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STACK_BOUNDARY */
comment|/* Make space on the stack, and get an rtx for the address of it.  */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|anti_adjust_stack
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|address
operator|=
name|copy_to_reg
argument_list|(
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_POINTER_OFFSET
block|{
comment|/* If the contents of the stack pointer reg are offset from the 	   actual top-of-stack address, add the offset here.  */
name|rtx
name|sp_offset
init|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|STACK_POINTER_OFFSET
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|int
name|direction
init|=
literal|1
decl_stmt|;
else|#
directive|else
comment|/* not STACK_GROWS_DOWNWARD */
name|int
name|direction
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* not STACK_GROWS_DOWNWARD */
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|>
operator|(
operator|(
name|STACK_POINTER_OFFSET
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|STACK_BOUNDARY
operator|)
condition|)
name|sp_offset
operator|=
name|plus_constant
argument_list|(
name|sp_offset
argument_list|,
operator|(
name|STACK_POINTER_OFFSET
operator|%
operator|(
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
name|direction
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STACK_BOUNDARY */
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|address
argument_list|,
name|sp_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STACK_POINTER_OFFSET */
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
name|anti_adjust_stack
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Some systems require a particular insn to refer to the stack 	 to make the pages exist.  */
ifdef|#
directive|ifdef
name|HAVE_probe
if|if
condition|(
name|HAVE_probe
condition|)
name|emit_insn
argument_list|(
name|gen_probe
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reference the variable indirect through that rtx.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If doing stupid register allocation, make sure life of any      register variable starts here, at the start of its scope.  */
if|if
condition|(
name|obey_regdecls
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to perform the initialization of a declaration DECL.  */
end_comment

begin_function
name|void
name|expand_decl_init
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Compute and store the initial value now.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
condition|)
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
name|emit_line_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* CLEANUP is an expression to be executed at exit from this binding contour;    for example, in C++, it might call the destructor for this variable.     If CLEANUP contains any SAVE_EXPRs, then you must preevaluate them    either before or after calling `expand_decl' but before compiling    any subsequent expressions.  This is because CLEANUP may be expanded    more than once, on different branches of execution.    For the same reason, CLEANUP may not contain a CALL_EXPR    except as its topmost node--else `preexpand_calls' would get confused.     If CLEANUP is nonzero and DECL is zero, we record a cleanup    that is not associated with any particular variable.     Return 0 if such an expansion is invalid.  Otherwise, return 1.  */
end_comment

begin_function
name|int
name|expand_decl_cleanup
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|)
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
comment|/* Record the cleanup if there is one.  */
if|if
condition|(
name|cleanup
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|thisblock
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
name|temp_tree_cons
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
comment|/* If this block has a cleanup, it belongs in stack_block_stack.  */
name|stack_block_stack
operator|=
name|thisblock
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* DECL is an anonymous union.  CLEANUP is a cleanup for DECL.    DECL_ELTS is the list of elements that belong to DECL's type.    In each, the TREE_VALUE is a VAR_DECL, and the TREE_PURPOSE a cleanup.  */
end_comment

begin_function
name|void
name|expand_anon_union_decl
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|,
name|decl_elts
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|cleanup
decl_stmt|,
name|decl_elts
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|x
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|decl_elts
condition|)
block|{
name|tree
name|decl_elt
init|=
name|TREE_VALUE
argument_list|(
name|decl_elts
argument_list|)
decl_stmt|;
name|tree
name|cleanup_elt
init|=
name|TREE_PURPOSE
argument_list|(
name|decl_elts
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_elt
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* @@ calling `change_address' means that we cannot 	     be at top-level, since `memory_address' might try 	     to kick this address into a register, which won't 	     work.  Will this work?  */
name|rtx
name|new
init|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|tmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|new
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|tmode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Record the cleanup if there is one.  */
if|if
condition|(
name|cleanup
operator|!=
literal|0
condition|)
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
name|temp_tree_cons
argument_list|(
name|decl_elt
argument_list|,
name|cleanup_elt
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
name|decl_elts
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_elts
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a list of cleanups LIST.    Elements may be expressions or may be nested lists.     If DONT_DO is nonnull, then any list-element    whose TREE_PURPOSE matches DONT_DO is omitted.    This is sometimes used to avoid a cleanup associated with    a value that is being returned out of the scope.  */
end_comment

begin_function
specifier|static
name|void
name|expand_cleanups
parameter_list|(
name|list
parameter_list|,
name|dont_do
parameter_list|)
name|tree
name|list
decl_stmt|;
name|tree
name|dont_do
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|dont_do
operator|==
literal|0
operator|||
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|!=
name|dont_do
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|expand_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|dont_do
argument_list|)
expr_stmt|;
else|else
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a list of cleanups for a goto fixup.    The expansion is put into the insn chain after the insn *BEFORE_JUMP    and *BEFORE_JUMP is set to the insn that now comes before the jump.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_cleanups
parameter_list|(
name|list
parameter_list|,
name|before_jump
parameter_list|)
name|tree
name|list
decl_stmt|;
name|rtx
modifier|*
name|before_jump
decl_stmt|;
block|{
name|rtx
name|beyond_jump
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|new_before_jump
decl_stmt|;
name|expand_cleanups
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|new_before_jump
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|beyond_jump
operator|!=
name|new_before_jump
condition|)
comment|/* If cleanups expand to nothing, don't reorder.  */
name|reorder_insns
argument_list|(
name|NEXT_INSN
argument_list|(
name|beyond_jump
argument_list|)
argument_list|,
name|new_before_jump
argument_list|,
operator|*
name|before_jump
argument_list|)
expr_stmt|;
operator|*
name|before_jump
operator|=
name|new_before_jump
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move all cleanups from the current block_stack    to the containing block_stack, where they are assumed to    have been created.  If anything can cause a temporary to    be created, but not expanded for more than one level of    block_stacks, then this code will have to change.  */
end_comment

begin_function
name|void
name|move_cleanups_up
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|block
init|=
name|block_stack
decl_stmt|;
name|struct
name|nesting
modifier|*
name|outer
init|=
name|block
operator|->
name|next
decl_stmt|;
name|outer
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
name|chainon
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|outer
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|this_contour_has_cleanups_p
parameter_list|()
block|{
return|return
name|block_stack
operator|&&
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Enter a case (Pascal) or switch (C) statement.    Push a block onto case_stack and nesting_stack    to accumulate the case-labels that are seen    and to record the labels generated for the statement.     EXIT_FLAG is nonzero if `exit_something' should exit this case stmt.    Otherwise, this construct is transparent for `exit_something'.     EXPR is the index-expression to be dispatched on.    TYPE is its nominal type.  We could simply convert EXPR to this type,    but instead we take short cuts.  */
end_comment

begin_function
name|void
name|expand_start_case
parameter_list|(
name|exit_flag
parameter_list|,
name|expr
parameter_list|,
name|type
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|nesting
modifier|*
name|thiscase
init|=
operator|(
expr|struct
name|nesting
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|stmt_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nesting
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make an entry on case_stack for the case we are entering.  */
name|thiscase
operator|->
name|next
operator|=
name|case_stack
expr_stmt|;
name|thiscase
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thiscase
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thiscase
operator|->
name|exit_label
operator|=
name|exit_flag
condition|?
name|gen_label_rtx
argument_list|()
else|:
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
operator|=
name|expr
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
operator|=
name|type
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|num_ranges
operator|=
literal|0
expr_stmt|;
name|case_stack
operator|=
name|thiscase
expr_stmt|;
name|nesting_stack
operator|=
name|thiscase
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Make sure case_stmt.start points to something that won't      need any transformation before expand_end_case.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a "dummy case statement" within which case labels are invalid    and are not connected to any larger real case statement.    This can be used if you don't want to let a case statement jump    into the middle of certain kinds of constructs.  */
end_comment

begin_function
name|void
name|expand_start_case_dummy
parameter_list|()
block|{
specifier|register
name|struct
name|nesting
modifier|*
name|thiscase
init|=
operator|(
expr|struct
name|nesting
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|stmt_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nesting
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make an entry on case_stack for the dummy.  */
name|thiscase
operator|->
name|next
operator|=
name|case_stack
expr_stmt|;
name|thiscase
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thiscase
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thiscase
operator|->
name|exit_label
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|num_ranges
operator|=
literal|0
expr_stmt|;
name|case_stack
operator|=
name|thiscase
expr_stmt|;
name|nesting_stack
operator|=
name|thiscase
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a dummy case statement.  */
end_comment

begin_function
name|void
name|expand_end_case_dummy
parameter_list|()
block|{
name|POPSTACK
argument_list|(
name|case_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Accumulate one case or default label inside a case or switch statement.    VALUE is the value of the case (a null pointer, for a default label).     If not currently inside a case or switch statement, return 1 and do    nothing.  The caller will print a language-specific error message.    If VALUE is a duplicate or overlaps, return 2 and do nothing.    If VALUE is out of range, return 3 and do nothing.    Return 0 on success.     Extended to handle range statements, should they ever    be adopted.  */
end_comment

begin_function
name|int
name|pushcase
parameter_list|(
name|value
parameter_list|,
name|label
parameter_list|)
specifier|register
name|tree
name|value
decl_stmt|;
specifier|register
name|tree
name|label
decl_stmt|;
block|{
specifier|register
name|struct
name|case_node
modifier|*
modifier|*
name|l
decl_stmt|;
specifier|register
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
name|tree
name|nominal_type
decl_stmt|;
comment|/* Fail if not inside a real case statement.  */
if|if
condition|(
operator|!
operator|(
name|case_stack
operator|&&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|)
condition|)
return|return
literal|1
return|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
argument_list|)
expr_stmt|;
name|nominal_type
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
expr_stmt|;
comment|/* If the index is erroneous, avoid more problems: pretend to succeed.  */
if|if
condition|(
name|index_type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
comment|/* Convert VALUE to the type in which the comparisons are nominally done.  */
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
name|value
operator|=
name|convert
argument_list|(
name|nominal_type
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Fail if this value is out of range for the actual type of the index      (which may be narrower than NOMINAL_TYPE).  */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|index_type
argument_list|)
condition|)
return|return
literal|3
return|;
comment|/* Fail if this is a duplicate or overlaps another entry.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|!=
literal|0
condition|)
return|return
literal|2
return|;
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
name|label
expr_stmt|;
block|}
else|else
block|{
comment|/* Find the elt in the chain before which to insert the new value, 	 to keep the chain sorted in increasing order. 	 But report an error if this element is a duplicate.  */
for|for
control|(
name|l
operator|=
operator|&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
comment|/* Keep going past elements distinctly less than VALUE.  */
operator|*
name|l
operator|!=
literal|0
operator|&&
name|tree_int_cst_lt
argument_list|(
operator|(
operator|*
name|l
operator|)
operator|->
name|high
argument_list|,
name|value
argument_list|)
condition|;
name|l
operator|=
operator|&
operator|(
operator|*
name|l
operator|)
operator|->
name|right
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|l
condition|)
block|{
comment|/* Element we will insert before must be distinctly greater; 	     overlap means error.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
operator|(
operator|*
name|l
operator|)
operator|->
name|low
argument_list|)
condition|)
return|return
literal|2
return|;
block|}
comment|/* Add this label to the chain, and succeed. 	 Copy VALUE so it is on temporary rather than momentary 	 obstack and will thus survive till the end of the case statement.  */
name|n
operator|=
operator|(
expr|struct
name|case_node
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|case_node
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|right
operator|=
operator|*
name|l
expr_stmt|;
name|n
operator|->
name|high
operator|=
name|n
operator|->
name|low
operator|=
name|copy_node
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|n
operator|->
name|code_label
operator|=
name|label
expr_stmt|;
name|n
operator|->
name|test_label
operator|=
literal|0
expr_stmt|;
operator|*
name|l
operator|=
name|n
expr_stmt|;
block|}
name|expand_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like pushcase but this case applies to all values    between VALUE1 and VALUE2 (inclusive).    The return value is the same as that of pushcase    but there is one additional error code:    4 means the specified range was empty.     Note that this does not currently work, since expand_end_case    has yet to be extended to handle RANGE_EXPRs.  */
end_comment

begin_function
name|int
name|pushcase_range
parameter_list|(
name|value1
parameter_list|,
name|value2
parameter_list|,
name|label
parameter_list|)
specifier|register
name|tree
name|value1
decl_stmt|,
name|value2
decl_stmt|;
specifier|register
name|tree
name|label
decl_stmt|;
block|{
specifier|register
name|struct
name|case_node
modifier|*
modifier|*
name|l
decl_stmt|;
specifier|register
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
name|tree
name|nominal_type
decl_stmt|;
comment|/* Fail if not inside a real case statement.  */
if|if
condition|(
operator|!
operator|(
name|case_stack
operator|&&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|)
condition|)
return|return
literal|1
return|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
argument_list|)
expr_stmt|;
name|nominal_type
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
expr_stmt|;
comment|/* If the index is erroneous, avoid more problems: pretend to succeed.  */
if|if
condition|(
name|index_type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
comment|/* Convert VALUEs to type in which the comparisons are nominally done.  */
if|if
condition|(
name|value1
operator|!=
literal|0
condition|)
name|value1
operator|=
name|convert
argument_list|(
name|nominal_type
argument_list|,
name|value1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value2
operator|!=
literal|0
condition|)
name|value2
operator|=
name|convert
argument_list|(
name|nominal_type
argument_list|,
name|value2
argument_list|)
expr_stmt|;
comment|/* Fail if these values are out of range.  */
if|if
condition|(
name|value1
operator|!=
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|value1
argument_list|,
name|index_type
argument_list|)
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|value2
operator|!=
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|value2
argument_list|,
name|index_type
argument_list|)
condition|)
return|return
literal|3
return|;
comment|/* Fail if the range is empty.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value2
argument_list|,
name|value1
argument_list|)
condition|)
return|return
literal|4
return|;
comment|/* If the bounds are equal, turn this into the one-value case.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|)
condition|)
return|return
name|pushcase
argument_list|(
name|value1
argument_list|,
name|label
argument_list|)
return|;
comment|/* Find the elt in the chain before which to insert the new value,      to keep the chain sorted in increasing order.      But report an error if this element is a duplicate.  */
for|for
control|(
name|l
operator|=
operator|&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
comment|/* Keep going past elements distinctly less than this range.  */
operator|*
name|l
operator|!=
literal|0
operator|&&
name|tree_int_cst_lt
argument_list|(
operator|(
operator|*
name|l
operator|)
operator|->
name|high
argument_list|,
name|value1
argument_list|)
condition|;
name|l
operator|=
operator|&
operator|(
operator|*
name|l
operator|)
operator|->
name|right
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|l
condition|)
block|{
comment|/* Element we will insert before must be distinctly greater; 	 overlap means error.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|value2
argument_list|,
operator|(
operator|*
name|l
operator|)
operator|->
name|low
argument_list|)
condition|)
return|return
literal|2
return|;
block|}
comment|/* Add this label to the chain, and succeed.      Copy VALUE1, VALUE2 so they are on temporary rather than momentary      obstack and will thus survive till the end of the case statement.  */
name|n
operator|=
operator|(
expr|struct
name|case_node
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|case_node
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|right
operator|=
operator|*
name|l
expr_stmt|;
name|n
operator|->
name|low
operator|=
name|copy_node
argument_list|(
name|value1
argument_list|)
expr_stmt|;
name|n
operator|->
name|high
operator|=
name|copy_node
argument_list|(
name|value2
argument_list|)
expr_stmt|;
name|n
operator|->
name|code_label
operator|=
name|label
expr_stmt|;
name|n
operator|->
name|test_label
operator|=
literal|0
expr_stmt|;
operator|*
name|l
operator|=
name|n
expr_stmt|;
name|expand_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|num_ranges
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check that all enumeration literals are covered by the case    expressions of a switch.  Also, warn if there are any extra    switch cases that are *not* elements of the enumerated type. */
end_comment

begin_function
name|void
name|check_for_full_enumeration_handling
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
specifier|register
name|tree
name|chain
decl_stmt|;
comment|/* The time complexity of this loop is currently O(N * M), with      N being the number of enumerals in the enumerated type, and       M being the number of case expressions in the switch. */
for|for
control|(
name|chain
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
comment|/* Find a match between enumeral and case expression, if possible. 	 Quit looking when we've gone too far (since case expressions 	 are kept sorted in ascending order).  Warn about enumerals not 	 handled in the switch statement case expression list. */
for|for
control|(
name|n
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
operator|&&
name|tree_int_cst_lt
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|n
operator|&&
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"enumerated value `%s' not handled in switch"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now we go the other way around; we warn if there are case       expressions that don't correspond to enumerals.  This can      occur since C and C++ don't enforce type-checking of       assignments to enumeration variables. */
for|for
control|(
name|n
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
for|for
control|(
name|chain
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|chain
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
name|warning
argument_list|(
literal|"case value `%d' not in enumerated type `%s'"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Terminate a case (Pascal) or switch (C) statement    in which CASE_INDEX is the expression to be tested.    Generate the code to test it and jump to the right place.  */
end_comment

begin_function
name|void
name|expand_end_case
parameter_list|(
name|orig_index
parameter_list|)
name|tree
name|orig_index
decl_stmt|;
block|{
name|tree
name|minval
decl_stmt|,
name|maxval
decl_stmt|,
name|range
decl_stmt|;
name|rtx
name|default_label
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
name|int
name|count
decl_stmt|;
name|rtx
name|index
decl_stmt|;
name|rtx
name|table_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|int
name|ncases
decl_stmt|;
name|rtx
modifier|*
name|labelvec
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|before_case
decl_stmt|;
specifier|register
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|case_stack
decl_stmt|;
name|tree
name|index_expr
init|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
argument_list|)
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* An ERROR_MARK occurs for various reasons including invalid data type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* If switch expression was an enumerated type, check that all 	 enumeration literals are covered by the cases. 	 No sense trying this if there's a default case, however.  */
if|if
condition|(
operator|!
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_index
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|warn_switch
condition|)
name|check_for_full_enumeration_handling
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we don't have a default-label, create one here, 	 after the body of the switch.  */
if|if
condition|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|==
literal|0
condition|)
block|{
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|expand_label
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
argument_list|)
expr_stmt|;
block|}
name|default_label
operator|=
name|label_rtx
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
argument_list|)
expr_stmt|;
name|before_case
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Simplify the case-list before we count it.  */
name|group_case_nodes
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|)
expr_stmt|;
comment|/* Get upper and lower bounds of case values. 	 Also convert all the case values to the index expr's data type.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
comment|/* Check low and high label values are integers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
operator|->
name|low
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
operator|->
name|high
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n
operator|->
name|low
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
argument_list|,
name|n
operator|->
name|low
argument_list|)
expr_stmt|;
name|n
operator|->
name|high
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
argument_list|,
name|n
operator|->
name|high
argument_list|)
expr_stmt|;
comment|/* Count the elements and track the largest and smallest 	     of them (treating them as signed even if they are not).  */
if|if
condition|(
name|count
operator|++
operator|==
literal|0
condition|)
block|{
name|minval
operator|=
name|n
operator|->
name|low
expr_stmt|;
name|maxval
operator|=
name|n
operator|->
name|high
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|minval
argument_list|)
condition|)
name|minval
operator|=
name|n
operator|->
name|low
expr_stmt|;
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
name|maxval
operator|=
name|n
operator|->
name|high
expr_stmt|;
block|}
comment|/* A range counts double, since it requires two compares.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
block|}
comment|/* Compute span of values.  */
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|range
operator|=
name|combine
argument_list|(
name|MINUS_EXPR
argument_list|,
name|maxval
argument_list|,
name|minval
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
comment|/* If range of values is much bigger than number of values, 	 make a sequence of conditional branches instead of a dispatch. 	 If the switch-index is a constant, do it this way 	 because we can optimize it.  */
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|range
argument_list|)
operator|!=
literal|0
ifdef|#
directive|ifdef
name|HAVE_casesi
operator|||
name|count
operator|<
literal|4
else|#
directive|else
comment|/* If machine does not have a case insn that compares the 		  bounds, this means extra overhead for dispatch tables 		  which raises the threshold for using them.  */
operator|||
name|count
operator|<
literal|5
endif|#
directive|endif
operator|||
call|(
name|unsigned
call|)
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|range
argument_list|)
argument_list|)
operator|>
literal|10
operator|*
name|count
operator|||
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the index is a short or char that we do not have 	     an insn to handle comparisons directly, convert it to 	     a full integer now, rather than letting each comparison 	     generate the conversion.  */
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|index
argument_list|)
operator|==
name|QImode
operator|||
name|GET_MODE
argument_list|(
name|index
argument_list|)
operator|==
name|HImode
operator|)
operator|&&
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|index
argument_list|)
index|]
operator|.
name|insn_code
operator|==
name|CODE_FOR_nothing
operator|)
condition|)
name|index
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|index
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|index
operator|=
name|protect_from_queue
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|MEM
condition|)
name|index
operator|=
name|copy_to_reg
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|CONST_INT
operator|||
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Make a tree node with the proper constant value 		 if we don't already have one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|index_expr
operator|=
name|build_int_2
argument_list|(
name|INTVAL
argument_list|(
name|index
argument_list|)
argument_list|,
operator|!
name|unsignedp
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|>=
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|index_expr
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
argument_list|,
name|index_expr
argument_list|)
expr_stmt|;
block|}
comment|/* For constant index expressions we need only 		 issue a unconditional branch to the appropriate 		 target code.  The job of removing any unreachable 		 code is left to the optimisation phase if the 		 "-O" option is specified.  */
for|for
control|(
name|n
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|index_expr
argument_list|,
name|n
operator|->
name|low
argument_list|)
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|index_expr
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|n
condition|)
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|n
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the index expression is not constant we generate 		 a binary decision tree to select the appropriate 		 target code.  This is done as follows:  		 The list of cases is rearranged into a binary tree, 		 nearly optimal assuming equal probability for each case.  		 The tree is transformed into RTL, eliminating 		 redundant test conditions at the same time.  		 If program flow could reach the end of the 		 decision tree an unconditional jump to the 		 default code is emitted.  */
if|if
condition|(
name|optimize
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_index
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
name|estimate_case_costs
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
name|default_label
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_jump_if_reachable
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_casesi
comment|/* Convert the index to SImode.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|index_expr
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|minval
operator|=
name|integer_zero_node
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
argument_list|)
operator|!=
name|SImode
condition|)
name|index_expr
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|index_expr
argument_list|)
expr_stmt|;
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|index
operator|=
name|protect_from_queue
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_casesi
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|minval
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|range
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAVE_tablejump
name|index_expr
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|index
operator|=
name|protect_from_queue
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_tablejump
argument_list|(
name|index
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|range
argument_list|)
argument_list|)
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
else|#
directive|else
name|lossage
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_tablejump */
endif|#
directive|endif
comment|/* not HAVE_casesi */
comment|/* Get table of labels to jump to, in order of case index.  */
name|ncases
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|range
argument_list|)
operator|+
literal|1
expr_stmt|;
name|labelvec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|ncases
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|labelvec
argument_list|,
name|ncases
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
specifier|register
name|int
name|i
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|minval
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|minval
argument_list|)
operator|<=
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
condition|)
name|labelvec
index|[
name|i
operator|++
index|]
operator|=
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|label_rtx
argument_list|(
name|n
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the gaps with the default.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncases
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|labelvec
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|labelvec
index|[
name|i
index|]
operator|=
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
comment|/* Output the table */
name|emit_label
argument_list|(
name|table_label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CASE_VECTOR_PC_RELATIVE
name|emit_jump_insn
argument_list|(
name|gen_rtx
argument_list|(
name|ADDR_DIFF_VEC
argument_list|,
name|CASE_VECTOR_MODE
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|table_label
argument_list|)
argument_list|,
name|gen_rtvec_v
argument_list|(
name|ncases
argument_list|,
name|labelvec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_jump_insn
argument_list|(
name|gen_rtx
argument_list|(
name|ADDR_VEC
argument_list|,
name|CASE_VECTOR_MODE
argument_list|,
name|gen_rtvec_v
argument_list|(
name|ncases
argument_list|,
name|labelvec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the case insn drops through the table, 	     after the table we must jump to the default-label. 	     Otherwise record no drop-through after the table.  */
ifdef|#
directive|ifdef
name|CASE_DROPS_THROUGH
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_barrier
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|reorder_insns
argument_list|(
name|NEXT_INSN
argument_list|(
name|before_case
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thiscase
operator|->
name|exit_label
condition|)
name|emit_label
argument_list|(
name|thiscase
operator|->
name|exit_label
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|case_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See case.c for CASE-handling code.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Allocate fixed slots in the stack frame of the current function.  */
end_comment

begin_comment
comment|/* Return size needed for stack frame based on slots so far allocated.  */
end_comment

begin_function
name|int
name|get_frame_size
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
return|return
operator|-
name|frame_offset
operator|+
name|STARTING_FRAME_OFFSET
return|;
else|#
directive|else
return|return
name|frame_offset
operator|-
name|STARTING_FRAME_OFFSET
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Allocate a stack slot of SIZE bytes and return a MEM rtx for it    with machine mode MODE.  */
end_comment

begin_function
name|rtx
name|assign_stack_local
parameter_list|(
name|mode
parameter_list|,
name|size
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|bigend_correction
init|=
literal|0
decl_stmt|;
name|frame_pointer_needed
operator|=
literal|1
expr_stmt|;
comment|/* Make each stack slot a multiple of the main allocation unit.  */
name|size
operator|=
operator|(
operator|(
operator|(
name|size
operator|+
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* On a big-endian machine, if we are allocating more space than we will use,      use the least significant bytes of those that are allocated.  */
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
name|bigend_correction
operator|=
name|size
operator|-
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|frame_offset
operator|-=
name|size
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|frame_pointer_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|frame_offset
operator|+
name|bigend_correction
operator|)
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FRAME_GROWS_DOWNWARD
name|frame_offset
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
condition|)
name|invalid_stack_slot
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|stack_slot_list
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|stack_slot_list
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Retroactively move an auto variable from a register to a stack slot.    This is done when an address-reference to the variable is seen.  */
end_comment

begin_function
name|void
name|put_var_into_stack
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|rtx
name|reg
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|new
decl_stmt|;
comment|/* No need to do anything if decl has no rtx yet      since in that case caller is setting TREE_ADDRESSABLE      and a stack slot will be assigned when the rtl is made.  */
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|new
operator|=
name|parm_stack_loc
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
name|new
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* `volatil' bit means one thing for MEMs, another entirely for REGs.  */
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PUT_CODE
argument_list|(
name|reg
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components,      mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|reg
argument_list|)
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
expr_stmt|;
name|fixup_var_refs
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|fixup_var_refs
parameter_list|(
name|var
parameter_list|)
name|rtx
name|var
decl_stmt|;
block|{
specifier|extern
name|rtx
name|sequence_stack
decl_stmt|;
name|rtx
name|stack
init|=
name|sequence_stack
decl_stmt|;
name|tree
name|pending
decl_stmt|;
name|stack
operator|=
name|sequence_stack
expr_stmt|;
comment|/* Must scan all insns for stack-refs that exceed the limit.  */
name|fixup_var_refs_insns
argument_list|(
name|var
argument_list|,
name|get_insns
argument_list|()
argument_list|,
name|stack
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|stack
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|push_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fixup_var_refs_insns
argument_list|(
name|var
argument_list|,
name|XEXP
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|stack
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Update remembered end of sequence 	 in case we added an insn at the end.  */
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|stack
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Scan all waiting RTL_EXPRs too.  */
for|for
control|(
name|pending
operator|=
name|rtl_expr_chain
init|;
name|pending
condition|;
name|pending
operator|=
name|TREE_CHAIN
argument_list|(
name|pending
argument_list|)
control|)
block|{
name|rtx
name|seq
init|=
name|RTL_EXPR_SEQUENCE
argument_list|(
name|TREE_VALUE
argument_list|(
name|pending
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
name|const0_rtx
operator|&&
name|seq
operator|!=
literal|0
condition|)
block|{
name|push_to_sequence
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|fixup_var_refs_insns
argument_list|(
name|var
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Scan the insn-chain starting with INSN for refs to VAR    and fix them up.  TOPLEVEL is nonzero if this chain is the    main chain of insns for the current function.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_var_refs_insns
parameter_list|(
name|var
parameter_list|,
name|insn
parameter_list|,
name|toplevel
parameter_list|)
name|rtx
name|var
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|toplevel
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* The insn to load VAR from a home in the arglist 	     is now a no-op.  When we see it, just delete it.  */
if|if
condition|(
name|toplevel
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|var
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|var
argument_list|)
condition|)
block|{
name|next
operator|=
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|last_parm_insn
condition|)
name|last_parm_insn
operator|=
name|PREV_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
else|else
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Also fix up any invalid exprs in the REG_NOTES of this insn. 	     But don't touch other insns referred to by reg-notes; 	     we will get them elsewhere.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|!=
name|INSN_LIST
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|walk_fixup_memory_subreg
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|rtx
name|fixup_var_refs_1
parameter_list|(
name|var
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|)
specifier|register
name|rtx
name|var
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|rtx
name|tem
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
if|if
condition|(
name|var
operator|==
name|x
condition|)
block|{
name|x
operator|=
name|fixup_stack_1
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put new insn before a CALL, before any USEs before it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
while|while
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tem
argument_list|,
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
break|break;
case|case
name|REG
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
return|return
name|x
return|;
case|case
name|SIGN_EXTRACT
case|:
case|case
name|ZERO_EXTRACT
case|:
comment|/* Note that in some cases those types of expressions are altered 	 by optimize_bit_field, and do not survive to get here.  */
case|case
name|SUBREG
case|:
name|tem
operator|=
name|x
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
name|var
condition|)
block|{
name|x
operator|=
name|fixup_stack_1
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|fixup_memory_subreg
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tem
argument_list|,
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
break|break;
case|case
name|SET
case|:
comment|/* First do special simplification of bit-field references.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|optimize_bit_field
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|optimize_bit_field
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|outerdest
init|=
name|dest
decl_stmt|;
name|rtx
name|outersrc
init|=
name|src
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If VAR does not appear at the top level of the SET 	   just scan the lower levels of the tree.  */
if|if
condition|(
name|src
operator|!=
name|var
operator|&&
name|dest
operator|!=
name|var
condition|)
break|break;
comment|/* Clean up (SUBREG:SI (MEM:mode ...) 0) 	   that may appear inside a SIGN_EXTRACT or ZERO_EXTRACT. 	   This was legitimate when the MEM was a REG.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|outerdest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|outerdest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|var
condition|)
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
operator|=
name|fixup_memory_subreg
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|outersrc
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|outersrc
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|var
condition|)
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
operator|=
name|fixup_memory_subreg
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Make sure that the machine's SIGN_EXTRACT and ZERO_EXTRACT insns 	   accept a memory operand.  */
ifdef|#
directive|ifdef
name|HAVE_extzv
if|if
condition|(
name|GET_CODE
argument_list|(
name|outersrc
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
operator|=
name|src
operator|=
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extv
if|if
condition|(
name|GET_CODE
argument_list|(
name|outersrc
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|&&
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
operator|=
name|src
operator|=
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_insv
if|if
condition|(
name|GET_CODE
argument_list|(
name|outerdest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|tem
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tem
argument_list|,
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|dest
operator|=
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
operator|=
name|tem
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Make sure a MEM inside a SIGN_EXTRACT has QImode 	   since that's what bit-field insns want.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|outerdest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|outerdest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|QImode
condition|)
block|{
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
comment|/* Adjust the address so the bit field starts within the byte 	       addressed.  This helps certain optimization patterns.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|offsettable_memref_p
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|count
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
operator|=
name|adj_offsettable_operand
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|count
operator|/
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|count
operator|%
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|outersrc
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|outersrc
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|QImode
condition|)
block|{
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
comment|/* Adjust the address so the bit field starts within the byte 	       addressed.  This helps certain optimization patterns.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|offsettable_memref_p
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|count
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
operator|=
name|adj_offsettable_operand
argument_list|(
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|count
operator|/
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|outersrc
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|count
operator|%
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* STRICT_LOW_PART is a no-op on memory references 	   and it can cause combinations to be unrecognizable, 	   so eliminate it.  */
if|if
condition|(
name|dest
operator|==
name|var
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* An insn to copy VAR into or out of a register 	   must be left alone, to avoid an infinite loop here. 	   But do fix up the address of VAR's stack slot if nec, 	   and fix up SUBREGs containing VAR 	   (since they are now memory subregs).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
condition|)
block|{
if|if
condition|(
name|src
operator|==
name|var
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|fixup_memory_subreg
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|var
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|fixup_memory_subreg
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|fixup_stack_1
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
return|;
block|}
comment|/* Otherwise, storing into VAR must be handled specially 	   by storing into a temporary and copying that into VAR 	   with a new insn after this one.  */
if|if
condition|(
name|dest
operator|==
name|var
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|rtx
name|fixeddest
decl_stmt|;
name|tem
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* STRICT_LOW_PART can be discarded, around a MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert (SUBREG (MEM)) to a MEM in a changed mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SUBREG
condition|)
name|tem
operator|=
name|fixup_memory_subreg
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fixeddest
operator|=
name|fixup_stack_1
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|fixeddest
argument_list|,
name|temp
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
comment|/* Nothing special about this RTX; fix its operands.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given X, an rtx of the form (SUBREG:m1 (MEM:m2 addr)),    return an rtx (MEM:m1 newaddr) which is equivalent.    If any insns must be emitted to compute NEWADDR, put them before INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|fixup_memory_subreg
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|saved
decl_stmt|,
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
name|offset
operator|+=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|change_address
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
return|;
name|saved
operator|=
name|start_sequence
argument_list|()
expr_stmt|;
name|result
operator|=
name|change_address
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_sequence
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|(
name|saved
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Do fixup_memory_subreg on all (SUBREG (MEM ...) ...) contained in X.    Replace subexpressions of X in place.    If X itself is a (SUBREG (MEM ...) ...), return the replacement expression.    Otherwise return X, with its contents possibly altered.     If any insns must be emitted to compute NEWADDR, put them before INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|walk_fixup_memory_subreg
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|fixup_memory_subreg
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
return|;
comment|/* Nothing special about this RTX; fix its operands.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|walk_fixup_memory_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|walk_fixup_memory_subreg
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Fix up any references to stack slots that are invalid memory addresses    because they exceed the maximum range of a displacement.  */
end_comment

begin_comment
unit|void fixup_stack_slots () {   register rtx insn;
comment|/* Did we generate a stack slot that is out of range      or otherwise has an invalid address?  */
end_comment

begin_comment
unit|if (invalid_stack_slot)     {
comment|/* Yes.  Must scan all insns for stack-refs that exceed the limit.  */
end_comment

begin_endif
unit|for (insn = get_insns (); insn; insn = NEXT_INSN (insn)) 	if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN 	    || GET_CODE (insn) == JUMP_INSN) 	  fixup_stack_1 (PATTERN (insn), insn);     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* For each memory ref within X, if it refers to a stack slot    with an out of range displacement, put the address in a temp register    (emitting new insns before INSN to load these registers)    and alter the memory ref to use that register.    Replace each such MEM rtx with a copy, to avoid clobberage.  */
end_comment

begin_function
specifier|static
name|rtx
name|fixup_stack_1
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|ad
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we have address of a stack slot but it's not valid 	 (displacement is too large), compute the sum in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ad
argument_list|)
condition|)
return|return
name|x
return|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|temp
argument_list|,
name|ad
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|temp
argument_list|)
return|;
block|}
return|return
name|x
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|fixup_stack_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|fixup_stack_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimization: a bit-field instruction whose field    happens to be a byte or halfword in memory    can be changed to a move instruction.     We call here when INSN is an insn to examine or store into a bit-field.    BODY is the SET-rtx to be altered.     EQUIV_MEM is the table `reg_equiv_mem' if that is available; else 0.    (Currently this is called only from stmt.c, and EQUIV_MEM is always 0.)  */
end_comment

begin_function
specifier|static
name|void
name|optimize_bit_field
parameter_list|(
name|body
parameter_list|,
name|insn
parameter_list|,
name|equiv_mem
parameter_list|)
name|rtx
name|body
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|equiv_mem
decl_stmt|;
block|{
specifier|register
name|rtx
name|bitfield
decl_stmt|;
name|int
name|destflag
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|bitfield
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|,
name|destflag
operator|=
literal|1
expr_stmt|;
else|else
name|bitfield
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|,
name|destflag
operator|=
literal|0
expr_stmt|;
comment|/* First check that the field being stored has constant size and position      and is in fact a byte or halfword suitably aligned.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
operator|)
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|%
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|rtx
name|memref
init|=
literal|0
decl_stmt|;
comment|/* Now check that the containing word is memory, not a register, 	 and that it is safe to change the machine mode and to 	 add something to the address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|memref
operator|=
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|equiv_mem
operator|!=
literal|0
condition|)
name|memref
operator|=
name|equiv_mem
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|memref
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|equiv_mem
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|memref
operator|=
name|equiv_mem
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|memref
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|offsettable_address_p
argument_list|(
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|bitfield
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Now adjust the address, first for any subreg'ing 	     that we are now getting rid of, 	     and then for which byte of the word is wanted.  */
specifier|register
name|int
name|offset
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|/
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
name|memref
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
condition|?
name|QImode
else|:
name|HImode
operator|)
argument_list|,
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store this memory reference where 	     we found the bit field reference.  */
if|if
condition|(
name|destflag
condition|)
block|{
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|=
name|adj_offsettable_operand
argument_list|(
name|memref
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_WORD
argument_list|(
name|src
argument_list|)
operator|==
literal|0
condition|)
name|src
operator|=
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
name|src
operator|=
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|src
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
comment|/* This shouldn't happen because anything that didn't have 		   one of these modes should have got converted explicitly 		   and then referenced through a subreg. 		   This is so because the original bit-field was 		   handled by agg_mode and so its tree structure had 		   the same mode that memref now has.  */
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_WORD
argument_list|(
name|dest
argument_list|)
operator|==
literal|0
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|=
name|dest
expr_stmt|;
name|memref
operator|=
name|adj_offsettable_operand
argument_list|(
name|memref
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|memref
expr_stmt|;
else|else
block|{
comment|/* Convert the mem ref to the destination mode.  */
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|newreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
name|convert_move
argument_list|(
name|newreg
argument_list|,
name|memref
argument_list|,
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
argument_list|)
expr_stmt|;
comment|/* Put the conversion before the insn being fixed.  */
name|reorder_insns
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|newreg
expr_stmt|;
block|}
block|}
comment|/* Cause the insn to be re-recognized.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* 1 + last pseudo register number used for loading a copy    of a parameter of this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_parm_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector indexed by REGNO, containing location on stack in which    to put the parm which is nominally in pseudo register REGNO,    if we discover that that parm must go in the stack.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|parm_reg_stack_loc
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|max_parm_reg_num
parameter_list|()
block|{
return|return
name|max_parm_reg
return|;
block|}
end_function

begin_comment
comment|/* Return the first insn following those generated by `assign_parms'.  */
end_comment

begin_function
name|rtx
name|get_first_nonparm_insn
parameter_list|()
block|{
if|if
condition|(
name|last_parm_insn
condition|)
return|return
name|NEXT_INSN
argument_list|(
name|last_parm_insn
argument_list|)
return|;
return|return
name|get_insns
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Get the stack home of a REG rtx that is one of this function's parameters.    This is called rather than assign a new stack slot as a local.    Return 0 if there is no existing stack home suitable for such use.  */
end_comment

begin_function
specifier|static
name|rtx
name|parm_stack_loc
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|max_parm_reg
condition|)
return|return
name|parm_reg_stack_loc
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXP returns an aggregate value, for which an address    must be passed to the function or returned by the function.  */
end_comment

begin_function
name|int
name|aggregate_value_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flag_pcc_struct_return
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert a mem ref into one with a valid memory address.    Pass through anything else unchanged.  */
end_comment

begin_function
name|rtx
name|validize_mem
parameter_list|(
name|ref
parameter_list|)
name|rtx
name|ref
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|ref
return|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|ref
return|;
return|return
name|change_address
argument_list|(
name|ref
argument_list|,
name|VOIDmode
argument_list|,
name|memory_address
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assign RTL expressions to the function's parameters.    This may involve copying them into registers and using    those registers as the RTL for them.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parms
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
specifier|register
name|tree
name|parm
decl_stmt|;
specifier|register
name|rtx
name|entry_parm
decl_stmt|;
specifier|register
name|rtx
name|stack_parm
decl_stmt|;
specifier|register
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
name|enum
name|machine_mode
name|passed_mode
decl_stmt|,
name|nominal_mode
decl_stmt|;
comment|/* Total space needed so far for args on the stack,      given as a constant and a tree-expression.  */
name|struct
name|args_size
name|stack_args_size
decl_stmt|;
name|int
name|first_parm_offset
init|=
name|FIRST_PARM_OFFSET
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
comment|/* This is used for the arg pointer when referring to stack args.  */
name|rtx
name|internal_arg_pointer
decl_stmt|;
name|int
name|nparmregs
init|=
name|list_length
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|+
name|FIRST_PSEUDO_REGISTER
decl_stmt|;
comment|/* Nonzero if function takes extra anonymous args.      This means the last named arg must be on the stack      right before the anonymous ones.      Also nonzero if the first arg is named `__builtin_va_alist',      which is used on some machines for old-fashioned non-ANSI varargs.h;      this too should be stuck onto the stack as if it had arrived there.  */
name|int
name|vararg
init|=
operator|(
operator|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"__builtin_va_alist"
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
operator|)
decl_stmt|;
name|int
name|arg_pointer_copied
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|==
name|FRAME_POINTER_REGNUM
name|internal_arg_pointer
operator|=
name|arg_pointer_rtx
expr_stmt|;
else|#
directive|else
comment|/* If the arg pointer reg is not a fixed reg,      make a copy of it, and address parms via the copy.  */
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
name|internal_arg_pointer
operator|=
name|arg_pointer_rtx
expr_stmt|;
else|else
block|{
name|internal_arg_pointer
operator|=
name|copy_to_reg
argument_list|(
name|arg_pointer_rtx
argument_list|)
expr_stmt|;
name|arg_pointer_copied
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|stack_args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|stack_args_size
operator|.
name|var
operator|=
literal|0
expr_stmt|;
comment|/* If struct value address comes on the stack, count it in size of args.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|struct_value_incoming_rtx
argument_list|)
operator|==
name|MEM
condition|)
name|stack_args_size
operator|.
name|constant
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|parm_reg_stack_loc
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|nparmregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|parm_reg_stack_loc
argument_list|,
name|nparmregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|fntype
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|int
name|aggregate
init|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
decl_stmt|;
name|struct
name|args_size
name|stack_offset
decl_stmt|;
name|rtx
name|stack_offset_rtx
decl_stmt|;
name|enum
name|direction
name|where_pad
decl_stmt|;
comment|/* Extra bytes to add in after parameter is assigned, in 	 case where argument cannot be assigned an offsetted 	 location.  For example, BLKmode parameters cannot be 	 other than on a word boundary (no matter the size) 	 because `access_parm_map' does not know how to handle 	 that case.  */
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|DECL_OFFSET
argument_list|(
name|parm
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|==
name|error_mark_node
comment|/* This can happen after weird syntax errors 	     or if an enum type is defined among the parms.  */
operator|||
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
operator|||
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Find mode of arg as it is passed, and mode of arg 	 as it should be during execution of this function.  */
name|passed_mode
operator|=
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|nominal_mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get this parm's offset as an rtx.  */
name|stack_offset
operator|=
name|stack_args_size
expr_stmt|;
name|stack_offset
operator|.
name|constant
operator|+=
name|first_parm_offset
expr_stmt|;
comment|/* If this argument needs more than the usual parm alignment, do 	 extrinsic padding to reach that alignment.  */
ifdef|#
directive|ifdef
name|MAX_PARM_BOUNDARY
comment|/* If MAX_PARM_BOUNDARY is not defined, it means that the usual 	 alignment requirements are relaxed for parms, and that no parm 	 needs more alignment than PARM_BOUNDARY, regardless of data type.  */
if|if
condition|(
name|PARM_BOUNDARY
operator|<
name|TYPE_ALIGN
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|boundary
init|=
name|PARM_BOUNDARY
decl_stmt|;
comment|/* Determine the boundary to pad up to.  */
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|>
name|boundary
condition|)
name|boundary
operator|=
name|TYPE_ALIGN
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|boundary
operator|>
name|MAX_PARM_BOUNDARY
condition|)
name|boundary
operator|=
name|MAX_PARM_BOUNDARY
expr_stmt|;
comment|/* If the previous args don't reach such a boundary, 	     advance to the next one.  */
name|boundary
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
name|stack_offset
operator|.
name|constant
operator|+=
name|boundary
operator|-
literal|1
expr_stmt|;
name|stack_offset
operator|.
name|constant
operator|&=
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
expr_stmt|;
name|stack_args_size
operator|.
name|constant
operator|+=
name|boundary
operator|-
literal|1
expr_stmt|;
name|stack_args_size
operator|.
name|constant
operator|&=
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|stack_offset
operator|.
name|var
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This case not implemented yet */
block|}
endif|#
directive|endif
comment|/* MAX_PARM_BOUNDARY */
comment|/* Find out if the parm needs intrinsic padding (up to PARM_BOUNDARY), 	 and whether above or below.  */
name|where_pad
operator|=
name|FUNCTION_ARG_PADDING
argument_list|(
name|passed_mode
argument_list|,
name|expand_expr
argument_list|(
name|size_in_bytes
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If arg should be padded below, adjust the stack address upward. 	 This padding is considered part of the space occupied by the 	 argument.  It pads only up to PARM_BOUNDARY, and it does not 	 depend on the previous arguments, since they are assumed to 	 occupy a multiple of PARM_BOUNDARY.  */
if|if
condition|(
name|where_pad
operator|==
name|downward
condition|)
block|{
if|if
condition|(
name|passed_mode
operator|!=
name|BLKmode
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|passed_mode
argument_list|)
operator|%
name|PARM_BOUNDARY
condition|)
name|stack_offset
operator|.
name|constant
operator|+=
operator|(
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|passed_mode
argument_list|)
operator|+
name|PARM_BOUNDARY
operator|-
literal|1
operator|)
operator|/
name|PARM_BOUNDARY
operator|*
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|passed_mode
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|sizetree
init|=
name|size_in_bytes
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|!=
name|PARM_BOUNDARY
condition|)
block|{
comment|/* Round the size up to multiple of PARM_BOUNDARY bits.  */
name|tree
name|s1
init|=
name|convert_units
argument_list|(
name|sizetree
argument_list|,
name|BITS_PER_UNIT
argument_list|,
name|PARM_BOUNDARY
argument_list|)
decl_stmt|;
name|tree
name|s2
init|=
name|convert_units
argument_list|(
name|s1
argument_list|,
name|PARM_BOUNDARY
argument_list|,
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
comment|/* Add it in.  */
name|ADD_PARM_SIZE
argument_list|(
name|stack_offset
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|SUB_PARM_SIZE
argument_list|(
name|stack_offset
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
name|extra
operator|=
name|stack_offset
operator|.
name|constant
operator|%
name|UNITS_PER_WORD
expr_stmt|;
name|stack_offset
operator|.
name|constant
operator|-=
name|extra
expr_stmt|;
block|}
block|}
block|}
name|stack_offset_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|stack_offset
argument_list|)
expr_stmt|;
comment|/* Determine parm's home in the stack, 	 in case it arrives in the stack or we should pretend it did.  */
name|stack_parm
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|passed_mode
argument_list|,
name|memory_address
argument_list|(
name|passed_mode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|internal_arg_pointer
argument_list|,
name|stack_offset_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components, 	 mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|stack_parm
argument_list|)
operator|=
name|aggregate
expr_stmt|;
comment|/* Let machine desc say which reg (if any) the parm arrives in. 	 0 means it arrives on the stack.  */
name|entry_parm
operator|=
literal|0
expr_stmt|;
comment|/* Variable-size args, and args following such, are never in regs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|stack_offset
operator|.
name|var
operator|!=
literal|0
condition|)
block|{
comment|/* Set LAST_NAMED if this is last named arg before some 	     anonymous args.  We treat it as if it were anonymous too.  */
name|int
name|last_named
init|=
operator|(
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
operator|&&
name|vararg
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
name|entry_parm
operator|=
name|FUNCTION_INCOMING_ARG
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
operator|!
name|last_named
argument_list|)
expr_stmt|;
else|#
directive|else
name|entry_parm
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
operator|!
name|last_named
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If this parm was passed part in regs and part in memory, 	 pretend it arrived entirely in memory 	 by pushing the register-part onto the stack.  	 In the special case of a DImode or DFmode that is split, 	 we could put it together in a pseudoreg directly, 	 but for now that's not worth bothering with.  */
if|if
condition|(
name|entry_parm
condition|)
block|{
name|int
name|nregs
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
name|nregs
operator|=
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Replaced by new calling convention 	 which actually passes these args on the stack.  */
comment|/* If this is the last named arg and anonymous args follow, 	     likewise pretend this arg arrived on the stack 	     so varargs can find the anonymous args following it.  */
block|if (TREE_CHAIN (parm) == 0&& vararg) 	    { 	      if (GET_MODE (entry_parm) == BLKmode) 		nregs = GET_MODE_SIZE (GET_MODE (entry_parm)) / UNITS_PER_WORD; 	      else 		nregs = (int_size_in_bytes (DECL_ARG_TYPE (parm)) 			 / UNITS_PER_WORD); 	    }
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
name|nregs
operator|>
literal|0
condition|)
block|{
name|current_function_pretend_args_size
operator|=
operator|(
operator|(
operator|(
name|nregs
operator|*
name|UNITS_PER_WORD
operator|)
operator|+
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|i
operator|=
name|nregs
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|stack_parm
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
operator|*
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|entry_parm
operator|=
name|stack_parm
expr_stmt|;
block|}
block|}
comment|/* If we didn't decide this parm came in a register, 	 by default it came on the stack.  */
if|if
condition|(
name|entry_parm
operator|==
literal|0
condition|)
name|entry_parm
operator|=
name|stack_parm
expr_stmt|;
comment|/* For a stack parm, record in DECL_OFFSET the arglist offset 	 of the parm at the time it is passed (before conversion).  */
if|if
condition|(
name|entry_parm
operator|==
name|stack_parm
condition|)
name|DECL_OFFSET
argument_list|(
name|parm
argument_list|)
operator|=
name|stack_offset
operator|.
name|constant
operator|*
name|BITS_PER_UNIT
expr_stmt|;
comment|/* If there is actually space on the stack for this parm, 	 count it in stack_args_size; otherwise set stack_parm to 0 	 to indicate there is no preallocated stack slot for the parm.  */
if|if
condition|(
name|entry_parm
operator|==
name|stack_parm
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
comment|/* On some machines, even if a parm value arrives in a register 	     there is still an (uninitialized) stack slot allocated for it.  */
operator|||
literal|1
endif|#
directive|endif
condition|)
block|{
name|tree
name|sizetree
init|=
name|size_in_bytes
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|where_pad
operator|!=
name|none
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|!=
name|PARM_BOUNDARY
condition|)
block|{
comment|/* Round the size up to multiple of PARM_BOUNDARY bits.  */
name|tree
name|s1
init|=
name|convert_units
argument_list|(
name|sizetree
argument_list|,
name|BITS_PER_UNIT
argument_list|,
name|PARM_BOUNDARY
argument_list|)
decl_stmt|;
name|sizetree
operator|=
name|convert_units
argument_list|(
name|s1
argument_list|,
name|PARM_BOUNDARY
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
comment|/* Add it in.  */
name|ADD_PARM_SIZE
argument_list|(
name|stack_args_size
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* No stack slot was pushed for this parm.  */
name|stack_parm
operator|=
literal|0
expr_stmt|;
comment|/* Now adjust STACK_PARM to the mode and precise location 	 where this parameter should live during execution, 	 if we discover that it must live in the stack during execution. 	 To make debuggers happier on big-endian machines, we store 	 the value in the last bytes of the space available.  */
if|if
condition|(
name|nominal_mode
operator|!=
name|BLKmode
operator|&&
name|nominal_mode
operator|!=
name|passed_mode
operator|&&
name|stack_parm
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|nominal_mode
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|stack_offset
operator|.
name|constant
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|passed_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|nominal_mode
argument_list|)
expr_stmt|;
name|stack_offset_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|stack_offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|stack_parm
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|nominal_mode
argument_list|,
name|memory_address
argument_list|(
name|nominal_mode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|arg_pointer_rtx
argument_list|,
name|stack_offset_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components, 	     mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|stack_parm
argument_list|)
operator|=
name|aggregate
expr_stmt|;
block|}
comment|/* If there is rounding to do for a BLKmode parameter, 	 add it in here, since STACK_OFFSET is not used for the 	 rest of this iteration.  */
name|stack_offset
operator|.
name|constant
operator|+=
name|extra
expr_stmt|;
comment|/* ENTRY_PARM is an RTX for the parameter as it arrives, 	 in the mode in which it arrives. 	 STACK_PARM is an RTX for a stack slot where the parameter can live 	 during the function (in case we want to put it there). 	 STACK_PARM is 0 if no stack slot was pushed for it.  	 Now output code if necessary to convert ENTRY_PARM to 	 the type in which this function declares it, 	 and store that result in an appropriate place, 	 which may be a pseudo reg, may be STACK_PARM, 	 or may be a local stack slot if STACK_PARM is 0.  	 Set DECL_RTL to that place.  */
if|if
condition|(
name|nominal_mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* If a BLKmode arrives in registers, copy it to a stack slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|stack_parm
operator|==
literal|0
condition|)
name|stack_parm
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|move_block_from_reg
argument_list|(
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|stack_parm
argument_list|,
operator|(
operator|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vararg
condition|)
block|{
comment|/* If this function uses varargs, and `__builtin_saveregs' 		 can clobber this stack location, then protect it.  */
name|rtx
name|pseudo_parm
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
name|pseudo_parm
operator|=
name|FUNCTION_INCOMING_ARG
argument_list|(
name|args_so_far
argument_list|,
name|SImode
argument_list|,
name|integer_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|pseudo_parm
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|SImode
argument_list|,
name|integer_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pseudo_parm
operator|&&
name|GET_CODE
argument_list|(
name|pseudo_parm
argument_list|)
operator|==
name|REG
condition|)
block|{
name|push_to_sequence
argument_list|(
name|save_from_saveregs
argument_list|)
expr_stmt|;
name|move_block_to_reg
argument_list|(
name|REGNO
argument_list|(
name|pseudo_parm
argument_list|)
argument_list|,
name|stack_parm
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|save_from_saveregs
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|stack_parm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|obey_regdecls
operator|&&
operator|!
name|TREE_REGDECL
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|TREE_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|)
comment|/* layout_decl may set this.  */
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|parm
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|parm
argument_list|)
comment|/* If -ffloat-store specified, don't put explicit 		     float variables into registers.  */
operator|||
operator|(
name|flag_float_store
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|)
operator|)
condition|)
block|{
comment|/* Store the parm in a pseudoregister during the function.  */
specifier|register
name|rtx
name|parmreg
init|=
name|gen_reg_rtx
argument_list|(
name|nominal_mode
argument_list|)
decl_stmt|;
name|REG_USERVAR_P
argument_list|(
name|parmreg
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|parmreg
expr_stmt|;
comment|/* Copy the value into the register.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|parmreg
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
condition|)
name|convert_move
argument_list|(
name|parmreg
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In any case, record the parm's desired stack location 	     in case we later discover it must live in the stack.  */
if|if
condition|(
name|REGNO
argument_list|(
name|parmreg
argument_list|)
operator|>=
name|nparmregs
condition|)
block|{
name|rtx
modifier|*
name|new
decl_stmt|;
name|nparmregs
operator|=
name|REGNO
argument_list|(
name|parmreg
argument_list|)
operator|+
literal|5
expr_stmt|;
name|new
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|nparmregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|parm_reg_stack_loc
argument_list|,
name|new
argument_list|,
name|nparmregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|parm_reg_stack_loc
operator|=
name|new
expr_stmt|;
block|}
name|parm_reg_stack_loc
index|[
name|REGNO
argument_list|(
name|parmreg
argument_list|)
index|]
operator|=
name|stack_parm
expr_stmt|;
comment|/* Mark the register as eliminable if we did no conversion 	     and it was copied from memory at a fixed offset, 	     and the arg pointer was not copied to a pseudo-reg. 	     If the arg pointer is a pseudo reg, such memory-equivalences 	     as we make here would screw up life analysis for it.  */
if|if
condition|(
name|nominal_mode
operator|==
name|passed_mode
operator|&&
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|MEM
operator|&&
name|stack_offset
operator|.
name|var
operator|==
literal|0
operator|&&
operator|!
name|arg_pointer_copied
condition|)
name|REG_NOTES
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUIV
argument_list|,
name|entry_parm
argument_list|,
name|REG_NOTES
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For pointer data type, suggest pointer register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|mark_reg_pointer
argument_list|(
name|parmreg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Value must be stored in the stack slot STACK_PARM 	     during function execution.  */
if|if
condition|(
name|passed_mode
operator|!=
name|nominal_mode
condition|)
comment|/* Conversion is required.  */
name|entry_parm
operator|=
name|convert_to_mode
argument_list|(
name|nominal_mode
argument_list|,
name|entry_parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_parm
operator|!=
name|stack_parm
condition|)
block|{
if|if
condition|(
name|stack_parm
operator|==
literal|0
condition|)
name|stack_parm
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|stack_parm
expr_stmt|;
name|frame_pointer_needed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|parm
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Update info on where next arg arrives in registers.  */
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|max_parm_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|last_parm_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|current_function_args_size
operator|=
name|stack_args_size
operator|.
name|constant
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocation of space for returned structure values.    During the rtl generation pass, `get_structure_value_addr'    is called from time to time to request the address of a block in our    stack frame in which called functions will store the structures    they are returning.  The same space is used for all of these blocks.       We allocate these blocks like stack locals.  We keep reusing    the same block until a bigger one is needed.  */
end_comment

begin_comment
comment|/* Length in bytes of largest structure value returned by    any function called so far in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_structure_value_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An rtx for the addr we are currently using for structure values.    This is typically (PLUS (REG:SI stackptr) (CONST_INT...)).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|structure_value
decl_stmt|;
end_decl_stmt

begin_function
name|rtx
name|get_structure_value_addr
parameter_list|(
name|sizex
parameter_list|)
name|rtx
name|sizex
decl_stmt|;
block|{
specifier|register
name|int
name|size
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sizex
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|=
name|INTVAL
argument_list|(
name|sizex
argument_list|)
expr_stmt|;
comment|/* Round up to a multiple of the main allocation unit.  */
name|size
operator|=
operator|(
operator|(
operator|(
name|size
operator|+
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* If this size is bigger than space we know to use,      get a bigger piece of space.  */
if|if
condition|(
name|size
operator|>
name|max_structure_value_size
condition|)
block|{
name|max_structure_value_size
operator|=
name|size
expr_stmt|;
name|structure_value
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|structure_value
argument_list|)
operator|==
name|MEM
condition|)
name|structure_value
operator|=
name|XEXP
argument_list|(
name|structure_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|structure_value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk the tree of LET_STMTs describing the binding levels within a function    and warn about uninitialized variables.    This is done after calling flow_analysis and before global_alloc    clobbers the pseudo-regs to hard regs.  */
end_comment

begin_function
name|void
name|uninitialized_vars_warning
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|,
name|sub
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|STMT_VARS
argument_list|(
name|block
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
comment|/* These warnings are unreliable for and aggregates 	     because assigning the fields one by one can fail to convince 	     flow.c that the entire aggregate was initialized. 	     Unions are troublesome because members may be shorter.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|regno_uninitialized
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' may be used uninitialized in this function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|regno_clobbered_at_setjmp
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"variable `%s' may be clobbered by `longjmp'"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sub
operator|=
name|STMT_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|sub
condition|;
name|sub
operator|=
name|TREE_CHAIN
argument_list|(
name|sub
argument_list|)
control|)
name|uninitialized_vars_warning
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If this function call setjmp, put all vars into the stack    unless they were declared `register'.  */
end_comment

begin_function
name|void
name|setjmp_protect
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|,
name|sub
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|STMT_VARS
argument_list|(
name|block
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
condition|)
name|put_var_into_stack
argument_list|(
name|decl
argument_list|)
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|STMT_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|sub
condition|;
name|sub
operator|=
name|TREE_CHAIN
argument_list|(
name|sub
argument_list|)
control|)
name|setjmp_protect
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the start of the function SUBR (a FUNCTION_DECL tree node)    and initialize static variables for generating RTL for the statements    of the function.  */
end_comment

begin_function
name|void
name|init_function_start
parameter_list|(
name|subr
parameter_list|)
name|tree
name|subr
decl_stmt|;
block|{
name|this_function
operator|=
name|subr
expr_stmt|;
name|cse_not_expected
operator|=
operator|!
name|optimize
expr_stmt|;
comment|/* We have not yet found a reason why a frame pointer cannot      be omitted for this function in particular, but maybe we know      a priori that it is required.      `flag_omit_frame_pointer' has its main effect here.  */
name|frame_pointer_needed
operator|=
name|FRAME_POINTER_REQUIRED
operator|||
operator|!
name|flag_omit_frame_pointer
expr_stmt|;
comment|/* Caller save not needed yet.  */
name|caller_save_needed
operator|=
literal|0
expr_stmt|;
comment|/* No gotos have been expanded yet.  */
name|goto_fixup_chain
operator|=
literal|0
expr_stmt|;
comment|/* No stack slots have been made yet.  */
name|stack_slot_list
operator|=
literal|0
expr_stmt|;
comment|/* No invalid stack slots have been made yet.  */
name|invalid_stack_slot
operator|=
literal|0
expr_stmt|;
comment|/* No parm regs have been allocated.      (This is important for output_inline_function.)  */
name|max_parm_reg
operator|=
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
comment|/* Initialize the RTL mechanism.  */
name|init_emit
argument_list|(
name|write_symbols
argument_list|)
expr_stmt|;
comment|/* Initialize the queue of pending postincrement and postdecrements,      and some other info in expr.c.  */
name|init_expr
argument_list|()
expr_stmt|;
name|init_const_rtx_hash_table
argument_list|()
expr_stmt|;
comment|/* Decide whether function should try to pop its args on return.  */
name|current_function_pops_args
operator|=
name|RETURN_POPS_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|subr
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_name
operator|=
operator|(
name|char
operator|*
operator|)
name|lang_printable_name
argument_list|(
name|subr
argument_list|)
expr_stmt|;
comment|/* Nonzero if this is a nested function that uses a static chain.  */
name|current_function_needs_context
operator|=
operator|(
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|LET_STMT
operator|)
expr_stmt|;
comment|/* Set if a call to setjmp is seen.  */
name|current_function_calls_setjmp
operator|=
literal|0
expr_stmt|;
name|current_function_calls_alloca
operator|=
literal|0
expr_stmt|;
name|current_function_returns_pcc_struct
operator|=
literal|0
expr_stmt|;
name|current_function_returns_struct
operator|=
literal|0
expr_stmt|;
comment|/* No space assigned yet for structure values.  */
name|max_structure_value_size
operator|=
literal|0
expr_stmt|;
name|structure_value
operator|=
literal|0
expr_stmt|;
comment|/* We are not currently within any block, conditional, loop or case.      @@ No longer true.  We are within the block for the parms.  */
name|block_stack
operator|=
literal|0
expr_stmt|;
name|loop_stack
operator|=
literal|0
expr_stmt|;
name|case_stack
operator|=
literal|0
expr_stmt|;
name|cond_stack
operator|=
literal|0
expr_stmt|;
name|nesting_stack
operator|=
literal|0
expr_stmt|;
name|nesting_depth
operator|=
literal|0
expr_stmt|;
name|block_start_count
operator|=
literal|0
expr_stmt|;
comment|/* We have not yet needed to make a label to jump to for tail-recursion.  */
name|tail_recursion_label
operator|=
literal|0
expr_stmt|;
comment|/* No stack slots allocated yet.  */
name|frame_offset
operator|=
name|STARTING_FRAME_OFFSET
expr_stmt|;
comment|/* No SAVE_EXPRs in this function yet.  */
name|save_expr_regs
operator|=
literal|0
expr_stmt|;
comment|/* No parameters to protect from `__builtin_saveregs' yet.  */
name|save_from_saveregs
operator|=
literal|0
expr_stmt|;
comment|/* No RTL_EXPRs in this function yet.  */
name|rtl_expr_chain
operator|=
literal|0
expr_stmt|;
comment|/* Within function body, compute a type's size as soon it is laid out.  */
name|immediate_size_expand
operator|++
expr_stmt|;
name|init_pending_stack_adjust
argument_list|()
expr_stmt|;
name|inhibit_defer_pop
operator|=
literal|0
expr_stmt|;
name|current_function_pretend_args_size
operator|=
literal|0
expr_stmt|;
comment|/* Prevent ever trying to delete the first instruction of a function.      Also tell final how to output a linenum before the function prologue.  */
name|emit_line_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|subr
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|subr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure first insn is a note even if we don't want linenums.      This makes sure the first insn will never be deleted.      Also, final expects a note to appear there.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Indicate the beginning of the function body,      as opposed to parm setup.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_FUNCTION_BEG
argument_list|)
expr_stmt|;
comment|/* Set flags used by final.c.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
if|if
condition|(
name|flag_pcc_struct_return
condition|)
name|current_function_returns_pcc_struct
operator|=
literal|1
expr_stmt|;
else|else
endif|#
directive|endif
name|current_function_returns_struct
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Start the RTL for a new function, and set variables used for    emitting RTL.    SUBR is the FUNCTION_DECL node.    PARMS_HAVE_CLEANUPS is nonzero if there are cleanups associated with    the function's parameters, which must be run at any return statement.  */
end_comment

begin_function
name|void
name|expand_function_start
parameter_list|(
name|subr
parameter_list|,
name|parms_have_cleanups
parameter_list|)
name|tree
name|subr
decl_stmt|;
name|int
name|parms_have_cleanups
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* Make sure volatile mem refs aren't considered      valid operands of arithmetic insns.  */
name|init_recog
argument_list|()
expr_stmt|;
comment|/* If the parameters of this function need cleaning up, get a label      for the beginning of the code which executes those cleanups.  This must      be done before doing anything with return_label.  */
if|if
condition|(
name|parms_have_cleanups
condition|)
name|cleanup_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
else|else
name|cleanup_label
operator|=
literal|0
expr_stmt|;
comment|/* Make the label for return statements to jump to, if this machine      does not have a one-instruction return and uses an epilogue,      or if it returns a structure, or if it has parm cleanups.  */
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|cleanup_label
operator|==
literal|0
operator|&&
name|HAVE_return
operator|&&
operator|!
name|current_function_returns_pcc_struct
operator|&&
operator|!
operator|(
name|current_function_returns_struct
operator|&&
operator|!
name|optimize
operator|)
condition|)
name|return_label
operator|=
literal|0
expr_stmt|;
else|else
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
else|#
directive|else
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize rtx used to return the value.  */
comment|/* Do this before assign_parms so that we copy the struct value address      before any library calls that assign parms might generate.  */
comment|/* Decide whether to return the value in memory or in a register.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Returning something that won't go in a register.  */
specifier|register
name|rtx
name|value_address
decl_stmt|;
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
if|if
condition|(
name|flag_pcc_struct_return
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|value_address
operator|=
name|assemble_static_space
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|current_function_returns_pcc_struct
operator|=
literal|1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* Expect to be passed the address of a place to store the value.  */
name|value_address
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|value_address
argument_list|,
name|struct_value_incoming_rtx
argument_list|)
expr_stmt|;
name|current_function_returns_struct
operator|=
literal|1
expr_stmt|;
block|}
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|,
name|value_address
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
comment|/* If return mode is void, this decl rtl should not be used.  */
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|parms_have_cleanups
condition|)
block|{
comment|/* If function will end with cleanup code for parms, 	 compute the return values into a pseudo reg, 	 which we will copy into the true return register 	 after the cleanups are done.  */
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_REGDECL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* Scalar, returned in a register.  */
block|{
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|,
name|subr
argument_list|)
expr_stmt|;
else|#
directive|else
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|,
name|subr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|current_function_returns_pointer
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|DECL_RESULT_TYPE
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
expr_stmt|;
comment|/* Mark this reg as the function's return value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|REG_FUNCTION_VALUE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_REGDECL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Initialize rtx for parameters and local variables.      In some cases this requires emitting insns.  */
name|assign_parms
argument_list|(
name|subr
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Not yet defined in GCC 1.37.1.  */
comment|/* Tell final that the parameters are in the final places      (either on the stack or in registers).  */
block|emit_note ((char *) 0, NOTE_INSN_PARMS_HOMED);
endif|#
directive|endif
comment|/* If doing stupid allocation, mark parms as born here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|NOTE
condition|)
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|parm_birth_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
block|{
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_parm_reg
condition|;
name|i
operator|++
control|)
name|use_variable
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* After the parm initializations is where the tail-recursion label      should go, if we end up needing one.  */
name|tail_recursion_reentry
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Evaluate now the sizes of any types declared among the arguments.  */
for|for
control|(
name|tem
operator|=
name|get_pending_sizes
argument_list|()
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure there is a line number after the function entry setup code.      There normally is one anyway, from the following statement,      but there could fail to be one if there is no newline here.  */
name|force_next_line_note
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the end of the current function.    FILENAME and LINE are the current position in the source file.  */
end_comment

begin_comment
comment|/* ??? Nobody seems to emit the cleanup_label and the cleanups themselves.     !!! Not true.  finish_function does this is cplus-decl.c.  */
end_comment

begin_function
name|void
name|expand_function_end
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|tree
name|decl
decl_stmt|;
specifier|extern
name|rtx
name|sequence_stack
decl_stmt|;
if|#
directive|if
literal|0
comment|/* I think unused parms are legitimate enough.  */
comment|/* Warn about unused parms.  */
block|if (warn_unused)     for (decl = DECL_ARGUMENTS (current_function_decl); 	 decl; decl = TREE_CHAIN (decl))       if (! TREE_USED (decl)&& TREE_CODE (decl) == VAR_DECL) 	warning_with_decl (decl, "unused parameter `%s'");
endif|#
directive|endif
comment|/* End any sequences that failed to be closed due to syntax errors.  */
while|while
condition|(
name|sequence_stack
condition|)
name|end_sequence
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Outside function body, can't compute type's actual size      until next function's body starts.  */
name|immediate_size_expand
operator|--
expr_stmt|;
comment|/* If doing stupid register allocation,      mark register parms as dying here.  */
if|if
condition|(
name|obey_regdecls
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_parm_reg
condition|;
name|i
operator|++
control|)
name|use_variable
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Likewise for the regs of all the SAVE_EXPRs in the function.  */
for|for
control|(
name|tem
operator|=
name|save_expr_regs
init|;
name|tem
condition|;
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|use_variable
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|use_variable_after
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|parm_birth_insn
argument_list|)
expr_stmt|;
block|}
block|}
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Mark the end of the function body.      If control reaches this insn, the function can drop through      without returning a value.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_FUNCTION_END
argument_list|)
expr_stmt|;
comment|/* Output a linenumber for the end of the function.      SDB depends on this.  */
name|emit_line_note_force
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Output the label for the actual return from the function,      if one is expected.  This happens either because a function epilogue      is used instead of a return instruction, or because a return was done      with a goto in order to run local cleanups, or because of pcc-style      structure returning.  */
if|if
condition|(
name|return_label
condition|)
name|emit_label
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
comment|/* If we had calls to alloca, and this machine needs      an accurate stack pointer to exit the function,      insert some code to save and restore the stack pointer.  */
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
condition|)
endif|#
directive|endif
if|if
condition|(
name|current_function_calls_alloca
condition|)
block|{
name|rtx
name|tem
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|tem
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|parm_birth_insn
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|tem
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If scalar return value was computed in a pseudo-reg,      copy that to the hard return register.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
name|rtx
name|real_decl_result
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|real_decl_result
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|real_decl_result
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REG_FUNCTION_VALUE_P
argument_list|(
name|real_decl_result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|real_decl_result
argument_list|,
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|real_decl_result
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If returning a structure, arrange to return the address of the value      in a place where debuggers expect to find it.  */
comment|/* If returning a structure PCC style,      the caller also depends on this value.      And current_function_returns_pcc_struct is not necessarily set.  */
if|if
condition|(
name|current_function_returns_struct
operator|||
name|current_function_returns_pcc_struct
condition|)
block|{
name|rtx
name|value_address
init|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|rtx
name|outgoing
init|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|outgoing
init|=
name|hard_function_value
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|1
comment|/* If this works, leave it in.  */
comment|/* This is not really the function value, 	 and it confuses integrate.c around line 1211.  */
name|REG_FUNCTION_VALUE_P
argument_list|(
name|outgoing
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|outgoing
argument_list|,
name|value_address
argument_list|)
expr_stmt|;
name|use_variable
argument_list|(
name|outgoing
argument_list|)
expr_stmt|;
block|}
comment|/* Output a return insn if we are using one.      Otherwise, let the rtl chain end here, to drop through      into the epilogue.  */
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|HAVE_return
condition|)
name|emit_jump_insn
argument_list|(
name|gen_return
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fix up any gotos that jumped out to the outermost      binding level of the function.      Must follow emitting RETURN_LABEL.  */
comment|/* If you have any cleanups to do at this point,      and they need to create temporary variables,      then you will lose.  */
name|fixup_gotos
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|get_insns
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|init_stmt
argument_list|()
end_macro

begin_block
block|{
name|obstack_init
argument_list|(
operator|&
name|stmt_obstack
argument_list|)
expr_stmt|;
name|empty_cleanup_list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

