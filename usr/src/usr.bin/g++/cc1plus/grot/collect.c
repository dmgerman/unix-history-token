begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output tables which say what global initializers need    to be called at program startup, and what global destructors    need to be called at program termination, for GNU C++ compiler.    Copyright (C) 1987 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@mcc.com)    COFF Changes by Dirk Grunwald (grunwald@flute.cs.uiuc.edu)  This file is part of GNU CC.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU CC General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU CC, but only under the conditions described in the GNU CC General Public License.   A copy of this license is supposed to have been given to you along with GNU CC so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* This file contains all the code needed for the program `collect'.     `collect' is run on all object files that are processed    by GNU C++, to create a list of all the file-level    initialization and destruction that need to be performed.    It generates an assembly file which holds the tables    which are walked by the global init and delete routines.    The format of the tables are an integer length,    followed by the list of function pointers for the    routines to be called.     Constructors are called in the order they are laid out    in the table.  Destructors are called in the reverse order    of the way they lie in the table.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_decl_stmt
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* satisfy dependency in config.h */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_COLLECT
end_ifndef

begin_function
name|main
parameter_list|()
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|UMAX
end_ifdef

begin_include
include|#
directive|include
file|<sgs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	Define various output routines in terms on ASM_INT_OP,  *	which should be defined in config.h -- if it's not, add it  *	as the marker used to allocate an int on your architecture.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|i386
end_ifdef

begin_define
define|#
directive|define
name|ASM_INT_OP
value|ASM_LONG
end_define

begin_define
define|#
directive|define
name|NO_UNDERSCORES
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|mips
end_ifdef

begin_define
define|#
directive|define
name|NO_UNDERSCORES
value|1
end_define

begin_comment
comment|/*  * provide stubs for various things in tm-mips.h  */
end_comment

begin_decl_stmt
name|enum
name|mips_sections
name|cur_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inside_function
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_source_filenames
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|print_options
parameter_list|()
block|{
return|return;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|void
name|data_section
parameter_list|()
block|{
return|return;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|FILE
modifier|*
name|asm_out_text_file
decl_stmt|,
modifier|*
name|asm_out_data_file
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect: %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pic_label_is_global
parameter_list|()
block|{
return|return;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_INT_CONST
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_INT_CONST
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf(FILE,"\t%s %d\n", ASM_INT_OP, VALUE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_LABELREF_AS_INT
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_LABELREF_AS_INT
parameter_list|(
name|FILE
parameter_list|,
name|NAME
parameter_list|)
define|\
value|(fprintf(FILE,"\t%s", ASM_INT_OP), \    ASM_OUTPUT_LABELREF(FILE,NAME), \    fprintf(FILE,"\n"))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_PTR_INT_SUM
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_PTR_INT_SUM
parameter_list|(
name|FILE
parameter_list|,
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|(fprintf(FILE,"\t%s", ASM_INT_OP), \    ASM_OUTPUT_LABELREF(FILE,NAME), \    fprintf(FILE,"+%d\n", VALUE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_SOURCE_FILENAME
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_SOURCE_FILENAME
parameter_list|(
name|FILE
parameter_list|,
name|NAME
parameter_list|)
define|\
value|fprintf (FILE, "\t.file\t\"%s\"\n", NAME);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|CTOR_TABLE_NAME
end_ifndef

begin_define
define|#
directive|define
name|CTOR_TABLE_NAME
value|"__CTOR_LIST__"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DTOR_TABLE_NAME
end_ifndef

begin_define
define|#
directive|define
name|DTOR_TABLE_NAME
value|"__DTOR_LIST__"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*	Define or undef this in your config.h. Should be defined for  *	MIPS& Sun-386i.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_UNDERSCORES
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|CTOR_DTOR_MARKER_NAME
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DOLLAR_IN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|CTOR_DTOR_MARKER_NAME
value|"_GLOBAL_$"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CTOR_DTOR_MARKER_NAME
value|"_GLOBAL_."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CTOR_DTOR_MARKER_LENGTH
value|9
end_define

begin_define
define|#
directive|define
name|CTOR_DTOR_MARKER_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|CTOR_DTOR_MARKER_NAME
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DOLLAR_IN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|CTOR_DTOR_MARKER_NAME
value|"__GLOBAL_$"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CTOR_DTOR_MARKER_NAME
value|"__GLOBAL_."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CTOR_DTOR_MARKER_LENGTH
value|10
end_define

begin_define
define|#
directive|define
name|CTOR_DTOR_MARKER_OFFSET
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|error_code
block|{
name|OK
block|,
name|BAD_MAGIC
block|,
name|NO_NAMELIST
block|,
name|FOPEN_ERROR
block|,
name|FREAD_ERROR
block|,
name|FWRITE_ERROR
block|,
name|RANDOM_ERROR
block|, }
enum|;
end_enum

begin_function_decl
name|enum
name|error_code
name|process
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|enum
name|error_code
name|process_a
argument_list|()
decl_stmt|,
name|process_o
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|enum
name|error_code
name|output_ctor_dtor_table
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|assemble_name
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Files for holding the assembly code for table of constructor    function pointer addresses and list of destructor    function pointer addresses.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default outfile name, or take name from argv with -o option.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|outfile_name
init|=
literal|"a.out"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For compatibility with toplev.c and tm-sun386.h  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dump_base_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|optimize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|language_string
init|=
literal|"GNU C++"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|main_input_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The list of constructors& destructors. We process all files& then  * spit these out in output_ctor_dtor_table(), because we need to know  *  the length of the list.  */
end_comment

begin_struct
struct|struct
name|ctor_dtor_list_elem
block|{
name|struct
name|ctor_dtor_list_elem
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
modifier|*
name|dtor_chain
struct|,
modifier|*
name|ctor_chain
struct|;
end_struct

begin_decl_stmt
name|int
name|dtor_chain_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ctor_chain_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|nerrs
init|=
literal|0
decl_stmt|;
name|enum
name|error_code
name|code
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-o"
argument_list|)
condition|)
block|{
name|outfile_name
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|i
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|outfile
operator|=
name|fopen
argument_list|(
name|outfile_name
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"collect"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|dump_base_name
operator|=
name|main_input_filename
operator|=
name|outfile_name
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|/* This is a library, skip it.  */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"collect `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
operator|=
name|process
argument_list|(
name|fp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
break|break;
case|case
name|BAD_MAGIC
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file `%s' has a bad magic number for collect\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
name|NO_NAMELIST
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file `%s' has a no namelist for collect\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
name|RANDOM_ERROR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"random error while processing file `%s':\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"collect"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
name|FOPEN_ERROR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fopen(3S) error while processing file `%s' in collect\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
name|FREAD_ERROR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fread(3S) error while processing file `%s' in collect\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
name|FWRITE_ERROR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fwrite(3S) error while processing file `%s' in collect\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
operator|=
name|output_ctor_dtor_table
argument_list|()
condition|)
block|{
case|case
name|OK
case|:
name|fclose
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|FREAD_ERROR
case|:
name|perror
argument_list|(
literal|"fread(3S) failed in collect, at end"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FWRITE_ERROR
case|:
name|perror
argument_list|(
literal|"fwrite(3S) failed in collect, at end"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOPEN_ERROR
case|:
name|perror
argument_list|(
literal|"fopen(3S) failed in collect, at end"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RANDOM_ERROR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"random error in collect, at end"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_ctor_dtor_elem
parameter_list|(
name|symbol_name
parameter_list|)
name|char
modifier|*
name|symbol_name
decl_stmt|;
block|{
comment|/*    *	In EXTENDED_COFF systems, it's possible to    *	have multiple occurances of symbols ( or so it    *	appears) in the symbol table. Sooo, we scan to    *	eliminate duplicate entries. This can never hurt,    *	and helps EXTENDED_COFF.    */
name|int
name|exists
decl_stmt|;
name|int
name|is_ctor
init|=
operator|(
name|symbol_name
index|[
name|CTOR_DTOR_MARKER_LENGTH
index|]
operator|==
literal|'I'
operator|)
decl_stmt|;
name|struct
name|ctor_dtor_list_elem
modifier|*
name|p
init|=
operator|(
operator|(
name|is_ctor
operator|)
condition|?
name|ctor_chain
else|:
name|dtor_chain
operator|)
decl_stmt|;
name|exists
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|symbol_name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|exists
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exists
condition|)
block|{
name|struct
name|ctor_dtor_list_elem
modifier|*
name|new
init|=
operator|(
expr|struct
name|ctor_dtor_list_elem
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ctor_dtor_list_elem
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symbol_name
argument_list|)
operator|+
name|CTOR_DTOR_MARKER_OFFSET
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
operator|->
name|name
argument_list|,
name|symbol_name
operator|+
name|CTOR_DTOR_MARKER_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ctor
condition|)
block|{
name|new
operator|->
name|next
operator|=
name|ctor_chain
expr_stmt|;
name|ctor_chain
operator|=
name|new
expr_stmt|;
name|ctor_chain_length
operator|++
expr_stmt|;
block|}
else|else
block|{
name|new
operator|->
name|next
operator|=
name|dtor_chain
expr_stmt|;
name|dtor_chain
operator|=
name|new
expr_stmt|;
name|dtor_chain_length
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|enum
name|error_code
name|output_ctor_dtor_table
parameter_list|()
block|{
name|int
name|dtor_offset
decl_stmt|;
comment|/* Write out the CTOR tabel */
name|ASM_FILE_START
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTENDED_COFF
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s\n"
argument_list|,
name|SDATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s\n"
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|outfile
argument_list|,
name|CTOR_TABLE_NAME
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|outfile
argument_list|,
name|CTOR_TABLE_NAME
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT_CONST
argument_list|(
name|outfile
argument_list|,
name|ctor_chain_length
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctor_chain
condition|)
block|{
name|ASM_OUTPUT_LABELREF_AS_INT
argument_list|(
name|outfile
argument_list|,
name|ctor_chain
operator|->
name|name
argument_list|)
expr_stmt|;
name|ctor_chain
operator|=
name|ctor_chain
operator|->
name|next
expr_stmt|;
block|}
comment|/* NULL-terminate the list of constructors.  -- not needed, but keep it */
name|ASM_OUTPUT_INT_CONST
argument_list|(
name|outfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Now, lay out the destructors    */
ifdef|#
directive|ifdef
name|EXTENDED_COFF
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s\n"
argument_list|,
name|SDATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s\n"
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|outfile
argument_list|,
name|DTOR_TABLE_NAME
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|outfile
argument_list|,
name|DTOR_TABLE_NAME
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT_CONST
argument_list|(
name|outfile
argument_list|,
name|dtor_chain_length
argument_list|)
expr_stmt|;
while|while
condition|(
name|dtor_chain
condition|)
block|{
name|ASM_OUTPUT_LABELREF_AS_INT
argument_list|(
name|outfile
argument_list|,
name|dtor_chain
operator|->
name|name
argument_list|)
expr_stmt|;
name|dtor_chain
operator|=
name|dtor_chain
operator|->
name|next
expr_stmt|;
block|}
name|ASM_OUTPUT_INT_CONST
argument_list|(
name|outfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT_CONST
argument_list|(
name|outfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*****************************************************************************  *	  *		COFF& EXTENDED COFF  *	  ****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|COFF
argument_list|)
operator|||
name|defined
argument_list|(
name|EXTENDED_COFF
argument_list|)
end_if

begin_include
include|#
directive|include
file|<ldfcn.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EXTENDED_COFF
argument_list|)
end_if

begin_define
define|#
directive|define
name|GCC_SYMBOLS
parameter_list|(
name|X
parameter_list|)
value|(SYMHEADER(X).isymMax+SYMHEADER(X).iextMax)
end_define

begin_define
define|#
directive|define
name|GCC_SYMENT
value|SYMR
end_define

begin_define
define|#
directive|define
name|GCC_OK_SYMBOL
parameter_list|(
name|X
parameter_list|)
value|((X).st == stProc&&  (X).sc == scText)
end_define

begin_define
define|#
directive|define
name|GCC_SYMINC
parameter_list|(
name|X
parameter_list|)
value|(1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCC_SYMBOLS
parameter_list|(
name|X
parameter_list|)
value|(HEADER(ldptr).f_nsyms)
end_define

begin_define
define|#
directive|define
name|GCC_SYMENT
value|SYMENT
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|UNUSUAL_COFF_DEFINITION
end_ifndef

begin_define
define|#
directive|define
name|GCC_OK_SYMBOL
parameter_list|(
name|X
parameter_list|)
value|(!(((X).n_type& N_TMASK) != (DT_NON<< N_BTSHFT)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCC_OK_SYMBOL
parameter_list|(
name|X
parameter_list|)
value|((X).n_scnum == 1&& (X).n_sclass == C_EXT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GCC_SYMINC
parameter_list|(
name|X
parameter_list|)
value|((X).n_numaux+1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|enum
name|error_code
name|process
parameter_list|(
name|fp
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|LDFILE
modifier|*
name|ldptr
init|=
name|NULL
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|ldptr
operator|=
name|ldopen
argument_list|(
name|filename
argument_list|,
name|ldptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ISCOFF
argument_list|(
name|HEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|f_magic
argument_list|)
condition|)
block|{
return|return
name|BAD_MAGIC
return|;
block|}
else|else
block|{
name|int
name|symbols
init|=
name|GCC_SYMBOLS
argument_list|(
name|ldptr
argument_list|)
decl_stmt|;
name|int
name|symindex
decl_stmt|;
for|for
control|(
name|symindex
operator|=
literal|0
init|;
name|symindex
operator|<
name|symbols
condition|;
control|)
block|{
name|GCC_SYMENT
name|symbol
decl_stmt|;
name|char
modifier|*
name|symbol_name
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ldgetname
parameter_list|()
function_decl|;
name|int
name|returnCode
decl_stmt|;
name|returnCode
operator|=
name|ldtbread
argument_list|(
name|ldptr
argument_list|,
name|symindex
argument_list|,
operator|&
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|returnCode
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
name|symindex
operator|+=
name|GCC_SYMINC
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GCC_OK_SYMBOL
argument_list|(
name|symbol
argument_list|)
condition|)
continue|continue;
name|symbol_name
operator|=
name|ldgetname
argument_list|(
name|ldptr
argument_list|,
operator|&
name|symbol
argument_list|)
expr_stmt|;
comment|/* Check to see if we have a CTOR/DTOR marker  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|CTOR_DTOR_MARKER_NAME
argument_list|,
name|symbol_name
argument_list|,
name|CTOR_DTOR_MARKER_LENGTH
argument_list|)
condition|)
name|add_ctor_dtor_elem
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
return|return
operator|(
name|RANDOM_ERROR
operator|)
return|;
block|}
block|}
do|while
condition|(
name|ldclose
argument_list|(
name|ldptr
argument_list|)
operator|==
name|FAILURE
condition|)
do|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/****** taken from sdbout.c ******/
end_comment

begin_comment
comment|/* Tell the assembler the source file name.    On systems that use SDB, this is done whether or not -g,    so it is called by ASM_FILE_START.     ASM_FILE is the assembler code output file,    INPUT_NAME is the name of the main input file.  */
end_comment

begin_comment
comment|/* void */
end_comment

begin_macro
name|sdbout_filename
argument_list|(
argument|asm_file
argument_list|,
argument|input_name
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|asm_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|input_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|input_name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|na
init|=
name|input_name
operator|+
name|len
decl_stmt|;
comment|/* NA gets INPUT_NAME sans directory names.  */
while|while
condition|(
name|na
operator|>
name|input_name
condition|)
block|{
if|if
condition|(
name|na
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
break|break;
name|na
operator|--
expr_stmt|;
block|}
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_escape
end_escape

begin_comment
comment|/*****************************************************************************  *	  *		BSD SYMBOL TABLES  *	  *****************************************************************************/
end_comment

begin_comment
comment|/* Figure out the type of file we need to process.    Currently, only .o and .a formats are acceptable.  */
end_comment

begin_function
name|enum
name|error_code
name|process
parameter_list|(
name|fp
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|file_stat
decl_stmt|;
union|union
block|{
name|char
name|ar_form
index|[
name|SARMAG
index|]
decl_stmt|;
name|struct
name|exec
name|a_out_form
decl_stmt|;
block|}
name|header
union|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fp
operator|->
name|_file
argument_list|,
operator|&
name|file_stat
argument_list|)
condition|)
return|return
name|RANDOM_ERROR
return|;
name|size
operator|=
name|file_stat
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|header
operator|.
name|ar_form
argument_list|,
name|SARMAG
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|<
literal|1
condition|)
return|return
name|RANDOM_ERROR
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|ARMAG
argument_list|,
name|header
operator|.
name|ar_form
argument_list|,
name|SARMAG
argument_list|)
condition|)
block|{
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|header
operator|.
name|a_out_form
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|<
literal|1
condition|)
return|return
name|RANDOM_ERROR
return|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|header
operator|.
name|a_out_form
argument_list|)
condition|)
return|return
name|BAD_MAGIC
return|;
return|return
name|process_o
argument_list|(
name|fp
argument_list|,
operator|&
name|header
operator|.
name|a_out_form
argument_list|,
name|size
argument_list|)
return|;
block|}
return|return
name|process_a
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|error_code
name|process_o
parameter_list|(
name|fp
parameter_list|,
name|header
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|exec
modifier|*
name|header
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|symoff
decl_stmt|,
name|symend
decl_stmt|;
ifndef|#
directive|ifndef
name|hp9000s300
name|struct
name|nlist
modifier|*
name|nelem
decl_stmt|,
modifier|*
name|nelems
decl_stmt|,
modifier|*
name|nend
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
else|#
directive|else
name|struct
name|nlist_
modifier|*
name|nelem
decl_stmt|,
modifier|*
name|nelems
decl_stmt|,
modifier|*
name|nend
decl_stmt|;
endif|#
directive|endif
comment|/* hp9000s300 */
if|if
condition|(
name|N_BADMAG
argument_list|(
operator|*
name|header
argument_list|)
condition|)
return|return
name|BAD_MAGIC
return|;
ifndef|#
directive|ifndef
name|hp9000s300
name|symoff
operator|=
name|N_SYMOFF
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
name|symend
operator|=
name|N_STROFF
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
else|#
directive|else
name|symoff
operator|=
name|LESYM_OFFSET
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
name|symend
operator|=
name|DNTT_OFFSET
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* hp9000s300 */
if|if
condition|(
name|symoff
operator|==
name|symend
condition|)
return|return
name|NO_NAMELIST
return|;
name|fseek
argument_list|(
name|fp
argument_list|,
name|symoff
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|hp9000s300
name|nelems
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|alloca
argument_list|(
name|symend
operator|-
name|symoff
argument_list|)
expr_stmt|;
else|#
directive|else
name|nelems
operator|=
operator|(
expr|struct
name|nlist_
operator|*
operator|)
name|alloca
argument_list|(
name|symend
operator|-
name|symoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* hp9000s300 */
if|if
condition|(
name|fread
argument_list|(
name|nelems
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|symend
operator|-
name|symoff
argument_list|,
name|fp
argument_list|)
operator|<
name|symend
operator|-
name|symoff
condition|)
return|return
name|FREAD_ERROR
return|;
ifndef|#
directive|ifndef
name|hp9000s300
name|strtab
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|char
operator|*
operator|)
name|size
operator|-
operator|(
name|char
operator|*
operator|)
name|symend
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|strtab
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|size
operator|-
operator|(
name|char
operator|*
operator|)
name|symend
argument_list|,
name|fp
argument_list|)
operator|<
operator|(
operator|(
name|char
operator|*
operator|)
name|size
operator|-
operator|(
name|char
operator|*
operator|)
name|symend
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
return|return
name|FREAD_ERROR
return|;
name|nend
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|nelems
operator|+
name|symend
operator|-
name|symoff
operator|)
expr_stmt|;
for|for
control|(
name|nelem
operator|=
name|nelems
init|;
name|nelem
operator|<
name|nend
condition|;
name|nelem
operator|++
control|)
else|#
directive|else
name|nend
operator|=
operator|(
expr|struct
name|nlist_
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|nelems
operator|+
name|symend
operator|-
name|symoff
operator|)
expr_stmt|;
for|for
control|(
name|nelem
operator|=
name|nelems
init|;
name|nelem
operator|<
name|nend
condition|;
control|)
endif|#
directive|endif
comment|/* hp9000s300 */
block|{
ifndef|#
directive|ifndef
name|hp9000s300
name|int
name|strindex
init|=
name|nelem
operator|->
name|n_un
operator|.
name|n_strx
decl_stmt|;
else|#
directive|else
name|int
name|symlen
init|=
name|nelem
operator|->
name|n_length
decl_stmt|;
name|char
name|p
index|[
literal|255
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|++
name|nelem
operator|)
argument_list|,
name|symlen
argument_list|)
expr_stmt|;
name|p
index|[
name|symlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* printf("'%s'\n",p);   */
endif|#
directive|endif
comment|/* hp9000s300 */
ifndef|#
directive|ifndef
name|hp9000s300
if|if
condition|(
name|strindex
condition|)
else|#
directive|else
name|nelem
operator|=
operator|(
expr|struct
name|nlist_
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|nelem
operator|+
name|symlen
operator|)
expr_stmt|;
if|if
condition|(
name|symlen
condition|)
endif|#
directive|endif
comment|/* hp9000s300 */
block|{
ifndef|#
directive|ifndef
name|hp9000s300
name|char
modifier|*
name|p
init|=
name|strtab
operator|+
name|strindex
decl_stmt|;
endif|#
directive|endif
comment|/* hp9000s300 */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"__GLOBAL_$"
argument_list|,
name|p
argument_list|,
literal|10
argument_list|)
condition|)
name|add_ctor_dtor_elem
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|OK
return|;
block|}
end_function

begin_function
name|enum
name|error_code
name|process_a
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|struct
name|ar_hdr
name|header
decl_stmt|;
name|struct
name|exec
name|exec_header
decl_stmt|;
name|int
name|size
decl_stmt|;
name|enum
name|error_code
name|code
decl_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|char
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|hp9000s300
name|int
name|curpos
decl_stmt|;
endif|#
directive|endif
comment|/* hp9000s300 */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|<
literal|1
condition|)
return|return
name|RANDOM_ERROR
return|;
name|size
operator|=
name|atoi
argument_list|(
name|header
operator|.
name|ar_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|hp9000s300
name|curpos
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* hp9000s300 */
ifndef|#
directive|ifndef
name|hp9000s300
if|if
condition|(
name|fread
argument_list|(
operator|&
name|exec_header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|<
literal|1
condition|)
return|return
name|RANDOM_ERROR
return|;
else|#
directive|else
comment|/* if the name starts with /, it's an index file */
if|if
condition|(
name|header
operator|.
name|ar_name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|exec_header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|<
literal|1
condition|)
return|return
name|RANDOM_ERROR
return|;
endif|#
directive|endif
comment|/* hp9000s300 */
name|code
operator|=
name|process_o
argument_list|(
name|fp
argument_list|,
operator|&
name|exec_header
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|OK
condition|)
return|return
name|code
return|;
ifdef|#
directive|ifdef
name|hp9000s300
block|}
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
operator|(
name|long
operator|)
name|curpos
operator|+
name|size
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|RANDOM_ERROR
return|;
endif|#
directive|endif
comment|/* hp9000s300 */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|'\n'
condition|)
empty_stmt|;
else|else
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output to FILE a reference to the assembler name of a C-level name NAME.    If NAME starts with a *, the rest of NAME is output verbatim.    Otherwise NAME is transformed in an implementation-defined way    (usually by the addition of an underscore).    Many macros in the tm file are defined to call this function.     Swiped from `varasm.c'  */
end_comment

begin_function
name|void
name|assemble_name
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|fputs
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|NO_UNDERSCORES
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"_%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Virtual memory exhausted\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

