begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|FIRST_PSEUDO_REGISTER
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Functions and data structures for expanding case statements.  */
end_comment

begin_comment
comment|/* Case label structure, used to hold info on labels within case    statements.  We handle "range" labels; for a single-value label    as in C, the high and low limits are the same.  */
end_comment

begin_struct
struct|struct
name|case_node
block|{
name|struct
name|case_node
modifier|*
name|left
decl_stmt|;
name|struct
name|case_node
modifier|*
name|right
decl_stmt|;
name|struct
name|case_node
modifier|*
name|parent
decl_stmt|;
name|tree
name|low
decl_stmt|;
name|tree
name|high
decl_stmt|;
name|tree
name|test_label
decl_stmt|;
name|tree
name|code_label
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|case_node
name|case_node
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|case_node
modifier|*
name|case_node_ptr
typedef|;
end_typedef

begin_function_decl
name|void
name|balance_case_nodes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|emit_case_nodes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|group_case_nodes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|emit_jump_if_reachable
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Generate code to jump to LABEL if OP1 and OP2 are equal.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_if_equal
parameter_list|(
name|op1
parameter_list|,
name|op2
parameter_list|,
name|label
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|label
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op2
argument_list|)
condition|)
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_cmp_insn
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_beq
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Not all case values are encountered equally.  This function    uses a heuristic to weight case labels, in cases where that    looks like a reasonable thing to do.     Right now, all we try to guess is text, and we establish the    following weights:  	chars above space:	16 	digits:			16 	default:		12 	space, punct:		8 	tab:			4 	newline:		2 	other "\" chars:	1 	remaining chars:	0     Under this weighting, ranges are automagically taken care of.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cost_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_cost_table
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|estimate_case_costs
parameter_list|(
name|node
parameter_list|,
name|default_label
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
name|rtx
name|default_label
decl_stmt|;
block|{
name|tree
name|min_ascii
init|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|tree
name|max_ascii
init|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
literal|127
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|case_node_ptr
name|n
decl_stmt|;
name|use_cost_table
operator|=
literal|0
expr_stmt|;
comment|/* If the user is running without default, who are we      to guess where values are likely to land?  */
if|if
condition|(
name|default_label
operator|==
literal|0
condition|)
return|return;
comment|/* See if all the case expressions look like text.  It is text if the lowest      constant is>= -1 and the highest constant is<= 127.  If the case      expression is unsigned, suppress the test for>= -1, since it would always      be true.  */
for|for
control|(
name|n
operator|=
name|node
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
if|if
condition|(
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|n
operator|->
name|low
argument_list|)
argument_list|)
operator|&&
name|tree_int_cst_lt
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|min_ascii
argument_list|)
operator|)
operator|||
name|tree_int_cst_lt
argument_list|(
name|max_ascii
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
return|return;
comment|/* All interesting values with within the range of      interesting ASCII characters.  */
if|if
condition|(
name|cost_table
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|cost_table
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|129
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|cost_table
operator|-
literal|1
argument_list|,
literal|128
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|i
argument_list|)
condition|)
name|cost_table
index|[
name|i
index|]
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|ispunct
argument_list|(
name|i
argument_list|)
condition|)
name|cost_table
index|[
name|i
index|]
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|iscntrl
argument_list|(
name|i
argument_list|)
condition|)
name|cost_table
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|cost_table
index|[
literal|' '
index|]
operator|=
literal|8
expr_stmt|;
name|cost_table
index|[
literal|'\t'
index|]
operator|=
literal|4
expr_stmt|;
name|cost_table
index|[
literal|'\0'
index|]
operator|=
literal|4
expr_stmt|;
name|cost_table
index|[
literal|'\n'
index|]
operator|=
literal|2
expr_stmt|;
name|cost_table
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|cost_table
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|cost_table
index|[
literal|'\b'
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|use_cost_table
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan an ordered list of case nodes    combining those with consecutive values or ranges.     Eg. three separate entries 1: 2: 3: become one entry 1..3:  */
end_comment

begin_function
name|void
name|group_case_nodes
parameter_list|(
name|head
parameter_list|)
name|case_node_ptr
name|head
decl_stmt|;
block|{
name|case_node_ptr
name|node
init|=
name|head
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|rtx
name|lb
init|=
name|next_real_insn
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
decl_stmt|;
name|case_node_ptr
name|np
init|=
name|node
decl_stmt|;
comment|/* Try to group the successors of NODE with NODE.  */
while|while
condition|(
operator|(
operator|(
name|np
operator|=
name|np
operator|->
name|right
operator|)
operator|!=
literal|0
operator|)
comment|/* Do they jump to the same place?  */
operator|&&
name|next_real_insn
argument_list|(
name|label_rtx
argument_list|(
name|np
operator|->
name|code_label
argument_list|)
argument_list|)
operator|==
name|lb
comment|/* Are their ranges consecutive?  */
operator|&&
name|tree_int_cst_equal
argument_list|(
name|np
operator|->
name|low
argument_list|,
name|combine
argument_list|(
name|PLUS_EXPR
argument_list|,
name|node
operator|->
name|high
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
condition|)
block|{
name|node
operator|->
name|high
operator|=
name|np
operator|->
name|high
expr_stmt|;
block|}
comment|/* NP is the first node after NODE which can't be grouped with it. 	 Delete the nodes in between, and move on to that node.  */
name|node
operator|->
name|right
operator|=
name|np
expr_stmt|;
name|node
operator|=
name|np
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Take an ordered list of case nodes    and transform them into a near optimal binary tree,    on the assumtion that any target code selection value is as    likely as any other.     The transformation is performed by splitting the ordered    list into two equal sections plus a pivot.  The parts are    then attached to the pivot as left and right branches.  Each    branch is is then transformed recursively.  */
end_comment

begin_function
name|void
name|balance_case_nodes
parameter_list|(
name|head
parameter_list|,
name|parent
parameter_list|)
name|case_node_ptr
modifier|*
name|head
decl_stmt|;
name|case_node_ptr
name|parent
decl_stmt|;
block|{
specifier|register
name|case_node_ptr
name|np
decl_stmt|;
name|np
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|np
condition|)
block|{
name|int
name|cost
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|ranges
init|=
literal|0
decl_stmt|;
specifier|register
name|case_node_ptr
modifier|*
name|npp
decl_stmt|;
name|case_node_ptr
name|left
decl_stmt|;
comment|/* Count the number of entries on branch. 	 Also count the ranges.  */
while|while
condition|(
name|np
condition|)
block|{
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|np
operator|->
name|low
argument_list|,
name|np
operator|->
name|high
argument_list|)
condition|)
block|{
name|ranges
operator|++
expr_stmt|;
if|if
condition|(
name|use_cost_table
condition|)
block|{
name|int
name|hi_cost
init|=
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|np
operator|->
name|high
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|hi_cost
operator|<
literal|0
condition|)
name|use_cost_table
operator|=
literal|0
expr_stmt|;
else|else
name|cost
operator|+=
name|hi_cost
expr_stmt|;
block|}
block|}
if|if
condition|(
name|use_cost_table
condition|)
block|{
name|int
name|lo_cost
init|=
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|np
operator|->
name|low
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|lo_cost
operator|<
literal|0
condition|)
name|use_cost_table
operator|=
literal|0
expr_stmt|;
else|else
name|cost
operator|+=
name|lo_cost
expr_stmt|;
block|}
else|else
name|cost
operator|+=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|np
operator|=
name|np
operator|->
name|right
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
comment|/* Split this list if it is long enough for that to help.  */
name|npp
operator|=
name|head
expr_stmt|;
name|left
operator|=
operator|*
name|npp
expr_stmt|;
if|if
condition|(
name|use_cost_table
condition|)
block|{
comment|/* Find the place in the list that bisects the list's total cost, 		 Here I gets half the total cost.  */
name|int
name|n_moved
init|=
literal|0
decl_stmt|;
name|i
operator|=
operator|(
name|cost
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip nodes while their cost does not reach that amount.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|,
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
condition|)
name|i
operator|-=
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
index|]
expr_stmt|;
name|i
operator|-=
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
name|n_moved
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_moved
operator|==
literal|0
condition|)
block|{
comment|/* Leave this branch lopsided, but optimize left-hand 		     side and fill in `parent' fields for right-hand side.  */
name|np
operator|=
operator|*
name|head
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|left
argument_list|,
name|np
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|np
operator|->
name|right
condition|;
name|np
operator|=
name|np
operator|->
name|right
control|)
name|np
operator|->
name|right
operator|->
name|parent
operator|=
name|np
expr_stmt|;
return|return;
block|}
block|}
comment|/* If there are just three nodes, split at the middle one.  */
elseif|else
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* Find the place in the list that bisects the list's total cost, 		 where ranges count as 2. 		 Here I gets half the total cost.  */
name|i
operator|=
operator|(
name|i
operator|+
name|ranges
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip nodes while their cost does not reach that amount.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|,
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
condition|)
name|i
operator|--
expr_stmt|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
block|}
block|}
operator|*
name|head
operator|=
name|np
operator|=
operator|*
name|npp
expr_stmt|;
operator|*
name|npp
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|np
operator|->
name|left
operator|=
name|left
expr_stmt|;
comment|/* Optimize each of the two split parts.  */
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|left
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|right
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Else leave this branch as one level, 	     but fill in `parent' fields.  */
name|np
operator|=
operator|*
name|head
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
for|for
control|(
init|;
name|np
operator|->
name|right
condition|;
name|np
operator|=
name|np
operator|->
name|right
control|)
name|np
operator|->
name|right
operator|->
name|parent
operator|=
name|np
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search the parent sections of the case node tree    to see if a test for the lower bound of NODE would be redundant.     The instructions to synthesis the case decision tree are    output in the same order as nodes are processed so it is    known that if a parent node checks the range of the current    node minus one that the current node is bounded at its lower    span.  Thus the test would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_has_low_bound
parameter_list|(
name|node
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
block|{
name|tree
name|low_minus_one
decl_stmt|;
name|case_node_ptr
name|pnode
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|left
condition|)
block|{
name|low_minus_one
operator|=
name|combine
argument_list|(
name|MINUS_EXPR
argument_list|,
name|node
operator|->
name|low
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
comment|/* Avoid the screw case of overflow where low_minus_one is> low.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|low_minus_one
argument_list|,
name|node
operator|->
name|low
argument_list|)
condition|)
for|for
control|(
name|pnode
operator|=
name|node
operator|->
name|parent
init|;
name|pnode
condition|;
name|pnode
operator|=
name|pnode
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|low_minus_one
argument_list|,
name|pnode
operator|->
name|high
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If a parent node has a left branch we know that none 	       of its parents can have a high bound of our target 	       minus one so we abort the search.  */
if|if
condition|(
name|node
operator|->
name|left
condition|)
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search the parent sections of the case node tree    to see if a test for the upper bound of NODE would be redundant.     The instructions to synthesis the case decision tree are    output in the same order as nodes are processed so it is    known that if a parent node checks the range of the current    node plus one that the current node is bounded at its upper    span.  Thus the test would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_has_high_bound
parameter_list|(
name|node
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
block|{
name|tree
name|high_plus_one
decl_stmt|;
name|case_node_ptr
name|pnode
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|right
operator|==
literal|0
condition|)
block|{
name|high_plus_one
operator|=
name|combine
argument_list|(
name|PLUS_EXPR
argument_list|,
name|node
operator|->
name|high
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
comment|/* Avoid the screw case of overflow where high_plus_one is> high.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|high_plus_one
argument_list|)
condition|)
for|for
control|(
name|pnode
operator|=
name|node
operator|->
name|parent
init|;
name|pnode
condition|;
name|pnode
operator|=
name|pnode
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|high_plus_one
argument_list|,
name|pnode
operator|->
name|low
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If a parent node has a right branch we know that none 	       of its parents can have a low bound of our target 	       plus one so we abort the search.  */
if|if
condition|(
name|node
operator|->
name|right
condition|)
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search the parent sections of the    case node tree to see if both tests for the upper and lower    bounds of NODE would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_is_bounded
parameter_list|(
name|node
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
block|{
if|if
condition|(
name|node
operator|->
name|left
operator|||
name|node
operator|->
name|right
condition|)
return|return
literal|0
return|;
return|return
name|node_has_low_bound
argument_list|(
name|node
argument_list|)
operator|&&
name|node_has_high_bound
argument_list|(
name|node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  Emit an unconditional jump to LABEL unless it would be dead code.  */
end_comment

begin_function
name|void
name|emit_jump_if_reachable
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
name|rtx
name|last_insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit step-by-step code to select a case for the value of INDEX.    The thus generated decision tree follows the form of the    case-node binary tree NODE, whose nodes represent test conditions.    UNSIGNEDP is nonzero if we should do unsigned comparisons.     Care is taken to prune redundant tests from the decision tree    by detecting any boundary conditions already checked by    emitted rtx.  (See node_has_high_bound, node_has_low_bound    and node_is_bounded, above.)     Where the test conditions can be shown to be redundant we emit    an unconditional jump to the target code.  As a further    optimization, the subordinates of a tree node are examined to    check for bounded nodes.  In this case conditional and/or    unconditional jumps as a result of the boundary check for the    current node are arranged to target the subordinates associated    code for out of bound conditions on the current node node.  */
end_comment

begin_function
name|void
name|emit_case_nodes
parameter_list|(
name|index
parameter_list|,
name|node
parameter_list|,
name|default_label
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|index
decl_stmt|;
name|case_node_ptr
name|node
decl_stmt|;
name|rtx
name|default_label
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
comment|/* If INDEX has an unsigned type, we must make unsigned branches.  */
typedef|typedef
name|rtx
name|rtx_function
parameter_list|()
function_decl|;
name|rtx_function
modifier|*
name|gen_bgt_pat
init|=
name|unsignedp
condition|?
name|gen_bgtu
else|:
name|gen_bgt
decl_stmt|;
name|rtx_function
modifier|*
name|gen_bge_pat
init|=
name|unsignedp
condition|?
name|gen_bgeu
else|:
name|gen_bge
decl_stmt|;
name|rtx_function
modifier|*
name|gen_blt_pat
init|=
name|unsignedp
condition|?
name|gen_bltu
else|:
name|gen_blt
decl_stmt|;
name|rtx_function
modifier|*
name|gen_ble_pat
init|=
name|unsignedp
condition|?
name|gen_bleu
else|:
name|gen_ble
decl_stmt|;
name|int
name|defaulted_left
init|=
literal|0
decl_stmt|;
name|int
name|defaulted_right
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|test_label
condition|)
block|{
comment|/* If this test node requires a label it follows that 	 it must be preceeded by an unconditional branch. 	 If control can pass to this point we can assume that 	 a "br default" is in order.  */
name|emit_jump_if_reachable
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
name|expand_label
argument_list|(
name|node
operator|->
name|test_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|node
operator|->
name|high
argument_list|)
condition|)
block|{
comment|/* Node is single valued.  */
name|do_jump_if_equal
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|right
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|left
condition|)
block|{
comment|/* This node has children on either side.  */
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|right
argument_list|)
condition|)
block|{
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|left
argument_list|)
condition|)
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|left
argument_list|)
condition|)
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_blt_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|node
operator|->
name|right
operator|->
name|test_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|test_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Here we have a right child but no left 		 so we issue conditional branch to default 		 and process the right child.  */
comment|/* Omit the conditional branch to default 		 if we it avoid only one right child; 		 it costs too much space to save so little time.  */
if|if
condition|(
name|node
operator|->
name|right
operator|->
name|right
operator|&&
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_blt_pat
call|)
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|right
argument_list|)
condition|)
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|left
condition|)
block|{
if|if
condition|(
name|use_cost_table
operator|&&
operator|!
name|defaulted_right
operator|&&
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|node
operator|->
name|high
argument_list|)
index|]
operator|<
literal|12
condition|)
block|{
comment|/* If our "most probably entry" is less probable 		 than the default label, emit a jump to 		 the default label using condition codes 		 already lying around.  With no right branch, 		 a branch-greater-than will get us to the default 		 label correctly.  */
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No sense doing this too often.  */
name|defaulted_right
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|left
argument_list|)
condition|)
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Node is a range.  */
if|if
condition|(
name|node
operator|->
name|right
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|left
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|right
argument_list|)
condition|)
block|{
comment|/* Right hand node is fully bounded so we can 		     eliminate any testing and branch directly 		     to the target code.  */
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Right hand node requires testing so create 		     a label to put on the cmp code.  */
name|node
operator|->
name|right
operator|->
name|test_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|test_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bge_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|left
argument_list|)
condition|)
block|{
comment|/* Left hand node is fully bounded so we can 		     eliminate any testing and branch directly 		     to the target code.  */
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* If right node has been given a test label above 		 we must process it now.  */
if|if
condition|(
name|node
operator|->
name|right
operator|->
name|test_label
condition|)
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_blt_pat
call|)
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_ble_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|right
argument_list|)
condition|)
block|{
comment|/* Right hand node is fully bounded so we can 		     eliminate any testing and branch directly 		     to the target code.  */
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|left
condition|)
block|{
if|if
condition|(
operator|!
name|node_has_high_bound
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bge_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|left
argument_list|)
condition|)
block|{
comment|/* Left hand node is fully bounded so we can 		 eliminate any testing and branch directly 		 to the target code.  */
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Node has no children so we check low and 	     high bounds to remove redundant tests. In practice 	     only one of the limits may be bounded or the parent 	     node will have emmited a jump to our target code.  */
if|if
condition|(
operator|!
name|node_has_high_bound
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bge_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We allow the default case to drop through since 	     it will picked up by calls to `jump_if_reachable' 	     either on the next test label or at the end of 	     the decision tree emission.  */
block|}
block|}
block|}
end_function

end_unit

