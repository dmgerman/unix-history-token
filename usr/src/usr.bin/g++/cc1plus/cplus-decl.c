begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C compiler.    Copyright (C) 1988 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@mcc.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cplus-tree.h"
end_include

begin_include
include|#
directive|include
file|"cplus-parse.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Define this if C structs should have gratuitous typedefing    done just like C++ structs do.  */
end_comment

begin_define
define|#
directive|define
name|BREAK_C_TAGS
end_define

begin_comment
comment|/* Stack of places to restore the search obstack back to.  */
end_comment

begin_comment
comment|/* Obstack used for remembering local class declarations (like    enums and static (const) members.  */
end_comment

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|decl_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stack_level
modifier|*
name|decl_stack
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"cplus-decl.h"
end_include

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X)< (Y) ? (X) : (Y))
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X)> (Y) ? (X) : (Y))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SHORT_TYPE_SIZE
value|(BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_LONG_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|tree
name|grokparms
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|grokdeclarator
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|pushdecl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|push_overloaded_decl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pop_implicit_try_blocks
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|builtin_function
parameter_list|(
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|)
define|\
value|define_function (NAME, TYPE, CODE, (void (*)())&pushdecl)
end_define

begin_define
define|#
directive|define
name|auto_function
parameter_list|(
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|)
define|\
value|define_function (NAME, TYPE, CODE, (void (*)())&push_overloaded_decl)
end_define

begin_comment
comment|/* static */
end_comment

begin_function_decl
name|void
name|grokclassfn
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* static */
end_comment

begin_decl_stmt
name|tree
name|grokopexpr
argument_list|()
decl_stmt|,
name|grokoptypename
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
name|lookup_tag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_tag_reverse
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_name_current_level
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|redeclaration_error_message
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parmlist_is_exprlist
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parmlist_is_random
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|grok_ctor_properties
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|grok_op_properties
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_static_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|deactivate_exception_cleanups
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|finish_table
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FIELD_XREF
end_ifdef

begin_function_decl
specifier|static
name|void
name|FIELD_end_scope
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* a node which has tree code ERROR_MARK, and whose type is itself.    All erroneous expressions are replaced with this node.  All functions    that accept nodes as arguments should avoid generating error messages    if this node is one of the arguments, since it is undesirable to get    multiple error messages from one error in the input.  */
end_comment

begin_undef
undef|#
directive|undef
name|error_mark_node
end_undef

begin_decl_stmt
name|tree
name|error_mark_node
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|error_mark_node
value|(&ERROR_MARK_NODE)
end_define

begin_comment
comment|/* Erroneous argument lists can use this *IFF* they do not modify it.  */
end_comment

begin_decl_stmt
name|tree
name|error_mark_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INTEGER_TYPE and REAL_TYPE nodes for the standard data types */
end_comment

begin_decl_stmt
name|tree
name|short_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_long_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|short_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_long_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|signed_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|float_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_double_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a VOID_TYPE node, and the same, packaged in a TREE_LIST.  */
end_comment

begin_decl_stmt
name|tree
name|void_type_node
decl_stmt|,
name|void_list_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A node for type `void *'.  */
end_comment

begin_decl_stmt
name|tree
name|ptr_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A node for type `char *'.  */
end_comment

begin_decl_stmt
name|tree
name|string_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `char[256]' or something like it.    Used when an array of char is needed and the size is irrelevant.  */
end_comment

begin_decl_stmt
name|tree
name|char_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `int[256]' or something like it.    Used when an array of int needed and the size is irrelevant.  */
end_comment

begin_decl_stmt
name|tree
name|int_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type `int ()' -- used for implicit declaration of functions.  */
end_comment

begin_decl_stmt
name|tree
name|default_function_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function types `double (double)' and `double (double, double)', etc.  */
end_comment

begin_decl_stmt
name|tree
name|double_ftype_double
decl_stmt|,
name|double_ftype_double_double
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|int_ftype_int
decl_stmt|,
name|long_ftype_long
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `void (void *, void *, int)' and similar ones.  */
end_comment

begin_decl_stmt
name|tree
name|void_ftype_ptr_ptr_int
decl_stmt|,
name|int_ftype_ptr_ptr_int
decl_stmt|,
name|void_ftype_ptr_int_int
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++ extensions */
end_comment

begin_decl_stmt
name|tree
name|vtable_entry_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|class_type_node
decl_stmt|,
name|record_type_node
decl_stmt|,
name|union_type_node
decl_stmt|,
name|enum_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|exception_type_node
decl_stmt|,
name|unknown_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `void * (long)', 'void (void *)' */
end_comment

begin_decl_stmt
name|tree
name|ptr_ftype_long
decl_stmt|,
name|void_ftype_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ptr_ftype_ptr_int_int_ptr
decl_stmt|,
name|void_ftype_ptr_int_int_ptr_int_int
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for virtual function tables.  */
end_comment

begin_decl_stmt
name|tree
name|vtbl_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array type `(void *)[]' */
end_comment

begin_decl_stmt
name|tree
name|vtbl_type_node
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SOS
end_ifdef

begin_comment
comment|/* SOS extensions.  */
end_comment

begin_decl_stmt
name|tree
name|zlink_type
decl_stmt|,
name|zret_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|zlink
decl_stmt|,
name|zret
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Static decls which do not have static initializers have no    initializers as far as GNU C is concerned.  EMPTY_INIT_NODE    is a static initializer which makes varasm code place the decl    in data rather than in bss space.  Such gymnastics are necessary    to avoid the problem that the linker will not include a library    file if all the library appears to contribute are bss variables.  */
end_comment

begin_decl_stmt
name|tree
name|empty_init_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a destructor, the point at which all derived class destroying    has been done, just before any base class destroying will be done.  */
end_comment

begin_decl_stmt
name|tree
name|dtor_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a constructor, the point at which we are ready to return    the pointer to the initialized object.  */
end_comment

begin_decl_stmt
name|tree
name|ctor_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A FUNCTION_DECL which can call `unhandled_exception'.    Not neccessarily the one that the user will declare,    but sufficient to be called by routines that want to abort the program.  */
end_comment

begin_decl_stmt
name|tree
name|unhandled_exception_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A FUNCTION_DECL which can call `abort'.  Not neccessarily the    one that the user will declare, but sufficient to be called    by routines that want to abort the program.  */
end_comment

begin_decl_stmt
name|tree
name|abort_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- end of C++ */
end_comment

begin_comment
comment|/* Two expressions that are constants with value zero.    The first is of type `int', the second of type `void *'.  */
end_comment

begin_decl_stmt
name|tree
name|integer_zero_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|null_pointer_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A node for the integer constants 1, 2, and 3.  */
end_comment

begin_decl_stmt
name|tree
name|integer_one_node
decl_stmt|,
name|integer_two_node
decl_stmt|,
name|integer_three_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An identifier whose name is<value>.  This is used as the "name"    of the RESULT_DECLs for values of functions.  */
end_comment

begin_decl_stmt
name|tree
name|value_identifier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If original DECL_RESULT of current function was a register,    but due to being an addressable named return value, would up    on the stack, this variable holds the named return value's    original location.  */
end_comment

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
name|original_result_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sequence of insns which represents base initialization.  */
end_comment

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
name|base_init_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++: Keep these around to reduce calls to `get_identifier'.    Identifiers for `this' in member functions and the auto-delete    parameter for destructors.  */
end_comment

begin_decl_stmt
name|tree
name|this_identifier
decl_stmt|,
name|in_charge_identifier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While defining an enum type, this is 1 plus the last enumerator    constant value.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|enum_next_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves a list of parameter names    or a chain or parameter decls here.  */
end_comment

begin_decl_stmt
name|tree
name|last_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves here a chain of structure    and enum types declared in the parmlist.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* After parsing the declarator that starts a function definition,    `start_function' puts here the list of parameter names or chain of decls.    `store_parm_decls' finds it here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for last_function_parm_tags.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list (chain of TREE_LIST nodes) of all LABEL_STMTs in the function    that have names.  Here so we can clear out their names' definitions    at the end of the function.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|named_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list (chain of TREE_LIST nodes) of named label uses.    The TREE_PURPOSE field is the list of variables defined    the the label's scope defined at the point of use.    The TREE_VALUE field is the LABEL_DECL used.    The TREE_TYPE field holds `current_binding_level' at the    point of the label's use.     Used only for jumps to as-yet undefined labels, since    jumps to defined labels can have their validity checked    by stmt.c.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|named_label_uses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of objects which have constructors or destructors    which reside in the global scope.  The decl is stored in    the TREE_VALUE slot and the initializer is stored    in the TREE_PURPOSE slot.  */
end_comment

begin_decl_stmt
name|tree
name|static_aggregates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of functions which were declared inline, but later had their    address taken.  Used only for non-virtual member functions, since we can    find other functions easily enough.  */
end_comment

begin_decl_stmt
name|tree
name|pending_addressable_inlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of overloaded functions which we should forget ever    existed, such as functions declared in a function's scope,    once we leave that function's scope.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|overloads_to_forget
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The FUNCTION_DECL for the function currently being compiled,    or 0 if between functions.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement that specifies a return value is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement with no argument is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to nonzero by `grokdeclarator' for a function    whose return type is defaulted, if warnings for this are desired.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_about_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when starting a function delcared `extern inline'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_extern_inline
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
name|char
modifier|*
name|language_string
init|=
literal|"GNU C++"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a constructor, set to 1    if that function does an allocation before referencing its    instance variable.  */
end_comment

begin_decl_stmt
name|int
name|current_function_assigns_this
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_function_just_assigned_this
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function.  Set non-zero when    store_parm_decls is called.  Don't call store_parm_decls    if this flag is non-zero!  */
end_comment

begin_decl_stmt
name|int
name|current_function_parms_stored
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Allocate a level of searching.  */
end_comment

begin_function
name|struct
name|stack_level
modifier|*
name|push_decl_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|stack_level
name|tem
decl_stmt|;
name|tem
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
return|return
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of decl allocation.  */
end_comment

begin_function
specifier|static
name|struct
name|stack_level
modifier|*
name|pop_decl_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
block|{
name|tree
modifier|*
name|bp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|stack
operator|->
name|obstack
decl_stmt|;
name|bp
operator|=
name|stack
operator|->
name|first
expr_stmt|;
name|tp
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp
operator|!=
name|bp
condition|)
block|{
operator|--
name|tp
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|pop_stack_level
argument_list|(
name|stack
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For each binding contour we allocate a binding_level structure  * which records the names defined in that contour.  * Contours include:  *  0) the global one  *  1) one for each function definition,  *     where internal declarations of the parameters appear.  *  2) one for each compound statement,  *     to record its declarations.  *  * The current meaning of a name can be found by searching the levels from  * the current one out to the global one.  *  * Off to the side, may be the class_binding_level.  This exists  * only to catch class-local declarations.  It is otherwise  * nonexistent.  *   * Also there may be binding levels that catch cleanups that  * must be run when exceptions occur.  */
end_comment

begin_comment
comment|/* Note that the information in the `names' component of the global contour    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */
end_comment

begin_struct
struct|struct
name|binding_level
block|{
comment|/* A chain of _DECL nodes for all variables, constants, functions,      * and typedef types.  These are in the reverse of the order supplied.      */
name|tree
name|names
decl_stmt|;
comment|/* A list of structure, union and enum definitions,      * for looking up tag names.      * It is a chain of TREE_LIST nodes, each of whose TREE_PURPOSE is a name,      * or NULL_TREE; and whose TREE_VALUE is a RECORD_TYPE, UNION_TYPE,      * or ENUMERAL_TYPE node.      *      * C++: the TREE_VALUE nodes can be simple types for component_bindings.      *      */
name|tree
name|tags
decl_stmt|;
comment|/* For each level, a list of shadowed outer-level local definitions        to be restored when this level is popped.        Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and        whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */
name|tree
name|shadowed
decl_stmt|;
comment|/* Same, for IDENTIFIER_CLASS_VALUE.  */
name|tree
name|class_shadowed
decl_stmt|;
comment|/* For each level (except not the global one),        a chain of LET_STMT nodes for all the levels        that were entered and exited one level down.  */
name|tree
name|blocks
decl_stmt|;
comment|/* The binding level which this one is contained in (inherits from).  */
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* Number of decls in `names' that have incomplete         structure or union types.  */
name|unsigned
name|short
name|n_incomplete
decl_stmt|;
comment|/* 1 for the level that holds the parameters of a function.        2 for the level that holds a class declaration.        3 for levels that hold parameter declarations.  */
name|unsigned
name|parm_flag
range|:
literal|4
decl_stmt|;
comment|/* 1 means make a LET_STMT for this level regardless of all else.        2 for temporary binding contours created by the compiler.  */
name|unsigned
name|keep
range|:
literal|3
decl_stmt|;
comment|/* Nonzero if this level "doesn't exist" for tags.  */
name|unsigned
name|tag_transparent
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if this level can safely have additional        cleanup-needing variables added to it.  */
name|unsigned
name|more_cleanups_ok
range|:
literal|1
decl_stmt|;
name|unsigned
name|have_cleanups
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if this level can safely have additional        exception-raising statements added to it.  */
name|unsigned
name|more_exceptions_ok
range|:
literal|1
decl_stmt|;
name|unsigned
name|have_exceptions
range|:
literal|1
decl_stmt|;
comment|/* Four bits left for this word.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NULL_BINDING_LEVEL
value|(struct binding_level *) NULL
end_define

begin_comment
comment|/* The binding level currently in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|current_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The binding level of the current class, if any.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|class_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A chain of binding_level structures awaiting reuse.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|free_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The outermost binding level, for names of file scope.    This is created when the compiler is started and exists    through the entire run.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|global_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Binding level structures are initialized by copying this one.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
name|clear_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means unconditionally make a LET_STMT for the next level pushed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_next_level_flag
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PUSH_BINDING_LEVEL
parameter_list|(
name|NEWLEVEL
parameter_list|,
name|TAG_TRANSPARENT
parameter_list|,
name|KEEP
parameter_list|)
define|\
value|do {									\
comment|/* Add this level to the front of the chain (stack) of levels that	\      are active.  */
value|\   *NEWLEVEL = clear_binding_level;					\   if (class_binding_level)						\     {									\       NEWLEVEL->level_chain = class_binding_level;			\       class_binding_level = 0;						\     }									\   else									\     {									\       NEWLEVEL->level_chain = current_binding_level;			\     }									\   current_binding_level = NEWLEVEL;					\   NEWLEVEL->tag_transparent = TAG_TRANSPARENT;				\   NEWLEVEL->more_cleanups_ok = 1;					\   NEWLEVEL->more_exceptions_ok = 1;					\   NEWLEVEL->keep = KEEP;						\ } while (0)
end_define

begin_define
define|#
directive|define
name|POP_BINDING_LEVEL
define|\
value|do {									\
comment|/* Pop the current level, and free the structure for reuse.  */
value|\   {									\     register struct binding_level *level = current_binding_level;	\     current_binding_level = current_binding_level->level_chain;		\     level->level_chain = free_binding_level;				\     free_binding_level = level;						\     if (current_binding_level->parm_flag == 2)				\       {									\ 	class_binding_level = current_binding_level;			\ 	do								\ 	  {								\ 	    current_binding_level = current_binding_level->level_chain;	\ 	  }								\ 	while (current_binding_level->parm_flag == 2);			\       }									\   }									\ } while (0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Create a new `struct binding_level'.  */
end_comment

begin_function
specifier|static
name|struct
name|binding_level
modifier|*
name|make_binding_level
parameter_list|()
block|{
comment|/* NOSTRICT */
return|return
operator|(
expr|struct
name|binding_level
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|binding_level
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in the global binding level.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|==
name|global_binding_level
return|;
block|}
end_function

begin_function
name|void
name|keep_next_level
parameter_list|()
block|{
name|keep_next_level_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Identify this binding level as a level of parameters.  */
end_comment

begin_function
name|void
name|declare_parm_level
parameter_list|()
block|{
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Identify this binding level as a level of a default exception handler.  */
end_comment

begin_function
name|void
name|declare_implicit_exception
parameter_list|()
block|{
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|3
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if current binding contour contains expressions    that might raise exceptions.  */
end_comment

begin_function
name|int
name|have_exceptions_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|have_exceptions
return|;
block|}
end_function

begin_comment
comment|/* Enter a new binding level.    If TAG_TRANSPARENT is nonzero, do so only for the name space of variables,    not for that of tags.  */
end_comment

begin_function
name|void
name|pushlevel
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|newlevel
init|=
name|NULL_BINDING_LEVEL
decl_stmt|;
comment|/* If this is the top level of a function,      just make sure that NAMED_LABELS is 0.      They should have been set to 0 at the end of the previous function.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|assert
argument_list|(
name|named_labels
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Reuse or create a struct for this binding level.  */
if|if
condition|(
name|free_binding_level
condition|)
block|{
name|newlevel
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|free_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
block|{
name|newlevel
operator|=
name|make_binding_level
argument_list|()
expr_stmt|;
block|}
name|PUSH_BINDING_LEVEL
argument_list|(
name|newlevel
argument_list|,
name|tag_transparent
argument_list|,
name|keep_next_level_flag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_start_scope
argument_list|(
name|newlevel
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|keep_next_level_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pushlevel_temporary
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
name|pushlevel
argument_list|(
name|tag_transparent
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|keep
operator|=
literal|2
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Don't call push_momentary here!  It will cause cleanups      to be allocated on the momentary obstack, and they      will be overwritten by the next statement.  */
block|push_momentary ();
endif|#
directive|endif
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exit a binding level.    Pop the level off, and restore the state of the identifier-decl mappings    that were in effect when this level was entered.     If KEEP == 1, this level had explicit declarations, so    and create a "block" (a LET_STMT node) for the level    to record its declarations and subblocks for symbol table output.     If KEEP == 2, this level's subblocks go to the front,    not the back of the current binding level.  This happens,    for instance, when code for constructors and destructors    need to generate code at the end of a function which must    be moved up to the front of the function.     If FUNCTIONBODY is nonzero, this level is the body of a function,    so create a block as if KEEP were set and also clear out all    label names.     If REVERSE is nonzero, reverse the order of decls before putting    them into the LET_STMT.  */
end_comment

begin_function
name|tree
name|poplevel
parameter_list|(
name|keep
parameter_list|,
name|reverse
parameter_list|,
name|functionbody
parameter_list|)
name|int
name|keep
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|int
name|functionbody
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
comment|/* The chain of decls was accumulated in reverse order.      Put it into forward order, just for cleanliness.  */
name|tree
name|decls
decl_stmt|;
name|int
name|tmp
init|=
name|functionbody
decl_stmt|;
name|int
name|implicit_try_block
init|=
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|3
decl_stmt|;
name|int
name|real_functionbody
init|=
name|current_binding_level
operator|->
name|keep
operator|==
literal|2
condition|?
operator|(
operator|(
name|functionbody
operator|=
literal|0
operator|)
expr|,
name|tmp
operator|)
else|:
name|functionbody
decl_stmt|;
name|tree
name|tags
init|=
name|functionbody
operator|>=
literal|0
condition|?
name|current_binding_level
operator|->
name|tags
else|:
literal|0
decl_stmt|;
name|tree
name|subblocks
init|=
name|functionbody
operator|>=
literal|0
condition|?
name|current_binding_level
operator|->
name|blocks
else|:
literal|0
decl_stmt|;
name|tree
name|block
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_end_scope
argument_list|(
name|current_binding_level
argument_list|,
name|current_binding_level
operator|->
name|level_chain
argument_list|,
name|current_binding_level
operator|->
name|parm_flag
argument_list|,
name|current_binding_level
operator|->
name|keep
argument_list|,
name|current_binding_level
operator|->
name|tag_transparent
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|current_binding_level
operator|->
name|keep
operator|==
literal|1
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
comment|/* This warning is turned off because it causes warnings for      declarations like `extern struct foo *x'.  */
if|#
directive|if
literal|0
comment|/* Warn about incomplete structure types in this level.  */
block|for (link = tags; link; link = TREE_CHAIN (link))     if (TYPE_SIZE (TREE_VALUE (link)) == 0)       { 	tree type = TREE_VALUE (link); 	char *errmsg; 	switch (TREE_CODE (type)) 	  { 	  case RECORD_TYPE: 	    errmsg = "`struct %s' incomplete in scope ending here"; 	    break; 	  case UNION_TYPE: 	    errmsg = "`union %s' incomplete in scope ending here"; 	    break; 	  case ENUMERAL_TYPE: 	    errmsg = "`enum %s' incomplete in scope ending here"; 	    break; 	  } 	if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE) 	  error (errmsg, IDENTIFIER_POINTER (TYPE_NAME (type))); 	else
comment|/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */
block|error (errmsg, IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));       }
endif|#
directive|endif
comment|/* 0 */
comment|/* Get the decls in the order they were written.      Usually current_binding_level->names is in reverse order.      But parameter decls were previously put in forward order.  */
if|if
condition|(
name|reverse
condition|)
name|current_binding_level
operator|->
name|names
operator|=
name|decls
operator|=
name|nreverse
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|)
expr_stmt|;
else|else
name|decls
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
comment|/* If there were any declarations or structure tags in that level,      or if this level is a function body,      create a LET_STMT to record them for the life of this function.  */
if|if
condition|(
name|keep
operator|==
literal|1
operator|||
name|functionbody
operator|>
literal|0
condition|)
name|block
operator|=
name|build_let
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|keep
condition|?
name|decls
else|:
literal|0
argument_list|,
name|subblocks
argument_list|,
literal|0
argument_list|,
name|keep
condition|?
name|tags
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* In each subblock, record that this is its superior.  */
if|if
condition|(
name|keep
operator|>=
literal|0
condition|)
for|for
control|(
name|link
operator|=
name|subblocks
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|STMT_SUPERCONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* Clear out the meanings of the local variables of this level;      also record in each decl which block it belongs to.  */
for|for
control|(
name|link
operator|=
name|decls
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
comment|/* Restore all name-meanings of the outer levels      that were shadowed by this level.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|class_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|/* If the level being exited is the top level of a function,      check over all the labels.  */
if|if
condition|(
name|functionbody
condition|)
block|{
comment|/* Clear out the definitions of all label names, 	 since their scopes end here.  */
for|for
control|(
name|link
operator|=
name|named_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"label `%s' used somewhere above but not defined"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Avoid crashing later.  */
name|define_label
argument_list|(
name|input_filename
argument_list|,
literal|1
argument_list|,
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
literal|"label `%s' defined but not used"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|named_labels
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Any uses of undefined labels now operate under constraints      of next binding contour.  */
block|{
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
name|level_chain
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|level_chain
condition|)
block|{
name|tree
name|labels
decl_stmt|;
for|for
control|(
name|labels
operator|=
name|named_label_uses
init|;
name|labels
condition|;
name|labels
operator|=
name|TREE_CHAIN
argument_list|(
name|labels
argument_list|)
control|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|labels
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|current_binding_level
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|labels
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|level_chain
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|labels
argument_list|)
operator|=
name|level_chain
operator|->
name|names
expr_stmt|;
block|}
block|}
block|}
name|tmp
operator|=
name|current_binding_level
operator|->
name|keep
expr_stmt|;
name|POP_BINDING_LEVEL
expr_stmt|;
if|if
condition|(
name|functionbody
operator|>
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* If this is the top level block of a function, 	 the vars are the function's parameters. 	 Don't leave them in the LET_STMT because they are 	 found in the FUNCTION_DECL instead.  */
name|STMT_VARS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|block
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* If we did not make a block for the level just exited,      any blocks made for inner levels      (since they cannot be recorded as subblocks in that level)      must be carried forward so they will later become subblocks      of something else.  */
elseif|else
if|if
condition|(
name|subblocks
condition|)
if|if
condition|(
name|keep
operator|==
literal|2
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|subblocks
argument_list|,
name|current_binding_level
operator|->
name|blocks
argument_list|)
expr_stmt|;
else|else
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|subblocks
argument_list|)
expr_stmt|;
comment|/* Take care of compiler's internal binding structures.  */
if|if
condition|(
name|tmp
operator|==
literal|2
operator|&&
operator|!
name|implicit_try_block
condition|)
block|{
if|#
directive|if
literal|0
comment|/* We did not call push_momentary for this 	 binding contour, so there is nothing to pop.  */
block|pop_momentary ();
endif|#
directive|endif
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
name|keep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|block
operator|=
name|poplevel
argument_list|(
name|keep
argument_list|,
name|reverse
argument_list|,
name|real_functionbody
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|block
condition|)
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Add BLOCK to the current list of blocks for this binding contour.  */
end_comment

begin_function
name|void
name|add_block_current_level
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do a pushlevel for class declarations.  */
end_comment

begin_function
name|void
name|pushlevel_class
parameter_list|()
block|{
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|decl_stack
operator|=
name|push_decl_level
argument_list|(
name|decl_stack
argument_list|,
operator|&
name|decl_obstack
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|class_binding_level
operator|->
name|parm_flag
operator|=
literal|2
expr_stmt|;
do|do
block|{
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
do|while
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
do|;
block|}
end_function

begin_comment
comment|/* ...and a poplevel for class declarations.  */
end_comment

begin_function
name|tree
name|poplevel_class
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|class_binding_level
decl_stmt|;
name|tree
name|block
init|=
literal|0
decl_stmt|;
name|tree
name|shadowed
decl_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|current_binding_level
operator|&&
name|class_binding_level
operator|==
literal|0
condition|)
name|block
operator|=
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"syntax error too serious"
argument_list|)
expr_stmt|;
name|level
operator|=
name|class_binding_level
expr_stmt|;
block|}
name|decl_stack
operator|=
name|pop_decl_level
argument_list|(
name|decl_stack
argument_list|)
expr_stmt|;
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_end_scope
argument_list|(
name|class_binding_level
argument_list|,
name|class_binding_level
operator|->
name|level_chain
argument_list|,
name|class_binding_level
operator|->
name|parm_flag
argument_list|,
name|class_binding_level
operator|->
name|keep
argument_list|,
name|class_binding_level
operator|->
name|tag_transparent
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|class_binding_level
operator|=
name|level
operator|->
name|level_chain
expr_stmt|;
name|level
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|level
expr_stmt|;
if|if
condition|(
name|class_binding_level
operator|->
name|parm_flag
operator|!=
literal|2
condition|)
name|class_binding_level
operator|=
literal|0
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push a definition of struct, union or enum tag "name".    "type" should be the type node.    We assume that the tag "name" is not already defined.     Note that the definition may really be just a forward reference.    In that case, the TYPE_SIZE will be zero.     C++ gratuitously puts all these tags in the name space. */
end_comment

begin_function
name|void
name|pushtag
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
name|b
operator|=
name|class_binding_level
expr_stmt|;
else|else
block|{
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|tag_transparent
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
block|{
comment|/* Record the identifier as the type's name if it has none.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
name|b
operator|->
name|tags
operator|=
name|perm_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|tags
operator|=
name|saveable_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
comment|/* Do C++ gratuitous typedefing.  Note that we put the          TYPE_DECL in the TREE_TYPE of the IDENTIFIER_NODE.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|!=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
ifndef|#
directive|ifndef
name|BREAK_C_TAGS
comment|/* This *should* only happen in C++ language scope. 	     But everybody else seems to think otherwise.  */
operator|&&
name|current_lang_name
operator|==
name|lang_name_cplusplus
endif|#
directive|endif
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
name|class_binding_level
operator|==
literal|0
operator|||
operator|!
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|tree
name|t
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_NONLOCAL
argument_list|(
name|type
argument_list|)
condition|)
name|t
operator|=
name|pushdecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|t
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
block|{
name|TREE_NONLOCAL
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|b
operator|->
name|tags
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of duplicate_decls: return truthvalue of whether    or not types of these decls match.  */
end_comment

begin_function
specifier|static
name|int
name|decls_match
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
name|int
name|types_match
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|f1
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|tree
name|f2
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|f1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|f2
argument_list|)
decl_stmt|;
comment|/* When we parse a static member function definition, 	 we put together a FUNCTION_DECL which thinks its type 	 is METHOD_TYPE.  Change that to FUNCTION_TYPE, and 	 proceed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|tree
name|n1
decl_stmt|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|n1
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|n1
operator|=
name|build_type_variant
argument_list|(
name|n1
argument_list|,
name|TREE_READONLY
argument_list|(
name|f1
argument_list|)
argument_list|,
name|TREE_VOLATILE
argument_list|(
name|f1
argument_list|)
argument_list|)
expr_stmt|;
name|n1
operator|=
name|build_exception_variant
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|f1
argument_list|)
argument_list|,
name|n1
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|f1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|n1
expr_stmt|;
name|f1
operator|=
name|n1
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Here we must take care of the case where new default 	 parameters are specified.  Also, warn if an old 	 declaration becomes ambiguous because default 	 parameters may cause the two to be ambiguous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|f2
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|compiler_error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' redeclared as member function"
argument_list|)
expr_stmt|;
else|else
name|compiler_error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' redeclared as non-member function"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|types_match
operator|=
name|compparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MERGED
comment|/* C++: copy friendlist *before* we get smooshed.  */
if|if
condition|(
name|DECL_FRIENDLIST
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_FRIENDLIST
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_FRIENDLIST
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FRIENDLIST
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|types_match
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|types_match
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|error_mark_node
expr_stmt|;
else|else
name|types_match
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|types_match
return|;
block|}
end_function

begin_comment
comment|/* Handle when a new declaration NEWDECL has the same name as an old    one OLDDECL in the same binding contour.  Prints an error message    if appropriate.     If safely possible, alter OLDDECL to look like NEWDECL, and return 1.    Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|duplicate_decls
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
specifier|register
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
name|int
name|types_match
decl_stmt|;
name|int
name|new_is_definition
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* If a new decl finds a list of old decls, then 	 we assume that the new decl has C linkage, and 	 that the old decls have C++ linkage.  In this case, 	 we must look through the list to see whether 	 there is an ambiguity or not.  */
name|tree
name|olddecls
init|=
name|olddecl
decl_stmt|;
comment|/* If the overload list is empty, just install the decl.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|olddecls
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|olddecls
argument_list|)
operator|=
name|newdecl
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
name|olddecls
condition|)
block|{
if|if
condition|(
name|decls_match
argument_list|(
name|newdecl
argument_list|,
name|TREE_VALUE
argument_list|(
name|olddecls
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_LANGUAGE
argument_list|(
name|TREE_VALUE
argument_list|(
name|olddecls
argument_list|)
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"declaration of `%s' with different language linkage"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|olddecls
argument_list|)
argument_list|,
literal|"previous declaration here"
argument_list|)
expr_stmt|;
block|}
name|types_match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|olddecls
operator|=
name|TREE_CHAIN
argument_list|(
name|olddecls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|olddecls
condition|)
name|olddecl
operator|=
name|TREE_VALUE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
else|else
return|return
literal|1
return|;
block|}
else|else
name|types_match
operator|=
name|decls_match
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
name|types_match
operator|=
literal|0
expr_stmt|;
comment|/* If this decl has linkage, and the old one does too, maybe no error.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' redeclared as different kind of symbol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|olddecl
operator|=
name|TREE_VALUE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
comment|/* New decl is completely inconsistent with the old one => 	 tell caller to replace the old one.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Now that functions must hold information normally held 	 by field decls, there is extra work to do so that 	 declaration information does not get destroyed during 	 definition.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_VINDEX
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_VINDEX
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_VINDEX
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VCONTEXT
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_VCONTEXT
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_VCONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_VCONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_FIELD_CONTEXT
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_FIELD_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOS
if|if
condition|(
name|DECL_DINDEX
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_DINDEX
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_DINDEX
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_DINDEX
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|olddecl
condition|)
comment|/* If -traditional, avoid error for redeclaring fcn        after implicit decl.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NOT_BUILT_IN
condition|)
block|{
if|if
condition|(
operator|!
name|types_match
condition|)
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"conflicting types for built-in function `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra_warnings
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"built-in function `%s' redeclared"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|int
name|give_error
init|=
literal|0
decl_stmt|;
comment|/* Already complained about this, so don't do so again.  */
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|give_error
operator|=
literal|1
expr_stmt|;
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"conflicting types for `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* Check for function type mismatch 	 involving an empty arglist vs a nonempty one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Classify the problem further.  */
specifier|register
name|tree
name|t
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"A parameter list with an ellipsis can't match"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"an empty parameter name list declaration."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|==
name|float_type_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"An argument type that has a default promotion"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"can't match an empty parameter name list declaration."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|give_error
condition|)
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
comment|/* There is one thing GNU C++ cannot tolerate: a constructor 	 which takes the type of object being constructed. 	 Farm that case out here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|TYPE_METHOD_BASETYPE
argument_list|(
name|newtype
argument_list|)
operator|)
condition|)
block|{
name|tree
name|parm
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|argtypes
init|=
name|hash_tree_chain
argument_list|(
name|build_reference_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TYPE_REFERENCE_TO
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|newtype
operator|=
name|build_cplus_method_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|newtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"constructor cannot take as argument the type being constructed"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|char
modifier|*
name|errmsg
init|=
name|redeclaration_error_message
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|errmsg
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_COMPILER_GENERATED_P
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_COMPILER_GENERATED_P
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"here is the previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Prototype decl follows defn w/o prototype.  */
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"prototype for `%s'"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"follows non-prototype definition here"
argument_list|)
expr_stmt|;
block|}
comment|/* These bits are logically part of the type.  */
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"type qualifiers for `%s' conflict with previous decl"
argument_list|)
expr_stmt|;
block|}
comment|/* Deal with C++: must preserve virtual function table size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
block|{
name|CLASSTYPE_VSIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|new_is_definition
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Copy all the DECL_... slots specified in the new decl      except for any that we copy here from the old type.  */
if|if
condition|(
name|types_match
condition|)
block|{
comment|/* Automatically handles default parameters.  */
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
comment|/* Merge the data types specified in the two decls.  */
name|tree
name|newtype
init|=
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Do this after calling `commontype' so that default 	 parameters don't confuse us.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newtype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|newdecl
argument_list|)
condition|)
name|ctype
operator|=
name|DECL_STATIC_CONTEXT
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|newtype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|newtype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|oldtype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compexcepttypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"declaration of `%s' raises different exceptions..."
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"...from previous declaration here"
argument_list|)
expr_stmt|;
block|}
block|}
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|newtype
expr_stmt|;
comment|/* Lay the type out, unless already done.  */
if|if
condition|(
name|oldtype
operator|!=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CONST_DECL
condition|)
name|layout_decl
argument_list|(
name|newdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the type is OLDDECL's, make OLDDECL's size go with.  */
name|DECL_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
operator|>
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the type qualifiers.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge the initialization information.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Keep the old rtl since we can safely use it.  */
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* If cannot merge, then use the new type and qualifiers,      and don't preserve the old rtl.  */
else|else
block|{
comment|/* Clean out any memory we had of the old declaration.  */
name|tree
name|oldstatic
init|=
name|value_member
argument_list|(
name|olddecl
argument_list|,
name|static_aggregates
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldstatic
condition|)
name|TREE_VALUE
argument_list|(
name|oldstatic
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_VOLATILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the storage class information.  */
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* For functions, static overrides non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|&=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* This is since we don't automatically 	     copy the attributes of NEWDECL into OLDDECL.  */
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If this clears `static', clear it in the identifier too.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* A `const' which was not declared `extern' and is 	 in static storage is invisible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* If either decl says `inline', this fn is inline,      unless its definition was passed already.  */
name|TREE_INLINE
argument_list|(
name|olddecl
argument_list|)
operator||=
name|TREE_INLINE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|new_is_definition
condition|)
comment|/* If defining a function declared with other language 	   linkage, use the previously declared language linkage.  */
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If redeclaring a builtin function, and not a definition, 	     it stays built in.  */
name|DECL_SET_FUNCTION_CODE
argument_list|(
name|newdecl
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* Previously saved insns go together with 	       the function's previous definition.  */
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_RESULT_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now preserve various other info from the definition.  */
name|TREE_ADDRESSABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Don't really know how much of the language-specific      values we should copy from old to new.  */
if|#
directive|if
literal|1
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_IN_AGGR_P
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_IN_AGGR_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|int
name|function_size
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|ol
init|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|nl
init|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|MERGED
name|function_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|function_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't lose track of having output OLDDECL as GDB symbol.  */
name|DECL_BLOCK_SYMTAB_ADDRESS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_BLOCK_SYMTAB_ADDRESS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
name|function_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|==
name|obstack_next_free
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
operator|-
operator|(
name|function_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
operator|)
condition|)
block|{
name|DECL_MAIN_VARIANT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|olddecl
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|ol
expr_stmt|;
name|bcopy
argument_list|(
name|nl
argument_list|,
name|ol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LANG_DECL_PERMANENT
elseif|else
if|if
condition|(
name|LANG_DECL_PERMANENT
argument_list|(
name|ol
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_MAIN_VARIANT
argument_list|(
name|olddecl
argument_list|)
operator|==
name|olddecl
condition|)
block|{
comment|/* Save these lang_decls that would otherwise be lost.  */
specifier|extern
name|tree
name|free_lang_decl_chain
decl_stmt|;
name|tree
name|free_lang_decl
init|=
operator|(
name|tree
operator|)
name|ol
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|free_lang_decl
argument_list|)
operator|=
name|free_lang_decl_chain
expr_stmt|;
name|free_lang_decl_chain
operator|=
name|free_lang_decl
expr_stmt|;
block|}
else|else
block|{
comment|/* Storage leak.  */
block|}
block|}
else|#
directive|else
comment|/* Storage leak.  */
endif|#
directive|endif
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|t
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|t
operator|==
name|error_mark_node
condition|)
comment|/* error_mark_node is 0 for a while during initialization!  */
block|{
name|t
operator|=
literal|0
expr_stmt|;
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"`%s' used prior to declaration"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
block|{
name|tree
name|cntxt
init|=
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|fatal
argument_list|(
literal|"parse errors have confused me too much"
argument_list|)
expr_stmt|;
name|cntxt
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|file
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
ifdef|#
directive|ifdef
name|BREAK_C_TAGS
empty_stmt|;
else|#
directive|else
name|warning
argument_list|(
literal|"type declaration of %s shadowed"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
ifdef|#
directive|ifdef
name|BREAK_C_TAGS
empty_stmt|;
else|#
directive|else
name|warning
argument_list|(
literal|"type declaration of %s shadows previous declaration"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
block|{
comment|/* If this decl is `static' and an `extern' was seen previously, 	     that is erroneous.  But don't complain if -traditional, 	     since traditional compilers don't complain.  	     Note that this does not apply to the C++ case of declaring 	     a variable `extern const' and then later `const'.  */
if|if
condition|(
operator|!
name|flag_traditional
operator|&&
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Due to interference in memory reclamation (X may be 		 obstack-deallocated at this point, we must guard against 		 one really special case).  */
if|if
condition|(
name|current_function_decl
operator|==
name|x
condition|)
name|current_function_decl
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`%s' was declared implicitly `extern' and later `static'"
argument_list|,
name|lang_printable_name
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' was declared `extern' and later `static'"
argument_list|,
name|lang_printable_name
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|warning_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"previous declaration of `%s'"
argument_list|,
name|lang_printable_name
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/* If declaring a type as a typedef, and the type has no known 	 typedef name, install this TYPE_DECL as its typedef name.  	 C++: If it had an anonymous aggregate or enum name, 	 give it a `better' one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|TYPE_DECL
ifndef|#
directive|ifndef
name|BREAK_C_TAGS
operator|&&
name|current_lang_name
operator|==
name|lang_name_cplusplus
endif|#
directive|endif
operator|)
condition|)
block|{
comment|/* If these are different names, make two equivalent 		 definitions.  */
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* do gratuitous C++ typedefing, and make sure that 		     we access this type either through TREE_TYPE field 		     or via the tags list.  */
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Multiple external decls of the same identifier ought to match.  */
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_EXTERNAL
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"type mismatch with previous external decl"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"previous external decl of `%s'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* In PCC-compatibility mode, extern decls of vars with no current decl 	 take effect at top level no matter where they are.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|lookup_name
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
name|b
operator|=
name|global_binding_level
expr_stmt|;
comment|/* This name is new in its binding level. 	 Install the new declaration and return it.  */
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Install a global value.  */
comment|/* Rule for VAR_DECLs, but not for other kinds of _DECLs: 	     A `const' which was not declared `extern' is invisible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If the first global decl has external linkage, 	     warn if we later see static one.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* Don't forget if the function was used via an implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't forget if its address was taken in that way.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Warn about mismatches against previous implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
comment|/* If this real decl matches the implicit, don't complain.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|)
condition|)
name|warning
argument_list|(
literal|"`%s' was previously implicitly declared to return `int'"
argument_list|,
name|lang_printable_name
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this decl is `static' and an `extern' was seen previously, 	     that is erroneous.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`%s' was declared implicitly `extern' and later `static'"
argument_list|,
name|lang_printable_name
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' was declared `extern' and later `static'"
argument_list|,
name|lang_printable_name
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Here to install a non-global value.  */
name|tree
name|oldlocal
init|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|oldglobal
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* If this is an extern function declaration, see if we 	     have a global definition for the function.  */
if|if
condition|(
name|oldlocal
operator|==
literal|0
operator|&&
name|oldglobal
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* We have one.  Their types must agree.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"local declaration of `%s' doesn't match global one"
argument_list|)
expr_stmt|;
comment|/* If the global one is inline, make the local one inline.  */
elseif|else
if|if
condition|(
name|TREE_INLINE
argument_list|(
name|oldglobal
argument_list|)
operator|||
name|DECL_FUNCTION_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|!=
name|NOT_BUILT_IN
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|oldglobal
expr_stmt|;
block|}
comment|/* If we have a local external declaration, 	     and no file-scope declaration has yet been seen, 	     then if we later have a file-scope decl it must not be static.  */
if|if
condition|(
name|oldlocal
operator|==
literal|0
operator|&&
name|oldglobal
operator|==
literal|0
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_INLINE
argument_list|(
name|x
argument_list|)
condition|)
comment|/* Inline decls shadow nothing.  */
empty_stmt|;
comment|/* Warn if shadowing an argument at the top level of the body.  */
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
literal|0
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARM_DECL
comment|/* The parm level is two levels above the first user-visible 		 level.  One level was created for parm cleanups, the 		 other declared by the user.  */
operator|&&
name|current_binding_level
operator|->
name|level_chain
operator|->
name|level_chain
operator|->
name|parm_flag
operator|==
literal|1
condition|)
name|warning
argument_list|(
literal|"declaration of `%s' shadows a parameter"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Maybe warn if shadowing something else.  */
elseif|else
if|if
condition|(
name|warn_shadow
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|char
modifier|*
name|warnstring
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|oldlocal
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows a parameter"
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows a member of `this'"
expr_stmt|;
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
literal|0
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows previous local"
expr_stmt|;
elseif|else
if|if
condition|(
name|oldglobal
operator|!=
literal|0
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows global declaration"
expr_stmt|;
if|if
condition|(
name|warnstring
condition|)
name|warning
argument_list|(
name|warnstring
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If storing a local value, there may already be one (inherited). 	     If so, record it for restoration when this binding level ends.  */
if|if
condition|(
name|oldlocal
operator|!=
literal|0
condition|)
name|b
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|oldlocal
argument_list|,
name|b
operator|->
name|shadowed
argument_list|)
expr_stmt|;
block|}
comment|/* Keep count of variables in this level with incomplete type.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|b
operator|->
name|n_incomplete
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"too many incomplete variables at this point"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Put decls on list in reverse order.      We will reverse them later if necessary.  */
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|b
operator|->
name|names
expr_stmt|;
name|b
operator|->
name|names
operator|=
name|x
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL,    if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|global_binding_level
expr_stmt|;
name|t
operator|=
name|pushdecl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make the declaration of X appear in CLASS scope.  */
end_comment

begin_function
name|tree
name|pushdecl_class_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|tree
name|oldclass
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldclass
condition|)
name|class_binding_level
operator|->
name|class_shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|oldclass
argument_list|,
name|class_binding_level
operator|->
name|class_shadowed
argument_list|)
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|decl_obstack
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Tell caller how to interpret a TREE_LIST which contains    chains of FUNCTION_DECLS.  */
end_comment

begin_function
name|int
name|overloaded_globals_p
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|==
name|TREE_LIST
argument_list|)
expr_stmt|;
comment|/* Don't commit caller to seeing them as globals.  */
if|if
condition|(
name|TREE_NONLOCAL
argument_list|(
name|list
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Do commit caller to seeing them as globals.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
return|return
literal|1
return|;
comment|/* Do commit caller to not seeing them as globals.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* DECL is a FUNCTION_DECL which may have other definitions already in place.    We get around this by making IDENTIFIER_GLOBAL_VALUE (DECL_ORIGINAL_NAME (DECL))    point to a list of all the things that want to be referenced by that name.    It is then up to the users of that name to decide what to do with that    list.  */
end_comment

begin_function
name|void
name|push_overloaded_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|orig_name
init|=
name|DECL_ORIGINAL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|glob
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|orig_name
argument_list|)
decl_stmt|;
name|DECL_OVERLOADED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|glob
operator|&&
name|TREE_CODE
argument_list|(
name|glob
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|==
name|lang_c
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|glob
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_LANGUAGE
argument_list|(
name|glob
argument_list|)
operator|==
name|lang_c
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"C-language function `%s' overloaded here"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|glob
argument_list|,
literal|"Previous C-language version of this function was `%s'"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_traditional
operator|&&
name|TREE_PERMANENT
argument_list|(
name|glob
argument_list|)
operator|==
literal|1
operator|&&
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
name|overloads_to_forget
operator|=
name|tree_cons
argument_list|(
name|orig_name
argument_list|,
name|glob
argument_list|,
name|overloads_to_forget
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|glob
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|glob
argument_list|)
operator|!=
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|glob
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"conflicting language contexts for declaration of `%s';"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|glob
argument_list|,
literal|"conflicts with previous declaration here"
argument_list|)
expr_stmt|;
block|}
name|glob
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|glob
argument_list|)
argument_list|,
name|glob
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|glob
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|glob
argument_list|)
argument_list|,
name|decl
argument_list|,
name|glob
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|orig_name
argument_list|)
operator|=
name|glob
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|glob
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|glob
condition|)
block|{
name|tree
name|tmp
decl_stmt|,
name|name
decl_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|glob
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|glob
argument_list|)
operator|=
name|decl
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|glob
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|!=
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"conflicting language contexts for declaration of `%s';"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"conflicts with previous declaration here"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|name
condition|)
return|return;
block|}
block|}
if|if
condition|(
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|==
name|lang_c
condition|)
block|{
name|tree
name|decls
init|=
name|glob
decl_stmt|;
while|while
condition|(
name|decls
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|TREE_VALUE
argument_list|(
name|decls
argument_list|)
argument_list|)
operator|==
name|lang_cplusplus
condition|)
name|decls
operator|=
name|TREE_CHAIN
argument_list|(
name|decls
argument_list|)
expr_stmt|;
if|if
condition|(
name|decls
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"C-language function `%s' overloaded here"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|decls
argument_list|)
argument_list|,
literal|"Previous C-language version of this function was `%s'"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|flag_traditional
operator|&&
operator|(
name|glob
operator|==
literal|0
operator|||
name|TREE_PERMANENT
argument_list|(
name|glob
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
name|overloads_to_forget
operator|=
name|tree_cons
argument_list|(
name|orig_name
argument_list|,
name|glob
argument_list|,
name|overloads_to_forget
argument_list|)
expr_stmt|;
name|glob
operator|=
name|tree_cons
argument_list|(
name|orig_name
argument_list|,
name|decl
argument_list|,
name|glob
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|orig_name
argument_list|)
operator|=
name|glob
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|glob
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an implicit declaration for identifier FUNCTIONID    as a function of type int ().  Print a warning if appropriate.  */
end_comment

begin_function
name|tree
name|implicitly_declare
parameter_list|(
name|functionid
parameter_list|)
name|tree
name|functionid
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
name|int
name|temp
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
comment|/* Save the decl permanently so we can warn if definition follows.  */
if|if
condition|(
name|temp
operator|&&
operator|(
name|flag_traditional
operator|||
operator|!
name|warn_implicit
operator|)
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* We used to reuse an old implicit decl here,      but this loses with inline functions because it can clobber      the saved decl chains.  */
comment|/*  if (IDENTIFIER_IMPLICIT_DECL (functionid) != 0)     decl = IDENTIFIER_IMPLICIT_DECL (functionid);   else  */
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|functionid
argument_list|,
name|default_function_type
argument_list|)
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ANSI standard says implicit declarations are in the innermost block.      So we record the decl in the standard fashion.      If flag_traditional is set, pushdecl does it top-level.  */
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_implicit
comment|/* Only one warning per identifier.  */
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"implicit declaration of function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|functionid
argument_list|)
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
operator|(
name|flag_traditional
operator|||
operator|!
name|warn_implicit
operator|)
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return zero if the declaration NEWDECL is valid    when the declaration OLDDECL (assumed to be for the same name)    has already been seen.    Otherwise return an error message format string with a %s    where the identifier should go.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|redeclaration_error_message
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* Because C++ can put things into name space for free, 	 constructs like "typedef struct foo { ... } foo" 	 would look like an erroneous redeclaration.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|"redefinition of `%s'"
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Declarations of functions can insist on internal linkage 	 but they can't be inconsistent with internal linkage, 	 so there can be no error on that account. 	 However defining the same name twice is no good.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
comment|/* However, defining once as extern inline and a second 	     time in another way is ok.  */
operator|&&
operator|!
operator|(
name|TREE_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_COMPILER_GENERATED_P
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|"`%s' not declared in class"
return|;
else|else
return|return
literal|"redefinition of `%s'"
return|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Objects declared at top level:  */
comment|/* If at least one is a reference, it's ok.  */
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|||
name|TREE_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reject two definitions.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|"redefinition of `%s'"
return|;
comment|/* Now we have two tentative defs, or one tentative and one real def.  */
comment|/* Insist that the linkage match.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|"conflicting declarations of `%s'"
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Objects declared with block scope:  */
comment|/* Reject two definitions, and reject a definition 	 together with an external reference.  */
if|if
condition|(
operator|!
operator|(
name|TREE_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
return|return
literal|"redeclaration of `%s'"
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the LABEL_DECL corresponding to identifier ID as a label.    Create one if none exists so far for the current function.    This function is called for both label definitions and label references.  */
end_comment

begin_function
name|tree
name|lookup_label
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|decl
operator|==
literal|0
operator|||
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|named_label_uses
operator|==
literal|0
operator|||
name|TREE_PURPOSE
argument_list|(
name|named_label_uses
argument_list|)
operator|!=
name|current_binding_level
operator|->
name|names
operator|||
name|TREE_VALUE
argument_list|(
name|named_label_uses
argument_list|)
operator|!=
name|decl
operator|)
condition|)
block|{
name|named_label_uses
operator|=
name|tree_cons
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|,
name|decl
argument_list|,
name|named_label_uses
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|named_label_uses
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|current_binding_level
expr_stmt|;
block|}
if|if
condition|(
name|decl
operator|!=
literal|0
condition|)
return|return
name|decl
return|;
comment|/* By giving the label type `void *', we can use it as a value.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|id
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Mark that the label's definition has not been seen.  */
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|named_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|named_labels
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|named_label_uses
argument_list|)
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Define a label, specifying the location in the source file.    Return the LABEL_DECL node for the label, if the definition is valid.    Otherwise return 0.  */
end_comment

begin_function
name|tree
name|define_label
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|lookup_label
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* After labels, make any new cleanups go into their      own new (temporary) binding contour.  */
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"duplicate label `%s'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|tree
name|uses
decl_stmt|,
name|prev
decl_stmt|;
comment|/* Mark label as having been defined.  */
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|line
expr_stmt|;
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|uses
operator|=
name|named_label_uses
init|;
name|uses
condition|;
name|prev
operator|=
name|uses
operator|,
name|uses
operator|=
name|TREE_CHAIN
argument_list|(
name|uses
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|uses
argument_list|)
operator|==
name|decl
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|new_decls
init|=
name|b
operator|->
name|names
decl_stmt|;
name|tree
name|old_decls
init|=
operator|(
operator|(
name|tree
operator|)
name|b
operator|==
name|TREE_TYPE
argument_list|(
name|uses
argument_list|)
condition|?
name|TREE_PURPOSE
argument_list|(
name|uses
argument_list|)
else|:
name|NULL_TREE
operator|)
decl_stmt|;
while|while
condition|(
name|new_decls
operator|!=
name|old_decls
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_decls
argument_list|)
operator|==
name|VAR_DECL
comment|/* Don't complain about crossing initialization 			   of temporaries.  They can't be accessed, 			   and they should be cleaned up 			   by the time we get to the label.  */
operator|&&
operator|!
name|TEMP_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|new_decls
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|DECL_INITIAL
argument_list|(
name|new_decls
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|new_decls
argument_list|)
operator|!=
name|error_mark_node
operator|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_decls
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"invalid jump to label `%s'"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|decl
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|new_decls
argument_list|,
literal|"crosses initialization of `%s'"
argument_list|)
expr_stmt|;
block|}
name|new_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|new_decls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tree
operator|)
name|b
operator|==
name|TREE_TYPE
argument_list|(
name|uses
argument_list|)
condition|)
break|break;
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|uses
argument_list|)
expr_stmt|;
else|else
name|named_label_uses
operator|=
name|TREE_CHAIN
argument_list|(
name|uses
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
block|}
end_function

begin_comment
comment|/* Same, but for CASE labels.  */
end_comment

begin_function
name|void
name|define_case_label
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* After labels, make any new cleanups go into their      own new (temporary) binding contour.  */
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the list of declarations of the current level.    Note that this list is in reverse order unless/until    you nreverse it; and when you do nreverse it, you must    store the result back using `storedecls' or you will lose.  */
end_comment

begin_function
name|tree
name|getdecls
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Return the list of type-tags (for structs, etc) of the current level.  */
end_comment

begin_function
name|tree
name|gettags
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|tags
return|;
block|}
end_function

begin_comment
comment|/* Store the list of declarations of the current level.    This is done for the parameter declarations of a function being defined,    after they are modified in the light of any missing parameters.  */
end_comment

begin_function
specifier|static
name|void
name|storedecls
parameter_list|(
name|decls
parameter_list|)
name|tree
name|decls
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|names
operator|=
name|decls
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, store the list of tags of the current level.  */
end_comment

begin_function
specifier|static
name|void
name|storetags
parameter_list|(
name|tags
parameter_list|)
name|tree
name|tags
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|tags
operator|=
name|tags
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, an IDENTIFIER_NODE,    return the structure (or union or enum) definition for that name.    Searches binding levels from BINDING_LEVEL up to the global level.    If THISLEVEL_ONLY is nonzero, searches only the specified context    (but skips any tag-transparent contexts to find one that is    meaningful for tags).    FORM says which kind of type the caller wants;    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.    If the wrong kind of type is found, an error is reported.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag
parameter_list|(
name|form
parameter_list|,
name|name
parameter_list|,
name|binding_level
parameter_list|,
name|thislevel_only
parameter_list|)
name|enum
name|tree_code
name|form
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|thislevel_only
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|!=
name|form
condition|)
block|{
comment|/* Definition isn't the kind we were looking for.  */
name|error
argument_list|(
literal|"`%s' defined as wrong kind of tag"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|thislevel_only
operator|&&
operator|!
name|level
operator|->
name|tag_transparent
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|current_class_type
operator|&&
name|level
operator|->
name|level_chain
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Try looking in this class's tags before heading into 	     global binding level.  */
name|tree
name|these_tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
while|while
condition|(
name|these_tags
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|these_tags
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|these_tags
argument_list|)
argument_list|)
operator|!=
name|form
condition|)
block|{
name|error
argument_list|(
literal|"`%s' defined as wrong kind of tag in class scope"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
name|these_tags
operator|=
name|TREE_CHAIN
argument_list|(
name|these_tags
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given a type, find the tag that was defined for it and return the tag name.    Otherwise return 0.  However, the value can never be 0    in the cases in which this is used.     C++: If NAME is non-zero, this is the new name to install.  This is    done when replacing anonymous tags with real tag names.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag_reverse
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given type TYPE which was not declared in C++ language context,    attempt to find a name by which it is refered.  */
end_comment

begin_function
name|tree
name|typedecl_for_tag
parameter_list|(
name|tag
parameter_list|)
name|tree
name|tag
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|tag
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|TYPE_NAME
argument_list|(
name|tag
argument_list|)
return|;
while|while
condition|(
name|b
condition|)
block|{
name|tree
name|decls
init|=
name|b
operator|->
name|names
decl_stmt|;
while|while
condition|(
name|decls
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decls
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|decls
argument_list|)
operator|==
name|tag
condition|)
break|break;
name|decls
operator|=
name|TREE_CHAIN
argument_list|(
name|decls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decls
condition|)
return|return
name|decls
return|;
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up NAME in the current binding level and its superiors    in the namespace of variables, functions and typedefs.    Return a ..._DECL node of some kind representing its definition,    or return 0 if it is undefined.  */
end_comment

begin_function
name|tree
name|lookup_name
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|val
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* In C++ class fields are between local and global scope,      just before the global scope.  */
elseif|else
if|if
condition|(
name|current_class_type
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|val
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|==
literal|0
operator|&&
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
comment|/* Try to find values from base classes 	     if we are presently defining a type. 	     We are presently only interested in TYPE_DECLs.  */
name|val
operator|=
name|lookup_field
argument_list|(
name|current_class_type
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
return|return
name|val
return|;
if|if
condition|(
name|val
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|val
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name' but look only at current binding level.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_name_current_level
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|name
condition|)
break|break;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|sigsegv
parameter_list|()
block|{
name|error
argument_list|(
literal|"Segmentation violation"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the predefined scalar types of C,    and some nodes representing standard constants (0, 1, (void *)0).    Initialize the global binding level.    Make definitions for built-in primitive functions.  */
end_comment

begin_decl_stmt
name|union
name|tree_node
name|ERROR_MARK_NODE
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_decl_processing
parameter_list|()
block|{
specifier|register
name|tree
name|endlink
decl_stmt|,
name|int_endlink
decl_stmt|,
name|double_endlink
decl_stmt|,
name|ptr_endlink
decl_stmt|;
comment|/* Have to make these distinct before we try using them.  */
name|lang_name_cplusplus
operator|=
name|get_identifier
argument_list|(
literal|"C++"
argument_list|)
expr_stmt|;
name|lang_name_c
operator|=
name|get_identifier
argument_list|(
literal|"C"
argument_list|)
expr_stmt|;
comment|/* Initially, C.  */
name|current_lang_name
operator|=
name|lang_name_c
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|named_labels
operator|=
name|NULL_TREE
expr_stmt|;
name|named_label_uses
operator|=
name|NULL_TREE
expr_stmt|;
name|current_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
name|free_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|==
name|GDB_DEBUG
condition|)
name|fatal
argument_list|(
literal|"GNU C++ does not support GDB symbol info yet, use -g"
argument_list|)
expr_stmt|;
comment|/* Handle signals.  */
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|sigsegv
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|decl_obstack
argument_list|)
expr_stmt|;
comment|/* Must lay these out before anything else gets laid out.  */
if|#
directive|if
literal|0
block|error_mark_node = make_node (ERROR_MARK);
else|#
directive|else
undef|#
directive|undef
name|error_mark_node
name|error_mark_node
operator|=
operator|&
name|ERROR_MARK_NODE
expr_stmt|;
define|#
directive|define
name|error_mark_node
value|(&ERROR_MARK_NODE)
name|TREE_PERMANENT
argument_list|(
name|error_mark_node
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|TREE_TYPE
argument_list|(
name|error_mark_node
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|error_mark_list
operator|=
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|error_mark_list
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* make the binding_level structure for global names.  */
name|global_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|value_identifier
operator|=
name|get_identifier
argument_list|(
literal|"<value>"
argument_list|)
expr_stmt|;
name|this_identifier
operator|=
name|get_identifier
argument_list|(
name|THIS_NAME
argument_list|)
expr_stmt|;
name|in_charge_identifier
operator|=
name|get_identifier
argument_list|(
name|IN_CHARGE_NAME
argument_list|)
expr_stmt|;
comment|/* Define `int' and `char' first so that dbx will output them first.  */
name|integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|,
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Define `char', which is like either `signed char' or `unsigned char'      but not the same as either.  */
name|char_type_node
operator|=
operator|(
name|flag_signed_char
condition|?
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
else|:
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
operator|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"char"
argument_list|)
argument_list|,
name|char_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long int"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned int"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long unsigned int"
argument_list|)
argument_list|,
name|long_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* `unsigned long' or `unsigned int' is the standard type for sizeof.      Traditionally, use a signed type.  */
if|if
condition|(
name|INT_TYPE_SIZE
operator|!=
name|BITS_PER_WORD
condition|)
name|sizetype
operator|=
name|flag_traditional
condition|?
name|long_integer_type_node
else|:
name|long_unsigned_type_node
expr_stmt|;
else|else
name|sizetype
operator|=
name|flag_traditional
condition|?
name|integer_type_node
else|:
name|unsigned_type_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|unsigned_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_unsigned_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_integer_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|short_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SHORT
index|]
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"short int"
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|long_long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long long int"
argument_list|)
argument_list|,
name|long_long_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|short_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned short int"
argument_list|)
argument_list|,
name|short_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|long_long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long long unsigned int"
argument_list|)
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Define both `signed char' and `unsigned char'.  */
name|signed_char_type_node
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"signed char"
argument_list|)
argument_list|,
name|signed_char_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_char_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned char"
argument_list|)
argument_list|,
name|unsigned_char_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|float_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
argument_list|,
name|float_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|float_type_node
argument_list|)
expr_stmt|;
name|double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|DOUBLE_TYPE_SIZE
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
argument_list|,
name|double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|double_type_node
argument_list|)
expr_stmt|;
name|long_double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|long_double_type_node
argument_list|)
operator|=
name|DOUBLE_TYPE_SIZE
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long double"
argument_list|)
argument_list|,
name|long_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|long_double_type_node
argument_list|)
expr_stmt|;
name|integer_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_zero_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_one_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_one_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_two_node
operator|=
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_two_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_three_node
operator|=
name|build_int_2
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_three_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|empty_init_node
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|size_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|size_zero_node
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|size_one_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|size_one_node
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|void_type_node
operator|=
name|make_node
argument_list|(
name|VOID_TYPE
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|,
name|void_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Uses integer_zero_node.  */
name|void_list_node
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|TREE_PARMLIST
argument_list|(
name|void_list_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|null_pointer_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
expr_stmt|;
name|string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
comment|/* make a type for arrays of 256 characters.      256 is picked randomly because we have a type for integers from 0 to 255.      With luck nothing will ever really depend on the length of this      array type.  */
name|char_array_type_node
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* Likewise for arrays of ints.  */
name|int_array_type_node
operator|=
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
name|default_function_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|build_pointer_type
argument_list|(
name|default_function_type
argument_list|)
expr_stmt|;
name|ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|endlink
operator|=
name|void_list_node
expr_stmt|;
name|int_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|double_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|ptr_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|double_ftype_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|double_endlink
argument_list|)
expr_stmt|;
name|double_ftype_double_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|double_endlink
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_int
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|int_endlink
argument_list|)
expr_stmt|;
name|long_ftype_long
operator|=
name|build_function_type
argument_list|(
name|long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr_ptr_int
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|int_endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_ptr_ptr_int
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|void_ftype_ptr_ptr_int
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr_int_int
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|int_endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ptr_ftype_long
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|long_ftype_long
argument_list|)
argument_list|)
expr_stmt|;
name|ptr_ftype_ptr_int_int_ptr
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|ptr_endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|ptr_endlink
argument_list|)
expr_stmt|;
name|void_ftype_ptr_int_int_ptr_int_int
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|void_ftype_ptr_int_int
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VTABLE_USES_MASK
comment|/* This is primarily for virtual function definition.  We      declare an array of `void *', which can later be      converted to the appropriate function pointer type.      To do pointers to members, we need a mask which can      distinguish an index value into a virtual function table      from an address.  */
name|vtbl_mask
operator|=
name|build_int_2
argument_list|(
operator|~
operator|(
name|VINDEX_MAX
operator|-
literal|1
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vtbl_type_node
operator|=
name|build_array_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|vtbl_type_node
argument_list|)
expr_stmt|;
name|vtbl_type_node
operator|=
name|build_type_variant
argument_list|(
name|vtbl_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_alloca"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|int_endlink
argument_list|)
argument_list|,
name|BUILT_IN_ALLOCA
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_abs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_ABS
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_fabs"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FABS
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_labs"
argument_list|,
name|long_ftype_long
argument_list|,
name|BUILT_IN_LABS
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_ffs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_FFS
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Support for these has not been written in either expand_builtin      or build_function_call.  */
block|builtin_function ("__builtin_div", default_ftype, BUILT_IN_DIV);   builtin_function ("__builtin_ldiv", default_ftype, BUILT_IN_LDIV);   builtin_function ("__builtin_ffloor", double_ftype_double, BUILT_IN_FFLOOR);   builtin_function ("__builtin_fceil", double_ftype_double, BUILT_IN_FCEIL);   builtin_function ("__builtin_fmod", double_ftype_double_double, BUILT_IN_FMOD);   builtin_function ("__builtin_frem", double_ftype_double_double, BUILT_IN_FREM);   builtin_function ("__builtin_memcpy", void_ftype_ptr_ptr_int, BUILT_IN_MEMCPY);   builtin_function ("__builtin_memcmp", int_ftype_ptr_ptr_int, BUILT_IN_MEMCMP);   builtin_function ("__builtin_memset", void_ftype_ptr_int_int, BUILT_IN_MEMSET);   builtin_function ("__builtin_fsqrt", double_ftype_double, BUILT_IN_FSQRT);   builtin_function ("__builtin_getexp", double_ftype_double, BUILT_IN_GETEXP);   builtin_function ("__builtin_getman", double_ftype_double, BUILT_IN_GETMAN);
endif|#
directive|endif
comment|/* C++ extensions */
name|unknown_type_node
operator|=
name|make_node
argument_list|(
name|UNKNOWN_TYPE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unknown type"
argument_list|)
argument_list|,
name|unknown_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Indirecting an UNKNOWN_TYPE node yields an UNKNOWN_TYPE node.  */
name|TREE_TYPE
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
comment|/* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same result.  */
name|TYPE_POINTER_TO
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
comment|/* Define these now, but use 0 as their DECL_FUNCTION_CODE.  This      will install them in the global binding level, but cause them      to be expanded normally.  */
name|builtin_function
argument_list|(
literal|"__main"
argument_list|,
name|default_function_type
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"__main"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_saveregs"
argument_list|,
name|default_function_type
argument_list|,
name|BUILT_IN_SAVEREGS
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_classify_type"
argument_list|,
name|default_function_type
argument_list|,
name|BUILT_IN_CLASSIFY_TYPE
argument_list|)
expr_stmt|;
block|{
comment|/* Simplify life by making a "vtable_entry_type".  Give its        fields names so that the debugger can use them.  */
name|tree
name|fields
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vtable_entry_type
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|CLASSTYPE_OFFSET
argument_list|(
name|vtable_entry_type
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|VTABLE_DELTA_NAME
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|VTABLE_INDEX_NAME
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|VTABLE_PFN_NAME
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|vtable_entry_type
argument_list|)
operator|=
name|fields
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|vtable_entry_type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|fields
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|vtable_entry_type
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|vtable_entry_type
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|vtable_entry_type
argument_list|)
expr_stmt|;
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|vtable_entry_type
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|vtable_entry_type
argument_list|)
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
name|VTBL_PTR_TYPE
argument_list|)
argument_list|,
name|vtable_entry_type
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make this part of an invisible union.  */
name|fields
index|[
literal|3
index|]
operator|=
name|copy_node
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|short_integer_type_node
expr_stmt|;
name|DECL_NAME
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|VTABLE_DELTA2_NAME
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
operator|=
name|fields
index|[
literal|3
index|]
expr_stmt|;
name|vtable_entry_type
operator|=
name|build_type_variant
argument_list|(
name|vtable_entry_type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOS
if|if
condition|(
name|flag_all_virtual
operator|==
literal|2
condition|)
block|{
name|tree
name|fields
index|[
literal|5
index|]
decl_stmt|;
name|tree
name|ptr_ftype_default
init|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|builtin_function
argument_list|(
literal|"sosFindCode"
argument_list|,
name|ptr_ftype_default
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sosLookup"
argument_list|,
name|ptr_ftype_default
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sosImport"
argument_list|,
name|ptr_ftype_default
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sosDynError"
argument_list|,
name|ptr_ftype_default
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|zlink_type
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|CLASSTYPE_OFFSET
argument_list|(
name|zlink_type
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"n"
argument_list|)
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"t"
argument_list|)
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"ptr"
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|default_function_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|zlink_type
argument_list|)
operator|=
name|fields
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|zlink_type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|fields
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|zlink_type
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|zlink_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|layout_type
argument_list|(
name|zlink_type
argument_list|)
expr_stmt|;
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|zlink_type
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|zret_type
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|CLASSTYPE_OFFSET
argument_list|(
name|zret_type
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"cn"
argument_list|)
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"ptr"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|default_function_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"n"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|3
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"bcl"
argument_list|)
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|4
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"f"
argument_list|)
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|zret_type
argument_list|)
operator|=
name|fields
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|TREE_CHAIN
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|fields
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|zret_type
expr_stmt|;
block|}
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|zret_type
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|zret_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|layout_type
argument_list|(
name|zret_type
argument_list|)
expr_stmt|;
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|zret_type
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Now, C++.  */
name|current_lang_name
operator|=
name|lang_name_cplusplus
expr_stmt|;
name|auto_function
argument_list|(
literal|"__builtin_new"
argument_list|,
name|ptr_ftype_long
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|auto_function
argument_list|(
literal|"__builtin_vec_new"
argument_list|,
name|ptr_ftype_ptr_int_int_ptr
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|auto_function
argument_list|(
literal|"__builtin_delete"
argument_list|,
name|void_ftype_ptr
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|auto_function
argument_list|(
literal|"__builtin_vec_delete"
argument_list|,
name|void_ftype_ptr_int_int_ptr_int_int
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|abort_fndecl
operator|=
name|define_function
argument_list|(
literal|"abort"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unhandled_exception_fndecl
operator|=
name|define_function
argument_list|(
literal|"__unhandled_exception"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Perform other language dependent initializations.  */
name|init_class_processing
argument_list|()
expr_stmt|;
name|init_init_processing
argument_list|()
expr_stmt|;
name|init_search_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
condition|)
block|{
name|init_exception_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
condition|)
comment|/* Too much trouble to inline all the trys needed for this.  */
name|flag_this_is_variable
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|flag_no_inline
condition|)
name|flag_inline_functions
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|init_cadillac
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a definition for a builtin function named NAME and whose data type    is TYPE.  TYPE should be a function type with argument types.    FUNCTION_CODE tells later passes how to compile calls to this function.    See tree.h for its possible values.  */
end_comment

begin_decl_stmt
name|tree
name|define_function
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|function_code
argument_list|,
name|pfn
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|built_in_function
name|function_code
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|pfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|tree
name|decl
init|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_function_rtl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfn
condition|)
name|pfn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_SET_FUNCTION_CODE
argument_list|(
name|decl
argument_list|,
name|function_code
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Called when a declaration is seen that contains no names to declare.    If its type is a reference to a structure, union or enum inherited    from a containing scope, shadow that tag name for the current scope    with a forward reference.    If its type defines a new named structure or union    or defines an enum, it is valid but we need not do anything here.    Otherwise, it is an error.     C++: may have to grok the declspecs to learn about static,    complain for anonymous unions.  */
end_comment

begin_function
name|void
name|shadow_tag
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|int
name|found_tag
init|=
literal|0
decl_stmt|;
name|int
name|warned
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|,
name|ok_code
init|=
name|ERROR_MARK
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|link
operator|=
name|declspecs
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
comment|/* Used to test also that TYPE_SIZE (value) != 0. 	   That caused warning for `struct foo;' at top level in the file.  */
block|{
specifier|register
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
name|name
operator|=
name|lookup_tag_reverse
argument_list|(
name|value
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
name|t
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|class_binding_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|int
name|temp
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
if|if
condition|(
name|temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
name|t
operator|=
name|make_lang_type
argument_list|(
name|code
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|ok_code
operator|=
name|code
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|name
operator|!=
literal|0
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
name|ok_code
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|ok_code
operator|!=
name|ERROR_MARK
condition|)
name|found_tag
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|warned
condition|)
name|warning
argument_list|(
literal|"useless keyword or type name in declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* This is where the variables in an anonymous union are      declared.  An anonymous union declaration looks like:      union { ... } ;      because there is no declarator after the union, the parser      sends that declaration here.  */
if|if
condition|(
name|ok_code
operator|==
name|UNION_TYPE
operator|&&
name|t
operator|!=
name|NULL_TREE
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|NULL_TREE
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|finish_anon_union
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ok_code
operator|==
name|RECORD_TYPE
operator|&&
name|found_tag
operator|==
literal|1
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|t
argument_list|,
literal|"redeclaration of exception `%s'"
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|ename
decl_stmt|,
name|decl
decl_stmt|;
name|int
name|temp
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
name|int
name|momentary
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
if|if
condition|(
name|temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|pushclass
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_exception
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ename
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ename
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|ename
operator|=
name|DECL_NAME
argument_list|(
name|ename
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ename
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|finish_exception_decl
argument_list|(
name|current_class_name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|end_exception_decls
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|momentary
condition|)
name|resume_momentary
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|warned
condition|)
block|{
if|if
condition|(
name|found_tag
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"multiple types in one declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_tag
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"empty declaration"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a "typename", such as "int **", returning a ..._TYPE node.  */
end_comment

begin_function
name|tree
name|groktypename
parameter_list|(
name|typename
parameter_list|)
name|tree
name|typename
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|typename
return|;
return|return
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode a declarator in an ordinary declaration or data definition.    This is called as soon as the type information and variable name    have been parsed, before parsing the initializer if any.    Here we create the ..._DECL node, fill in its type,    and put it on the list of decls for the current context.    The ..._DECL node is returned as the value.     Exception: for arrays where the length is not specified,    the type is left null, to be filled in by `finish_decl'.     Function definitions do not come here; they go to start_function    instead.  However, external and forward declarations of functions    do go through here.  Structure field declarations are done by    grokfield and not through here.  */
end_comment

begin_comment
comment|/* Set this to zero to debug not using the temporary obstack    to parse initializers.  */
end_comment

begin_decl_stmt
name|int
name|debug_temp_inits
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|start_decl
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|initialized
parameter_list|,
name|raises
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|tree
name|raises
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
name|initialized
argument_list|,
name|raises
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|type
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|init_written
init|=
name|initialized
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|decl
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Don't lose if destructors must be executed at file-level.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_PERMANENT
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|decl
operator|=
name|copy_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|itype
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|itype
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|itype
operator|=
name|build_index_type
argument_list|(
name|copy_to_permanent
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
block|}
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
comment|/* Interesting work for this is done in `finish_exception_decl'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If it was not explicitly declared `extern', 	 revoke any previous claims of TREE_EXTERNAL.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pushclass
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* If this type of object needs a cleanup, and control may      jump past it, make a new binding level so that it is cleaned      up only when it is initialized first.  */
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|==
literal|0
condition|)
name|pushlevel_temporary
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `finish_decl' to ignore the initializer once it is parsed.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
comment|/* typedef foo = bar  means give foo the same type as bar. 	   We haven't parsed bar yet, so `finish_decl' will fix that up. 	   Any other case of an initialization in a TYPE_DECL is an error.  */
if|if
condition|(
name|pedantic
operator|||
name|list_length
argument_list|(
name|declspecs
argument_list|)
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"typedef `%s' is initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
name|error
argument_list|(
literal|"function `%s' is initialized like a variable"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* Don't allow initializations for incomplete types 	   except for arrays which might be completed by the initialization.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|/* A complete type is ok.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"variable `%s' has initializer but incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"elements of array `%s' have incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|initialized
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"aggregate `%s' has incomplete type and cannot be initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Change the type so that assemble_variable will give 	     DECL an rtl we can live with: (mem (const_int 0)).  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
comment|/* If any base type in the hierarchy of TYPE needs a constructor, 	     then we set initialized to 1.  This way any nodes which are 	     created for the purposes of initializing this aggregate 	     will live as long as it does.  This is necessary for global 	     aggregates which do not have their initializers processed until 	     the end of the file.  */
name|initialized
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|initialized
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"declaration of `%s' has `extern' and is initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Tell `pushdecl' this is an initialized decl 	 even though we don't yet have the initializer expression. 	 Also tell `finish_decl' it may store the real initializer.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Add this decl to the current binding level, but not if it      comes from another scope, e.g. a static member variable.      TEM may equal DECL or it may be a previous decl of the same name.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|LANG_TYPE
condition|)
name|tem
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|tem
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|tem2
init|=
name|value_member
argument_list|(
name|decl
argument_list|,
name|tem
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem2
operator|!=
name|NULL_TREE
condition|)
name|tem
operator|=
name|TREE_VALUE
argument_list|(
name|tem2
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|tem
operator|&&
operator|!
name|decls_match
argument_list|(
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
condition|)
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
name|NULL_TREE
condition|)
name|tem
operator|=
name|decl
expr_stmt|;
else|else
name|tem
operator|=
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
literal|0
comment|/* We don't do this yet for GNU C++.  */
comment|/* For a local variable, define the RTL now.  */
block|if (current_binding_level != global_binding_level
comment|/* But not if this is a duplicate decl 	 and we preserved the rtl from the previous one 	 (which may or may not happen).  */
block|&& DECL_RTL (tem) == 0)     {       if (TYPE_SIZE (TREE_TYPE (tem)) != 0) 	expand_decl (tem);       else if (TREE_CODE (TREE_TYPE (tem)) == ARRAY_TYPE&& DECL_INITIAL (tem) != 0) 	expand_decl (tem);     }
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_OVERLOADED
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* @@ Also done in start_function.  */
name|push_overloaded_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_written
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|PARM_DECL
operator|||
operator|(
name|TREE_READONLY
argument_list|(
name|tem
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|FIELD_DECL
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* When parsing and digesting the initializer, 	 use temporary storage.  Do this even if we will ignore the value.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|debug_temp_inits
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
comment|/* In this case, the initializer must lay down in permanent 	       storage, since it will be saved until `finish_file' is run.   */
empty_stmt|;
else|else
name|temporary_allocation
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Handle initialization of references.    These three arguments from from `finish_decl', and have the    same meaning here that they do there.  */
end_comment

begin_function
specifier|static
name|void
name|grok_reference_init
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|,
name|cleanupp
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|init
decl_stmt|;
name|tree
modifier|*
name|cleanupp
decl_stmt|;
block|{
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
name|int
name|is_reference
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|tree
name|this_ptr_type
decl_stmt|,
name|actual_init
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"variable declared as reference not initialized"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|is_reference
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
expr_stmt|;
name|tmp
operator|=
name|is_reference
condition|?
name|convert_from_reference
argument_list|(
name|init
argument_list|)
else|:
name|init
expr_stmt|;
if|if
condition|(
name|is_reference
condition|)
block|{
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|errstr
operator|=
literal|"initialization of `%s' from dissimilar reference type"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|is_reference
operator|=
literal|0
expr_stmt|;
name|init
operator|=
name|tmp
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Note: default conversion is only called in very 	     special cases.  */
name|init
operator|=
name|default_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
block|{
name|init
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init
operator|!=
name|error_mark_node
operator|&&
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|errstr
operator|=
literal|"invalid type conversion for reference"
expr_stmt|;
block|}
if|if
condition|(
name|errstr
condition|)
block|{
comment|/* Things did not go smoothly; look for type conversion.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL_TREE
condition|)
block|{
name|init
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
name|errstr
operator|=
literal|"ambiguous pointer conversion"
expr_stmt|;
else|else
name|errstr
operator|=
literal|0
expr_stmt|;
name|is_reference
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL_TREE
condition|)
block|{
name|init
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
name|errstr
operator|=
literal|"ambiguous pointer conversion"
expr_stmt|;
else|else
name|errstr
operator|=
literal|0
expr_stmt|;
name|is_reference
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|errstr
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* In the case of initialization, it is permissable      to assign one reference to another.  */
name|this_ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_reference
condition|)
block|{
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|init
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|save_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
else|else
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lvalue_p
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_ptr_type
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|save_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_decl
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|copy_node
argument_list|(
name|current_class_decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|actual_init
operator|=
name|unary_complex_lvalue
argument_list|(
name|ADDR_EXPR
argument_list|,
name|init
argument_list|)
operator|)
condition|)
block|{
comment|/* The initializer for this decl goes into its 	 DECL_REFERENCE_SLOT.  Make sure that we can handle 	 multiple evaluations without ill effect.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|actual_init
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|actual_init
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEW_EXPR
condition|)
name|actual_init
operator|=
name|save_expr
argument_list|(
name|actual_init
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_ptr_type
argument_list|)
argument_list|,
name|actual_init
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|save_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
comment|/* Section 8.4.3 allows us to make a temporary for        the initialization of const&.  */
block|{
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|tmp_addr
decl_stmt|;
name|tmp
operator|=
name|get_temp_name
argument_list|(
name|target_type
argument_list|,
name|current_binding_level
operator|==
name|global_binding_level
argument_list|)
expr_stmt|;
name|tmp_addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tmp_addr
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_ptr_type
argument_list|)
argument_list|,
name|tmp_addr
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
comment|/* lay this variable out now.  Otherwise `output_addressed_constants' 		 gets confused by its initializer.  */
name|make_decl_rtl
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|static_aggregates
operator|=
name|perm_tree_cons
argument_list|(
name|init
argument_list|,
name|tmp
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init
operator|=
name|build_method_call
argument_list|(
name|tmp
argument_list|,
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|target_type
argument_list|)
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cleanupp
operator|=
name|maybe_build_cleanup
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DECL_INITIAL
argument_list|(
name|tmp
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|tmp
argument_list|)
operator|=
name|current_binding_level
operator|==
name|global_binding_level
expr_stmt|;
name|finish_decl
argument_list|(
name|tmp
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"type mismatch in initialization of `%s' (use `const')"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* ?? Can this be optimized in some cases to      hand back the DECL_INITIAL slot??  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|convert_from_reference
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_LITERAL
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|expand_static_init
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish processing of a declaration;    install its line number and initial value.    If the length of an array type is not known before,    it must be determined now, from the initial value, or it is an error.     For C++, `finish_decl' must be fairly evasive:  it must keep initializers    for aggregates that have constructors alive on the permanent obstack,    so that the global initializing functions can be written at the end.     INIT0 holds the value of an initializer that should be allowed to escape    the normal rules.     For functions that take defualt parameters, DECL points to its    "maximal" instantiation.  finish_decl must then also declared its    subsequently lower and lower forms of instantiation, checking for    ambiguity as it goes.  This can be sped up later.  */
end_comment

begin_function
name|void
name|finish_decl
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
block|{
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|cleanup
init|=
name|NULL_TREE
decl_stmt|,
name|ttype
decl_stmt|;
name|int
name|was_incomplete
decl_stmt|;
name|int
name|temporary
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
name|char
modifier|*
name|asmspec
init|=
literal|0
decl_stmt|;
name|int
name|was_readonly
init|=
literal|0
decl_stmt|;
comment|/* If this is 0, then we did not change obstacks.  */
if|if
condition|(
operator|!
name|decl
condition|)
block|{
if|if
condition|(
name|init
condition|)
name|error
argument_list|(
literal|"assignment (not initialization) in declaration"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asmspec_tree
condition|)
block|{
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
comment|/* Zero out old RTL, since we will rewrite it.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If the type of the thing we are declaring either has      a constructor, or has a virtual function table pointer,      AND its initialization was accepted by `start_decl',      then we stayed on the permanent obstack through the      declaration, otherwise, changed obstacks as GCC would.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|was_incomplete
operator|=
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* Take care of TYPE_DECLs up front.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|init
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* typedef foo = bar; store the type of bar as the type of foo.  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|BREAK_C_TAGS
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|type
condition|)
name|warning
argument_list|(
literal|"shadowing previous type declaration of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
name|current_binding_level
operator|==
name|global_binding_level
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|finish_end
goto|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|finish_exception_decl
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
goto|goto
name|finish_end
goto|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|ttype
operator|=
name|target_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|old_id
init|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newname
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|old_id
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|newname
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|bcopy
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|old_id
argument_list|)
argument_list|,
name|newname
operator|+
literal|1
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|old_id
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|old_id
operator|=
name|get_identifier
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|lookup_tag_reverse
argument_list|(
name|ttype
argument_list|,
name|old_id
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
argument_list|)
operator|=
name|old_id
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Currently, GNU C++ puts constants in text space, making them 	 impossible to initialize.  In the future, one would hope for 	 an operating system which understood the difference between 	 initialization and the running of a program.  */
name|was_readonly
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|init
operator|&&
name|init
operator|!=
name|error_mark_node
condition|)
name|assert
argument_list|(
name|TREE_PERMANENT
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec
condition|)
block|{
comment|/* This must override the asm specifier which was placed 	     by grokclassfn.  Lay this out fresh. 	      	     @@ Should emit an error if this redefines an asm-specified 	     @@ name, or if we have already used the function's name.  */
name|DECL_RTL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|asmspec
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If `start_decl' didn't like having an initialization, ignore it now.  */
elseif|else
if|if
condition|(
name|init
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|init
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|grok_reference_init
argument_list|(
name|decl
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
operator|&
name|cleanup
argument_list|)
expr_stmt|;
name|init
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
comment|/* This will keep us from needing to worry about our obstacks.  */
name|assert
argument_list|(
name|init
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|init
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' must be initialized by constructor, not by `{...}'"
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* fix this in `build_functional_cast' instead. 	     Here's the trigger code:  		struct ostream 		{ 		  ostream (); 		  ostream (int, char *); 		  ostream (char *); 		  operator char *(); 		  ostream (void *); 		  operator void *(); 		  operator<< (int); 		}; 		int buf_size = 1024; 		static char buf[buf_size]; 		const char *debug(int i) { 		  char *b =&buf[0]; 		  ostream o = ostream(buf_size, b); 		  o<< i; 		  return buf; 		} 		*/
block|else if (TREE_CODE (init) == NEW_EXPR&& TREE_CODE (TREE_OPERAND (init, 1) == CPLUS_NEW_EXPR)) 	    {
comment|/* User wrote something like `foo x = foo (args)'  */
block|assert (TREE_CODE (TREE_OPERAND (init, 0)) == VAR_DECL); 	      assert (DECL_NAME (TREE_OPERAND (init, 0)) == NULL_TREE);
comment|/* User wrote exactly `foo x = foo (args)'  */
block|if (TYPE_MAIN_VARIANT (type) == TREE_TYPE (init)) 		{ 		  init = build (CALL_EXPR, TREE_TYPE (init), 				TREE_OPERAND (TREE_OPERAND (init, 1), 0), 				TREE_OPERAND (TREE_OPERAND (init, 1), 1), 0); 		  TREE_VOLATILE (init) = 1; 		} 	    }
endif|#
directive|endif
comment|/* We must hide the initializer so that expand_decl 	     won't try to do something it does not understand.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|tree
name|value
init|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|empty_init_node
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
else|else
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_VEC
condition|)
name|init
operator|=
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
comment|/* Don't let anyone try to initialize this variable 	       until we are ready to do so.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|ctype
init|=
name|type
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|ctype
operator|=
name|TREE_TYPE
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|ctype
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"structure `%s' with uninitialized const members"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|ctype
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"structure `%s' with uninitialized reference members"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"uninitialized const `%s'"
argument_list|)
expr_stmt|;
comment|/* Initialize variables in need of static initialization 	 with `empty_init_node' to keep assemble_variable from putting them 	 in the wrong program space.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
block|{
name|tree
name|value
init|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|empty_init_node
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"uninitialized const `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* For top-level declaration, the initial value was read in      the temporary obstack.  MAXINDEX, rtl, etc. to be made below      must go in the permanent obstack; but don't discard the      temporary data yet.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Deduce size of array from initialization, if not already known.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|int
name|do_default
init|=
operator|!
operator|(
operator|(
operator|!
name|pedantic
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|tree
name|initializer
init|=
name|init
condition|?
name|init
else|:
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|initializer
argument_list|,
name|do_default
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
operator|==
literal|1
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"initializer fails to determine size of `%s'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"array size missing in `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"zero-size array `%s'"
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* A static variable with an incomplete type: 	     that is an error if it is initialized or `static'. 	     Otherwise, let it through, but if it is not `extern' 	     then it may cause an error message later.  */
if|if
condition|(
operator|!
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't known"
argument_list|)
expr_stmt|;
name|init
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* An automatic variable with an incomplete type: 	     that is an error.  */
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't known"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|TREE_LITERAL
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't constant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|yes
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* PARM_DECLs get cleanups, too.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
comment|/* Output the assembler code and/or RTL code for variables and functions,      unless the type is an undefined structure or union.      If not, it will get done when the type is completed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
name|int
name|toplev
init|=
name|current_binding_level
operator|==
name|global_binding_level
decl_stmt|;
name|int
name|was_temp
init|=
operator|(
operator|(
name|flag_traditional
operator|||
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|)
operator|)
operator|&&
name|allocation_temporary_p
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|was_temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* If we are in need of a cleanup, get out of any implicit 	 handlers that have been established so far.  */
if|if
condition|(
name|cleanup
operator|&&
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|3
condition|)
block|{
name|pop_implicit_try_blocks
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|more_exceptions_ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
name|toplev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|empty_init_node
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|save_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|asmspec
expr_stmt|;
if|if
condition|(
operator|!
name|toplev
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
comment|/* If this variable is really a constant, then fill its DECL_RTL 		 slot with something which won't take up storage. 		 If something later should take its address, we can always give 		 it legitimate RTL at that time.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
expr|struct
name|rtx_def
operator|*
operator|)
name|gen_reg_rtx
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toplev
condition|)
block|{
comment|/* Keep GCC from complaining that this variable 		 is defined but never used.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|)
expr_stmt|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
if|if
condition|(
name|init
operator|==
literal|0
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Just a constant field.  Should not need any rtl.  */
goto|goto
name|finish_end0
goto|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_temp
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* C++: Handle overloaded functions with defualt parameters.  */
if|if
condition|(
name|DECL_OVERLOADED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|parmtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|prev
init|=
name|NULL_TREE
decl_stmt|;
name|char
modifier|*
name|original_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|tmp_lang_decl
init|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* All variants will share an uncollectable lang_decl.  */
name|copy_decl_lang_specific
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|parmtypes
operator|&&
name|parmtypes
operator|!=
name|void_list_node
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
condition|)
block|{
name|tree
name|fnname
decl_stmt|,
name|fndecl
decl_stmt|;
name|tree
modifier|*
name|argp
init|=
name|prev
condition|?
operator|&
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
else|:
operator|&
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
operator|*
name|argp
operator|=
name|NULL_TREE
expr_stmt|;
name|fnname
operator|=
name|build_decl_overload
argument_list|(
name|original_name
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|argp
operator|=
name|parmtypes
expr_stmt|;
name|fndecl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fnname
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fndecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|TREE_INLINE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Keep G++ from thinking this function is unused. 			 It is only used to speed up search in name space.  */
name|TREE_USED
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|pushdecl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|parmtypes
expr_stmt|;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|=
name|tmp_lang_decl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Cleanups for static variables are handled by `finish_file'.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|init
operator|!=
name|NULL_TREE
condition|)
name|expand_static_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
block|{
comment|/* This is a declared decl which must live until the 	     end of the binding contour.  It may need a cleanup.  */
comment|/* Recompute the RTL of a local array now 	     if it used to be an incomplete type.  */
if|if
condition|(
name|was_incomplete
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If we used it already as memory, it must stay in memory.  */
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If it's still incomplete now, no init will save it.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
condition|)
block|{
comment|/* Do this here, because we did not expand this decl's 		 rtl in start_decl.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cleanup
condition|)
block|{
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
comment|/* Cleanup used up here.  */
name|cleanup
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Compute and store the initial value.  */
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|emit_line_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set this to 0 so we can tell whether an aggregate 	     which was initialized was ever used.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Store the cleanup, if there was one.  */
if|if
condition|(
name|cleanup
condition|)
block|{
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"parser lost in parsing declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_end0
label|:
comment|/* Undo call to `pushclass' that was done in `start_decl' 	 due to initialization of qualified member variable. 	 I.e., Foo::x = 10;  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
name|popclass
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|finish_end
label|:
comment|/* Resume permanent allocation, if not within a function.  */
if|if
condition|(
name|temporary
operator|&&
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|permanent_allocation
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* @@ I don't know whether this is true for GNU C++.  */
comment|/* We need to remember that this array HAD an initialization, 	 but discard the actual nodes, since they are temporary anyway.  */
block|if (DECL_INITIAL (decl) != 0) 	DECL_INITIAL (decl) = error_mark_node;
endif|#
directive|endif
block|}
if|if
condition|(
name|was_readonly
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_static_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|oldstatic
init|=
name|value_member
argument_list|(
name|decl
argument_list|,
name|static_aggregates
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldstatic
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|oldstatic
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"multiple initializations given for `%s'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
block|{
comment|/* Emit code to perform this initialization but once.  */
name|tree
name|temp
init|=
name|get_temp_name
argument_list|(
name|integer_type_node
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|temp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|temp
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|temp
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
else|else
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|temporary
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
if|if
condition|(
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|static_aggregates
operator|=
name|tree_cons
argument_list|(
name|temp
argument_list|,
name|decl
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|static_aggregates
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This code takes into account memory allocation 	 policy of `start_decl'.  Namely, if TYPE_NEEDS_CONSTRUCTING 	 does not hold for this object, then we must make permanent 	 the storage currently in the temporary obstack.  */
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|preserve_initializer
argument_list|()
expr_stmt|;
name|static_aggregates
operator|=
name|perm_tree_cons
argument_list|(
name|init
argument_list|,
name|decl
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make TYPE a complete type based on INITIAL_VALUE.    Return 0 if successful, 1 if INITIAL_VALUE can't be decyphered,    2 if there was no information (in which case assume 1 if DO_DEFAULT).  */
end_comment

begin_function
name|int
name|complete_array_type
parameter_list|(
name|type
parameter_list|,
name|initial_value
parameter_list|,
name|do_default
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|initial_value
decl_stmt|;
name|int
name|do_default
decl_stmt|;
block|{
specifier|register
name|tree
name|maxindex
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|temporary
init|=
operator|(
name|TREE_PERMANENT
argument_list|(
name|type
argument_list|)
operator|&&
name|allocation_temporary_p
argument_list|()
operator|)
decl_stmt|;
comment|/* Don't put temporary nodes in permanent type.  */
if|if
condition|(
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|initial_value
condition|)
block|{
comment|/* Note MAXINDEX  is really the maximum index, 	 one less than the size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|STRING_CST
condition|)
name|maxindex
operator|=
name|build_int_2
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|initial_value
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
specifier|register
name|int
name|nelts
init|=
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
name|nelts
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make an error message unless that happened already.  */
if|if
condition|(
name|initial_value
operator|!=
name|error_mark_node
condition|)
name|value
operator|=
literal|1
expr_stmt|;
comment|/* Prevent further error messages.  */
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|maxindex
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|maxindex
condition|)
block|{
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|=
name|build_index_type
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Lay out the type now that we can get the real answer.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return zero if something is declared to be a member of type    CTYPE when in the context of CUR_TYPE.  STRING is the error    message to print in that case.  Otherwise, quietly return 1.  */
end_comment

begin_function
specifier|static
name|int
name|member_function_or_else
parameter_list|(
name|ctype
parameter_list|,
name|cur_type
parameter_list|,
name|string
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|cur_type
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|ctype
operator|&&
name|ctype
operator|!=
name|cur_type
condition|)
block|{
name|error
argument_list|(
name|string
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `grokdeclarator'.  */
end_comment

begin_comment
comment|/* CTYPE is class type, or null if non-class.    TYPE is type this FUNCTION_DECL should have, either FUNCTION_TYPE    or METHOD_TYPE.    DECLARATOR is the function's name.    VIRTUALP is truthvalue of whether the function is virtual or not.    FLAGS are to be passed through to `grokclassfn'.    QUALS are qualifiers indicating whether the function is `const'    or `volatile'.    RAISES is a list of exceptions that this function can raise.    CHECK is 1 if we must find this method in CTYPE, 0 if we should    not look, and -1 if we should not call `grokclassfn' at all.  */
end_comment

begin_function
specifier|static
name|tree
name|grokfndecl
parameter_list|(
name|ctype
parameter_list|,
name|type
parameter_list|,
name|declarator
parameter_list|,
name|virtualp
parameter_list|,
name|flags
parameter_list|,
name|quals
parameter_list|,
name|raises
parameter_list|,
name|check
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|int
name|virtualp
decl_stmt|;
name|enum
name|overload_flags
name|flags
decl_stmt|;
name|tree
name|quals
decl_stmt|,
name|raises
decl_stmt|;
name|int
name|check
decl_stmt|;
block|{
name|tree
name|cname
decl_stmt|,
name|decl
decl_stmt|;
name|int
name|staticp
init|=
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
decl_stmt|;
if|if
condition|(
name|ctype
condition|)
name|cname
operator|=
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|?
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
else|:
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
else|else
name|cname
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|raises
condition|)
block|{
name|type
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|raises
argument_list|)
expr_stmt|;
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|staticp
condition|)
block|{
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_STATIC_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|quals
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* Dont have DECL_ORIGINAL_NAME yet, so we cannot pretty print it.  */
name|error
argument_list|(
literal|"functions cannot have method qualifiers"
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Caller will do the rest of this.  */
if|if
condition|(
name|check
operator|<
literal|0
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|flags
operator|==
name|NO_SPECIAL
operator|&&
name|ctype
operator|&&
name|declarator
operator|==
name|cname
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* Just handle constructors here.  We could do this 	 inside the following if stmt, but I think 	 that the code is more legible by breaking this 	 case out.  See comments below for what each of 	 the following calls is supposed to do.  */
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|declarator
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|check
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|grok_ctor_properties
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|==
literal|0
condition|)
block|{
name|tmp
operator|=
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"inconsistant declarations for `%s'"
argument_list|)
expr_stmt|;
else|else
block|{
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|decl
operator|=
name|tmp
expr_stmt|;
block|}
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Function gets the ugly name, field gets the nice one. 	 This call may change the type of the function (because 	 of default parameters)! 	  	 Wrappers get field names which will not conflict 	 with constructors and destructors.  */
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|cname
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|check
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPERATOR_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_OPERATOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|grok_op_properties
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|||
name|check
condition|)
return|return
name|decl
return|;
comment|/* Now install the declaration of this function so that 	 others may find it (esp. its DECL_FRIENDLIST). 	 Pretend we are at top level, we will get true 	 reference later, perhaps.  */
name|tmp
operator|=
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"inconsistant declarations for `%s'"
argument_list|)
expr_stmt|;
else|else
block|{
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|decl
operator|=
name|tmp
expr_stmt|;
block|}
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If this declaration supersedes the declaration of 	 a method declared virtual in the base class, then 	 mark this field as being virtual as well.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|ctype
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|basetype
init|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|ctype
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
operator|||
name|flag_all_virtual
operator|==
literal|1
condition|)
block|{
name|tmp
operator|=
name|get_first_matching_virtual
argument_list|(
name|basetype
argument_list|,
name|decl
argument_list|,
name|flags
operator|==
name|DTOR_FLAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
comment|/* The TMP we really want is the one from the deepest 		     baseclass on this path, taking care not to 		     duplicate if we have already found it (via another 		     path to its virtual baseclass.  */
if|if
condition|(
name|staticp
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"method `%s' may not be declared static"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|tmp
argument_list|,
literal|"(since `%s' declared virtual in base class.)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|virtualp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
operator|||
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ctype
argument_list|)
operator|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
operator|!=
name|DECL_VCONTEXT
argument_list|(
name|tmp
argument_list|)
condition|)
name|tmp
operator|=
name|get_first_matching_virtual
argument_list|(
name|DECL_VCONTEXT
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|decl
argument_list|,
name|flags
operator|==
name|DTOR_FLAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_member
argument_list|(
name|tmp
argument_list|,
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* The argument types may have changed... */
name|tree
name|argtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_variant
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argtypes
argument_list|)
argument_list|)
decl_stmt|;
name|argtypes
operator|=
name|commonparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But the return type has not.  */
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|base_variant
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
block|{
name|type
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|raises
argument_list|)
expr_stmt|;
name|raises
operator|==
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|SET_DECL_VINDEX
argument_list|(
name|decl
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tmp
argument_list|,
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|virtualp
condition|)
block|{
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|declarator
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|(
name|write_virtuals
operator|==
literal|2
operator|||
operator|(
name|write_virtuals
operator|==
literal|3
operator|&&
operator|!
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|ctype
argument_list|)
operator|)
operator|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|grokvardecl
parameter_list|(
name|ctype
parameter_list|,
name|type
parameter_list|,
name|declarator
parameter_list|,
name|specbits
parameter_list|,
name|initialized
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|int
name|specbits
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* If you declare a static member so that it 	 can be initialized, the code will reach here.  */
name|tree
name|field
init|=
name|lookup_field
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|tree
name|basetype
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"`%s' is not a static member of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|basetype
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|field
expr_stmt|;
if|if
condition|(
name|initialized
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
comment|/* Complain about multiply-initialized 		 member variables, but don't be faked 		 out if initializer is faked up from `empty_init_node'.  */
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|CONSTRUCTOR
operator|||
name|CONSTRUCTOR_ELTS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|)
condition|)
name|error_with_aggr_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|"multiple initializations of static member `%s::%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|initialized
expr_stmt|;
block|}
comment|/* In class context, static means one per class,      public visibility, and static storage.  */
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* At top level, either `static' or no s.c. makes a definition      (perhaps tentative), and absence of `static' makes it public.  */
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Not at top level, only `static' makes a static definition.  */
else|else
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* `extern' with initialization is invalid if not at top level.  */
if|if
condition|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
operator|&&
name|initialized
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' has both `extern' and initializer"
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Given declspecs and a declarator,    determine the name and type of the object declared    and construct a ..._DECL node for it.    (In one case we can return a ..._TYPE node instead.     For invalid input we sometimes return 0.)     DECLSPECS is a chain of tree_list nodes whose value fields     are the storage classes and type specifiers.     DECL_CONTEXT says which syntactic context this declaration is in:      NORMAL for most contexts.  Make a VAR_DECL or FUNCTION_DECL or TYPE_DECL.      FUNCDEF for a function definition.  Like NORMAL but a few different       error messages in each case.  Return value may be zero meaning       this definition is too screwy to try to parse.      MEMFUNCDEF for a function definition.  Like FUNCDEF but prepares to       handle member functions (which have FIELD context).       Return value may be zero meaning this definition is too screwy to       try to parse.      PARM for a parameter declaration (either within a function prototype       or before a function body).  Make a PARM_DECL, or return void_type_node.      TYPENAME if for a typename (in a cast or sizeof).       Don't make a DECL node; just return the ..._TYPE node.      FIELD for a struct or union field; make a FIELD_DECL.    INITIALIZED is 1 if the decl has an initializer.     In the TYPENAME case, DECLARATOR is really an absolute declarator.    It may also be so in the PARM case, for a prototype where the    argument type is specified but not the name.     This function is where the complicated C meanings of `static'    and `extern' are intrepreted.     For C++, if there is any monkey business to do, the function which    calls this one must do it, i.e., prepending instance variables,    renaming overloaded function names, etc.     Note that for this C++, it is an error to define a method within a class    which does not belong to that class.     Execpt in the case where SCOPE_REFs are implicitly known (such as    methods within a class being redundantly qualified),    declarations which involve SCOPE_REFs are returned as SCOPE_REFs    (class_name::decl_name).  The caller must also deal with this.     If a constructor or destructor is seen, and the context is FIELD,    then the type gains the attribtue TREE_HAS_x.  If such a declaration    is erroneous, NULL_TREE is returned.     QUALS is used only for FUNCDEF and MEMFUNCDEF cases.  For a member    function, these are the qualifiers to give to the `this' pointer.     May return void_type_node if the declarator turned out to be a friend.    See grokfield for details.  */
end_comment

begin_enum
enum|enum
name|return_types
block|{
name|return_normal
block|,
name|return_ctor
block|,
name|return_dtor
block|,
name|return_conversion
block|, }
enum|;
end_enum

begin_function
name|tree
name|grokdeclarator
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|decl_context
parameter_list|,
name|initialized
parameter_list|,
name|raises
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|enum
name|decl_context
name|decl_context
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|tree
name|raises
decl_stmt|;
block|{
name|int
name|specbits
init|=
literal|0
decl_stmt|;
name|int
name|nclasses
init|=
literal|0
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|longlong
init|=
literal|0
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|int
name|virtualp
decl_stmt|,
name|friendp
decl_stmt|,
name|inlinep
decl_stmt|,
name|staticp
decl_stmt|;
name|int
name|explicit_int
init|=
literal|0
decl_stmt|;
name|int
name|explicit_char
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|typedef_type
init|=
literal|0
decl_stmt|;
name|int
name|funcdef_flag
init|=
literal|0
decl_stmt|;
name|int
name|resume_temporary
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|innermost_code
init|=
name|ERROR_MARK
decl_stmt|;
comment|/* Set this to error_mark_node for FIELD_DECLs we could not handle properly.      All FIELD_DECLs we build here have `init' put into their DECL_INITIAL.  */
name|tree
name|init
init|=
literal|0
decl_stmt|;
comment|/* Keep track of what sort of function is being processed      so that we can warn about default return values, or explicit      return values which do not match prescribed defaults.  */
name|enum
name|return_types
name|return_type
init|=
name|return_normal
decl_stmt|;
name|tree
name|dname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ctype
init|=
name|current_class_type
decl_stmt|;
name|tree
name|ctor_return_type
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|overload_flags
name|flags
init|=
name|NO_SPECIAL
decl_stmt|;
name|int
name|seen_scope_ref
init|=
literal|0
decl_stmt|;
name|tree
name|quals
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FUNCDEF
condition|)
name|funcdef_flag
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|NORMAL
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|MEMFUNCDEF
condition|)
name|funcdef_flag
operator|=
operator|-
literal|1
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
if|if
condition|(
name|flag_traditional
operator|&&
name|allocation_temporary_p
argument_list|()
condition|)
block|{
name|resume_temporary
operator|=
literal|1
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|}
comment|/* Look inside a declarator for the name being declared      and get it as a string, for an error message.  */
block|{
name|tree
name|type
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|decl
init|=
name|declarator
decl_stmt|;
name|name
operator|=
literal|0
expr_stmt|;
comment|/* If we see something of the form `aggr_type xyzzy (a, b, c)'        it is either an old-style function declaration or a call to        a constructor.  The following conditional makes recognizes this        case as being a call to a constructor.  Too bad if it is not.  */
comment|/* For Doug Lea, also grok `aggr_type xyzzy (a, b, c)[10][10][10]'.  */
while|while
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|last
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
operator|&&
name|decl
operator|&&
name|declspecs
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCOPE_REF
operator|)
condition|)
block|{
name|type
operator|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|?
name|lookup_name
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
else|:
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
condition|?
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|parmlist_is_exprlist
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* That was an initializer list.  */
name|sorry
argument_list|(
literal|"initializer lists for field declarations"
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|declarator
expr_stmt|;
block|}
name|declarator
operator|=
name|decl
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
goto|goto
name|bot
goto|;
block|}
else|else
block|{
name|tree
name|init
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|init
condition|)
name|error
argument_list|(
literal|"arrays cannot take initializers"
argument_list|)
expr_stmt|;
block|}
else|else
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|parmlist_is_random
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"bad parameter list specification for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad parameter list specification for function"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bot
label|:
empty_stmt|;
block|}
else|else
comment|/* It didn't look like we thought it would, leave the ARRAY_REFs on.  */
name|decl
operator|=
name|declarator
expr_stmt|;
while|while
condition|(
name|decl
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|WRAPPER_EXPR
case|:
comment|/* for C++ wrappers.  */
if|if
condition|(
name|current_lang_name
operator|!=
name|lang_name_cplusplus
condition|)
name|error
argument_list|(
literal|"wrapper declared in \"%s\" language context"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_lang_name
argument_list|)
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|)
expr_stmt|;
name|flags
operator|=
name|WRAPPER_FLAG
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANTI_WRAPPER_EXPR
case|:
comment|/* for C++ wrappers.  */
if|if
condition|(
name|current_lang_name
operator|!=
name|lang_name_cplusplus
condition|)
name|error
argument_list|(
literal|"anti-wrapper declared in \"%s\" language context"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_lang_name
argument_list|)
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ANTI_WRAPPER_FLAG
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|current_lang_name
operator|!=
name|lang_name_cplusplus
condition|)
name|error
argument_list|(
literal|"wrapper predicate declared in \"%s\" language context"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_lang_name
argument_list|)
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|assert
argument_list|(
name|flags
operator|==
name|WRAPPER_FLAG
argument_list|)
expr_stmt|;
name|flags
operator|=
name|WRAPPER_PRED_FLAG
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
comment|/* for C++ destructors!  */
block|{
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rename
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|current_lang_name
operator|!=
name|lang_name_cplusplus
condition|)
name|error
argument_list|(
literal|"destructor declared in \"%s\" language context"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_lang_name
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|)
expr_stmt|;
name|flags
operator|=
name|DTOR_FLAG
expr_stmt|;
name|return_type
operator|=
name|return_dtor
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"destructors must be member functions"
argument_list|)
expr_stmt|;
name|flags
operator|=
name|NO_SPECIAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_class_name
operator|!=
name|name
condition|)
name|rename
operator|=
name|current_class_name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|!=
name|name
condition|)
name|rename
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
condition|)
block|{
name|error
argument_list|(
literal|"destructor `%s' must match class name `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|rename
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|rename
expr_stmt|;
block|}
name|decl
operator|=
name|name
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* C++ reference declaration */
comment|/* fall through */
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|flags
operator|!=
name|DTOR_FLAG
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ctype
condition|)
block|{
name|return_type
operator|=
name|return_ctor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|dname
operator|=
name|decl
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
comment|/* Parse error puts this typespec where 	     a declarator should go.  */
name|error
argument_list|(
literal|"declarator name missing"
argument_list|)
expr_stmt|;
name|dname
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname
operator|&&
name|TREE_CODE
argument_list|(
name|dname
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|dname
operator|=
name|DECL_NAME
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dname
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
else|:
literal|"<nameless>"
expr_stmt|;
name|declspecs
operator|=
name|temp_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
name|decl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OP_IDENTIFIER
case|:
if|if
condition|(
name|current_lang_name
operator|!=
name|lang_name_cplusplus
condition|)
name|error
argument_list|(
literal|"operator declared in \"%s\" language context"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_lang_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* C++ operators: if these are member functions, then 	     they overload the same way normal methods do.  However, 	     if they are declared outside of a classes scope, then 	     they are implicitly treated like `friends', i.e., 	     they do not take any unseen arguments.  */
name|assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|)
expr_stmt|;
name|flags
operator|=
name|OP_FLAG
expr_stmt|;
name|name
operator|=
literal|"operator name"
expr_stmt|;
name|decl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TYPE_EXPR
case|:
if|if
condition|(
name|current_lang_name
operator|!=
name|lang_name_cplusplus
condition|)
name|error
argument_list|(
literal|"type conversion operator declared in \"%s\" language context"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_lang_name
argument_list|)
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|)
expr_stmt|;
name|flags
operator|=
name|TYPENAME_FLAG
expr_stmt|;
name|name
operator|=
literal|"operator<typename>"
expr_stmt|;
comment|/* Go to the absdcl.  */
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|return_type
operator|=
name|return_conversion
expr_stmt|;
break|break;
comment|/* C++ extension */
case|case
name|SCOPE_REF
case|:
if|if
condition|(
name|current_lang_name
operator|!=
name|lang_name_cplusplus
condition|)
name|error
argument_list|(
literal|"member function declared in \"%s\" language context"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_lang_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seen_scope_ref
operator|==
literal|1
condition|)
name|error
argument_list|(
literal|"multiple `::' terms in declarator invalid"
argument_list|)
expr_stmt|;
name|seen_scope_ref
operator|+=
literal|1
expr_stmt|;
block|{
comment|/* Perform error checking, and convert class names to types. 	       We may call grokdeclarator multiple times for the same 	       tree structure, so only do the conversion once.  In this 	       case, we have exactly what we want for `ctype'.  */
name|tree
name|cname
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|cname
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|cname
argument_list|)
condition|)
name|ctype
operator|=
name|cname
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|cname
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Must test TREE_OPERAND (decl, 1), in case user gives 	       us `typedef (class::memfunc)(int); memfunc *memfuncptr;'  */
elseif|else
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cname
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
name|ctype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cname
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
else|else
block|{
name|tree
name|new_type
init|=
name|get_base_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cname
argument_list|)
argument_list|)
argument_list|,
name|ctype
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_type
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"type `%s' is not derived from type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cname
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ctype
operator|=
name|new_type
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
block|}
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|==
name|decl
condition|)
block|{
name|return_type
operator|=
name|return_ctor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ERROR_MARK
case|:
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|name
operator|=
literal|"type name"
expr_stmt|;
block|}
comment|/* A function definition's declarator must have the form of      a function declarator.  */
if|if
condition|(
name|funcdef_flag
operator|&&
name|innermost_code
operator|!=
name|CALL_EXPR
condition|)
return|return
literal|0
return|;
comment|/* Anything declared one level down from the top level      must be one of the parameters of a function      (because the body is at least two levels down).  */
comment|/* This heuristic cannot be applied to C++ nodes! Fixed, however,      by not allowing C++ class definitions to specify their parameters      with xdecls (must be spec.d in the parmlist).       Since we now wait to push a class scope until we are sure that      we are in a legitimate method context, we must set oldcname      explicitly (since current_class_name is not yet alive).  */
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
name|current_binding_level
operator|->
name|level_chain
operator|==
name|global_binding_level
condition|)
name|decl_context
operator|=
name|PARM
expr_stmt|;
comment|/* Look through the decl specs and record which ones appear.      Some typespecs are defined as built-in typenames.      Others, the ones that are modifiers of other types,      are represented by bits in SPECBITS: set the bits for      the modifiers that appear.  Storage class keywords are also in SPECBITS.       If there is a typedef name or a type, store the type in TYPE.      This includes builtin typedefs such as `int'.       Set EXPLICIT_INT if the type is `int' or `char' and did not      come from a user typedef.       Set LONGLONG if `long' is mentioned twice.       For C++, constructors and destructors have their own fast treatment.  */
for|for
control|(
name|spec
operator|=
name|declspecs
init|;
name|spec
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|tree
name|id
init|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
decl_stmt|;
comment|/* Certain parse errors slip through.  For example, 	 `int class;' is not caught by the parser. Try 	 weakly to recover here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|spec
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"extraneous `int' ignored"
argument_list|)
expr_stmt|;
else|else
block|{
name|explicit_int
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"extraneous `char' ignored"
argument_list|)
expr_stmt|;
else|else
block|{
name|explicit_char
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
comment|/* C++ aggregate types.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"multiple declarations `%s' and `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|type
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|RID_FIRST_MODIFIER
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ridpointers
index|[
name|i
index|]
operator|==
name|id
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|RID_LONG
operator|&&
name|specbits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|warning
argument_list|(
literal|"`long long long' is too long for GCC"
argument_list|)
expr_stmt|;
else|else
name|longlong
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|warning
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|specbits
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
block|}
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"two or more data types in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
specifier|register
name|tree
name|t
init|=
name|lookup_name
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|error
argument_list|(
literal|"`%s' fails to be a typedef or built in type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
comment|/* Can't change CLASS nodes into RECORD nodes here!  */
name|type
operator|=
name|id
expr_stmt|;
name|found
label|:
block|{}
block|}
name|typedef_type
operator|=
name|type
expr_stmt|;
comment|/* No type at all: default to `int', and set EXPLICIT_INT      because it was not a user-defined typedef.  */
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|explicit_int
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|return_dtor
condition|)
name|type
operator|=
name|void_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_ctor
condition|)
name|type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|ctor_return_type
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|funcdef_flag
operator|&&
name|warn_return_type
operator|&&
name|return_type
operator|==
name|return_normal
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator|)
operator|)
condition|)
name|warn_about_return_type
operator|=
literal|1
expr_stmt|;
comment|/* Save warning until we know what is really going on.  */
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_dtor
condition|)
block|{
name|error
argument_list|(
literal|"return type specification for destructor invalid"
argument_list|)
expr_stmt|;
name|type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_ctor
condition|)
block|{
name|warning
argument_list|(
literal|"return type specification for constructor invalid"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|ctor_return_type
argument_list|)
expr_stmt|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now process the modifiers that were specified      and check for invalid combinations.  */
comment|/* Long double is a special combination.  */
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|&&
name|type
operator|==
name|double_type_node
condition|)
block|{
name|specbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
expr_stmt|;
name|type
operator|=
name|long_double_type_node
expr_stmt|;
block|}
comment|/* Check all other uses of type modifiers.  */
if|if
condition|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit_int
operator|&&
operator|!
name|explicit_char
operator|&&
operator|!
name|pedantic
condition|)
name|error
argument_list|(
literal|"long, short, signed or unsigned used invalidly for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|&&
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
condition|)
name|error
argument_list|(
literal|"long and short specified together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|||
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator|)
operator|&&
name|explicit_char
condition|)
name|error
argument_list|(
literal|"long or short specified with char for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|&&
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
condition|)
name|error
argument_list|(
literal|"signed and unsigned given together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
condition|)
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
condition|)
name|type
operator|=
name|short_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|unsigned_char_type_node
expr_stmt|;
else|else
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|&&
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|signed_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
condition|)
name|type
operator|=
name|short_integer_type_node
expr_stmt|;
block|}
block|}
comment|/* Set CONSTP if this declaration is `const', whether by      explicit specification or via a typedef.      Likewise for VOLATILEP.  */
name|constp
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_CONST
operator|)
operator|+
name|TREE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|volatilep
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_VOLATILE
operator|)
operator|+
name|TREE_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
name|inlinep
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_VIRTUAL
operator|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
condition|)
name|staticp
operator|=
literal|1
operator|+
operator|(
name|decl_context
operator|==
name|FIELD
operator|)
expr_stmt|;
if|if
condition|(
name|virtualp
operator|&&
name|staticp
operator|==
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"member `%s' cannot be declared both virtual and static"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
name|friendp
operator|=
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_FRIEND
operator|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_VIRTUAL
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_FRIEND
operator|)
operator|)
expr_stmt|;
comment|/* Warn if two storage classes are given. Default to `auto'.  */
if|if
condition|(
name|specbits
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
name|nclasses
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"storage class specifiers invalid in parameter declarations"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
name|error
argument_list|(
literal|"typedef declaration invalid in parameter declaration"
argument_list|)
expr_stmt|;
name|nclasses
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
name|nclasses
operator|++
expr_stmt|;
block|}
comment|/* Give error if `virtual' is used outside of class declaration.  */
if|if
condition|(
name|virtualp
operator|&&
name|current_class_name
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"virtual outside class declaration"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Warn about storage classes that are invalid for certain      kinds of declarations (parameters, typenames, etc.).  */
if|if
condition|(
name|nclasses
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"multiple storage classes in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|!=
name|NORMAL
operator|&&
name|nclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
operator|(
name|specbits
operator|&
operator|(
comment|/* C++ allows static class elements  */
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
comment|/* ...and inlines  */
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
comment|/* ...and signed and unsigned elements.  */
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator|)
condition|)
block|{
comment|/* A typedef which was made in a class's scope.  */
name|tree
name|loc_typedecl
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
comment|/* keep `grokdeclarator' from thinking we are in PARM context.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|loc_typedecl
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|initialized
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
name|pi
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|loc_typedecl
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|loc_typedecl
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|tree
name|ref
init|=
name|lookup_tag
argument_list|(
name|ENUMERAL_TYPE
argument_list|,
name|DECL_NAME
argument_list|(
name|loc_typedecl
argument_list|)
argument_list|,
name|current_binding_level
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
name|pushtag
argument_list|(
name|DECL_NAME
argument_list|(
name|loc_typedecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|loc_typedecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|loc_typedecl
argument_list|)
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|loc_typedecl
argument_list|,
literal|"typedef of `%s' in class scope hides previous declaration"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Must push this into scope via `pushdecl_class_level'.  */
block|IDENTIFIER_CLASS_VALUE (DECL_NAME (loc_typedecl)) = loc_typedecl;
endif|#
directive|endif
return|return
name|loc_typedecl
return|;
block|}
else|else
block|{
name|error
argument_list|(
operator|(
name|decl_context
operator|==
name|FIELD
condition|?
literal|"storage class specified for structure field `%s'"
else|:
operator|(
name|decl_context
operator|==
name|PARM
condition|?
literal|"storage class specified for parameter `%s'"
else|:
literal|"storage class specified for typename"
operator|)
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
condition|)
name|error
argument_list|(
literal|"top-level declaration of `%s' specifies `auto'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (specbits& (1<< (int) RID_REGISTER)) 	error ("top-level declaration of `%s' specifies `register'", name);
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* I'm not sure under what circumstances we should turn 	 on the extern bit, and under what circumstances we should 	 warn if other bits are turned on.  */
block|if (decl_context == NORMAL&& (specbits& (1<< (int) RID_EXTERN)) == 0&& ! root_lang_context_p ()) 	{ 	  specbits |= (1<< (int) RID_EXTERN); 	}
endif|#
directive|endif
block|}
comment|/* Now figure out the structure of the declarator proper.      Descend through it, creating more complex types, until we reach      the declared identifier (or NULL_TREE, in an absolute declarator).  */
while|while
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]), 	 an INDIRECT_REF (for *...), 	 a CALL_EXPR (for ...(...)), 	 an identifier (for the name being declared) 	 or a null pointer (for the place in an absolute declarator 	 where the name was omitted). 	 For the last two cases, we have just exited the loop.  	 For C++ it could also be 	 a SCOPE_REF (for class :: ...).  In this case, we have converted 	 sensible names to types, and those are the values we use to 	 qualify the member name. 	 an ADDR_EXPR (for&...), 	 a BIT_NOT_EXPR (for destructors) 	 a TYPE_EXPR (for operator typenames) 	 a WRAPPER_EXPR (for wrappers) 	 an ANTI_WRAPPER_EXPR (for averting wrappers)  	 At this point, TYPE is the type of elements of an array, 	 or for a function to return, or for a pointer to point to. 	 After this sequence of ifs, TYPE is the type of the 	 array or function or pointer, and DECLARATOR has had its 	 outermost layer removed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|OP_IDENTIFIER
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|quals
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|declarator
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|SCOPE_REF
operator|)
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|dummy
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|ctype
operator|=
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|dummy
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
case|case
name|ARRAY_REF
case|:
block|{
specifier|register
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|size
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for some types that there cannot be arrays of.  */
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as array of voids"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as array of functions"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|size
condition|)
block|{
comment|/* Must suspend_momentary here because the index 		   type may need to live until the end of the function. 		   For example, it is used in the declaration of a 		   variable which requires destructing at the end of 		   the function; then build_vec_delete will need this 		   value.  */
name|int
name|yes
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
comment|/* might be a cast */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|size
operator|=
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' has non-integer type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|size
argument_list|)
condition|)
name|size
operator|=
name|decl_constant_value
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids zero-size array `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|size
argument_list|)
condition|)
block|{
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|size
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' is negative"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
name|itype
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|size
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids variable-size array `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|itype
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|itype
operator|=
name|build_index_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
block|}
comment|/* Build the array type itself. 	       Merge any constancy or volatility into the target type.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* don't clear these; leave them set so that the array type 	   or the variable is itself const or volatile.  */
block|constp = 0; 	    volatilep = 0;
endif|#
directive|endif
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|arg_types
decl_stmt|;
comment|/* Declaring a function type. 	       Make sure we have a valid type for the function to return.  */
comment|/* Is this an error?  Should they be merged into TYPE here?  */
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
name|warning
argument_list|(
literal|"function declared to return const or volatile result"
argument_list|)
expr_stmt|;
comment|/* Warn about some types functions can't return.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning an array"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|==
name|FIELD
operator|&&
operator|(
name|friendp
operator|==
literal|0
operator|||
name|dname
operator|==
name|current_class_name
operator|)
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|flags
operator|==
name|TYPENAME_FLAG
condition|)
name|TYPE_HAS_CONVERSION
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|==
name|dname
condition|)
block|{
comment|/* We are within a class's scope. If our declarator name 		   is the same as the class name, and we are defining 		   a function, then it is a constructor/destructor, and 		   therefore returns a void type.  */
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
block|{
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"destructor cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
literal|"destructor for alien class `%s' cannot be a member"
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|ctype
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|ctype
argument_list|,
literal|"class `%s' already has destructor defined"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|WRAPPER_FLAG
operator|||
name|flags
operator|==
name|ANTI_WRAPPER_FLAG
condition|)
block|{
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"wrapper cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
literal|"wrapper for alien class `%s' cannot be member"
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|TYPE_WRAP_TYPE
argument_list|(
name|ctype
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|WRAPPER_PRED_FLAG
condition|)
block|{
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"wrapper predicate cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"wrapper predicated must return an integer type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
literal|"wrapper predicate for alien class `%s' cannot be member"
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|TYPE_HAS_WRAPPER_PRED
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* its a constructor. */
block|{
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"constructor cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtualp
operator|||
name|friendp
condition|)
block|{
name|error
argument_list|(
literal|"constructors cannot be declared virtual or friend"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|specbits
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"return value type specifier for `%s' ignored"
argument_list|,
name|flags
operator|==
name|DTOR_FLAG
condition|?
literal|"destructor"
else|:
literal|"constructor"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
literal|"constructor for alien class `%s' cannot be member"
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assert
argument_list|(
name|return_type
operator|==
name|return_ctor
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|friendp
operator|&&
name|virtualp
condition|)
block|{
comment|/* Cannot be both friend and virtual.  */
name|error
argument_list|(
literal|"virtual functions cannot be friends"
argument_list|)
expr_stmt|;
name|specbits
operator|^=
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_FRIEND
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
name|friendp
condition|)
name|error
argument_list|(
literal|"friend declaration not in class definition"
argument_list|)
expr_stmt|;
comment|/* Picky up type qualifiers which should be applied to `this'.  */
name|quals
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Traditionally, declaring return type float means double.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|type
operator|==
name|float_type_node
condition|)
name|type
operator|=
name|double_type_node
expr_stmt|;
comment|/* Construct the function type and go to the next 	       inner layer of declarator.  */
block|{
name|int
name|funcdef_p
decl_stmt|;
name|tree
name|inner_parms
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|inner_decl
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_decl
operator|&&
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|inner_decl
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Say it's a definition only for the CALL_EXPR 		 closest to the identifier.  */
name|funcdef_p
operator|=
operator|(
name|inner_decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|OP_IDENTIFIER
operator|||
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|TYPE_EXPR
operator|)
operator|)
condition|?
name|funcdef_flag
else|:
literal|0
expr_stmt|;
name|arg_types
operator|=
name|grokparms
argument_list|(
name|inner_parms
argument_list|,
name|funcdef_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declarator
condition|)
block|{
comment|/* Get past destructors, wrappers, etc. 		   We know we have one because FLAGS will be non-zero.  		   Complain about improper parameter lists here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict_prototype
operator|==
literal|0
operator|&&
name|arg_types
operator|==
name|NULL_TREE
condition|)
name|arg_types
operator|=
name|void_list_node
expr_stmt|;
elseif|else
if|if
condition|(
name|arg_types
operator|==
name|NULL_TREE
operator|||
name|arg_types
operator|!=
name|void_list_node
condition|)
block|{
name|error
argument_list|(
literal|"destructors cannot be specified with parameters"
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|void_list_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|WRAPPER_EXPR
condition|)
block|{
comment|/* Report misuse of wrappers and their associates. 		       Note that because wrappers may be invoked 		       quite a bit implicitly, if we give an error 		       message, we make an effort to fix that error 		       so that spurious errors do not show up.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* First parameter must be a pointer to a member function. 			   Rest of parameters must all be default parameters.  */
if|if
condition|(
name|arg_types
operator|==
name|NULL_TREE
operator|||
name|arg_types
operator|==
name|void_list_node
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"wrapper predicate takes a pointer-to-member-function as first argument"
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|!=
name|void_list_node
operator|&&
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"all arguments past first must be default for wrapper predicate"
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|declarator
operator|=
name|wrapper_pred_name
expr_stmt|;
block|}
else|else
block|{
comment|/* First parameter must be an int. 			   Second parameter must be a pointer to a member function.  */
if|if
condition|(
name|arg_types
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"wrappers must have at least two arguments (int, pointer-to-member-function)"
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"first argument to wrapper must be an integer"
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"second argument to wrapper must be a pointer-to-member-function type"
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
name|declarator
operator|=
name|wrapper_name
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ANTI_WRAPPER_EXPR
condition|)
name|declarator
operator|=
name|anti_wrapper_name
expr_stmt|;
block|}
name|type
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|flag_traditional
condition|?
literal|0
else|:
name|arg_types
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
comment|/* Filter out pointers-to-references and references-to-references. 	     We can get these if a TYPE_DECL is used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare %s to references"
argument_list|,
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|?
literal|"references"
else|:
literal|"pointers"
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Merge any constancy or volatility into the target type 	     for the pointer.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
block|{
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare references to functions; use pointer to function instead"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
condition|)
name|error
argument_list|(
literal|"invalid type: `void&'"
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Process a list of type modifier keywords (such as 	     const or volatile) that were given inside the `*' or `&'.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|typemodlist
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
for|for
control|(
name|typemodlist
operator|=
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
init|;
name|typemodlist
condition|;
name|typemodlist
operator|=
name|TREE_CHAIN
argument_list|(
name|typemodlist
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
condition|)
name|constp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
name|volatilep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|erred
condition|)
block|{
name|erred
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"invalid type modifier within %s declarator"
argument_list|,
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|?
literal|"reference"
else|:
literal|"pointer"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
block|}
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|SCOPE_REF
case|:
block|{
comment|/* We have converted type names to NULL_TREE if the 	       name was bogus, or to a _TYPE node, if not.  	       The variable CTYPE holds the type we will ultimately 	       resolve to.  The code here just needs to build 	       up appropriate member types.  */
name|tree
name|sname
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* We had a reference to a global decl, or 		   perhaps we were given a non-aggregate typedef, 		   in which case we cleared this out, and should just 		   keep going as though it wasn't there.  */
name|declarator
operator|=
name|sname
expr_stmt|;
continue|continue;
block|}
name|ctype
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sname
operator|==
name|NULL_TREE
condition|)
goto|goto
name|done_scoping
goto|;
comment|/* Destructors can have their visibilities changed as well.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|sname
operator|=
name|TREE_OPERAND
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* This is the `standard' use of the scoping operator: 		   basetype :: member .  */
if|if
condition|(
name|ctype
operator|==
name|current_class_type
operator|||
name|friendp
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_member_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* have to move this code elsewhere in this function. 		       this code is used for i.e., typedef int A::M; M *pm; */
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
name|t
operator|=
name|lookup_field
argument_list|(
name|ctype
argument_list|,
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|t
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|ctype
argument_list|,
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|=
name|init
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* No such field, try member functions.  */
name|t
operator|=
name|lookup_fnfields
argument_list|(
name|CLASSTYPE_AS_LIST
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Don't include destructor with constructors.  */
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"class `%s' does not have any constructors"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sname
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|ctype
argument_list|,
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|=
name|init
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|flags
operator|==
name|TYPENAME_FLAG
condition|)
name|error_with_aggr_type
argument_list|(
name|ctype
argument_list|,
literal|"type conversion is not a member of structure `%s'"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"field `%s' is not a member of structure `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sname
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_member_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|sorry
argument_list|(
literal|"structure `%s' not yet defined"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|sname
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|TYPE_EXPR
condition|)
block|{
comment|/* A TYPE_EXPR will change types out from under us. 		   So do the TYPE_EXPR now, and make this SCOPE_REF 		   inner to the TYPE_EXPR's CALL_EXPR.  		   This does not work if we don't get a CALL_EXPR back. 		   I did not think about error recovery, hence the 		   assert (0).  */
comment|/* Get the CALL_EXPR.  */
name|sname
operator|=
name|grokoptypename
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|CALL_EXPR
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scope the CALL_EXPR's name.  */
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put the SCOPE_EXPR in the CALL_EXPR's innermost position.  */
name|TREE_OPERAND
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
operator|=
name|declarator
expr_stmt|;
comment|/* Now work from the CALL_EXPR.  */
name|declarator
operator|=
name|sname
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
block|{
name|done_scoping
label|:
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
condition|)
comment|/* In this case, we will deal with it later.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_member_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|OP_IDENTIFIER
case|:
comment|/* This is exceptional, in that we must finalize a  	     member type before calling grokopexpr, if we want 	     to use the declared type information to resolve 	     ambiguities.  Do not get fooled by friends, 	     which do not have a member type built for them 	     unless they were explicitly scoped (in which case that 	     will have been taken care of in the SCOPE_REF case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"operator name missing at this point in file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEW_EXPR
condition|)
block|{
name|int
name|was_method
init|=
name|ctype
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
decl_stmt|;
name|type
operator|=
name|coerce_new_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_method
condition|)
name|staticp
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|DELETE_EXPR
condition|)
block|{
name|int
name|was_method
init|=
name|ctype
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
decl_stmt|;
name|type
operator|=
name|coerce_delete_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_method
condition|)
name|staticp
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|ctype
operator|!=
literal|0
operator|&&
operator|(
name|friendp
operator|==
literal|0
operator|||
name|staticp
operator|<
literal|2
operator|)
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|tree
name|tmp
init|=
name|declarator
decl_stmt|;
name|declarator
operator|=
name|grokopexpr
argument_list|(
operator|&
name|tmp
argument_list|,
name|ctype
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|staticp
operator|==
literal|2
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declarator
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_EXPR
case|:
name|declarator
operator|=
name|grokoptypename
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit_int
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"type conversion function declared to return incongruent type"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"return type specified for type conversion function"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|WRAPPER_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COND_EXPR
condition|)
name|declarator
operator|=
name|wrapper_pred_name
expr_stmt|;
else|else
name|declarator
operator|=
name|wrapper_name
expr_stmt|;
break|break;
case|case
name|ANTI_WRAPPER_EXPR
case|:
name|declarator
operator|=
name|anti_wrapper_name
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|declarator
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
name|declarator
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* layout_type (type); */
if|#
directive|if
literal|0
comment|/* @@ Should perhaps replace the following code by changes in        * @@ stor_layout.c. */
block|if (TREE_CODE (type) == FUNCTION_DECL) 	{
comment|/* A function variable in C should be Pmode rather than EPmode 	     because it has just the address of a function, no static chain.*/
block|TYPE_MODE (type) = Pmode; 	}
endif|#
directive|endif
block|}
comment|/* Now TYPE has the actual type.  */
comment|/* If this is declaring a typedef name, return a TYPE_DECL.  */
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
comment|/* If the user declares "struct {...} foo" then `foo' will have 	 an anonymous name.  Fill that name in now.  Nothing can 	 refer to it, so nothing needs know about the name change. 	 The TYPE_NAME field was filled in by build_struct_xref.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
ifndef|#
directive|ifndef
name|BREAK_C_TAGS
operator|&&
name|current_lang_name
operator|==
name|lang_name_cplusplus
endif|#
directive|endif
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* replace the anonymous name with the real name everywhere.  */
name|lookup_tag_reverse
argument_list|(
name|type
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|declarator
expr_stmt|;
comment|/* Replace names of default constructors and/or destructors.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|fnptr
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|fnptr
condition|)
block|{
name|DECL_ORIGINAL_NAME
argument_list|(
name|fnptr
argument_list|)
operator|=
name|declarator
expr_stmt|;
name|fnptr
operator|=
name|TREE_CHAIN
argument_list|(
name|fnptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resume_temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Detect the case of an array type of unspecified size      which came, as such, direct from a typedef name.      We must copy the type, so that each identifier gets      a distinct type, so that each identifier's size can be      controlled separately by its own initializer.  */
if|if
condition|(
name|type
operator|==
name|typedef_type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a type name (such as, in a cast or sizeof),      compute the type and return it now.  */
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
comment|/* Special case: "friend class foo" looks like a TYPENAME context.  */
if|if
condition|(
name|friendp
condition|)
block|{
comment|/* A friendly class?  */
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quals
condition|)
block|{
name|tree
name|dummy
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|dummy
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resume_temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/* `void' at top level (not within pointer)      is allowed only in typedefs or type names.      We don't complain about parms either, but that is because      a better error message can be made later.  */
if|if
condition|(
name|type
operator|==
name|void_type_node
operator|&&
name|decl_context
operator|!=
name|PARM
condition|)
block|{
if|if
condition|(
name|declarator
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
literal|"variable or field `%s' declared void"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"variable or field declared void"
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now create the decl, which may be a VAR_DECL, a PARM_DECL      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
if|if
condition|(
name|ctype
condition|)
name|error
argument_list|(
literal|"cannot use `::' in parameter declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtualp
condition|)
name|error
argument_list|(
literal|"parameter declared `virtual'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
condition|)
name|error
argument_list|(
literal|"`const' and `volatile' function specifiers invalid in parameter declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|friendp
condition|)
name|error
argument_list|(
literal|"invalid friend declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|error
argument_list|(
literal|"invalid raises declaration"
argument_list|)
expr_stmt|;
comment|/* A parameter declared as an array of T is really a pointer to T. 	   One declared as a function is really a pointer to a function. 	   One declared as a member is really a pointer to member.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Transfer const-ness of array into that of type pointed to.  */
name|type
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|constp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Compute the type actually passed in the parmlist, 	   for the case where there is no prototype. 	   (For example, shorts and chars are passed as ints.) 	   When there is a prototype, this is overridden later.  */
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|double_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Happens when declaring arrays of sizes which 	       are error_mark_node, for example.  */
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
block|{
name|error
argument_list|(
literal|"field `%s' declared as a function in %s language context"
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_lang_name
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|friendp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|staticp
operator|<
literal|2
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|TREE_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
name|inlinep
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|TREE_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
name|inlinep
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Handle a class-local exception declaration.  */
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
name|finish_exception_decl
argument_list|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|?
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
else|:
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|staticp
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|||
name|initialized
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|declarator
condition|)
name|error
argument_list|(
literal|"field `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"field has incomplete type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|friendp
condition|)
block|{
if|if
condition|(
name|declarator
condition|)
name|error
argument_list|(
literal|"`%s' is neither function nor method; cannot be declared friend"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"invalid friend declaration"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|friendp
condition|)
block|{
comment|/* Friends are treated specially.  */
if|if
condition|(
name|ctype
operator|==
name|current_class_type
condition|)
name|warning
argument_list|(
literal|"member functions are implicitly friends of their class"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|do_friend
argument_list|(
name|ctype
argument_list|,
name|declarator
argument_list|,
name|decl
argument_list|,
name|last_function_parms
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
return|;
else|else
return|return
name|void_type_node
return|;
block|}
comment|/* Structure field.  It may not be a function, except for C++ */
if|if
condition|(
name|decl
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
name|error
argument_list|(
literal|"field declared `virtual'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
condition|)
name|error
argument_list|(
literal|"`const' and `volatile' function specifiers invalid in field declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|friendp
condition|)
name|error
argument_list|(
literal|"invalid friend declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|error
argument_list|(
literal|"invalid raises declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|staticp
operator|||
operator|(
name|constp
operator|&&
name|initialized
operator|)
condition|)
block|{
comment|/* C++ allows static class members. 		   All other work for this is done by grokfield. 		   This VAR_DECL is built by build_lang_field_decl. 		   All other VAR_DECLs are built by build_decl.  */
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
block|{
if|if
condition|(
name|staticp
condition|)
name|error
argument_list|(
literal|"field `%s' declared static in %s language context"
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_lang_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"field `%s' declared with initializer in %s language context"
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_lang_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|staticp
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* In class context, static means public visibility.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|int
name|was_overloaded
init|=
literal|0
decl_stmt|;
name|tree
name|original_name
init|=
name|declarator
decl_stmt|;
if|if
condition|(
operator|!
name|declarator
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Function declaration not at top level. 	   Storage classes other than `extern' are not allowed 	   and `extern' makes no difference.  */
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
operator|)
operator|)
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
block|{
name|error
argument_list|(
literal|"virtual non-class function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NO_AUTO_OVERLOAD
if|if
condition|(
name|is_overloaded
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
comment|/* Plain overloading: will not be grok'd by grokclassfn.  */
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
name|declarator
operator|=
name|build_decl_overload
argument_list|(
name|name
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|was_overloaded
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
operator|&&
operator|!
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|original_name
argument_list|)
operator|==
literal|4
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'m'
operator|&&
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|original_name
argument_list|)
operator|>
literal|10
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
operator|+
literal|2
argument_list|,
literal|"builtin_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Plain overloading: will not be grok'd by grokclassfn.  */
name|declarator
operator|=
name|build_decl_overload
argument_list|(
name|name
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|was_overloaded
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|staticp
operator|<
literal|2
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* Record presence of `static'.  In C++, `inline' is like `static'.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Record presence of `inline', if it is reasonable.  */
if|if
condition|(
name|inlinep
condition|)
block|{
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|was_overloaded
operator|&&
operator|!
name|ctype
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot inline function `main'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last
operator|&&
name|last
operator|!=
name|void_list_node
condition|)
name|warning
argument_list|(
literal|"inline declaration ignored for function with `...'"
argument_list|)
expr_stmt|;
else|else
comment|/* Assume that otherwise the function can be inlined.  */
name|TREE_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
condition|)
name|current_extern_inline
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|was_overloaded
condition|)
block|{
name|DECL_OVERLOADED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ORIGINAL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|original_name
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's a variable.  */
if|if
condition|(
name|virtualp
condition|)
name|error
argument_list|(
literal|"variable declared `virtual'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|warning
argument_list|(
literal|"variable declared `inline'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
condition|)
name|error
argument_list|(
literal|"`const' and `volatile' function specifiers invalid in field declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|friendp
condition|)
name|error
argument_list|(
literal|"invalid friend declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|error
argument_list|(
literal|"invalid raises declaration"
argument_list|)
expr_stmt|;
comment|/* An uninitialized decl with `extern' is a reference.  */
name|decl
operator|=
name|grokvardecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|declarator
argument_list|,
name|specbits
argument_list|,
name|initialized
argument_list|)
expr_stmt|;
block|}
comment|/* Record `register' declaration for warnings on&        and in case doing stupid register allocation.  */
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
condition|)
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record constancy and volatility.  */
if|if
condition|(
name|constp
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
block|{
name|TREE_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|resume_temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell if a parmlist/exprlist looks like an exprlist or a parmlist.    An empty exprlist is a parmlist.  An exprlist which    contains only identifiers at the global level    is a parmlist.  Otherwise, it is an exprlist. */
end_comment

begin_function
specifier|static
name|int
name|parmlist_is_exprlist
parameter_list|(
name|exprs
parameter_list|)
name|tree
name|exprs
decl_stmt|;
block|{
if|if
condition|(
name|exprs
operator|==
name|NULL_TREE
operator|||
name|TREE_PARMLIST
argument_list|(
name|exprs
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
comment|/* At the global level, if these are all identifiers, 	 then it is a parmlist.  */
while|while
condition|(
name|exprs
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|exprs
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
literal|1
return|;
name|exprs
operator|=
name|TREE_CHAIN
argument_list|(
name|exprs
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Make sure that the this list of PARMS has a chance of being    grokked by `grokparms'.     @@ This is really weak, but the grammar does not allow us    @@ to easily reject things that this has to catch as syntax errors.  */
end_comment

begin_function
specifier|static
name|int
name|parmlist_is_random
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|parms
condition|)
block|{
if|if
condition|(
name|parms
operator|==
name|void_list_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
literal|1
return|;
comment|/* Don't get faked out by overloaded functions, which 	 masquerade as TREE_LISTs!  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|unknown_type_node
condition|)
return|return
literal|1
return|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of `grokparms'.  In a fcn definition, arg types must    be complete.     C++: also subroutine of `start_function'.  */
end_comment

begin_function
specifier|static
name|void
name|require_complete_types_for_parms
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
while|while
condition|(
name|parms
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter has incomplete type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* If the arg types are incomplete in a declaration, 	 they must include undefined tags. 	 These tags can never be defined in the scope of the declaration, 	 so the types can never be completed, 	 and no call can be compiled successfully.  */
comment|/* This is not the right behavior for C++, but not having 	 it is also probably wrong.  */
block|else 	{
comment|/* Now warn if is a pointer to an incomplete type.  */
block|while (TREE_CODE (type) == POINTER_TYPE 		 || TREE_CODE (type) == REFERENCE_TYPE) 	    type = TREE_TYPE (type); 	  type = TYPE_MAIN_VARIANT (type); 	  if (TYPE_SIZE (type) == 0) 	    { 	      if (DECL_NAME (parm) != 0) 		warning ("parameter `%s' points to incomplete type", 			 IDENTIFIER_POINTER (DECL_NAME (parm))); 	      else 		warning ("parameter points to incomplete type"); 	    } 	}
endif|#
directive|endif
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decode the list of parameter types for a function type.    Given the list of things declared inside the parens,    return a list of types.     The list we receive can have three kinds of elements:    an IDENTIFIER_NODE for names given without types,    a TREE_LIST node for arguments given as typespecs or names with typespecs,    or void_type_node, to mark the end of an argument list    when additional arguments are not permitted (... was not used).     FUNCDEF_FLAG is nonzero for a function definition, 0 for    a mere declaration.  A nonempty identifier-list gets an error message    when FUNCDEF_FLAG is zero.    If FUNCDEF_FLAG is 1, then parameter types must be complete.    If FUNCDEF_FLAG is -1, then parameter types may be incomplete.     If all elements of the input list contain types,    we return a list of the types.    If all elements contain no type (except perhaps a void_type_node    at the end), we return a null list.    If some have types and some do not, it is an error, and we    return a null list.     Also set last_function_parms to either    a list of names (IDENTIFIER_NODEs) or a chain of PARM_DECLs.    A list of names is converted to a chain of PARM_DECLs    by store_parm_decls so that ultimately it is always a chain of decls.     Note that in C++, paramters can take default values.  These default    values are in the TREE_PURPOSE field of the TREE_LIST.  It is    an error to specify default values which are followed by parameters    that have no defualt values, or an ELLIPSES.  For simplicities sake,    only parameters which are specified with their types can take on    default values.  */
end_comment

begin_function
specifier|static
name|tree
name|grokparms
parameter_list|(
name|first_parm
parameter_list|,
name|funcdef_flag
parameter_list|)
name|tree
name|first_parm
decl_stmt|;
name|int
name|funcdef_flag
decl_stmt|;
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|first_parm
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|first_parm
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|funcdef_flag
condition|)
name|warning
argument_list|(
literal|"parameter names (without types) in function declaration"
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|first_parm
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Types were specified.  This is a list of declarators 	 each represented as a TREE_LIST node.  */
specifier|register
name|tree
name|parm
decl_stmt|,
name|chain
decl_stmt|;
name|int
name|any_init
init|=
literal|0
decl_stmt|,
name|any_error
init|=
literal|0
decl_stmt|,
name|saw_void
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|first_parm
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|last_result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|last_decl
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|first_parm
init|;
name|parm
operator|!=
name|NULL_TREE
condition|;
name|parm
operator|=
name|chain
control|)
block|{
name|tree
name|type
decl_stmt|,
name|list_node
init|=
name|parm
decl_stmt|;
specifier|register
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* @@ weak defense against parse errors.  */
if|if
condition|(
name|decl
operator|!=
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
comment|/* Give various messages as the need arises.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
name|error
argument_list|(
literal|"invalid string constant `%s'"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"invalid integer constant in parameter list, did you forget to give parameter name?"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|decl
operator|!=
name|void_type_node
condition|)
block|{
comment|/* @@ May need to fetch out a `raises' here.  */
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|PARM
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
continue|continue;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
name|decl
operator|=
name|void_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Cannot use `error_with_decl' here because 			   we don't have DECL_CONTEXT set up yet.  */
name|error
argument_list|(
literal|"parameter `%s' invalidly declared method type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter invalidly declared method type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter `%s' invalidly declared offset type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter invalidly declared offset type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
block|}
if|if
condition|(
name|decl
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
block|{
name|result
operator|=
name|void_list_node
expr_stmt|;
name|last_result
operator|=
name|result
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_result
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
name|last_result
operator|=
name|void_list_node
expr_stmt|;
block|}
name|saw_void
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
operator|(
name|chain
operator|!=
name|void_list_node
operator|||
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"`void' in parameter list must be entire list"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Since there is a prototype, args are passed in their own types.  */
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|any_error
condition|)
block|{
if|if
condition|(
name|init
condition|)
block|{
name|any_init
operator|++
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|PARM_DECL_EXPR
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|init
operator|=
name|require_instantiated_type
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|any_init
condition|)
block|{
name|error
argument_list|(
literal|"all trailing parameters must have default arguments"
argument_list|)
expr_stmt|;
name|any_error
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|decls
operator|==
name|NULL_TREE
condition|)
block|{
name|decls
operator|=
name|decl
expr_stmt|;
name|last_decl
operator|=
name|decls
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_decl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|last_decl
operator|=
name|decl
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|list_node
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|list_node
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|list_node
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|list_node
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|list_node
operator|=
name|saveable_tree_cons
argument_list|(
name|init
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
block|{
name|result
operator|=
name|list_node
expr_stmt|;
name|last_result
operator|=
name|result
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_result
argument_list|)
operator|=
name|list_node
expr_stmt|;
name|last_result
operator|=
name|list_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_result
condition|)
name|TREE_CHAIN
argument_list|(
name|last_result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If there are no parameters, and the function does not end 	     with `...', then last_decl will be NULL_TREE.  */
if|if
condition|(
name|last_decl
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|last_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
name|last_function_parms
operator|=
name|decls
expr_stmt|;
comment|/* In a fcn definition, arg types must be complete.  */
if|if
condition|(
name|funcdef_flag
operator|>
literal|0
condition|)
name|require_complete_types_for_parms
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These memoizing functions keep track of special properties which    a class may have.  `grok_ctor_properties' notices whether a class    has a constructor of the for X(X&), and also complains    if the class has a constructor of the form X(X).    `grok_op_properties' takes notice of the various forms of    operator= which are defined, as well as what sorts of type conversion    may apply.  Both functions take a FUNCTION_DECL as an argument.  */
end_comment

begin_function
specifier|static
name|void
name|grok_ctor_properties
parameter_list|(
name|ctype
parameter_list|,
name|decl
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|parmtypes
init|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parmtype
init|=
name|parmtypes
condition|?
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
else|:
name|void_type_node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
operator|==
name|ctype
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|void_list_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
condition|)
block|{
name|TYPE_HAS_INIT_REF
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_GETS_INIT_REF
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
name|TYPE_GETS_CONST_INIT_REF
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|TYPE_GETS_INIT_AGGR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|==
name|ctype
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|void_list_node
condition|)
name|error
argument_list|(
literal|"invalid constructor; you probably meant `%s (%s&)'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_class_name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_class_name
argument_list|)
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|TYPE_GETS_INIT_AGGR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|grok_op_properties
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|argtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|OPERATOR_NEW_FORMAT
argument_list|,
name|OPERATOR_NEW_LENGTH
argument_list|)
condition|)
block|{
comment|/* Take care of function decl if we had syntax errors.  */
if|if
condition|(
name|argtypes
operator|==
name|NULL_TREE
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|OPERATOR_DELETE_FORMAT
argument_list|,
name|OPERATOR_DELETE_LENGTH
argument_list|)
condition|)
block|{
if|if
condition|(
name|argtypes
operator|==
name|NULL_TREE
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|hash_tree_chain
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' cannot be a static member function"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|OPERATOR_MODIFY_FORMAT
argument_list|,
name|OPERATOR_MODIFY_LENGTH
argument_list|)
condition|)
block|{
name|tree
name|parmtypes
init|=
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
decl_stmt|;
name|tree
name|parmtype
init|=
name|parmtypes
condition|?
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
else|:
name|void_type_node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|current_class_type
condition|)
block|{
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_GETS_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
name|TYPE_GETS_CONST_INIT_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the struct, enum or union (CODE says which) with tag NAME.    Define the tag as a forward-reference if it is not defined.     C++: If a class derivation is given, process it here, and report    an error if multiple derivation declarations are not identical.     If we are compiling for SOS, then      if CODE_TYPE_NODE is a TREE_LIST, then we have a dynamic class      declaration.  The name associated with the class is the tree      purpose, and the real CODE is in the tree value slot.  */
end_comment

begin_function
name|tree
name|xref_tag
parameter_list|(
name|code_type_node
parameter_list|,
name|name
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|code_type_node
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|binfo
decl_stmt|;
block|{
name|enum
name|tag_types
name|tag_code
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|temp
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
operator|(
name|class_binding_level
condition|?
name|class_binding_level
else|:
name|current_binding_level
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SOS
name|tree
name|dynamic_name
init|=
name|error_mark_node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|code_type_node
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|dynamic_name
operator|=
name|TREE_PURPOSE
argument_list|(
name|code_type_node
argument_list|)
expr_stmt|;
name|code_type_node
operator|=
name|TREE_VALUE
argument_list|(
name|code_type_node
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tag_code
operator|=
operator|(
expr|enum
name|tag_types
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|code_type_node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag_code
condition|)
block|{
case|case
name|record_type
case|:
case|case
name|class_type
case|:
case|case
name|exception_type
case|:
name|code
operator|=
name|RECORD_TYPE
expr_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|binfo
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|union_type
case|:
name|code
operator|=
name|UNION_TYPE
expr_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
name|error
argument_list|(
literal|"derived union `%s' invalid"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|enum_type
case|:
name|code
operator|=
name|ENUMERAL_TYPE
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If a cross reference is requested, look up the type      already defined for this tag and return it.  */
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
block|{
comment|/* Try finding it as a type declaration.  If that wins, use it.  */
name|ref
operator|=
name|lookup_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|code
condition|)
name|ref
operator|=
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
else|else
name|ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ref
condition|)
block|{
comment|/* If no such tag is yet defined, create a forward-reference node 	 and record it as the "definition". 	 When a real declaration of this type is found, 	 the forward-reference will be altered into a real type.  */
comment|/* In C++, since these migrate into the global scope, we must 	 build them on the permanent obstack.  */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|allocation_temporary_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|ref
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
comment|/* Give the type a default layout like unsigned int 	     to avoid crashing if it does not get defined.  */
name|TYPE_MODE
argument_list|(
name|ref
argument_list|)
operator|=
name|SImode
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* Enable us to recognize when a type is created in class context. 	     To do nested classes correctly, this should probably be cleared 	     out when we leave this classes scope.  Currently this in only 	     done in `start_enum'.  */
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_enum
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag_code
operator|==
name|exception_type
condition|)
block|{
name|ref
operator|=
name|make_lang_type
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|CLASSTYPE_OFFSET
argument_list|(
name|ref
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* Enable us to recognize when an exception type is created in 	     class context.  To do nested classes correctly, this should 	     probably be cleared out when we leave this class's scope.  */
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_struct
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|extern
name|tree
name|pending_vtables
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|old_b
init|=
name|class_binding_level
decl_stmt|;
name|int
name|needs_writing
decl_stmt|;
name|ref
operator|=
name|make_lang_type
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|CLASSTYPE_BASECLASSES
argument_list|(
name|ref
argument_list|)
operator|=
operator|(
name|tree
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|ref
argument_list|)
operator|=
name|len
operator|-
literal|1
expr_stmt|;
name|CLASSTYPE_OFFSET
argument_list|(
name|ref
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|CLASSTYPE_VIAS
argument_list|(
name|ref
argument_list|)
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Record how to set the visibility of this class's 	     virtual functions.  If write_virtuals == 2 or 3, then 	     inline virtuals are ``extern inline''.  */
switch|switch
condition|(
name|write_virtuals
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|needs_writing
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|needs_writing
operator|=
operator|!
operator|!
name|value_member
argument_list|(
name|name
argument_list|,
name|pending_vtables
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|needs_writing
operator|=
operator|!
operator|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|ref
argument_list|)
operator|||
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|ref
argument_list|)
operator|)
expr_stmt|;
break|break;
default|default:
name|needs_writing
operator|=
literal|0
expr_stmt|;
block|}
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|ref
argument_list|)
operator|=
name|needs_writing
expr_stmt|;
comment|/* Class types don't nest the way enums do.  */
name|class_binding_level
operator|=
literal|0
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|old_b
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_struct
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (TREE_CODE (TYPE_NAME (ref)) == IDENTIFIER_NODE
ifndef|#
directive|ifndef
name|BREAK_C_TAGS
block|&& current_lang_name == lang_name_cplusplus
endif|#
directive|endif
block|&& ! CLASSTYPE_DECLARED_EXCEPTION (ref)) 	    {
comment|/* Silently typedef a tag which came from C.  */
block|register tree t = pushdecl (build_decl (TYPE_DECL, name, ref)); 	      TYPE_NAME (ref) = t; 	      TREE_TYPE (name) = t; 	    }
endif|#
directive|endif
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ref
argument_list|)
operator|&&
operator|(
operator|(
name|tag_code
operator|==
name|exception_type
operator|)
operator|!=
operator|(
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|ref
argument_list|)
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"type `%s' is both exception and aggregate type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|ref
argument_list|)
operator|=
operator|(
name|tag_code
operator|==
name|exception_type
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|binfo
condition|)
block|{
name|tree
name|tt1
init|=
name|binfo
decl_stmt|;
name|tree
modifier|*
name|tt2
init|=
name|CLASSTYPE_BASECLASSES
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|ref
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|tt1
condition|;
name|i
operator|++
operator|,
name|tt1
operator|=
name|TREE_CHAIN
argument_list|(
name|tt1
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tt1
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|tt2
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"redeclaration of derivation chain of type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tt1
operator|!=
name|NULL_TREE
condition|)
block|{
name|free
argument_list|(
name|CLASSTYPE_BASECLASSES
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|CLASSTYPE_VIAS
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_BASECLASSES
argument_list|(
name|ref
argument_list|)
operator|=
operator|(
name|tree
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|ref
argument_list|)
operator|=
name|len
operator|-
literal|1
expr_stmt|;
name|CLASSTYPE_OFFSET
argument_list|(
name|ref
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|CLASSTYPE_ASSOC
argument_list|(
name|ref
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_VIAS
argument_list|(
name|ref
argument_list|)
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The user told us something we already knew.  */
goto|goto
name|just_return
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|SOS
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
operator|(
name|dynamic_name
operator|!=
name|error_mark_node
operator|)
operator|!=
name|TYPE_DYNAMIC
argument_list|(
name|ref
argument_list|)
condition|)
name|error
argument_list|(
literal|"type `%s' declared both dynamic and non-dynamic"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|binfo
condition|)
block|{
name|CLASSTYPE_MARKED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|binfo
condition|;
name|binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
comment|/* The base of a derived struct is public.  */
name|int
name|via_public
init|=
operator|(
name|tag_code
operator|!=
name|class_type
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_public
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_public_virtual
operator|)
decl_stmt|;
name|int
name|via_virtual
init|=
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_private_virtual
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_public_virtual
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_default_virtual
operator|)
decl_stmt|;
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_hier
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|via_public
argument_list|,
name|via_virtual
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|basetype
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basetype
operator|||
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"base type `%s' fails to be a struct or class type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
if|else if (TYPE_SIZE (basetype) == 0) 	    { 	      error_with_aggr_type (basetype, "base class `%s' has incomplete type"); 	      continue; 	    }
endif|#
directive|endif
else|else
block|{
ifdef|#
directive|ifdef
name|SOS
if|if
condition|(
name|dynamic_name
operator|==
name|error_mark_node
operator|&&
name|TYPE_DYNAMIC
argument_list|(
name|basetype
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|ref
argument_list|,
literal|"non-dynamic type `%s' cannot derive from dynamic type `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|basetype
operator|==
name|ref
condition|)
name|error_with_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|"recursive type `%s' undefined"
argument_list|)
expr_stmt|;
else|else
name|error_with_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|"duplicate base type `%s' invalid"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|CLASSTYPE_BASECLASS
argument_list|(
name|ref
argument_list|,
name|i
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XYZZY TEST VIRTUAL BASECLASSES */
block|if (CLASSTYPE_N_BASECLASSES (basetype) == 0&& TYPE_HAS_DEFAULT_CONSTRUCTOR (basetype)&& via_virtual == 0)   {     warning ("making type `%s' a virtual baseclass", 	     TYPE_NAME_STRING (basetype));     via_virtual = 1;   }
endif|#
directive|endif
name|SET_CLASSTYPE_VIAS
argument_list|(
name|ref
argument_list|,
name|i
argument_list|,
name|via_public
argument_list|,
name|via_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
name|via_virtual
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
condition|)
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_WRAPPER_PRED
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_HAS_WRAPPER_PRED
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_GETS_NEW
argument_list|(
name|ref
argument_list|)
operator||=
name|TREE_GETS_NEW
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_GETS_DELETE
argument_list|(
name|ref
argument_list|)
operator||=
name|TREE_GETS_DELETE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|ref
argument_list|)
operator||=
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Set the true number of baseclasses this type really has.  */
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|ref
argument_list|)
operator|=
operator|--
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|CLASSTYPE_MARKED
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|ref
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
block|}
name|CLASSTYPE_MARKED
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|just_return
label|:
ifdef|#
directive|ifdef
name|SOS
if|if
condition|(
name|dynamic_name
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|allocation_temporary_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|dynamic_name
condition|)
name|CLASSTYPE_DYNAMIC_FILENAME
argument_list|(
name|ref
argument_list|)
operator|=
name|combine_strings
argument_list|(
name|dynamic_name
argument_list|)
expr_stmt|;
else|else
name|CLASSTYPE_DYNAMIC_FILENAME
argument_list|(
name|ref
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_DYNAMIC
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_TYPENAME_AS_STRING
argument_list|(
name|ref
argument_list|)
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Until the type is defined, tentatively accept whatever      structure tag the user hands us.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ref
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ref
operator|!=
name|current_class_type
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ref
argument_list|)
condition|)
block|{
if|if
condition|(
name|tag_code
operator|==
name|class_type
condition|)
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tag_code
operator|==
name|record_type
condition|)
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|temp
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin compiling the definition of an enumeration type.    NAME is its name (or null if anonymous).    Returns the type object, as yet incomplete.    Also records info about it so that build_enumerator    may be used to declare the individual values as they are read.  */
end_comment

begin_function
name|tree
name|start_enum
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|enumtype
init|=
literal|0
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
operator|(
name|class_binding_level
condition|?
name|class_binding_level
else|:
name|current_binding_level
operator|)
decl_stmt|;
comment|/* If this is the real definition for a previous forward reference,      fill in the contents in the same object that used to be the      forward reference.  */
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|enumtype
operator|=
name|lookup_tag
argument_list|(
name|ENUMERAL_TYPE
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|enumtype
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|enumtype
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|enumtype
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This enum is a named one that has been declared already.  */
name|error
argument_list|(
literal|"redeclaration of `enum %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Completely replace its old definition. 	 The old enumerators remain defined, however.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Initially, set up this enum as like `int'      so that we can create the enumerators' declarations and values.      Later on, the precision of the type may be changed and      it may be laid out again.  */
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|fixup_unsigned_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
comment|/* We copy this value because enumerated type constants      are really of the type of the enumerator, not integer_type_node.  */
name|enum_next_value
operator|=
name|copy_node
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* After processing and defining all the values of an enumeration type,    install their decls in the enumeration type and finish it off.    ENUMTYPE is the type object and VALUES a list of name-value pairs.    Returns ENUMTYPE.  */
end_comment

begin_function
name|tree
name|finish_enum
parameter_list|(
name|enumtype
parameter_list|,
name|values
parameter_list|)
specifier|register
name|tree
name|enumtype
decl_stmt|,
name|values
decl_stmt|;
block|{
specifier|register
name|tree
name|pair
decl_stmt|;
specifier|register
name|long
name|maxvalue
init|=
literal|0
decl_stmt|;
specifier|register
name|long
name|minvalue
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|values
expr_stmt|;
comment|/* Calculate the maximum value of any enumerator in this type.  */
if|if
condition|(
name|values
condition|)
block|{
comment|/* Speed up the main loop by performing some precalculations */
name|int
name|value
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|)
operator|=
name|enumtype
expr_stmt|;
name|minvalue
operator|=
name|maxvalue
operator|=
name|value
expr_stmt|;
for|for
control|(
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>
name|maxvalue
condition|)
name|maxvalue
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|<
name|minvalue
condition|)
name|minvalue
operator|=
name|value
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
argument_list|)
operator|=
name|enumtype
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_short_enums
condition|)
block|{
comment|/* Determine the precision this type needs, lay it out, and define it.  */
for|for
control|(
name|i
operator|=
name|maxvalue
init|;
name|i
condition|;
name|i
operator|>>=
literal|1
control|)
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
condition|)
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Cancel the laying out previously done for the enum type, 	 so that fixup_unsigned_type will do it over.  */
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|fixup_unsigned_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
argument_list|)
operator|=
name|maxvalue
expr_stmt|;
comment|/* An enum can have some negative values; then it is signed.  */
if|if
condition|(
name|minvalue
operator|<
literal|0
condition|)
block|{
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
argument_list|)
operator|=
name|minvalue
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_enum
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* Build and install a CONST_DECL for one value of the    current enumeration type (one that was begun with start_enum).    Return a tree-list containing the name and its value.    Assignment of sequential values by default is handled here.  */
end_comment

begin_function
name|tree
name|build_enumerator
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|tree
name|name
decl_stmt|,
name|value
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|result
decl_stmt|;
comment|/* Validate and default VALUE.  */
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
name|decl_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"enumerator value for `%s' not integer constant"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* The order of things is reversed here so that we      can check for possible sharing of enum values,      to keep that from happening.  */
comment|/* Default based on previous value.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|enum_next_value
expr_stmt|;
comment|/* Remove no-op casts from the value.  */
while|while
condition|(
name|value
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make up for hacks in cplus-lex.c.  */
if|if
condition|(
name|value
operator|==
name|integer_zero_node
condition|)
name|value
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
name|integer_one_node
condition|)
name|value
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|value
operator|=
name|copy_node
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
name|result
operator|=
name|saveable_tree_cons
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* C++ associates enums with global, function, or class declarations.  */
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Create a declaration for the enum value name.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Set basis for default for next value.  */
name|enum_next_value
operator|=
name|build_binary_op_nodefault
argument_list|(
name|PLUS_EXPR
argument_list|,
name|value
argument_list|,
name|integer_one_node
argument_list|,
name|PLUS_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_UID
argument_list|(
name|enum_next_value
argument_list|)
operator|<
name|TREE_UID
argument_list|(
name|result
argument_list|)
condition|)
name|enum_next_value
operator|=
name|copy_node
argument_list|(
name|enum_next_value
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|tree
name|grok_enum_decls
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|class_binding_level
decl_stmt|;
name|tree
name|tag
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|values
decl_stmt|;
while|while
condition|(
name|b
condition|)
block|{
name|tag
operator|=
name|value_member
argument_list|(
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
break|break;
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"class-local enum declaration `%s' is not in scope here"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|!=
name|class_binding_level
condition|)
block|{
name|warning
argument_list|(
literal|"class-local declaration for enumeral type `%s' found"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tag
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"(probably missing '}' before that enum declaration)"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|tag
argument_list|)
condition|)
return|return
name|decl
return|;
else|else
name|TREE_ADDRESSABLE
argument_list|(
name|tag
argument_list|)
operator|=
literal|1
expr_stmt|;
name|values
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|values
condition|)
block|{
comment|/* Create a declaration for the enum value name.  */
name|tree
name|next
init|=
name|build_lang_field_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|values
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_INITIAL
argument_list|(
name|next
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|next
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|values
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns 1 on success.  If the DECLARATOR is not suitable for a function    (it defines a datum instead), we return 0, which tells    yyparse to report a parse error.     For C++, we must first check whether that datum makes any sense.    For example, "class A local_a(1,2);" means that variable local    a is an aggregate of type A, which should have a constructor    applied to it with the argument list [1, 2].     @@ There is currently no way to retrieve the storage    @@ allocated to FUNCTION (or all of its parms) if we return    @@ something we had previously.  */
end_comment

begin_function
name|int
name|start_function
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|raises
parameter_list|,
name|pre_parsed_p
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|raises
decl_stmt|;
name|int
name|pre_parsed_p
decl_stmt|;
block|{
specifier|extern
name|int
name|interface_only
decl_stmt|,
name|interface_unknown
decl_stmt|;
specifier|extern
name|tree
name|EHS_decl
decl_stmt|;
name|tree
name|decl1
decl_stmt|,
name|olddecl
decl_stmt|;
name|tree
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|tree
name|restype
decl_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|&&
name|EHS_decl
operator|==
name|NULL_TREE
condition|)
name|init_exception_processing_1
argument_list|()
expr_stmt|;
comment|/* Sanity check.  */
name|assert
argument_list|(
name|TREE_VALUE
argument_list|(
name|void_list_node
argument_list|)
operator|==
name|void_type_node
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|void_list_node
argument_list|)
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Assume, until we see it does. */
name|current_function_returns_value
operator|=
literal|0
expr_stmt|;
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
name|warn_about_return_type
operator|=
literal|0
expr_stmt|;
name|current_extern_inline
operator|=
literal|0
expr_stmt|;
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
name|current_function_parms_stored
operator|=
literal|0
expr_stmt|;
name|original_result_rtx
operator|=
literal|0
expr_stmt|;
name|clear_temp_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|pre_parsed_p
condition|)
block|{
name|decl1
operator|=
name|declarator
expr_stmt|;
name|last_function_parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|last_function_parm_tags
operator|=
literal|0
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|DECL_VIRTUAL_P
argument_list|(
name|decl1
argument_list|)
operator|&&
name|write_virtuals
operator|>=
literal|2
operator|&&
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|ctype
argument_list|)
operator|)
condition|)
name|current_extern_inline
operator|=
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* In a fcn definition, arg types must be complete.  */
name|require_complete_types_for_parms
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl1
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FUNCDEF
argument_list|,
literal|1
argument_list|,
name|raises
argument_list|)
expr_stmt|;
comment|/* If the declarator is not suitable for a function definition, 	 cause a syntax error.  */
if|if
condition|(
name|decl1
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|decl1
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
literal|0
return|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|restype
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|restype
argument_list|)
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|restype
argument_list|,
literal|"semicolon missing after declaration of `%s'"
argument_list|)
expr_stmt|;
name|shadow_tag
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|restype
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|restype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|fntype
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|integer_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
literal|4
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
comment|/* If this doesn't return an integer type, complain.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
if|#
directive|if
literal|0
block|error ("return type for `main' must be integer type");
else|#
directive|else
name|warning
argument_list|(
literal|"return type for `main' changed to integer type"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
operator|=
name|default_function_type
expr_stmt|;
block|}
name|warn_about_return_type
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Warn if function was previously implicitly declared      (but not if we warned then).  */
if|if
condition|(
operator|!
name|warn_implicit
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|warning_with_decl
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
literal|"`%s' implicitly declared before its definition"
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
else|else
name|announce_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
literal|"return-type `%s' is an incomplete type"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"return-type is an incomplete type"
argument_list|)
expr_stmt|;
comment|/* Make it return void instead.  */
if|if
condition|(
name|ctype
condition|)
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|void_type_node
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_about_return_type
condition|)
name|warning
argument_list|(
literal|"return-type defaults to `int'"
argument_list|)
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is not tentative.      error_mark_node is replaced below (in poplevel) with the LET_STMT.  */
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_AUTO_OVERLOAD
comment|/* If this definition isn't a prototype and we had a prototype declaration      before, copy the arg type info from that prototype.  */
name|olddecl
operator|=
name|lookup_name_current_level
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddecl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Didn't get anything from C.  */
name|olddecl
operator|=
literal|0
expr_stmt|;
comment|/* This is a definition, not a reference.      So normally clear TREE_EXTERNAL.      However, `extern inline' acts like a declaration      except for defining how to inline.  So set TREE_EXTERNAL in that case.  */
name|TREE_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|current_extern_inline
expr_stmt|;
comment|/* This function exists in static storage.      (This does not mean `static' in the C sense!)  */
name|TREE_STATIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this inline function belongs to the implementation, make it public.  */
if|if
condition|(
name|TREE_INLINE
argument_list|(
name|decl1
argument_list|)
operator|&&
name|interface_unknown
operator|==
literal|0
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|=
operator|!
name|interface_only
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|interface_only
expr_stmt|;
block|}
comment|/* Now see if this is the implementation of a function      declared with "C" linkage.  */
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
block|{
name|olddecl
operator|=
name|lookup_name_current_level
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddecl
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|olddecl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|olddecl
operator|&&
name|DECL_ORIGINAL_NAME
argument_list|(
name|decl1
argument_list|)
operator|!=
name|DECL_ORIGINAL_NAME
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* Collision between user and internal naming scheme.  */
name|olddecl
operator|=
name|lookup_name_current_level
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddecl
operator|==
name|NULL_TREE
condition|)
name|olddecl
operator|=
name|decl1
expr_stmt|;
block|}
if|if
condition|(
name|olddecl
operator|&&
name|olddecl
operator|!=
name|decl1
operator|&&
name|DECL_ORIGINAL_NAME
argument_list|(
name|decl1
argument_list|)
operator|==
name|DECL_ORIGINAL_NAME
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|decls_match
argument_list|(
name|decl1
argument_list|,
name|olddecl
argument_list|)
operator|||
name|comp_target_parms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|olddecl
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_PRINT_NAME
argument_list|(
name|decl1
argument_list|)
operator|=
name|DECL_PRINT_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_OVERLOADED
argument_list|(
name|decl1
argument_list|)
operator|=
name|DECL_OVERLOADED
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
name|redeclaration_error_message
argument_list|(
name|decl1
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate_decls
argument_list|(
name|decl1
argument_list|,
name|olddecl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|decl1
operator|=
name|olddecl
expr_stmt|;
block|}
else|else
name|olddecl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Record the decl so that the function name is defined.      If we already have a decl for this name, and it is a FUNCTION_DECL,      use the old decl.  */
if|if
condition|(
name|olddecl
condition|)
name|current_function_decl
operator|=
name|olddecl
expr_stmt|;
elseif|else
if|if
condition|(
name|pre_parsed_p
operator|==
literal|0
condition|)
block|{
name|current_function_decl
operator|=
name|pushdecl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* @@ revert to modified original declaration.  */
name|decl1
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
block|}
else|else
block|{
name|decl1
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MAIN_VARIANT
argument_list|(
name|decl1
argument_list|)
operator|=
name|decl1
expr_stmt|;
block|}
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
else|else
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
if|if
condition|(
name|DECL_OVERLOADED
argument_list|(
name|decl1
argument_list|)
condition|)
name|push_overloaded_decl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
literal|0
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
operator|=
name|last_function_parms
expr_stmt|;
name|ctype
operator|=
literal|0
expr_stmt|;
block|}
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
comment|/* Save the parm names or decls from this function's declarator      where store_parm_decls will find them.  */
name|current_function_parms
operator|=
name|last_function_parms
expr_stmt|;
name|current_function_parm_tags
operator|=
name|last_function_parm_tags
expr_stmt|;
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_function
argument_list|(
name|decl1
argument_list|,
name|current_function_parms
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|make_function_rtl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
name|pushclass
argument_list|(
name|ctype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We know that this was set up by `grokclassfn'. 	 We do not wait until `store_parm_decls', since evil 	 parse errors may never get us to that point.  Here 	 we keep the consistency between `current_class_type' 	 and `current_class_decl'.  */
name|current_class_decl
operator|=
name|last_function_parms
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|current_class_decl
argument_list|)
operator|==
name|PARM_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|variant
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_INST_VAR
argument_list|(
name|ctype
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Can't call build_indirect_ref here, because it has special 		 logic to return C_C_D given this argument.  */
name|C_C_D
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|current_class_type
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
name|CLASSTYPE_INST_VAR
argument_list|(
name|ctype
argument_list|)
operator|=
name|C_C_D
expr_stmt|;
block|}
else|else
block|{
name|C_C_D
operator|=
name|CLASSTYPE_INST_VAR
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
comment|/* `current_class_decl' is different for every 		 function we compile.  */
name|TREE_OPERAND
argument_list|(
name|C_C_D
argument_list|,
literal|0
argument_list|)
operator|=
name|current_class_decl
expr_stmt|;
block|}
name|TREE_READONLY
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|variant
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TREE_VOLATILE
argument_list|(
name|variant
argument_list|)
expr_stmt|;
block|}
else|else
name|C_C_D
operator|=
name|current_class_decl
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|pushclass
argument_list|(
name|DECL_STATIC_CONTEXT
argument_list|(
name|decl1
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|push_memoized_context
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Promote the value to int before returning it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|restype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|restype
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|restype
operator|=
name|integer_type_node
expr_stmt|;
name|DECL_RESULT_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|restype
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
name|value_identifier
argument_list|,
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
block|{
name|dtor_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ctor_label
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|dtor_label
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|ctor_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Initializations from `emit_base_init' might go inline. 	     Protect the binding level of the parms.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Allocate further tree nodes temporarily during compilation      of this function only.  */
name|temporary_allocation
argument_list|()
expr_stmt|;
comment|/* If this fcn was already referenced via a block-scope `extern' decl      (or an implicit decl), propagate certain information about the usage.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store the parameter declarations into the current function declaration.    This is called after parsing the parameter declarations, before    digesting the body of the function.     Also install to binding contour return value identifier, if any.  */
end_comment

begin_function
name|void
name|store_parm_decls
parameter_list|()
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
specifier|register
name|tree
name|parm
decl_stmt|;
name|int
name|parms_have_cleanups
init|=
literal|0
decl_stmt|;
name|tree
name|eh_decl
decl_stmt|;
comment|/* This is either a chain of PARM_DECLs (when a prototype is used).  */
name|tree
name|specparms
init|=
name|current_function_parms
decl_stmt|;
comment|/* This is a list of types declared among parms in a prototype.  */
name|tree
name|parmtags
init|=
name|current_function_parm_tags
decl_stmt|;
comment|/* This is a chain of any other decls that came in among the parm      declarations.  If a parm is declared with  enum {foo, bar} x;      then CONST_DECLs for foo and bar are put here.  */
name|tree
name|nonparms
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|fatal
argument_list|(
literal|"parse errors have confused me too much"
argument_list|)
expr_stmt|;
comment|/* Initialize RTL machinery.  */
name|init_function_start
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Create a binding level for the parms.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Prepare to catch raises, if appropriate.  */
if|if
condition|(
name|flag_handle_exceptions
condition|)
block|{
comment|/* Get this cleanup to be run last, since it 	 is a call to `longjmp'.  */
name|setup_exception_throw_decl
argument_list|()
expr_stmt|;
name|eh_decl
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
name|current_binding_level
operator|->
name|names
operator|=
name|TREE_CHAIN
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_handle_exceptions
condition|)
name|expand_start_try
argument_list|(
name|integer_one_node
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|specparms
operator|!=
literal|0
condition|)
block|{
comment|/* This case is when the function was defined with an ANSI prototype. 	 The parms already have decls, so we need not do anything here 	 except record them as in effect 	 and complain if any redundant old-style parm decls were written.  */
specifier|register
name|tree
name|next
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|nreverse
argument_list|(
name|specparms
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|next
control|)
block|{
name|tree
name|cleanup
init|=
name|maybe_build_cleanup
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|error_with_decl (parm, "parameter name omitted");
else|#
directive|else
comment|/* for C++, this is not an error.  */
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|==
name|void_type_node
condition|)
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"parameter `%s' declared void"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Now fill in DECL_REFERENCE_SLOT for any of the parm decls. 		 A parameter is assumed not to have any side effects. 		 If this should change for any reason, then this 		 will have to wrap the bashed reference type in a save_expr. 		  		 Also, if the parameter type is declared to be an X 		 and there is an X(X&) constructor, we cannot lay it 		 into the stack (any more), so we make this parameter 		 look like it is really of reference type.  Functions 		 which pass parameters to this function will know to 		 create a temporary in their frame, and pass a reference 		 to that.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|parm
argument_list|,
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanup
condition|)
block|{
name|expand_decl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|parm
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|parms_have_cleanups
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Get the decls in their original chain order 	 and record in the function.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|getdecls
argument_list|()
expr_stmt|;
name|storetags
argument_list|(
name|chainon
argument_list|(
name|parmtags
argument_list|,
name|gettags
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now store the final chain of decls for the arguments      as the decl-chain of the current lexical scope.      Put the enumerators in as well, at the front so that      DECL_ARGUMENTS is not modified.  */
name|storedecls
argument_list|(
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the RTL code for the function.  */
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|expand_function_start
argument_list|(
name|fndecl
argument_list|,
name|parms_have_cleanups
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
condition|)
block|{
comment|/* Make the throw decl visibile at this level, just 	 not in the way of the parameters.  */
name|pushdecl
argument_list|(
name|eh_decl
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|eh_decl
argument_list|)
expr_stmt|;
block|}
comment|/* Create a binding contour which can be used to catch      cleanup-generated temporaries.  Also, if the return value needs or      has initialization, deal with that now.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_function_parms_stored
operator|=
literal|1
expr_stmt|;
comment|/* If this function is `main', emit a call to `__main'      to run global initializers, etc.  */
if|if
condition|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|4
operator|&&
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
condition|)
name|expand_expr
argument_list|(
name|build_function_call
argument_list|(
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"__main"
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bind a name and initialization to the return value of    the current function.  */
end_comment

begin_function
name|void
name|store_return_init
parameter_list|(
name|init
parameter_list|)
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
comment|/* Can't let this happen for constructors.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"can't redefine default return value for constructors"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have a named return value, put that in our scope as well.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|value_identifier
condition|)
block|{
comment|/* If this named return value comes in a register, 	 put it in a pseudo-register.  */
if|if
condition|(
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|original_result_rtx
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
expr|struct
name|rtx_def
operator|*
operator|)
name|gen_reg_rtx
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Let `finish_decl' know that this initializer is ok.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code for default X(X&) constructor.  */
end_comment

begin_function
specifier|static
name|void
name|build_default_constructor
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|int
name|i
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parm
operator|=
name|DECL_REFERENCE_SLOT
argument_list|(
name|parm
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|tree
name|basetype
init|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|current_class_type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_GETS_INIT_REF
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|parm
argument_list|,
name|current_base_init_list
argument_list|)
expr_stmt|;
block|}
name|i
operator|-=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|name
decl_stmt|,
name|init
decl_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|fields
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
condition|)
block|{
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* True for duplicate members.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|!=
name|fields
condition|)
continue|continue;
block|}
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|parm
argument_list|,
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ANON_UNION_ELEM
argument_list|(
name|fields
argument_list|)
condition|)
name|name
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|C_C_D
argument_list|,
name|fields
argument_list|)
expr_stmt|;
else|else
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
name|current_member_init_list
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|init
argument_list|,
name|current_member_init_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up a function declaration and compile that function    all the way to assembler language output.  The free the storage    for the function definition.     This is called after parsing the body of the function definition.    LINENO is the current line number.     C++: CALL_POPLEVEL is non-zero if an extra call to poplevel    (and expand_end_bindings) must be made to take care of the binding    contour for the base initialazers.  This is only relevant for    constructors.  */
end_comment

begin_function
name|void
name|finish_function
parameter_list|(
name|lineno
parameter_list|,
name|call_poplevel
parameter_list|)
name|int
name|lineno
decl_stmt|;
name|int
name|call_poplevel
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|,
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|rtx_def
modifier|*
name|head
decl_stmt|,
modifier|*
name|last_parm_insn
decl_stmt|,
modifier|*
name|mark
decl_stmt|;
specifier|extern
name|struct
name|rtx_def
modifier|*
name|get_last_insn
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|rtx_def
modifier|*
name|cleanup_label
decl_stmt|,
modifier|*
name|return_label
decl_stmt|;
specifier|extern
name|int
name|sets_exception_throw_decl
decl_stmt|;
comment|/*  TREE_READONLY (fndecl) = 1;     This caused&foo to be of type ptr-to-const-function     which then got a warning when stored in a ptr-to-function variable.  */
comment|/* This happens on strange parse errors.  */
if|if
condition|(
operator|!
name|current_function_parms_stored
condition|)
block|{
name|call_poplevel
operator|=
literal|0
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
block|}
comment|/* Clean house because we will need to reorder insns here.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|dtor_label
condition|)
block|{
name|tree
name|cond
init|=
name|integer_one_node
decl_stmt|;
name|tree
name|exprstmt
decl_stmt|,
name|vfields
decl_stmt|;
name|tree
name|in_charge_node
init|=
name|lookup_name
argument_list|(
name|in_charge_identifier
argument_list|)
decl_stmt|;
name|int
name|ok_to_optimize_dtor
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|current_function_assigns_this
condition|)
name|cond
operator|=
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|current_class_decl
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
comment|/* If this destructor is empty, then we don't need to check 	     whether `this' is NULL in some cases.  */
name|mark
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|last_parm_insn
operator|=
operator|(
expr|struct
name|rtx_def
operator|*
operator|)
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flag_this_is_variable
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|ok_to_optimize_dtor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|mark
operator|==
name|last_parm_insn
condition|)
name|ok_to_optimize_dtor
operator|=
operator|(
name|n_baseclasses
operator|==
literal|0
operator|||
operator|(
name|n_baseclasses
operator|==
literal|1
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|current_class_type
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* These initializations might go inline.  Protect 	 the binding level of the parms.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_assigns_this
condition|)
block|{
name|TYPE_ANY_ASSIGNS_THIS
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Generate the code to call destructor on base class. 	 If this destructor belongs to a class with virtual 	 functions, then set the virtual function table 	 pointer to represent the type of our base class.  */
comment|/* This side-effect makes call to `build_delete' generate the 	 code we have to have at the end of this destructor.  */
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* These are two cases where we cannot delegate deletion.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
operator|||
name|TREE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|exprstmt
operator|=
name|build_delete
argument_list|(
name|current_class_type
argument_list|,
name|C_C_D
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|exprstmt
operator|=
name|build_delete
argument_list|(
name|current_class_type
argument_list|,
name|C_C_D
argument_list|,
name|in_charge_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we did not assign to this, then `this' is non-zero at 	 the end of a destructor.  As a special optimization, don't 	 emit test if this is an empty destructor.  If it does nothing, 	 it does nothing.  If it calls a base destructor, the base 	 destructor will perform the test.  */
if|if
condition|(
name|exprstmt
operator|!=
name|error_mark_node
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|exprstmt
argument_list|)
operator|!=
name|NOP_EXPR
operator|||
name|TREE_OPERAND
argument_list|(
name|exprstmt
argument_list|,
literal|0
argument_list|)
operator|!=
name|integer_zero_node
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
operator|)
condition|)
block|{
name|expand_label
argument_list|(
name|dtor_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|integer_one_node
condition|)
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|exprstmt
argument_list|)
expr_stmt|;
comment|/* Run destructor on all virtual baseclasses.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|vbases
init|=
name|nreverse
argument_list|(
name|copy_list
argument_list|(
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|expand_start_cond
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|in_charge_node
argument_list|,
name|integer_two_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_VALUE
argument_list|(
name|vbases
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|ptr
init|=
name|convert_pointer_to_vbase
argument_list|(
name|TREE_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|current_class_decl
argument_list|)
decl_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_delete
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|TREE_VALUE
argument_list|(
name|vbases
argument_list|)
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
operator||
name|LOOKUP_HAS_IN_CHARGE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|integer_one_node
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* At the end, call delete if that's what's requested.  */
if|if
condition|(
name|TREE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|exprstmt
operator|=
name|build_method_call
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
name|OPERATOR_DELETE_FORMAT
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|exprstmt
operator|=
name|build_x_delete
argument_list|(
name|ptr_type_node
argument_list|,
name|current_class_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|exprstmt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exprstmt
condition|)
block|{
name|cond
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|in_charge_node
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|exprstmt
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
comment|/* End of destructor.  */
name|poplevel
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Back to the top of destructor.  */
comment|/* Dont execute destructor code if `this' is NULL.  */
name|mark
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|last_parm_insn
operator|=
operator|(
expr|struct
name|rtx_def
operator|*
operator|)
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_parm_insn
operator|==
literal|0
condition|)
name|last_parm_insn
operator|=
name|mark
expr_stmt|;
else|else
name|last_parm_insn
operator|=
operator|(
expr|struct
name|rtx_def
operator|*
operator|)
name|previous_insn
argument_list|(
name|last_parm_insn
argument_list|)
expr_stmt|;
comment|/* Make all virtual function table pointers point to CURRENT_CLASS_TYPE's 	 virtual function tables.  */
if|if
condition|(
name|CLASSTYPE_VFIELDS
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
for|for
control|(
name|vfields
operator|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|current_class_type
argument_list|)
init|;
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
name|expand_expr_stmt
argument_list|(
name|build_virtual_init
argument_list|(
name|current_class_type
argument_list|,
name|TREE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|,
name|current_class_decl
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_virtual_init
argument_list|(
name|current_class_type
argument_list|,
name|current_class_type
argument_list|,
name|current_class_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|expand_expr_stmt
argument_list|(
name|build_vbase_vtables_init
argument_list|(
name|current_class_type
argument_list|,
name|current_class_type
argument_list|,
name|C_C_D
argument_list|,
name|current_class_decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sparc
name|expand_asm_operands
argument_list|(
name|build_string
argument_list|(
literal|32
argument_list|,
literal|"! end of vtable initialization"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ok_to_optimize_dtor
condition|)
block|{
name|cond
operator|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|current_class_decl
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mark
operator|!=
name|get_last_insn
argument_list|()
condition|)
name|reorder_insns
argument_list|(
name|next_insn
argument_list|(
name|mark
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|last_parm_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok_to_optimize_dtor
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_assigns_this
condition|)
block|{
comment|/* Does not need to call emit_base_init, because 	 that is done (if needed) just after assignment to this 	 is seen.  */
name|TYPE_ANY_ASSIGNS_THIS
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* Undo call to pushlevel from `start_function'.  */
name|poplevel
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_label
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
name|ctor_label
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|call_poplevel
condition|)
block|{
name|tree
name|decls
init|=
name|getdecls
argument_list|()
decl_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
condition|)
name|deactivate_exception_cleanups
argument_list|()
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|decls
argument_list|,
name|decls
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
name|decls
operator|!=
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|c_expand_return
argument_list|(
name|current_class_decl
argument_list|)
expr_stmt|;
block|}
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
name|base_init_insns
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|allocated_this
decl_stmt|;
name|tree
name|cond
decl_stmt|,
name|thenclause
decl_stmt|;
comment|/* Allow constructor for a type to get a new instance of the object 	 using `build_new'.  */
name|tree
name|abstract_virtuals
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_RETURNS_FIRST_ARG
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_this_is_variable
condition|)
block|{
name|cond
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|current_class_decl
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|thenclause
operator|=
name|build_modify_expr
argument_list|(
name|current_class_decl
argument_list|,
name|NOP_EXPR
argument_list|,
name|build_new
argument_list|(
name|NULL_TREE
argument_list|,
name|current_class_type
argument_list|,
name|void_type_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
condition|)
block|{
name|tree
name|cleanup
decl_stmt|,
name|cleanup_deallocate
decl_stmt|;
name|allocated_this
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TREE_REGDECL
argument_list|(
name|allocated_this
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|allocated_this
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|expand_decl
argument_list|(
name|allocated_this
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|allocated_this
argument_list|)
expr_stmt|;
comment|/* How we cleanup `this' if an exception was raised before 		 we are ready to bail out.  */
name|cleanup
operator|=
name|TREE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
condition|?
name|build_opfncall
argument_list|(
name|DELETE_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|allocated_this
argument_list|)
else|:
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|allocated_this
argument_list|)
argument_list|,
name|allocated_this
argument_list|,
name|integer_three_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_HAS_IN_CHARGE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cleanup_deallocate
operator|=
name|build_modify_expr
argument_list|(
name|current_class_decl
argument_list|,
name|NOP_EXPR
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup_deallocate
argument_list|)
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|allocated_this
argument_list|,
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|allocated_this
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|build_compound_expr
argument_list|(
name|cleanup
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_GETS_NEW
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* Just check visibility here.  */
name|build_method_call
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
name|OPERATOR_NEW_FORMAT
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|abstract_virtuals
expr_stmt|;
comment|/* must keep the first insn safe.  */
name|head
operator|=
operator|(
expr|struct
name|rtx_def
operator|*
operator|)
name|get_insns
argument_list|()
expr_stmt|;
comment|/* this note will come up to the top with us.  */
name|mark
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_this_is_variable
condition|)
block|{
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|thenclause
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
condition|)
name|expand_assignment
argument_list|(
name|allocated_this
argument_list|,
name|current_class_decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|DECL_COMPILER_GENERATED_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|build_default_constructor
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Emit insns from `emit_base_init' which sets up virtual 	 function table pointer(s).  */
name|emit_insns
argument_list|(
name|base_init_insns
argument_list|)
expr_stmt|;
name|base_init_insns
operator|=
literal|0
expr_stmt|;
comment|/* This is where the body of the constructor begins. 	 If there were no insns in this function body, then the 	 last_parm_insn is also the last insn.  	 If optimization is enabled, last_parm_insn may move, so 	 we don't hold on to it (across emit_base_init).  */
name|last_parm_insn
operator|=
operator|(
expr|struct
name|rtx_def
operator|*
operator|)
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_parm_insn
operator|==
literal|0
condition|)
name|last_parm_insn
operator|=
name|mark
expr_stmt|;
else|else
name|last_parm_insn
operator|=
operator|(
expr|struct
name|rtx_def
operator|*
operator|)
name|previous_insn
argument_list|(
name|last_parm_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark
operator|!=
name|get_last_insn
argument_list|()
condition|)
name|reorder_insns
argument_list|(
name|next_insn
argument_list|(
name|mark
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|last_parm_insn
argument_list|)
expr_stmt|;
comment|/* This is where the body of the constructor ends.  */
name|expand_label
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
name|ctor_label
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
condition|)
block|{
name|expand_assignment
argument_list|(
name|allocated_this
argument_list|,
name|integer_zero_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deactivate_exception_cleanups
argument_list|()
expr_stmt|;
block|}
name|pop_implicit_try_blocks
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Undo call to pushlevel from `start_function'.  */
name|poplevel
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_poplevel
condition|)
block|{
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|any_pending_cleanups
argument_list|()
condition|)
comment|/* Do things the hard way.  */
name|c_expand_return
argument_list|(
name|current_class_decl
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Just store CURRENT_CLASS_DECL in the 	     DECL_RESULT of our current function decl 	     and fall through to end.  */
name|struct
name|rtx_def
modifier|*
name|val
init|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|store_expr
argument_list|(
name|current_class_decl
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|use_variable
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|4
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
comment|/* Make it so that `main' always returns 0 by default.  */
ifdef|#
directive|ifdef
name|VMS
name|c_expand_return
argument_list|(
name|integer_one_node
argument_list|)
expr_stmt|;
else|#
directive|else
name|c_expand_return
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* That's the end of the vtable decl's life.  Need to mark it such      if doing stupid register allocation.       Note that current_vtable_decl is really an INDIRECT_REF      on top of a VAR_DECL here.  */
if|if
condition|(
name|obey_regdecls
operator|&&
name|current_vtable_decl
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|current_vtable_decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove the binding contour which is used      to catch cleanup-generated temporaries.  */
name|expand_end_bindings
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Must mark the RESULT_DECL as being in this function.  */
name|DECL_CONTEXT
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Obey `register' declarations if `setjmp' is called in this fn.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|current_function_calls_setjmp
condition|)
name|setjmp_protect
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate rtl for function exit.  */
name|head
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|expand_function_end
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_label
condition|)
block|{
name|mark
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Emit label at beginning of cleanup code for parmeters.  */
name|emit_label
argument_list|(
name|cleanup_label
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/* Cheap hack to get better code from GNU C++.  Remove when cse is fixed.  */
if|if
condition|(
name|exception_throw_decl
operator|&&
name|sets_exception_throw_decl
operator|==
literal|0
condition|)
name|expand_assignment
argument_list|(
name|exception_throw_decl
argument_list|,
name|integer_zero_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_handle_exceptions
condition|)
block|{
name|expand_end_try
argument_list|()
expr_stmt|;
name|expand_start_except
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_end_except
argument_list|()
expr_stmt|;
block|}
name|expand_end_bindings
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get return value into reigster if that's where it's supposed to be.  */
if|if
condition|(
name|original_result_rtx
condition|)
name|fixup_result_decl
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|original_result_rtx
argument_list|)
expr_stmt|;
comment|/* reset scope for C++: if we were in the scope of a class,      then when we finish this function, we are not longer so.      This cannot be done until we know for sure that no more      class members will ever be referenced in this function      (i.e., calls to destructors).  */
if|if
condition|(
name|current_class_name
condition|)
block|{
name|ctype
operator|=
name|current_class_type
expr_stmt|;
name|popclass
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|pop_memoized_context
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Forget about all overloaded functions defined in      this scope which go away.  */
while|while
condition|(
name|overloads_to_forget
condition|)
block|{
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|overloads_to_forget
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|overloads_to_forget
argument_list|)
expr_stmt|;
name|overloads_to_forget
operator|=
name|TREE_CHAIN
argument_list|(
name|overloads_to_forget
argument_list|)
expr_stmt|;
block|}
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_label
condition|)
block|{
comment|/* To keep us from getting the compiler confused about 	 what constitutes control dropping off the end, 	 send control to RETURN_LABEL.  All this really 	 avoids is the NOTE_INSN_FUNCTION_END note.  */
if|if
condition|(
name|return_label
condition|)
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|return_label
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_return
else|else
name|emit_jump_insn
argument_list|(
name|gen_return
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_barrier
argument_list|()
expr_stmt|;
name|reorder_insns
argument_list|(
name|next_insn
argument_list|(
name|mark
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
comment|/* So we can tell if jump_optimize sets it to 1.  */
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|fndecl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|fndecl
argument_list|)
comment|/* This function is just along for the ride.  If we can make 	 it inline, that's great.  Otherwise, just punt it.  */
operator|&&
operator|(
name|TREE_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|==
literal|0
operator|||
name|function_cannot_inline_p
argument_list|(
name|fndecl
argument_list|)
operator|)
condition|)
block|{
specifier|extern
name|int
name|rtl_dump_and_exit
decl_stmt|;
name|int
name|old_rtl_dump_and_exit
init|=
name|rtl_dump_and_exit
decl_stmt|;
comment|/* This throws away the code for FNDECL.  */
name|rtl_dump_and_exit
operator|=
literal|1
expr_stmt|;
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|rtl_dump_and_exit
operator|=
name|old_rtl_dump_and_exit
expr_stmt|;
block|}
else|else
comment|/* Run the optimizers and output the assembler code for this function.  */
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|fndecl
argument_list|)
condition|)
name|CLASSTYPE_ASM_WRITTEN
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Since we don't normally go through c_expand_return for constructors,      this normally gets the wrong value.      Also, named return values have their return codes emitted after      NOTE_INSN_FUNCTION_END, confusing jump.c.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|value_identifier
condition|)
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
literal|"`volatile' function does return"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_return_type
operator|&&
name|current_function_returns_null
operator|&&
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
operator|!=
name|void_type_node
condition|)
comment|/* If this function returns non-void and control can drop through,        complain.  */
name|warning
argument_list|(
literal|"control reaches end of non-void function"
argument_list|)
expr_stmt|;
comment|/* With just -W, complain only if function returns both with      and without a value.  */
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
name|current_function_returns_value
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
literal|"this function may return with or without a value"
argument_list|)
expr_stmt|;
comment|/* Free all the tree nodes making up this function.  */
comment|/* Switch back to allocating nodes permanently      until we start another function.  */
name|permanent_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_function
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Stop pointing to the local nodes about to be freed.  */
comment|/* But DECL_INITIAL must remain nonzero so we know this 	 was an actual function definition.  */
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|||
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Let the error reporting routines know that we're outside a function.  */
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|named_label_uses
operator|=
name|NULL_TREE
expr_stmt|;
name|clear_anon_parm_name
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    LINE1 is the line number that the definition absolutely begins on.    LINE2 is the line number that the name of the function appears on.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns a FUNCTION_DECL on success.     If the DECLARATOR is not suitable for a function (it defines a datum    instead), we return 0, which tells yyparse to report a parse error.     May return void_type_node indicating that this method is actually    a friend.  See grokfield for more details.     Came here with a `.pushlevel' .     DO NOT MAKE ANY CHANGES TO THIS CODE WITHOUT MAKING CORRESPONDING    CHANGES TO CODE IN `grokfield'.  */
end_comment

begin_function
name|tree
name|start_method
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|raises
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|raises
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|MEMFUNCDEF
argument_list|,
literal|0
argument_list|,
name|raises
argument_list|)
decl_stmt|;
comment|/* Something too ugly to handle.  */
if|if
condition|(
name|fndecl
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Pass friends other than inline friend functions back.  */
if|if
condition|(
name|fndecl
operator|==
name|void_type_node
condition|)
return|return
name|void_type_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* Not a function, tell parser to report parse error.  */
return|return
literal|0
return|;
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"`%s' is already defined in aggregate scope"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|flag_default_inline
condition|)
name|TREE_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We read in the parameters on the maybepermanent_obstack,      but we won't be getting back to them until after we      may have clobbered them.  So the call to preserve_data      will keep them safe.  */
name|preserve_data
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_FRIEND_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
comment|/* Need a fresh node here so that we don't get circularity 	   when we link these together.  If FNDECL was a friend, then 	   `pushdecl' does the right thing, which is nothing wrt its 	   current value of TREE_CHAIN.  */
name|fndecl
operator|=
name|copy_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|grok_ctor_properties
argument_list|(
name|current_class_type
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|OPERATOR_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_OPERATOR
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|grok_op_properties
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_decl
argument_list|(
name|fndecl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make a place for the parms */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_function

begin_comment
comment|/* Go through the motions of finishing a function definition.    We don't compile this method until after the whole class has    been processed.     FINISH_METHOD must return something that looks as though it    came from GROKFIELD (since we are defining a method, after all).     This is called after parsing the body of the function definition.    STMTS is the chain of statements that makes up the function body.     DECL is the ..._DECL that `start_method' provided.  */
end_comment

begin_function
name|tree
name|finish_method
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|decl
decl_stmt|;
name|tree
name|old_initial
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|void_type_node
condition|)
return|return
name|decl
return|;
name|old_initial
operator|=
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Undo the level for the parms (from start_method).      This is like poplevel, but it causes nothing to be      saved.  Saving information here confuses symbol-table      output routines.  Besides, this information will      be correctly output when this method is actually      compiled.  */
comment|/* Clear out the meanings of the local variables of this level;      also record in each decl which block it belongs to.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|link
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Restore all name-meanings of the outer levels      that were shadowed by this level.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|class_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_end_scope
argument_list|(
name|current_binding_level
argument_list|,
name|current_binding_level
operator|->
name|level_chain
argument_list|,
name|current_binding_level
operator|->
name|parm_flag
argument_list|,
name|current_binding_level
operator|->
name|keep
argument_list|,
name|current_binding_level
operator|->
name|tag_transparent
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|POP_BINDING_LEVEL
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|old_initial
expr_stmt|;
if|if
condition|(
name|DECL_FRIEND_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when a new struct TYPE is defined.    If this structure or union completes the type of any previous    variable declaration, lay it out and output its rtl.  */
end_comment

begin_function
name|void
name|hack_incomplete_structures
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|n_incomplete
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|decl
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|type
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|type
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|toplevel
init|=
name|global_binding_level
operator|==
name|current_binding_level
decl_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
name|toplevel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel
condition|)
block|{
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
operator|--
name|current_binding_level
operator|->
name|n_incomplete
expr_stmt|;
name|assert
argument_list|(
name|current_binding_level
operator|->
name|n_incomplete
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if presently building a cleanup.  Needed because    SAVE_EXPRs are not the right things to use inside of cleanups.    They are only ever evaluated once, where the cleanup    might be evaluated several times.  In this case, a later evaluation    of the cleanup might fill in the SAVE_EXPR_RTL, and it will    not be valid for an earlier cleanup.  */
end_comment

begin_decl_stmt
name|int
name|building_cleanup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If DECL is of a type which needs a cleanup, build that cleanup here.    We don't build cleanups if just going for syntax checking, since    fixup_cleanups does not know how to not handle them.     Don't build these on the momentary obstack; they must live    the life of the binding contour.  */
end_comment

begin_function
name|tree
name|maybe_build_cleanup
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|temp
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|int
name|old_building_cleanup
init|=
name|building_cleanup
decl_stmt|;
name|building_cleanup
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|temp
operator|=
name|allocation_temporary_p
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|rval
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|rval
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_vbase_delete
argument_list|(
name|type
argument_list|,
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|have_cleanups
operator|=
literal|1
expr_stmt|;
name|current_binding_level
operator|->
name|more_exceptions_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|temp
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
else|else
name|resume_momentary
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|building_cleanup
operator|=
name|old_building_cleanup
expr_stmt|;
return|return
name|rval
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|tree
name|cleanup_after_call
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|get_temp_name
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rval
init|=
name|build
argument_list|(
name|WITH_CLEANUP_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|type
argument_list|,
name|decl
argument_list|,
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a C++ expression at the statement level.    This is needed to ferret out nodes which have UNKNOWN_TYPE.    The C++ type checker should get all of these out when    expressions are combined with other, type-providing, expressions,    leaving only orphan expressions, such as:&class::bar;		/ / takes its address, but do nothing with it.     */
end_comment

begin_function
name|void
name|cplus_expand_expr_stmt
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|unknown_type_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|OP_IDENTIFIER
condition|)
name|error
argument_list|(
literal|"unresolved reference to user-defined operator"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"address of overloaded function with no contextual type information"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|error
argument_list|(
literal|"address of overloaded function with no contextual type information"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OP_IDENTIFIER
condition|)
name|error
argument_list|(
literal|"unresolved reference to user-defined operator"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|warning
argument_list|(
literal|"useless reference to a member function name, did you forget the ()?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|remove_implicit_immediately
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|cleanup_after_call
argument_list|(
name|exp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|warning_with_decl
argument_list|(
name|exp
argument_list|,
literal|"reference, not call, to function `%s'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_RAISES
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|flag_handle_exceptions
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|current_binding_level
operator|->
name|more_exceptions_ok
condition|)
block|{
specifier|extern
name|struct
name|nesting
modifier|*
name|nesting_stack
decl_stmt|,
modifier|*
name|block_stack
decl_stmt|;
name|remove_implicit_immediately
operator|=
operator|(
name|nesting_stack
operator|!=
name|block_stack
operator|)
expr_stmt|;
name|cplus_expand_start_try
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|current_binding_level
operator|->
name|have_exceptions
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|expand_expr_stmt
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove_implicit_immediately
condition|)
name|pop_implicit_try_blocks
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up any pending cleanups.  This happens when a function call      returns a cleanup-needing value that nobody uses.  */
name|expand_cleanups_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When a stmt has been parsed, this function is called.     Currently, this function only does something within a    constructor's scope: if a stmt has just assigned to this,    and we are in a derived class, we call `emit_base_init'.  */
end_comment

begin_function
name|void
name|finish_stmt
parameter_list|()
block|{
specifier|extern
name|struct
name|nesting
modifier|*
name|cond_stack
decl_stmt|,
modifier|*
name|loop_stack
decl_stmt|,
modifier|*
name|case_stack
decl_stmt|;
if|if
condition|(
name|current_function_assigns_this
operator|||
operator|!
name|current_function_just_assigned_this
condition|)
return|return;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* Constructors must wait until we are out of control 	 zones before calling base constructors.  */
if|if
condition|(
name|cond_stack
operator|||
name|loop_stack
operator|||
name|case_stack
condition|)
return|return;
name|emit_insns
argument_list|(
name|base_init_insns
argument_list|)
expr_stmt|;
name|check_base_init
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
block|}
name|current_function_assigns_this
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_implicit_try_blocks
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|decl
condition|)
block|{
name|assert
argument_list|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|3
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|names
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|3
condition|)
block|{
name|tree
name|name
init|=
name|get_identifier
argument_list|(
literal|"(compiler error)"
argument_list|)
decl_stmt|;
name|tree
name|orig_ex_type
init|=
name|current_exception_type
decl_stmt|;
name|tree
name|orig_ex_decl
init|=
name|current_exception_decl
decl_stmt|;
name|tree
name|orig_ex_obj
init|=
name|current_exception_object
decl_stmt|;
name|tree
name|decl
init|=
name|cplus_expand_end_try
argument_list|(
literal|2
argument_list|)
decl_stmt|,
name|decls
decl_stmt|;
name|tree
name|current_exception_ptr
decl_stmt|;
comment|/* @@ It would be nice to make all these point 	 to exactly the same handler.  */
comment|/* Start hidden EXCEPT.  */
name|cplus_expand_start_except
argument_list|(
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* reraise ALL.  */
name|cplus_expand_reraise
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|current_exception_type
operator|=
name|orig_ex_type
expr_stmt|;
name|current_exception_decl
operator|=
name|orig_ex_decl
expr_stmt|;
name|current_exception_object
operator|=
name|orig_ex_obj
expr_stmt|;
comment|/* This will reraise for us.  */
name|cplus_expand_end_except
argument_list|(
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
name|current_binding_level
operator|->
name|names
operator|=
name|decl
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FIELD_XREF
end_ifdef

begin_function
specifier|static
name|void
name|FIELD_end_scope
parameter_list|(
name|lvl
parameter_list|)
name|struct
name|binding_level
modifier|*
name|lvl
decl_stmt|;
block|{
name|FIELD_xref_end_scope
argument_list|(
name|lvl
argument_list|,
name|lvl
operator|->
name|level_chain
argument_list|,
name|lvl
operator|->
name|parm_flag
argument_list|,
name|lvl
operator|->
name|keep
argument_list|,
name|lvl
operator|->
name|tag_transparent
argument_list|)
expr_stmt|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Push a cleanup onto the current binding contour that will cause    ADDR to be cleaned up, in the case that an exception propagates    through its binding contour.  */
end_comment

begin_function
name|void
name|push_exception_cleanup
parameter_list|(
name|addr
parameter_list|)
name|tree
name|addr
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|EXCEPTION_CLEANUP_NAME
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|decl
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|decl
argument_list|,
name|lookup_name
argument_list|(
name|in_charge_identifier
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each binding contour, emit code that deactivates the    exception cleanups.  All other cleanups are left as they were.  */
end_comment

begin_function
specifier|static
name|void
name|deactivate_exception_cleanups
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|tree
name|xyzzy
init|=
name|get_identifier
argument_list|(
name|EXCEPTION_CLEANUP_NAME
argument_list|)
decl_stmt|;
while|while
condition|(
name|b
operator|!=
name|class_binding_level
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|3
condition|)
block|{
name|tree
name|decls
init|=
name|b
operator|->
name|names
decl_stmt|;
while|while
condition|(
name|decls
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decls
argument_list|)
operator|==
name|xyzzy
condition|)
name|expand_assignment
argument_list|(
name|decls
argument_list|,
name|integer_zero_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decls
operator|=
name|TREE_CHAIN
argument_list|(
name|decls
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
block|}
end_function

end_unit

