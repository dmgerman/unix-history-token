begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-depednent node constructors for parse phase of GNU compiler.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@mcc.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cplus-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)> (y) ? (x) : (y))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)< (y) ? (x) : (y))
end_define

begin_define
define|#
directive|define
name|CEIL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + (y) - 1) / (y))
end_define

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language.    Lvalues can be assigned, unless they have TREE_READONLY.    Lvalues can have their address taken, unless they have TREE_REGDECL.  */
end_comment

begin_function
name|int
name|lvalue_p
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|language_lvalue_valid
argument_list|(
name|ref
argument_list|)
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
return|return
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|ref
argument_list|)
condition|)
return|return
literal|0
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|ERROR_MARK
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|NEW_EXPR
case|:
return|return
literal|1
return|;
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
comment|/* unary_complex_lvalue knows how to deal with this case.  */
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
comment|/* A currently unresolved scope ref.  */
case|case
name|SCOPE_REF
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|OFFSET_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|ref
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|ref
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language;    otherwise, print an error message and return zero.  */
end_comment

begin_function
name|int
name|lvalue_or_else
parameter_list|(
name|ref
parameter_list|,
name|string
parameter_list|)
name|tree
name|ref
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|win
init|=
name|lvalue_p
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|error
argument_list|(
literal|"invalid lvalue in %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/* INIT is a CALL_EXPR which needs info about its target.    TYPE is the type that this initialization should appear to have.     Build an encapsultation of the initialization to perfom    and return it so that it can be processed by language-independent    and language-specific expression expanders.  */
end_comment

begin_function
name|tree
name|build_cplus_new
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|slot
init|=
name|build
argument_list|(
name|VAR_DECL
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|rval
init|=
name|build
argument_list|(
name|CPLUS_NEW_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
name|slot
argument_list|)
decl_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|NEW_EXPR
argument_list|,
name|type
argument_list|,
name|slot
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|,
name|class_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a type like TYPE except that its CLASSTYPE_OFFSET    is OFFSET.     Such variant types already made are recorded so that duplicates    are not made.     A variant types should never be used as the type of an expression.    Use TYPE_MAIN_VARIANT to find the main variant.  */
end_comment

begin_function
name|tree
name|build_classtype_variant
parameter_list|(
name|type
parameter_list|,
name|offset
parameter_list|,
name|virtualp
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|virtualp
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|,
name|m
init|=
name|CLASSTYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_saveable_obstack
init|=
name|saveable_obstack
decl_stmt|;
specifier|register
name|int
name|lo
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|offset
argument_list|)
decl_stmt|;
specifier|register
name|int
name|hi
init|=
name|TREE_INT_CST_HIGH
argument_list|(
name|offset
argument_list|)
decl_stmt|;
comment|/* First search the chain variants for one that is what we want.  */
if|if
condition|(
name|hi
operator|==
literal|0
operator|&&
name|lo
operator|==
literal|0
condition|)
name|offset
operator|=
name|integer_zero_node
expr_stmt|;
for|for
control|(
name|t
operator|=
name|m
init|;
name|t
condition|;
name|t
operator|=
name|CLASSTYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|virtualp
operator|==
name|TREE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|)
operator|&&
name|lo
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|CLASSTYPE_OFFSET
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|hi
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|CLASSTYPE_OFFSET
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* We need a new one.  */
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|type
argument_list|)
condition|)
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|current_obstack
operator|=
name|saveable_obstack
expr_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|copy_type_lang_specific
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_OFFSET
argument_list|(
name|t
argument_list|)
operator|=
name|offset
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|)
operator|=
name|virtualp
expr_stmt|;
comment|/* Always promise to have TYPE_POINTER_TO filled in.  */
name|build_pointer_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Add this type to the chain of variants of TYPE.  */
name|CLASSTYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|CLASSTYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CLASSTYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
operator|=
name|t
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
name|saveable_obstack
operator|=
name|ambient_saveable_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Here is how primitive or already-canonicalized types' hash    codes are made.  MUST BE CONSISTENT WITH tree.c !!! */
end_comment

begin_define
define|#
directive|define
name|TYPE_HASH
parameter_list|(
name|TYPE
parameter_list|)
value|TREE_UID (TYPE)
end_define

begin_comment
comment|/* Construct, lay out and return the type of methods belonging to class    BASETYPE and whose arguments and values are described by TYPE.    If that type exists already, reuse it.    TYPE must be a FUNCTION_TYPE node.  */
end_comment

begin_function
name|tree
name|build_cplus_method_type
parameter_list|(
name|basetype
parameter_list|,
name|rettype
parameter_list|,
name|argtypes
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|rettype
decl_stmt|,
name|argtypes
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|tree
name|ptype
init|=
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|METHOD_TYPE
argument_list|)
expr_stmt|;
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|rettype
expr_stmt|;
name|ptype
operator|=
name|build_type_variant
argument_list|(
name|ptype
argument_list|,
operator|!
name|flag_this_is_variable
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The actual arglist for this function includes a "hidden" argument      which is "this".  Put it into the list of argument types.  */
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|ptype
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
comment|/* If we already have such a type, use the old one and free this one.      Note that it also frees up the above cons cell if found.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|basetype
argument_list|)
operator|+
name|TYPE_HASH
argument_list|(
name|rettype
argument_list|)
operator|+
name|type_hash_list
argument_list|(
name|argtypes
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build_cplus_array_type
parameter_list|(
name|elt_type
parameter_list|,
name|index_type
parameter_list|)
name|tree
name|elt_type
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_saveable_obstack
init|=
name|saveable_obstack
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* We need a new one.  If ELT_TYPE is permanent, make this permanent too.  */
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|elt_type
argument_list|)
condition|)
block|{
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
name|t
operator|=
name|build_array_type
argument_list|(
name|elt_type
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* Push these needs up so that initialization takes place      more easily.  */
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
name|saveable_obstack
operator|=
name|ambient_saveable_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* This is temporary until later.  */
end_comment

begin_comment
comment|/* Construct, lay out and return the type of objects which are of type TYPE    as members of type BASETYPE.  If that type exists already, reuse it.  */
end_comment

begin_function
name|tree
name|build_member_type
parameter_list|(
name|basetype
parameter_list|,
name|type
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|OFFSET_TYPE
argument_list|)
expr_stmt|;
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|hashcode
operator|=
name|TREE_UID
argument_list|(
name|basetype
argument_list|)
operator|+
name|TREE_UID
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the actual offsets that our virtual base classes    will have *for this type*.  This must be performed after    the fields are laid out, since virtual baseclasses must    lay down at the end of the record.     Returns the maximum number of virtual functions any of the virtual    baseclasses provide.  */
end_comment

begin_function
name|int
name|layout_vbasetypes
parameter_list|(
name|rec
parameter_list|,
name|max
parameter_list|)
name|tree
name|rec
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
comment|/* Get all the virtual base types that this type uses.      The TREE_VALUE slot holds the virtual baseclass type.  */
name|tree
name|vbase_types
init|=
name|get_vbase_types
argument_list|(
name|rec
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
name|int
name|record_align
init|=
name|MAX
argument_list|(
name|STRUCTURE_SIZE_BOUNDARY
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|record_align
init|=
name|MAX
argument_list|(
name|BITS_PER_UNIT
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* Record size so far is CONST_SIZE + VAR_SIZE * SIZE_UNIT bits,      where CONST_SIZE is an integer      and VAR_SIZE is a tree expression.      If VAR_SIZE is null, the size is just CONST_SIZE.      Naturally we try to avoid using VAR_SIZE.  */
specifier|register
name|int
name|const_size
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|var_size
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|size_unit
init|=
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|nonvirtual_const_size
decl_stmt|;
name|tree
name|nonvirtual_var_size
decl_stmt|;
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|rec
argument_list|)
operator|=
name|vbase_types
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|const_size
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|rec
argument_list|)
expr_stmt|;
else|else
block|{
name|var_size
operator|=
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
expr_stmt|;
name|size_unit
operator|=
name|record_align
expr_stmt|;
block|}
name|nonvirtual_const_size
operator|=
name|const_size
expr_stmt|;
name|nonvirtual_var_size
operator|=
name|var_size
expr_stmt|;
while|while
condition|(
name|vbase_types
condition|)
block|{
name|int
name|inc
decl_stmt|;
name|tree
name|basetype
init|=
name|ASSOC_TYPE
argument_list|(
name|vbase_types
argument_list|)
decl_stmt|;
name|tree
name|offset
decl_stmt|;
if|if
condition|(
name|const_size
operator|==
literal|0
condition|)
name|offset
operator|=
name|integer_zero_node
expr_stmt|;
else|else
name|offset
operator|=
name|convert_units
argument_list|(
name|build_int
argument_list|(
name|const_size
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
operator|>
name|max
condition|)
name|max
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|ASSOC_OFFSET
argument_list|(
name|vbase_types
argument_list|)
operator|=
name|offset
expr_stmt|;
name|inc
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|const_size
operator|+=
name|inc
expr_stmt|;
name|vbase_types
operator|=
name|TREE_CHAIN
argument_list|(
name|vbase_types
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|const_size
operator|-
name|nonvirtual_const_size
condition|)
block|{
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|convert_units
argument_list|(
name|build_int
argument_list|(
name|const_size
operator|-
name|nonvirtual_const_size
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|convert_units
argument_list|(
name|build_int
argument_list|(
name|const_size
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
else|else
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
return|return
name|max
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This function should never be needed.  */
end_comment

begin_endif
unit|void fixup_vbase_offsets (type)      tree type; {   tree virtuals = TREE_CHAIN (CLASS_ASSOC_VIRTUALS (type));    while (virtuals)     {       tree pfn = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals));       tree decl = TREE_OPERAND (pfn, 0);       tree vcontext = get_base_type (DECL_VCONTEXT (decl), DECL_CONTEXT (decl), 0);       if (vcontext != NULL_TREE&& TREE_VIA_VIRTUAL (vcontext)) 	{ 	  tree offset; 	  tree vbase_offset_info; 	  tree parent_type;  	  if (DECL_CONTEXT (decl) == TYPE_MAIN_VARIANT (type)) 	    parent_type = type; 	  else 	    { 	      parent_type = get_base_type (DECL_CONTEXT (decl), type, 0); 	      if (parent_type == 0) 		parent_type = type; 	    } 	  vbase_offset_info = value_member (vcontext, 					    CLASSTYPE_VBASECLASSES (parent_type)); 	  offset = genop (MINUS_EXPR, CLASSTYPE_OFFSET (parent_type), 			  TREE_PURPOSE (vbase_offset_info)); 	  TREE_VALUE (virtuals) = build_vtable_entry (offset, pfn); 	}       virtuals = TREE_CHAIN (virtuals);     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Lay out the base types of a record type, REC.    Tentatively set the size and alignment of REC    according to the base types alone.     Returns list of virtual base classes in a FIELD_DECL chain.  */
end_comment

begin_function
name|tree
name|layout_basetypes
parameter_list|(
name|rec
parameter_list|)
name|tree
name|rec
decl_stmt|;
block|{
comment|/* Chain to hold all the new FIELD_DECLs which point at virtual      base classes.  */
name|tree
name|vbase_decls
init|=
name|NULL_TREE
decl_stmt|;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
name|int
name|record_align
init|=
name|MAX
argument_list|(
name|STRUCTURE_SIZE_BOUNDARY
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|record_align
init|=
name|MAX
argument_list|(
name|BITS_PER_UNIT
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* Record size so far is CONST_SIZE + VAR_SIZE * SIZE_UNIT bits,      where CONST_SIZE is an integer      and VAR_SIZE is a tree expression.      If VAR_SIZE is null, the size is just CONST_SIZE.      Naturally we try to avoid using VAR_SIZE.  */
specifier|register
name|int
name|const_size
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|var_size
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|size_unit
init|=
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|rec
argument_list|)
decl_stmt|;
comment|/* Handle basetypes almost like fields, but record their      offsets differently.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|int
name|inc
decl_stmt|,
name|desired_align
decl_stmt|;
specifier|register
name|tree
name|basetype
init|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|rec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|"base class `%s' has incomplete type"
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_VIAS
argument_list|(
name|rec
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* All basetypes are recorded in the association list of the 	 derived type.  */
if|if
condition|(
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|rec
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NAME_LENGTH
argument_list|(
name|basetype
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|VBASE_NAME
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|VBASE_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The offset for a virtual base class is only 	     used in computing virtual function tables and 	     for initializing virtual base pointers.  The assoc 	     for this base type is built once `get_vbase_types' 	     is called.  */
name|CLASSTYPE_BASECLASS
argument_list|(
name|rec
argument_list|,
name|i
argument_list|)
operator|=
name|basetype
operator|=
name|build_classtype_variant
argument_list|(
name|basetype
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If this basetype can come from another vbase pointer 	     without an additional indirection, we will share 	     that pointer.  If an indirection is involved, we 	     make our own pointer.  */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n_baseclasses
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|rec
argument_list|,
name|j
argument_list|)
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|rec
argument_list|,
name|j
argument_list|)
argument_list|)
operator|&&
name|value_member
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|rec
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
goto|goto
name|got_it
goto|;
block|}
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|rec
expr_stmt|;
name|SET_DECL_FCONTEXT
argument_list|(
name|decl
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_VBASE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|vbase_decls
expr_stmt|;
name|vbase_decls
operator|=
name|decl
expr_stmt|;
name|got_it
label|:
comment|/* The space this decl occupies has already been accounted for.  */
continue|continue;
block|}
else|else
block|{
name|tree
name|class_offset
decl_stmt|;
name|tree
name|assoc
decl_stmt|;
if|if
condition|(
name|const_size
operator|==
literal|0
condition|)
name|class_offset
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
comment|/* Give each base type the alignment it wants.  */
name|const_size
operator|=
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|*
name|TYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|class_offset
operator|=
name|convert_units
argument_list|(
name|build_int
argument_list|(
name|const_size
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|CLASSTYPE_BASECLASS
argument_list|(
name|rec
argument_list|,
name|i
argument_list|)
operator|=
name|basetype
operator|=
name|build_classtype_variant
argument_list|(
name|basetype
argument_list|,
name|class_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
condition|)
name|assoc
operator|=
name|make_assoc
argument_list|(
name|class_offset
argument_list|,
name|basetype
argument_list|,
name|CLASS_ASSOC_VTABLE
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|CLASSTYPE_ASSOC
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|assoc
operator|=
name|make_assoc
argument_list|(
name|class_offset
argument_list|,
name|basetype
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CLASSTYPE_ASSOC
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_ASSOC
argument_list|(
name|rec
argument_list|)
operator|=
name|assoc
expr_stmt|;
if|if
condition|(
name|const_size
operator|!=
literal|0
condition|)
block|{
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|=
name|copy_node
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|DECL_OFFSET
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|=
name|const_size
expr_stmt|;
block|}
block|}
comment|/* Add only the amount of storage not present in 	 the virtual baseclasses.  */
name|inc
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record must have at least as much alignment as any field.  */
name|desired_align
operator|=
name|TYPE_ALIGN
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|record_align
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
name|const_size
operator|+=
name|inc
expr_stmt|;
block|}
if|if
condition|(
name|const_size
condition|)
name|CLASSTYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|build_int_2
argument_list|(
name|const_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|CLASSTYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|CLASSTYPE_ALIGN
argument_list|(
name|rec
argument_list|)
operator|=
name|record_align
expr_stmt|;
return|return
name|vbase_decls
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hashing of lists so that we don't make duplicates.    The entry point is `list_hash_canon'.  */
end_comment

begin_comment
comment|/* Each hash table slot is a bucket containing a chain    of these structures.  */
end_comment

begin_struct
struct|struct
name|list_hash
block|{
name|struct
name|list_hash
modifier|*
name|next
decl_stmt|;
comment|/* Next structure in the bucket.  */
name|int
name|hashcode
decl_stmt|;
comment|/* Hash code of this list.  */
name|tree
name|list
decl_stmt|;
comment|/* The list recorded here.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Now here is the hash table.  When recording a list, it is added    to the slot whose index is the hash code mod the table size.    Note that the hash table is used for several kinds of lists.    While all these live in the same table, they are completely independent,    and the hash code is computed differently for each of these.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_HASH_SIZE
value|59
end_define

begin_decl_stmt
name|struct
name|list_hash
modifier|*
name|list_hash_table
index|[
name|TYPE_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is how primitive or already-canonicalized lists' hash    codes are made.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_HASH
parameter_list|(
name|TYPE
parameter_list|)
value|TREE_UID (TYPE)
end_define

begin_comment
comment|/* Compute a hash code for a list (chain of TREE_LIST nodes    with goodies in the TREE_PURPOSE, TREE_VALUE, and bits of the    TREE_COMMON slots), by adding the hash codes of the individual entries.  */
end_comment

begin_function
name|int
name|list_hash
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|int
name|hashcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
condition|)
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|hashcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|hashcode
operator|+=
literal|1007
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|hashcode
operator|+=
literal|1009
expr_stmt|;
return|return
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* Look in the type hash table for a type isomorphic to TYPE.    If one is found, return it.  Otherwise return 0.  */
end_comment

begin_function
name|tree
name|list_hash_lookup
parameter_list|(
name|hashcode
parameter_list|,
name|list
parameter_list|)
name|int
name|hashcode
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|struct
name|list_hash
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|list_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_VIA_VIRTUAL
argument_list|(
name|list
argument_list|)
operator|&&
name|TREE_VIA_PUBLIC
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_VIA_PUBLIC
argument_list|(
name|list
argument_list|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|h
operator|->
name|list
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add an entry to the list-hash-table    for a list TYPE whose hash code is HASHCODE.  */
end_comment

begin_function
name|void
name|list_hash_add
parameter_list|(
name|hashcode
parameter_list|,
name|list
parameter_list|)
name|int
name|hashcode
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|struct
name|list_hash
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|list_hash
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|class_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|list_hash
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hashcode
operator|=
name|hashcode
expr_stmt|;
name|h
operator|->
name|list
operator|=
name|list
expr_stmt|;
name|h
operator|->
name|next
operator|=
name|list_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
expr_stmt|;
name|list_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given TYPE, and HASHCODE its hash code, return the canonical    object for an identical list if one already exists.    Otherwise, return TYPE, and record it as the canonical object    if it is a permanent object.     To use this function, first create a list of the sort you want.    Then compute its hash code from the fields of the list that    make it different from other similar lists.    Then call this function and use the value.    This function frees the list you pass in if it is a duplicate.  */
end_comment

begin_comment
comment|/* Set to 1 to debug without canonicalization.  Never set by program.  */
end_comment

begin_decl_stmt
name|int
name|debug_no_list_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|list_hash_canon
parameter_list|(
name|hashcode
parameter_list|,
name|list
parameter_list|)
name|int
name|hashcode
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|t1
decl_stmt|;
if|if
condition|(
name|debug_no_list_hash
condition|)
return|return
name|list
return|;
name|t1
operator|=
name|list_hash_lookup
argument_list|(
name|hashcode
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
literal|0
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|class_obstack
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
comment|/* If this is a new list, record it for later reuse.  */
name|list_hash_add
argument_list|(
name|hashcode
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
name|tree
name|hash_tree_cons
parameter_list|(
name|via_public
parameter_list|,
name|via_virtual
parameter_list|,
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|int
name|via_public
decl_stmt|,
name|via_virtual
decl_stmt|;
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|class_obstack
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|t
argument_list|)
operator|=
name|via_public
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|)
operator|=
name|via_virtual
expr_stmt|;
name|hashcode
operator|=
name|list_hash
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|list_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Constructor for hashed lists.  */
end_comment

begin_function
name|tree
name|hash_tree_chain
parameter_list|(
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|class_obstack
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|list_hash
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|list_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similar, but used for concatenating two lists.  */
end_comment

begin_function
name|tree
name|hash_chainon
parameter_list|(
name|list1
parameter_list|,
name|list2
parameter_list|)
name|tree
name|list1
decl_stmt|,
name|list2
decl_stmt|;
block|{
if|if
condition|(
name|list2
operator|==
literal|0
condition|)
return|return
name|list1
return|;
if|if
condition|(
name|list1
operator|==
literal|0
condition|)
return|return
name|list2
return|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list1
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|hash_tree_chain
argument_list|(
name|TREE_VALUE
argument_list|(
name|list1
argument_list|)
argument_list|,
name|list2
argument_list|)
return|;
return|return
name|hash_tree_chain
argument_list|(
name|TREE_VALUE
argument_list|(
name|list1
argument_list|)
argument_list|,
name|hash_chainon
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list1
argument_list|)
argument_list|,
name|list2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_decl_list_1
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|list
operator|=
name|IDENTIFIER_AS_LIST
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|!=
name|TREE_LIST
operator|||
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|!=
name|value
operator|)
condition|)
name|list
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_AS_ID_LIST
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|CLASSTYPE_AS_ID_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|list
operator|=
name|CLASSTYPE_AS_ID_LIST
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|value
argument_list|)
condition|)
name|list
operator|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL_TREE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
return|return
name|build_decl_list
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look in the type hash table for a type isomorphic to    `build_tree_list (NULL_TREE, VALUE)'.    If one is found, return it.  Otherwise return 0.  */
end_comment

begin_function
name|tree
name|list_hash_lookup_or_cons
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
specifier|register
name|int
name|hashcode
init|=
name|TYPE_HASH
argument_list|(
name|value
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|list_hash
modifier|*
name|h
decl_stmt|;
name|struct
name|obstack
modifier|*
name|ambient_obstack
decl_stmt|;
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|list
operator|=
name|IDENTIFIER_AS_LIST
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|!=
name|TREE_LIST
operator|||
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|!=
name|value
operator|)
condition|)
name|list
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_AS_ID_LIST
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|CLASSTYPE_AS_ID_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|list
operator|=
name|CLASSTYPE_AS_ID_LIST
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|list
operator|=
name|CLASSTYPE_AS_ID_LIST
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|value
argument_list|)
condition|)
name|list
operator|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL_TREE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
if|if
condition|(
name|debug_no_list_hash
condition|)
return|return
name|hash_tree_chain
argument_list|(
name|value
argument_list|,
name|NULL_TREE
argument_list|)
return|;
for|for
control|(
name|h
operator|=
name|list_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_VIA_PUBLIC
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_PURPOSE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
name|value
condition|)
block|{
name|assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|h
operator|->
name|list
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|h
operator|->
name|list
return|;
block|}
name|ambient_obstack
operator|=
name|current_obstack
expr_stmt|;
name|current_obstack
operator|=
operator|&
name|class_obstack
expr_stmt|;
name|list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|list_hash_add
argument_list|(
name|hashcode
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an association between TYPE and some parameters:     OFFSET is the offset added to `this' to convert it to a pointer    of type `TYPE *'     VTABLE is the virtual function table with which to initialize    sub-objects of type TYPE.     VIRTUALS are the virtual functions sitting in VTABLE.     CHAIN are more associations we must retain.  */
end_comment

begin_function
name|tree
name|make_assoc
parameter_list|(
name|offset
parameter_list|,
name|type
parameter_list|,
name|vtable
parameter_list|,
name|virtuals
parameter_list|,
name|chain
parameter_list|)
name|tree
name|offset
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|vtable
decl_stmt|,
name|virtuals
decl_stmt|;
name|tree
name|chain
decl_stmt|;
block|{
name|tree
name|assoc
init|=
name|make_tree_vec
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|assoc
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|assoc
argument_list|)
operator|=
name|chain
expr_stmt|;
if|if
condition|(
name|chain
condition|)
name|TREE_USED
argument_list|(
name|assoc
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* n.b.: TREE_VEC_ELT (assoc, 0)<=> TREE_VALUE (assoc).  */
name|TREE_VEC_ELT
argument_list|(
name|assoc
argument_list|,
literal|0
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|assoc
argument_list|,
literal|1
argument_list|)
operator|=
name|offset
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|assoc
argument_list|,
literal|2
argument_list|)
operator|=
name|vtable
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|assoc
argument_list|,
literal|3
argument_list|)
operator|=
name|virtuals
expr_stmt|;
return|return
name|assoc
return|;
block|}
end_function

begin_function
name|tree
name|copy_assoc
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|assoc
init|=
name|copy_list
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|tree
name|rval
init|=
name|assoc
decl_stmt|;
while|while
condition|(
name|assoc
condition|)
block|{
name|TREE_USED
argument_list|(
name|assoc
argument_list|)
operator|=
literal|0
expr_stmt|;
name|assoc
operator|=
name|TREE_CHAIN
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_function
name|tree
name|assoc_value
parameter_list|(
name|elem
parameter_list|,
name|type
parameter_list|)
name|tree
name|elem
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|assoc
init|=
name|CLASSTYPE_ASSOC
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Dispose quickly of degenerate case.  */
if|if
condition|(
name|elem
operator|==
name|type
condition|)
return|return
name|assoc
return|;
while|while
condition|(
name|assoc
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|ASSOC_VALUE
argument_list|(
name|assoc
argument_list|)
condition|)
comment|/* If we find it on the main spine, then 	   there can be no ambiguity.  */
return|return
name|assoc
return|;
if|if
condition|(
name|ASSOC_VALUE
argument_list|(
name|assoc
argument_list|)
operator|!=
name|type
condition|)
block|{
name|tree
name|nval
init|=
name|assoc_value
argument_list|(
name|elem
argument_list|,
name|ASSOC_TYPE
argument_list|(
name|assoc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nval
condition|)
if|if
condition|(
name|rval
operator|&&
name|ASSOC_TYPE
argument_list|(
name|rval
argument_list|)
operator|!=
name|ASSOC_TYPE
argument_list|(
name|nval
argument_list|)
condition|)
comment|/* If we find it underneath, we must make sure that 		 there are no two ways to do it.  */
name|compiler_error
argument_list|(
literal|"base class `%s' ambiguous in assoc_value"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|nval
expr_stmt|;
block|}
name|assoc
operator|=
name|TREE_CHAIN
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_function
name|tree
name|virtual_member
parameter_list|(
name|elem
parameter_list|,
name|list
parameter_list|)
name|tree
name|elem
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|rval
decl_stmt|,
name|nval
decl_stmt|;
for|for
control|(
name|t
operator|=
name|list
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|elem
operator|==
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|rval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|list
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|nval
operator|=
name|assoc_value
argument_list|(
name|elem
argument_list|,
name|CLASSTYPE_BASECLASS
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
condition|)
block|{
if|if
condition|(
name|rval
operator|&&
name|TREE_TYPE
argument_list|(
name|nval
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rval
operator|=
name|nval
expr_stmt|;
block|}
block|}
block|}
return|return
name|rval
return|;
block|}
end_function

begin_function
name|void
name|debug_dump_assoc
parameter_list|(
name|elem
parameter_list|)
name|tree
name|elem
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|virtuals
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"type \"%s\"; offset = %d\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|ASSOC_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|ASSOC_OFFSET
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable type:\n"
argument_list|)
expr_stmt|;
name|dump_tree
argument_list|(
name|stderr
argument_list|,
name|ASSOC_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASSOC_VTABLE
argument_list|(
name|elem
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable decl \"%s\"\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|ASSOC_VTABLE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no vtable decl yet\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"virtuals:\n"
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|ASSOC_VIRTUALS
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtuals
operator|!=
literal|0
condition|)
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s [%d =? %d]\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|lang_printable_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|THIS_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
literal|"this"
return|;
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|"((anonymous))"
return|;
block|}
if|if
condition|(
name|DECL_PRINT_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|print_ret_type_p
init|=
operator|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|temp
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|8192
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|fndecl_as_string
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|decl
argument_list|,
name|print_ret_type_p
argument_list|)
decl_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|DECL_PRINT_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|oballoc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|DECL_PRINT_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_PRINT_NAME
argument_list|(
name|decl
argument_list|)
operator|=
literal|"((anonymous))"
expr_stmt|;
return|return
name|DECL_PRINT_NAME
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue about whether debugger should    output full info about this type or not.     Current strategy is to permit types which define    no member functions to be output normally.  For    those which do define member functions, if no    member functions have yet been output, then don't    output the definition of the type.  If member functions    for the type are later seen, a full definition of the    type will eventually be output.  */
end_comment

begin_function
name|int
name|lang_output_debug_info
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|extern
name|tree
name|pending_vtables
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flag_minimal_debug
condition|)
block|{
comment|/* Don't output full info about any type 	 which does not have its implementation defined here.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
operator|&&
name|write_virtuals
operator|==
literal|2
condition|)
return|return
name|value_member
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|pending_vtables
argument_list|)
operator|!=
literal|0
return|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|CLASSTYPE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
return|;
block|}
else|else
comment|/* Can't work until GDB is modified.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Comparison function for sorting identifiers in RAISES lists.    Note that because IDENTIFIER_NODEs are unique, we can sort    them by address, saving an indirection.  */
end_comment

begin_function
specifier|static
name|int
name|id_cmp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|int
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|*
name|p1
operator|-
operator|*
name|p2
return|;
block|}
end_block

begin_comment
comment|/* Build the FUNCTION_TYPE or METHOD_TYPE which may raise exceptions    listed in RAISES.  */
end_comment

begin_function
name|tree
name|build_exception_variant
parameter_list|(
name|ctype
parameter_list|,
name|type
parameter_list|,
name|raises
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|raises
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|v
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|t2
decl_stmt|,
name|cname
decl_stmt|;
name|tree
modifier|*
name|a
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|list_length
argument_list|(
name|raises
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|constp
init|=
name|TREE_READONLY
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TREE_VOLATILE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|raises
operator|&&
name|TREE_CHAIN
argument_list|(
name|raises
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|t
operator|=
name|raises
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|i
operator|++
control|)
name|a
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
comment|/* NULL terminator for list.  */
name|a
index|[
name|i
index|]
operator|=
name|NULL_TREE
expr_stmt|;
name|qsort
argument_list|(
name|a
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|id_cmp
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
name|TREE_CHAIN
argument_list|(
name|a
index|[
name|i
index|]
argument_list|)
operator|=
name|a
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|raises
operator|=
name|a
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|raises
condition|)
comment|/* do nothing.  */
empty_stmt|;
else|else
return|return
name|build_type_variant
argument_list|(
name|v
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
return|;
if|if
condition|(
name|ctype
condition|)
block|{
name|cname
operator|=
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cname
operator|=
name|DECL_NAME
argument_list|(
name|cname
argument_list|)
expr_stmt|;
block|}
else|else
name|cname
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|t
operator|=
name|raises
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
comment|/* See that all the exceptions we are thinking about 	 raising have been declared.  */
name|tree
name|this_cname
init|=
name|lookup_exception_cname
argument_list|(
name|ctype
argument_list|,
name|cname
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|lookup_exception_object
argument_list|(
name|this_cname
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
name|decl
operator|=
name|lookup_exception_object
argument_list|(
name|this_cname
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Place canonical exception decl into TREE_TYPE of RAISES list.  */
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
for|for
control|(
name|v
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|v
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|v
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|v
argument_list|)
operator|!=
name|constp
operator|||
name|TREE_VOLATILE
argument_list|(
name|v
argument_list|)
operator|!=
name|volatilep
condition|)
continue|continue;
name|t
operator|=
name|raises
expr_stmt|;
name|t2
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|&&
name|t2
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
condition|)
block|{
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|t
operator|||
name|t2
condition|)
continue|continue;
comment|/* List of exceptions raised matches previously found list.           @@ Nice to free up storage used in consing up the 	 @@ list of exceptions raised.  */
return|return
name|v
return|;
block|}
comment|/* Need to build a new variant.  */
name|v
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|v
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|type
argument_list|)
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|raises
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|raises
argument_list|)
condition|)
block|{
name|int
name|temporary
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
if|if
condition|(
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|raises
operator|=
name|copy_list
argument_list|(
name|raises
argument_list|)
expr_stmt|;
if|if
condition|(
name|temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|v
argument_list|)
operator|=
name|raises
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of make_permanent_node.     Assuming T is a node build bottom-up, make it all exist on    permanent obstack, if it is not permanent already.  */
end_comment

begin_function
specifier|static
name|tree
name|make_deep_copy
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
switch|switch
condition|(
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|CONST_DECL
case|:
break|break;
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|chain
init|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|=
name|make_deep_copy
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|make_deep_copy
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|make_deep_copy
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|TREE_VEC
case|:
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|len
argument_list|)
operator|=
name|make_deep_copy
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
name|copy_node
argument_list|(
name|t
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
case|case
name|NEW_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|make_deep_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|make_deep_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|make_deep_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|SAVE_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|make_deep_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|MODIFY_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|CALL_EXPR
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|make_deep_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|make_deep_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|make_deep_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
comment|/*  This list is incomplete, but should suffice for now. 	  It is very important that `sorry' does not call 	  `report_error_function'.  That could cause an infinite loop.  */
default|default:
name|sorry
argument_list|(
literal|"initializer contains unrecognized tree code"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assuming T is a node built bottom-up, make it all exist on    permanent obstack, if it is not permanent already.  */
end_comment

begin_function
name|tree
name|copy_to_permanent
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_saveable_obstack
init|=
name|saveable_obstack
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|current_obstack
operator|=
name|saveable_obstack
expr_stmt|;
name|t
operator|=
name|make_deep_copy
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
name|saveable_obstack
operator|=
name|ambient_saveable_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|int
name|lang_simple_cst_equal
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|CPLUS_NEW_EXPR
case|:
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_list_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

end_unit

