begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Prints out tree in human readable form - GNU C++ compiler    Copyright (C) 1987 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@mcc.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cplus-tree.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tree_code_err_name
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tree_code_err_asg_name
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|mode_name
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|spaces
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x< y) ? x : y)
end_define

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This code is copied from print-tree.c.  */
end_comment

begin_function
specifier|static
name|void
name|wruid
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
name|fputs
argument_list|(
literal|"<>"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%1d"
argument_list|,
name|TREE_UID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|part
parameter_list|(
name|title
parameter_list|,
name|node
parameter_list|)
name|char
name|title
index|[]
decl_stmt|;
name|tree
name|node
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %s = "
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|wruid
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to `part' but prefix with @ if value is not constant    and print the constant value if it is constant.  */
end_comment

begin_function
specifier|static
name|void
name|cpart
parameter_list|(
name|title
parameter_list|,
name|ct
parameter_list|,
name|punct
parameter_list|)
name|char
modifier|*
name|title
decl_stmt|;
name|tree
name|ct
decl_stmt|;
name|char
name|punct
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %s = "
argument_list|,
name|title
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
name|fputs
argument_list|(
literal|"<>"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|TREE_LITERAL
argument_list|(
name|ct
argument_list|)
condition|)
block|{
name|putc
argument_list|(
literal|'@'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|wruid
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%ld"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|ct
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|punct
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_lang_decl
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|walk_lang_decl
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|print_lang_type
parameter_list|(
name|node
parameter_list|)
specifier|register
name|tree
name|node
decl_stmt|;
block|{
name|int
name|first
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
return|return;
name|first
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
literal|" ["
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"needs-constructor"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"needs-destructor"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"has-type-conversion"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"has-int-conversion"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"has-float-conversion"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"X(X&)"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_GETS_NEW
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"gets-new"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_GETS_DELETE
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"gets-delete"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"has="
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"gets="
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"this=(X&)"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_GETS_ASSIGN_REF
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"gets=(X&)"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_WRAPPER
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"wrapper"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"op->()"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_GETS_INIT_AGGR
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"gets X(X, ...)"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"op()"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"op[]"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"uses-multiple-inheritance"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"] "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|walk_lang_type
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|)
return|return;
name|part
argument_list|(
literal|"member functions"
argument_list|,
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|part
argument_list|(
literal|"baselinks"
argument_list|,
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|cpart
argument_list|(
literal|"offset"
argument_list|,
name|CLASSTYPE_OFFSET
argument_list|(
name|node
argument_list|)
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"n_parents = %d; n_ancestors = %d;"
argument_list|,
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|node
argument_list|)
argument_list|,
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

