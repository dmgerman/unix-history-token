begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C-compiler utilities for types and variables storage layout    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_comment
comment|/* For GET_MODE_SIZE */
end_comment

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)> (y) ? (x) : (y))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)< (y) ? (x) : (y))
end_define

begin_define
define|#
directive|define
name|CEIL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + (y) - 1) / (y))
end_define

begin_comment
comment|/* Data type for the expressions representing sizes of data types.    It is the first integer type laid out.    In C, this is int.  */
end_comment

begin_decl_stmt
name|tree
name|sizetype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An integer constant with value 0 whose type is sizetype.  */
end_comment

begin_decl_stmt
name|tree
name|size_zero_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An integer constant with value 1 whose type is sizetype.  */
end_comment

begin_decl_stmt
name|tree
name|size_one_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Integer constants with sizes for pointers and reference types,    function types, and method types respectively.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|ptr_size_node
decl_stmt|,
name|function_size_node
decl_stmt|,
name|method_size_node
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GET_MODE_ALIGNMENT
parameter_list|(
name|MODE
parameter_list|)
define|\
value|MIN (BIGGEST_ALIGNMENT, 	   \        MAX (1, (GET_MODE_UNIT_SIZE (MODE) * BITS_PER_UNIT)))
end_define

begin_escape
end_escape

begin_comment
comment|/* Chain of all permanent types we have allocated since last    call to get_permanent_types.  */
end_comment

begin_decl_stmt
name|tree
name|permanent_type_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all temporary types we have allocated in this function.  */
end_comment

begin_decl_stmt
name|tree
name|temporary_type_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When the chains is not null, these point at the last    types on the two chains.  These help us tell whether a type    is already on a chain.  */
end_comment

begin_decl_stmt
name|tree
name|permanent_type_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|temporary_type_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Put the newly-made type T    on either permanent_type_chain or temporary_type_chain.    Types that are const or volatile variants of other types    are not put on any chain, since in the gdb symbol segment    we do not make those distinctions.     If T is already on the chain, we do nothing.  */
end_comment

begin_function
name|void
name|chain_type
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|!=
name|t
condition|)
return|return;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* If T is on the chain at the end, don't chain it to itself!  */
if|if
condition|(
name|t
operator|==
name|permanent_type_end
condition|)
return|return;
comment|/* Add T to the end of the chain.  */
if|if
condition|(
name|permanent_type_chain
operator|==
literal|0
condition|)
name|permanent_type_chain
operator|=
name|t
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|permanent_type_end
argument_list|)
operator|=
name|t
expr_stmt|;
name|permanent_type_end
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t
operator|==
name|temporary_type_end
condition|)
return|return;
if|if
condition|(
name|temporary_type_chain
operator|==
literal|0
condition|)
name|temporary_type_chain
operator|=
name|t
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|temporary_type_end
argument_list|)
operator|=
name|t
expr_stmt|;
name|temporary_type_end
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a chain of all permanent types made since this function    was last called.  */
end_comment

begin_function
name|tree
name|get_permanent_types
parameter_list|()
block|{
specifier|register
name|tree
name|tem
init|=
name|permanent_type_chain
decl_stmt|;
name|permanent_type_chain
operator|=
literal|0
expr_stmt|;
name|permanent_type_end
operator|=
literal|0
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Get a chain of all temporary types made since this function    was last called.  */
end_comment

begin_function
name|tree
name|get_temporary_types
parameter_list|()
block|{
specifier|register
name|tree
name|tem
init|=
name|temporary_type_chain
decl_stmt|;
name|temporary_type_chain
operator|=
literal|0
expr_stmt|;
name|temporary_type_end
operator|=
literal|0
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* SAVE_EXPRs for sizes of types and decls, waiting to be expanded.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|pending_sizes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means cannot safely call expand_expr now,    so put variable sizes onto `pending_sizes' instead.  */
end_comment

begin_decl_stmt
name|int
name|immediate_size_expand
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|get_pending_sizes
parameter_list|()
block|{
name|tree
name|chain
init|=
name|pending_sizes
decl_stmt|;
name|pending_sizes
operator|=
literal|0
expr_stmt|;
return|return
name|chain
return|;
block|}
end_function

begin_comment
comment|/* Given a size SIZE that isn't constant, return a SAVE_EXPR    to serve as the actual size-expression for a type or decl.  */
end_comment

begin_function
specifier|static
name|tree
name|variable_size
parameter_list|(
name|size
parameter_list|)
name|tree
name|size
decl_stmt|;
block|{
name|size
operator|=
name|save_expr
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_bindings_p
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"variable-size type declared outside of any function"
argument_list|)
expr_stmt|;
return|return
name|build_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|immediate_size_expand
condition|)
name|expand_expr
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|pending_sizes
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|pending_sizes
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the machine mode to use for an aggregate of SIZE bits.     Note!!!  We only use a non-BLKmode mode if the size matches exactly.    There used to be the idea of using DImode for anything whose    size was less than DImode but more than SImode.  This does not work    because DImode moves cannot be used to store such objects in memory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_FIXED_MODE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_FIXED_MODE_SIZE
value|GET_MODE_BITSIZE (DImode)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|enum
name|machine_mode
name|agg_mode
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|units
init|=
name|size
operator|/
name|BITS_PER_UNIT
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|t
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|size
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
condition|)
return|return
name|BLKmode
return|;
if|if
condition|(
name|size
operator|>
name|MAX_FIXED_MODE_SIZE
condition|)
return|return
name|BLKmode
return|;
comment|/* Get the last mode which has this size.  */
name|val
operator|=
name|BLKmode
expr_stmt|;
for|for
control|(
name|t
operator|=
name|QImode
init|;
name|GET_MODE_CLASS
argument_list|(
name|t
argument_list|)
operator|==
name|MODE_INT
condition|;
name|t
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|t
operator|+
literal|1
operator|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
name|units
condition|)
name|val
operator|=
name|t
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an INTEGER_CST with value V and type from `sizetype'.  */
end_comment

begin_function
name|tree
name|build_int
parameter_list|(
name|v
parameter_list|)
name|int
name|v
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|sizetype
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Combine operands OP1 and OP2 with arithmetic operation OPC.    OPC is a tree code.  Data type is taken from `sizetype',    If the operands are constant, so is the result.  */
end_comment

begin_function
name|tree
name|genop
parameter_list|(
name|opc
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|enum
name|tree_code
name|opc
decl_stmt|;
name|tree
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
comment|/* Handle the special case of two integer constants faster.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* And some specific cases even faster than that.  */
if|if
condition|(
name|opc
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|op2
return|;
if|if
condition|(
name|opc
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|op2
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|op2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|opc
operator|==
name|MULT_EXPR
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|==
literal|1
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|op2
return|;
if|if
condition|(
name|opc
operator|==
name|CEIL_DIV_EXPR
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|op2
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|op2
argument_list|)
condition|)
return|return
name|size_one_node
return|;
comment|/* Handle general case of two integer constants.  */
return|return
name|combine
argument_list|(
name|opc
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
if|if
condition|(
name|op1
operator|==
name|error_mark_node
operator|||
name|op2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|opc
argument_list|,
name|sizetype
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a size which is SIZE when expressed in unit INUNITS    into the units OUTUNITS.  Rounds up if conversion is not exact.    If SIZE is constant, so is the result.  */
end_comment

begin_function
name|tree
name|convert_units
parameter_list|(
name|size
parameter_list|,
name|inunits
parameter_list|,
name|outunits
parameter_list|)
name|tree
name|size
decl_stmt|;
specifier|register
name|int
name|inunits
decl_stmt|,
name|outunits
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|inunits
operator|==
name|outunits
condition|)
return|return
name|size
return|;
comment|/* Check for inunits divisible by outunits.      In that case, just multiply by their ratio.  */
if|if
condition|(
literal|0
operator|==
operator|(
name|inunits
operator|%
name|outunits
operator|)
condition|)
return|return
name|genop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size
argument_list|,
name|build_int
argument_list|(
name|inunits
operator|/
name|outunits
argument_list|)
argument_list|)
return|;
comment|/* The inverse case.  */
if|if
condition|(
literal|0
operator|==
operator|(
name|outunits
operator|%
name|inunits
operator|)
condition|)
block|{
comment|/* Discard anything in SIZE to round it up to a multiple 	 of a number N that divides our current divisor.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|==
operator|(
name|outunits
operator|/
name|inunits
operator|)
operator|%
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CEIL_DIV_EXPR
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|size
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|genop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|size
argument_list|,
name|build_int
argument_list|(
name|outunits
operator|/
name|inunits
argument_list|)
argument_list|)
return|;
block|}
comment|/* The general case.  */
name|t
operator|=
name|genop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size
argument_list|,
name|build_int
argument_list|(
name|inunits
argument_list|)
argument_list|)
expr_stmt|;
comment|/* convert to bits */
return|return
name|genop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|t
argument_list|,
name|build_int
argument_list|(
name|outunits
argument_list|)
argument_list|)
return|;
comment|/* then to outunits */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the size, mode and alignment of a ..._DECL node.    TYPE_DECL does need this for C++.  It is up to language-specific    code to intialize the DECL_OFFSET of TYPE_DECL nodes.    Note that LABEL_DECL and CONST_DECL nodes do not need this,    and FUNCTION_DECL nodes have them set up in a special (and simple) way.    Don't call layout_decl for them.     KNOWN_ALIGN is the amount of alignment we can assume this    decl has with no special effort.  It is relevant only for FIELD_DECLs    and depends on the previous fields.    All that matters about KNOWN_ALIGN is which powers of 2 divide it.    If KNOWN_ALIGN is 0, it means, "as much alignment as you like":    the record will be aligned to suit.  */
end_comment

begin_function
name|void
name|layout_decl
parameter_list|(
name|decl
parameter_list|,
name|known_align
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|unsigned
name|known_align
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|spec_size
init|=
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|CONST_DECL
condition|)
return|return;
if|if
condition|(
name|code
operator|!=
name|VAR_DECL
operator|&&
name|code
operator|!=
name|PARM_DECL
operator|&&
name|code
operator|!=
name|RESULT_DECL
operator|&&
name|code
operator|!=
name|FIELD_DECL
operator|&&
name|code
operator|!=
name|TYPE_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|type
operator|=
name|void_type_node
expr_stmt|;
name|spec_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Usually the size and mode come from the data type without change.  */
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|FIELD_DECL
operator|&&
name|TREE_PACKED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* This is a bit-field.  We don't know how to handle 	 them except for integers and enums, and front end should 	 never generate them otherwise.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|spec_size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Mode is "integer bit field".  */
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|BImode
expr_stmt|;
comment|/* Size is specified number of bits.  */
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|size_one_node
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|spec_size
expr_stmt|;
block|}
comment|/* Force alignment required for the data type.      But if the decl itself wants greater alignment, don't override that.  */
elseif|else
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
condition|)
name|bitsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* See if we can use a scalar mode such as QImode or SImode      in place of BLKmode or a packed byte mode.  */
comment|/* Conditions are: a fixed size that is correct for another mode      and occupying a complete byte or bytes on proper boundary.  */
if|if
condition|(
operator|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BLKmode
operator|||
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BImode
operator|)
comment|/* Don't do this if DECL's type requires it to be BLKmode.  */
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
specifier|register
name|enum
name|machine_mode
name|xmode
init|=
name|agg_mode
argument_list|(
name|bitsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|xmode
operator|!=
name|BLKmode
operator|&&
name|known_align
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|xmode
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MAX
argument_list|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|xmode
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|xmode
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_int
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|xmode
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|xmode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't let more than one word of an aggregate occupy one register,      since then the SUBREG used to access the high part would malfunction.      Check that the expected # of registers is big enough that they      seem to hold this variable with just a word per register.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
condition|)
block|{
comment|/* This test is not exactly right, since we really want the minimum 	 number of regs in any class that can hold this mode. 	 But it does distinguish the machines we need to distinguish, 	 for now.  */
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|ALL_REGS
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
name|BITS_PER_WORD
operator|<
name|bitsize
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Evaluate nonconstant size only once, either now or as soon as safe.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|TREE_LITERAL
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|variable_size
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lay out a RECORD_TYPE type (a C struct).    This means laying out the fields, determining their offsets,    and computing the overall size and required alignment of the record.    Note that if you set the TYPE_ALIGN before calling this    then the struct is aligned to at least that boundary.     If the type has basetypes, you must call layout_basetypes    before calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|layout_record
parameter_list|(
name|rec
parameter_list|)
name|tree
name|rec
decl_stmt|;
block|{
specifier|register
name|tree
name|field
decl_stmt|;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
name|int
name|record_align
init|=
name|MAX
argument_list|(
name|STRUCTURE_SIZE_BOUNDARY
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|record_align
init|=
name|MAX
argument_list|(
name|BITS_PER_UNIT
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* These must be laid out *after* the record is.  */
name|tree
name|pending_statics
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Record size so far is CONST_SIZE + VAR_SIZE * SIZE_UNIT bits,      where CONST_SIZE is an integer      and VAR_SIZE is a tree expression.      If VAR_SIZE is null, the size is just CONST_SIZE.      Naturally we try to avoid using VAR_SIZE.  */
specifier|register
name|int
name|const_size
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|var_size
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|size_unit
init|=
name|BITS_PER_UNIT
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|rec
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
specifier|register
name|int
name|desired_align
decl_stmt|;
comment|/* If FIELD is a VAR_DECL, then treat it like a separate variable, 	 not really like a structure field. 	 If it is a FUNCTION_DECL, it's a method. 	 In both cases, all we do is lay out the decl, 	 and we do it *after* the record is laid out.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|pending_statics
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|field
argument_list|,
name|pending_statics
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Enumerators and enum types which are local to this class need not 	 be laid out.  Same with initialized constant fields.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
comment|/* Lay out the field so we know what alignment it needs. 	 For KNOWN_ALIGN, pass the number of bits from start of record 	 or some divisor of it.  */
name|layout_decl
argument_list|(
name|field
argument_list|,
name|var_size
condition|?
name|size_unit
else|:
name|const_size
argument_list|)
expr_stmt|;
name|desired_align
operator|=
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* Record must have at least as much alignment as any field. 	 Otherwise, the alignment of the field within the record 	 is meaningless.  */
name|record_align
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
comment|/* In PCC on Vax, Sony, etc., a bit field of declare type `int' 	 forces the entire structure to have `int' alignment.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
condition|)
name|record_align
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Does this field automatically have alignment it needs 	 by virtue of the fields that precede it and the record's 	 own alignment?  */
if|if
condition|(
name|const_size
operator|%
name|desired_align
operator|!=
literal|0
operator|||
operator|(
name|size_unit
operator|%
name|desired_align
operator|!=
literal|0
operator|&&
name|var_size
operator|)
condition|)
block|{
comment|/* No, we need to skip space before this field. 	     Bump the cumulative size to multiple of field alignment.  */
if|if
condition|(
name|var_size
operator|==
literal|0
operator|||
name|size_unit
operator|%
name|desired_align
operator|==
literal|0
condition|)
name|const_size
operator|=
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|desired_align
argument_list|)
operator|*
name|desired_align
expr_stmt|;
else|else
block|{
name|var_size
operator|=
name|genop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|var_size
argument_list|,
name|build_int
argument_list|(
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|size_unit
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|const_size
operator|=
literal|0
expr_stmt|;
name|var_size
operator|=
name|convert_units
argument_list|(
name|var_size
argument_list|,
name|size_unit
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
name|size_unit
operator|=
name|desired_align
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|int
name|type_align
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|dsize
init|=
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|int
name|field_size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|dsize
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|/* A bit field may not span the unit of alignment of its type. 	     Advance to next boundary if necessary.  */
if|if
condition|(
name|const_size
operator|/
name|type_align
operator|!=
operator|(
name|const_size
operator|+
name|field_size
operator|-
literal|1
operator|)
operator|/
name|type_align
condition|)
name|const_size
operator|=
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|type_align
argument_list|)
operator|*
name|type_align
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Size so far becomes the offset of this field.  */
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
operator|=
name|const_size
expr_stmt|;
name|DECL_VOFFSET
argument_list|(
name|field
argument_list|)
operator|=
name|var_size
expr_stmt|;
name|DECL_VOFFSET_UNIT
argument_list|(
name|field
argument_list|)
operator|=
name|size_unit
expr_stmt|;
comment|/* If this field is an anonymous union, 	 give each union-member the same offset as the union has.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|uelt
init|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|uelt
condition|;
name|uelt
operator|=
name|TREE_CHAIN
argument_list|(
name|uelt
argument_list|)
control|)
block|{
name|DECL_FIELD_CONTEXT
argument_list|(
name|uelt
argument_list|)
operator|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|DECL_OFFSET
argument_list|(
name|uelt
argument_list|)
operator|=
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|DECL_VOFFSET
argument_list|(
name|uelt
argument_list|)
operator|=
name|DECL_VOFFSET
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|DECL_VOFFSET_UNIT
argument_list|(
name|uelt
argument_list|)
operator|=
name|DECL_VOFFSET_UNIT
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now add size of this field to the size of the record.  */
block|{
specifier|register
name|tree
name|dsize
init|=
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|dsize
argument_list|)
condition|)
name|const_size
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|dsize
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var_size
operator|==
literal|0
condition|)
block|{
name|var_size
operator|=
name|dsize
expr_stmt|;
name|size_unit
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|tunits
init|=
name|MIN
argument_list|(
name|size_unit
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|var_size
operator|=
name|genop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|convert_units
argument_list|(
name|var_size
argument_list|,
name|size_unit
argument_list|,
name|tunits
argument_list|)
argument_list|,
name|convert_units
argument_list|(
name|dsize
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|,
name|tunits
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Work out the total size and alignment of the record      as one expression and store in the record type.      Round it up to a multiple of the record's alignment.  */
if|if
condition|(
name|var_size
operator|==
literal|0
condition|)
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|build_int
argument_list|(
name|CEIL
argument_list|(
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|record_align
argument_list|)
operator|*
name|record_align
argument_list|,
name|size_unit
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|const_size
condition|)
name|var_size
operator|=
name|genop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|var_size
argument_list|,
name|build_int
argument_list|(
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|size_unit
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|convert_units
argument_list|(
name|var_size
argument_list|,
name|size_unit
argument_list|,
name|record_align
argument_list|)
expr_stmt|;
name|size_unit
operator|=
name|record_align
expr_stmt|;
block|}
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|convert_units
argument_list|(
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|,
name|size_unit
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|rec
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
operator|=
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|record_align
argument_list|)
expr_stmt|;
comment|/* Lay out any static members.  This is done now      because their type may use the record's type.  */
for|for
control|(
name|field
operator|=
name|pending_statics
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
name|layout_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lay out a UNION_TYPE type.    Lay out all the fields, set their offsets to zero,    and compute the size and alignment of the union (maximum of any field).    Note that if you set the TYPE_ALIGN before calling this    then the union align is aligned to at least that boundary.  */
end_comment

begin_function
specifier|static
name|void
name|layout_union
parameter_list|(
name|rec
parameter_list|)
name|tree
name|rec
decl_stmt|;
block|{
specifier|register
name|tree
name|field
decl_stmt|;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
name|int
name|union_align
init|=
name|STRUCTURE_SIZE_BOUNDARY
decl_stmt|;
else|#
directive|else
name|int
name|union_align
init|=
name|BITS_PER_UNIT
decl_stmt|;
endif|#
directive|endif
comment|/* The size of the union, based on the fields scanned so far,      is max (CONST_SIZE, VAR_SIZE).      VAR_SIZE may be null; then CONST_SIZE by itself is the size.  */
specifier|register
name|int
name|const_size
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|var_size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|rec
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
comment|/* Enums which are local to this class need not 	 be laid out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|layout_decl
argument_list|(
name|field
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_VOFFSET
argument_list|(
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_VOFFSET_UNIT
argument_list|(
name|field
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Union must be at least as aligned as any field requires.  */
name|union_align
operator|=
name|MAX
argument_list|(
name|union_align
argument_list|,
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
comment|/* On the m88000, a bit field of declare type `int' 	 forces the entire union to have `int' alignment.  */
name|union_align
operator|=
name|MAX
argument_list|(
name|union_align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set union_size to max (decl_size, union_size). 	 There are more and less general ways to do this. 	 Use only CONST_SIZE unless forced to use VAR_SIZE.  */
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|const_size
operator|=
name|MAX
argument_list|(
name|const_size
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var_size
operator|==
literal|0
condition|)
name|var_size
operator|=
name|convert_units
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|var_size
operator|=
name|genop
argument_list|(
name|MAX_EXPR
argument_list|,
name|convert_units
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|var_size
argument_list|)
expr_stmt|;
block|}
comment|/* Determine the ultimate size of the union (in bytes).  */
if|if
condition|(
name|NULL
operator|==
name|var_size
condition|)
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|build_int
argument_list|(
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|const_size
operator|==
literal|0
condition|)
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|var_size
expr_stmt|;
else|else
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|genop
argument_list|(
name|MAX_EXPR
argument_list|,
name|var_size
argument_list|,
name|build_int
argument_list|(
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine the desired alignment.  */
name|union_align
operator|=
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|union_align
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|,
name|union_align
argument_list|)
expr_stmt|;
comment|/* Round the size up to be a multiple of the required alignment */
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|convert_units
argument_list|(
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|rec
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate the mode, size, and alignment for TYPE.    For an array type, calculate the element separation as well.    Record TYPE on the chain of permanent or temporary types    so that dbxout will find out about it.     TYPE_SIZE of a type is nonzero if the type has been laid out already.    layout_type does nothing on such a type.     If the type is incomplete, its TYPE_SIZE remains zero.  */
end_comment

begin_function
name|void
name|layout_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|old
decl_stmt|;
name|int
name|temporary
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Do nothing if type has been laid out before.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
return|return;
comment|/* Make sure all nodes we allocate are not momentary;      they must last past the current statement.  */
name|old
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|type
argument_list|)
operator|&&
name|allocation_temporary_p
argument_list|()
condition|)
block|{
name|temporary
operator|=
literal|1
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|}
name|chain_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|LANG_TYPE
case|:
comment|/* This kind of type is the responsibility 	 of the languge-specific code.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|VOID_TYPE
case|:
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* What follows is like agg_mode except that it ignores 	 MAX_FIXED_MODE_SIZE.  That applies only to structures.  */
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|t
decl_stmt|;
comment|/* Get the last mode which has this size.  */
name|mode
operator|=
name|BLKmode
expr_stmt|;
for|for
control|(
name|t
operator|=
name|QImode
init|;
name|GET_MODE_CLASS
argument_list|(
name|t
argument_list|)
operator|==
name|MODE_INT
condition|;
name|t
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|t
operator|+
literal|1
operator|)
control|)
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
name|mode
operator|=
name|t
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode
expr_stmt|;
block|}
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|build_int
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
block|{
specifier|register
name|int
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|prec
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|SFmode
argument_list|)
condition|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|SFmode
expr_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|DFmode
argument_list|)
condition|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|DFmode
expr_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|TFmode
argument_list|)
condition|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|TFmode
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|build_int
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|Pmode
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|ptr_size_node
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|POINTER_BOUNDARY
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
name|POINTER_SIZE
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
block|{
specifier|register
name|tree
name|index
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|length
decl_stmt|;
specifier|register
name|tree
name|element
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/*	layout_type (element);	*/
name|build_pointer_type
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
name|length
operator|=
literal|0
expr_stmt|;
else|else
name|length
operator|=
name|genop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_one_node
argument_list|,
name|genop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|index
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PACKED
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* ??? Not written yet since not needed for C.  */
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|&&
name|TYPE_SIZE
argument_list|(
name|element
argument_list|)
condition|)
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|genop
argument_list|(
name|MULT_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|element
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|TYPE_SEP
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|TYPE_SEP_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|element
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
comment|/* BLKmode elements force BLKmode aggregate; 	       else extract/store fields may lose.  */
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|BLKmode
ifdef|#
directive|ifdef
name|STRICT_ALIGNMENT
operator|&&
operator|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
name|BIGGEST_ALIGNMENT
operator|||
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|agg_mode
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|RECORD_TYPE
case|:
name|layout_record
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
comment|/* If structure's known alignment is less than 	     what the scalar mode would need, and it matters, 	     then stick with BLKmode.  */
ifdef|#
directive|ifdef
name|STRICT_ALIGNMENT
operator|&&
operator|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
name|BIGGEST_ALIGNMENT
operator|||
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* A record which has any BLKmode members must itself be BLKmode; 	     it can't go in a register.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
goto|goto
name|record_lose
goto|;
comment|/* Must be BLKmode if any field crosses a word boundary, 		 since extract_bit_field can't handle that in registers.  */
if|if
condition|(
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
operator|/
name|BITS_PER_WORD
operator|!=
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
operator|+
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_WORD
operator|)
condition|)
goto|goto
name|record_lose
goto|;
block|}
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|agg_mode
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|record_lose
label|:
empty_stmt|;
block|}
break|break;
case|case
name|UNION_TYPE
case|:
name|layout_union
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
comment|/* If structure's known alignment is less than 	     what the scalar mode would need, and it matters, 	     then stick with BLKmode.  */
ifdef|#
directive|ifdef
name|STRICT_ALIGNMENT
operator|&&
operator|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
name|BIGGEST_ALIGNMENT
operator|||
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* A union which has any BLKmode members must itself be BLKmode; 	     it can't go in a register.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
goto|goto
name|union_lose
goto|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|agg_mode
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|union_lose
label|:
empty_stmt|;
block|}
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|EPmode
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|function_size_node
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|POINTER_BOUNDARY
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|EPmode
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|method_size_node
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|POINTER_BOUNDARY
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* end switch */
comment|/* Evaluate nonconstant size only once, either now or as soon as safe.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|TREE_LITERAL
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|variable_size
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Also layout any other variants of the type.  */
if|if
condition|(
name|TYPE_NEXT_VARIANT
argument_list|(
name|type
argument_list|)
operator|||
name|type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|variant
decl_stmt|;
comment|/* Record layout info of this variant.  */
name|tree
name|size
init|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|size_unit
init|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|align
init|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Copy it into all variants.  */
for|for
control|(
name|variant
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|variant
condition|;
name|variant
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variant
argument_list|)
control|)
block|{
name|TYPE_SIZE
argument_list|(
name|variant
argument_list|)
operator|=
name|size
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|variant
argument_list|)
operator|=
name|size_unit
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|variant
argument_list|)
operator|=
name|align
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|variant
argument_list|)
operator|=
name|mode
expr_stmt|;
block|}
block|}
if|if
condition|(
name|temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|resume_momentary
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create and return a type for signed integers of PRECISION bits.  */
end_comment

begin_function
name|tree
name|make_signed_type
parameter_list|(
name|precision
parameter_list|)
name|int
name|precision
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
name|precision
expr_stmt|;
comment|/* Create the extreme values based on the number of bits.  */
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|build_int_2
argument_list|(
operator|(
name|precision
operator|-
name|HOST_BITS_PER_INT
operator|>
literal|0
condition|?
literal|0
else|:
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|precision
operator|-
literal|1
operator|)
operator|)
argument_list|,
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|precision
operator|-
name|HOST_BITS_PER_INT
operator|-
literal|1
operator|>
literal|0
condition|?
name|precision
operator|-
name|HOST_BITS_PER_INT
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|build_int_2
argument_list|(
operator|(
name|precision
operator|-
name|HOST_BITS_PER_INT
operator|>
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
literal|1
operator|<<
operator|(
name|precision
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
argument_list|,
operator|(
name|precision
operator|-
name|HOST_BITS_PER_INT
operator|-
literal|1
operator|>
literal|0
condition|?
operator|(
literal|1
operator|<<
operator|(
name|precision
operator|-
name|HOST_BITS_PER_INT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Give this type's extreme values this type as their type.  */
name|TREE_TYPE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* The first type made with this or `make_unsigned_type'      is the type for size values.  */
if|if
condition|(
name|sizetype
operator|==
literal|0
condition|)
block|{
name|sizetype
operator|=
name|type
expr_stmt|;
name|ptr_size_node
operator|=
name|build_int
argument_list|(
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|function_size_node
operator|=
name|ptr_size_node
expr_stmt|;
name|method_size_node
operator|=
name|build_int
argument_list|(
literal|2
operator|*
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
comment|/* Lay out the type: set its alignment, size, etc.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Create and return a type for unsigned integers of PRECISION bits.  */
end_comment

begin_function
name|tree
name|make_unsigned_type
parameter_list|(
name|precision
parameter_list|)
name|int
name|precision
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
name|precision
expr_stmt|;
comment|/* The first type made with this or `make_unsigned_type'      is the type for size values.  */
if|if
condition|(
name|sizetype
operator|==
literal|0
condition|)
block|{
name|sizetype
operator|=
name|type
expr_stmt|;
name|ptr_size_node
operator|=
name|build_int
argument_list|(
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|function_size_node
operator|=
name|ptr_size_node
expr_stmt|;
name|method_size_node
operator|=
name|build_int
argument_list|(
literal|2
operator|*
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
name|fixup_unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Set the extreme values of TYPE based on its precision in bits,    the lay it out.  This is used both in `make_unsigned_type'    and for enumeral types.  */
end_comment

begin_function
name|void
name|fixup_unsigned_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|int
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|build_int_2
argument_list|(
name|precision
operator|-
name|HOST_BITS_PER_INT
operator|>=
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
literal|1
operator|<<
name|precision
operator|)
operator|-
literal|1
argument_list|,
name|precision
operator|-
name|HOST_BITS_PER_INT
operator|>
literal|0
condition|?
operator|(
operator|(
name|unsigned
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_INT
operator|-
operator|(
name|precision
operator|-
name|HOST_BITS_PER_INT
operator|)
operator|)
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Lay out the type: set its alignment, size, etc.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

