begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Report error messages, build initializers, and perform    some front-end optimizations for C++ compiler.    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@mcc.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C front end.    It contains routines to build C expressions given their operands,    including computing the types of the result, C-specific error checks,    and some optimization.     There are also routines to build RETURN_STMT nodes and CASE_STMT nodes,    and to process initializations in declarations (since they work    like a strange sort of assignment).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cplus-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_function_decl
specifier|static
name|tree
name|process_init_constructor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|digest_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|incomplete_type_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|readonly_warning_or_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|tree
name|convert_for_initialization
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Print an error message stemming from an attempt to use    BASETYPE as a base class for TYPE.  */
end_comment

begin_function
name|void
name|error_not_base_type
parameter_list|(
name|basetype
parameter_list|,
name|type
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|name1
init|=
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
name|tree
name|name2
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name1
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name1
operator|=
name|DECL_NAME
argument_list|(
name|name1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name2
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name2
operator|=
name|DECL_NAME
argument_list|(
name|name2
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"type `%s' is not a base type for type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name1
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|basetype_or_else
parameter_list|(
name|parent_or_type
parameter_list|,
name|type
parameter_list|)
name|tree
name|parent_or_type
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|basetype
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent_or_type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|parent_or_type
return|;
if|if
condition|(
name|basetype
operator|=
name|get_base_type
argument_list|(
name|parent_or_type
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|basetype
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|basetype
return|;
block|}
name|error_not_base_type
argument_list|(
name|parent_or_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Print an error message stemming from an invalid use of an    aggregate type.     TYPE is the type which draws the error.    MSG is the message to print.    ARG is an optional argument which may provide more information.  */
end_comment

begin_function
name|void
name|error_with_aggr_type
parameter_list|(
name|type
parameter_list|,
name|msg
parameter_list|,
name|arg
parameter_list|)
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|arg
decl_stmt|;
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Warn or give error about storing in something that is `const'.  */
end_comment

begin_function
name|void
name|readonly_warning_or_error
parameter_list|(
name|arg
parameter_list|,
name|string
parameter_list|)
name|tree
name|arg
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" of member `%s' in read-only structure"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" of read-only member `%s'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|,
name|lang_printable_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|arg
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|arg
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" of constant field `%s'"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" of read-only variable `%s'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|,
name|lang_printable_name
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" of read-only parameter `%s'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|,
name|lang_printable_name
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" of read-only reference `%s'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|,
name|lang_printable_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"%s of read-only location"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print an error message for invalid use of a type which declares    virtual functions which are not inheritable.  */
end_comment

begin_function
name|void
name|abstract_virtuals_error
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|typename
init|=
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|u
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"cannot declare variable `%s' to be of type `%s'"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"cannot declare parameter `%s' to be of type `%s'"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"cannot declare field `%s' to be of type `%s'"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"invalid return type for function `%s'"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"cannot allocate an object of type `%s'"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
comment|/* Only go through this once.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|u
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"since the following virtual functions are abstract:"
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|u
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
while|while
condition|(
name|u
condition|)
block|{
name|error_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|u
argument_list|)
argument_list|,
literal|"%s"
argument_list|)
expr_stmt|;
name|u
operator|=
name|TREE_CHAIN
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"since type `%s' has abstract virtual functions"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message for invalid use of an incomplete type.    VALUE is the expression that was used (or 0 if that isn't known)    and TYPE is the type that was invalid.  */
end_comment

begin_function
name|void
name|incomplete_type_error
parameter_list|(
name|value
parameter_list|,
name|type
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* Avoid duplicate error message.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
name|error
argument_list|(
literal|"`%s' has an incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|retry
label|:
comment|/* We must print an error message.  Be clever about what it says.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
name|errmsg
operator|=
literal|"invalid use of undefined type `struct %s'"
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
name|errmsg
operator|=
literal|"invalid use of undefined type `union %s'"
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|errmsg
operator|=
literal|"invalid use of undefined type `enum %s'"
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|error
argument_list|(
literal|"invalid use of void expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|error
argument_list|(
literal|"invalid use of array with unspecified bounds"
argument_list|)
expr_stmt|;
return|return;
case|case
name|OFFSET_TYPE
case|:
name|error
argument_list|(
literal|"invalid use of member type (did you forget the `&' ?)"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|error_with_aggr_type
argument_list|(
name|type
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if VALUE is a valid constant-valued expression    for use in initializing a static variable; one that can be an    element of a "constant" initializer.     Return 1 if the value is absolute; return 2 if it is relocatable.    We assume that VALUE has been folded as much as possible;    therefore, we do not need to check for such things as    arithmetic-combinations of integers.  */
end_comment

begin_function
specifier|static
name|int
name|initializer_constant_valid_p
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONSTRUCTOR
case|:
return|return
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
case|case
name|ADDR_EXPR
case|:
return|return
literal|2
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
comment|/* Allow conversions between types of the same kind.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Allow (int)&foo.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|PLUS_EXPR
case|:
block|{
name|int
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|valid0
operator|==
literal|1
operator|&&
name|valid1
operator|==
literal|2
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|valid0
operator|==
literal|2
operator|&&
name|valid1
operator|==
literal|1
condition|)
return|return
literal|2
return|;
return|return
literal|0
return|;
block|}
case|case
name|MINUS_EXPR
case|:
block|{
name|int
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|valid0
operator|==
literal|2
operator|&&
name|valid1
operator|==
literal|1
condition|)
return|return
literal|2
return|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform appropriate conversions on the initial value of a variable,    store it in the declaration DECL,    and print any error messages that are appropriate.    If the init is invalid, store an ERROR_MARK.     C++: Note that INIT might be a TREE_LIST, which would mean that it is    a base class initializer for some aggregate type, hopefully compatible    with DECL.  If INIT is a single element, and DECL is an aggregate    type, we silently convert INIT into a TREE_LIST, allowing a constructor    to be called.     If INIT is a TREE_LIST and there is no constructor, turn INIT    into a CONSTRUCTOR and use standard initialization techniques.    Perhaps a warning should be generated?     Returns value of initializer if initialization could not be    performed for static variable.  In that case, caller must do    the storing.  */
end_comment

begin_function
name|tree
name|store_init_value
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
block|{
specifier|register
name|tree
name|value
decl_stmt|,
name|type
decl_stmt|;
comment|/* If variable's type was invalidly declared, just ignore it.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Take care of C++ business up here.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* implicitly tests if IS_AGGR_TYPE.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* @@ This may be wrong, but I do not know what is right.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|type
argument_list|,
literal|"constructor syntax used, but no constructor declared for type `%s'"
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|!=
name|unknown_type_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comma expression used to initialize return value"
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* Use the type of our variable to instantiate 	     the type of our initializer.  */
name|init
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* End of special C++ code.  */
comment|/* Digest the specified initializer into an expression.  */
name|value
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Store the expression if valid; else report error.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ERROR_MARK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|TREE_LITERAL
argument_list|(
name|value
argument_list|)
operator|||
operator|!
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|)
operator|)
condition|)
return|return
name|value
return|;
else|else
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_LITERAL
argument_list|(
name|value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"aggregate initializer is not constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"aggregate initializer uses complicated arithmetic"
argument_list|)
expr_stmt|;
block|}
block|}
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Digest the parser output INIT as an initializer for type TYPE.    Return a C expression of type TYPE to represent the initial value.     If TAIL is nonzero, it points to a variable holding a list of elements    of which INIT is the first.  We update the list stored there by    removing from the head all the elements that we use.    Normally this is only one; we use more than one element only if    TYPE is an aggregate and INIT is not a constructor.  */
end_comment

begin_function
name|tree
name|digest_init
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|,
name|tail
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|,
decl|*
name|tail
decl_stmt|;
end_function

begin_block
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|element
init|=
literal|0
decl_stmt|;
name|tree
name|old_tail_contents
decl_stmt|;
comment|/* Nonzero if INIT is a braced grouping, which comes in as a CONSTRUCTOR      tree node which has no TREE_TYPE.  */
name|int
name|raw_constructor
init|=
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
literal|0
decl_stmt|;
comment|/* By default, assume we use one element from a list.      We correct this later in the sole case where it is not true.  */
if|if
condition|(
name|tail
condition|)
block|{
name|old_tail_contents
operator|=
operator|*
name|tail
expr_stmt|;
operator|*
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|init
operator|&&
name|raw_constructor
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|element
operator|=
name|TREE_VALUE
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* Any type can be initialized from an expression of the same type,      optionally with braces.  */
if|if
condition|(
name|init
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|type
operator|||
operator|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|STRING_CST
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids initializing array from array expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|init
argument_list|)
condition|)
name|init
operator|=
name|decl_constant_value
argument_list|(
name|init
argument_list|)
expr_stmt|;
return|return
name|init
return|;
block|}
if|if
condition|(
name|element
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
operator|==
name|type
operator|||
operator|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|code
operator|==
name|ARRAY_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids initializing array from array expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|)
condition|)
name|warning
argument_list|(
literal|"single-expression nonscalar initializer has braces"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|element
operator|=
name|DECL_INITIAL
argument_list|(
name|element
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|element
argument_list|)
condition|)
name|element
operator|=
name|decl_constant_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
return|return
name|element
return|;
block|}
comment|/* Check for initializing a union by its first field.      Such an initializer must use braces.  */
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"union with no members cannot be initialized"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|raw_constructor
condition|)
block|{
name|error
argument_list|(
literal|"type mismatch in initialization"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|element
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"union initializer requires one element"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
block|{
comment|/* Take just the first element from within the constructor 	     and it should match the type of the first element.  */
name|element
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|element
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|build_tree_list
argument_list|(
literal|0
argument_list|,
name|element
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_LITERAL
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_LITERAL
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|result
argument_list|)
operator|=
operator|(
name|initializer_constant_valid_p
argument_list|(
name|element
argument_list|)
operator|&&
name|TREE_LITERAL
argument_list|(
name|element
argument_list|)
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/* Initialization of an array of chars from a string constant      optionally enclosed in braces.  */
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|typ1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|typ1
operator|==
name|char_type_node
operator|||
name|typ1
operator|==
name|signed_char_type_node
operator|||
name|typ1
operator|==
name|unsigned_char_type_node
operator|||
name|typ1
operator|==
name|unsigned_type_node
operator|||
name|typ1
operator|==
name|integer_type_node
operator|)
operator|&&
operator|(
operator|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|||
operator|(
name|element
operator|&&
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|)
condition|)
block|{
name|tree
name|string
init|=
name|element
condition|?
name|element
else|:
name|init
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|==
name|BITS_PER_UNIT
condition|)
block|{
name|error
argument_list|(
literal|"char-array initialized from wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|!=
name|BITS_PER_UNIT
condition|)
block|{
name|error
argument_list|(
literal|"int-array initialized from non-wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|typ1
operator|!=
name|char_type_node
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids string initializer except for `char' elements"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_LITERAL
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|int
name|size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Subtract 1 because it's ok to ignore the terminating null char 		 that is counted in the length of the constant.  */
if|if
condition|(
name|size
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|string
argument_list|)
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"initializer-string for array of chars is too long"
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
block|}
comment|/* Handle scalar types, including conversions.  */
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|||
name|code
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|raw_constructor
condition|)
block|{
if|if
condition|(
name|element
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"initializer for scalar variable requires one element"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|init
operator|=
name|element
expr_stmt|;
block|}
return|return
name|convert_for_initialization
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
literal|"initialization"
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
comment|/* Come here only for records and arrays (and unions with constructors).  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_LITERAL
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"variable-sized object may not be initialized"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
operator|||
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|raw_constructor
condition|)
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* This can only be reached when caller is initializing 	     ARRAY_TYPE.  In that case, we don't want to convert 	     INIT to TYPE.  We will let `expand_vec_init' do it.  */
return|return
name|init
return|;
block|}
elseif|else
if|if
condition|(
name|tail
operator|!=
literal|0
condition|)
block|{
operator|*
name|tail
operator|=
name|old_tail_contents
expr_stmt|;
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|tail
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|flag_traditional
condition|)
comment|/* Traditionally one can say `char x[100] = 0;'.  */
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
literal|0
argument_list|,
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|!=
name|ARRAY_TYPE
condition|)
return|return
name|convert_for_initialization
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
literal|"initialization"
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"invalid initializer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Process a constructor for a variable of type TYPE.    The constructor elements may be specified either with INIT or with ELTS,    only one of which should be non-null.     If INIT is specified, it is a CONSTRUCTOR node which is specifically    and solely for initializing this datum.     If ELTS is specified, it is the address of a variable containing    a list of expressions.  We take as many elements as we need    from the head of the list and update the list.     In the resulting constructor, TREE_LITERAL is set if all elts are    constant, and TREE_STATIC is set if, in addition, all elts are simple enough    constants that the assembler and linker can compute them.  */
end_comment

begin_function
specifier|static
name|tree
name|process_init_constructor
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|,
name|elts
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|,
decl|*
name|elts
decl_stmt|;
end_function

begin_block
block|{
specifier|extern
name|tree
name|empty_init_node
decl_stmt|;
specifier|register
name|tree
name|tail
decl_stmt|;
comment|/* List of the elements of the result constructor,      in reverse order.  */
specifier|register
name|tree
name|members
init|=
name|NULL
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|int
name|allconstant
init|=
literal|1
decl_stmt|;
name|int
name|allsimple
init|=
literal|1
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
comment|/* Make TAIL be the list of elements to use for the initialization,      no matter how the data was given to us.  */
if|if
condition|(
name|elts
condition|)
name|tail
operator|=
operator|*
name|elts
expr_stmt|;
else|else
name|tail
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* Gobble as many elements as needed, and make a constructor or initial value      for each element of this aggregate.  Chain them together in result.      If there are too few, use 0 for each scalar ultimate component.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|long
name|len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|domain
condition|)
name|len
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|len
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Take as many as there are */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|len
operator|<
literal|0
operator|||
name|i
operator|<
name|len
operator|)
operator|&&
name|tail
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|tree
name|next1
decl_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|tail1
init|=
name|tail
decl_stmt|;
name|next1
operator|=
name|digest_init
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
operator|&
name|tail1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tail1
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|tail1
argument_list|)
operator|==
name|TREE_LIST
argument_list|)
expr_stmt|;
name|tail
operator|=
name|tail1
expr_stmt|;
block|}
else|else
block|{
name|next1
operator|=
name|error_mark_node
expr_stmt|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next1
operator|==
name|error_mark_node
condition|)
name|erred
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_LITERAL
argument_list|(
name|next1
argument_list|)
condition|)
name|allconstant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|next1
argument_list|)
condition|)
name|allsimple
operator|=
literal|0
expr_stmt|;
name|members
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|next1
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|init
operator|!=
name|empty_init_node
condition|)
block|{
specifier|register
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|tail
condition|)
block|{
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"initializer list for object of class with virtual baseclasses"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
block|{
name|sorry
argument_list|(
literal|"initializer list for object of class with baseclasses"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"initializer list for object using virtual functions"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
operator|&&
name|tail
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
specifier|register
name|tree
name|next1
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|members
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|integer_zero_node
argument_list|,
name|members
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|tail1
init|=
name|tail
decl_stmt|;
name|next1
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
operator|&
name|tail1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tail1
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|tail1
argument_list|)
operator|==
name|TREE_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|global_bindings_p
argument_list|()
condition|)
name|warning_with_decl
argument_list|(
name|field
argument_list|,
literal|"initialization of static member `%s'"
argument_list|)
expr_stmt|;
name|tail
operator|=
name|tail1
expr_stmt|;
block|}
else|else
block|{
name|next1
operator|=
name|error_mark_node
expr_stmt|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next1
operator|==
name|error_mark_node
condition|)
name|erred
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_LITERAL
argument_list|(
name|next1
argument_list|)
condition|)
name|allconstant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|next1
argument_list|)
condition|)
name|allsimple
operator|=
literal|0
expr_stmt|;
name|members
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|next1
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
comment|/* Does this field have a default initializtion?  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|next1
init|=
name|DECL_INITIAL
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|next1
argument_list|)
operator|==
name|ERROR_MARK
condition|)
name|erred
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_LITERAL
argument_list|(
name|next1
argument_list|)
condition|)
name|allconstant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|next1
argument_list|)
condition|)
name|allsimple
operator|=
literal|0
expr_stmt|;
name|members
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|next1
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
condition|)
name|error
argument_list|(
literal|"uninitialized const member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"member `%s' with uninitialized const fields"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|error
argument_list|(
literal|"member `%s' is uninitialized reference"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If arguments were specified as a list, just remove the ones we used.  */
if|if
condition|(
name|elts
condition|)
operator|*
name|elts
operator|=
name|tail
expr_stmt|;
comment|/* If arguments were specified as a constructor,      complain unless we used all the elements of the constructor.  */
elseif|else
if|if
condition|(
name|tail
condition|)
name|warning
argument_list|(
literal|"excess elements in aggregate initializer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|erred
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|members
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|allconstant
condition|)
name|TREE_LITERAL
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|allconstant
operator|&&
name|allsimple
condition|)
name|TREE_STATIC
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Given a structure or union value DATUM, construct and return    the structure or union component which results from narrowing    that value by the types specified in TYPES.  For example, given the    hierarchy     class L { int ii; };    class A : L { ... };    class B : L { ... };    class C : A, B { ... };     and the declaration     C x;     then the expression     x::C::A::L::ii refers to the ii member of the L part of    of A part of the C object named by X.  In this case,    DATUM would be x, and TYPES would be a SCOPE_REF consisting of  	SCOPE_REF 		SCOPE_REF 			C	A 		L     The last entry in the SCOPE_REF is always an IDENTIFIER_NODE.  */
end_comment

begin_function
name|tree
name|build_scoped_ref
parameter_list|(
name|datum
parameter_list|,
name|types
parameter_list|)
name|tree
name|datum
decl_stmt|;
name|tree
name|types
decl_stmt|;
block|{
name|tree
name|orig_ref
decl_stmt|,
name|ref
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
decl_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|types
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
comment|/* We have some work to do.  */
struct|struct
name|type_chain
block|{
name|tree
name|type
decl_stmt|;
name|struct
name|type_chain
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|chain
init|=
literal|0
struct|,
modifier|*
name|head
init|=
literal|0
struct|;
name|orig_ref
operator|=
name|ref
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|datum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|types
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|tree
name|t
init|=
name|TREE_OPERAND
argument_list|(
name|types
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_aggr_typedef
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|head
operator|=
operator|(
expr|struct
name|type_chain
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type_chain
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|head
expr_stmt|;
name|types
operator|=
name|TREE_OPERAND
argument_list|(
name|types
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|types
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|head
operator|=
operator|(
expr|struct
name|type_chain
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type_chain
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|types
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|head
expr_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|tree
name|basetype
init|=
name|chain
operator|->
name|type
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|!=
name|type
condition|)
block|{
name|basetype
operator|=
name|get_base_type
argument_list|(
name|basetype
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|basetype
operator|==
literal|0
condition|)
block|{
name|error_not_base_type
argument_list|(
name|TYPE_NAME_STRING
argument_list|(
name|chain
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|ref
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|ref
argument_list|,
literal|"(compiler error in build_scoped_ref)"
argument_list|)
return|;
block|}
comment|/* This is an easy conversion.  */
if|if
condition|(
name|is_aggr_typedef
argument_list|(
name|types
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|types
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|basetype
operator|!=
name|type
condition|)
block|{
name|basetype
operator|=
name|get_base_type
argument_list|(
name|basetype
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|basetype
operator|==
literal|0
condition|)
block|{
name|error_not_base_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|types
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|datum
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|ref
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ref
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|ref
argument_list|,
literal|"(compiler error in build_scoped_ref)"
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Build a reference to an object specified by the C++ `->' operator.    Usually this just involves dereferencing the object, but if the    `->' operator is overloaded, then such overloads must be    performed until an object which does not have the `->' operator    overloaded is found.  An error is reported when circular pointer    delegation is detected.  */
end_comment

begin_function
name|tree
name|build_x_arrow
parameter_list|(
name|datum
parameter_list|)
name|tree
name|datum
decl_stmt|;
block|{
name|tree
name|types_memoized
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|rval
init|=
name|datum
decl_stmt|;
name|tree
name|last_rval
init|=
name|default_conversion
argument_list|(
name|datum
argument_list|)
decl_stmt|;
if|if
condition|(
name|last_rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
while|while
condition|(
name|rval
operator|=
name|build_opfncall
argument_list|(
name|COMPONENT_REF
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|rval
argument_list|)
condition|)
block|{
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|value_member
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|types_memoized
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"circular pointer delegation detected"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|types_memoized
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|types_memoized
argument_list|)
expr_stmt|;
block|}
name|last_rval
operator|=
name|rval
expr_stmt|;
block|}
name|more
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|last_rval
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|last_rval
operator|=
name|convert_from_reference
argument_list|(
name|last_rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|last_rval
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
return|return
name|build_indirect_ref
argument_list|(
name|last_rval
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|last_rval
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last_rval
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_STATIC
argument_list|(
name|TREE_OPERAND
argument_list|(
name|last_rval
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|last_rval
operator|=
name|TREE_OPERAND
argument_list|(
name|last_rval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|more
goto|;
block|}
name|compiler_error
argument_list|(
literal|"invalid member type in build_x_arrow"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|types_memoized
condition|)
name|error
argument_list|(
literal|"result of `operator->()' yields non-pointer result"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"base operand of `->' is not a pointer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Make an expression to refer to the COMPONENT field of    structure or union value DATUM.  COMPONENT is an arbitrary    expression.  DATUM has already been checked out to be of    aggregate type.     For C++, COMPONENT may be a TREE_LIST.  This happens when we must    return an object of member type to a method of the current class,    but there is not yet enough typing information to know which one.    As a special case, if there is only one method by that name,    it is returned.  Otherwise we return an expression which other    routines will have to know how to deal with later.  */
end_comment

begin_function
name|tree
name|build_m_component_ref
parameter_list|(
name|datum
parameter_list|,
name|component
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|component
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
decl_stmt|;
name|tree
name|objtype
init|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
decl_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
operator|||
name|component
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|OFFSET_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"non-member type composed with object"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|objtype
operator|=
name|TREE_TYPE
argument_list|(
name|objtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|objtype
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"member type `%s::' incompatible with object type `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|objtype
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|)
argument_list|,
name|datum
argument_list|,
name|component
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a tree node for the expression TYPENAME '(' PARMS ')'.  */
end_comment

begin_function
name|tree
name|build_functional_cast
parameter_list|(
name|exp
parameter_list|,
name|parms
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|tree
name|parms
decl_stmt|;
block|{
comment|/* This is either a call to a constructor,      or a C cast in C++'s `functional' notation.  */
name|tree
name|type
decl_stmt|,
name|name
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|parms
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|name
operator|=
name|exp
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|type
operator|=
name|lookup_name
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"`%s' fails to be a typedef or built-in type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Either an enum or an aggregate type.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|exp
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* this must build a C cast */
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"cannot cast null list to type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|build_compound_expr
argument_list|(
name|parms
argument_list|)
argument_list|)
return|;
block|}
comment|/* Call to a consructor.  If this expression      is actually used, for example, 	       return X (arg1, arg2, ...); 	       then the slot being initialized will be filled in.  */
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
block|{
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"type `%s' is not yet defined"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|rval
init|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
name|error
argument_list|(
literal|"type `%s' does not have a constructor"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Look through this type until we find the 	 base type which has a constructor.  */
do|do
block|{
name|int
name|i
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
break|break;
comment|/* Hack for MI.  */
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|index
operator|==
literal|0
condition|)
name|index
operator|=
name|i
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"multiple base classes with constructor, ambiguous"
argument_list|)
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|i
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
literal|0
condition|)
break|break;
block|}
do|while
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
do|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|}
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
block|{
name|int
name|flags
init|=
operator|(
name|parms
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
condition|?
name|LOOKUP_PROTECT
operator||
name|LOOKUP_NO_CONVERSION
else|:
name|LOOKUP_COMPLAIN
operator|)
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|try_again
label|:
name|rval
operator|=
name|build_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|error_mark_node
condition|)
block|{
name|rval
operator|=
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|rval
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
comment|/* If it didn't work going through constructor, try type conversion.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
operator|)
condition|)
block|{
name|rval
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
operator|!
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NO_CONVERSION
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_NO_CONVERSION
condition|)
block|{
name|flags
operator|=
name|LOOKUP_NORMAL
expr_stmt|;
goto|goto
name|try_again
goto|;
block|}
block|}
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform optimizations for front end.     @@ These should be moved to fold-const.c when they are working.  */
end_comment

begin_function
specifier|static
name|tree
name|make_merged_ref
parameter_list|(
name|ref
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|mode
parameter_list|,
name|volstruct
parameter_list|)
name|tree
name|ref
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|volstruct
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
decl_stmt|;
name|rtx
name|op
decl_stmt|,
name|extract_bit_field
argument_list|()
decl_stmt|,
name|change_address
argument_list|()
decl_stmt|;
comment|/* This type is probably not right, but what effect will it have?  */
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Get base reference for these fields.  */
name|op
operator|=
name|expand_expr
argument_list|(
name|ref
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|!=
name|bitsize
condition|)
block|{
name|op
operator|=
name|extract_bit_field
argument_list|(
name|op
argument_list|,
name|bitsize
operator|<<
literal|1
argument_list|,
name|bitpos
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|change_address
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|op
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
operator||=
name|volstruct
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|rval
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|rval
argument_list|)
operator|=
name|op
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Optimize COMPONENT_REFs in expressions that look like    (x.p == y.p&& x.q == y.q) or (x.p != y.p || x.q != y.q).     Also optimize (x.p == c1&& x.q == c2).     Return NULL_TREE if we could not perform the optimization,    Otherwise, return the optimized result.  */
end_comment

begin_function
name|tree
name|merge_component_comparisons
parameter_list|(
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|op0
decl_stmt|;
name|tree
name|op1
decl_stmt|;
block|{
name|tree
name|l0
decl_stmt|,
name|r0
decl_stmt|,
name|l1
decl_stmt|,
name|r1
decl_stmt|;
name|l0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|l1
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r1
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|l0
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|l1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|r0
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|r1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|l0
argument_list|)
operator|!=
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|l0
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r0
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|l1
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r1
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|l0
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
operator|(
name|TREE_LITERAL
argument_list|(
name|r0
argument_list|)
operator|&&
name|TREE_LITERAL
argument_list|(
name|r1
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|l0
argument_list|,
literal|1
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|r0
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|l1
argument_list|,
literal|1
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|r1
argument_list|,
literal|1
argument_list|)
operator|&&
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|r0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|r1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
literal|0
operator|)
operator|)
operator|&&
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|l0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|l1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|f0
init|=
name|TREE_OPERAND
argument_list|(
name|l0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|f1
init|=
name|TREE_OPERAND
argument_list|(
name|l1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|tem0
init|=
name|TREE_OPERAND
argument_list|(
name|l0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|tem1
init|=
literal|0
decl_stmt|;
name|int
name|align
decl_stmt|,
name|bitsize
decl_stmt|,
name|bitsize0
decl_stmt|,
name|bitsize1
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|bitpos0
decl_stmt|,
name|bitpos1
decl_stmt|;
name|enum
name|machine_mode
name|trymode
decl_stmt|;
name|int
name|volstruct0
init|=
literal|0
decl_stmt|,
name|volstruct1
init|=
literal|0
decl_stmt|;
name|bitsize0
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|f0
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|f0
argument_list|)
expr_stmt|;
name|bitsize1
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|f1
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|f1
argument_list|)
expr_stmt|;
comment|/* Only handles easy cases right now: 	 QImode+QImode => HImode 	 HImode+HImode => SImode.  */
if|if
condition|(
operator|(
name|bitsize0
operator|!=
name|bitsize1
operator|&&
name|TREE_CODE
argument_list|(
name|r0
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|||
name|bitsize0
operator|+
name|bitsize1
operator|>
name|BITS_PER_WORD
condition|)
return|return
literal|0
return|;
comment|/* Compute cumulative bit-offset for nested component-refs 	 and array-refs, and find the ultimate containing object.  */
if|if
condition|(
name|DECL_OFFSET
argument_list|(
name|f1
argument_list|)
operator|>
name|DECL_OFFSET
argument_list|(
name|f0
argument_list|)
condition|)
name|bitpos0
operator|=
name|DECL_OFFSET
argument_list|(
name|f0
argument_list|)
operator|,
name|bitpos1
operator|=
name|DECL_OFFSET
argument_list|(
name|f1
argument_list|)
expr_stmt|;
else|else
name|bitpos0
operator|=
name|DECL_OFFSET
argument_list|(
name|f1
argument_list|)
operator|,
name|bitpos1
operator|=
name|DECL_OFFSET
argument_list|(
name|f0
argument_list|)
expr_stmt|;
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tem1
operator|=
name|TREE_OPERAND
argument_list|(
name|r0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem1
argument_list|)
argument_list|)
operator|<
name|align
condition|)
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|tem1
argument_list|)
expr_stmt|;
block|}
name|bitpos
operator|=
name|bitpos0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem0
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|bitpos0
operator|+=
name|DECL_OFFSET
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|tem0
argument_list|)
condition|)
name|volstruct0
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem0
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|bitpos0
operator|+=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem0
argument_list|)
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
break|break;
name|tem0
operator|=
name|TREE_OPERAND
argument_list|(
name|tem0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem1
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem1
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|tem1
argument_list|)
condition|)
name|volstruct1
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem1
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
empty_stmt|;
else|else
break|break;
block|}
name|bitpos1
operator|+=
name|bitpos0
operator|-
name|bitpos
expr_stmt|;
comment|/* If these two accesses are not contiguous,  	 or they are not to the same byte, just fail.  */
if|if
condition|(
name|bitpos0
operator|+
name|bitsize0
operator|==
name|bitpos1
condition|)
comment|/* This is the size of the access we want to make.  */
name|bitsize
operator|=
name|bitsize0
operator|<<
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|bitpos0
operator|+
name|bitsize0
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
operator|)
operator|==
operator|(
operator|(
name|bitpos1
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
operator|)
condition|)
comment|/* Bits from the same byte.  */
name|bitsize
operator|=
name|bitpos1
operator|-
name|bitpos0
expr_stmt|;
else|else
comment|/* Failure.  */
return|return
literal|0
return|;
if|if
condition|(
name|align
operator|<
name|bitsize
condition|)
return|return
literal|0
return|;
comment|/* Figure out the mode we will use for this access.  */
for|for
control|(
name|trymode
operator|=
name|QImode
init|;
name|trymode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|trymode
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|<
name|bitsize
condition|;
name|trymode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|trymode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|trymode
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|>
name|align
condition|)
return|return
literal|0
return|;
name|assert
argument_list|(
operator|(
name|int
operator|)
name|trymode
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Now build tree structure which distributes TREE_CODE (op0) over CODE.  */
name|tem0
operator|=
name|make_merged_ref
argument_list|(
name|tem0
argument_list|,
name|bitsize
argument_list|,
name|bitpos0
argument_list|,
name|trymode
argument_list|,
name|volstruct0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tem1
operator|=
name|make_merged_ref
argument_list|(
name|tem1
argument_list|,
name|bitsize
argument_list|,
name|bitpos0
argument_list|,
name|trymode
argument_list|,
name|volstruct1
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|,
name|tem0
argument_list|,
name|tem1
argument_list|)
return|;
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|r0
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|r1
argument_list|)
condition|)
name|tem1
operator|=
name|integer_zero_node
expr_stmt|;
else|else
name|tem1
operator|=
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|r0
argument_list|)
operator||
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|r1
argument_list|)
operator|<<
operator|(
name|bitpos1
operator|-
name|bitpos0
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos0
operator|+
name|bitsize0
operator|==
name|bitpos1
condition|)
return|return
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|,
name|tem0
argument_list|,
name|tem1
argument_list|)
return|;
comment|/* Test this quantity against a mask.  */
return|return
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type_node
argument_list|,
name|tem0
argument_list|,
name|tem1
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the character string for the name that encodes the    enumeral value VALUE in the domain TYPE.  */
end_comment

begin_function
name|char
modifier|*
name|enum_name_string
parameter_list|(
name|value
parameter_list|,
name|type
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|tree
name|values
init|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|intval
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
while|while
condition|(
name|values
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|)
operator|!=
name|intval
condition|)
name|values
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|==
name|NULL_TREE
condition|)
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|16
operator|+
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Value must have been cast.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(enum %s)%d"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|,
name|intval
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|values
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print out a language-specific error message for    (Pascal) case or (C) switch statements.    CODE tells what sort of message to print.     TYPE is the type of the switch index expression.    NEW is the new value that we were trying to add.    OLD is the old value that stopped us from adding it.  */
end_comment

begin_function
name|void
name|report_case_error
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|new_value
parameter_list|,
name|old_value
parameter_list|)
name|int
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|new_value
decl_stmt|,
name|old_value
decl_stmt|;
block|{
if|if
condition|(
name|code
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|new_value
condition|)
name|error
argument_list|(
literal|"case label not within a switch statement"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"default label not within a switch statement"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|new_value
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"multiple default labels in one switch"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_value
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_value
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|4
operator|*
operator|(
literal|8
operator|+
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"overlapping ranges [%s..%s], [%s..%s] in case expression"
argument_list|,
name|enum_name_string
argument_list|(
name|TREE_OPERAND
argument_list|(
name|new_value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|,
name|enum_name_string
argument_list|(
name|TREE_OPERAND
argument_list|(
name|new_value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|,
name|enum_name_string
argument_list|(
name|TREE_OPERAND
argument_list|(
name|old_value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|,
name|enum_name_string
argument_list|(
name|TREE_OPERAND
argument_list|(
name|old_value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"overlapping ranges [%d..%d], [%d..%d] in case expression"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|new_value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|new_value
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|old_value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|old_value
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|4
operator|*
operator|(
literal|8
operator|+
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"range [%s..%s] includes element `%s' in case expression"
argument_list|,
name|enum_name_string
argument_list|(
name|TREE_OPERAND
argument_list|(
name|new_value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|,
name|enum_name_string
argument_list|(
name|TREE_OPERAND
argument_list|(
name|new_value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|,
name|enum_name_string
argument_list|(
name|old_value
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"range [%d..%d] includes (%d) in case expression"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|new_value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|new_value
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|old_value
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_value
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|4
operator|*
operator|(
literal|8
operator|+
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"range [%s..%s] includes element `%s' in case expression"
argument_list|,
name|enum_name_string
argument_list|(
name|TREE_OPERAND
argument_list|(
name|old_value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|,
name|enum_name_string
argument_list|(
name|TREE_OPERAND
argument_list|(
name|old_value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|,
name|enum_name_string
argument_list|(
name|new_value
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"range [%d..%d] includes (%d) in case expression"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|old_value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|old_value
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|new_value
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|error
argument_list|(
literal|"duplicate label `%s' in switch statement"
argument_list|,
name|enum_name_string
argument_list|(
name|new_value
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"duplicate label (%d) in switch statement"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|new_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|warning
argument_list|(
literal|"case value out of range for enum %s"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"case value out of range"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|error
argument_list|(
literal|"range values `%s' and `%s' reversed"
argument_list|,
name|enum_name_string
argument_list|(
name|new_value
argument_list|,
name|type
argument_list|)
argument_list|,
name|enum_name_string
argument_list|(
name|old_value
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"range values reversed"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

