begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)graph.c	4.2 3/30/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_define
define|#
directive|define
name|INF
value|HUGE
end_define

begin_define
define|#
directive|define
name|F
value|.25
end_define

begin_struct
struct|struct
name|xy
block|{
name|int
name|xlbf
decl_stmt|;
comment|/*flag:explicit lower bound*/
name|int
name|xubf
decl_stmt|;
comment|/*flag:explicit upper bound*/
name|int
name|xqf
decl_stmt|;
comment|/*flag:explicit quantum*/
name|double
function_decl|(
modifier|*
name|xf
function_decl|)
parameter_list|()
function_decl|;
comment|/*transform function, e.g. log*/
name|float
name|xa
decl_stmt|,
name|xb
decl_stmt|;
comment|/*scaling coefficients*/
name|float
name|xlb
decl_stmt|,
name|xub
decl_stmt|;
comment|/*lower and upper bound*/
name|float
name|xquant
decl_stmt|;
comment|/*quantum*/
name|float
name|xoff
decl_stmt|;
comment|/*screen offset fraction*/
name|float
name|xsize
decl_stmt|;
comment|/*screen fraction*/
name|int
name|xbot
decl_stmt|,
name|xtop
decl_stmt|;
comment|/*screen coords of border*/
name|float
name|xmult
decl_stmt|;
comment|/*scaling constant*/
block|}
name|xd
struct|,
name|yd
struct|;
end_struct

begin_struct
struct|struct
name|val
block|{
name|float
name|xv
decl_stmt|;
name|float
name|yv
decl_stmt|;
name|int
name|lblptr
decl_stmt|;
block|}
modifier|*
name|xx
struct|;
end_struct

begin_decl_stmt
name|char
modifier|*
name|labs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|labsiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tick
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|top
init|=
literal|4000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bot
init|=
literal|200
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|absbot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|erasf
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gridf
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symbf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|absf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|transf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|brkf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|dx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|plotsymb
decl_stmt|;
end_decl_stmt

begin_function_decl
name|double
name|atof
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BSIZ
value|80
end_define

begin_decl_stmt
name|char
name|labbuf
index|[
name|BSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|titlebuf
index|[
name|BSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|modes
index|[]
init|=
block|{
literal|"disconnected"
block|,
literal|"solid"
block|,
literal|"dotted"
block|,
literal|"dotdashed"
block|,
literal|"shortdashed"
block|,
literal|"longdashed"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mode
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|double
name|ident
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|space
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|4096
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|init
argument_list|(
operator|&
name|xd
argument_list|)
expr_stmt|;
name|init
argument_list|(
operator|&
name|yd
argument_list|)
expr_stmt|;
name|xd
operator|.
name|xsize
operator|=
name|yd
operator|.
name|xsize
operator|=
literal|1.
expr_stmt|;
name|xx
operator|=
operator|(
expr|struct
name|val
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|labs
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|labs
index|[
name|labsiz
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|setopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|erasf
condition|)
name|erase
argument_list|()
expr_stmt|;
name|readin
argument_list|()
expr_stmt|;
name|transpose
argument_list|()
expr_stmt|;
name|scale
argument_list|(
operator|&
name|xd
argument_list|,
operator|(
expr|struct
name|val
operator|*
operator|)
operator|&
name|xx
operator|->
name|xv
argument_list|)
expr_stmt|;
name|scale
argument_list|(
operator|&
name|yd
argument_list|,
operator|(
expr|struct
name|val
operator|*
operator|)
operator|&
name|xx
operator|->
name|yv
argument_list|)
expr_stmt|;
name|axes
argument_list|()
expr_stmt|;
name|title
argument_list|()
expr_stmt|;
name|plot
argument_list|()
expr_stmt|;
name|move
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|closevt
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|init
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|xy
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p
operator|->
name|xf
operator|=
name|ident
expr_stmt|;
name|p
operator|->
name|xmult
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|setopt
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|float
name|temp
decl_stmt|;
name|xd
operator|.
name|xlb
operator|=
name|yd
operator|.
name|xlb
operator|=
name|INF
expr_stmt|;
name|xd
operator|.
name|xub
operator|=
name|yd
operator|.
name|xub
operator|=
operator|-
name|INF
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|again
label|:
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'-'
case|:
name|argv
index|[
literal|0
index|]
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
case|case
literal|'l'
case|:
comment|/* label for plot */
name|p1
operator|=
name|titlebuf
expr_stmt|;
if|if
condition|(
name|argc
operator|>=
literal|2
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|p2
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|++
operator|=
operator|*
name|p2
operator|++
condition|)
empty_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
comment|/*disconnected,obsolete option*/
case|case
literal|'m'
case|:
comment|/*line mode*/
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
break|break;
if|if
condition|(
name|temp
operator|>=
sizeof|sizeof
argument_list|(
name|modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|modes
argument_list|)
condition|)
name|mode
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|>=
literal|0
condition|)
name|mode
operator|=
name|temp
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/*automatic abscissas*/
name|absf
operator|=
literal|1
expr_stmt|;
name|dx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|dx
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
break|break;
if|if
condition|(
name|numb
argument_list|(
operator|&
name|absbot
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
name|absf
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/*save screen, overlay plot*/
name|erasf
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/*grid style 0 none, 1 ticks, 2 full*/
name|gridf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
name|temp
operator|=
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
comment|/*for caompatibility*/
if|if
condition|(
name|temp
operator|>=
literal|0
operator|&&
name|temp
operator|<=
literal|2
condition|)
name|gridf
operator|=
name|temp
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/*character(s) for plotting*/
if|if
condition|(
name|argc
operator|>=
literal|2
condition|)
block|{
name|symbf
operator|=
literal|1
expr_stmt|;
name|plotsymb
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
comment|/*transpose*/
name|transf
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/*breaks*/
name|brkf
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/*x limits */
name|limread
argument_list|(
operator|&
name|xd
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|limread
argument_list|(
operator|&
name|yd
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/*set height of plot */
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|yd
operator|.
name|xsize
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
name|badarg
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/*set width of plot */
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|xd
operator|.
name|xsize
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
name|badarg
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* set offset to right */
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|xd
operator|.
name|xoff
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
name|badarg
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/*set offset up the screen*/
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|yd
operator|.
name|xoff
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
name|badarg
argument_list|()
expr_stmt|;
break|break;
default|default:
name|badarg
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|limread
argument_list|(
name|p
argument_list|,
name|argcp
argument_list|,
name|argvp
argument_list|)
specifier|register
expr|struct
name|xy
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|argcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|argcp
operator|>
literal|1
operator|&&
operator|(
operator|*
name|argvp
operator|)
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'l'
condition|)
block|{
operator|(
operator|*
name|argcp
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
name|argvp
operator|)
operator|++
expr_stmt|;
name|p
operator|->
name|xf
operator|=
name|log10
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|p
operator|->
name|xlb
argument_list|,
name|argcp
argument_list|,
name|argvp
argument_list|)
condition|)
return|return;
name|p
operator|->
name|xlbf
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|p
operator|->
name|xub
argument_list|,
name|argcp
argument_list|,
name|argvp
argument_list|)
condition|)
return|return;
name|p
operator|->
name|xubf
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|p
operator|->
name|xquant
argument_list|,
name|argcp
argument_list|,
name|argvp
argument_list|)
condition|)
return|return;
name|p
operator|->
name|xqf
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|numb
argument_list|(
argument|np
argument_list|,
argument|argcp
argument_list|,
argument|argvp
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|argcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|argcp
operator|<=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
name|argvp
operator|)
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|)
operator|==
literal|'+'
condition|)
operator|(
operator|*
name|argvp
operator|)
index|[
literal|1
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|&&
operator|(
operator|*
name|argvp
operator|)
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|<
literal|'A'
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|np
operator|=
name|atof
argument_list|(
operator|(
operator|*
name|argvp
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|argcp
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
name|argvp
operator|)
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|readin
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|t
expr_stmt|;
name|struct
name|val
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|absf
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|xd
operator|.
name|xlbf
condition|)
name|absbot
operator|=
name|xd
operator|.
name|xlb
expr_stmt|;
elseif|else
if|if
condition|(
name|xd
operator|.
name|xf
operator|==
name|log10
condition|)
name|absbot
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|temp
operator|=
operator|(
expr|struct
name|val
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|xx
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|n
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
return|return;
name|xx
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|absf
condition|)
name|xx
index|[
name|n
index|]
operator|.
name|xv
operator|=
name|n
operator|*
name|dx
operator|+
name|absbot
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|getfloat
argument_list|(
operator|&
name|xx
index|[
name|n
index|]
operator|.
name|xv
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|getfloat
argument_list|(
operator|&
name|xx
index|[
name|n
index|]
operator|.
name|yv
argument_list|)
condition|)
return|return;
name|xx
index|[
name|n
index|]
operator|.
name|lblptr
operator|=
operator|-
literal|1
expr_stmt|;
name|t
operator|=
name|getstring
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|0
condition|)
name|xx
index|[
name|n
index|]
operator|.
name|lblptr
operator|=
name|copystring
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
return|return;
block|}
block|}
end_block

begin_macro
name|transpose
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|float
name|f
decl_stmt|;
name|struct
name|xy
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|transf
condition|)
return|return;
name|t
operator|=
name|xd
expr_stmt|;
name|xd
operator|=
name|yd
expr_stmt|;
name|yd
operator|=
name|t
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|xx
index|[
name|i
index|]
operator|.
name|xv
expr_stmt|;
name|xx
index|[
name|i
index|]
operator|.
name|xv
operator|=
name|xx
index|[
name|i
index|]
operator|.
name|yv
expr_stmt|;
name|xx
index|[
name|i
index|]
operator|.
name|yv
operator|=
name|f
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|copystring
argument_list|(
argument|k
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|q
decl_stmt|;
name|temp
operator|=
name|realloc
argument_list|(
name|labs
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|labsiz
operator|+
literal|1
operator|+
name|k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|labs
operator|=
name|temp
expr_stmt|;
name|q
operator|=
name|labsiz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|k
condition|;
name|i
operator|++
control|)
name|labs
index|[
name|labsiz
operator|++
index|]
operator|=
name|labbuf
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_block

begin_function
name|float
name|modceil
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
name|float
name|f
decl_stmt|,
name|t
decl_stmt|;
block|{
name|t
operator|=
name|fabs
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ceil
argument_list|(
name|f
operator|/
name|t
argument_list|)
operator|*
name|t
operator|)
return|;
block|}
end_function

begin_function
name|float
name|modfloor
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
name|float
name|f
decl_stmt|,
name|t
decl_stmt|;
block|{
name|t
operator|=
name|fabs
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|floor
argument_list|(
name|f
operator|/
name|t
argument_list|)
operator|*
name|t
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|getlim
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
specifier|register
expr|struct
name|xy
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|val
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|xlbf
operator|&&
name|p
operator|->
name|xlb
operator|>
name|v
index|[
name|i
index|]
operator|.
name|xv
condition|)
name|p
operator|->
name|xlb
operator|=
name|v
index|[
name|i
index|]
operator|.
name|xv
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|xubf
operator|&&
name|p
operator|->
name|xub
operator|<
name|v
index|[
name|i
index|]
operator|.
name|xv
condition|)
name|p
operator|->
name|xub
operator|=
name|v
index|[
name|i
index|]
operator|.
name|xv
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|n
condition|)
do|;
block|}
end_block

begin_struct
struct|struct
name|z
block|{
name|float
name|lb
decl_stmt|,
name|ub
decl_stmt|,
name|mult
decl_stmt|,
name|quant
decl_stmt|;
block|}
name|setloglim
argument_list|()
struct|,
name|setlinlim
argument_list|()
struct|;
end_struct

begin_expr_stmt
name|setlim
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|xy
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|float
name|t
decl_stmt|,
name|delta
decl_stmt|,
name|sign
decl_stmt|;
name|struct
name|z
name|z
decl_stmt|;
name|int
name|mark
index|[
literal|50
index|]
decl_stmt|;
name|float
name|lb
decl_stmt|,
name|ub
decl_stmt|;
name|int
name|lbf
decl_stmt|,
name|ubf
decl_stmt|;
name|lb
operator|=
name|p
operator|->
name|xlb
expr_stmt|;
name|ub
operator|=
name|p
operator|->
name|xub
expr_stmt|;
name|delta
operator|=
name|ub
operator|-
name|lb
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|xqf
condition|)
block|{
if|if
condition|(
name|delta
operator|*
name|p
operator|->
name|xquant
operator|<=
literal|0
condition|)
name|badarg
argument_list|()
expr_stmt|;
return|return;
block|}
name|sign
operator|=
literal|1
expr_stmt|;
name|lbf
operator|=
name|p
operator|->
name|xlbf
expr_stmt|;
name|ubf
operator|=
name|p
operator|->
name|xubf
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|t
operator|=
name|lb
expr_stmt|;
name|lb
operator|=
name|ub
expr_stmt|;
name|ub
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|lbf
expr_stmt|;
name|lbf
operator|=
name|ubf
expr_stmt|;
name|ubf
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ub
operator|>
literal|0
condition|)
block|{
name|ub
operator|=
literal|2
operator|*
name|ub
expr_stmt|;
name|lb
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lb
operator|<
literal|0
condition|)
block|{
name|lb
operator|=
literal|2
operator|*
name|lb
expr_stmt|;
name|ub
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ub
operator|=
literal|1
expr_stmt|;
name|lb
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|xf
operator|==
name|log10
operator|&&
name|lb
operator|>
literal|0
operator|&&
name|ub
operator|>
name|lb
condition|)
block|{
name|z
operator|=
name|setloglim
argument_list|(
name|lbf
argument_list|,
name|ubf
argument_list|,
name|lb
argument_list|,
name|ub
argument_list|)
expr_stmt|;
name|p
operator|->
name|xlb
operator|=
name|z
operator|.
name|lb
expr_stmt|;
name|p
operator|->
name|xub
operator|=
name|z
operator|.
name|ub
expr_stmt|;
name|p
operator|->
name|xmult
operator|*=
name|z
operator|.
name|mult
expr_stmt|;
name|p
operator|->
name|xquant
operator|=
name|z
operator|.
name|quant
expr_stmt|;
if|if
condition|(
name|setmark
argument_list|(
name|mark
argument_list|,
name|p
argument_list|)
operator|<
literal|2
condition|)
block|{
name|p
operator|->
name|xqf
operator|=
name|lbf
operator|=
name|ubf
operator|=
literal|1
expr_stmt|;
name|lb
operator|=
name|z
operator|.
name|lb
expr_stmt|;
name|ub
operator|=
name|z
operator|.
name|ub
expr_stmt|;
block|}
else|else
return|return;
block|}
name|z
operator|=
name|setlinlim
argument_list|(
name|lbf
argument_list|,
name|ubf
argument_list|,
name|lb
argument_list|,
name|ub
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
operator|>
literal|0
condition|)
block|{
name|p
operator|->
name|xlb
operator|=
name|z
operator|.
name|lb
expr_stmt|;
name|p
operator|->
name|xub
operator|=
name|z
operator|.
name|ub
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|xlb
operator|=
name|z
operator|.
name|ub
expr_stmt|;
name|p
operator|->
name|xub
operator|=
name|z
operator|.
name|lb
expr_stmt|;
block|}
name|p
operator|->
name|xmult
operator|*=
name|z
operator|.
name|mult
expr_stmt|;
name|p
operator|->
name|xquant
operator|=
name|sign
operator|*
name|z
operator|.
name|quant
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|z
name|setloglim
parameter_list|(
name|lbf
parameter_list|,
name|ubf
parameter_list|,
name|lb
parameter_list|,
name|ub
parameter_list|)
name|float
name|lb
decl_stmt|,
name|ub
decl_stmt|;
block|{
name|float
name|r
decl_stmt|,
name|s
decl_stmt|,
name|t
decl_stmt|;
name|struct
name|z
name|z
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|1
init|;
name|lb
operator|*
name|s
operator|<
literal|1
condition|;
name|s
operator|*=
literal|10
control|)
empty_stmt|;
name|lb
operator|*=
name|s
expr_stmt|;
name|ub
operator|*=
name|s
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|1
init|;
literal|10
operator|*
name|r
operator|<=
name|lb
condition|;
name|r
operator|*=
literal|10
control|)
empty_stmt|;
for|for
control|(
name|t
operator|=
literal|1
init|;
name|t
operator|<
name|ub
condition|;
name|t
operator|*=
literal|10
control|)
empty_stmt|;
name|z
operator|.
name|lb
operator|=
operator|!
name|lbf
condition|?
name|r
else|:
name|lb
expr_stmt|;
name|z
operator|.
name|ub
operator|=
operator|!
name|ubf
condition|?
name|t
else|:
name|ub
expr_stmt|;
if|if
condition|(
name|ub
operator|/
name|lb
operator|<
literal|100
condition|)
block|{
if|if
condition|(
operator|!
name|lbf
condition|)
block|{
if|if
condition|(
name|lb
operator|>=
literal|5
operator|*
name|z
operator|.
name|lb
condition|)
name|z
operator|.
name|lb
operator|*=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|lb
operator|>=
literal|2
operator|*
name|z
operator|.
name|lb
condition|)
name|z
operator|.
name|lb
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ubf
condition|)
block|{
if|if
condition|(
name|ub
operator|*
literal|5
operator|<=
name|z
operator|.
name|ub
condition|)
name|z
operator|.
name|ub
operator|/=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|ub
operator|*
literal|2
operator|<=
name|z
operator|.
name|ub
condition|)
name|z
operator|.
name|ub
operator|/=
literal|2
expr_stmt|;
block|}
block|}
name|z
operator|.
name|mult
operator|=
name|s
expr_stmt|;
name|z
operator|.
name|quant
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|z
name|setlinlim
parameter_list|(
name|lbf
parameter_list|,
name|ubf
parameter_list|,
name|xlb
parameter_list|,
name|xub
parameter_list|)
name|int
name|lbf
decl_stmt|,
name|ubf
decl_stmt|;
name|float
name|xlb
decl_stmt|,
name|xub
decl_stmt|;
block|{
name|struct
name|z
name|z
decl_stmt|;
name|float
name|r
decl_stmt|,
name|s
decl_stmt|,
name|delta
decl_stmt|;
name|float
name|ub
decl_stmt|,
name|lb
decl_stmt|;
name|loop
label|:
name|ub
operator|=
name|xub
expr_stmt|;
name|lb
operator|=
name|xlb
expr_stmt|;
name|delta
operator|=
name|ub
operator|-
name|lb
expr_stmt|;
comment|/*scale up by s, a power of 10, so range (delta) exceeds 1*/
comment|/*find power of 10 quantum, r, such that delta/10<=r<delta*/
name|r
operator|=
name|s
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|delta
operator|*
name|s
operator|<
literal|10
condition|)
name|s
operator|*=
literal|10
expr_stmt|;
name|delta
operator|*=
name|s
expr_stmt|;
while|while
condition|(
literal|10
operator|*
name|r
operator|<
name|delta
condition|)
name|r
operator|*=
literal|10
expr_stmt|;
name|lb
operator|*=
name|s
expr_stmt|;
name|ub
operator|*=
name|s
expr_stmt|;
comment|/*set r=(1,2,5)*10**n so that 3-5 quanta cover range*/
if|if
condition|(
name|r
operator|>=
name|delta
operator|/
literal|2
condition|)
name|r
operator|/=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|<
name|delta
operator|/
literal|5
condition|)
name|r
operator|*=
literal|2
expr_stmt|;
name|z
operator|.
name|ub
operator|=
name|ubf
condition|?
name|ub
else|:
name|modceil
argument_list|(
name|ub
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|z
operator|.
name|lb
operator|=
name|lbf
condition|?
name|lb
else|:
name|modfloor
argument_list|(
name|lb
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lbf
operator|&&
name|z
operator|.
name|lb
operator|<=
name|r
operator|&&
name|z
operator|.
name|lb
operator|>
literal|0
condition|)
block|{
name|xlb
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ubf
operator|&&
name|z
operator|.
name|ub
operator|>=
operator|-
name|r
operator|&&
name|z
operator|.
name|ub
operator|<
literal|0
condition|)
block|{
name|xub
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|z
operator|.
name|quant
operator|=
name|r
expr_stmt|;
name|z
operator|.
name|mult
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|scale
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
specifier|register
expr|struct
name|xy
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|val
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|float
name|edge
decl_stmt|;
name|getlim
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|setlim
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|edge
operator|=
name|top
operator|-
name|bot
expr_stmt|;
name|p
operator|->
name|xa
operator|=
name|p
operator|->
name|xsize
operator|*
name|edge
operator|/
operator|(
call|(
modifier|*
name|p
operator|->
name|xf
call|)
argument_list|(
name|p
operator|->
name|xub
argument_list|)
operator|-
call|(
modifier|*
name|p
operator|->
name|xf
call|)
argument_list|(
name|p
operator|->
name|xlb
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|xbot
operator|=
name|bot
operator|+
name|edge
operator|*
name|p
operator|->
name|xoff
expr_stmt|;
name|p
operator|->
name|xtop
operator|=
name|p
operator|->
name|xbot
operator|+
operator|(
name|top
operator|-
name|bot
operator|)
operator|*
name|p
operator|->
name|xsize
expr_stmt|;
name|p
operator|->
name|xb
operator|=
name|p
operator|->
name|xbot
operator|-
call|(
modifier|*
name|p
operator|->
name|xf
call|)
argument_list|(
name|p
operator|->
name|xlb
argument_list|)
operator|*
name|p
operator|->
name|xa
operator|+
literal|.5
expr_stmt|;
block|}
end_block

begin_macro
name|axes
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|int
name|mark
index|[
literal|50
index|]
decl_stmt|;
name|int
name|xn
decl_stmt|,
name|yn
decl_stmt|;
if|if
condition|(
name|gridf
operator|==
literal|0
condition|)
return|return;
name|line
argument_list|(
name|xd
operator|.
name|xbot
argument_list|,
name|yd
operator|.
name|xbot
argument_list|,
name|xd
operator|.
name|xtop
argument_list|,
name|yd
operator|.
name|xbot
argument_list|)
expr_stmt|;
name|cont
argument_list|(
name|xd
operator|.
name|xtop
argument_list|,
name|yd
operator|.
name|xtop
argument_list|)
expr_stmt|;
name|cont
argument_list|(
name|xd
operator|.
name|xbot
argument_list|,
name|yd
operator|.
name|xtop
argument_list|)
expr_stmt|;
name|cont
argument_list|(
name|xd
operator|.
name|xbot
argument_list|,
name|yd
operator|.
name|xbot
argument_list|)
expr_stmt|;
name|xn
operator|=
name|setmark
argument_list|(
name|mark
argument_list|,
operator|&
name|xd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xn
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gridf
operator|==
literal|2
condition|)
name|line
argument_list|(
name|mark
index|[
name|i
index|]
argument_list|,
name|yd
operator|.
name|xbot
argument_list|,
name|mark
index|[
name|i
index|]
argument_list|,
name|yd
operator|.
name|xtop
argument_list|)
expr_stmt|;
if|if
condition|(
name|gridf
operator|==
literal|1
condition|)
block|{
name|line
argument_list|(
name|mark
index|[
name|i
index|]
argument_list|,
name|yd
operator|.
name|xbot
argument_list|,
name|mark
index|[
name|i
index|]
argument_list|,
name|yd
operator|.
name|xbot
operator|+
name|tick
argument_list|)
expr_stmt|;
name|line
argument_list|(
name|mark
index|[
name|i
index|]
argument_list|,
name|yd
operator|.
name|xtop
operator|-
name|tick
argument_list|,
name|mark
index|[
name|i
index|]
argument_list|,
name|yd
operator|.
name|xtop
argument_list|)
expr_stmt|;
block|}
block|}
name|yn
operator|=
name|setmark
argument_list|(
name|mark
argument_list|,
operator|&
name|yd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|yn
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gridf
operator|==
literal|2
condition|)
name|line
argument_list|(
name|xd
operator|.
name|xbot
argument_list|,
name|mark
index|[
name|i
index|]
argument_list|,
name|xd
operator|.
name|xtop
argument_list|,
name|mark
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gridf
operator|==
literal|1
condition|)
block|{
name|line
argument_list|(
name|xd
operator|.
name|xbot
argument_list|,
name|mark
index|[
name|i
index|]
argument_list|,
name|xd
operator|.
name|xbot
operator|+
name|tick
argument_list|,
name|mark
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|line
argument_list|(
name|xd
operator|.
name|xtop
operator|-
name|tick
argument_list|,
name|mark
index|[
name|i
index|]
argument_list|,
name|xd
operator|.
name|xtop
argument_list|,
name|mark
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|setmark
argument_list|(
argument|xmark
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|xmark
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|xy
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|xn
init|=
literal|0
decl_stmt|;
name|float
name|x
decl_stmt|,
name|xl
decl_stmt|,
name|xu
decl_stmt|;
name|float
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|xf
operator|==
name|log10
operator|&&
operator|!
name|p
operator|->
name|xqf
condition|)
block|{
for|for
control|(
name|x
operator|=
name|p
operator|->
name|xquant
init|;
name|x
operator|<
name|p
operator|->
name|xub
condition|;
name|x
operator|*=
literal|10
control|)
block|{
name|submark
argument_list|(
name|xmark
argument_list|,
operator|&
name|xn
argument_list|,
name|x
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|xub
operator|/
name|p
operator|->
name|xlb
operator|<=
literal|100
condition|)
block|{
name|submark
argument_list|(
name|xmark
argument_list|,
operator|&
name|xn
argument_list|,
literal|2
operator|*
name|x
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|submark
argument_list|(
name|xmark
argument_list|,
operator|&
name|xn
argument_list|,
literal|5
operator|*
name|x
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|xn
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|xquant
expr_stmt|;
if|if
condition|(
name|q
operator|>
literal|0
condition|)
block|{
name|xl
operator|=
name|modceil
argument_list|(
name|p
operator|->
name|xlb
operator|+
name|q
operator|/
literal|6
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|xu
operator|=
name|modfloor
argument_list|(
name|p
operator|->
name|xub
operator|-
name|q
operator|/
literal|6
argument_list|,
name|q
argument_list|)
operator|+
name|q
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|xl
operator|=
name|modceil
argument_list|(
name|p
operator|->
name|xub
operator|-
name|q
operator|/
literal|6
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|xu
operator|=
name|modfloor
argument_list|(
name|p
operator|->
name|xlb
operator|+
name|q
operator|/
literal|6
argument_list|,
name|q
argument_list|)
operator|-
name|q
operator|/
literal|2
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
name|xl
init|;
name|x
operator|<=
name|xu
condition|;
name|x
operator|+=
name|fabs
argument_list|(
name|p
operator|->
name|xquant
argument_list|)
control|)
name|xmark
index|[
name|xn
operator|++
index|]
operator|=
call|(
modifier|*
name|p
operator|->
name|xf
call|)
argument_list|(
name|x
argument_list|)
operator|*
name|p
operator|->
name|xa
operator|+
name|p
operator|->
name|xb
expr_stmt|;
block|}
return|return
operator|(
name|xn
operator|)
return|;
block|}
end_block

begin_macro
name|submark
argument_list|(
argument|xmark
argument_list|,
argument|pxn
argument_list|,
argument|x
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|xmark
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pxn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|xy
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
literal|1.001
operator|*
name|p
operator|->
name|xlb
operator|<
name|x
operator|&&
literal|.999
operator|*
name|p
operator|->
name|xub
operator|>
name|x
condition|)
name|xmark
index|[
operator|(
operator|*
name|pxn
operator|)
operator|++
index|]
operator|=
name|log10
argument_list|(
name|x
argument_list|)
operator|*
name|p
operator|->
name|xa
operator|+
name|p
operator|->
name|xb
expr_stmt|;
block|}
end_block

begin_macro
name|plot
argument_list|()
end_macro

begin_block
block|{
name|int
name|ix
decl_stmt|,
name|iy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|conn
decl_stmt|;
name|conn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|0
condition|)
name|linemod
argument_list|(
name|modes
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|conv
argument_list|(
name|xx
index|[
name|i
index|]
operator|.
name|xv
argument_list|,
operator|&
name|xd
argument_list|,
operator|&
name|ix
argument_list|)
operator|||
operator|!
name|conv
argument_list|(
name|xx
index|[
name|i
index|]
operator|.
name|yv
argument_list|,
operator|&
name|yd
argument_list|,
operator|&
name|iy
argument_list|)
condition|)
block|{
name|conn
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|conn
operator|!=
literal|0
condition|)
name|cont
argument_list|(
name|ix
argument_list|,
name|iy
argument_list|)
expr_stmt|;
else|else
name|move
argument_list|(
name|ix
argument_list|,
name|iy
argument_list|)
expr_stmt|;
name|conn
operator|=
literal|1
expr_stmt|;
block|}
name|conn
operator|&=
name|symbol
argument_list|(
name|ix
argument_list|,
name|iy
argument_list|,
name|xx
index|[
name|i
index|]
operator|.
name|lblptr
argument_list|)
expr_stmt|;
block|}
name|linemod
argument_list|(
name|modes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|conv
argument_list|(
argument|xv
argument_list|,
argument|p
argument_list|,
argument|ip
argument_list|)
end_macro

begin_decl_stmt
name|float
name|xv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|xy
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|ix
decl_stmt|;
name|ix
operator|=
name|p
operator|->
name|xa
operator|*
call|(
modifier|*
name|p
operator|->
name|xf
call|)
argument_list|(
name|xv
operator|*
name|p
operator|->
name|xmult
argument_list|)
operator|+
name|p
operator|->
name|xb
expr_stmt|;
if|if
condition|(
name|ix
operator|<
name|p
operator|->
name|xbot
operator|||
name|ix
operator|>
name|p
operator|->
name|xtop
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|ip
operator|=
name|ix
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|getfloat
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|float
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|i
operator|=
name|scanf
argument_list|(
literal|"%f"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|==
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|getstring
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|char
name|junk
index|[
literal|20
index|]
decl_stmt|;
name|i
operator|=
name|scanf
argument_list|(
literal|"%1s"
argument_list|,
name|labbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
operator|*
name|labbuf
condition|)
block|{
default|default:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|labbuf
argument_list|)
condition|)
block|{
name|ungetc
argument_list|(
operator|*
name|labbuf
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|i
operator|=
name|scanf
argument_list|(
literal|"%s"
argument_list|,
name|labbuf
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'.'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
name|ungetc
argument_list|(
operator|*
name|labbuf
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'"'
case|:
name|i
operator|=
name|scanf
argument_list|(
literal|"%[^\"\n]"
argument_list|,
name|labbuf
argument_list|)
expr_stmt|;
name|scanf
argument_list|(
literal|"%[\"]"
argument_list|,
name|junk
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|strlen
argument_list|(
name|labbuf
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|symbol
argument_list|(
argument|ix
argument_list|,
argument|iy
argument_list|,
argument|k
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|symbf
operator|==
literal|0
operator|&&
name|k
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|point
argument_list|(
name|ix
argument_list|,
name|iy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|move
argument_list|(
name|ix
argument_list|,
name|iy
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|k
operator|>=
literal|0
condition|?
name|labs
operator|+
name|k
else|:
name|plotsymb
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|ix
argument_list|,
name|iy
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|brkf
operator||
name|k
operator|<
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|title
argument_list|()
end_macro

begin_block
block|{
name|move
argument_list|(
name|xd
operator|.
name|xbot
argument_list|,
name|yd
operator|.
name|xbot
operator|-
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
name|titlebuf
index|[
literal|0
index|]
condition|)
block|{
name|label
argument_list|(
name|titlebuf
argument_list|)
expr_stmt|;
name|label
argument_list|(
literal|"       "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|erasf
operator|&&
name|gridf
condition|)
block|{
name|axlab
argument_list|(
literal|'x'
argument_list|,
operator|&
name|xd
argument_list|)
expr_stmt|;
name|label
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|axlab
argument_list|(
literal|'y'
argument_list|,
operator|&
name|yd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|axlab
argument_list|(
argument|c
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|xy
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%g -%s%c- %g"
argument_list|,
name|p
operator|->
name|xlb
operator|/
name|p
operator|->
name|xmult
argument_list|,
name|p
operator|->
name|xf
operator|==
name|log10
condition|?
literal|"log "
else|:
literal|""
argument_list|,
name|c
argument_list|,
name|p
operator|->
name|xub
operator|/
name|p
operator|->
name|xmult
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|badarg
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"graph: error in arguments\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

