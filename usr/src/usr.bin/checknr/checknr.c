begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)checknr.c	4.3 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * checknr: check an nroff/troff input file for matching macro calls.  * we also attempt to match size and font changes, but only the embedded  * kind.  These must end in \s0 and \fP resp.  Maybe more sophistication  * later but for now think of these restrictions as contributions to  * structured typesetting.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|MAXSTK
value|100
end_define

begin_comment
comment|/* Stack size */
end_comment

begin_define
define|#
directive|define
name|MAXBR
value|100
end_define

begin_comment
comment|/* Max number of bracket pairs known */
end_comment

begin_define
define|#
directive|define
name|MAXCMDS
value|500
end_define

begin_comment
comment|/* Max number of commands known */
end_comment

begin_comment
comment|/*  * The stack on which we remember what we've seen so far.  */
end_comment

begin_struct
struct|struct
name|stkstr
block|{
name|int
name|opno
decl_stmt|;
comment|/* number of opening bracket */
name|int
name|pl
decl_stmt|;
comment|/* '+', '-', ' ' for \s, 1 for \f, 0 for .ft */
name|int
name|parm
decl_stmt|;
comment|/* parm to size, font, etc */
name|int
name|lno
decl_stmt|;
comment|/* line number the thing came in in */
block|}
name|stk
index|[
name|MAXSTK
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|stktop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The kinds of opening and closing brackets.  */
end_comment

begin_struct
struct|struct
name|brstr
block|{
name|char
modifier|*
name|opbr
decl_stmt|;
name|char
modifier|*
name|clbr
decl_stmt|;
block|}
name|br
index|[
name|MAXBR
index|]
init|=
block|{
comment|/* A few bare bones troff commands */
define|#
directive|define
name|SZ
value|0
literal|"sz"
block|,
literal|"sz"
block|,
comment|/* also \s */
define|#
directive|define
name|FT
value|1
literal|"ft"
block|,
literal|"ft"
block|,
comment|/* also \f */
comment|/* the -mm package */
literal|"AL"
block|,
literal|"LE"
block|,
literal|"AS"
block|,
literal|"AE"
block|,
literal|"BL"
block|,
literal|"LE"
block|,
literal|"BS"
block|,
literal|"BE"
block|,
literal|"DF"
block|,
literal|"DE"
block|,
literal|"DL"
block|,
literal|"LE"
block|,
literal|"DS"
block|,
literal|"DE"
block|,
literal|"FS"
block|,
literal|"FE"
block|,
literal|"ML"
block|,
literal|"LE"
block|,
literal|"NS"
block|,
literal|"NE"
block|,
literal|"RL"
block|,
literal|"LE"
block|,
literal|"VL"
block|,
literal|"LE"
block|,
comment|/* the -ms package */
literal|"AB"
block|,
literal|"AE"
block|,
literal|"CD"
block|,
literal|"DE"
block|,
literal|"DS"
block|,
literal|"DE"
block|,
literal|"FS"
block|,
literal|"FE"
block|,
literal|"ID"
block|,
literal|"DE"
block|,
literal|"KF"
block|,
literal|"KE"
block|,
literal|"KS"
block|,
literal|"KE"
block|,
literal|"LD"
block|,
literal|"DE"
block|,
literal|"LG"
block|,
literal|"NL"
block|,
literal|"QS"
block|,
literal|"QE"
block|,
literal|"RS"
block|,
literal|"RE"
block|,
literal|"SM"
block|,
literal|"NL"
block|,
comment|/* The -me package */
literal|"(b"
block|,
literal|")b"
block|,
literal|"(c"
block|,
literal|")c"
block|,
literal|"(d"
block|,
literal|")d"
block|,
literal|"(f"
block|,
literal|")f"
block|,
literal|"(l"
block|,
literal|")l"
block|,
literal|"(q"
block|,
literal|")q"
block|,
literal|"(x"
block|,
literal|")x"
block|,
literal|"(z"
block|,
literal|")z"
block|,
comment|/* Things needed by preprocessors */
literal|"EQ"
block|,
literal|"EN"
block|,
literal|"TS"
block|,
literal|"TE"
block|,
comment|/* Refer */
literal|"["
block|,
literal|"]"
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_comment
comment|/*  * All commands known to nroff, plus macro packages.  * Used so we can complain about unrecognized commands.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|knowncmds
index|[
name|MAXCMDS
index|]
init|=
block|{
literal|"$c"
block|,
literal|"$f"
block|,
literal|"$h"
block|,
literal|"$p"
block|,
literal|"$s"
block|,
literal|"(b"
block|,
literal|"(c"
block|,
literal|"(d"
block|,
literal|"(f"
block|,
literal|"(l"
block|,
literal|"(q"
block|,
literal|"(t"
block|,
literal|"(x"
block|,
literal|"(z"
block|,
literal|")b"
block|,
literal|")c"
block|,
literal|")d"
block|,
literal|")f"
block|,
literal|")l"
block|,
literal|")q"
block|,
literal|")t"
block|,
literal|")x"
block|,
literal|")z"
block|,
literal|"++"
block|,
literal|"+c"
block|,
literal|"1C"
block|,
literal|"1c"
block|,
literal|"2C"
block|,
literal|"2c"
block|,
literal|"@("
block|,
literal|"@)"
block|,
literal|"@C"
block|,
literal|"@D"
block|,
literal|"@F"
block|,
literal|"@I"
block|,
literal|"@M"
block|,
literal|"@c"
block|,
literal|"@e"
block|,
literal|"@f"
block|,
literal|"@h"
block|,
literal|"@m"
block|,
literal|"@n"
block|,
literal|"@o"
block|,
literal|"@p"
block|,
literal|"@r"
block|,
literal|"@t"
block|,
literal|"@z"
block|,
literal|"AB"
block|,
literal|"AE"
block|,
literal|"AF"
block|,
literal|"AI"
block|,
literal|"AL"
block|,
literal|"AS"
block|,
literal|"AT"
block|,
literal|"AU"
block|,
literal|"AX"
block|,
literal|"B"
block|,
literal|"B1"
block|,
literal|"B2"
block|,
literal|"BD"
block|,
literal|"BE"
block|,
literal|"BG"
block|,
literal|"BL"
block|,
literal|"BS"
block|,
literal|"BT"
block|,
literal|"BX"
block|,
literal|"C1"
block|,
literal|"C2"
block|,
literal|"CD"
block|,
literal|"CM"
block|,
literal|"CT"
block|,
literal|"D"
block|,
literal|"DA"
block|,
literal|"DE"
block|,
literal|"DF"
block|,
literal|"DL"
block|,
literal|"DS"
block|,
literal|"EC"
block|,
literal|"EF"
block|,
literal|"EG"
block|,
literal|"EH"
block|,
literal|"EM"
block|,
literal|"EN"
block|,
literal|"EQ"
block|,
literal|"EX"
block|,
literal|"FA"
block|,
literal|"FD"
block|,
literal|"FE"
block|,
literal|"FG"
block|,
literal|"FJ"
block|,
literal|"FK"
block|,
literal|"FL"
block|,
literal|"FN"
block|,
literal|"FO"
block|,
literal|"FQ"
block|,
literal|"FS"
block|,
literal|"FV"
block|,
literal|"FX"
block|,
literal|"H"
block|,
literal|"HC"
block|,
literal|"HM"
block|,
literal|"HO"
block|,
literal|"HU"
block|,
literal|"I"
block|,
literal|"ID"
block|,
literal|"IE"
block|,
literal|"IH"
block|,
literal|"IM"
block|,
literal|"IP"
block|,
literal|"IZ"
block|,
literal|"KD"
block|,
literal|"KE"
block|,
literal|"KF"
block|,
literal|"KQ"
block|,
literal|"KS"
block|,
literal|"LB"
block|,
literal|"LC"
block|,
literal|"LD"
block|,
literal|"LE"
block|,
literal|"LG"
block|,
literal|"LI"
block|,
literal|"LP"
block|,
literal|"MC"
block|,
literal|"ME"
block|,
literal|"MF"
block|,
literal|"MH"
block|,
literal|"ML"
block|,
literal|"MR"
block|,
literal|"MT"
block|,
literal|"ND"
block|,
literal|"NE"
block|,
literal|"NH"
block|,
literal|"NL"
block|,
literal|"NP"
block|,
literal|"NS"
block|,
literal|"OF"
block|,
literal|"OH"
block|,
literal|"OK"
block|,
literal|"OP"
block|,
literal|"P"
block|,
literal|"PF"
block|,
literal|"PH"
block|,
literal|"PP"
block|,
literal|"PT"
block|,
literal|"PY"
block|,
literal|"QE"
block|,
literal|"QP"
block|,
literal|"QS"
block|,
literal|"R"
block|,
literal|"RA"
block|,
literal|"RC"
block|,
literal|"RE"
block|,
literal|"RL"
block|,
literal|"RP"
block|,
literal|"RQ"
block|,
literal|"RS"
block|,
literal|"RT"
block|,
literal|"S"
block|,
literal|"S0"
block|,
literal|"S2"
block|,
literal|"S3"
block|,
literal|"SA"
block|,
literal|"SG"
block|,
literal|"SH"
block|,
literal|"SK"
block|,
literal|"SM"
block|,
literal|"SP"
block|,
literal|"SY"
block|,
literal|"TA"
block|,
literal|"TB"
block|,
literal|"TC"
block|,
literal|"TD"
block|,
literal|"TE"
block|,
literal|"TH"
block|,
literal|"TL"
block|,
literal|"TM"
block|,
literal|"TP"
block|,
literal|"TQ"
block|,
literal|"TR"
block|,
literal|"TS"
block|,
literal|"TX"
block|,
literal|"UL"
block|,
literal|"US"
block|,
literal|"UX"
block|,
literal|"VL"
block|,
literal|"WC"
block|,
literal|"WH"
block|,
literal|"XD"
block|,
literal|"XF"
block|,
literal|"XK"
block|,
literal|"XP"
block|,
literal|"["
block|,
literal|"[-"
block|,
literal|"[0"
block|,
literal|"[1"
block|,
literal|"[2"
block|,
literal|"[3"
block|,
literal|"[4"
block|,
literal|"[5"
block|,
literal|"[<"
block|,
literal|"[>"
block|,
literal|"[]"
block|,
literal|"]"
block|,
literal|"]-"
block|,
literal|"]<"
block|,
literal|"]>"
block|,
literal|"]["
block|,
literal|"ab"
block|,
literal|"ac"
block|,
literal|"ad"
block|,
literal|"af"
block|,
literal|"am"
block|,
literal|"ar"
block|,
literal|"as"
block|,
literal|"b"
block|,
literal|"ba"
block|,
literal|"bc"
block|,
literal|"bd"
block|,
literal|"bi"
block|,
literal|"bl"
block|,
literal|"bp"
block|,
literal|"br"
block|,
literal|"bx"
block|,
literal|"c."
block|,
literal|"c2"
block|,
literal|"cc"
block|,
literal|"ce"
block|,
literal|"cf"
block|,
literal|"ch"
block|,
literal|"cs"
block|,
literal|"ct"
block|,
literal|"cu"
block|,
literal|"da"
block|,
literal|"de"
block|,
literal|"di"
block|,
literal|"dl"
block|,
literal|"dn"
block|,
literal|"ds"
block|,
literal|"dt"
block|,
literal|"dw"
block|,
literal|"dy"
block|,
literal|"ec"
block|,
literal|"ef"
block|,
literal|"eh"
block|,
literal|"el"
block|,
literal|"em"
block|,
literal|"eo"
block|,
literal|"ep"
block|,
literal|"ev"
block|,
literal|"ex"
block|,
literal|"fc"
block|,
literal|"fi"
block|,
literal|"fl"
block|,
literal|"fo"
block|,
literal|"fp"
block|,
literal|"ft"
block|,
literal|"fz"
block|,
literal|"hc"
block|,
literal|"he"
block|,
literal|"hl"
block|,
literal|"hp"
block|,
literal|"ht"
block|,
literal|"hw"
block|,
literal|"hx"
block|,
literal|"hy"
block|,
literal|"i"
block|,
literal|"ie"
block|,
literal|"if"
block|,
literal|"ig"
block|,
literal|"in"
block|,
literal|"ip"
block|,
literal|"it"
block|,
literal|"ix"
block|,
literal|"lc"
block|,
literal|"lg"
block|,
literal|"li"
block|,
literal|"ll"
block|,
literal|"ln"
block|,
literal|"lo"
block|,
literal|"lp"
block|,
literal|"ls"
block|,
literal|"lt"
block|,
literal|"m1"
block|,
literal|"m2"
block|,
literal|"m3"
block|,
literal|"m4"
block|,
literal|"mc"
block|,
literal|"mk"
block|,
literal|"mo"
block|,
literal|"n1"
block|,
literal|"n2"
block|,
literal|"na"
block|,
literal|"ne"
block|,
literal|"nf"
block|,
literal|"nh"
block|,
literal|"nl"
block|,
literal|"nm"
block|,
literal|"nn"
block|,
literal|"np"
block|,
literal|"nr"
block|,
literal|"ns"
block|,
literal|"nx"
block|,
literal|"of"
block|,
literal|"oh"
block|,
literal|"os"
block|,
literal|"pa"
block|,
literal|"pc"
block|,
literal|"pi"
block|,
literal|"pl"
block|,
literal|"pm"
block|,
literal|"pn"
block|,
literal|"po"
block|,
literal|"pp"
block|,
literal|"ps"
block|,
literal|"q"
block|,
literal|"r"
block|,
literal|"rb"
block|,
literal|"rd"
block|,
literal|"re"
block|,
literal|"rm"
block|,
literal|"rn"
block|,
literal|"ro"
block|,
literal|"rr"
block|,
literal|"rs"
block|,
literal|"rt"
block|,
literal|"sb"
block|,
literal|"sc"
block|,
literal|"sh"
block|,
literal|"sk"
block|,
literal|"so"
block|,
literal|"sp"
block|,
literal|"ss"
block|,
literal|"st"
block|,
literal|"sv"
block|,
literal|"sz"
block|,
literal|"ta"
block|,
literal|"tc"
block|,
literal|"th"
block|,
literal|"ti"
block|,
literal|"tl"
block|,
literal|"tm"
block|,
literal|"tp"
block|,
literal|"tr"
block|,
literal|"u"
block|,
literal|"uf"
block|,
literal|"uh"
block|,
literal|"ul"
block|,
literal|"vs"
block|,
literal|"wh"
block|,
literal|"xp"
block|,
literal|"yr"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line number in input file */
end_comment

begin_decl_stmt
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cfilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of current file */
end_comment

begin_decl_stmt
name|int
name|nfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of files to process */
end_comment

begin_decl_stmt
name|int
name|fflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -f: ignore \f */
end_comment

begin_decl_stmt
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -s: ignore \s */
end_comment

begin_decl_stmt
name|int
name|ncmds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of knowncmds */
end_comment

begin_decl_stmt
name|int
name|slot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* slot in knowncmds found by binsrch */
end_comment

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|b1
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* Figure out how many known commands there are */
while|while
condition|(
name|knowncmds
index|[
name|ncmds
index|]
condition|)
name|ncmds
operator|++
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
comment|/* -a: add pairs of macros */
case|case
literal|'a'
case|:
name|i
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|6
operator|!=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* look for empty macro slots */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|br
index|[
name|i
index|]
operator|.
name|opbr
condition|;
name|i
operator|++
control|)
empty_stmt|;
for|for
control|(
name|cp
operator|=
name|argv
index|[
literal|1
index|]
operator|+
literal|3
init|;
name|cp
index|[
operator|-
literal|1
index|]
condition|;
name|cp
operator|+=
literal|6
control|)
block|{
name|br
index|[
name|i
index|]
operator|.
name|opbr
operator|=
name|malloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|br
index|[
name|i
index|]
operator|.
name|opbr
argument_list|,
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|br
index|[
name|i
index|]
operator|.
name|clbr
operator|=
name|malloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|br
index|[
name|i
index|]
operator|.
name|clbr
argument_list|,
name|cp
operator|+
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|addmac
argument_list|(
name|br
index|[
name|i
index|]
operator|.
name|opbr
argument_list|)
expr_stmt|;
comment|/* knows pairs are also known cmds */
name|addmac
argument_list|(
name|br
index|[
name|i
index|]
operator|.
name|clbr
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
break|break;
comment|/* -c: add known commands */
case|case
literal|'c'
case|:
name|i
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|3
operator|!=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|argv
index|[
literal|1
index|]
operator|+
literal|3
init|;
name|cp
index|[
operator|-
literal|1
index|]
condition|;
name|cp
operator|+=
literal|3
control|)
block|{
if|if
condition|(
name|cp
index|[
literal|2
index|]
operator|&&
name|cp
index|[
literal|2
index|]
operator|!=
literal|'.'
condition|)
name|usage
argument_list|()
expr_stmt|;
name|strncpy
argument_list|(
name|b1
argument_list|,
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|addmac
argument_list|(
name|b1
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* -f: ignore font changes */
case|case
literal|'f'
case|:
name|fflag
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* -s: ignore size changes */
case|case
literal|'s'
case|:
name|sflag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|nfiles
operator|=
name|argc
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nfiles
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|cfilename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|cfilename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|perror
argument_list|(
name|cfilename
argument_list|)
expr_stmt|;
else|else
name|process
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cfilename
operator|=
literal|"stdin"
expr_stmt|;
name|process
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"Usage: checknr -s -f -a.xx.yy.xx.yy... -c.xx.xx.xx...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|process
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|char
name|mac
index|[
literal|5
index|]
decl_stmt|;
comment|/* The current macro or nroff command */
name|int
name|pl
decl_stmt|;
name|stktop
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|lineno
operator|=
literal|1
init|;
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|f
argument_list|)
condition|;
name|lineno
operator|++
control|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* 			 * find and isolate the macro/command name. 			 */
name|strncpy
argument_list|(
name|mac
argument_list|,
name|line
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|mac
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|pe
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Empty command\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
name|mac
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|mac
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
name|mac
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|mac
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mac
index|[
literal|0
index|]
operator|!=
literal|'\\'
operator|||
name|mac
index|[
literal|1
index|]
operator|!=
literal|'\"'
condition|)
block|{
name|pe
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Command too long\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Is it a known command? 			 */
name|checkknown
argument_list|(
name|mac
argument_list|)
expr_stmt|;
comment|/* 			 * Should we add it? 			 */
if|if
condition|(
name|eq
argument_list|(
name|mac
argument_list|,
literal|"de"
argument_list|)
condition|)
name|addcmd
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|chkcmd
argument_list|(
name|line
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * At this point we process the line looking 		 * for \s and \f. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|line
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|line
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|line
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'\\'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|sflag
operator|&&
name|line
index|[
operator|++
name|i
index|]
operator|==
literal|'s'
condition|)
block|{
name|pl
operator|=
name|line
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|pl
argument_list|)
condition|)
block|{
name|n
operator|=
name|pl
operator|-
literal|'0'
expr_stmt|;
name|pl
operator|=
literal|' '
expr_stmt|;
block|}
else|else
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|line
index|[
operator|++
name|i
index|]
argument_list|)
condition|)
name|n
operator|=
literal|10
operator|*
name|n
operator|+
name|line
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stk
index|[
name|stktop
index|]
operator|.
name|opno
operator|==
name|SZ
condition|)
block|{
name|stktop
operator|--
expr_stmt|;
block|}
else|else
block|{
name|pe
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unmatched \\s0\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|stk
index|[
operator|++
name|stktop
index|]
operator|.
name|opno
operator|=
name|SZ
expr_stmt|;
name|stk
index|[
name|stktop
index|]
operator|.
name|pl
operator|=
name|pl
expr_stmt|;
name|stk
index|[
name|stktop
index|]
operator|.
name|parm
operator|=
name|n
expr_stmt|;
name|stk
index|[
name|stktop
index|]
operator|.
name|lno
operator|=
name|lineno
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|fflag
operator|&&
name|line
index|[
name|i
index|]
operator|==
literal|'f'
condition|)
block|{
name|n
operator|=
name|line
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|'P'
condition|)
block|{
if|if
condition|(
name|stk
index|[
name|stktop
index|]
operator|.
name|opno
operator|==
name|FT
condition|)
block|{
name|stktop
operator|--
expr_stmt|;
block|}
else|else
block|{
name|pe
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unmatched \\fP\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|stk
index|[
operator|++
name|stktop
index|]
operator|.
name|opno
operator|=
name|FT
expr_stmt|;
name|stk
index|[
name|stktop
index|]
operator|.
name|pl
operator|=
literal|1
expr_stmt|;
name|stk
index|[
name|stktop
index|]
operator|.
name|parm
operator|=
name|n
expr_stmt|;
name|stk
index|[
name|stktop
index|]
operator|.
name|lno
operator|=
name|lineno
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * We've hit the end and look at all this stuff that hasn't been 	 * matched yet!  Complain, complain. 	 */
for|for
control|(
name|i
operator|=
name|stktop
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|complain
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|complain
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
name|pe
argument_list|(
name|stk
index|[
name|i
index|]
operator|.
name|lno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unmatched "
argument_list|)
expr_stmt|;
name|prop
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|prop
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|stk
index|[
name|i
index|]
operator|.
name|pl
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|".%s"
argument_list|,
name|br
index|[
name|stk
index|[
name|i
index|]
operator|.
name|opno
index|]
operator|.
name|opbr
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|stk
index|[
name|i
index|]
operator|.
name|opno
condition|)
block|{
case|case
name|SZ
case|:
name|printf
argument_list|(
literal|"\\s%c%d"
argument_list|,
name|stk
index|[
name|i
index|]
operator|.
name|pl
argument_list|,
name|stk
index|[
name|i
index|]
operator|.
name|parm
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT
case|:
name|printf
argument_list|(
literal|"\\f%c"
argument_list|,
name|stk
index|[
name|i
index|]
operator|.
name|parm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Bug: stk[%d].opno = %d = .%s, .%s"
argument_list|,
name|i
argument_list|,
name|stk
index|[
name|i
index|]
operator|.
name|opno
argument_list|,
name|br
index|[
name|stk
index|[
name|i
index|]
operator|.
name|opno
index|]
operator|.
name|opbr
argument_list|,
name|br
index|[
name|stk
index|[
name|i
index|]
operator|.
name|opno
index|]
operator|.
name|clbr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|chkcmd
argument_list|(
argument|line
argument_list|,
argument|mac
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mac
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/* 	 * Check to see if it matches top of stack. 	 */
if|if
condition|(
name|stktop
operator|>=
literal|0
operator|&&
name|eq
argument_list|(
name|mac
argument_list|,
name|br
index|[
name|stk
index|[
name|stktop
index|]
operator|.
name|opno
index|]
operator|.
name|clbr
argument_list|)
condition|)
name|stktop
operator|--
expr_stmt|;
comment|/* OK. Pop& forget */
else|else
block|{
comment|/* No. Maybe it's an opener */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|br
index|[
name|i
index|]
operator|.
name|opbr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eq
argument_list|(
name|mac
argument_list|,
name|br
index|[
name|i
index|]
operator|.
name|opbr
argument_list|)
condition|)
block|{
comment|/* Found. Push it. */
name|stktop
operator|++
expr_stmt|;
name|stk
index|[
name|stktop
index|]
operator|.
name|opno
operator|=
name|i
expr_stmt|;
name|stk
index|[
name|stktop
index|]
operator|.
name|pl
operator|=
literal|0
expr_stmt|;
name|stk
index|[
name|stktop
index|]
operator|.
name|parm
operator|=
literal|0
expr_stmt|;
name|stk
index|[
name|stktop
index|]
operator|.
name|lno
operator|=
name|lineno
expr_stmt|;
break|break;
block|}
comment|/* 			 * Maybe it's an unmatched closer. 			 * NOTE: this depends on the fact 			 * that none of the closers can be 			 * openers too. 			 */
if|if
condition|(
name|eq
argument_list|(
name|mac
argument_list|,
name|br
index|[
name|i
index|]
operator|.
name|clbr
argument_list|)
condition|)
block|{
name|nomatch
argument_list|(
name|mac
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|nomatch
argument_list|(
argument|mac
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mac
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * Look for a match further down on stack 	 * If we find one, it suggests that the stuff in 	 * between is supposed to match itself. 	 */
for|for
control|(
name|j
operator|=
name|stktop
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|eq
argument_list|(
name|mac
argument_list|,
name|br
index|[
name|stk
index|[
name|j
index|]
operator|.
name|opno
index|]
operator|.
name|clbr
argument_list|)
condition|)
block|{
comment|/* Found.  Make a good diagnostic. */
if|if
condition|(
name|j
operator|==
name|stktop
operator|-
literal|2
condition|)
block|{
comment|/* 				 * Check for special case \fx..\fR and don't 				 * complain. 				 */
if|if
condition|(
name|stk
index|[
name|j
operator|+
literal|1
index|]
operator|.
name|opno
operator|==
name|FT
operator|&&
name|stk
index|[
name|j
operator|+
literal|1
index|]
operator|.
name|parm
operator|!=
literal|'R'
operator|&&
name|stk
index|[
name|j
operator|+
literal|2
index|]
operator|.
name|opno
operator|==
name|FT
operator|&&
name|stk
index|[
name|j
operator|+
literal|2
index|]
operator|.
name|parm
operator|==
literal|'R'
condition|)
block|{
name|stktop
operator|=
name|j
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 				 * We have two unmatched frobs.  Chances are 				 * they were intended to match, so we mention 				 * them together. 				 */
name|pe
argument_list|(
name|stk
index|[
name|j
operator|+
literal|1
index|]
operator|.
name|lno
argument_list|)
expr_stmt|;
name|prop
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" does not match %d: "
argument_list|,
name|stk
index|[
name|j
operator|+
literal|2
index|]
operator|.
name|lno
argument_list|)
expr_stmt|;
name|prop
argument_list|(
name|j
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
name|j
operator|+
literal|1
init|;
name|i
operator|<=
name|stktop
condition|;
name|i
operator|++
control|)
block|{
name|complain
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|stktop
operator|=
name|j
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Didn't find one.  Throw this away. */
name|pe
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unmatched .%s\n"
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* eq: are two strings equal? */
end_comment

begin_macro
name|eq
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* print the first part of an error message, given the line number */
end_comment

begin_macro
name|pe
argument_list|(
argument|lineno
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|nfiles
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|cfilename
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d: "
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|checkknown
argument_list|(
argument|mac
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mac
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|eq
argument_list|(
name|mac
argument_list|,
literal|"."
argument_list|)
condition|)
return|return;
if|if
condition|(
name|binsrch
argument_list|(
name|mac
argument_list|)
operator|>=
literal|0
condition|)
return|return;
if|if
condition|(
name|mac
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|mac
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
comment|/* comments */
return|return;
name|pe
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unknown command: .%s\n"
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * We have a .de xx line in "line".  Add xx to the list of known commands.  */
end_comment

begin_macro
name|addcmd
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|mac
decl_stmt|;
comment|/* grab the macro being defined */
name|mac
operator|=
name|line
operator|+
literal|4
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|mac
argument_list|)
condition|)
name|mac
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|mac
operator|==
literal|0
condition|)
block|{
name|pe
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"illegal define: %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
name|mac
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|mac
index|[
literal|1
index|]
argument_list|)
operator|||
name|mac
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|mac
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ncmds
operator|>=
name|MAXCMDS
condition|)
block|{
name|printf
argument_list|(
literal|"Only %d known commands allowed\n"
argument_list|,
name|MAXCMDS
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|addmac
argument_list|(
name|mac
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Add mac to the list.  We should really have some kind of tree  * structure here but this is a quick-and-dirty job and I just don't  * have time to mess with it.  (I wonder if this will come back to haunt  * me someday?)  Anyway, I claim that .de is fairly rare in user  * nroff programs, and the register loop below is pretty fast.  */
end_comment

begin_macro
name|addmac
argument_list|(
argument|mac
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mac
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|src
decl_stmt|,
modifier|*
modifier|*
name|dest
decl_stmt|,
modifier|*
modifier|*
name|loc
decl_stmt|;
name|binsrch
argument_list|(
name|mac
argument_list|)
expr_stmt|;
comment|/* it's OK to redefine something */
comment|/* binsrch sets slot as a side effect */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"binsrch(%s) -> %d\n"
argument_list|,
name|mac
argument_list|,
name|slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|loc
operator|=
operator|&
name|knowncmds
index|[
name|slot
index|]
expr_stmt|;
name|src
operator|=
operator|&
name|knowncmds
index|[
name|ncmds
operator|-
literal|1
index|]
expr_stmt|;
name|dest
operator|=
name|src
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|dest
operator|>
name|loc
condition|)
operator|*
name|dest
operator|--
operator|=
operator|*
name|src
operator|--
expr_stmt|;
operator|*
name|loc
operator|=
name|malloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|loc
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|ncmds
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"after: %s %s %s %s %s, %d cmds\n"
argument_list|,
name|knowncmds
index|[
name|slot
operator|-
literal|2
index|]
argument_list|,
name|knowncmds
index|[
name|slot
operator|-
literal|1
index|]
argument_list|,
name|knowncmds
index|[
name|slot
index|]
argument_list|,
name|knowncmds
index|[
name|slot
operator|+
literal|1
index|]
argument_list|,
name|knowncmds
index|[
name|slot
operator|+
literal|2
index|]
argument_list|,
name|ncmds
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Do a binary search in knowncmds for mac.  * If found, return the index.  If not, return -1.  */
end_comment

begin_macro
name|binsrch
argument_list|(
argument|mac
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mac
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* pointer to current cmd in list */
specifier|register
name|int
name|d
decl_stmt|;
comment|/* difference if any */
specifier|register
name|int
name|mid
decl_stmt|;
comment|/* mid point in binary search */
specifier|register
name|int
name|top
decl_stmt|,
name|bot
decl_stmt|;
comment|/* boundaries of bin search, inclusive */
name|top
operator|=
name|ncmds
operator|-
literal|1
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|top
operator|>=
name|bot
condition|)
block|{
name|mid
operator|=
operator|(
name|top
operator|+
name|bot
operator|)
operator|/
literal|2
expr_stmt|;
name|p
operator|=
name|knowncmds
index|[
name|mid
index|]
expr_stmt|;
name|d
operator|=
name|p
index|[
literal|0
index|]
operator|-
name|mac
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|d
operator|=
name|p
index|[
literal|1
index|]
operator|-
name|mac
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
return|return
name|mid
return|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|bot
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|top
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
name|slot
operator|=
name|bot
expr_stmt|;
comment|/* place it would have gone */
return|return
operator|-
literal|1
return|;
block|}
end_block

end_unit

