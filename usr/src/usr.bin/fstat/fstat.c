begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1987 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1987 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)fstat.c	5.5 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !lint */
end_comment

begin_comment
comment|/*  *  fstat   */
end_comment

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_include
include|#
directive|include
file|<sys/text.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/vlimit.h>
end_include

begin_include
include|#
directive|include
file|<sys/inode.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/unpcb.h>
end_include

begin_define
define|#
directive|define
name|KERNEL
end_define

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ULTRIX
end_ifdef

begin_comment
comment|/* UFS -> GFS */
end_comment

begin_define
define|#
directive|define
name|inode
value|gnode
end_define

begin_define
define|#
directive|define
name|x_iptr
value|x_gptr
end_define

begin_define
define|#
directive|define
name|i_dev
value|g_dev
end_define

begin_define
define|#
directive|define
name|i_number
value|g_number
end_define

begin_define
define|#
directive|define
name|i_mode
value|g_mode
end_define

begin_define
define|#
directive|define
name|i_size
value|g_size
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ULTRIX */
end_comment

begin_define
define|#
directive|define
name|TEXT
value|-2
end_define

begin_define
define|#
directive|define
name|WD
value|-1
end_define

begin_define
define|#
directive|define
name|vprintf
value|if (vflg) printf
end_define

begin_struct
struct|struct
name|devs
block|{
name|struct
name|devs
modifier|*
name|next
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|int
name|inum
decl_stmt|;
block|}
name|devs
struct|;
end_struct

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
block|{
literal|"_proc"
block|}
block|,
define|#
directive|define
name|X_PROC
value|0
block|{
literal|"_Usrptmap"
block|}
block|,
define|#
directive|define
name|X_USRPTMA
value|1
block|{
literal|"_usrpt"
block|}
block|,
define|#
directive|define
name|X_USRPT
value|2
block|{
literal|"_nswap"
block|}
block|,
define|#
directive|define
name|X_NSWAP
value|3
block|{
literal|"_nproc"
block|}
block|,
define|#
directive|define
name|X_NPROC
value|4
block|{
literal|""
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
name|proc
index|[
literal|8
index|]
decl_stmt|,
modifier|*
name|mproc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8 = a few, for less syscalls */
end_comment

begin_decl_stmt
name|struct
name|pte
modifier|*
name|Usrptma
decl_stmt|,
modifier|*
name|usrpt
decl_stmt|;
end_decl_stmt

begin_union
union|union
block|{
name|struct
name|user
name|user
decl_stmt|;
name|char
name|upages
index|[
name|UPAGES
index|]
index|[
name|NBPG
index|]
decl_stmt|;
block|}
name|user
union|;
end_union

begin_decl_stmt
specifier|static
name|int
name|nproc
decl_stmt|,
name|nswap
decl_stmt|,
name|kmem
decl_stmt|,
name|mem
decl_stmt|,
name|swap
decl_stmt|,
name|uid
decl_stmt|,
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uflg
decl_stmt|,
name|fflg
decl_stmt|,
name|vflg
decl_stmt|,
name|pflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|kmemf
init|=
literal|"kmem"
decl_stmt|,
modifier|*
name|memf
init|=
literal|"mem"
decl_stmt|,
modifier|*
name|swapf
init|=
literal|"drum"
decl_stmt|,
modifier|*
name|nlistf
init|=
literal|"/vmunix"
decl_stmt|,
modifier|*
name|uname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|lgetw
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|emalloc
argument_list|()
decl_stmt|,
modifier|*
name|getinetproto
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|off_t
name|procp
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|"/dev"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"/dev"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"p:u:v"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
case|case
literal|'p'
case|:
if|if
condition|(
name|pflg
operator|++
operator|||
operator|(
operator|(
name|pid
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
operator|)
operator|<=
literal|0
operator|)
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|uflg
operator|++
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|uid
operator|=
name|getuname
argument_list|(
name|optarg
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown user\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
name|vflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|argv
operator|+=
name|optind
init|;
operator|*
name|argv
condition|;
operator|++
name|argv
control|)
block|{
name|fflg
operator|=
literal|1
expr_stmt|;
name|getfname
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"USER\t CMD\t      PID    FD\tDEVICE\tINODE\t  SIZE\tTYPE\n"
argument_list|)
expr_stmt|;
name|openfiles
argument_list|()
expr_stmt|;
name|getkvars
argument_list|()
expr_stmt|;
name|procp
operator|=
name|lgetw
argument_list|(
operator|(
name|off_t
operator|)
name|nl
index|[
name|X_PROC
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|nproc
operator|=
operator|(
name|int
operator|)
name|lgetw
argument_list|(
operator|(
name|off_t
operator|)
name|nl
index|[
name|X_NPROC
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nproc
condition|;
name|i
operator|+=
literal|8
control|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|procp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|j
operator|=
name|MIN
argument_list|(
name|nproc
operator|-
name|i
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|j
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|proc
argument_list|,
name|j
argument_list|)
operator|!=
name|j
condition|)
name|cantread
argument_list|(
literal|"proc table"
argument_list|,
name|kmemf
argument_list|)
expr_stmt|;
name|procp
operator|+=
name|j
expr_stmt|;
for|for
control|(
name|j
operator|=
name|j
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|mproc
operator|=
operator|&
name|proc
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|mproc
operator|->
name|p_stat
operator|==
literal|0
condition|)
continue|continue;
name|doproc
argument_list|()
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|lgetw
parameter_list|(
name|loc
parameter_list|)
name|off_t
name|loc
decl_stmt|;
block|{
name|long
name|word
decl_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|loc
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|word
argument_list|,
sizeof|sizeof
argument_list|(
name|word
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|word
argument_list|)
condition|)
name|vprintf
argument_list|(
literal|"error reading kmem at %lx\n"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
name|word
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|openfiles
argument_list|()
block|{
name|kmem
operator|=
name|open
argument_list|(
name|kmemf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
block|;
if|if
condition|(
name|kmem
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|kmemf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|open
argument_list|(
name|memf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|mem
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|memf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|swap
operator|=
name|open
argument_list|(
name|swapf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|swap
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|swapf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_macro
unit|}  static
name|getkvars
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|nlist
argument_list|(
name|nlistf
argument_list|,
name|nl
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|!
name|nl
index|[
literal|0
index|]
operator|.
name|n_type
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: No namelist\n"
argument_list|,
name|nlistf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Usrptma
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|nl
index|[
name|X_USRPTMA
index|]
operator|.
name|n_value
expr_stmt|;
name|usrpt
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|nl
index|[
name|X_USRPT
index|]
operator|.
name|n_value
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|nl
index|[
name|X_NSWAP
index|]
operator|.
name|n_value
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nswap
argument_list|,
sizeof|sizeof
argument_list|(
name|nswap
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|nswap
argument_list|)
condition|)
block|{
name|cantread
argument_list|(
literal|"nswap"
argument_list|,
name|kmemf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|cantread
argument_list|(
argument|what
argument_list|,
argument|fromwhat
argument_list|)
name|char
operator|*
name|what
operator|,
operator|*
name|fromwhat
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|vprintf
argument_list|(
literal|"fstat: error reading %s from %s"
argument_list|,
name|what
argument_list|,
name|fromwhat
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|doproc
argument_list|()
block|{ 	struct
name|passwd
operator|*
name|getpwuid
argument_list|()
block|;
if|if
condition|(
name|uflg
operator|&&
name|mproc
operator|->
name|p_uid
operator|!=
name|uid
condition|)
return|return;
end_expr_stmt

begin_if
if|if
condition|(
name|pflg
operator|&&
name|mproc
operator|->
name|p_pid
operator|!=
name|pid
condition|)
return|return;
end_if

begin_if
if|if
condition|(
name|mproc
operator|->
name|p_stat
operator|!=
name|SZOMB
operator|&&
name|getu
argument_list|()
operator|==
literal|0
condition|)
return|return;
end_if

begin_expr_stmt
name|uname
operator|=
name|getpwuid
argument_list|(
name|mproc
operator|->
name|p_uid
argument_list|)
operator|->
name|pw_name
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dotext
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|getf
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
unit|}  static
name|getu
argument_list|()
end_macro

begin_block
block|{
name|struct
name|pte
modifier|*
name|pteaddr
decl_stmt|,
name|apte
decl_stmt|;
name|struct
name|pte
name|arguutl
index|[
name|UPAGES
operator|+
name|CLSIZE
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|ncl
decl_stmt|,
name|size
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mproc
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|swap
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|swap
argument_list|,
operator|(
name|off_t
operator|)
name|dtob
argument_list|(
name|mproc
operator|->
name|p_swaddr
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|swap
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|user
operator|.
name|user
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fstat: cant read u for pid %d from %s\n"
argument_list|,
name|mproc
operator|->
name|p_pid
argument_list|,
name|swapf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pteaddr
operator|=
operator|&
name|Usrptma
index|[
name|btokmx
argument_list|(
name|mproc
operator|->
name|p_p0br
argument_list|)
operator|+
name|mproc
operator|->
name|p_szpt
operator|-
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|pteaddr
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|apte
argument_list|,
sizeof|sizeof
argument_list|(
name|apte
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|apte
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"fstat: cant read indir pte to get u for pid %d from %s\n"
argument_list|,
name|mproc
operator|->
name|p_pid
argument_list|,
name|swapf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|mem
argument_list|,
operator|(
name|off_t
operator|)
name|ctob
argument_list|(
name|apte
operator|.
name|pg_pfnum
operator|+
literal|1
argument_list|)
operator|-
operator|(
name|UPAGES
operator|+
name|CLSIZE
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arguutl
argument_list|,
sizeof|sizeof
argument_list|(
name|arguutl
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|arguutl
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"fstat: cant read page table for u of pid %d from %s\n"
argument_list|,
name|mproc
operator|->
name|p_pid
argument_list|,
name|kmemf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ncl
operator|=
operator|(
name|size
operator|+
name|NBPG
operator|*
name|CLSIZE
operator|-
literal|1
operator|)
operator|/
operator|(
name|NBPG
operator|*
name|CLSIZE
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|ncl
operator|>=
literal|0
condition|)
block|{
name|i
operator|=
name|ncl
operator|*
name|CLSIZE
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|mem
argument_list|,
operator|(
name|off_t
operator|)
name|ctob
argument_list|(
name|arguutl
index|[
name|CLSIZE
operator|+
name|i
index|]
operator|.
name|pg_pfnum
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
name|user
operator|.
name|upages
index|[
name|i
index|]
argument_list|,
name|CLSIZE
operator|*
name|NBPG
argument_list|)
operator|!=
name|CLSIZE
operator|*
name|NBPG
condition|)
block|{
name|printf
argument_list|(
literal|"fstat: cant read page %u of u of pid %d from %s\n"
argument_list|,
name|arguutl
index|[
name|CLSIZE
operator|+
name|i
index|]
operator|.
name|pg_pfnum
argument_list|,
name|mproc
operator|->
name|p_pid
argument_list|,
name|memf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|dotext
argument_list|()
block|{ 	struct
name|text
name|text
block|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|mproc
operator|->
name|p_textp
argument_list|,
name|L_SET
argument_list|)
block|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|text
argument_list|)
condition|)
block|{
name|cantread
argument_list|(
literal|"text table"
argument_list|,
name|kmemf
argument_list|)
expr_stmt|;
return|return;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|text
operator|.
name|x_flag
operator|==
literal|0
condition|)
return|return;
end_if

begin_expr_stmt
name|itrans
argument_list|(
name|DTYPE_INODE
argument_list|,
name|text
operator|.
name|x_iptr
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  char
operator|*
name|itypename
index|[]
operator|=
block|{
literal|"unk"
block|,
define|#
directive|define
name|UNK
value|0
comment|/* unknown */
literal|"chr"
block|,
define|#
directive|define
name|CHR
value|1
literal|"dir"
block|,
define|#
directive|define
name|DIR
value|2
literal|"blk"
block|,
define|#
directive|define
name|BLK
value|3
literal|"reg"
block|,
define|#
directive|define
name|REG
value|4
literal|"lnk"
block|,
define|#
directive|define
name|LNK
value|5
literal|"soc"
define|#
directive|define
name|SOC
value|6
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|itype
argument_list|(
argument|mode
argument_list|)
name|u_short
name|mode
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|mode
operator|&
name|IFMT
condition|)
block|{
case|case
name|IFCHR
case|:
return|return
operator|(
name|CHR
operator|)
return|;
case|case
name|IFDIR
case|:
return|return
operator|(
name|DIR
operator|)
return|;
case|case
name|IFBLK
case|:
return|return
operator|(
name|BLK
operator|)
return|;
case|case
name|IFREG
case|:
return|return
operator|(
name|REG
operator|)
return|;
case|case
name|IFLNK
case|:
return|return
operator|(
name|LNK
operator|)
return|;
case|case
name|IFSOCK
case|:
return|return
operator|(
name|SOC
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|itrans
argument_list|(
argument|ftype
argument_list|,
argument|g
argument_list|,
argument|fno
argument_list|)
name|int
name|ftype
operator|,
name|fno
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|inode
modifier|*
name|g
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if ftype is inode */
end_comment

begin_block
block|{
name|struct
name|inode
name|inode
decl_stmt|;
name|dev_t
name|idev
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|comm
decl_stmt|;
if|if
condition|(
name|g
operator|||
name|fflg
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|g
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inode
argument_list|,
sizeof|sizeof
argument_list|(
name|inode
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|inode
argument_list|)
condition|)
block|{
name|vprintf
argument_list|(
literal|"error %d reading inode at %x from kmem\n"
argument_list|,
name|errno
argument_list|,
operator|(
name|int
operator|)
name|g
argument_list|)
expr_stmt|;
return|return;
block|}
name|idev
operator|=
name|inode
operator|.
name|i_dev
expr_stmt|;
if|if
condition|(
name|fflg
operator|&&
operator|!
name|devmatch
argument_list|(
name|idev
argument_list|,
name|inode
operator|.
name|i_number
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
name|mproc
operator|->
name|p_pid
operator|==
literal|0
condition|)
name|comm
operator|=
literal|"swapper"
expr_stmt|;
elseif|else
if|if
condition|(
name|mproc
operator|->
name|p_pid
operator|==
literal|2
condition|)
name|comm
operator|=
literal|"pagedaemon"
expr_stmt|;
else|else
name|comm
operator|=
name|user
operator|.
name|user
operator|.
name|u_comm
expr_stmt|;
name|printf
argument_list|(
literal|"%-8.8s %-10.10s %5d  "
argument_list|,
name|uname
argument_list|,
name|comm
argument_list|,
name|mproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fno
operator|==
name|WD
condition|)
name|printf
argument_list|(
literal|"  wd"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fno
operator|==
name|TEXT
condition|)
name|printf
argument_list|(
literal|"text"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%4d"
argument_list|,
name|fno
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"* (deallocated)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ftype
condition|)
block|{
case|case
name|DTYPE_INODE
case|:
name|type
operator|=
name|itype
argument_list|(
name|inode
operator|.
name|i_mode
argument_list|)
expr_stmt|;
comment|/* determine inode type */
name|printf
argument_list|(
literal|"\t%2d, %2d\t%5lu\t%6ld\t%3s\n"
argument_list|,
name|major
argument_list|(
name|inode
operator|.
name|i_dev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|inode
operator|.
name|i_dev
argument_list|)
argument_list|,
name|inode
operator|.
name|i_number
argument_list|,
name|type
operator|==
name|SOC
condition|?
literal|0
else|:
name|inode
operator|.
name|i_size
argument_list|,
name|itypename
index|[
name|type
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTYPE_SOCKET
case|:
name|socktrans
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
name|g
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DTYPE_PORT
case|case
name|DTYPE_PORT
case|:
name|printf
argument_list|(
literal|"* (fifo / named pipe)\n"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"* (unknown file type)\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|devmatch
argument_list|(
argument|idev
argument_list|,
argument|inum
argument_list|)
name|dev_t
name|idev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ino_t
name|inum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|devs
modifier|*
name|d
init|=
operator|&
name|devs
decl_stmt|;
for|for
control|(
name|d
operator|=
name|d
operator|->
name|next
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
name|d
operator|->
name|dev
operator|==
name|idev
operator|&&
operator|(
operator|!
name|d
operator|->
name|inum
operator|||
name|d
operator|->
name|inum
operator|==
name|inum
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|socktrans
argument_list|(
argument|sock
argument_list|)
expr|struct
name|socket
operator|*
name|sock
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|stypename
index|[]
init|=
block|{
literal|"unused"
block|,
comment|/* 0 */
literal|"stream"
block|,
comment|/* 1 */
literal|"dgram"
block|,
comment|/* 2 */
literal|"raw"
block|,
comment|/* 3 */
literal|"rdm"
block|,
comment|/* 4 */
literal|"seqpak"
comment|/* 5 */
block|}
decl_stmt|;
define|#
directive|define
name|STYPEMAX
value|5
name|struct
name|socket
name|so
decl_stmt|;
name|struct
name|protosw
name|proto
decl_stmt|;
name|struct
name|domain
name|dom
decl_stmt|;
name|struct
name|inpcb
name|inpcb
decl_stmt|;
name|struct
name|unpcb
name|unpcb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|stype
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|;
name|char
name|dname
index|[
literal|32
index|]
decl_stmt|;
comment|/* domain name, e.g. "inet" */
comment|/* fill in socket */
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|sock
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|socket
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|socket
argument_list|)
condition|)
block|{
name|vprintf
argument_list|(
literal|"error %d reading socket at %x from kmem\n"
argument_list|,
name|errno
argument_list|,
operator|(
name|int
operator|)
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fill in protosw entry */
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|so
operator|.
name|so_proto
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|proto
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|protosw
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|protosw
argument_list|)
condition|)
block|{
name|vprintf
argument_list|(
literal|"error %d reading protosw at %x from kmem\n"
argument_list|,
name|errno
argument_list|,
operator|(
name|int
operator|)
name|so
operator|.
name|so_proto
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fill in domain */
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|proto
operator|.
name|pr_domain
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dom
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|domain
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|domain
argument_list|)
condition|)
block|{
name|vprintf
argument_list|(
literal|"error %d reading domain at %x from kmem\n"
argument_list|,
name|errno
argument_list|,
operator|(
name|int
operator|)
name|proto
operator|.
name|pr_domain
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Grab domain name */
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|dom
operator|.
name|dom_name
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
comment|/* 30 leaves room for null byte */
for|for
control|(
name|cp
operator|=
name|dname
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
operator|,
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
block|{
name|vprintf
argument_list|(
literal|"error %d reading char at %x from kmem\n"
argument_list|,
name|errno
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dom
operator|.
name|dom_name
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
operator|*
name|cp
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* kludge "internet" --> "inet" for brevity */
if|if
condition|(
name|dom
operator|.
name|dom_family
operator|==
name|AF_INET
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dname
argument_list|,
literal|"inet"
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|.
name|so_type
operator|<
literal|1
operator|||
name|so
operator|.
name|so_type
operator|>
name|STYPEMAX
condition|)
block|{
name|stype
operator|=
name|emalloc
argument_list|(
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|stype
argument_list|,
literal|"unk%d"
argument_list|,
name|so
operator|.
name|so_type
argument_list|)
expr_stmt|;
block|}
else|else
name|stype
operator|=
name|stypename
index|[
name|so
operator|.
name|so_type
index|]
expr_stmt|;
comment|/* print sock type, sock state, and domain name */
name|printf
argument_list|(
literal|"* (%s %s %x"
argument_list|,
name|dname
argument_list|,
name|stype
argument_list|,
name|so
operator|.
name|so_state
argument_list|)
expr_stmt|;
comment|/*  	 * protocol specific formating  	 * 	 * Try to find interesting things to print.  For tcp, the 	 * interesting thing is the address of the tcpcb, for udp 	 * and others, just the inpcb (socket pcb).  For unix 	 * domain, its the address of the socket pcb and the address of 	 * the connected pcb (if connected).  Otherwise just print 	 * the protocol number and address of the socket itself. The 	 * idea is not to duplicate netstat, but to make available 	 * enough information for further analysis.  	 */
if|if
condition|(
name|dom
operator|.
name|dom_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* print name of protocol number */
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|getinetproto
argument_list|(
name|proto
operator|.
name|pr_protocol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|.
name|pr_protocol
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
name|so
operator|.
name|so_pcb
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|so
operator|.
name|so_pcb
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inpcb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inpcb
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|inpcb
argument_list|)
condition|)
block|{
name|vprintf
argument_list|(
literal|"error %d reading inpcb at %x from kmem\n"
argument_list|,
name|errno
argument_list|,
operator|(
name|int
operator|)
name|so
operator|.
name|so_pcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|" %x"
argument_list|,
operator|(
name|int
operator|)
name|inpcb
operator|.
name|inp_ppcb
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|so
operator|.
name|so_pcb
condition|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
operator|(
name|int
operator|)
name|so
operator|.
name|so_pcb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dom
operator|.
name|dom_family
operator|==
name|AF_UNIX
condition|)
block|{
comment|/* print address of pcb and connected pcb */
if|if
condition|(
name|so
operator|.
name|so_pcb
condition|)
block|{
name|printf
argument_list|(
literal|" %x"
argument_list|,
operator|(
name|int
operator|)
name|so
operator|.
name|so_pcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|so
operator|.
name|so_pcb
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|unpcb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unpcb
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|unpcb
argument_list|)
condition|)
block|{
name|vprintf
argument_list|(
literal|"error %d reading unpcb at %x from kmem\n"
argument_list|,
name|errno
argument_list|,
operator|(
name|int
operator|)
name|so
operator|.
name|so_pcb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|unpcb
operator|.
name|unp_conn
condition|)
block|{
name|char
name|shoconn
index|[
literal|4
index|]
decl_stmt|;
operator|*
name|shoconn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|so
operator|.
name|so_state
operator|&
name|SS_CANTRCVMORE
operator|)
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|shoconn
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|shoconn
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|so
operator|.
name|so_state
operator|&
name|SS_CANTSENDMORE
operator|)
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|shoconn
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s %x"
argument_list|,
name|shoconn
argument_list|,
operator|(
name|int
operator|)
name|unpcb
operator|.
name|unp_conn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* print protocol number and socket address */
name|printf
argument_list|(
literal|" %d %x"
argument_list|,
name|proto
operator|.
name|pr_protocol
argument_list|,
operator|(
name|int
operator|)
name|sock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|getinetproto
parameter_list|(
name|number
parameter_list|)
name|int
name|number
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
switch|switch
condition|(
name|number
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
literal|"ip"
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
literal|"icmp"
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
literal|"ggp"
operator|)
return|;
case|case
literal|6
case|:
return|return
operator|(
literal|"tcp"
operator|)
return|;
case|case
literal|8
case|:
return|return
operator|(
literal|"egp"
operator|)
return|;
case|case
literal|12
case|:
return|return
operator|(
literal|"pup"
operator|)
return|;
case|case
literal|17
case|:
return|return
operator|(
literal|"udp"
operator|)
return|;
case|case
literal|22
case|:
return|return
operator|(
literal|"idp"
operator|)
return|;
case|case
literal|255
case|:
return|return
operator|(
literal|"raw"
operator|)
return|;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
operator|=
name|emalloc
argument_list|(
literal|16
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|number
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|emalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|u_int
operator|)
name|size
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fstat: out of space.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|file
modifier|*
name|getf
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|struct
name|file
name|lfile
decl_stmt|;
name|itrans
argument_list|(
name|DTYPE_INODE
argument_list|,
name|user
operator|.
name|user
operator|.
name|u_cdir
argument_list|,
name|WD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOFILE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|user
operator|.
name|user
operator|.
name|u_ofile
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|user
operator|.
name|user
operator|.
name|u_ofile
index|[
name|i
index|]
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lfile
argument_list|,
sizeof|sizeof
argument_list|(
name|lfile
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|lfile
argument_list|)
condition|)
block|{
name|cantread
argument_list|(
literal|"file"
argument_list|,
name|kmemf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|itrans
argument_list|(
name|lfile
operator|.
name|f_type
argument_list|,
operator|(
expr|struct
name|inode
operator|*
operator|)
name|lfile
operator|.
name|f_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|usage
argument_list|()
block|{
name|fputs
argument_list|(
literal|"usage: fstat [-v] [-u user] [-p pid] [filename ...]\n"
argument_list|,
name|stderr
argument_list|)
block|;
name|exit
argument_list|(
literal|1
argument_list|)
block|; }
specifier|static
name|getuname
argument_list|(
argument|arg_uname
argument_list|)
name|char
operator|*
name|arg_uname
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|passwd
modifier|*
name|passwd
decl_stmt|,
modifier|*
name|getpwnam
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|passwd
operator|=
name|getpwnam
argument_list|(
name|arg_uname
argument_list|)
operator|)
condition|?
name|passwd
operator|->
name|pw_uid
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|getfname
argument_list|(
argument|filename
argument_list|)
name|char
operator|*
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|struct
name|devs
modifier|*
name|d
decl_stmt|,
modifier|*
name|oldd
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|int
name|inum
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * if file is block special, look for open files on it 	 */
if|if
condition|(
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFBLK
condition|)
block|{
name|inum
operator|=
name|statbuf
operator|.
name|st_ino
expr_stmt|;
name|dev
operator|=
name|statbuf
operator|.
name|st_dev
expr_stmt|;
block|}
else|else
block|{
name|inum
operator|=
literal|0
expr_stmt|;
name|dev
operator|=
name|statbuf
operator|.
name|st_rdev
expr_stmt|;
block|}
for|for
control|(
name|d
operator|=
name|oldd
operator|=
operator|&
name|devs
init|;
name|d
condition|;
name|oldd
operator|=
name|d
operator|,
name|d
operator|=
name|d
operator|->
name|next
control|)
empty_stmt|;
name|d
operator|=
operator|(
expr|struct
name|devs
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|devs
argument_list|)
argument_list|)
expr_stmt|;
name|oldd
operator|->
name|next
operator|=
name|d
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|d
operator|->
name|inum
operator|=
name|inum
expr_stmt|;
block|}
end_block

end_unit

