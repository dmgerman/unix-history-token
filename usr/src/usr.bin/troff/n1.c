begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)n1.c	4.2 6/14/82"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"tdef.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_decl_stmt
specifier|extern
include|#
directive|include
file|"d.h"
specifier|extern
include|#
directive|include
file|"v.h"
ifdef|#
directive|ifdef
name|NROFF
specifier|extern
include|#
directive|include
file|"tw.h"
endif|#
directive|endif
include|#
directive|include
file|"sdef.h"
include|#
directive|include
file|<setjmp.h>
name|jmp_buf
name|sjbuf
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_comment
comment|/* troff1.c  consume options, initialization, main loop, input routines, escape function calling */
end_comment

begin_decl_stmt
name|int
name|inchar
index|[
name|LNSIZE
index|]
decl_stmt|,
modifier|*
name|pinchar
init|=
name|inchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|s
modifier|*
name|frame
decl_stmt|,
modifier|*
name|stk
decl_stmt|,
modifier|*
name|nxf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|s
modifier|*
name|ejl
decl_stmt|,
modifier|*
name|litlev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|filep
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|filep
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|filep
name|nextb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|stdi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|waitf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nofeed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|quiet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ptid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ascii
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|npn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|xflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|ibuf
index|[
name|IBUFSZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|xbuf
index|[
name|IBUFSZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ibufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xbufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|eibuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xeibuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cbuf
index|[
name|NC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|vlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|mflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pfrom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|chbits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ibf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ttyod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sgttyb
name|ttys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|iflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rargc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|trtab
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lgf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|copyf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|eschar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ch0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cwidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nlflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|donef
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nflush
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nchar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rchar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ifile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|padc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tabc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|dotc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|raw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tabtab
index|[
name|NTAB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|nextf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfi
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NROFF
end_ifdef

begin_decl_stmt
specifier|extern
name|char
name|termtab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tti
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|ifl
index|[
name|NSO
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ifi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pendt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|flss
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|ptname
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nonumb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pnlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|pnp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|trap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ejf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|c2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|spread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|oline
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|olinep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|dpn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|noscale
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|unlkp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ttysave
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tdelim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|dotT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tabch
decl_stmt|,
name|ldrch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|eqflg
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern no_out;
end_extern

begin_decl_stmt
specifier|extern
name|int
name|hflg
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NROFF
end_ifndef

begin_decl_stmt
specifier|extern
name|char
name|codetab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|spbits
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|xxx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stopmesg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|filep
name|ipl
index|[
name|NSO
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|offl
index|[
name|NSO
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|ioff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ttyp
decl_stmt|;
end_decl_stmt

begin_struct
specifier|extern
struct|struct
name|contab
block|{
name|int
name|rq
decl_stmt|;
union|union
block|{
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
name|unsigned
name|mx
decl_stmt|;
block|}
name|x
union|;
block|}
name|contab
index|[
name|NM
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|ms
index|[]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NROFF
end_ifndef

begin_decl_stmt
name|int
name|acctf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|i
operator|,
name|j
expr_stmt|;
extern|extern catch(
block|)
operator|,
function|fpecatch
parameter_list|()
operator|,
function|kcatch
parameter_list|()
function|;
end_function

begin_expr_stmt
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|catch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catch
argument_list|)
operator|==
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|fpecatch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|catch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|kcatch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init1
argument_list|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|options
label|:
end_label

begin_while
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|(
operator|++
name|argv
operator|)
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0
case|:
goto|goto
name|start
goto|;
case|case
literal|'i'
case|:
name|stdi
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
if|if
condition|(
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|ttys
argument_list|)
operator|>=
literal|0
condition|)
name|ttysave
operator|=
name|ttys
operator|.
name|sg_flags
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|npn
operator|=
name|cnum
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
name|xflg
operator|=
literal|0
expr_stmt|;
name|cps
operator|=
name|cnum
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'S'
case|:
name|stopmesg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
operator|(
name|stop
operator|=
name|cnum
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
name|stop
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|vlist
index|[
name|findr
argument_list|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
index|]
operator|=
name|cnum
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'m'
case|:
name|p
operator|=
operator|&
name|nextf
index|[
name|nfi
index|]
expr_stmt|;
name|q
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|access
argument_list|(
name|nextf
argument_list|,
literal|4
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|local
init|=
literal|"/usr/local/lib/tmac/tmac.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
decl_stmt|;
name|strcat
argument_list|(
name|local
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|local
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|nextf
argument_list|,
name|local
argument_list|)
expr_stmt|;
block|}
name|mflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'o'
case|:
name|getpn
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
ifdef|#
directive|ifdef
name|NROFF
case|case
literal|'h'
case|:
name|hflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
name|no_out
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
name|eqflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
name|p
operator|=
operator|&
name|termtab
index|[
name|tti
index|]
expr_stmt|;
name|q
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|q
operator|)
operator|&
literal|0177
operator|)
condition|)
continue|continue;
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|dotT
operator|++
expr_stmt|;
continue|continue;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NROFF
case|case
literal|'z'
case|:
name|no_out
operator|++
expr_stmt|;
case|case
literal|'a'
case|:
name|ascii
operator|=
literal|1
expr_stmt|;
name|nofeed
operator|++
expr_stmt|;
case|case
literal|'t'
case|:
name|ptid
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
name|waitf
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
name|nofeed
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
name|xflg
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
if|if
condition|(
name|open
argument_list|(
name|ptname
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|prstr
argument_list|(
literal|"Busy.\n"
argument_list|)
expr_stmt|;
else|else
name|prstr
argument_list|(
literal|"Available.\n"
argument_list|)
expr_stmt|;
name|done3
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'g'
case|:
name|stop
operator|=
name|ptid
operator|=
name|gflag
operator|=
literal|1
expr_stmt|;
name|dpn
operator|=
literal|0
expr_stmt|;
continue|continue;
endif|#
directive|endif
default|default:
name|pto
operator|=
name|cnum
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_while

begin_if
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|pfrom
operator|=
name|cnum
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|print
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
goto|goto
name|options
goto|;
block|}
end_if

begin_label
name|start
label|:
end_label

begin_expr_stmt
name|argp
operator|=
name|argv
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rargc
operator|=
name|argc
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init2
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|loop
label|:
end_label

begin_expr_stmt
name|copyf
operator|=
name|lgf
operator|=
name|nb
operator|=
name|nflush
operator|=
name|nlflg
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ip
operator|&&
operator|(
name|rbf0
argument_list|(
name|ip
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|ejf
operator|&&
operator|(
name|frame
operator|->
name|pframe
operator|<=
name|ejl
operator|)
condition|)
block|{
name|nflush
operator|++
expr_stmt|;
name|trap
operator|=
literal|0
expr_stmt|;
name|eject
argument_list|(
operator|(
expr|struct
name|s
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_if

begin_expr_stmt
name|i
operator|=
name|getch
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|pendt
condition|)
goto|goto
name|lt
goto|;
end_if

begin_if
if|if
condition|(
name|lit
operator|&&
operator|(
name|frame
operator|<=
name|litlev
operator|)
condition|)
block|{
name|lit
operator|--
expr_stmt|;
goto|goto
name|lt
goto|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|j
operator|=
operator|(
name|i
operator|&
name|CMASK
operator|)
operator|)
operator|==
name|XPAR
condition|)
block|{
name|copyf
operator|++
expr_stmt|;
name|tflg
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|(
name|i
operator|&
name|CMASK
operator|)
operator|!=
literal|'\n'
condition|;
control|)
name|pchar
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
expr_stmt|;
name|tflg
operator|=
literal|0
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|j
operator|==
name|cc
operator|)
operator|||
operator|(
name|j
operator|==
name|c2
operator|)
condition|)
block|{
if|if
condition|(
name|j
operator|==
name|c2
condition|)
name|nb
operator|++
expr_stmt|;
name|copyf
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|j
operator|=
operator|(
operator|(
name|i
operator|=
name|getch
argument_list|()
operator|)
operator|&
name|CMASK
operator|)
operator|)
operator|==
literal|' '
operator|)
operator|||
operator|(
name|j
operator|==
literal|'\t'
operator|)
condition|)
empty_stmt|;
name|ch
operator|=
name|i
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
name|control
argument_list|(
name|getrq
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|flushi
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_if

begin_label
name|lt
label|:
end_label

begin_expr_stmt
name|ch
operator|=
name|i
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|text
argument_list|()
expr_stmt|;
end_expr_stmt

begin_goto
goto|goto
name|loop
goto|;
end_goto

begin_expr_stmt
unit|} catch
operator|(
operator|)
block|{
comment|/* 	prstr("Interrupt\n"); */
name|done3
argument_list|(
literal|01
argument_list|)
block|; }
name|fpecatch
argument_list|()
block|{
name|prstrfl
argument_list|(
literal|"Floating Exception.\n"
argument_list|)
block|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|fpecatch
argument_list|)
block|; }
name|kcatch
argument_list|()
block|{
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
block|;
name|done3
argument_list|(
literal|01
argument_list|)
block|; }
ifndef|#
directive|ifndef
name|NROFF
name|acctg
argument_list|()
block|{
specifier|static
name|char
operator|*
name|acct_file
operator|=
literal|"/usr/adm/tracct"
block|;
name|acctf
operator|=
name|open
argument_list|(
name|acct_file
argument_list|,
literal|1
argument_list|)
block|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
block|; }
endif|#
directive|endif
name|init1
argument_list|(
argument|a
argument_list|)
name|char
name|a
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
specifier|register
name|i
expr_stmt|;
ifndef|#
directive|ifndef
name|NROFF
name|acctg
argument_list|()
expr_stmt|;
comment|/*open troff actg file while mode 4755*/
endif|#
directive|endif
name|p
operator|=
name|mktemp
argument_list|(
literal|"/tmp/taXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|'a'
condition|)
name|p
operator|=
operator|&
name|p
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|close
argument_list|(
name|creat
argument_list|(
name|p
argument_list|,
literal|0600
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|prstr
argument_list|(
literal|"Cannot create temp file.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ibf
operator|=
name|open
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|256
init|;
operator|--
name|i
condition|;
control|)
name|trtab
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|trtab
index|[
name|UNPAD
index|]
operator|=
literal|' '
expr_stmt|;
name|mchbits
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|!=
literal|'a'
condition|)
name|unlkp
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_macro
name|init2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
specifier|extern
name|int
name|block
decl_stmt|;
specifier|extern
name|char
modifier|*
name|setbrk
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
name|ttyod
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ttyp
operator|=
name|ttyname
argument_list|(
name|j
operator|=
literal|0
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
operator|||
operator|(
operator|(
name|ttyp
operator|=
name|ttyname
argument_list|(
name|j
operator|=
literal|1
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
operator|||
operator|(
operator|(
name|ttyp
operator|=
name|ttyname
argument_list|(
name|j
operator|=
literal|2
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
condition|)
empty_stmt|;
else|else
name|ttyp
operator|=
literal|"notty"
expr_stmt|;
name|iflg
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|ascii
condition|)
name|mesg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|ptid
operator|)
operator|&&
operator|(
operator|!
name|waitf
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ptid
operator|=
name|open
argument_list|(
name|ptname
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|prstr
argument_list|(
literal|"Typesetter busy.\n"
argument_list|)
expr_stmt|;
name|done3
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|ptinit
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NEV
init|;
name|i
operator|--
condition|;
control|)
name|write
argument_list|(
name|ibf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|block
argument_list|,
name|EVS
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|olinep
operator|=
name|oline
expr_stmt|;
name|ibufp
operator|=
name|eibuf
operator|=
name|ibuf
expr_stmt|;
name|v
operator|.
name|hp
operator|=
name|init
operator|=
literal|0
expr_stmt|;
name|pinchar
operator|=
name|inchar
expr_stmt|;
comment|/* XXX */
name|ioff
operator|=
literal|0
expr_stmt|;
name|v
operator|.
name|nl
operator|=
operator|-
literal|1
expr_stmt|;
name|cvtime
argument_list|()
expr_stmt|;
name|frame
operator|=
name|stk
operator|=
operator|(
expr|struct
name|s
operator|*
operator|)
name|setbrk
argument_list|(
name|DELTA
argument_list|)
expr_stmt|;
name|dip
operator|=
operator|&
name|d
index|[
literal|0
index|]
expr_stmt|;
name|nxf
operator|=
name|frame
operator|+
literal|1
expr_stmt|;
name|nx
operator|=
name|mflg
expr_stmt|;
block|}
end_block

begin_macro
name|cvtime
argument_list|()
end_macro

begin_block
block|{
name|long
name|tt
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|time
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|tt
operator|-=
literal|3600
operator|*
name|ZONE
expr_stmt|;
comment|/*5hrs for EST*/
name|v
operator|.
name|dy
operator|=
operator|(
name|tt
operator|/
literal|86400L
operator|)
operator|+
literal|1
expr_stmt|;
name|v
operator|.
name|dw
operator|=
operator|(
name|v
operator|.
name|dy
operator|+
literal|3
operator|)
operator|%
literal|7
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|v
operator|.
name|yr
operator|=
literal|70
init|;
condition|;
name|v
operator|.
name|yr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|v
operator|.
name|yr
operator|)
operator|%
literal|4
condition|)
name|ms
index|[
literal|1
index|]
operator|=
literal|28
expr_stmt|;
else|else
name|ms
index|[
literal|1
index|]
operator|=
literal|29
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
control|)
block|{
if|if
condition|(
name|v
operator|.
name|dy
operator|<=
name|ms
index|[
name|i
index|]
condition|)
block|{
name|v
operator|.
name|mo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return;
block|}
name|v
operator|.
name|dy
operator|-=
name|ms
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|cnum
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|ibufp
operator|=
name|a
expr_stmt|;
name|eibuf
operator|=
name|MAXPTR
expr_stmt|;
name|i
operator|=
name|atoi
argument_list|()
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|mesg
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|ttyp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|stat
argument_list|(
name|ttyp
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
name|mode
operator|=
operator|(
operator|(
expr|struct
name|stat
operator|*
operator|)
operator|(
name|cbuf
operator|)
operator|)
operator|->
name|st_mode
expr_stmt|;
name|chmod
argument_list|(
name|ttyp
argument_list|,
name|mode
operator|&
operator|~
literal|022
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chmod
argument_list|(
name|ttyp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|prstrfl
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|flusho
argument_list|()
expr_stmt|;
name|prstr
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|prstr
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|j
decl_stmt|;
name|j
operator|=
name|s
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|s
condition|;
name|i
operator|++
control|)
name|s
operator|++
expr_stmt|;
name|write
argument_list|(
name|ttyod
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|control
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
specifier|extern
name|filep
name|boff
parameter_list|()
function_decl|;
name|i
operator|=
name|a
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|j
operator|=
name|findmn
argument_list|(
name|i
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|contab
index|[
name|j
index|]
operator|.
name|rq
operator|&
name|MMASK
condition|)
block|{
name|nxf
operator|->
name|nargs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
condition|)
name|collect
argument_list|()
expr_stmt|;
name|flushi
argument_list|()
expr_stmt|;
return|return
operator|(
name|pushi
argument_list|(
operator|(
operator|(
name|filep
operator|)
name|contab
index|[
name|j
index|]
operator|.
name|x
operator|.
name|mx
operator|)
operator|<<
name|BLKBITS
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|b
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|contab
index|[
name|j
index|]
operator|.
name|x
operator|.
name|f
operator|)
operator|(
literal|0
operator|)
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|getrq
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|=
name|getach
argument_list|()
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|j
operator|=
name|getach
argument_list|()
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|rtn
goto|;
name|i
operator|=
name|PAIR
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|rtn
label|:
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|getch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|level
operator|++
expr_stmt|;
name|g0
label|:
if|if
condition|(
name|ch
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|i
operator|=
name|ch
operator|)
operator|&
name|CMASK
operator|)
operator|==
literal|'\n'
condition|)
name|nlflg
operator|++
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
name|level
operator|--
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|nlflg
condition|)
block|{
name|level
operator|--
expr_stmt|;
return|return
operator|(
literal|'\n'
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|k
operator|=
operator|(
name|i
operator|=
name|getch0
argument_list|()
operator|)
operator|&
name|CMASK
operator|)
operator|!=
name|ESC
condition|)
block|{
if|if
condition|(
name|i
operator|&
name|MOT
condition|)
goto|goto
name|g2
goto|;
if|if
condition|(
name|k
operator|==
name|FLSS
condition|)
block|{
name|copyf
operator|++
expr_stmt|;
name|raw
operator|++
expr_stmt|;
name|i
operator|=
name|getch0
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fi
condition|)
name|flss
operator|=
name|i
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
name|raw
operator|--
expr_stmt|;
goto|goto
name|g0
goto|;
block|}
if|if
condition|(
name|k
operator|==
name|RPT
condition|)
block|{
name|setrpt
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
block|}
if|if
condition|(
operator|!
name|copyf
condition|)
block|{
if|if
condition|(
operator|(
name|k
operator|==
literal|'f'
operator|)
operator|&&
name|lg
operator|&&
operator|!
name|lgf
condition|)
block|{
name|i
operator|=
name|getlg
argument_list|(
name|i
argument_list|)
expr_stmt|;
goto|goto
name|g2
goto|;
block|}
if|if
condition|(
operator|(
name|k
operator|==
name|fc
operator|)
operator|||
operator|(
name|k
operator|==
name|tabch
operator|)
operator|||
operator|(
name|k
operator|==
name|ldrch
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|setfield
argument_list|(
name|k
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|g0
goto|;
else|else
goto|goto
name|g2
goto|;
block|}
if|if
condition|(
name|k
operator|==
literal|010
condition|)
block|{
name|i
operator|=
name|makem
argument_list|(
operator|-
name|width
argument_list|(
literal|' '
operator||
name|chbits
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|g2
goto|;
block|}
block|}
goto|goto
name|g2
goto|;
block|}
name|k
operator|=
operator|(
name|j
operator|=
name|getch0
argument_list|()
operator|)
operator|&
name|CMASK
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|MOT
condition|)
block|{
name|i
operator|=
name|j
expr_stmt|;
goto|goto
name|g2
goto|;
block|}
comment|/* 	if(k == tdelim){ 		i = TDELIM; 		tdelim = IMP; 		goto g2; 	} */
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/*concealed newline*/
goto|goto
name|g0
goto|;
case|case
literal|'n'
case|:
comment|/*number register*/
name|setn
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'*'
case|:
comment|/*string indicator*/
name|setstr
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'$'
case|:
comment|/*argument indicator*/
name|seta
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'{'
case|:
comment|/*LEFT*/
name|i
operator|=
name|LEFT
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'}'
case|:
comment|/*RIGHT*/
name|i
operator|=
name|RIGHT
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'"'
case|:
comment|/*comment*/
while|while
condition|(
operator|(
operator|(
name|i
operator|=
name|getch0
argument_list|()
operator|)
operator|&
name|CMASK
operator|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
goto|goto
name|g2
goto|;
case|case
name|ESC
case|:
comment|/*double backslash*/
name|i
operator|=
name|eschar
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'e'
case|:
comment|/*printable version of current eschar*/
name|i
operator|=
name|PRESC
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|' '
case|:
comment|/*unpaddable space*/
name|i
operator|=
name|UNPAD
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'|'
case|:
comment|/*narrow space*/
name|i
operator|=
name|NARSP
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'^'
case|:
comment|/*half of narrow space*/
name|i
operator|=
name|HNSP
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'\''
case|:
comment|/*\(aa*/
name|i
operator|=
literal|0222
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'`'
case|:
comment|/*\(ga*/
name|i
operator|=
literal|0223
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'_'
case|:
comment|/*\(ul*/
name|i
operator|=
literal|0224
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'-'
case|:
comment|/*current font minus*/
name|i
operator|=
literal|0210
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'&'
case|:
comment|/*filler*/
name|i
operator|=
name|FILLER
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'c'
case|:
comment|/*to be continued*/
name|i
operator|=
name|CONT
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|':'
case|:
comment|/*lem's char*/
name|i
operator|=
name|COLON
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'!'
case|:
comment|/*transparent indicator*/
name|i
operator|=
name|XPAR
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'t'
case|:
comment|/*tab*/
name|i
operator|=
literal|'\t'
expr_stmt|;
goto|goto
name|g2
goto|;
case|case
literal|'a'
case|:
comment|/*leader (SOH)*/
name|i
operator|=
name|LEADER
expr_stmt|;
goto|goto
name|g2
goto|;
case|case
literal|'%'
case|:
comment|/*ohc*/
name|i
operator|=
name|OHC
expr_stmt|;
goto|goto
name|g2
goto|;
case|case
literal|'.'
case|:
comment|/*.*/
name|i
operator|=
literal|'.'
expr_stmt|;
name|gx
label|:
name|i
operator|=
operator|(
name|j
operator|&
operator|~
name|CMASK
operator|)
operator||
name|i
expr_stmt|;
goto|goto
name|g2
goto|;
block|}
if|if
condition|(
operator|!
name|copyf
condition|)
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|'p'
case|:
comment|/*spread*/
name|spread
operator|++
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'('
case|:
comment|/*special char name*/
if|if
condition|(
operator|(
name|i
operator|=
name|setch
argument_list|()
operator|)
operator|==
literal|0
condition|)
goto|goto
name|g0
goto|;
break|break;
case|case
literal|'s'
case|:
comment|/*size indicator*/
name|setps
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'f'
case|:
comment|/*font indicator*/
name|setfont
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'w'
case|:
comment|/*width function*/
name|setwd
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'v'
case|:
comment|/*vert mot*/
if|if
condition|(
name|i
operator|=
name|vmot
argument_list|()
condition|)
break|break;
goto|goto
name|g0
goto|;
case|case
literal|'h'
case|:
comment|/*horiz mot*/
if|if
condition|(
name|i
operator|=
name|hmot
argument_list|()
condition|)
break|break;
goto|goto
name|g0
goto|;
case|case
literal|'z'
case|:
comment|/*zero with char*/
name|i
operator|=
name|setz
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/*hor line*/
name|setline
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'L'
case|:
comment|/*vert line*/
name|setvline
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'b'
case|:
comment|/*bracket*/
name|setbra
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'o'
case|:
comment|/*overstrike*/
name|setov
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'k'
case|:
comment|/*mark hor place*/
if|if
condition|(
operator|(
name|i
operator|=
name|findr
argument_list|(
name|getsn
argument_list|()
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|g0
goto|;
name|vlist
index|[
name|i
index|]
operator|=
name|v
operator|.
name|hp
operator|=
name|sumhp
argument_list|()
expr_stmt|;
comment|/* XXX */
goto|goto
name|g0
goto|;
case|case
literal|'j'
case|:
comment|/*mark output hor place*/
if|if
condition|(
operator|!
operator|(
name|i
operator|=
name|getach
argument_list|()
operator|)
condition|)
goto|goto
name|g0
goto|;
name|i
operator|=
operator|(
name|i
operator|<<
name|BYTE
operator|)
operator||
name|JREG
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/*number space*/
name|i
operator|=
name|makem
argument_list|(
name|width
argument_list|(
literal|'0'
operator||
name|chbits
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/*extra line space*/
if|if
condition|(
name|i
operator|=
name|xlss
argument_list|()
condition|)
break|break;
goto|goto
name|g0
goto|;
case|case
literal|'u'
case|:
comment|/*half em up*/
case|case
literal|'r'
case|:
comment|/*full em up*/
case|case
literal|'d'
case|:
comment|/*half em down*/
name|i
operator|=
name|sethl
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
default|default:
name|i
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
name|ch0
operator|=
name|j
expr_stmt|;
name|i
operator|=
name|eschar
expr_stmt|;
block|}
name|g2
label|:
if|if
condition|(
operator|(
name|i
operator|&
name|CMASK
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|nlflg
operator|++
expr_stmt|;
name|v
operator|.
name|hp
operator|=
literal|0
expr_stmt|;
name|pinchar
operator|=
name|inchar
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|ip
operator|==
literal|0
condition|)
name|v
operator|.
name|cd
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|--
name|level
condition|)
block|{
comment|/* j = width(i); */
comment|/* v.hp += j; */
comment|/* cwidth = j; */
if|if
condition|(
name|pinchar
operator|>=
name|inchar
operator|+
name|LNSIZE
condition|)
block|{
comment|/* XXX */
name|inchar
index|[
literal|0
index|]
operator|=
name|makem
argument_list|(
name|sumhp
argument_list|()
argument_list|)
expr_stmt|;
name|pinchar
operator|=
operator|&
name|inchar
index|[
literal|1
index|]
expr_stmt|;
block|}
operator|*
name|pinchar
operator|++
operator|=
name|i
expr_stmt|;
comment|/* XXX */
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|sumhp
argument_list|()
end_macro

begin_comment
comment|/* XXX - add up widths in inchar array */
end_comment

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
modifier|*
name|p
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|inchar
init|;
name|p
operator|<
name|pinchar
condition|;
name|p
operator|++
control|)
name|n
operator|+=
name|width
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|ifilt
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|001
block|,
literal|002
block|,
literal|003
block|,
literal|0
block|,
literal|005
block|,
literal|006
block|,
literal|007
block|,
literal|010
block|,
literal|011
block|,
literal|012
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|getch0
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|ch0
condition|)
block|{
name|i
operator|=
name|ch0
expr_stmt|;
name|ch0
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|nchar
condition|)
block|{
name|nchar
operator|--
expr_stmt|;
return|return
operator|(
name|rchar
operator|)
return|;
block|}
name|again
label|:
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
operator|*
name|cp
operator|++
operator|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|ap
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
operator|*
name|ap
operator|++
operator|)
operator|==
literal|0
condition|)
block|{
name|ap
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|ip
condition|)
block|{
if|if
condition|(
name|ip
operator|==
operator|-
literal|1
condition|)
name|i
operator|=
name|rdtty
argument_list|()
expr_stmt|;
else|else
name|i
operator|=
name|rbf
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|donef
condition|)
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|||
operator|(
operator|(
name|ibufp
operator|>=
name|eibuf
operator|)
operator|&&
operator|(
name|ibufp
operator|!=
name|MAXPTR
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|nfo
condition|)
goto|goto
name|g1
goto|;
name|g0
label|:
if|if
condition|(
name|nextfile
argument_list|()
condition|)
block|{
if|if
condition|(
name|ip
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|ibufp
operator|<
name|eibuf
condition|)
goto|goto
name|g2
goto|;
block|}
name|g1
label|:
name|nx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|read
argument_list|(
name|ifile
argument_list|,
name|ibuf
argument_list|,
name|IBUFSZ
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|g0
goto|;
name|ibufp
operator|=
name|ibuf
expr_stmt|;
name|eibuf
operator|=
name|ibuf
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|ip
condition|)
goto|goto
name|again
goto|;
block|}
name|g2
label|:
name|i
operator|=
operator|*
name|ibufp
operator|++
operator|&
literal|0177
expr_stmt|;
name|ioff
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|040
condition|)
goto|goto
name|g4
goto|;
else|else
name|i
operator|=
name|ifilt
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|raw
condition|)
return|return
operator|(
name|i
operator|)
return|;
if|if
condition|(
operator|(
name|j
operator|=
name|i
operator|&
name|CMASK
operator|)
operator|==
name|IMP
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|!
name|init
condition|)
goto|goto
name|again
goto|;
name|g4
label|:
if|if
condition|(
operator|(
name|copyf
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|i
operator|&
operator|~
name|BMASK
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|i
operator|&
name|CMASK
operator|)
operator|<
literal|0370
operator|)
condition|)
ifndef|#
directive|ifndef
name|NROFF
if|if
condition|(
name|spbits
operator|&&
operator|(
name|i
operator|>
literal|31
operator|)
operator|&&
operator|(
operator|(
name|codetab
index|[
name|i
operator|-
literal|32
index|]
operator|&
literal|0200
operator|)
operator|)
condition|)
name|i
operator||=
name|spbits
expr_stmt|;
else|else
endif|#
directive|endif
name|i
operator||=
name|chbits
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|CMASK
operator|)
operator|==
name|eschar
condition|)
name|i
operator|=
operator|(
name|i
operator|&
operator|~
name|CMASK
operator|)
operator||
name|ESC
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|nextfile
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|n0
label|:
if|if
condition|(
name|ifile
condition|)
name|close
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
condition|)
block|{
name|p
operator|=
name|nextf
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
goto|goto
name|n1
goto|;
block|}
if|if
condition|(
name|ifi
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|popf
argument_list|()
condition|)
goto|goto
name|n0
goto|;
comment|/*popf error*/
return|return
operator|(
literal|1
operator|)
return|;
comment|/*popf ok*/
block|}
if|if
condition|(
name|rargc
operator|--
operator|<=
literal|0
condition|)
goto|goto
name|n2
goto|;
name|p
operator|=
operator|(
name|argp
operator|++
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|n1
label|:
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|ifile
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifile
operator|=
name|open
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|prstr
argument_list|(
literal|"Cannot open "
argument_list|)
expr_stmt|;
name|prstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|prstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|nfo
operator|-=
name|mflg
expr_stmt|;
name|done
argument_list|(
literal|02
argument_list|)
expr_stmt|;
block|}
name|nfo
operator|++
expr_stmt|;
name|v
operator|.
name|cd
operator|=
literal|0
expr_stmt|;
name|ioff
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|n2
label|:
if|if
condition|(
operator|(
name|nfo
operator|-=
name|mflg
operator|)
operator|&&
operator|!
name|stdi
condition|)
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nfo
operator|++
expr_stmt|;
name|v
operator|.
name|cd
operator|=
name|ifile
operator|=
name|stdi
operator|=
name|mflg
operator|=
literal|0
expr_stmt|;
name|ioff
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|popf
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
name|ioff
operator|=
name|offl
index|[
operator|--
name|ifi
index|]
expr_stmt|;
name|ip
operator|=
name|ipl
index|[
name|ifi
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ifile
operator|=
name|ifl
index|[
name|ifi
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|xbuf
expr_stmt|;
name|q
operator|=
name|ibuf
expr_stmt|;
name|ibufp
operator|=
name|xbufp
expr_stmt|;
name|eibuf
operator|=
name|xeibuf
expr_stmt|;
while|while
condition|(
name|q
operator|<
name|eibuf
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|lseek
argument_list|(
name|ifile
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ioff
operator|&
operator|~
operator|(
name|IBUFSZ
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|ifile
argument_list|,
name|ibuf
argument_list|,
name|IBUFSZ
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|eibuf
operator|=
name|ibuf
operator|+
name|i
expr_stmt|;
name|ibufp
operator|=
name|ibuf
expr_stmt|;
if|if
condition|(
name|ttyname
argument_list|(
name|ifile
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
if|if
condition|(
operator|(
name|ibufp
operator|=
name|ibuf
operator|+
call|(
name|int
call|)
argument_list|(
name|ioff
operator|&
operator|(
name|IBUFSZ
operator|-
literal|1
operator|)
argument_list|)
operator|)
operator|>=
name|eibuf
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|flushi
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|nflush
condition|)
return|return;
name|ch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ch0
operator|&
name|CMASK
operator|)
operator|==
literal|'\n'
condition|)
name|nlflg
operator|++
expr_stmt|;
name|ch0
operator|=
literal|0
expr_stmt|;
name|copyf
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|nlflg
condition|)
block|{
if|if
condition|(
name|donef
operator|&&
operator|(
name|frame
operator|==
name|stk
operator|)
condition|)
break|break;
name|getch
argument_list|()
expr_stmt|;
block|}
name|copyf
operator|--
expr_stmt|;
name|v
operator|.
name|hp
operator|=
literal|0
expr_stmt|;
name|pinchar
operator|=
name|inchar
expr_stmt|;
comment|/* XXX */
block|}
end_block

begin_macro
name|getach
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|lgf
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|=
name|getch
argument_list|()
operator|)
operator|&
name|MOT
operator|)
operator|||
operator|(
operator|(
name|i
operator|&
name|CMASK
operator|)
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|(
name|i
operator|&
name|CMASK
operator|)
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|i
operator|&
literal|0200
operator|)
condition|)
block|{
name|ch
operator|=
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|lgf
operator|--
expr_stmt|;
return|return
operator|(
name|i
operator|&
literal|0177
operator|)
return|;
block|}
end_block

begin_macro
name|casenx
argument_list|()
end_macro

begin_block
block|{
name|lgf
operator|++
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
name|getname
argument_list|()
expr_stmt|;
name|nx
operator|++
expr_stmt|;
name|nextfile
argument_list|()
expr_stmt|;
name|nlflg
operator|++
expr_stmt|;
name|ip
operator|=
literal|0
expr_stmt|;
name|ap
operator|=
literal|0
expr_stmt|;
name|nchar
operator|=
name|pendt
operator|=
literal|0
expr_stmt|;
name|frame
operator|=
name|stk
expr_stmt|;
name|nxf
operator|=
name|frame
operator|+
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|getname
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|lgf
operator|++
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|NS
operator|-
literal|1
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|j
operator|=
operator|(
name|i
operator|=
name|getch
argument_list|()
operator|)
operator|&
name|CMASK
operator|)
operator|<=
literal|' '
operator|)
operator|||
operator|(
name|j
operator|>
literal|0176
operator|)
condition|)
break|break;
name|nextf
index|[
name|k
index|]
operator|=
name|j
expr_stmt|;
block|}
name|nextf
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|i
expr_stmt|;
name|lgf
operator|--
expr_stmt|;
return|return
operator|(
name|nextf
index|[
literal|0
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|caseso
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|lgf
operator|++
expr_stmt|;
name|nextf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip
argument_list|()
operator|||
operator|!
name|getname
argument_list|()
operator|||
operator|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|nextf
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|ifi
operator|>=
name|NSO
operator|)
condition|)
block|{
name|prstr
argument_list|(
literal|"can't open file "
argument_list|)
expr_stmt|;
name|prstr
argument_list|(
name|nextf
argument_list|)
expr_stmt|;
name|prstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|02
argument_list|)
expr_stmt|;
block|}
name|flushi
argument_list|()
expr_stmt|;
name|ifl
index|[
name|ifi
index|]
operator|=
name|ifile
expr_stmt|;
name|ifile
operator|=
name|i
expr_stmt|;
name|offl
index|[
name|ifi
index|]
operator|=
name|ioff
expr_stmt|;
name|ioff
operator|=
literal|0
expr_stmt|;
name|ipl
index|[
name|ifi
index|]
operator|=
name|ip
expr_stmt|;
name|ip
operator|=
literal|0
expr_stmt|;
name|nx
operator|++
expr_stmt|;
name|nflush
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ifl
index|[
name|ifi
operator|++
index|]
condition|)
block|{
name|p
operator|=
name|ibuf
expr_stmt|;
name|q
operator|=
name|xbuf
expr_stmt|;
name|xbufp
operator|=
name|ibufp
expr_stmt|;
name|xeibuf
operator|=
name|eibuf
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|eibuf
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|casecf
argument_list|()
end_macro

begin_block
block|{
comment|/* copy file without change */
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|char
name|buf
index|[
name|OBUFSZ
index|]
decl_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|lgf
operator|++
expr_stmt|;
name|nextf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip
argument_list|()
operator|||
operator|!
name|getname
argument_list|()
operator|||
operator|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|nextf
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|ifi
operator|>=
name|NSO
operator|)
condition|)
block|{
name|prstr
argument_list|(
literal|"can't open file "
argument_list|)
expr_stmt|;
name|prstr
argument_list|(
name|nextf
argument_list|)
expr_stmt|;
name|prstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|02
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|OBUFSZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|oput
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getpn
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|neg
expr_stmt|;
name|long
name|atoi1
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
operator|*
name|a
operator|&
literal|0177
operator|)
operator|==
literal|0
condition|)
return|return;
name|neg
operator|=
literal|0
expr_stmt|;
name|ibufp
operator|=
name|a
expr_stmt|;
name|eibuf
operator|=
name|MAXPTR
expr_stmt|;
name|noscale
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getch
argument_list|()
operator|&
name|CMASK
operator|)
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|','
case|:
continue|continue;
case|case
literal|'-'
case|:
name|neg
operator|=
name|MOT
expr_stmt|;
goto|goto
name|d2
goto|;
default|default:
name|ch
operator|=
name|i
expr_stmt|;
name|d2
label|:
name|i
operator|=
name|atoi1
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonumb
condition|)
goto|goto
name|fini
goto|;
else|else
block|{
operator|*
name|pnp
operator|++
operator|=
name|i
operator||
name|neg
expr_stmt|;
name|neg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pnp
operator|>=
operator|&
name|pnlist
index|[
name|NPN
operator|-
literal|2
index|]
condition|)
block|{
name|prstr
argument_list|(
literal|"Too many page numbers\n"
argument_list|)
expr_stmt|;
name|done3
argument_list|(
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fini
label|:
if|if
condition|(
name|neg
condition|)
operator|*
name|pnp
operator|++
operator|=
operator|-
literal|2
expr_stmt|;
operator|*
name|pnp
operator|=
operator|-
literal|1
expr_stmt|;
name|ch
operator|=
name|noscale
operator|=
name|print
operator|=
literal|0
expr_stmt|;
name|pnp
operator|=
name|pnlist
expr_stmt|;
if|if
condition|(
operator|*
name|pnp
operator|!=
operator|-
literal|1
condition|)
name|chkpn
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|setrpt
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|copyf
operator|++
expr_stmt|;
name|raw
operator|++
expr_stmt|;
name|i
operator|=
name|getch0
argument_list|()
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
name|raw
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|j
operator|=
name|getch0
argument_list|()
operator|)
operator|&
name|CMASK
operator|)
operator|==
name|RPT
operator|)
condition|)
return|return;
name|rchar
operator|=
name|j
expr_stmt|;
name|nchar
operator|=
name|i
operator|&
name|BMASK
expr_stmt|;
block|}
end_block

end_unit

