begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)atrm.c	1.3	(Berkeley)	%G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  *	synopsis: atrm [-f] [-i] [-] [[job #] [user] ...]  *  *  *	Remove files from the directory /usr/spool/at. These files  *	represent jobs to be run at a later date.  *  *	Author: Steve Wall  *		Computer Systems Research Group  *		University of California @ Berkeley  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|SUPERUSER
value|0
end_define

begin_comment
comment|/* is user super-user? */
end_comment

begin_define
define|#
directive|define
name|MAXENTRIES
value|1000
end_define

begin_comment
comment|/* max # of entries allowed */
end_comment

begin_define
define|#
directive|define
name|ATDIR
value|"/usr/spool/at"
end_define

begin_comment
comment|/* spooling area */
end_comment

begin_decl_stmt
name|int
name|user
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* person requesting removal */
end_comment

begin_decl_stmt
name|int
name|fflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* suppress announcements? */
end_comment

begin_decl_stmt
name|int
name|iflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* run interactively? */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* for loop index */
name|int
name|userid
decl_stmt|;
comment|/* uid of owner of file */
name|int
name|isuname
decl_stmt|;
comment|/* is a command line argv a user name?*/
name|int
name|numjobs
decl_stmt|;
comment|/* # of jobs in spooling area */
name|int
name|usage
parameter_list|()
function_decl|;
comment|/* print usage info and exit */
name|int
name|allflag
init|=
literal|0
decl_stmt|;
comment|/* remove all jobs belonging to user? */
name|int
name|jobexists
decl_stmt|;
comment|/* does a requested job exist? */
name|int
name|alphasort
parameter_list|()
function_decl|;
comment|/* sort jobs by date of execution */
name|int
name|filewanted
parameter_list|()
function_decl|;
comment|/* should a file be listed in queue? */
name|char
modifier|*
name|getname
parameter_list|()
function_decl|;
comment|/* get a user name from a uid */
name|struct
name|stat
modifier|*
name|statptr
decl_stmt|;
comment|/* pointer to file stat structure */
name|struct
name|stat
modifier|*
name|stbuf
index|[
name|MAXENTRIES
index|]
decl_stmt|;
comment|/* array of pointers to stat structs */
name|struct
name|direct
modifier|*
modifier|*
name|namelist
decl_stmt|;
comment|/* names of jobs in spooling area */
comment|/* 	 * If job number, user name, or "-" is not specified, just print 	 * usage info and exit. 	 */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
comment|/* 	 * Process command line flags. 	 */
while|while
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
operator|(
operator|*
name|argv
operator|)
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
case|case
literal|'\0'
case|:
operator|++
name|allflag
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|++
name|fflag
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
operator|++
name|iflag
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
block|}
comment|/* 	 * If all jobs are to be removed and extra command line arguments  	 * are given, print usage info and exit. 	 */
if|if
condition|(
name|allflag
operator|&&
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* 	 * If only certain jobs are to be removed and no job #'s or user 	 * names are specified, print usage info and exit. 	 */
if|if
condition|(
operator|!
name|allflag
operator|&&
operator|!
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* 	 * If interactive removal and quiet removal are requested, override 	 * quiet removal and run interactively. 	 */
if|if
condition|(
name|iflag
operator|&&
name|fflag
condition|)
name|fflag
operator|=
literal|0
expr_stmt|;
comment|/*  	 * Move to spooling area and get user id of person requesting removal. 	 */
if|if
condition|(
name|chdir
argument_list|(
name|ATDIR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|ATDIR
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|user
operator|=
name|getuid
argument_list|()
expr_stmt|;
comment|/* 	 * Get a list of the files in the spooling area. 	 */
if|if
condition|(
operator|(
name|numjobs
operator|=
name|scandir
argument_list|(
literal|"."
argument_list|,
operator|&
name|namelist
argument_list|,
name|filewanted
argument_list|,
name|alphasort
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|ATDIR
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Build an array of pointers to the file stats for all jobs in 	 * the spooling area. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numjobs
condition|;
operator|++
name|i
control|)
block|{
name|statptr
operator|=
operator|(
expr|struct
name|stat
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|statptr
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|namelist
index|[
name|i
index|]
operator|->
name|d_name
argument_list|,
name|statptr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"stat"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|stbuf
index|[
name|i
index|]
operator|=
name|statptr
expr_stmt|;
block|}
comment|/* 	 * If all jobs belonging to the user are to be removed, compare 	 * the user's id to the owner of the file. If they match, remove 	 * the file. If the user is the super-user, don't bother comparing 	 * the id's. After all files are removed, exit (status 0). 	 */
if|if
condition|(
name|allflag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numjobs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|user
operator|==
name|SUPERUSER
operator|||
name|isowner
argument_list|(
name|getname
argument_list|(
name|user
argument_list|)
argument_list|,
name|namelist
index|[
name|i
index|]
operator|->
name|d_name
argument_list|)
condition|)
name|removentry
argument_list|(
name|namelist
index|[
name|i
index|]
operator|->
name|d_name
argument_list|,
operator|(
name|int
operator|)
name|stbuf
index|[
name|i
index|]
operator|->
name|st_ino
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If only certain jobs are to be removed, interpret each command 	 * line argument. A check is done to see if it is a user's name or 	 * a job number (inode #). If it's a user's name, compare the argument 	 * to the files owner. If it's a job number, compare the argument to 	 * the inode number of the file. In either case, if a match occurs, 	 * try to remove the file. (The function "isusername" scans the 	 * argument to see if it is all digits which we will assume means  	 * that it's a job number (a fairly safe assumption?). This is done 	 * because we have to determine whether we are dealing with a user 	 * name or a job number. By assuming that only arguments that are 	 * all digits is a job number, we allow users to have digits in 	 * their login name i.e. "johndoe2"). 	 */
while|while
condition|(
name|argc
operator|--
condition|)
block|{
name|jobexists
operator|=
literal|0
expr_stmt|;
name|isuname
operator|=
name|isusername
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numjobs
condition|;
operator|++
name|i
control|)
block|{
comment|/*  			 * if argv is a username, compare his/her uid to 			 * the uid of the owner of the file...... 			 */
if|if
condition|(
name|isuname
condition|)
block|{
if|if
condition|(
operator|!
name|isowner
argument_list|(
operator|*
name|argv
argument_list|,
name|namelist
index|[
name|i
index|]
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
comment|/* 			 * otherwise, we assume that the argv is a job # and 			 * thus compare argv to the inode (job #) of the file. 			 */
block|}
else|else
block|{
if|if
condition|(
name|stbuf
index|[
name|i
index|]
operator|->
name|st_ino
operator|!=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
condition|)
continue|continue;
block|}
operator|++
name|jobexists
expr_stmt|;
name|removentry
argument_list|(
name|namelist
index|[
name|i
index|]
operator|->
name|d_name
argument_list|,
operator|(
name|int
operator|)
name|stbuf
index|[
name|i
index|]
operator|->
name|st_ino
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If a requested argument doesn't exist, print a message. 		 */
if|if
condition|(
operator|!
name|jobexists
operator|&&
operator|!
name|fflag
operator|&&
operator|!
name|isuname
condition|)
block|{
name|printf
argument_list|(
literal|"%6s: no such job number\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
operator|++
name|argv
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print usage info and exit.  */
end_comment

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: atrm [-f] [-i] [-] [[job #] [user] ...]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do we want to include a file in the queue? (used by "scandir") We are looking  * for files with following syntax: yy.ddd.hhhh. so the test is made to see if   * the file name has three dots in it. This test will suffice since the only  * other files in /usr/spool/at don't have any dots in their name.  */
end_comment

begin_macro
name|filewanted
argument_list|(
argument|direntry
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|direct
modifier|*
name|direntry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|numdot
init|=
literal|0
decl_stmt|;
comment|/* number of dots in a filename */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* filename we are looking at */
name|filename
operator|=
name|direntry
operator|->
name|d_name
expr_stmt|;
while|while
condition|(
operator|*
name|filename
condition|)
name|numdot
operator|+=
operator|(
operator|*
operator|(
name|filename
operator|++
operator|)
operator|==
literal|'.'
operator|)
expr_stmt|;
return|return
operator|(
name|numdot
operator|==
literal|3
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Is a command line argument a username? As noted above we will assume   * that an argument that is all digits means that it's a job number, not  * a user's name. We choose to determine whether an argument is a user name  * in this manner because then it's ok for someone to have digits in their   * user name.  */
end_comment

begin_macro
name|isusername
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* pointer used for scanning string */
name|ptr
operator|=
name|string
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|++
name|ptr
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|ptr
operator|==
literal|'\0'
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Remove an entry from the queue. The access of the file is checked for  * write permission (since all jobs are mode 644). If access is granted,  * unlink the file. If the fflag (suppress announcements) is not set,  * print the job number that we are removing and the result of the access  * check (either "permission denied" or "removed"). If we are running   * interactively (iflag), prompt the user before we unlink the file. If   * the super-user is removing jobs, inform him/her who owns each file before   * it is removed.  */
end_comment

begin_macro
name|removentry
argument_list|(
argument|filename
argument_list|,
argument|inode
argument_list|,
argument|user
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|user
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|printf
argument_list|(
literal|"%6d: "
argument_list|,
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isowner
argument_list|(
name|getname
argument_list|(
name|user
argument_list|)
argument_list|,
name|filename
argument_list|)
operator|&&
name|user
operator|!=
name|SUPERUSER
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
block|{
name|printf
argument_list|(
literal|"permission denied\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|iflag
condition|)
block|{
if|if
condition|(
name|user
operator|==
name|SUPERUSER
condition|)
block|{
name|printf
argument_list|(
literal|"\t(owned by "
argument_list|)
expr_stmt|;
name|powner
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"remove it? "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
return|return;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|filename
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
block|{
name|fputs
argument_list|(
literal|"FATAL ERROR (unlink fails): "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|fflag
operator|&&
operator|!
name|iflag
condition|)
name|printf
argument_list|(
literal|"removed\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * See if "name" owns "job".  */
end_comment

begin_macro
name|isowner
argument_list|(
argument|name
argument_list|,
argument|job
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|job
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
comment|/* buffer for 1st line of spoolfile  					   header */
name|FILE
modifier|*
name|infile
decl_stmt|;
comment|/* I/O stream to spoolfile */
if|if
condition|(
operator|(
name|infile
operator|=
name|fopen
argument_list|(
name|job
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't open spoolfile"
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"# owner: %s\n"
argument_list|,
name|buf
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|close
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Print the owner of the job. This is stored on the first line of the  * spoolfile. If we run into trouble getting the name, we'll just print "???".  */
end_comment

begin_macro
name|powner
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|owner
index|[
literal|80
index|]
decl_stmt|;
comment|/* the owner */
name|FILE
modifier|*
name|infile
decl_stmt|;
comment|/* I/O stream to spoolfile */
comment|/* 	 * Open the job file and grab the first line. 	 */
if|if
condition|(
operator|(
name|infile
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
literal|"???"
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"# owner: %s"
argument_list|,
name|owner
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
literal|"???"
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return;
block|}
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|owner
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get answer to interactive prompts, eating all characters beyond the first  * one. If a 'y' is typed, return 1.  */
end_comment

begin_macro
name|yes
argument_list|()
end_macro

begin_block
block|{
name|char
name|ch
decl_stmt|;
comment|/* dummy variable */
name|char
name|ch1
decl_stmt|;
comment|/* dummy variable */
name|ch
operator|=
name|ch1
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|ch1
operator|!=
literal|'\n'
operator|&&
name|ch1
operator|!=
name|EOF
condition|)
name|ch1
operator|=
name|getchar
argument_list|()
expr_stmt|;
return|return
operator|(
name|ch
operator|==
literal|'y'
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get the uid of a person using his/her login name. Return -1 if no  * such account name exists.  */
end_comment

begin_macro
name|getid
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|passwd
modifier|*
name|pwdinfo
decl_stmt|;
comment|/* password info structure */
if|if
condition|(
operator|(
name|pwdinfo
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|pwdinfo
operator|->
name|pw_uid
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get the full login name of a person using his/her user id.  */
end_comment

begin_function
name|char
modifier|*
name|getname
parameter_list|(
name|uid
parameter_list|)
name|int
name|uid
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pwdinfo
decl_stmt|;
comment|/* password info structure */
if|if
condition|(
operator|(
name|pwdinfo
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|"???"
operator|)
return|;
return|return
operator|(
name|pwdinfo
operator|->
name|pw_name
operator|)
return|;
block|}
end_function

end_unit

