begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Analyze file differences for GNU DIFF.    Copyright (C) 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU DIFF; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* The basic algorithm is described in:     "An O(ND) Difference Algorithm and its Variations", Eugene Myers,    Algorithmica Vol. 1 No. 2, 1986, p 251.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_function_decl
name|struct
name|change
modifier|*
name|find_change
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|finish_output
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_context_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_context_script
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_ed_script
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_ifdef_script
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_normal_script
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_rcs_script
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pr_forward_ed_script
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|setup_output
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|no_discards
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|xvec
decl_stmt|,
modifier|*
name|yvec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vectors being compared. */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|fdiag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector, indexed by diagonal, containing 				   the X coordinate of the point furthest 				   along the given diagonal in the forward 				   search of the edit matrix. */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|bdiag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector, indexed by diagonal, containing 				   the X coordinate of the point furthest 				   along the given diagonal in the backward 				   search of the edit matrix. */
end_comment

begin_comment
comment|/* Find the midpoint of the shortest edit script for a specified    portion of the two files.     We scan from the beginnings of the files, and simultaneously from the ends,    doing a breadth-first search through the space of edit-sequence.    When the two searches meet, we have found the midpoint of the shortest    edit sequence.     The value returned is the number of the diagonal on which the midpoint lies.    The diagonal number equals the number of inserted lines minus the number    of deleted lines (counting only lines before the midpoint).    The edit cost is stored into *COST; this is the total number of    lines inserted or deleted (counting only lines before the midpoint).     This function assumes that the first lines of the specified portions    of the two files do not match, and likewise that the last lines do not    match.  The caller must trim matching lines from the beginning and end    of the portions it is going to specify.     Note that if we return the "wrong" diagonal value, or if    the value of bdiag at that diagonal is "wrong",    the worst this can do is cause suboptimal diff output.    It cannot cause incorrect diff output.  */
end_comment

begin_function
specifier|static
name|int
name|diag
parameter_list|(
name|xoff
parameter_list|,
name|xlim
parameter_list|,
name|yoff
parameter_list|,
name|ylim
parameter_list|,
name|cost
parameter_list|)
name|int
name|xoff
decl_stmt|,
name|xlim
decl_stmt|,
name|yoff
decl_stmt|,
name|ylim
decl_stmt|;
name|int
modifier|*
name|cost
decl_stmt|;
block|{
name|int
modifier|*
specifier|const
name|fd
init|=
name|fdiag
decl_stmt|;
comment|/* Give the compiler a chance. */
name|int
modifier|*
specifier|const
name|bd
init|=
name|bdiag
decl_stmt|;
comment|/* Additional help for the compiler. */
name|int
modifier|*
specifier|const
name|xv
init|=
name|xvec
decl_stmt|;
comment|/* Still more help for the compiler. */
name|int
modifier|*
specifier|const
name|yv
init|=
name|yvec
decl_stmt|;
comment|/* And more and more . . . */
specifier|const
name|int
name|dmin
init|=
name|xoff
operator|-
name|ylim
decl_stmt|;
comment|/* Minimum valid diagonal. */
specifier|const
name|int
name|dmax
init|=
name|xlim
operator|-
name|yoff
decl_stmt|;
comment|/* Maximum valid diagonal. */
specifier|const
name|int
name|fmid
init|=
name|xoff
operator|-
name|yoff
decl_stmt|;
comment|/* Center diagonal of top-down search. */
specifier|const
name|int
name|bmid
init|=
name|xlim
operator|-
name|ylim
decl_stmt|;
comment|/* Center diagonal of bottom-up search. */
name|int
name|fmin
init|=
name|fmid
decl_stmt|,
name|fmax
init|=
name|fmid
decl_stmt|;
comment|/* Limits of top-down search. */
name|int
name|bmin
init|=
name|bmid
decl_stmt|,
name|bmax
init|=
name|bmid
decl_stmt|;
comment|/* Limits of bottom-up search. */
name|int
name|c
decl_stmt|;
comment|/* Cost. */
name|int
name|odd
init|=
name|fmid
operator|-
name|bmid
operator|&
literal|1
decl_stmt|;
comment|/* True if southeast corner is on an odd 				   diagonal with respect to the northwest. */
name|fd
index|[
name|fmid
index|]
operator|=
name|xoff
expr_stmt|;
name|bd
index|[
name|bmid
index|]
operator|=
name|xlim
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
condition|;
operator|++
name|c
control|)
block|{
name|int
name|d
decl_stmt|;
comment|/* Active diagonal. */
name|int
name|big_snake
init|=
literal|0
decl_stmt|;
comment|/* Extend the top-down search by an edit step in each diagonal. */
name|fmin
operator|>
name|dmin
condition|?
name|fd
index|[
operator|--
name|fmin
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
else|:
operator|++
name|fmin
expr_stmt|;
name|fmax
operator|<
name|dmax
condition|?
name|fd
index|[
operator|++
name|fmax
operator|+
literal|1
index|]
operator|=
operator|-
literal|1
else|:
operator|--
name|fmax
expr_stmt|;
for|for
control|(
name|d
operator|=
name|fmax
init|;
name|d
operator|>=
name|fmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|oldx
decl_stmt|,
name|tlo
init|=
name|fd
index|[
name|d
operator|-
literal|1
index|]
decl_stmt|,
name|thi
init|=
name|fd
index|[
name|d
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|tlo
operator|>=
name|thi
condition|)
name|x
operator|=
name|tlo
operator|+
literal|1
expr_stmt|;
else|else
name|x
operator|=
name|thi
expr_stmt|;
name|oldx
operator|=
name|x
expr_stmt|;
name|y
operator|=
name|x
operator|-
name|d
expr_stmt|;
while|while
condition|(
name|x
operator|<
name|xlim
operator|&&
name|y
operator|<
name|ylim
operator|&&
name|xv
index|[
name|x
index|]
operator|==
name|yv
index|[
name|y
index|]
condition|)
operator|++
name|x
operator|,
operator|++
name|y
expr_stmt|;
if|if
condition|(
name|x
operator|-
name|oldx
operator|>
literal|20
condition|)
name|big_snake
operator|=
literal|1
expr_stmt|;
name|fd
index|[
name|d
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|odd
operator|&&
name|bmin
operator|<=
name|d
operator|&&
name|d
operator|<=
name|bmax
operator|&&
name|bd
index|[
name|d
index|]
operator|<=
name|fd
index|[
name|d
index|]
condition|)
block|{
operator|*
name|cost
operator|=
literal|2
operator|*
name|c
operator|-
literal|1
expr_stmt|;
return|return
name|d
return|;
block|}
block|}
comment|/* Similar extend the bottom-up search. */
name|bmin
operator|>
name|dmin
condition|?
name|bd
index|[
operator|--
name|bmin
operator|-
literal|1
index|]
operator|=
name|INT_MAX
else|:
operator|++
name|bmin
expr_stmt|;
name|bmax
operator|<
name|dmax
condition|?
name|bd
index|[
operator|++
name|bmax
operator|+
literal|1
index|]
operator|=
name|INT_MAX
else|:
operator|--
name|bmax
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bmax
init|;
name|d
operator|>=
name|bmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|oldx
decl_stmt|,
name|tlo
init|=
name|bd
index|[
name|d
operator|-
literal|1
index|]
decl_stmt|,
name|thi
init|=
name|bd
index|[
name|d
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|tlo
operator|<
name|thi
condition|)
name|x
operator|=
name|tlo
expr_stmt|;
else|else
name|x
operator|=
name|thi
operator|-
literal|1
expr_stmt|;
name|oldx
operator|=
name|x
expr_stmt|;
name|y
operator|=
name|x
operator|-
name|d
expr_stmt|;
while|while
condition|(
name|x
operator|>
name|xoff
operator|&&
name|y
operator|>
name|yoff
operator|&&
name|xv
index|[
name|x
operator|-
literal|1
index|]
operator|==
name|yv
index|[
name|y
operator|-
literal|1
index|]
condition|)
operator|--
name|x
operator|,
operator|--
name|y
expr_stmt|;
if|if
condition|(
name|oldx
operator|-
name|x
operator|>
literal|20
condition|)
name|big_snake
operator|=
literal|1
expr_stmt|;
name|bd
index|[
name|d
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|odd
operator|&&
name|fmin
operator|<=
name|d
operator|&&
name|d
operator|<=
name|fmax
operator|&&
name|bd
index|[
name|d
index|]
operator|<=
name|fd
index|[
name|d
index|]
condition|)
block|{
operator|*
name|cost
operator|=
literal|2
operator|*
name|c
expr_stmt|;
return|return
name|d
return|;
block|}
block|}
comment|/* Heuristic: check occasionally for a diagonal that has made 	 lots of progress compared with the edit distance. 	 If we have any such, find the one that has made the most 	 progress and return it as if it had succeeded.  	 With this heuristic, for files with a constant small density 	 of changes, the algorithm is linear in the file size.  */
if|if
condition|(
name|c
operator|>
literal|200
operator|&&
name|big_snake
operator|&&
name|heuristic
condition|)
block|{
name|int
name|best
decl_stmt|;
name|int
name|bestpos
decl_stmt|;
name|best
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|fmax
init|;
name|d
operator|>=
name|fmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|dd
init|=
name|d
operator|-
name|fmid
decl_stmt|;
if|if
condition|(
operator|(
name|fd
index|[
name|d
index|]
operator|-
name|xoff
operator|)
operator|*
literal|2
operator|-
name|dd
operator|>
literal|12
operator|*
operator|(
name|c
operator|+
operator|(
name|dd
operator|>
literal|0
condition|?
name|dd
else|:
operator|-
name|dd
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|fd
index|[
name|d
index|]
operator|*
literal|2
operator|-
name|dd
operator|>
name|best
operator|&&
name|fd
index|[
name|d
index|]
operator|-
name|xoff
operator|>
literal|20
operator|&&
name|fd
index|[
name|d
index|]
operator|-
name|d
operator|-
name|yoff
operator|>
literal|20
condition|)
block|{
name|int
name|k
decl_stmt|;
name|int
name|x
init|=
name|fd
index|[
name|d
index|]
decl_stmt|;
comment|/* We have a good enough best diagonal; 			 now insist that it end with a significant snake.  */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
literal|20
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|xvec
index|[
name|x
operator|-
name|k
index|]
operator|!=
name|yvec
index|[
name|x
operator|-
name|d
operator|-
name|k
index|]
condition|)
break|break;
if|if
condition|(
name|k
operator|==
literal|21
condition|)
block|{
name|best
operator|=
name|fd
index|[
name|d
index|]
operator|*
literal|2
operator|-
name|dd
expr_stmt|;
name|bestpos
operator|=
name|d
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|best
operator|>
literal|0
condition|)
block|{
operator|*
name|cost
operator|=
literal|2
operator|*
name|c
operator|-
literal|1
expr_stmt|;
return|return
name|bestpos
return|;
block|}
name|best
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bmax
init|;
name|d
operator|>=
name|bmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|dd
init|=
name|d
operator|-
name|bmid
decl_stmt|;
if|if
condition|(
operator|(
name|xlim
operator|-
name|bd
index|[
name|d
index|]
operator|)
operator|*
literal|2
operator|+
name|dd
operator|>
literal|12
operator|*
operator|(
name|c
operator|+
operator|(
name|dd
operator|>
literal|0
condition|?
name|dd
else|:
operator|-
name|dd
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|xlim
operator|-
name|bd
index|[
name|d
index|]
operator|)
operator|*
literal|2
operator|+
name|dd
operator|>
name|best
operator|&&
name|xlim
operator|-
name|bd
index|[
name|d
index|]
operator|>
literal|20
operator|&&
name|ylim
operator|-
operator|(
name|bd
index|[
name|d
index|]
operator|-
name|d
operator|)
operator|>
literal|20
condition|)
block|{
comment|/* We have a good enough best diagonal; 			 now insist that it end with a significant snake.  */
name|int
name|k
decl_stmt|;
name|int
name|x
init|=
name|bd
index|[
name|d
index|]
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|20
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|xvec
index|[
name|x
operator|+
name|k
index|]
operator|!=
name|yvec
index|[
name|x
operator|-
name|d
operator|+
name|k
index|]
condition|)
break|break;
if|if
condition|(
name|k
operator|==
literal|20
condition|)
block|{
name|best
operator|=
operator|(
name|xlim
operator|-
name|bd
index|[
name|d
index|]
operator|)
operator|*
literal|2
operator|+
name|dd
expr_stmt|;
name|bestpos
operator|=
name|d
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|best
operator|>
literal|0
condition|)
block|{
operator|*
name|cost
operator|=
literal|2
operator|*
name|c
operator|-
literal|1
expr_stmt|;
return|return
name|bestpos
return|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare in detail contiguous subsequences of the two files    which are known, as a whole, to match each other.     The results are recorded in the vectors files[N].changed_flag, by    storing a 1 in the element for each line that is an insertion or deletion.     The subsequence of file 0 is [XOFF, XLIM) and likewise for file 1.     Note that XLIM, YLIM are exclusive bounds.    All line numbers are origin-0 and discarded lines are not counted.  */
end_comment

begin_function
specifier|static
name|void
name|compareseq
parameter_list|(
name|xoff
parameter_list|,
name|xlim
parameter_list|,
name|yoff
parameter_list|,
name|ylim
parameter_list|)
name|int
name|xoff
decl_stmt|,
name|xlim
decl_stmt|,
name|yoff
decl_stmt|,
name|ylim
decl_stmt|;
block|{
comment|/* Slide down the bottom initial diagonal. */
while|while
condition|(
name|xoff
operator|<
name|xlim
operator|&&
name|yoff
operator|<
name|ylim
operator|&&
name|xvec
index|[
name|xoff
index|]
operator|==
name|yvec
index|[
name|yoff
index|]
condition|)
operator|++
name|xoff
operator|,
operator|++
name|yoff
expr_stmt|;
comment|/* Slide up the top initial diagonal. */
while|while
condition|(
name|xlim
operator|>
name|xoff
operator|&&
name|ylim
operator|>
name|yoff
operator|&&
name|xvec
index|[
name|xlim
operator|-
literal|1
index|]
operator|==
name|yvec
index|[
name|ylim
operator|-
literal|1
index|]
condition|)
operator|--
name|xlim
operator|,
operator|--
name|ylim
expr_stmt|;
comment|/* Handle simple cases. */
if|if
condition|(
name|xoff
operator|==
name|xlim
condition|)
while|while
condition|(
name|yoff
operator|<
name|ylim
condition|)
name|files
index|[
literal|1
index|]
operator|.
name|changed_flag
index|[
name|files
index|[
literal|1
index|]
operator|.
name|realindexes
index|[
name|yoff
operator|++
index|]
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|yoff
operator|==
name|ylim
condition|)
while|while
condition|(
name|xoff
operator|<
name|xlim
condition|)
name|files
index|[
literal|0
index|]
operator|.
name|changed_flag
index|[
name|files
index|[
literal|0
index|]
operator|.
name|realindexes
index|[
name|xoff
operator|++
index|]
index|]
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|c
decl_stmt|,
name|d
decl_stmt|,
name|f
decl_stmt|,
name|b
decl_stmt|;
comment|/* Find a point of correspondence in the middle of the files.  */
name|d
operator|=
name|diag
argument_list|(
name|xoff
argument_list|,
name|xlim
argument_list|,
name|yoff
argument_list|,
name|ylim
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|f
operator|=
name|fdiag
index|[
name|d
index|]
expr_stmt|;
name|b
operator|=
name|bdiag
index|[
name|d
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|1
condition|)
block|{
comment|/* This should be impossible, because it implies that 	     one of the two subsequences is empty, 	     and that case was handled above without calling `diag'. 	     Let's verify that this is true.  */
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The two subsequences differ by a single insert or delete; 	     record it and we are done.  */
block|if (d< xoff - yoff) 	    files[1].changed_flag[files[1].realindexes[b - d - 1]] = 1; 	  else 	    files[0].changed_flag[files[0].realindexes[b]] = 1;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Use that point to split this problem into two subproblems.  */
name|compareseq
argument_list|(
name|xoff
argument_list|,
name|b
argument_list|,
name|yoff
argument_list|,
name|b
operator|-
name|d
argument_list|)
expr_stmt|;
comment|/* This used to use f instead of b, 	     but that is incorrect! 	     It is not necessarily the case that diagonal d 	     has a snake from b to f.  */
name|compareseq
argument_list|(
name|b
argument_list|,
name|xlim
argument_list|,
name|b
operator|-
name|d
argument_list|,
name|ylim
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Discard lines from one file that have no matches in the other file.     A line which is discarded will not be considered by the actual    comparison algorithm; it will be as if that line were not in the file.    The file's `realindexes' table maps virtual line numbers    (which don't count the discarded lines) into real line numbers;    this is how the actual comparison algorithm produces results    that are comprehensible when the discarded lines are counted.     When we discard a line, we also mark it as a deletion or insertion    so that it will be printed in the output.  */
end_comment

begin_function
name|void
name|discard_confusing_lines
parameter_list|(
name|filevec
parameter_list|)
name|struct
name|file_data
name|filevec
index|[]
decl_stmt|;
block|{
name|unsigned
name|int
name|f
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|discarded
index|[
literal|2
index|]
decl_stmt|;
name|int
modifier|*
name|equiv_count
index|[
literal|2
index|]
decl_stmt|;
comment|/* Allocate our results.  */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
name|filevec
index|[
name|f
index|]
operator|.
name|undiscarded
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|filevec
index|[
name|f
index|]
operator|.
name|buffered_lines
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|filevec
index|[
name|f
index|]
operator|.
name|realindexes
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|filevec
index|[
name|f
index|]
operator|.
name|buffered_lines
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set up equiv_count[F][I] as the number of lines in file F      that fall in equivalence class I.  */
name|equiv_count
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|equiv_max
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|equiv_count
index|[
literal|0
index|]
argument_list|,
name|filevec
index|[
literal|0
index|]
operator|.
name|equiv_max
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|equiv_count
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|filevec
index|[
literal|1
index|]
operator|.
name|equiv_max
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|equiv_count
index|[
literal|1
index|]
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|equiv_max
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
condition|;
operator|++
name|i
control|)
operator|++
name|equiv_count
index|[
literal|0
index|]
index|[
name|filevec
index|[
literal|0
index|]
operator|.
name|equivs
index|[
name|i
index|]
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
condition|;
operator|++
name|i
control|)
operator|++
name|equiv_count
index|[
literal|1
index|]
index|[
name|filevec
index|[
literal|1
index|]
operator|.
name|equivs
index|[
name|i
index|]
index|]
expr_stmt|;
comment|/* Set up tables of which lines are going to be discarded.  */
name|discarded
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
argument_list|)
expr_stmt|;
name|discarded
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|discarded
index|[
literal|0
index|]
argument_list|,
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|discarded
index|[
literal|1
index|]
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
argument_list|)
expr_stmt|;
comment|/* Mark to be discarded each line that matches no line of the other file.      If a line matches many lines, mark it as provisionally discardable.  */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
name|unsigned
name|int
name|end
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|buffered_lines
decl_stmt|;
name|char
modifier|*
name|discards
init|=
name|discarded
index|[
name|f
index|]
decl_stmt|;
name|int
modifier|*
name|counts
init|=
name|equiv_count
index|[
literal|1
operator|-
name|f
index|]
decl_stmt|;
name|int
modifier|*
name|equivs
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|equivs
decl_stmt|;
name|unsigned
name|int
name|many
init|=
literal|5
decl_stmt|;
name|unsigned
name|int
name|tem
init|=
name|end
operator|/
literal|64
decl_stmt|;
comment|/* Multiply MANY by approximate square root of number of lines. 	 That is the threshold for provisionally discardable lines.  */
while|while
condition|(
operator|(
name|tem
operator|=
name|tem
operator|>>
literal|2
operator|)
operator|>
literal|0
condition|)
name|many
operator|*=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nmatch
decl_stmt|;
if|if
condition|(
name|equivs
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|nmatch
operator|=
name|counts
index|[
name|equivs
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|nmatch
operator|==
literal|0
condition|)
name|discards
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|nmatch
operator|>
name|many
condition|)
name|discards
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Don't really discard the provisional lines except when they occur      in a run of discardables, with nonprovisionals at the beginning      and end.  */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
name|unsigned
name|int
name|end
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|buffered_lines
decl_stmt|;
specifier|register
name|char
modifier|*
name|discards
init|=
name|discarded
index|[
name|f
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
comment|/* Cancel provisional discards not in middle of run of discards.  */
if|if
condition|(
name|discards
index|[
name|i
index|]
operator|==
literal|2
condition|)
name|discards
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|discards
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* We have found a nonprovisional discard.  */
specifier|register
name|int
name|j
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|provisional
init|=
literal|0
decl_stmt|;
comment|/* Find end of this run of discardable lines. 		 Count how many are provisionally discardable.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|end
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|discards
index|[
name|j
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|discards
index|[
name|j
index|]
operator|==
literal|2
condition|)
operator|++
name|provisional
expr_stmt|;
block|}
comment|/* Cancel provisional discards at end, and shrink the run.  */
while|while
condition|(
name|j
operator|>
name|i
operator|&&
name|discards
index|[
name|j
operator|-
literal|1
index|]
operator|==
literal|2
condition|)
name|discards
index|[
operator|--
name|j
index|]
operator|=
literal|0
operator|,
operator|--
name|provisional
expr_stmt|;
comment|/* Now we have the length of a run of discardable lines 		 whose first and last are not provisional.  */
name|length
operator|=
name|j
operator|-
name|i
expr_stmt|;
comment|/* If 1/4 of the lines in the run are provisional, 		 cancel discarding of all provisional lines in the run.  */
if|if
condition|(
name|provisional
operator|*
literal|4
operator|>
name|length
condition|)
block|{
while|while
condition|(
name|j
operator|>
name|i
condition|)
if|if
condition|(
name|discards
index|[
operator|--
name|j
index|]
operator|==
literal|2
condition|)
name|discards
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|unsigned
name|int
name|consec
decl_stmt|;
name|unsigned
name|int
name|minimum
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|tem
init|=
name|length
operator|/
literal|4
decl_stmt|;
comment|/* MINIMUM is approximate square root of LENGTH/4. 		     A subrun of two or more provisionals can stand 		     when LENGTH is at least 16. 		     A subrun of 4 or more can stand when LENGTH>= 64.  */
while|while
condition|(
operator|(
name|tem
operator|=
name|tem
operator|>>
literal|2
operator|)
operator|>
literal|0
condition|)
name|minimum
operator|*=
literal|2
expr_stmt|;
name|minimum
operator|++
expr_stmt|;
comment|/* Cancel any subrun of MINIMUM or more provisionals 		     within the larger run.  */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|consec
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|!=
literal|2
condition|)
name|consec
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|minimum
operator|==
operator|++
name|consec
condition|)
comment|/* Back up to start of subrun, to cancel it all.  */
name|j
operator|-=
name|consec
expr_stmt|;
elseif|else
if|if
condition|(
name|minimum
operator|<
name|consec
condition|)
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Scan from beginning of run 		     until we find 3 or more nonprovisionals in a row 		     or until the first nonprovisional at least 8 lines in. 		     Until that point, cancel any provisionals.  */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|consec
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|8
operator|&&
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|==
literal|2
condition|)
name|consec
operator|=
literal|0
operator|,
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|==
literal|0
condition|)
name|consec
operator|=
literal|0
expr_stmt|;
else|else
name|consec
operator|++
expr_stmt|;
if|if
condition|(
name|consec
operator|==
literal|3
condition|)
break|break;
block|}
comment|/* I advances to the last line of the run.  */
name|i
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
comment|/* Same thing, from end.  */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|consec
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|8
operator|&&
name|discards
index|[
name|i
operator|-
name|j
index|]
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
name|discards
index|[
name|i
operator|-
name|j
index|]
operator|==
literal|2
condition|)
name|consec
operator|=
literal|0
operator|,
name|discards
index|[
name|i
operator|-
name|j
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|discards
index|[
name|i
operator|-
name|j
index|]
operator|==
literal|0
condition|)
name|consec
operator|=
literal|0
expr_stmt|;
else|else
name|consec
operator|++
expr_stmt|;
if|if
condition|(
name|consec
operator|==
literal|3
condition|)
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Actually discard the lines. */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
name|char
modifier|*
name|discards
init|=
name|discarded
index|[
name|f
index|]
decl_stmt|;
name|unsigned
name|int
name|end
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|buffered_lines
decl_stmt|;
name|unsigned
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|no_discards
operator|||
name|discards
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|filevec
index|[
name|f
index|]
operator|.
name|undiscarded
index|[
name|j
index|]
operator|=
name|filevec
index|[
name|f
index|]
operator|.
name|equivs
index|[
name|i
index|]
expr_stmt|;
name|filevec
index|[
name|f
index|]
operator|.
name|realindexes
index|[
name|j
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
name|filevec
index|[
name|f
index|]
operator|.
name|changed_flag
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|filevec
index|[
name|f
index|]
operator|.
name|nondiscarded_lines
operator|=
name|j
expr_stmt|;
block|}
name|free
argument_list|(
name|discarded
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|discarded
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|equiv_count
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|equiv_count
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust inserts/deletes of blank lines to join changes    as much as possible.     We do something when a run of changed lines include a blank    line at one end and have an excluded blank line at the other.    We are free to choose which blank line is included.    `compareseq' always chooses the one at the beginning,    but usually it is cleaner to consider the following blank line    to be the "change".  The only exception is if the preceding blank line    would join this change to other changes.  */
end_comment

begin_decl_stmt
name|int
name|inhibit
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|shift_boundaries
parameter_list|(
name|filevec
parameter_list|)
name|struct
name|file_data
name|filevec
index|[]
decl_stmt|;
block|{
name|int
name|f
decl_stmt|;
if|if
condition|(
name|inhibit
condition|)
return|return;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
name|char
modifier|*
name|changed
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|changed_flag
decl_stmt|;
name|char
modifier|*
name|other_changed
init|=
name|filevec
index|[
literal|1
operator|-
name|f
index|]
operator|.
name|changed_flag
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|i_end
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|buffered_lines
decl_stmt|;
name|int
name|preceding
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|other_preceding
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|other_start
decl_stmt|;
comment|/* Scan forwards to find beginning of another run of changes. 	     Also keep track of the corresponding point in the other file.  */
while|while
condition|(
name|i
operator|<
name|i_end
operator|&&
name|changed
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|other_changed
index|[
name|j
operator|++
index|]
condition|)
comment|/* Non-corresponding lines in the other file 		   will count as the preceding batch of changes.  */
name|other_preceding
operator|=
name|j
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|i_end
condition|)
break|break;
name|start
operator|=
name|i
expr_stmt|;
name|other_start
operator|=
name|j
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Now find the end of this run of changes.  */
while|while
condition|(
name|i
operator|<
name|i_end
operator|&&
name|changed
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|i
operator|++
expr_stmt|;
name|end
operator|=
name|i
expr_stmt|;
comment|/* If the first changed line matches the following unchanged one, 		 and this run does not follow right after a previous run, 		 and there are no lines deleted from the other file here, 		 then classify the first changed line as unchanged 		 and the following line as changed in its place.  */
comment|/* You might ask, how could this run follow right after another? 		 Only because the previous run was shifted here.  */
if|if
condition|(
name|end
operator|!=
name|i_end
operator|&&
name|files
index|[
name|f
index|]
operator|.
name|equivs
index|[
name|start
index|]
operator|==
name|files
index|[
name|f
index|]
operator|.
name|equivs
index|[
name|end
index|]
operator|&&
operator|!
name|other_changed
index|[
name|j
index|]
operator|&&
name|end
operator|!=
name|i_end
operator|&&
operator|!
operator|(
operator|(
name|preceding
operator|>=
literal|0
operator|&&
name|start
operator|==
name|preceding
operator|)
operator|||
operator|(
name|other_preceding
operator|>=
literal|0
operator|&&
name|other_start
operator|==
name|other_preceding
operator|)
operator|)
condition|)
block|{
name|changed
index|[
name|end
operator|++
index|]
operator|=
literal|1
expr_stmt|;
name|changed
index|[
name|start
operator|++
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
comment|/* Since one line-that-matches is now before this run 		     instead of after, we must advance in the other file 		     to keep in synch.  */
operator|++
name|j
expr_stmt|;
block|}
else|else
break|break;
block|}
name|preceding
operator|=
name|i
expr_stmt|;
name|other_preceding
operator|=
name|j
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Cons an additional entry onto the front of an edit script OLD.    LINE0 and LINE1 are the first affected lines in the two files (origin 0).    DELETED is the number of lines deleted here from file 0.    INSERTED is the number of lines inserted here in file 1.     If DELETED is 0 then LINE0 is the number of the line before    which the insertion was done; vice versa for INSERTED and LINE1.  */
end_comment

begin_function
specifier|static
name|struct
name|change
modifier|*
name|add_change
parameter_list|(
name|line0
parameter_list|,
name|line1
parameter_list|,
name|deleted
parameter_list|,
name|inserted
parameter_list|,
name|old
parameter_list|)
name|int
name|line0
decl_stmt|,
name|line1
decl_stmt|,
name|deleted
decl_stmt|,
name|inserted
decl_stmt|;
name|struct
name|change
modifier|*
name|old
decl_stmt|;
block|{
name|struct
name|change
modifier|*
name|new
init|=
operator|(
expr|struct
name|change
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|change
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|line0
operator|=
name|line0
expr_stmt|;
name|new
operator|->
name|line1
operator|=
name|line1
expr_stmt|;
name|new
operator|->
name|inserted
operator|=
name|inserted
expr_stmt|;
name|new
operator|->
name|deleted
operator|=
name|deleted
expr_stmt|;
name|new
operator|->
name|link
operator|=
name|old
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Scan the tables of which lines are inserted and deleted,    producing an edit script in reverse order.  */
end_comment

begin_function
specifier|static
name|struct
name|change
modifier|*
name|build_reverse_script
parameter_list|(
name|filevec
parameter_list|)
name|struct
name|file_data
name|filevec
index|[]
decl_stmt|;
block|{
name|struct
name|change
modifier|*
name|script
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|changed0
init|=
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
decl_stmt|;
name|char
modifier|*
name|changed1
init|=
name|filevec
index|[
literal|1
index|]
operator|.
name|changed_flag
decl_stmt|;
name|int
name|len0
init|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
decl_stmt|;
name|int
name|len1
init|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
decl_stmt|;
comment|/* Note that changedN[len0] does exist, and contains 0.  */
name|int
name|i0
init|=
literal|0
decl_stmt|,
name|i1
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i0
operator|<
name|len0
operator|||
name|i1
operator|<
name|len1
condition|)
block|{
if|if
condition|(
name|changed0
index|[
name|i0
index|]
operator|||
name|changed1
index|[
name|i1
index|]
condition|)
block|{
name|int
name|line0
init|=
name|i0
decl_stmt|,
name|line1
init|=
name|i1
decl_stmt|;
comment|/* Find # lines changed here in each file.  */
while|while
condition|(
name|changed0
index|[
name|i0
index|]
condition|)
operator|++
name|i0
expr_stmt|;
while|while
condition|(
name|changed1
index|[
name|i1
index|]
condition|)
operator|++
name|i1
expr_stmt|;
comment|/* Record this change.  */
name|script
operator|=
name|add_change
argument_list|(
name|line0
argument_list|,
name|line1
argument_list|,
name|i0
operator|-
name|line0
argument_list|,
name|i1
operator|-
name|line1
argument_list|,
name|script
argument_list|)
expr_stmt|;
block|}
comment|/* We have reached lines in the two files that match each other.  */
name|i0
operator|++
operator|,
name|i1
operator|++
expr_stmt|;
block|}
return|return
name|script
return|;
block|}
end_function

begin_comment
comment|/* Scan the tables of which lines are inserted and deleted,    producing an edit script in forward order.  */
end_comment

begin_function
specifier|static
name|struct
name|change
modifier|*
name|build_script
parameter_list|(
name|filevec
parameter_list|)
name|struct
name|file_data
name|filevec
index|[]
decl_stmt|;
block|{
name|struct
name|change
modifier|*
name|script
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|changed0
init|=
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
decl_stmt|;
name|char
modifier|*
name|changed1
init|=
name|filevec
index|[
literal|1
index|]
operator|.
name|changed_flag
decl_stmt|;
name|int
name|len0
init|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
decl_stmt|;
name|int
name|len1
init|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
decl_stmt|;
name|int
name|i0
init|=
name|len0
decl_stmt|,
name|i1
init|=
name|len1
decl_stmt|;
comment|/* Note that changedN[-1] does exist, and contains 0.  */
if|#
directive|if
literal|0
comment|/* Unnecessary since a line includes its trailing newline.  */
comment|/* In RCS comparisons, making the existence or nonexistence of trailing      newlines really matter. */
block|if (output_style == OUTPUT_RCS&& filevec[0].missing_newline != filevec[1].missing_newline)     changed0[len0 - 1] = changed1[len1 - 1] = 1;
endif|#
directive|endif
while|while
condition|(
name|i0
operator|>=
literal|0
operator|||
name|i1
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|changed0
index|[
name|i0
operator|-
literal|1
index|]
operator|||
name|changed1
index|[
name|i1
operator|-
literal|1
index|]
condition|)
block|{
name|int
name|line0
init|=
name|i0
decl_stmt|,
name|line1
init|=
name|i1
decl_stmt|;
comment|/* Find # lines changed here in each file.  */
while|while
condition|(
name|changed0
index|[
name|i0
operator|-
literal|1
index|]
condition|)
operator|--
name|i0
expr_stmt|;
while|while
condition|(
name|changed1
index|[
name|i1
operator|-
literal|1
index|]
condition|)
operator|--
name|i1
expr_stmt|;
comment|/* Record this change.  */
name|script
operator|=
name|add_change
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|,
name|line0
operator|-
name|i0
argument_list|,
name|line1
operator|-
name|i1
argument_list|,
name|script
argument_list|)
expr_stmt|;
block|}
comment|/* We have reached lines in the two files that match each other.  */
name|i0
operator|--
operator|,
name|i1
operator|--
expr_stmt|;
block|}
return|return
name|script
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Report the differences of two files.  DEPTH is the current directory    depth. */
end_comment

begin_function
name|int
name|diff_2_files
parameter_list|(
name|filevec
parameter_list|,
name|depth
parameter_list|)
name|struct
name|file_data
name|filevec
index|[]
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
name|int
name|diags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|change
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|change
modifier|*
name|script
decl_stmt|;
name|int
name|binary
decl_stmt|;
name|int
name|changes
decl_stmt|;
comment|/* See if the two named files are actually the same physical file.      If so, we know they are identical without actually reading them.  */
if|if
condition|(
name|output_style
operator|!=
name|OUTPUT_IFDEF
operator|&&
name|filevec
index|[
literal|0
index|]
operator|.
name|stat
operator|.
name|st_ino
operator|==
name|filevec
index|[
literal|1
index|]
operator|.
name|stat
operator|.
name|st_ino
operator|&&
name|filevec
index|[
literal|0
index|]
operator|.
name|stat
operator|.
name|st_dev
operator|==
name|filevec
index|[
literal|1
index|]
operator|.
name|stat
operator|.
name|st_dev
condition|)
return|return
literal|0
return|;
name|binary
operator|=
name|read_files
argument_list|(
name|filevec
argument_list|)
expr_stmt|;
comment|/* If we have detected that file 0 is a binary file,      compare the two files as binary.  This can happen      only when the first chunk is read.      Also, -q means treat all files as binary.  */
if|if
condition|(
name|binary
operator|||
name|no_details_flag
condition|)
block|{
name|int
name|differs
init|=
operator|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
operator|!=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
operator|||
name|bcmp
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|differs
condition|)
name|message
argument_list|(
name|binary
condition|?
literal|"Binary files %s and %s differ\n"
else|:
literal|"Files %s and %s differ\n"
argument_list|,
name|filevec
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|filevec
index|[
name|i
index|]
operator|.
name|buffer
condition|)
name|free
argument_list|(
name|filevec
index|[
name|i
index|]
operator|.
name|buffer
argument_list|)
expr_stmt|;
return|return
name|differs
return|;
block|}
comment|/* Allocate vectors for the results of comparison:      a flag for each line of each file, saying whether that line      is an insertion or deletion.      Allocate an extra element, always zero, at each end of each vector.  */
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
operator|+
literal|2
argument_list|)
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|changed_flag
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
argument_list|,
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|filevec
index|[
literal|1
index|]
operator|.
name|changed_flag
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
operator|+
literal|2
argument_list|)
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
operator|++
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|changed_flag
operator|++
expr_stmt|;
comment|/* Some lines are obviously insertions or deletions      because they don't match anything.  Detect them now,      and avoid even thinking about them in the main comparison algorithm.  */
name|discard_confusing_lines
argument_list|(
name|filevec
argument_list|)
expr_stmt|;
comment|/* Now do the main comparison algorithm, considering just the      undiscarded lines.  */
name|xvec
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|undiscarded
expr_stmt|;
name|yvec
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|undiscarded
expr_stmt|;
name|diags
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|nondiscarded_lines
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
operator|+
literal|3
expr_stmt|;
name|fdiag
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|diags
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|fdiag
operator|+=
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
operator|+
literal|1
expr_stmt|;
name|bdiag
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|diags
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bdiag
operator|+=
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
operator|+
literal|1
expr_stmt|;
name|files
index|[
literal|0
index|]
operator|=
name|filevec
index|[
literal|0
index|]
expr_stmt|;
name|files
index|[
literal|1
index|]
operator|=
name|filevec
index|[
literal|1
index|]
expr_stmt|;
name|compareseq
argument_list|(
literal|0
argument_list|,
name|filevec
index|[
literal|0
index|]
operator|.
name|nondiscarded_lines
argument_list|,
literal|0
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
argument_list|)
expr_stmt|;
name|bdiag
operator|-=
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
operator|+
literal|1
expr_stmt|;
name|free
argument_list|(
name|bdiag
argument_list|)
expr_stmt|;
name|fdiag
operator|-=
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
operator|+
literal|1
expr_stmt|;
name|free
argument_list|(
name|fdiag
argument_list|)
expr_stmt|;
comment|/* Modify the results slightly to make them prettier      in cases where that can validly be done.  */
name|shift_boundaries
argument_list|(
name|filevec
argument_list|)
expr_stmt|;
comment|/* Get the results of comparison in the form of a chain      of `struct change's -- an edit script.  */
if|if
condition|(
name|output_style
operator|==
name|OUTPUT_ED
condition|)
name|script
operator|=
name|build_reverse_script
argument_list|(
name|filevec
argument_list|)
expr_stmt|;
else|else
name|script
operator|=
name|build_script
argument_list|(
name|filevec
argument_list|)
expr_stmt|;
if|if
condition|(
name|script
operator|||
name|output_style
operator|==
name|OUTPUT_IFDEF
condition|)
block|{
name|setup_output
argument_list|(
name|files
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|files
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
name|depth
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|output_style
condition|)
block|{
case|case
name|OUTPUT_CONTEXT
case|:
name|print_context_header
argument_list|(
name|files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_context_script
argument_list|(
name|script
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_UNIFIED
case|:
name|print_context_header
argument_list|(
name|files
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|print_context_script
argument_list|(
name|script
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_ED
case|:
name|print_ed_script
argument_list|(
name|script
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_FORWARD_ED
case|:
name|pr_forward_ed_script
argument_list|(
name|script
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_RCS
case|:
name|print_rcs_script
argument_list|(
name|script
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_NORMAL
case|:
name|print_normal_script
argument_list|(
name|script
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_IFDEF
case|:
name|print_ifdef_script
argument_list|(
name|script
argument_list|)
expr_stmt|;
break|break;
block|}
name|finish_output
argument_list|()
expr_stmt|;
block|}
comment|/* Set CHANGES if we had any diffs that were printed.      If some changes are being ignored, we must scan the script to decide.  */
if|if
condition|(
name|ignore_blank_lines_flag
operator|||
name|ignore_regexp
condition|)
block|{
name|struct
name|change
modifier|*
name|next
init|=
name|script
decl_stmt|;
name|changes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|next
operator|&&
name|changes
operator|==
literal|0
condition|)
block|{
name|struct
name|change
modifier|*
name|this
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|first0
decl_stmt|,
name|last0
decl_stmt|,
name|first1
decl_stmt|,
name|last1
decl_stmt|,
name|deletes
decl_stmt|,
name|inserts
decl_stmt|;
comment|/* Find a set of changes that belong together.  */
name|this
operator|=
name|next
expr_stmt|;
name|end
operator|=
name|find_change
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Disconnect them from the rest of the changes, 	     making them a hunk, and remember the rest for next iteration.  */
name|next
operator|=
name|end
operator|->
name|link
expr_stmt|;
name|end
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
comment|/* Determine whether this hunk was printed.  */
name|analyze_hunk
argument_list|(
name|this
argument_list|,
operator|&
name|first0
argument_list|,
operator|&
name|last0
argument_list|,
operator|&
name|first1
argument_list|,
operator|&
name|last1
argument_list|,
operator|&
name|deletes
argument_list|,
operator|&
name|inserts
argument_list|)
expr_stmt|;
comment|/* Reconnect the script so it will all be freed properly.  */
name|end
operator|->
name|link
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|deletes
operator|||
name|inserts
condition|)
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|changes
operator|=
operator|(
name|script
operator|!=
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|free
argument_list|(
name|filevec
index|[
name|i
index|]
operator|.
name|realindexes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filevec
index|[
name|i
index|]
operator|.
name|undiscarded
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|free
argument_list|(
operator|--
name|filevec
index|[
name|i
index|]
operator|.
name|changed_flag
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|free
argument_list|(
name|filevec
index|[
name|i
index|]
operator|.
name|equivs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|filevec
index|[
name|i
index|]
operator|.
name|buffer
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|filevec
index|[
name|i
index|]
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filevec
index|[
name|i
index|]
operator|.
name|linbuf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|script
init|;
name|e
condition|;
name|e
operator|=
name|p
control|)
block|{
name|p
operator|=
name|e
operator|->
name|link
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ROBUST_OUTPUT_STYLE
argument_list|(
name|output_style
argument_list|)
comment|/* For -D, invent newlines silently.  That's ok in C code.  */
operator|&&
name|output_style
operator|!=
name|OUTPUT_IFDEF
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|filevec
index|[
name|i
index|]
operator|.
name|missing_newline
condition|)
block|{
name|error
argument_list|(
literal|"No newline at end of file %s"
argument_list|,
name|filevec
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|changes
operator|=
literal|2
expr_stmt|;
block|}
return|return
name|changes
return|;
block|}
end_function

end_unit

