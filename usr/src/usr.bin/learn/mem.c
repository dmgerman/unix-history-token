begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)mem.c	4.3	(Berkeley)	5/15/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_include
include|#
directive|include
file|"lrnref.h"
end_include

begin_define
define|#
directive|define
name|SAME
value|0
end_define

begin_struct
struct|struct
name|keys
block|{
name|char
modifier|*
name|k_wd
decl_stmt|;
name|int
name|k_val
decl_stmt|;
block|}
name|keybuff
index|[]
init|=
block|{
block|{
literal|"ready"
block|,
name|READY
block|}
block|,
block|{
literal|"answer"
block|,
name|READY
block|}
block|,
block|{
literal|"#print"
block|,
name|PRINT
block|}
block|,
block|{
literal|"#copyin"
block|,
name|COPYIN
block|}
block|,
block|{
literal|"#uncopyin"
block|,
name|UNCOPIN
block|}
block|,
block|{
literal|"#copyout"
block|,
name|COPYOUT
block|}
block|,
block|{
literal|"#uncopyout"
block|,
name|UNCOPOUT
block|}
block|,
block|{
literal|"#pipe"
block|,
name|PIPE
block|}
block|,
block|{
literal|"#unpipe"
block|,
name|UNPIPE
block|}
block|,
block|{
literal|"#succeed"
block|,
name|SUCCEED
block|}
block|,
block|{
literal|"#fail"
block|,
name|FAIL
block|}
block|,
block|{
literal|"bye"
block|,
name|BYE
block|}
block|,
block|{
literal|"chdir"
block|,
name|CHDIR
block|}
block|,
block|{
literal|"cd"
block|,
name|CHDIR
block|}
block|,
block|{
literal|"learn"
block|,
name|LEARN
block|}
block|,
block|{
literal|"#log"
block|,
name|LOG
block|}
block|,
block|{
literal|"yes"
block|,
name|YES
block|}
block|,
block|{
literal|"no"
block|,
name|NO
block|}
block|,
block|{
literal|"again"
block|,
name|AGAIN
block|}
block|,
block|{
literal|"#mv"
block|,
name|MV
block|}
block|,
block|{
literal|"#user"
block|,
name|USER
block|}
block|,
block|{
literal|"#next"
block|,
name|NEXT
block|}
block|,
block|{
literal|"skip"
block|,
name|SKIP
block|}
block|,
block|{
literal|"where"
block|,
name|WHERE
block|}
block|,
block|{
literal|"#match"
block|,
name|MATCH
block|}
block|,
block|{
literal|"#bad"
block|,
name|BAD
block|}
block|,
block|{
literal|"#create"
block|,
name|CREATE
block|}
block|,
block|{
literal|"#cmp"
block|,
name|CMP
block|}
block|,
block|{
literal|"hint"
block|,
name|HINT
block|}
block|,
block|{
literal|"#once"
block|,
name|ONCE
block|}
block|,
block|{
literal|"#"
block|,
name|NOP
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
name|int
modifier|*
name|action
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|keys
modifier|*
name|kp
decl_stmt|;
for|for
control|(
name|kp
operator|=
name|keybuff
init|;
name|kp
operator|->
name|k_wd
condition|;
name|kp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|kp
operator|->
name|k_wd
argument_list|,
name|s
argument_list|)
operator|==
name|SAME
condition|)
return|return
operator|(
operator|&
operator|(
name|kp
operator|->
name|k_val
operator|)
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NW
value|100
end_define

begin_define
define|#
directive|define
name|NWCH
value|800
end_define

begin_struct
struct|struct
name|whichdid
block|{
name|char
modifier|*
name|w_less
decl_stmt|;
name|int
name|w_seq
decl_stmt|;
block|}
name|which
index|[
name|NW
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|nwh
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|whbuff
index|[
name|NWCH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|whcp
init|=
name|whbuff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|whichdid
modifier|*
name|pw
decl_stmt|;
end_decl_stmt

begin_macro
name|setdid
argument_list|(
argument|lesson
argument_list|,
argument|sequence
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lesson
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sequence
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|already
argument_list|(
name|lesson
argument_list|)
condition|)
block|{
name|pw
operator|->
name|w_seq
operator|=
name|sequence
expr_stmt|;
return|return;
block|}
name|pw
operator|=
name|which
operator|+
name|nwh
operator|++
expr_stmt|;
if|if
condition|(
name|nwh
operator|>=
name|NW
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Setdid:  too many lessons\n"
argument_list|)
expr_stmt|;
name|tellwhich
argument_list|()
expr_stmt|;
name|wrapup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|->
name|w_seq
operator|=
name|sequence
expr_stmt|;
name|pw
operator|->
name|w_less
operator|=
name|whcp
expr_stmt|;
while|while
condition|(
operator|*
name|whcp
operator|++
operator|=
operator|*
name|lesson
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|whcp
operator|>=
name|whbuff
operator|+
name|NWCH
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Setdid:  lesson names too long\n"
argument_list|)
expr_stmt|;
name|tellwhich
argument_list|()
expr_stmt|;
name|wrapup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|unsetdid
argument_list|(
argument|lesson
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lesson
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|already
argument_list|(
name|lesson
argument_list|)
condition|)
return|return;
name|nwh
operator|=
name|pw
operator|-
name|which
expr_stmt|;
comment|/* pretend the rest have not been done */
name|whcp
operator|=
name|pw
operator|->
name|w_less
expr_stmt|;
block|}
end_block

begin_macro
name|already
argument_list|(
argument|lesson
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lesson
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
name|pw
operator|=
name|which
init|;
name|pw
operator|<
name|which
operator|+
name|nwh
condition|;
name|pw
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|pw
operator|->
name|w_less
argument_list|,
name|lesson
argument_list|)
operator|==
name|SAME
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|tellwhich
argument_list|()
end_macro

begin_block
block|{
for|for
control|(
name|pw
operator|=
name|which
init|;
name|pw
operator|<
name|which
operator|+
name|nwh
condition|;
name|pw
operator|++
control|)
name|printf
argument_list|(
literal|"%3d lesson %7s sequence %3d\n"
argument_list|,
name|pw
operator|-
name|which
argument_list|,
name|pw
operator|->
name|w_less
argument_list|,
name|pw
operator|->
name|w_seq
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

