begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)copy.c	4.4	(Berkeley)	9/11/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_include
include|#
directive|include
file|"signal.h"
end_include

begin_include
include|#
directive|include
file|"lrnref.h"
end_include

begin_decl_stmt
name|char
name|togo
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|last
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|logf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|subdir
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|review
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|noclobber
decl_stmt|;
end_decl_stmt

begin_macro
name|copy
argument_list|(
argument|prompt
argument_list|,
argument|fin
argument_list|)
end_macro

begin_decl_stmt
name|int
name|prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fin
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fout
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|char
name|s
index|[
literal|100
index|]
decl_stmt|,
name|t
index|[
literal|100
index|]
decl_stmt|,
name|s1
index|[
literal|100
index|]
decl_stmt|,
name|nm
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|tod
decl_stmt|,
name|c
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|,
name|tv
index|[
literal|2
index|]
decl_stmt|;
specifier|extern
name|int
name|intrpt
argument_list|()
decl_stmt|,
modifier|*
name|action
argument_list|()
decl_stmt|;
specifier|extern
name|char
modifier|*
name|wordb
parameter_list|()
function_decl|;
name|int
name|nmatch
init|=
literal|0
decl_stmt|;
name|long
name|mark
decl_stmt|;
if|if
condition|(
name|subdir
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|subdir
argument_list|,
literal|"%s/%s"
argument_list|,
name|direct
argument_list|,
name|sname
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pgets
argument_list|(
name|s
argument_list|,
name|prompt
argument_list|,
name|fin
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|fin
operator|==
name|stdin
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Type \"bye\" if you want to leave learn.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
name|trim
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* trim newline */
comment|/* change the sequence %s to lesson directory */
comment|/* if needed */
for|for
control|(
name|r
operator|=
name|s
init|;
operator|*
name|r
condition|;
name|r
operator|++
control|)
if|if
condition|(
operator|*
name|r
operator|==
literal|'%'
condition|)
block|{
name|sprintf
argument_list|(
name|s1
argument_list|,
name|s
argument_list|,
name|subdir
argument_list|,
name|subdir
argument_list|,
name|subdir
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|s1
argument_list|)
expr_stmt|;
break|break;
block|}
name|r
operator|=
name|wordb
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* t = first token, r = rest */
name|p
operator|=
name|action
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* p = token class */
if|if
condition|(
name|p
operator|&&
operator|*
name|p
operator|==
name|ONCE
condition|)
block|{
comment|/* some actions done only once per script */
if|if
condition|(
name|wrong
operator|&&
operator|!
name|review
condition|)
block|{
comment|/* we are on 2nd time */
name|scopy
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|strcpy
argument_list|(
name|s
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|wordb
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|p
operator|=
name|action
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|comfile
operator|>=
literal|0
condition|)
block|{
comment|/* if #pipe in effect ... */
name|write
argument_list|(
name|comfile
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|comfile
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* else must be UNIX command ... */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|status
operator|=
name|mysys
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intrpt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|incopy
condition|)
block|{
name|fprintf
argument_list|(
name|incopy
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|last
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|READY
case|:
if|if
condition|(
name|incopy
operator|&&
name|r
condition|)
block|{
name|fprintf
argument_list|(
name|incopy
argument_list|,
literal|"%s\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|last
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|PRINT
case|:
if|if
condition|(
name|wrong
condition|)
name|scopy
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* don't repeat message */
elseif|else
if|if
condition|(
name|r
condition|)
name|list
argument_list|(
name|r
argument_list|)
expr_stmt|;
else|else
name|scopy
argument_list|(
name|fin
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|HINT
case|:
name|mark
operator|=
name|ftell
argument_list|(
name|scrin
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|rewind
argument_list|(
name|scrin
argument_list|)
expr_stmt|;
while|while
condition|(
call|(
name|int
call|)
argument_list|(
name|c
operator|=
name|fgetc
argument_list|(
name|scrin
argument_list|)
argument_list|)
operator|!=
name|EOF
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|scrin
argument_list|,
name|mark
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP
case|:
break|break;
case|case
name|MATCH
case|:
if|if
condition|(
name|nmatch
operator|>
literal|0
condition|)
comment|/* we have already passed */
name|scopy
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|status
operator|=
name|strcmp
argument_list|(
name|r
argument_list|,
name|last
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* did we pass this time? */
name|nmatch
operator|++
expr_stmt|;
name|scopy
argument_list|(
name|fin
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|scopy
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|BAD
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|r
argument_list|,
name|last
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scopy
argument_list|(
name|fin
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|scopy
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUCCEED
case|:
name|scopy
argument_list|(
name|fin
argument_list|,
operator|(
name|status
operator|==
literal|0
operator|)
condition|?
name|stdout
else|:
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAIL
case|:
name|scopy
argument_list|(
name|fin
argument_list|,
operator|(
name|status
operator|!=
literal|0
operator|)
condition|?
name|stdout
else|:
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CREATE
case|:
if|if
condition|(
name|noclobber
condition|)
name|fout
operator|=
name|NULL
expr_stmt|;
else|else
name|fout
operator|=
name|fopen
argument_list|(
name|r
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|scopy
argument_list|(
name|fin
argument_list|,
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noclobber
condition|)
name|fclose
argument_list|(
name|fout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMP
case|:
name|status
operator|=
name|cmp
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* contains two file names */
break|break;
case|case
name|MV
case|:
name|sprintf
argument_list|(
name|nm
argument_list|,
literal|"%s/L%s.%s"
argument_list|,
name|subdir
argument_list|,
name|todo
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|fcopy
argument_list|(
name|r
argument_list|,
name|nm
argument_list|)
expr_stmt|;
break|break;
case|case
name|USER
case|:
case|case
name|NEXT
case|:
if|if
condition|(
name|noclobber
condition|)
name|noclobber
operator|=
literal|0
expr_stmt|;
name|more
operator|=
literal|1
expr_stmt|;
return|return;
comment|/* "again previous_lesson" has a hard-to-reproduce bug */
case|case
name|AGAIN
case|:
name|review
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|r
operator|=
name|todo
expr_stmt|;
name|noclobber
operator|=
literal|1
expr_stmt|;
name|review
operator|=
literal|1
expr_stmt|;
block|}
name|again
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|togo
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|unhook
argument_list|()
expr_stmt|;
return|return;
case|case
name|SKIP
case|:
name|skip
operator|=
literal|1
expr_stmt|;
name|unhook
argument_list|()
expr_stmt|;
return|return;
case|case
name|COPYIN
case|:
name|incopy
operator|=
name|fopen
argument_list|(
literal|".copy"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNCOPIN
case|:
name|fclose
argument_list|(
name|incopy
argument_list|)
expr_stmt|;
name|incopy
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|COPYOUT
case|:
name|teed
operator|=
name|maktee
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNCOPOUT
case|:
name|untee
argument_list|()
expr_stmt|;
name|teed
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PIPE
case|:
name|comfile
operator|=
name|makpipe
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNPIPE
case|:
name|close
argument_list|(
name|comfile
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|comfile
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|YES
case|:
case|case
name|NO
case|:
if|if
condition|(
name|incopy
condition|)
block|{
name|fprintf
argument_list|(
name|incopy
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|last
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|WHERE
case|:
name|printf
argument_list|(
literal|"You are in lesson %s of \"%s\" with a speed rating of %d.\n"
argument_list|,
name|todo
argument_list|,
name|sname
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"You have completed %d out of a possible %d lessons.\n"
argument_list|,
name|sequence
operator|-
literal|1
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|tellwhich
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYE
case|:
name|more
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|CHDIR
case|:
name|printf
argument_list|(
literal|"cd not allowed\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEARN
case|:
name|printf
argument_list|(
literal|"You are already in learn.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG
case|:
comment|/* logfiles should be created mode 666 */
if|if
condition|(
operator|!
name|logging
condition|)
break|break;
if|if
condition|(
name|logf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|logf
argument_list|,
literal|"%s/log/%s"
argument_list|,
name|direct
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
operator|(
name|r
condition|?
name|r
else|:
name|logf
operator|)
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
break|break;
name|time
argument_list|(
name|tv
argument_list|)
expr_stmt|;
name|tod
operator|=
name|ctime
argument_list|(
name|tv
argument_list|)
expr_stmt|;
name|tod
index|[
literal|24
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s L%-6s %s %2d %s\n"
argument_list|,
name|tod
argument_list|,
name|todo
argument_list|,
name|status
condition|?
literal|"fail"
else|:
literal|"pass"
argument_list|,
name|speed
argument_list|,
name|pwline
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return;
block|}
end_block

begin_macro
name|pgets
argument_list|(
argument|s
argument_list|,
argument|prompt
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|prompt
condition|)
block|{
if|if
condition|(
name|comfile
operator|<
literal|0
condition|)
name|fputs
argument_list|(
literal|"% "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fgets
argument_list|(
name|s
argument_list|,
literal|100
argument_list|,
name|f
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|trim
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|s
operator|==
literal|'\n'
condition|)
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|scopy
argument_list|(
argument|fi
argument_list|,
argument|fo
argument_list|)
end_macro

begin_comment
comment|/* copy fi to fo until a line with # 		 * sequence "#\n" means a line not ending with \n 		 * control-M's are filtered out */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fi
decl_stmt|,
modifier|*
name|fo
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fi
argument_list|)
operator|)
operator|!=
literal|'#'
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|fo
operator|!=
name|NULL
condition|)
name|fflush
argument_list|(
name|fo
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fo
operator|!=
name|NULL
condition|)
name|putc
argument_list|(
literal|'#'
argument_list|,
name|fo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
break|break;
if|if
condition|(
name|fo
operator|!=
name|NULL
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|fo
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fi
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
do|;
block|}
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|fo
operator|!=
name|NULL
condition|)
name|fflush
argument_list|(
name|fo
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cmp
argument_list|(
argument|r
argument_list|)
end_macro

begin_comment
comment|/* compare two files for status; #cmp f1 f2 [ firstnlinesonly ] */
end_comment

begin_decl_stmt
name|char
modifier|*
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|h
decl_stmt|;
name|FILE
modifier|*
name|f1
decl_stmt|,
modifier|*
name|f2
decl_stmt|;
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|stat
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|s
operator|=
name|r
init|;
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
empty_stmt|;
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* r contains file 1 */
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
for|for
control|(
name|h
operator|=
name|s
init|;
operator|*
name|h
operator|!=
literal|' '
operator|&&
operator|*
name|h
operator|!=
literal|'\0'
condition|;
name|h
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|h
condition|)
block|{
operator|*
name|h
operator|++
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|h
operator|==
literal|' '
condition|)
name|h
operator|++
expr_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
else|else
name|n
operator|=
literal|077777
expr_stmt|;
name|f1
operator|=
name|fopen
argument_list|(
name|r
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|f2
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f1
operator|==
name|NULL
operator|||
name|f2
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* failure */
name|stat
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c1
operator|=
name|getc
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|getc
argument_list|(
name|f2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
block|{
name|stat
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|h
operator|&&
name|c1
operator|==
literal|'\n'
condition|)
if|if
condition|(
operator|--
name|n
condition|)
break|break;
if|if
condition|(
name|c1
operator|==
name|EOF
operator|||
name|c2
operator|==
name|EOF
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f2
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|wordb
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/* in s, t is prefix; return tail */
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
break|break;
operator|*
name|t
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
return|return
operator|(
name|c
condition|?
name|s
else|:
name|NULL
operator|)
return|;
block|}
end_block

begin_macro
name|unhook
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|incopy
condition|)
block|{
name|fclose
argument_list|(
name|incopy
argument_list|)
expr_stmt|;
name|incopy
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|comfile
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|comfile
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|comfile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|teed
condition|)
block|{
name|teed
operator|=
literal|0
expr_stmt|;
name|untee
argument_list|()
expr_stmt|;
block|}
name|fclose
argument_list|(
name|scrin
argument_list|)
expr_stmt|;
name|scrin
operator|=
name|NULL
expr_stmt|;
block|}
end_block

end_unit

