begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)trapov_.c	5.4	%G%  *  *	Fortran/C floating-point overflow handler  *  *	The idea of these routines is to catch floating-point overflows  *	and print an eror message.  When we then get a reserved operand  *	exception, we then fix up the value to the highest possible  *	number.  Keen, no?  *	Messy, yes!  *  *	Synopsis:  *		call trapov(n)  *			causes overflows to be trapped, with the first 'n'  *			overflows getting an "Overflow!" message printed.  *		k = ovcnt(0)  *			causes 'k' to get the number of overflows since the  *			last call to trapov().  *  *	Gary Klimowicz, April 17, 1981  *	Integerated with libF77: David Wasley, UCB, July 1981.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|"opcodes.h"
end_include

begin_include
include|#
directive|include
file|"../libI77/fiodefs.h"
end_include

begin_define
define|#
directive|define
name|SIG_VAL
value|void (*)()
end_define

begin_comment
comment|/*  *	Potential operand values  */
end_comment

begin_typedef
typedef|typedef
union|union
name|operand_types
block|{
name|char
name|o_byte
decl_stmt|;
name|short
name|o_word
decl_stmt|;
name|long
name|o_long
decl_stmt|;
name|float
name|o_float
decl_stmt|;
name|long
name|o_quad
index|[
literal|2
index|]
decl_stmt|;
name|double
name|o_double
decl_stmt|;
block|}
name|anyval
typedef|;
end_typedef

begin_comment
comment|/*  *	the fortran unit control table  */
end_comment

begin_decl_stmt
specifier|extern
name|unit
name|units
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fortran message table is in main  */
end_comment

begin_struct
struct|struct
name|msgtbl
block|{
name|char
modifier|*
name|mesg
decl_stmt|;
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|msgtbl
name|act_fpe
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|anyval
modifier|*
name|get_operand_address
argument_list|()
decl_stmt|,
modifier|*
name|addr_of_reg
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|opcode_name
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * trap type codes  */
end_comment

begin_define
define|#
directive|define
name|INT_OVF_T
value|1
end_define

begin_define
define|#
directive|define
name|INT_DIV_T
value|2
end_define

begin_define
define|#
directive|define
name|FLT_OVF_T
value|3
end_define

begin_define
define|#
directive|define
name|FLT_DIV_T
value|4
end_define

begin_define
define|#
directive|define
name|FLT_UND_T
value|5
end_define

begin_define
define|#
directive|define
name|DEC_OVF_T
value|6
end_define

begin_define
define|#
directive|define
name|SUB_RNG_T
value|7
end_define

begin_define
define|#
directive|define
name|FLT_OVF_F
value|8
end_define

begin_define
define|#
directive|define
name|FLT_DIV_F
value|9
end_define

begin_define
define|#
directive|define
name|FLT_UND_F
value|10
end_define

begin_define
define|#
directive|define
name|RES_ADR_F
value|0
end_define

begin_define
define|#
directive|define
name|RES_OPC_F
value|1
end_define

begin_define
define|#
directive|define
name|RES_OPR_F
value|2
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_comment
comment|/*  *	Operand modes  */
end_comment

begin_define
define|#
directive|define
name|LITERAL0
value|0x0
end_define

begin_define
define|#
directive|define
name|LITERAL1
value|0x1
end_define

begin_define
define|#
directive|define
name|LITERAL2
value|0x2
end_define

begin_define
define|#
directive|define
name|LITERAL3
value|0x3
end_define

begin_define
define|#
directive|define
name|INDEXED
value|0x4
end_define

begin_define
define|#
directive|define
name|REGISTER
value|0x5
end_define

begin_define
define|#
directive|define
name|REG_DEF
value|0x6
end_define

begin_define
define|#
directive|define
name|AUTO_DEC
value|0x7
end_define

begin_define
define|#
directive|define
name|AUTO_INC
value|0x8
end_define

begin_define
define|#
directive|define
name|AUTO_INC_DEF
value|0x9
end_define

begin_define
define|#
directive|define
name|BYTE_DISP
value|0xa
end_define

begin_define
define|#
directive|define
name|BYTE_DISP_DEF
value|0xb
end_define

begin_define
define|#
directive|define
name|WORD_DISP
value|0xc
end_define

begin_define
define|#
directive|define
name|WORD_DISP_DEF
value|0xd
end_define

begin_define
define|#
directive|define
name|LONG_DISP
value|0xe
end_define

begin_define
define|#
directive|define
name|LONG_DISP_DEF
value|0xf
end_define

begin_comment
comment|/*  *	Operand value types  */
end_comment

begin_define
define|#
directive|define
name|F
value|1
end_define

begin_define
define|#
directive|define
name|D
value|2
end_define

begin_define
define|#
directive|define
name|IDUNNO
value|3
end_define

begin_define
define|#
directive|define
name|PC
value|0xf
end_define

begin_define
define|#
directive|define
name|SP
value|0xe
end_define

begin_define
define|#
directive|define
name|FP
value|0xd
end_define

begin_define
define|#
directive|define
name|AP
value|0xc
end_define

begin_comment
comment|/*  *	GLOBAL VARIABLES (we need a few)  *  *	Actual program counter and locations of registers.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|regs0t6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|regs7t11
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_messages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_overflows
decl_stmt|;
end_decl_stmt

begin_union
specifier|static
union|union
block|{
name|long
name|v_long
index|[
literal|2
index|]
decl_stmt|;
name|double
name|v_double
decl_stmt|;
block|}
name|retrn
union|;
end_union

begin_decl_stmt
specifier|static
name|sig_t
name|sigill_default
init|=
operator|(
name|SIG_VAL
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sig_t
name|sigfpe_default
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *	This routine sets up the signal handler for the floating-point  *	and reserved operand interrupts.  */
end_comment

begin_macro
name|trapov_
argument_list|(
argument|count
argument_list|,
argument|rtnval
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
modifier|*
name|rtnval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|void
name|got_overflow
argument_list|()
decl_stmt|,
name|got_illegal_instruction
argument_list|()
decl_stmt|;
name|sigfpe_default
operator|=
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|got_overflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigill_default
operator|==
operator|(
name|SIG_VAL
operator|)
operator|-
literal|1
condition|)
name|sigill_default
operator|=
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|got_illegal_instruction
argument_list|)
expr_stmt|;
name|total_overflows
operator|=
literal|0
expr_stmt|;
name|max_messages
operator|=
operator|*
name|count
expr_stmt|;
name|retrn
operator|.
name|v_double
operator|=
operator|*
name|rtnval
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	got_overflow - routine called when overflow occurs  *  *	This routine just prints a message about the overflow.  *	It is impossible to find the bad result at this point.  *	Instead, we wait until we get the reserved operand exception  *	when we try to use it.  This raises the SIGILL signal.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|got_overflow
argument_list|(
argument|signo
argument_list|,
argument|codeword
argument_list|,
argument|myaddr
argument_list|,
argument|pc
argument_list|,
argument|ps
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|myaddr
decl_stmt|,
modifier|*
name|pc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
modifier|*
name|sp
decl_stmt|,
name|i
decl_stmt|;
name|FILE
modifier|*
name|ef
decl_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|got_overflow
argument_list|)
expr_stmt|;
name|ef
operator|=
name|units
index|[
name|STDERR
index|]
operator|.
name|ufd
expr_stmt|;
switch|switch
condition|(
name|codeword
condition|)
block|{
case|case
name|INT_OVF_T
case|:
case|case
name|INT_DIV_T
case|:
case|case
name|FLT_UND_T
case|:
case|case
name|DEC_OVF_T
case|:
case|case
name|SUB_RNG_T
case|:
case|case
name|FLT_OVF_F
case|:
case|case
name|FLT_DIV_F
case|:
case|case
name|FLT_UND_F
case|:
if|if
condition|(
name|sigfpe_default
operator|>
operator|(
name|SIG_VAL
operator|)
literal|7
condition|)
call|(
modifier|*
name|sigfpe_default
call|)
argument_list|(
name|signo
argument_list|,
name|codeword
argument_list|,
name|myaddr
argument_list|,
name|pc
argument_list|,
name|ps
argument_list|)
expr_stmt|;
else|else
name|sigdie
argument_list|(
name|signo
argument_list|,
name|codeword
argument_list|,
name|myaddr
argument_list|,
name|pc
argument_list|,
name|ps
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|FLT_OVF_T
case|:
case|case
name|FLT_DIV_T
case|:
if|if
condition|(
operator|++
name|total_overflows
operator|<=
name|max_messages
condition|)
block|{
name|fprintf
argument_list|(
name|ef
argument_list|,
literal|"trapov: %s"
argument_list|,
name|act_fpe
index|[
name|codeword
operator|-
literal|1
index|]
operator|.
name|mesg
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_overflows
operator|==
name|max_messages
condition|)
name|fprintf
argument_list|(
name|ef
argument_list|,
literal|": No more messages will be printed.\n"
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|ef
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
end_block

begin_function
name|int
name|ovcnt_
parameter_list|()
block|{
return|return
name|total_overflows
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	got_illegal_instruction - handle "illegal instruction" signals.  *  *	This really deals only with reserved operand exceptions.  *	Since there is no way to check this directly, we look at the  *	opcode of the instruction we are executing to see if it is a  *	floating-point operation (with floating-point operands, not  *	just results).  *  *	This is complicated by the fact that the registers that will  *	eventually be restored are saved in two places.  registers 7-11  *	are saved by this routine, and are in its call frame. (we have  *	to take special care that these registers are specified in  *	the procedure entry mask here.)  *	Registers 0-6 are saved at interrupt time, and are at a offset  *	-8 from the 'signo' parameter below.  *	There is ane extremely inimate connection between the value of  *	the entry mask set by the 'makefile' script, and the constants  *	used in the register offset calculations below.  *	Can someone think of a better way to do this?  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|got_illegal_instruction
argument_list|(
argument|signo
argument_list|,
argument|codeword
argument_list|,
argument|myaddr
argument_list|,
argument|trap_pc
argument_list|,
argument|ps
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|myaddr
decl_stmt|,
modifier|*
name|trap_pc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|first_local
index|[
literal|1
index|]
decl_stmt|;
comment|/* must be first */
name|int
name|i
decl_stmt|,
name|opcode
decl_stmt|,
name|type
decl_stmt|,
name|o_no
decl_stmt|,
name|no_reserved
decl_stmt|;
name|anyval
modifier|*
name|opnd
decl_stmt|;
name|regs7t11
operator|=
operator|&
name|first_local
index|[
literal|0
index|]
expr_stmt|;
name|regs0t6
operator|=
operator|&
name|signo
operator|-
literal|8
expr_stmt|;
name|pc
operator|=
name|trap_pc
expr_stmt|;
name|opcode
operator|=
name|fetch_byte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
name|no_reserved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|codeword
operator|!=
name|RES_OPR_F
operator|||
operator|!
name|is_floating_operation
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
if|if
condition|(
name|sigill_default
operator|>
operator|(
name|SIG_VAL
operator|)
literal|7
condition|)
return|return
operator|(
call|(
modifier|*
name|sigill_default
call|)
argument_list|(
name|signo
argument_list|,
name|codeword
argument_list|,
name|myaddr
argument_list|,
name|trap_pc
argument_list|,
name|ps
argument_list|)
operator|)
return|;
else|else
name|sigdie
argument_list|(
name|signo
argument_list|,
name|codeword
argument_list|,
name|myaddr
argument_list|,
name|trap_pc
argument_list|,
name|ps
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|opcode
operator|==
name|POLYD
operator|||
name|opcode
operator|==
name|POLYF
condition|)
block|{
name|got_illegal_poly
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|opcode
operator|==
name|EMODD
operator|||
name|opcode
operator|==
name|EMODF
condition|)
block|{
name|got_illegal_emod
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * This opcode wasn't "unusual". 	 * Look at the operands to try and find a reserved operand. 	 */
for|for
control|(
name|o_no
operator|=
literal|1
init|;
name|o_no
operator|<=
name|no_operands
argument_list|(
name|opcode
argument_list|)
condition|;
operator|++
name|o_no
control|)
block|{
name|type
operator|=
name|operand_type
argument_list|(
name|opcode
argument_list|,
name|o_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|F
operator|&&
name|type
operator|!=
name|D
condition|)
block|{
name|advance_pc
argument_list|(
name|type
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* F or D operand.  Check it out */
name|opnd
operator|=
name|get_operand_address
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnd
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|units
index|[
name|STDERR
index|]
operator|.
name|ufd
argument_list|,
literal|"Can't get operand address: 0x%x, %d\n"
argument_list|,
name|pc
argument_list|,
name|o_no
argument_list|)
expr_stmt|;
name|f77_abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|F
operator|&&
name|opnd
operator|->
name|o_long
operator|==
literal|0x00008000
condition|)
block|{
comment|/* found one */
name|opnd
operator|->
name|o_long
operator|=
name|retrn
operator|.
name|v_long
index|[
literal|0
index|]
expr_stmt|;
operator|++
name|no_reserved
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|D
operator|&&
name|opnd
operator|->
name|o_long
operator|==
literal|0x00008000
condition|)
block|{
comment|/* found one here, too! */
name|opnd
operator|->
name|o_quad
index|[
literal|0
index|]
operator|=
name|retrn
operator|.
name|v_long
index|[
literal|0
index|]
expr_stmt|;
comment|/* Fix next pointer */
if|if
condition|(
name|opnd
operator|==
name|addr_of_reg
argument_list|(
literal|6
argument_list|)
condition|)
name|opnd
operator|=
name|addr_of_reg
argument_list|(
literal|7
argument_list|)
expr_stmt|;
else|else
name|opnd
operator|=
operator|(
name|anyval
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|opnd
operator|+
literal|4
operator|)
expr_stmt|;
name|opnd
operator|->
name|o_quad
index|[
literal|0
index|]
operator|=
name|retrn
operator|.
name|v_long
index|[
literal|1
index|]
expr_stmt|;
operator|++
name|no_reserved
expr_stmt|;
block|}
block|}
if|if
condition|(
name|no_reserved
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|units
index|[
name|STDERR
index|]
operator|.
name|ufd
argument_list|,
literal|"Can't find any reserved operand!\n"
argument_list|)
expr_stmt|;
name|f77_abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * is_floating_exception - was the operation code for a floating instruction?  */
end_comment

begin_macro
name|is_floating_operation
argument_list|(
argument|opcode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|opcode
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|ACBD
case|:
case|case
name|ACBF
case|:
case|case
name|ADDD2
case|:
case|case
name|ADDD3
case|:
case|case
name|ADDF2
case|:
case|case
name|ADDF3
case|:
case|case
name|CMPD
case|:
case|case
name|CMPF
case|:
case|case
name|CVTDB
case|:
case|case
name|CVTDF
case|:
case|case
name|CVTDL
case|:
case|case
name|CVTDW
case|:
case|case
name|CVTFB
case|:
case|case
name|CVTFD
case|:
case|case
name|CVTFL
case|:
case|case
name|CVTFW
case|:
case|case
name|CVTRDL
case|:
case|case
name|CVTRFL
case|:
case|case
name|DIVD2
case|:
case|case
name|DIVD3
case|:
case|case
name|DIVF2
case|:
case|case
name|DIVF3
case|:
case|case
name|EMODD
case|:
case|case
name|EMODF
case|:
case|case
name|MNEGD
case|:
case|case
name|MNEGF
case|:
case|case
name|MOVD
case|:
case|case
name|MOVF
case|:
case|case
name|MULD2
case|:
case|case
name|MULD3
case|:
case|case
name|MULF2
case|:
case|case
name|MULF3
case|:
case|case
name|POLYD
case|:
case|case
name|POLYF
case|:
case|case
name|SUBD2
case|:
case|case
name|SUBD3
case|:
case|case
name|SUBF2
case|:
case|case
name|SUBF3
case|:
case|case
name|TSTD
case|:
case|case
name|TSTF
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * got_illegal_poly - handle an illegal POLY[DF] instruction.  *  * We don't do anything here yet.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|got_illegal_poly
argument_list|(
argument|opcode
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|units
index|[
name|STDERR
index|]
operator|.
name|ufd
argument_list|,
literal|"Can't do 'poly' instructions yet\n"
argument_list|)
expr_stmt|;
name|f77_abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * got_illegal_emod - handle illegal EMOD[DF] instruction.  *  * We don't do anything here yet.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|got_illegal_emod
argument_list|(
argument|opcode
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|units
index|[
name|STDERR
index|]
operator|.
name|ufd
argument_list|,
literal|"Can't do 'emod' instructions yet\n"
argument_list|)
expr_stmt|;
name|f77_abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	no_operands - determine the number of operands in this instruction.  *  */
end_comment

begin_macro
name|no_operands
argument_list|(
argument|opcode
argument_list|)
end_macro

begin_block
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|ACBD
case|:
case|case
name|ACBF
case|:
return|return
literal|3
return|;
case|case
name|MNEGD
case|:
case|case
name|MNEGF
case|:
case|case
name|MOVD
case|:
case|case
name|MOVF
case|:
case|case
name|TSTD
case|:
case|case
name|TSTF
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|2
return|;
block|}
block|}
end_block

begin_comment
comment|/*  *	operand_type - is the operand a D or an F?  *  *	We are only descriminating between Floats and Doubles here.  *	Other operands may be possible on exotic instructions.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|operand_type
argument_list|(
argument|opcode
argument_list|,
argument|no
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|opcode
operator|>=
literal|0x40
operator|&&
name|opcode
operator|<=
literal|0x56
condition|)
return|return
name|F
return|;
if|if
condition|(
name|opcode
operator|>=
literal|0x60
operator|&&
name|opcode
operator|<=
literal|0x76
condition|)
return|return
name|D
return|;
return|return
name|IDUNNO
return|;
block|}
end_block

begin_comment
comment|/*  *	advance_pc - Advance the program counter past an operand.  *  *	We just bump the pc by the appropriate values.  */
end_comment

begin_macro
name|advance_pc
argument_list|(
argument|type
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|mode
decl_stmt|,
name|reg
decl_stmt|;
name|mode
operator|=
name|fetch_byte
argument_list|()
expr_stmt|;
name|reg
operator|=
name|mode
operator|&
literal|0xf
expr_stmt|;
name|mode
operator|=
operator|(
name|mode
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|LITERAL0
case|:
case|case
name|LITERAL1
case|:
case|case
name|LITERAL2
case|:
case|case
name|LITERAL3
case|:
return|return;
case|case
name|INDEXED
case|:
name|advance_pc
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return;
case|case
name|REGISTER
case|:
case|case
name|REG_DEF
case|:
case|case
name|AUTO_DEC
case|:
return|return;
case|case
name|AUTO_INC
case|:
if|if
condition|(
name|reg
operator|==
name|PC
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|F
condition|)
operator|(
name|void
operator|)
name|fetch_long
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|D
condition|)
block|{
operator|(
name|void
operator|)
name|fetch_long
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fetch_long
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|units
index|[
name|STDERR
index|]
operator|.
name|ufd
argument_list|,
literal|"Bad type %d in advance\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|f77_abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
case|case
name|AUTO_INC_DEF
case|:
if|if
condition|(
name|reg
operator|==
name|PC
condition|)
operator|(
name|void
operator|)
name|fetch_long
argument_list|()
expr_stmt|;
return|return;
case|case
name|BYTE_DISP
case|:
case|case
name|BYTE_DISP_DEF
case|:
operator|(
name|void
operator|)
name|fetch_byte
argument_list|()
expr_stmt|;
return|return;
case|case
name|WORD_DISP
case|:
case|case
name|WORD_DISP_DEF
case|:
operator|(
name|void
operator|)
name|fetch_word
argument_list|()
expr_stmt|;
return|return;
case|case
name|LONG_DISP
case|:
case|case
name|LONG_DISP_DEF
case|:
operator|(
name|void
operator|)
name|fetch_long
argument_list|()
expr_stmt|;
return|return;
default|default:
name|fprintf
argument_list|(
name|units
index|[
name|STDERR
index|]
operator|.
name|ufd
argument_list|,
literal|"Bad mode 0x%x in op_length()\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|f77_abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_function
name|anyval
modifier|*
name|get_operand_address
parameter_list|(
name|type
parameter_list|)
block|{
specifier|register
name|int
name|mode
decl_stmt|,
name|reg
decl_stmt|,
name|base
decl_stmt|;
name|mode
operator|=
name|fetch_byte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
name|reg
operator|=
name|mode
operator|&
literal|0xf
expr_stmt|;
name|mode
operator|=
operator|(
name|mode
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|LITERAL0
case|:
case|case
name|LITERAL1
case|:
case|case
name|LITERAL2
case|:
case|case
name|LITERAL3
case|:
return|return
name|NULL
return|;
case|case
name|INDEXED
case|:
name|base
operator|=
operator|(
name|int
operator|)
name|get_operand_address
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|base
operator|+=
name|contents_of_reg
argument_list|(
name|reg
argument_list|)
operator|*
name|type_length
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|anyval
operator|*
operator|)
name|base
return|;
case|case
name|REGISTER
case|:
return|return
name|addr_of_reg
argument_list|(
name|reg
argument_list|)
return|;
case|case
name|REG_DEF
case|:
return|return
operator|(
name|anyval
operator|*
operator|)
name|contents_of_reg
argument_list|(
name|reg
argument_list|)
return|;
case|case
name|AUTO_DEC
case|:
return|return
operator|(
name|anyval
operator|*
operator|)
operator|(
name|contents_of_reg
argument_list|(
name|reg
argument_list|)
operator|-
name|type_length
argument_list|(
name|type
argument_list|)
operator|)
return|;
case|case
name|AUTO_INC
case|:
return|return
operator|(
name|anyval
operator|*
operator|)
name|contents_of_reg
argument_list|(
name|reg
argument_list|)
return|;
case|case
name|AUTO_INC_DEF
case|:
return|return
operator|(
name|anyval
operator|*
operator|)
operator|*
operator|(
name|long
operator|*
operator|)
name|contents_of_reg
argument_list|(
name|reg
argument_list|)
return|;
case|case
name|BYTE_DISP
case|:
name|base
operator|=
name|fetch_byte
argument_list|()
expr_stmt|;
name|base
operator|+=
name|contents_of_reg
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|anyval
operator|*
operator|)
name|base
return|;
case|case
name|BYTE_DISP_DEF
case|:
name|base
operator|=
name|fetch_byte
argument_list|()
expr_stmt|;
name|base
operator|+=
name|contents_of_reg
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|anyval
operator|*
operator|)
operator|*
operator|(
name|long
operator|*
operator|)
name|base
return|;
case|case
name|WORD_DISP
case|:
name|base
operator|=
name|fetch_word
argument_list|()
expr_stmt|;
name|base
operator|+=
name|contents_of_reg
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|anyval
operator|*
operator|)
name|base
return|;
case|case
name|WORD_DISP_DEF
case|:
name|base
operator|=
name|fetch_word
argument_list|()
expr_stmt|;
name|base
operator|+=
name|contents_of_reg
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|anyval
operator|*
operator|)
operator|*
operator|(
name|long
operator|*
operator|)
name|base
return|;
case|case
name|LONG_DISP
case|:
name|base
operator|=
name|fetch_long
argument_list|()
expr_stmt|;
name|base
operator|+=
name|contents_of_reg
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|anyval
operator|*
operator|)
name|base
return|;
case|case
name|LONG_DISP_DEF
case|:
name|base
operator|=
name|fetch_long
argument_list|()
expr_stmt|;
name|base
operator|+=
name|contents_of_reg
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|anyval
operator|*
operator|)
operator|*
operator|(
name|long
operator|*
operator|)
name|base
return|;
default|default:
name|fprintf
argument_list|(
name|units
index|[
name|STDERR
index|]
operator|.
name|ufd
argument_list|,
literal|"Bad mode 0x%x in get_addr()\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|f77_abort
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_macro
name|contents_of_reg
argument_list|(
argument|reg
argument_list|)
end_macro

begin_block
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|PC
condition|)
name|value
operator|=
operator|(
name|int
operator|)
name|pc
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|==
name|SP
condition|)
name|value
operator|=
operator|(
name|int
operator|)
operator|&
name|regs0t6
index|[
literal|6
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|==
name|FP
condition|)
name|value
operator|=
name|regs0t6
index|[
operator|-
literal|2
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|==
name|AP
condition|)
name|value
operator|=
name|regs0t6
index|[
operator|-
literal|3
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|0
operator|&&
name|reg
operator|<=
literal|6
condition|)
name|value
operator|=
name|regs0t6
index|[
name|reg
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|7
operator|&&
name|reg
operator|<=
literal|11
condition|)
name|value
operator|=
name|regs7t11
index|[
name|reg
index|]
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|units
index|[
name|STDERR
index|]
operator|.
name|ufd
argument_list|,
literal|"Bad register 0x%x to contents_of()\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|f77_abort
argument_list|()
expr_stmt|;
name|value
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_block

begin_function
name|anyval
modifier|*
name|addr_of_reg
parameter_list|(
name|reg
parameter_list|)
block|{
if|if
condition|(
name|reg
operator|>=
literal|0
operator|&&
name|reg
operator|<=
literal|6
condition|)
block|{
return|return
operator|(
name|anyval
operator|*
operator|)
operator|&
name|regs0t6
index|[
name|reg
index|]
return|;
block|}
if|if
condition|(
name|reg
operator|>=
literal|7
operator|&&
name|reg
operator|<=
literal|11
condition|)
block|{
return|return
operator|(
name|anyval
operator|*
operator|)
operator|&
name|regs7t11
index|[
name|reg
index|]
return|;
block|}
name|fprintf
argument_list|(
name|units
index|[
name|STDERR
index|]
operator|.
name|ufd
argument_list|,
literal|"Bad reg 0x%x to addr_of()\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|f77_abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	fetch_{byte, word, long} - extract values from the PROGRAM area.  *  *	These routines are used in the operand decoding to extract various  *	fields from where the program counter points.  This is because the  *	addressing on the Vax is dynamic: the program counter advances  *	while we are grabbing operands, as well as when we pass instructions.  *	This makes things a bit messy, but I can't help it.  */
end_comment

begin_macro
name|fetch_byte
argument_list|()
end_macro

begin_block
block|{
return|return
operator|*
name|pc
operator|++
return|;
block|}
end_block

begin_macro
name|fetch_word
argument_list|()
end_macro

begin_block
block|{
name|int
modifier|*
name|old_pc
decl_stmt|;
name|old_pc
operator|=
operator|(
name|int
operator|*
operator|)
name|pc
expr_stmt|;
name|pc
operator|+=
literal|2
expr_stmt|;
return|return
operator|*
name|old_pc
return|;
block|}
end_block

begin_macro
name|fetch_long
argument_list|()
end_macro

begin_block
block|{
name|long
modifier|*
name|old_pc
decl_stmt|;
name|old_pc
operator|=
operator|(
name|long
operator|*
operator|)
name|pc
expr_stmt|;
name|pc
operator|+=
literal|4
expr_stmt|;
return|return
operator|*
name|old_pc
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|type_length
argument_list|(
argument|type
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|type
operator|==
name|F
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|type
operator|==
name|D
condition|)
return|return
literal|8
return|;
name|fprintf
argument_list|(
name|units
index|[
name|STDERR
index|]
operator|.
name|ufd
argument_list|,
literal|"Bad type 0x%x in type_length()\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|f77_abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|opcode_name
parameter_list|(
name|opcode
parameter_list|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|ACBD
case|:
return|return
literal|"ACBD"
return|;
case|case
name|ACBF
case|:
return|return
literal|"ACBF"
return|;
case|case
name|ADDD2
case|:
return|return
literal|"ADDD2"
return|;
case|case
name|ADDD3
case|:
return|return
literal|"ADDD3"
return|;
case|case
name|ADDF2
case|:
return|return
literal|"ADDF2"
return|;
case|case
name|ADDF3
case|:
return|return
literal|"ADDF3"
return|;
case|case
name|CMPD
case|:
return|return
literal|"CMPD"
return|;
case|case
name|CMPF
case|:
return|return
literal|"CMPF"
return|;
case|case
name|CVTDB
case|:
return|return
literal|"CVTDB"
return|;
case|case
name|CVTDF
case|:
return|return
literal|"CVTDF"
return|;
case|case
name|CVTDL
case|:
return|return
literal|"CVTDL"
return|;
case|case
name|CVTDW
case|:
return|return
literal|"CVTDW"
return|;
case|case
name|CVTFB
case|:
return|return
literal|"CVTFB"
return|;
case|case
name|CVTFD
case|:
return|return
literal|"CVTFD"
return|;
case|case
name|CVTFL
case|:
return|return
literal|"CVTFL"
return|;
case|case
name|CVTFW
case|:
return|return
literal|"CVTFW"
return|;
case|case
name|CVTRDL
case|:
return|return
literal|"CVTRDL"
return|;
case|case
name|CVTRFL
case|:
return|return
literal|"CVTRFL"
return|;
case|case
name|DIVD2
case|:
return|return
literal|"DIVD2"
return|;
case|case
name|DIVD3
case|:
return|return
literal|"DIVD3"
return|;
case|case
name|DIVF2
case|:
return|return
literal|"DIVF2"
return|;
case|case
name|DIVF3
case|:
return|return
literal|"DIVF3"
return|;
case|case
name|EMODD
case|:
return|return
literal|"EMODD"
return|;
case|case
name|EMODF
case|:
return|return
literal|"EMODF"
return|;
case|case
name|MNEGD
case|:
return|return
literal|"MNEGD"
return|;
case|case
name|MNEGF
case|:
return|return
literal|"MNEGF"
return|;
case|case
name|MOVD
case|:
return|return
literal|"MOVD"
return|;
case|case
name|MOVF
case|:
return|return
literal|"MOVF"
return|;
case|case
name|MULD2
case|:
return|return
literal|"MULD2"
return|;
case|case
name|MULD3
case|:
return|return
literal|"MULD3"
return|;
case|case
name|MULF2
case|:
return|return
literal|"MULF2"
return|;
case|case
name|MULF3
case|:
return|return
literal|"MULF3"
return|;
case|case
name|POLYD
case|:
return|return
literal|"POLYD"
return|;
case|case
name|POLYF
case|:
return|return
literal|"POLYF"
return|;
case|case
name|SUBD2
case|:
return|return
literal|"SUBD2"
return|;
case|case
name|SUBD3
case|:
return|return
literal|"SUBD3"
return|;
case|case
name|SUBF2
case|:
return|return
literal|"SUBF2"
return|;
case|case
name|SUBF3
case|:
return|return
literal|"SUBF3"
return|;
case|case
name|TSTD
case|:
return|return
literal|"TSTD"
return|;
case|case
name|TSTF
case|:
return|return
literal|"TSTF"
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|vax
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|tahoe
end_ifdef

begin_comment
comment|/*  *	NO RESERVED OPERAND EXCEPTION ON RESULT OF FP OVERFLOW ON TAHOE.  * 	JUST PRINT THE OVERFLOW MESSAGE. RESULT IS 0 (zero).  */
end_comment

begin_comment
comment|/*  *	GLOBAL VARIABLES (we need a few)  *  *	Actual program counter and locations of registers.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|regs0t1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|regs2t12
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_messages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_overflows
decl_stmt|;
end_decl_stmt

begin_union
specifier|static
union|union
block|{
name|long
name|v_long
index|[
literal|2
index|]
decl_stmt|;
name|double
name|v_double
decl_stmt|;
block|}
name|retrn
union|;
end_union

begin_decl_stmt
specifier|static
name|sig_t
name|sigill_default
init|=
operator|(
name|SIG_VAL
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sig_t
name|sigfpe_default
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *	This routine sets up the signal handler for the floating-point  *	and reserved operand interrupts.  */
end_comment

begin_macro
name|trapov_
argument_list|(
argument|count
argument_list|,
argument|rtnval
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
modifier|*
name|rtnval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|void
name|got_overflow
parameter_list|()
function_decl|;
name|sigfpe_default
operator|=
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|got_overflow
argument_list|)
expr_stmt|;
name|total_overflows
operator|=
literal|0
expr_stmt|;
name|max_messages
operator|=
operator|*
name|count
expr_stmt|;
name|retrn
operator|.
name|v_double
operator|=
operator|*
name|rtnval
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	got_overflow - routine called when overflow occurs  *  *	This routine just prints a message about the overflow.  *	It is impossible to find the bad result at this point.  * 	 NEXT 2 LINES DON'T HOLD FOR TAHOE !  *	Instead, we wait until we get the reserved operand exception  *	when we try to use it.  This raises the SIGILL signal.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|got_overflow
parameter_list|(
name|signo
parameter_list|,
name|codeword
parameter_list|,
name|sc
parameter_list|)
name|int
name|signo
decl_stmt|,
name|codeword
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|sc
decl_stmt|;
block|{
name|int
modifier|*
name|sp
decl_stmt|,
name|i
decl_stmt|;
name|FILE
modifier|*
name|ef
decl_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|got_overflow
argument_list|)
expr_stmt|;
name|ef
operator|=
name|units
index|[
name|STDERR
index|]
operator|.
name|ufd
expr_stmt|;
switch|switch
condition|(
name|codeword
condition|)
block|{
case|case
name|INT_OVF_T
case|:
case|case
name|INT_DIV_T
case|:
case|case
name|FLT_UND_T
case|:
case|case
name|FLT_DIV_T
case|:
if|if
condition|(
name|sigfpe_default
operator|>
operator|(
name|SIG_VAL
operator|)
literal|7
condition|)
call|(
modifier|*
name|sigfpe_default
call|)
argument_list|(
name|signo
argument_list|,
name|codeword
argument_list|,
name|sc
argument_list|)
expr_stmt|;
else|else
name|sigdie
argument_list|(
name|signo
argument_list|,
name|codeword
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|FLT_OVF_T
case|:
if|if
condition|(
operator|++
name|total_overflows
operator|<=
name|max_messages
condition|)
block|{
name|fprintf
argument_list|(
name|ef
argument_list|,
literal|"trapov: %s"
argument_list|,
name|act_fpe
index|[
name|codeword
operator|-
literal|1
index|]
operator|.
name|mesg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ef
argument_list|,
literal|": Current PC = %X"
argument_list|,
name|sc
operator|->
name|sc_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_overflows
operator|==
name|max_messages
condition|)
name|fprintf
argument_list|(
name|ef
argument_list|,
literal|": No more messages will be printed.\n"
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|ef
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
end_function

begin_function
name|int
name|ovcnt_
parameter_list|()
block|{
return|return
name|total_overflows
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|tahoe
end_endif

end_unit

