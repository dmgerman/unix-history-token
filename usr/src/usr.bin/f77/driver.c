begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
name|char
modifier|*
name|xxxvers
index|[]
init|=
literal|"\n@(#) FORTRAN 77 DRIVER, VERSION 2.03.5,   7 NOVEMBER 1980\n"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"defines"
end_include

begin_include
include|#
directive|include
file|"machdefs"
end_include

begin_include
include|#
directive|include
file|"drivedefs"
end_include

begin_include
include|#
directive|include
file|"ftypes"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
specifier|static
name|FILEP
name|diagfile
init|=
block|{
name|stderr
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigivalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigqvalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sighvalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigtvalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pass1name
init|=
name|PASS1NAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pass2name
init|=
name|PASS2NAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|asmname
init|=
name|ASMNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ldname
init|=
name|LDNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|footname
init|=
name|FOOTNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|proffoot
init|=
name|PROFFOOT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|macroname
init|=
literal|"m4"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|shellname
init|=
literal|"/bin/sh"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|aoutname
init|=
literal|"a.out"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temppref
init|=
name|TEMPPREF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|infname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|textfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|asmfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|asmpass2
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|initfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sortfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|prepfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|objfdefault
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|optzfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|setfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|fflags
index|[
literal|50
index|]
init|=
literal|"-"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cflags
index|[
literal|50
index|]
init|=
literal|"-c"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|TARGET
operator|==
name|GCOS
end_if

begin_decl_stmt
specifier|static
name|char
name|eflags
index|[
literal|30
index|]
init|=
literal|"system=gcos "
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|eflags
index|[
literal|30
index|]
init|=
literal|"system=unix "
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|rflags
index|[
literal|30
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|lflag
index|[
literal|3
index|]
init|=
literal|"-x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fflagp
init|=
name|fflags
operator|+
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cflagp
init|=
name|cflags
operator|+
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|eflagp
init|=
name|eflags
operator|+
literal|12
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rflagp
init|=
name|rflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|loadargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|loadp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|erred
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|loadflag
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|saveasmflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|profileflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|optimflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|debugflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|verbose
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|nofloating
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|fortonly
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|macroflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|sdbflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|status
decl_stmt|;
name|char
modifier|*
name|setdoto
argument_list|()
decl_stmt|,
modifier|*
name|lastchar
argument_list|()
decl_stmt|,
modifier|*
name|lastfield
argument_list|()
decl_stmt|,
modifier|*
name|copys
argument_list|()
decl_stmt|;
name|ptr
name|ckalloc
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|fortfile
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|int
name|intrupt
parameter_list|()
function_decl|;
name|sigivalue
operator|=
operator|(
name|int
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|&
literal|01
expr_stmt|;
name|sigqvalue
operator|=
operator|(
name|int
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|&
literal|01
expr_stmt|;
name|sighvalue
operator|=
operator|(
name|int
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|&
literal|01
expr_stmt|;
name|sigtvalue
operator|=
operator|(
name|int
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|&
literal|01
expr_stmt|;
name|enbint
argument_list|(
name|intrupt
argument_list|)
expr_stmt|;
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|crfnames
argument_list|()
expr_stmt|;
name|loadargs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|argc
operator|+
literal|20
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|loadargs
argument_list|)
argument_list|)
expr_stmt|;
name|loadargs
index|[
literal|1
index|]
operator|=
literal|"-X"
expr_stmt|;
name|loadargs
index|[
literal|2
index|]
operator|=
literal|"-u"
expr_stmt|;
if|#
directive|if
name|HERE
operator|==
name|PDP11
operator|||
name|HERE
operator|==
name|VAX
name|loadargs
index|[
literal|3
index|]
operator|=
literal|"_MAIN__"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HERE
operator|==
name|INTERDATA
name|loadargs
index|[
literal|3
index|]
operator|=
literal|"main"
expr_stmt|;
endif|#
directive|endif
name|loadp
operator|=
name|loadargs
operator|+
literal|4
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|s
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|1
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'T'
case|:
comment|/* use special passes */
switch|switch
condition|(
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'1'
case|:
name|pass1name
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'2'
case|:
name|pass2name
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'a'
case|:
name|asmname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'l'
case|:
name|ldname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'F'
case|:
name|footname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'m'
case|:
name|macroname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'t'
case|:
name|temppref
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
default|default:
name|fatali
argument_list|(
literal|"bad option -T%c"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'6'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'6'
condition|)
block|{
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
goto|goto
name|copyfflag
goto|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"invalid flag 6%c\n"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
case|case
literal|'w'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'6'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|copyfflag
label|:
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
case|case
literal|'1'
case|:
case|case
literal|'C'
case|:
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|optimflag
operator|=
name|YES
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
operator|*
name|loadp
operator|++
operator|=
literal|"-r"
expr_stmt|;
operator|*
name|loadp
operator|++
operator|=
literal|"-d"
expr_stmt|;
endif|#
directive|endif
operator|*
name|fflagp
operator|++
operator|=
literal|'O'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|fflagp
operator|++
operator|=
operator|*
operator|++
name|s
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
operator|*
name|fflagp
operator|++
operator|=
literal|'N'
expr_stmt|;
if|if
condition|(
name|oneof
argument_list|(
operator|*
operator|++
name|s
argument_list|,
literal|"qxscn"
argument_list|)
condition|)
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"invalid flag -N%c\n"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
literal|'X'
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'m'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'4'
condition|)
operator|++
name|s
expr_stmt|;
name|macroflag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|strcat
argument_list|(
name|cflags
argument_list|,
literal|" -S"
argument_list|)
expr_stmt|;
name|saveasmflag
operator|=
name|YES
expr_stmt|;
case|case
literal|'c'
case|:
name|loadflag
operator|=
name|NO
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debugflag
operator|=
name|YES
expr_stmt|;
goto|goto
name|copyfflag
goto|;
case|case
literal|'M'
case|:
operator|*
name|loadp
operator|++
operator|=
literal|"-M"
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|strcat
argument_list|(
name|cflags
argument_list|,
literal|" -g"
argument_list|)
expr_stmt|;
name|sdbflag
operator|=
name|YES
expr_stmt|;
goto|goto
name|copyfflag
goto|;
case|case
literal|'p'
case|:
name|profileflag
operator|=
name|YES
expr_stmt|;
name|strcat
argument_list|(
name|cflags
argument_list|,
literal|" -p"
argument_list|)
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
literal|'p'
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'g'
condition|)
block|{
name|proffoot
operator|=
name|GPRFFOOT
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"onetrip"
argument_list|)
condition|)
block|{
operator|*
name|fflagp
operator|++
operator|=
literal|'1'
expr_stmt|;
goto|goto
name|endfor
goto|;
block|}
name|aoutname
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
break|break;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
case|case
literal|'f'
case|:
name|nofloating
operator|=
name|YES
expr_stmt|;
name|pass2name
operator|=
name|NOFLPASS2
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'F'
case|:
name|fortonly
operator|=
name|YES
expr_stmt|;
name|loadflag
operator|=
name|NO
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'2'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'4'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
block|{
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
goto|goto
name|copyfflag
goto|;
block|}
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"invalid flag -I%c\n"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'l'
case|:
comment|/* letter ell--library */
name|s
index|[
operator|-
literal|1
index|]
operator|=
literal|'-'
expr_stmt|;
operator|*
name|loadp
operator|++
operator|=
name|s
operator|-
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'E'
case|:
comment|/* EFL flag argument */
while|while
condition|(
operator|*
name|eflagp
operator|++
operator|=
operator|*
operator|++
name|s
condition|)
empty_stmt|;
operator|*
name|eflagp
operator|++
operator|=
literal|' '
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'R'
case|:
while|while
condition|(
operator|*
name|rflagp
operator|++
operator|=
operator|*
operator|++
name|s
condition|)
empty_stmt|;
operator|*
name|rflagp
operator|++
operator|=
literal|' '
expr_stmt|;
goto|goto
name|endfor
goto|;
default|default:
name|lflag
index|[
literal|1
index|]
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|loadp
operator|++
operator|=
name|copys
argument_list|(
name|lflag
argument_list|)
expr_stmt|;
break|break;
block|}
name|endfor
label|:
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
block|}
operator|*
name|fflagp
operator|=
literal|'\0'
expr_stmt|;
name|loadargs
index|[
literal|0
index|]
operator|=
name|ldname
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
if|if
condition|(
name|nofloating
condition|)
operator|*
name|loadp
operator|++
operator|=
operator|(
name|profileflag
condition|?
name|NOFLPROF
else|:
name|NOFLFOOT
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|*
name|loadp
operator|++
operator|=
operator|(
name|profileflag
condition|?
name|proffoot
else|:
name|footname
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
switch|switch
condition|(
name|c
operator|=
name|dotchar
argument_list|(
name|infname
operator|=
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* Ratfor file */
case|case
literal|'e'
case|:
comment|/* EFL file */
if|if
condition|(
name|unreadable
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|fortfile
expr_stmt|;
name|t
operator|=
name|lastfield
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
condition|)
empty_stmt|;
name|s
index|[
operator|-
literal|2
index|]
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|macroflag
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s>%s"
argument_list|,
name|macroname
argument_list|,
name|infname
argument_list|,
name|prepfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
block|{
name|rmf
argument_list|(
name|prepfname
argument_list|)
expr_stmt|;
name|erred
operator|=
name|YES
expr_stmt|;
break|break;
block|}
name|infname
operator|=
name|prepfname
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'e'
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"efl %s %s>%s"
argument_list|,
name|eflags
argument_list|,
name|infname
argument_list|,
name|fortfile
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"ratfor %s %s>%s"
argument_list|,
name|rflags
argument_list|,
name|infname
argument_list|,
name|fortfile
argument_list|)
expr_stmt|;
name|status
operator|=
name|sys
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|macroflag
condition|)
name|rmf
argument_list|(
name|infname
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
name|rmf
argument_list|(
name|fortfile
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|fortonly
condition|)
block|{
name|infname
operator|=
name|argv
index|[
name|i
index|]
operator|=
name|lastfield
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|lastchar
argument_list|(
name|infname
argument_list|)
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|dofort
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
else|else
block|{
if|if
condition|(
name|nodup
argument_list|(
name|t
operator|=
name|setdoto
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|t
expr_stmt|;
name|rmf
argument_list|(
name|fortfile
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'f'
case|:
comment|/* Fortran file */
case|case
literal|'F'
case|:
if|if
condition|(
name|unreadable
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|dofort
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|nodup
argument_list|(
name|t
operator|=
name|setdoto
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|t
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* C file */
case|case
literal|'s'
case|:
comment|/* Assembler file */
if|if
condition|(
name|unreadable
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HERE
operator|==
name|PDP11
operator|||
name|HERE
operator|==
name|VAX
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%s:\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"cc %s %s"
argument_list|,
name|cflags
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|nodup
argument_list|(
name|t
operator|=
name|setdoto
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|t
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|nodup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-o"
argument_list|)
condition|)
name|aoutname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
operator|*
name|loadp
operator|++
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|loadflag
operator|&&
operator|!
name|erred
condition|)
name|doload
argument_list|(
name|loadargs
argument_list|,
name|loadp
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|erred
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|dofort
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retcode
decl_stmt|;
name|char
name|buff
index|[
literal|200
index|]
decl_stmt|;
name|infname
operator|=
name|s
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s %s %s %s"
argument_list|,
name|pass1name
argument_list|,
name|fflags
argument_list|,
name|s
argument_list|,
name|asmfname
argument_list|,
name|initfname
argument_list|,
name|textfname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
goto|goto
name|error
goto|;
case|case
literal|0
case|:
break|break;
default|default:
goto|goto
name|comperror
goto|;
block|}
if|if
condition|(
name|content
argument_list|(
name|initfname
argument_list|)
operator|>
literal|0
condition|)
if|if
condition|(
name|dodata
argument_list|()
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|dopass2
argument_list|()
condition|)
goto|goto
name|comperror
goto|;
name|doasm
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
name|ret
label|:
name|rmf
argument_list|(
name|asmfname
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|initfname
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|textfname
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
name|error
label|:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\nError.  No assembly.\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
name|comperror
label|:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\ncompiler error.\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|2
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
end_block

begin_macro
name|dopass2
argument_list|()
end_macro

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"PASS2."
argument_list|)
expr_stmt|;
if|#
directive|if
name|FAMILY
operator|==
name|DMR
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s - %s"
argument_list|,
name|pass2name
argument_list|,
name|textfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
return|return
operator|(
name|sys
argument_list|(
name|buff
argument_list|)
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FAMILY
operator|==
name|PCC
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -A%s<%s>%s"
argument_list|,
name|pass2name
argument_list|,
name|setfname
argument_list|,
name|textfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s>%s"
argument_list|,
name|pass2name
argument_list|,
name|textfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|sys
argument_list|(
name|buff
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|doasm
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|lastc
decl_stmt|;
name|char
modifier|*
name|obj
decl_stmt|;
name|char
name|buff
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|lastchar
argument_list|()
decl_stmt|,
modifier|*
name|setdoto
argument_list|()
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|s
operator|=
name|objfdefault
expr_stmt|;
name|lastc
operator|=
name|lastchar
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|obj
operator|=
name|setdoto
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
operator|||
name|TARGET
operator|==
name|VAX
ifdef|#
directive|ifdef
name|PASS2OPT
if|if
condition|(
name|optimflag
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s"
argument_list|,
name|PASS2OPT
argument_list|,
name|asmpass2
argument_list|,
name|optzfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
name|rmf
argument_list|(
name|optzfname
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"mv %s %s"
argument_list|,
name|optzfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
name|sys
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|saveasmflag
condition|)
block|{
operator|*
name|lastc
operator|=
literal|'s'
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"cat %s %s %s>%s"
argument_list|,
name|asmfname
argument_list|,
name|setfname
argument_list|,
name|asmpass2
argument_list|,
name|obj
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"cat %s %s>%s"
argument_list|,
name|asmfname
argument_list|,
name|asmpass2
argument_list|,
name|obj
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sys
argument_list|(
name|buff
argument_list|)
expr_stmt|;
operator|*
name|lastc
operator|=
literal|'o'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"  ASM."
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -o %s %s %s %s"
argument_list|,
name|asmname
argument_list|,
name|obj
argument_list|,
name|asmfname
argument_list|,
name|setfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|VAX
comment|/* vax assembler currently accepts only one input file */
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"cat %s>>%s"
argument_list|,
name|asmpass2
argument_list|,
name|asmfname
argument_list|)
expr_stmt|;
name|sys
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -o %s %s"
argument_list|,
name|asmname
argument_list|,
name|obj
argument_list|,
name|asmfname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|PDP11
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -u -o %s %s %s"
argument_list|,
name|asmname
argument_list|,
name|obj
argument_list|,
name|asmfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|!=
name|INTERDATA
operator|&&
name|TARGET
operator|!=
name|PDP11
operator|&&
name|TARGET
operator|!=
name|VAX
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -o %s %s %s"
argument_list|,
name|asmname
argument_list|,
name|obj
argument_list|,
name|asmfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"assembler error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HERE
operator|==
name|PDP11
operator|&&
name|TARGET
operator|!=
name|PDP11
name|rmf
argument_list|(
name|obj
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|rmf
argument_list|(
name|asmpass2
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|doload
argument_list|(
name|v0
argument_list|,
name|v
argument_list|)
specifier|register
name|char
operator|*
name|v0
index|[]
operator|,
operator|*
name|v
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|waitpid
decl_stmt|;
if|if
condition|(
name|sdbflag
condition|)
operator|*
name|v
operator|++
operator|=
literal|"-lg"
expr_stmt|;
for|for
control|(
name|p
operator|=
name|liblist
init|;
operator|*
name|p
condition|;
operator|*
name|v
operator|++
operator|=
operator|*
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|v
operator|++
operator|=
literal|"-o"
expr_stmt|;
operator|*
name|v
operator|++
operator|=
name|aoutname
expr_stmt|;
operator|*
name|v
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"LOAD."
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflag
condition|)
block|{
for|for
control|(
name|p
operator|=
name|v0
init|;
name|p
operator|<
name|v
condition|;
operator|++
name|p
control|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%s "
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HERE
operator|==
name|PDP11
operator|||
name|HERE
operator|==
name|INTERDATA
operator|||
name|HERE
operator|==
name|VAX
if|if
condition|(
operator|(
name|waitpid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|enbint
argument_list|(
name|SIG_DFL
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|ldname
argument_list|,
name|v0
argument_list|)
expr_stmt|;
name|fatalstr
argument_list|(
literal|"couldn't load %s"
argument_list|,
name|ldname
argument_list|)
expr_stmt|;
block|}
name|await
argument_list|(
name|waitpid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HERE
operator|==
name|INTERDATA
if|if
condition|(
name|optimflag
condition|)
block|{
name|char
name|buff1
index|[
literal|100
index|]
decl_stmt|,
name|buff2
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff1
argument_list|,
literal|"nopt %s -o junk.%d"
argument_list|,
name|aoutname
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff2
argument_list|,
literal|"mv junk.%d %s"
argument_list|,
name|pid
argument_list|,
name|aoutname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
argument_list|(
name|buff1
argument_list|)
operator|||
name|sys
argument_list|(
name|buff2
argument_list|)
condition|)
name|err
argument_list|(
literal|"bad optimization"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Process control and Shell-simulating routines */
end_comment

begin_macro
name|sys
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|100
index|]
decl_stmt|,
name|path
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|inname
decl_stmt|,
modifier|*
name|outname
decl_stmt|;
name|int
name|append
decl_stmt|;
name|int
name|waitpid
decl_stmt|;
name|int
name|argc
decl_stmt|;
if|if
condition|(
name|debugflag
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|inname
operator|=
name|NULL
expr_stmt|;
name|outname
operator|=
name|NULL
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|shellname
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|str
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
operator|++
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'<'
condition|)
name|inname
operator|=
name|t
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|t
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
block|{
name|append
operator|=
name|YES
expr_stmt|;
name|outname
operator|=
name|t
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|append
operator|=
name|NO
expr_stmt|;
name|outname
operator|=
name|t
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
operator|&&
operator|*
name|t
operator|!=
literal|'\0'
condition|)
operator|++
name|t
expr_stmt|;
if|if
condition|(
operator|*
name|t
condition|)
block|{
operator|*
name|t
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
operator|++
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
comment|/* no command */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|path
expr_stmt|;
name|t
operator|=
literal|"/usr/bin/"
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
for|for
control|(
name|t
operator|=
name|argv
index|[
literal|1
index|]
init|;
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
condition|;
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|waitpid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|inname
condition|)
name|freopen
argument_list|(
name|inname
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|outname
condition|)
name|freopen
argument_list|(
name|outname
argument_list|,
operator|(
name|append
condition|?
literal|"a"
else|:
literal|"w"
operator|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|enbint
argument_list|(
name|SIG_DFL
argument_list|)
expr_stmt|;
name|texec
argument_list|(
name|path
operator|+
literal|9
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* command */
name|texec
argument_list|(
name|path
operator|+
literal|4
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/*  /bin/command */
name|texec
argument_list|(
name|path
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* /usr/bin/command */
name|fatalstr
argument_list|(
literal|"Cannot load %s"
argument_list|,
name|path
operator|+
literal|9
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|await
argument_list|(
name|waitpid
argument_list|)
operator|)
return|;
block|}
end_block

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_comment
comment|/* modified version from the Shell */
end_comment

begin_macro
name|texec
argument_list|(
argument|f
argument_list|,
argument|av
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|execv
argument_list|(
name|f
argument_list|,
name|av
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOEXEC
condition|)
block|{
name|av
index|[
literal|1
index|]
operator|=
name|f
expr_stmt|;
name|execv
argument_list|(
name|shellname
argument_list|,
name|av
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"No shell!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
name|fatalstr
argument_list|(
literal|"%s: too large"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|done
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|recurs
init|=
name|NO
decl_stmt|;
if|if
condition|(
name|recurs
operator|==
name|NO
condition|)
block|{
name|recurs
operator|=
name|YES
expr_stmt|;
name|rmfiles
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
end_block

begin_function_decl
name|enbint
function_decl|(
name|k
function_decl|)
name|int
argument_list|(
argument|*k
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|sigivalue
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigqvalue
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|sighvalue
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigtvalue
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|intrupt
argument_list|()
end_macro

begin_block
block|{
name|done
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|await
argument_list|(
argument|waitpid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|waitpid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|w
decl_stmt|,
name|status
decl_stmt|;
name|enbint
argument_list|(
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|waitpid
condition|)
if|if
condition|(
name|w
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"bad wait code"
argument_list|)
expr_stmt|;
name|enbint
argument_list|(
name|intrupt
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0377
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|SIGINT
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Termination code %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|>>
literal|8
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* File Name and File Manipulation Routines */
end_comment

begin_expr_stmt
name|unreadable
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Error: Cannot read file %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|clf
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|FILEP
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
name|stdout
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"writing error"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|rmfiles
argument_list|()
end_macro

begin_block
block|{
name|rmf
argument_list|(
name|textfname
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|asmfname
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|initfname
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|asmpass2
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
name|rmf
argument_list|(
name|setfname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* return -1 if file does not exist, 0 if it is of zero length    and 1 if of positive length */
end_comment

begin_macro
name|content
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|VERSION6
struct|struct
name|stat
block|{
name|char
name|cjunk
index|[
literal|9
index|]
decl_stmt|;
name|char
name|size0
decl_stmt|;
name|int
name|size1
decl_stmt|;
name|int
name|ijunk
index|[
literal|12
index|]
decl_stmt|;
block|}
name|buf
struct|;
else|#
directive|else
include|#
directive|include
file|<sys/types.h>
include|#
directive|include
file|<sys/stat.h>
name|struct
name|stat
name|buf
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|VERSION6
return|return
operator|(
name|buf
operator|.
name|size0
operator|||
name|buf
operator|.
name|size1
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|buf
operator|.
name|st_size
operator|>
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|crfnames
argument_list|()
end_macro

begin_block
block|{
name|fname
argument_list|(
name|textfname
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|asmfname
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|asmpass2
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|initfname
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|sortfname
argument_list|,
literal|"S"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|objfdefault
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|prepfname
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|optzfname
argument_list|,
literal|"z"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|setfname
argument_list|,
literal|"A"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rmf
argument_list|(
name|fn
argument_list|)
specifier|register
name|char
operator|*
name|fn
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|debugflag
operator|&&
name|fn
operator|!=
name|NULL
operator|&&
operator|*
name|fn
operator|!=
literal|'\0'
condition|)
name|unlink
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|LOCAL
name|fname
parameter_list|(
name|name
parameter_list|,
name|suff
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|suff
decl_stmt|;
end_function

begin_block
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"/tmp/%s%d.%s"
argument_list|,
name|temppref
argument_list|,
name|pid
argument_list|,
name|suff
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dotchar
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
for|for
control|(
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|s
index|[
literal|1
index|]
operator|)
return|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|lastfield
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
name|t
operator|=
name|s
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|lastchar
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
operator|++
name|s
expr_stmt|;
return|return
operator|(
name|s
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|setdoto
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
operator|*
name|lastchar
argument_list|(
name|s
argument_list|)
operator|=
literal|'o'
expr_stmt|;
return|return
operator|(
name|lastfield
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|badfile
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fatalstr
argument_list|(
literal|"cannot open intermediate file %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|ptr
name|ckalloc
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|ptr
name|p
decl_stmt|,
name|calloc
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|n
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|fatal
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|char
modifier|*
name|copyn
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|copys
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
name|copyn
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|oneof
argument_list|(
name|c
argument_list|,
name|s
argument_list|)
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|c
condition|)
return|return
operator|(
name|YES
operator|)
return|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_macro
name|nodup
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|loadargs
init|;
name|p
operator|<
name|loadp
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
name|s
argument_list|)
condition|)
return|return
operator|(
name|NO
operator|)
return|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|fatal
argument_list|(
argument|t
argument_list|)
name|char
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Compiler error in file %s: %s\n"
argument_list|,
name|infname
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflag
condition|)
name|abort
argument_list|()
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|fatali
argument_list|(
argument|t
argument_list|,
argument|d
argument_list|)
name|char
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|t
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|fatalstr
argument_list|(
argument|t
argument_list|,
argument|s
argument_list|)
name|char
operator|*
name|t
operator|,
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|err
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Error in file %s: %s\n"
argument_list|,
name|infname
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Code to generate initializations for DATA statements */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|nch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|FILEP
name|asmfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|FILEP
name|sortfile
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"ftypes"
end_include

begin_decl_stmt
specifier|static
name|ftnint
name|typesize
index|[
name|NTYPES
index|]
init|=
block|{
literal|1
block|,
name|SZADDR
block|,
name|SZSHORT
block|,
name|SZLONG
block|,
name|SZLONG
block|,
literal|2
operator|*
name|SZLONG
block|,
literal|2
operator|*
name|SZLONG
block|,
literal|4
operator|*
name|SZLONG
block|,
name|SZLONG
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|typealign
index|[
name|NTYPES
index|]
init|=
block|{
literal|1
block|,
name|ALIADDR
block|,
name|ALISHORT
block|,
name|ALILONG
block|,
name|ALILONG
block|,
name|ALIDOUBLE
block|,
name|ALILONG
block|,
name|ALIDOUBLE
block|,
name|ALILONG
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|dodata
argument_list|()
end_macro

begin_block
block|{
name|char
name|buff
index|[
literal|50
index|]
decl_stmt|;
name|char
name|varname
index|[
name|XL
operator|+
literal|1
index|]
decl_stmt|,
name|ovarname
index|[
name|XL
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|flag
name|erred
decl_stmt|;
name|ftnint
name|offset
decl_stmt|,
name|vlen
decl_stmt|,
name|type
decl_stmt|;
specifier|register
name|ftnint
name|ooffset
decl_stmt|,
name|ovlen
decl_stmt|;
name|ftnint
name|nblank
decl_stmt|,
name|vchar
decl_stmt|;
name|int
name|size
decl_stmt|,
name|align
decl_stmt|;
name|int
name|vargroup
decl_stmt|;
name|ftnint
name|totlen
decl_stmt|,
name|doeven
argument_list|()
decl_stmt|;
name|erred
operator|=
name|NO
expr_stmt|;
name|ovarname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ooffset
operator|=
literal|0
expr_stmt|;
name|ovlen
operator|=
literal|0
expr_stmt|;
name|totlen
operator|=
literal|0
expr_stmt|;
name|nch
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"sort %s>%s"
argument_list|,
name|initfname
argument_list|,
name|sortfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|=
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
name|fatali
argument_list|(
literal|"call sort status = %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sortfile
operator|=
name|fopen
argument_list|(
name|sortfname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|badfile
argument_list|(
name|sortfname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|asmfile
operator|=
name|fopen
argument_list|(
name|asmfname
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|badfile
argument_list|(
name|asmfname
argument_list|)
expr_stmt|;
name|pruse
argument_list|(
name|asmfile
argument_list|,
name|USEINIT
argument_list|)
expr_stmt|;
while|while
condition|(
name|rdname
argument_list|(
operator|&
name|vargroup
argument_list|,
name|varname
argument_list|)
operator|&&
name|rdlong
argument_list|(
operator|&
name|offset
argument_list|)
operator|&&
name|rdlong
argument_list|(
operator|&
name|vlen
argument_list|)
operator|&&
name|rdlong
argument_list|(
operator|&
name|type
argument_list|)
condition|)
block|{
name|size
operator|=
name|typesize
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|varname
argument_list|,
name|ovarname
argument_list|)
condition|)
block|{
name|prspace
argument_list|(
name|ovlen
operator|-
name|ooffset
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ovarname
argument_list|,
name|varname
argument_list|)
expr_stmt|;
name|ooffset
operator|=
literal|0
expr_stmt|;
name|totlen
operator|+=
name|ovlen
expr_stmt|;
name|ovlen
operator|=
name|vlen
expr_stmt|;
if|if
condition|(
name|vargroup
operator|==
literal|0
condition|)
name|align
operator|=
operator|(
name|type
operator|==
name|TYCHAR
operator|||
name|type
operator|==
name|TYBLANK
condition|?
name|SZLONG
else|:
name|typealign
index|[
name|type
index|]
operator|)
expr_stmt|;
else|else
name|align
operator|=
name|ALIDOUBLE
expr_stmt|;
name|totlen
operator|=
name|doeven
argument_list|(
name|totlen
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|vargroup
operator|==
literal|2
condition|)
name|prcomblock
argument_list|(
name|asmfile
argument_list|,
name|varname
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
name|LABELFMT
argument_list|,
name|varname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
name|ooffset
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
name|err
argument_list|(
literal|"overlapping initializations"
argument_list|)
expr_stmt|;
name|ooffset
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>
name|ooffset
condition|)
block|{
name|prspace
argument_list|(
name|offset
operator|-
name|ooffset
argument_list|)
expr_stmt|;
name|ooffset
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|rdlong
argument_list|(
operator|&
name|vchar
argument_list|)
condition|)
name|prch
argument_list|(
operator|(
name|int
operator|)
name|vchar
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"bad intermediate file format"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TYBLANK
condition|)
block|{
if|if
condition|(
name|rdlong
argument_list|(
operator|&
name|nblank
argument_list|)
condition|)
block|{
name|size
operator|=
name|nblank
expr_stmt|;
while|while
condition|(
operator|--
name|nblank
operator|>=
literal|0
condition|)
name|prch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"bad intermediate file format"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
while|while
condition|(
name|putc
argument_list|(
name|getc
argument_list|(
name|sortfile
argument_list|)
argument_list|,
name|asmfile
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|ooffset
operator|+=
name|size
operator|)
operator|>
name|ovlen
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
name|err
argument_list|(
literal|"initialization out of bounds"
argument_list|)
expr_stmt|;
block|}
block|}
name|prspace
argument_list|(
name|ovlen
operator|-
name|ooffset
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|doeven
argument_list|(
name|totlen
operator|+
name|ovlen
argument_list|,
operator|(
name|ALIDOUBLE
operator|>
name|SZLONG
condition|?
name|ALIDOUBLE
else|:
name|SZLONG
operator|)
argument_list|)
expr_stmt|;
name|clf
argument_list|(
operator|&
name|sortfile
argument_list|)
expr_stmt|;
name|clf
argument_list|(
operator|&
name|asmfile
argument_list|)
expr_stmt|;
name|clf
argument_list|(
operator|&
name|sortfile
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|sortfname
argument_list|)
expr_stmt|;
return|return
operator|(
name|erred
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|prspace
argument_list|(
name|n
argument_list|)
specifier|register
name|ftnint
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ftnint
name|m
decl_stmt|;
while|while
condition|(
name|nch
operator|>
literal|0
operator|&&
name|n
operator|>
literal|0
condition|)
block|{
operator|--
name|n
expr_stmt|;
name|prch
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|SZSHORT
operator|*
operator|(
name|n
operator|/
name|SZSHORT
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|0
condition|)
name|prskip
argument_list|(
name|asmfile
argument_list|,
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|-=
name|m
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
name|prch
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|ftnint
name|doeven
parameter_list|(
name|tot
parameter_list|,
name|align
parameter_list|)
specifier|register
name|ftnint
name|tot
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|ftnint
name|new
decl_stmt|;
name|new
operator|=
name|roundup
argument_list|(
name|tot
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|prspace
argument_list|(
name|new
operator|-
name|tot
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_macro
name|rdname
argument_list|(
argument|vargroupp
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|vargroupp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|sortfile
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|NO
operator|)
return|;
operator|*
name|vargroupp
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|sortfile
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|NO
operator|)
return|;
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
operator|*
name|name
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|name
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|rdlong
argument_list|(
name|n
argument_list|)
specifier|register
name|ftnint
operator|*
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|getc
argument_list|(
name|sortfile
argument_list|)
init|;
name|c
operator|!=
name|EOF
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
name|getc
argument_list|(
name|sortfile
argument_list|)
control|)
empty_stmt|;
empty_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|NO
operator|)
return|;
for|for
control|(
operator|*
name|n
operator|=
literal|0
init|;
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
name|getc
argument_list|(
name|sortfile
argument_list|)
control|)
operator|*
name|n
operator|=
literal|10
operator|*
operator|(
operator|*
name|n
operator|)
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|prch
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|int
name|buff
index|[
name|SZSHORT
index|]
decl_stmt|;
name|buff
index|[
name|nch
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|nch
operator|==
name|SZSHORT
condition|)
block|{
name|prchars
argument_list|(
name|asmfile
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|nch
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

end_unit

