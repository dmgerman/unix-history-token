begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)regalloc.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * regalloc.c  *  * Register optimization routines for f77 compiler, pass 1  *  * University of Utah CS Dept modification history:  *  * $History$  * $Log:	regalloc.c,v $  * Revision 2.9  85/03/18  21:35:05  donn  * Bob Corbett's hack to prevent conflicts between subroutine side effects  * and register assignment.  Makes the code a lot worse...  *   * Revision 2.8  85/02/22  02:14:08  donn  * In code like 'x = foo(x)', alreg() would copy the memory version of the  * variable 'x' into the register version after the assignment, clobbering  * the result.  A small change to regwrite() seems to prevent this.  *   * Revision 2.7  85/02/16  03:32:45  donn  * Fixed a bug where the loop test and increment were having register  * substitution performed twice, once in the environment of the current  * loop and once in the environment of the containing loop.  If the  * containing loop puts (say) the inner loop's index variable in register  * but the inner loop does not, havoc results.  *   * Revision 2.6  85/02/14  23:21:45  donn  * Don't permit variable references of the form 'a(i)' to be put in register  * if array 'a' is in common.  This is because there is no good way to  * identify instances of this sort without getting confused with other  * variables in the same common block which are in register.  Sigh.  *   * Revision 2.5  85/01/11  21:08:00  donn  * Made changes so that we pay attention to SAVE statements.  Added a new  * gensetreturn() function to implement this.  *   * Revision 2.4  84/09/03  22:37:28  donn  * Changed the treatment of SKRETURN in alreg() so that all variables in  * register, not just COMMON variables, get written out to memory before a  * RETURN.  This was causing the return value of a function to get lost when  * a RETURN was done from inside a loop (among other problems).  *   * Revision 2.3  84/08/04  20:52:42  donn  * Added fixes for EXTERNAL parameters from Jerry Berkman.  *   * Revision 2.2  84/08/04  20:34:29  donn  * Fixed a stupidity pointed out by Jerry Berkman -- the 'floats in register'  * stuff applies if the TARGET is a VAX, not if the local machine is a VAX.  *   * Revision 2.1  84/07/19  12:04:47  donn  * Changed comment headers for UofU.  *   * Revision 1.5  83/11/27  19:25:41  donn  * Added REAL to the list of types which may appear in registers (VAXen only).  *   * Revision 1.4  83/11/13  02:38:39  donn  * Bug fixed in alreg()'s handling of computed goto's.  A '<=' in place of a  * '<' led to core dumps when we walked off the end of the list of labels...  *   * Revision 1.3  83/11/12  01:25:57  donn  * Bug in redundant register assignment code, mistakenly carried over some old  * code that sometimes rewound a slot pointer even when a redundant slot wasn't  * deleted; this caused an infinite loop...  Seems to work now.  *   * Revision 1.2  83/11/09  14:58:12  donn  * Took out broken code dealing with redundant register initializations.  * Couldn't see what to do about redundantly initializing a DO variable but  * I did fix things so that an assignment from a register into the same  * register is always deleted.  *   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"optim.h"
end_include

begin_define
define|#
directive|define
name|LABTABSIZE
value|101
end_define

begin_define
define|#
directive|define
name|VARTABSIZE
value|1009
end_define

begin_define
define|#
directive|define
name|TABLELIMIT
value|12
end_define

begin_if
if|#
directive|if
name|TARGET
operator|==
name|VAX
end_if

begin_define
define|#
directive|define
name|MSKREGTYPES
value|M(TYLOGICAL) | M(TYADDR) | M(TYSHORT) | M(TYLONG) | M(TYREAL)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MSKREGTYPES
value|M(TYLOGICAL) | M(TYADDR) | M(TYSHORT) | M(TYLONG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ISREGTYPE
parameter_list|(
name|x
parameter_list|)
value|ONEOF(x, MSKREGTYPES)
end_define

begin_define
define|#
directive|define
name|MSKVARS
value|M(STGAUTO) | M(STGBSS) | M(STGINIT) | M(STGCONST) |\ 		M(STGEQUIV) | M(STGARG) | M(STGCOMMON)
end_define

begin_define
define|#
directive|define
name|ISVAR
parameter_list|(
name|x
parameter_list|)
value|((((expptr) x)->headblock.vclass == CLVAR || \ 			((expptr) x)->headblock.vclass == CLUNKNOWN) \&& ONEOF(((expptr) x)->headblock.vstg, MSKVARS))
end_define

begin_typedef
typedef|typedef
struct|struct
name|regdata
block|{
name|field
name|vstg
decl_stmt|;
name|field
name|vtype
decl_stmt|;
name|int
name|memno
decl_stmt|;
name|int
name|memoffset
decl_stmt|;
name|int
name|refs
decl_stmt|;
name|Addrp
name|stgp
decl_stmt|;
name|unsigned
name|isarrayarg
range|:
literal|1
decl_stmt|;
name|unsigned
name|istemp
range|:
literal|1
decl_stmt|;
name|unsigned
name|isset
range|:
literal|1
decl_stmt|;
name|unsigned
name|setfirst
range|:
literal|1
decl_stmt|;
block|}
name|REGDATA
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|labelnode
block|{
name|struct
name|labelnode
modifier|*
name|link
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|}
name|LABELNODE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|varnode
block|{
name|struct
name|varnode
modifier|*
name|link
decl_stmt|;
name|int
name|memoffset
decl_stmt|;
name|unsigned
name|isset
range|:
literal|1
decl_stmt|;
name|unsigned
name|isused
range|:
literal|1
decl_stmt|;
name|unsigned
name|setfirst
range|:
literal|1
decl_stmt|;
name|unsigned
name|unusable
range|:
literal|1
decl_stmt|;
name|int
name|refs
decl_stmt|;
name|Addrp
name|stgp
decl_stmt|;
block|}
name|VARNODE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|addrnode
block|{
name|struct
name|addrnode
modifier|*
name|link
decl_stmt|;
name|field
name|vtype
decl_stmt|;
name|field
name|vstg
decl_stmt|;
name|int
name|memno
decl_stmt|;
name|unsigned
name|istemp
range|:
literal|1
decl_stmt|;
name|unsigned
name|isset
range|:
literal|1
decl_stmt|;
name|unsigned
name|freeuse
range|:
literal|1
decl_stmt|;
name|unsigned
name|mixedtype
range|:
literal|1
decl_stmt|;
name|unsigned
name|fixed
range|:
literal|1
decl_stmt|;
name|int
name|refs
decl_stmt|;
name|struct
name|addrnode
modifier|*
name|commonlink
decl_stmt|;
name|VARNODE
modifier|*
name|varlist
decl_stmt|;
block|}
name|ADDRNODE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|setnode
block|{
name|struct
name|setnode
modifier|*
name|link
decl_stmt|;
name|field
name|vstg
decl_stmt|;
name|int
name|memno
decl_stmt|;
name|int
name|memoffset
decl_stmt|;
block|}
name|SETNODE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|doqueue
block|{
name|struct
name|doqueue
modifier|*
name|up
decl_stmt|,
modifier|*
name|down
decl_stmt|;
name|Slotp
name|dohead
decl_stmt|,
name|doend
decl_stmt|;
name|int
name|nregvars
decl_stmt|;
name|REGNODE
modifier|*
name|reg
index|[
name|MAXREGVAR
index|]
decl_stmt|;
block|}
name|DOQUEUE
typedef|;
end_typedef

begin_decl_stmt
name|LOCAL
name|DOQUEUE
modifier|*
name|dqptr
decl_stmt|,
modifier|*
name|dqtop
decl_stmt|,
modifier|*
name|dqbottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|Slotp
name|dohead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|Slotp
name|doend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|Slotp
name|newcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|LABELNODE
modifier|*
name|labeltable
index|[
name|LABTABSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|ADDRNODE
modifier|*
name|vartable
index|[
name|VARTABSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|ADDRNODE
modifier|*
name|commonvars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|SETNODE
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|topregvar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|toplcv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|allset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|ADDRNODE
modifier|*
name|currentaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|loopcost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|REGDATA
modifier|*
name|regtab
index|[
name|MAXREGVAR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|REGDATA
modifier|*
name|rt
index|[
name|TABLELIMIT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|tabletop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|linearcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|globalbranch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|commonunusable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|regdefined
index|[
name|MAXREGVAR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|memdefined
index|[
name|MAXREGVAR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|regaltered
index|[
name|MAXREGVAR
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|LOCAL
name|insertlabel
parameter_list|(
name|l
parameter_list|)
name|int
name|l
decl_stmt|;
block|{
name|int
name|key
decl_stmt|;
name|LABELNODE
modifier|*
name|p
decl_stmt|;
name|key
operator|=
name|l
operator|%
name|LABTABSIZE
expr_stmt|;
for|for
control|(
name|p
operator|=
name|labeltable
index|[
name|key
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
if|if
condition|(
name|p
operator|->
name|labelno
operator|==
name|l
condition|)
return|return;
name|p
operator|=
name|labeltable
index|[
name|key
index|]
expr_stmt|;
name|labeltable
index|[
name|key
index|]
operator|=
name|ALLOC
argument_list|(
name|labelnode
argument_list|)
expr_stmt|;
name|labeltable
index|[
name|key
index|]
operator|->
name|link
operator|=
name|p
expr_stmt|;
name|labeltable
index|[
name|key
index|]
operator|->
name|labelno
operator|=
name|l
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|LOCAL
name|int
name|locallabel
parameter_list|(
name|l
parameter_list|)
name|int
name|l
decl_stmt|;
block|{
name|int
name|key
decl_stmt|;
name|LABELNODE
modifier|*
name|p
decl_stmt|;
name|key
operator|=
name|l
operator|%
name|LABTABSIZE
expr_stmt|;
for|for
control|(
name|p
operator|=
name|labeltable
index|[
name|key
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
if|if
condition|(
name|p
operator|->
name|labelno
operator|==
name|l
condition|)
return|return
name|YES
return|;
return|return
name|NO
return|;
block|}
end_function

begin_function
name|LOCAL
name|freelabtab
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|LABELNODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LABTABSIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|labeltable
index|[
name|i
index|]
condition|)
block|{
name|p
operator|=
name|labeltable
index|[
name|i
index|]
expr_stmt|;
name|labeltable
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|q
operator|=
name|p
operator|->
name|link
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|ADDRNODE
modifier|*
name|getaddr
parameter_list|(
name|ap
parameter_list|)
name|Addrp
name|ap
decl_stmt|;
block|{
name|int
name|key
decl_stmt|;
name|field
name|vstg
decl_stmt|;
name|int
name|memno
decl_stmt|;
specifier|register
name|ADDRNODE
modifier|*
name|q
decl_stmt|;
name|ADDRNODE
modifier|*
name|q1
decl_stmt|;
if|if
condition|(
operator|!
name|ISVAR
argument_list|(
name|ap
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"regalloc: bad data sent to getaddr"
argument_list|)
expr_stmt|;
name|vstg
operator|=
name|ap
operator|->
name|vstg
expr_stmt|;
name|memno
operator|=
name|ap
operator|->
name|memno
expr_stmt|;
name|key
operator|=
operator|(
literal|256
operator|*
name|vstg
operator|+
name|memno
operator|)
operator|%
name|VARTABSIZE
expr_stmt|;
for|for
control|(
name|q
operator|=
name|vartable
index|[
name|key
index|]
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|link
control|)
if|if
condition|(
operator|(
name|q
operator|->
name|vstg
operator|==
name|vstg
operator|)
operator|&&
operator|(
name|q
operator|->
name|memno
operator|==
name|memno
operator|)
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|istemp
condition|)
name|q
operator|->
name|istemp
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|vtype
operator|!=
name|q
operator|->
name|vtype
condition|)
name|q
operator|->
name|mixedtype
operator|=
name|YES
expr_stmt|;
if|if
condition|(
operator|!
name|fixedaddress
argument_list|(
name|ap
argument_list|)
condition|)
name|q
operator|->
name|fixed
operator|=
name|NO
expr_stmt|;
return|return
name|q
return|;
block|}
name|q1
operator|=
name|vartable
index|[
name|key
index|]
expr_stmt|;
name|vartable
index|[
name|key
index|]
operator|=
name|q
operator|=
name|ALLOC
argument_list|(
name|addrnode
argument_list|)
expr_stmt|;
name|q
operator|->
name|link
operator|=
name|q1
expr_stmt|;
name|q
operator|->
name|vstg
operator|=
name|vstg
expr_stmt|;
name|q
operator|->
name|memno
operator|=
name|memno
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|istemp
condition|)
name|q
operator|->
name|istemp
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|fixedaddress
argument_list|(
name|ap
argument_list|)
condition|)
name|q
operator|->
name|fixed
operator|=
name|YES
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|ap
operator|->
name|vtype
expr_stmt|;
name|q
operator|->
name|varlist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vstg
operator|==
name|STGCOMMON
condition|)
block|{
name|q
operator|->
name|commonlink
operator|=
name|commonvars
expr_stmt|;
name|commonvars
operator|=
name|q
expr_stmt|;
block|}
return|return
name|q
return|;
block|}
end_function

begin_function
name|LOCAL
name|VARNODE
modifier|*
name|getvar
parameter_list|(
name|ainfo
parameter_list|,
name|ap
parameter_list|)
name|ADDRNODE
modifier|*
name|ainfo
decl_stmt|;
name|Addrp
name|ap
decl_stmt|;
block|{
specifier|register
name|VARNODE
modifier|*
name|q
decl_stmt|;
name|VARNODE
modifier|*
name|q1
decl_stmt|;
name|int
name|memoffset
decl_stmt|;
if|if
condition|(
operator|!
name|ISVAR
argument_list|(
name|ap
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"regalloc:  bad data sent to getvar"
argument_list|)
expr_stmt|;
name|memoffset
operator|=
name|ap
operator|->
name|memoffset
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
for|for
control|(
name|q
operator|=
name|ainfo
operator|->
name|varlist
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|link
control|)
if|if
condition|(
name|q
operator|->
name|memoffset
operator|==
name|memoffset
condition|)
return|return
name|q
return|;
name|q1
operator|=
name|ainfo
operator|->
name|varlist
expr_stmt|;
name|ainfo
operator|->
name|varlist
operator|=
name|q
operator|=
name|ALLOC
argument_list|(
name|varnode
argument_list|)
expr_stmt|;
name|q
operator|->
name|link
operator|=
name|q1
expr_stmt|;
name|q
operator|->
name|memoffset
operator|=
name|memoffset
expr_stmt|;
name|q
operator|->
name|stgp
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_function
name|LOCAL
name|ADDRNODE
modifier|*
name|lookupaddr
parameter_list|(
name|vstg
parameter_list|,
name|memno
parameter_list|)
name|field
name|vstg
decl_stmt|;
name|int
name|memno
decl_stmt|;
block|{
name|int
name|key
decl_stmt|;
specifier|register
name|ADDRNODE
modifier|*
name|q
decl_stmt|;
name|key
operator|=
operator|(
literal|256
operator|*
name|vstg
operator|+
name|memno
operator|)
operator|%
name|VARTABSIZE
expr_stmt|;
for|for
control|(
name|q
operator|=
name|vartable
index|[
name|key
index|]
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|link
control|)
if|if
condition|(
operator|(
name|q
operator|->
name|vstg
operator|==
name|vstg
operator|)
operator|&&
operator|(
name|q
operator|->
name|memno
operator|==
name|memno
operator|)
condition|)
return|return
name|q
return|;
name|fatal
argument_list|(
literal|"regalloc:  lookupaddr"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|VARNODE
modifier|*
name|lookupvar
parameter_list|(
name|ainfo
parameter_list|,
name|memoffset
parameter_list|)
name|ADDRNODE
modifier|*
name|ainfo
decl_stmt|;
name|int
name|memoffset
decl_stmt|;
block|{
specifier|register
name|VARNODE
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|ainfo
operator|->
name|varlist
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|link
control|)
if|if
condition|(
name|q
operator|->
name|memoffset
operator|==
name|memoffset
condition|)
return|return
name|q
return|;
name|fatal
argument_list|(
literal|"regalloc:  lookupvar"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|int
name|invartable
parameter_list|(
name|p
parameter_list|)
name|REGNODE
modifier|*
name|p
decl_stmt|;
block|{
name|field
name|vstg
decl_stmt|;
name|int
name|memno
decl_stmt|;
name|int
name|key
decl_stmt|;
specifier|register
name|ADDRNODE
modifier|*
name|q
decl_stmt|;
name|vstg
operator|=
name|p
operator|->
name|vstg
expr_stmt|;
name|memno
operator|=
name|p
operator|->
name|memno
expr_stmt|;
name|key
operator|=
operator|(
literal|256
operator|*
name|vstg
operator|+
name|memno
operator|)
operator|%
name|VARTABSIZE
expr_stmt|;
for|for
control|(
name|q
operator|=
name|vartable
index|[
name|key
index|]
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|link
control|)
if|if
condition|(
operator|(
name|q
operator|->
name|vstg
operator|==
name|vstg
operator|)
operator|&&
operator|(
name|q
operator|->
name|memno
operator|==
name|memno
operator|)
condition|)
return|return
name|YES
return|;
return|return
name|NO
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|freevartab
parameter_list|()
block|{
specifier|register
name|ADDRNODE
modifier|*
name|p
decl_stmt|;
name|ADDRNODE
modifier|*
name|p1
decl_stmt|;
specifier|register
name|VARNODE
modifier|*
name|q
decl_stmt|;
name|VARNODE
modifier|*
name|q1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARTABSIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vartable
index|[
name|i
index|]
condition|)
block|{
name|p
operator|=
name|vartable
index|[
name|i
index|]
expr_stmt|;
name|vartable
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
for|for
control|(
name|q
operator|=
name|p
operator|->
name|varlist
init|;
name|q
condition|;
name|q
operator|=
name|q1
control|)
block|{
name|q1
operator|=
name|q
operator|->
name|link
expr_stmt|;
name|frexpr
argument_list|(
name|q
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
name|p1
operator|=
name|p
operator|->
name|link
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|insertset
parameter_list|(
name|vstg
parameter_list|,
name|memno
parameter_list|,
name|memoffset
parameter_list|)
name|field
name|vstg
decl_stmt|;
name|int
name|memno
decl_stmt|;
name|int
name|memoffset
decl_stmt|;
block|{
specifier|register
name|SETNODE
modifier|*
name|p
decl_stmt|;
name|SETNODE
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|allset
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|setlist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
if|if
condition|(
operator|(
name|p
operator|->
name|vstg
operator|==
name|vstg
operator|)
operator|&&
operator|(
name|p
operator|->
name|memno
operator|==
name|memno
operator|)
operator|&&
operator|(
name|p
operator|->
name|memoffset
operator|==
name|memoffset
operator|)
condition|)
return|return;
name|q
operator|=
name|p
expr_stmt|;
name|setlist
operator|=
name|p
operator|=
name|ALLOC
argument_list|(
name|setnode
argument_list|)
expr_stmt|;
name|p
operator|->
name|link
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|vstg
operator|=
name|vstg
expr_stmt|;
name|p
operator|->
name|memno
operator|=
name|memno
expr_stmt|;
name|p
operator|->
name|memoffset
operator|=
name|memoffset
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|LOCAL
name|int
name|insetlist
parameter_list|(
name|vstg
parameter_list|,
name|memno
parameter_list|,
name|memoffset
parameter_list|)
name|field
name|vstg
decl_stmt|;
name|int
name|memno
decl_stmt|;
name|int
name|memoffset
decl_stmt|;
block|{
specifier|register
name|SETNODE
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|allset
condition|)
return|return
name|YES
return|;
for|for
control|(
name|p
operator|=
name|setlist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
if|if
condition|(
operator|(
name|p
operator|->
name|vstg
operator|==
name|vstg
operator|)
operator|&&
operator|(
name|p
operator|->
name|memno
operator|==
name|memno
operator|)
operator|&&
operator|(
name|p
operator|->
name|memoffset
operator|==
name|memoffset
operator|)
condition|)
return|return
name|YES
return|;
return|return
name|NO
return|;
block|}
end_function

begin_function
name|LOCAL
name|clearsets
parameter_list|()
block|{
specifier|register
name|SETNODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|allset
operator|=
name|NO
expr_stmt|;
name|p
operator|=
name|setlist
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|q
operator|=
name|p
operator|->
name|link
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|setlist
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|alreg
parameter_list|()
block|{
specifier|register
name|Slotp
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|ADDRNODE
modifier|*
name|p
decl_stmt|;
specifier|register
name|VARNODE
modifier|*
name|q
decl_stmt|;
name|Slotp
name|sp1
decl_stmt|,
name|sp2
decl_stmt|;
name|ADDRNODE
modifier|*
name|addrinfo
decl_stmt|;
name|VARNODE
modifier|*
name|varinfo
decl_stmt|;
name|int
name|docount
decl_stmt|;
name|struct
name|Labelblock
modifier|*
modifier|*
name|lp
decl_stmt|;
name|int
name|toptrack
decl_stmt|;
name|int
name|track
index|[
name|MAXREGVAR
index|]
decl_stmt|;
name|Addrp
name|ap
decl_stmt|,
name|ap1
decl_stmt|;
name|DOQUEUE
modifier|*
name|dqp
decl_stmt|;
name|REGDATA
modifier|*
name|rp
decl_stmt|;
name|REGNODE
modifier|*
name|regp
decl_stmt|;
if|if
condition|(
name|nregvar
operator|>=
name|maxregvar
condition|)
return|return;
name|commonvars
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|dohead
init|;
name|sp
operator|!=
name|doend
operator|->
name|next
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
switch|switch
condition|(
name|sp
operator|->
name|type
condition|)
block|{
case|case
name|SKLABEL
case|:
name|insertlabel
argument_list|(
name|sp
operator|->
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKARIF
case|:
case|case
name|SKASGOTO
case|:
case|case
name|SKCALL
case|:
case|case
name|SKCMGOTO
case|:
case|case
name|SKEQ
case|:
case|case
name|SKIFN
case|:
case|case
name|SKIOIFN
case|:
case|case
name|SKSTOP
case|:
case|case
name|SKPAUSE
case|:
case|case
name|SKRETURN
case|:
name|scanvars
argument_list|(
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKNULL
case|:
case|case
name|SKGOTO
case|:
case|case
name|SKDOHEAD
case|:
case|case
name|SKENDDO
case|:
case|case
name|SKASSIGN
case|:
break|break;
default|default:
name|badthing
argument_list|(
literal|"SKtype"
argument_list|,
literal|"alreg-1"
argument_list|,
name|sp
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|loopcost
operator|=
literal|0
expr_stmt|;
name|docount
operator|=
literal|1
expr_stmt|;
name|commonunusable
operator|=
name|NO
expr_stmt|;
if|if
condition|(
operator|!
name|dohead
operator|->
name|nullslot
condition|)
name|fatal
argument_list|(
literal|"missing dohead->nullslot -cbb"
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|dohead
operator|->
name|next
operator|,
name|globalbranch
operator|=
name|NO
init|;
name|docount
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
operator|,
name|clearsets
argument_list|()
operator|,
name|globalbranch
operator|=
name|NO
control|)
if|if
condition|(
name|docount
operator|>
literal|1
condition|)
switch|switch
condition|(
name|sp
operator|->
name|type
condition|)
block|{
case|case
name|SKDOHEAD
case|:
name|docount
operator|++
expr_stmt|;
break|break;
case|case
name|SKENDDO
case|:
name|docount
operator|--
expr_stmt|;
default|default:
break|break;
block|}
else|else
switch|switch
condition|(
name|sp
operator|->
name|type
condition|)
block|{
case|case
name|SKARIF
case|:
define|#
directive|define
name|LM
value|((struct Labelblock * *)sp->ctlinfo)[0]->labelno
define|#
directive|define
name|LZ
value|((struct Labelblock * *)sp->ctlinfo)[1]->labelno
define|#
directive|define
name|LP
value|((struct Labelblock * *)sp->ctlinfo)[2]->labelno
if|if
condition|(
operator|!
name|locallabel
argument_list|(
name|LM
argument_list|)
operator|||
operator|!
name|locallabel
argument_list|(
name|LZ
argument_list|)
operator|||
operator|!
name|locallabel
argument_list|(
name|LP
argument_list|)
condition|)
block|{
name|setall
argument_list|()
expr_stmt|;
name|globalbranch
operator|=
name|YES
expr_stmt|;
block|}
name|countrefs
argument_list|(
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKASGOTO
case|:
name|setall
argument_list|()
expr_stmt|;
name|globalbranch
operator|=
name|YES
expr_stmt|;
name|countrefs
argument_list|(
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKCMGOTO
case|:
name|lp
operator|=
operator|(
expr|struct
name|Labelblock
operator|*
operator|*
operator|)
name|sp
operator|->
name|ctlinfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|label
condition|;
name|i
operator|++
operator|,
name|lp
operator|++
control|)
if|if
condition|(
operator|!
name|locallabel
argument_list|(
operator|(
operator|*
name|lp
operator|)
operator|->
name|labelno
argument_list|)
condition|)
block|{
name|setall
argument_list|()
expr_stmt|;
name|globalbranch
operator|=
name|YES
expr_stmt|;
break|break;
block|}
name|countrefs
argument_list|(
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKDOHEAD
case|:
name|globalbranch
operator|=
name|YES
expr_stmt|;
name|loopcost
operator|=
literal|2
expr_stmt|;
name|docount
operator|++
expr_stmt|;
break|break;
case|case
name|SKENDDO
case|:
name|docount
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SKGOTO
case|:
if|if
condition|(
operator|!
name|locallabel
argument_list|(
name|sp
operator|->
name|label
argument_list|)
condition|)
block|{
name|setall
argument_list|()
expr_stmt|;
name|globalbranch
operator|=
name|YES
expr_stmt|;
block|}
break|break;
case|case
name|SKIFN
case|:
case|case
name|SKIOIFN
case|:
if|if
condition|(
operator|!
name|locallabel
argument_list|(
name|sp
operator|->
name|label
argument_list|)
condition|)
block|{
name|setall
argument_list|()
expr_stmt|;
name|globalbranch
operator|=
name|YES
expr_stmt|;
block|}
name|countrefs
argument_list|(
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKEQ
case|:
case|case
name|SKCALL
case|:
case|case
name|SKSTOP
case|:
case|case
name|SKPAUSE
case|:
name|linearcode
operator|=
name|YES
expr_stmt|;
name|countrefs
argument_list|(
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
name|linearcode
operator|=
name|NO
expr_stmt|;
break|break;
block|}
name|topregvar
operator|=
name|toplcv
operator|=
name|nregvar
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregvar
condition|;
name|i
operator|++
control|)
block|{
name|ap
operator|=
name|memversion
argument_list|(
name|regnamep
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|regtab
index|[
name|i
index|]
operator|=
name|rp
operator|=
name|ALLOC
argument_list|(
name|regdata
argument_list|)
expr_stmt|;
name|rp
operator|->
name|vstg
operator|=
name|ap
operator|->
name|vstg
expr_stmt|;
name|rp
operator|->
name|vtype
operator|=
name|ap
operator|->
name|vtype
expr_stmt|;
name|rp
operator|->
name|memno
operator|=
name|ap
operator|->
name|memno
expr_stmt|;
name|rp
operator|->
name|memoffset
operator|=
name|ap
operator|->
name|memoffset
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
name|rp
operator|->
name|isarrayarg
operator|=
name|NO
expr_stmt|;
name|rp
operator|->
name|stgp
operator|=
name|ap
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXREGVAR
condition|;
name|i
operator|++
control|)
name|track
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
for|for
control|(
name|dqp
operator|=
name|dqptr
operator|->
name|down
init|;
name|dqp
condition|;
name|dqp
operator|=
name|dqp
operator|->
name|down
control|)
block|{
if|if
condition|(
name|dqp
operator|->
name|nregvars
operator|-
literal|1
operator|>
name|topregvar
condition|)
name|topregvar
operator|=
name|dqp
operator|->
name|nregvars
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<
name|dqp
operator|->
name|nregvars
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|track
index|[
name|i
index|]
condition|)
if|if
condition|(
name|regp
operator|=
name|dqp
operator|->
name|reg
index|[
name|i
index|]
condition|)
if|if
condition|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|samevar
argument_list|(
name|rp
argument_list|,
name|regp
argument_list|)
condition|)
name|track
index|[
name|i
index|]
operator|=
name|NO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|invartable
argument_list|(
name|regp
argument_list|)
condition|)
block|{
name|regtab
index|[
name|i
index|]
operator|=
name|rp
operator|=
name|ALLOC
argument_list|(
name|regdata
argument_list|)
expr_stmt|;
name|rp
operator|->
name|vstg
operator|=
name|regp
operator|->
name|vstg
expr_stmt|;
name|rp
operator|->
name|vtype
operator|=
name|regp
operator|->
name|vtype
expr_stmt|;
name|rp
operator|->
name|memno
operator|=
name|regp
operator|->
name|memno
expr_stmt|;
name|rp
operator|->
name|memoffset
operator|=
name|regp
operator|->
name|memoffset
expr_stmt|;
name|addrinfo
operator|=
name|lookupaddr
argument_list|(
name|rp
operator|->
name|vstg
argument_list|,
name|rp
operator|->
name|memno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regp
operator|->
name|isarrayarg
condition|)
block|{
name|rp
operator|->
name|isarrayarg
operator|=
name|YES
expr_stmt|;
name|rp
operator|->
name|refs
operator|=
name|addrinfo
operator|->
name|refs
expr_stmt|;
block|}
else|else
block|{
name|varinfo
operator|=
name|lookupvar
argument_list|(
name|addrinfo
argument_list|,
name|regp
operator|->
name|memoffset
argument_list|)
expr_stmt|;
name|rp
operator|->
name|refs
operator|=
name|varinfo
operator|->
name|refs
expr_stmt|;
name|rp
operator|->
name|stgp
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|varinfo
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|istemp
operator|=
name|addrinfo
operator|->
name|istemp
expr_stmt|;
name|rp
operator|->
name|isset
operator|=
name|varinfo
operator|->
name|isset
expr_stmt|;
name|rp
operator|->
name|setfirst
operator|=
name|varinfo
operator|->
name|setfirst
expr_stmt|;
block|}
block|}
else|else
name|track
index|[
name|i
index|]
operator|=
name|NO
expr_stmt|;
else|else
name|track
index|[
name|i
index|]
operator|=
name|NO
expr_stmt|;
block|}
name|toptrack
operator|=
name|topregvar
expr_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regtab
index|[
name|i
index|]
condition|)
if|if
condition|(
operator|(
name|track
index|[
name|i
index|]
operator|==
name|NO
operator|)
operator|||
operator|(
name|regtab
index|[
name|i
index|]
operator|->
name|refs
operator|<=
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|regtab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|regtab
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|tabletop
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|topregvar
operator|<
name|maxregvar
operator|-
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARTABSIZE
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|vartable
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|entableaddr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|p
operator|->
name|mixedtype
operator|)
operator|&&
operator|(
name|p
operator|->
name|vstg
operator|!=
name|STGARG
operator|)
operator|&&
operator|!
operator|(
operator|(
name|p
operator|->
name|vstg
operator|==
name|STGCOMMON
operator|)
operator|&&
operator|(
operator|(
operator|!
name|p
operator|->
name|fixed
operator|)
operator|||
name|commonunusable
operator|)
operator|)
condition|)
for|for
control|(
name|q
operator|=
name|p
operator|->
name|varlist
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|link
control|)
name|entablevar
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<=
name|tabletop
operator|)
operator|&&
operator|(
name|topregvar
operator|+
literal|1
operator|<
name|maxregvar
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inregtab
argument_list|(
name|rt
index|[
name|i
index|]
argument_list|)
operator|||
operator|(
name|loopcost
operator|&&
name|rt
index|[
name|i
index|]
operator|->
name|isset
operator|)
condition|)
continue|continue;
name|topregvar
operator|++
expr_stmt|;
name|regtab
index|[
name|topregvar
index|]
operator|=
name|rp
operator|=
name|ALLOC
argument_list|(
name|regdata
argument_list|)
expr_stmt|;
name|rp
operator|->
name|vstg
operator|=
name|rt
index|[
name|i
index|]
operator|->
name|vstg
expr_stmt|;
name|rp
operator|->
name|vtype
operator|=
name|rt
index|[
name|i
index|]
operator|->
name|vtype
expr_stmt|;
name|rp
operator|->
name|memno
operator|=
name|rt
index|[
name|i
index|]
operator|->
name|memno
expr_stmt|;
name|rp
operator|->
name|memoffset
operator|=
name|rt
index|[
name|i
index|]
operator|->
name|memoffset
expr_stmt|;
name|rp
operator|->
name|refs
operator|=
name|rt
index|[
name|i
index|]
operator|->
name|refs
expr_stmt|;
name|rp
operator|->
name|stgp
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rt
index|[
name|i
index|]
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|isarrayarg
operator|=
name|rt
index|[
name|i
index|]
operator|->
name|isarrayarg
expr_stmt|;
name|rp
operator|->
name|istemp
operator|=
name|rt
index|[
name|i
index|]
operator|->
name|istemp
expr_stmt|;
name|rp
operator|->
name|isset
operator|=
name|rt
index|[
name|i
index|]
operator|->
name|isset
expr_stmt|;
name|rp
operator|->
name|setfirst
operator|=
name|rt
index|[
name|i
index|]
operator|->
name|setfirst
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
condition|)
if|if
condition|(
name|rp
operator|->
name|isarrayarg
condition|)
block|{
name|ap
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|ap
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|ap
operator|->
name|vstg
operator|=
name|STGREG
expr_stmt|;
name|ap
operator|->
name|vtype
operator|=
name|TYADDR
expr_stmt|;
name|ap
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
name|ap
operator|->
name|memno
operator|=
name|regnum
index|[
name|i
index|]
expr_stmt|;
name|ap
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ap1
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|ap1
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|ap1
operator|->
name|vstg
operator|=
name|rp
operator|->
name|vstg
expr_stmt|;
name|ap1
operator|->
name|vtype
operator|=
name|rp
operator|->
name|vtype
expr_stmt|;
name|ap1
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
name|ap1
operator|->
name|memno
operator|=
name|rp
operator|->
name|memno
expr_stmt|;
name|ap1
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|insertassign
argument_list|(
name|dohead
argument_list|,
name|ap
argument_list|,
name|addrof
argument_list|(
name|ap1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|setfirst
operator|&&
name|rp
operator|->
name|istemp
operator|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|istemp
condition|)
for|for
control|(
name|sp
operator|=
name|newcode
init|;
name|sp
operator|&&
name|sp
operator|!=
name|dohead
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
if|if
condition|(
name|sp
operator|->
name|type
operator|==
name|SKEQ
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|sp
operator|->
name|expr
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|->
name|vstg
operator|==
name|rp
operator|->
name|vstg
operator|)
operator|&&
operator|(
name|ap
operator|->
name|memno
operator|==
name|rp
operator|->
name|memno
operator|)
operator|&&
name|fixedaddress
argument_list|(
name|ap
argument_list|)
operator|&&
operator|(
name|ap
operator|->
name|memoffset
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|==
name|rp
operator|->
name|memoffset
operator|)
condition|)
block|{
name|changetoreg
argument_list|(
name|ap
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|L1
goto|;
block|}
block|}
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|changetoreg
argument_list|(
name|ap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|insertassign
argument_list|(
name|dohead
argument_list|,
name|ap
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|L1
label|:
empty_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
condition|)
if|if
condition|(
name|rp
operator|->
name|isset
operator|&&
operator|!
operator|(
name|rp
operator|->
name|istemp
operator|||
name|rp
operator|->
name|isarrayarg
operator|)
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|changetoreg
argument_list|(
name|ap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|appendassign
argument_list|(
name|doend
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|docount
operator|=
literal|1
expr_stmt|;
name|clearmems
argument_list|()
expr_stmt|;
name|setregs
argument_list|()
expr_stmt|;
name|sp
operator|=
name|dohead
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|loopcost
condition|)
for|for
control|(
name|i
operator|=
name|toptrack
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
operator|)
operator|&&
operator|!
name|rp
operator|->
name|isarrayarg
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|changetoreg
argument_list|(
name|ap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|insertassign
argument_list|(
name|sp
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|dohead
operator|->
name|next
init|;
name|docount
operator|||
name|sp
operator|->
name|type
operator|!=
name|SKNULL
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
if|if
condition|(
name|docount
operator|>
literal|1
condition|)
switch|switch
condition|(
name|sp
operator|->
name|type
condition|)
block|{
case|case
name|SKDOHEAD
case|:
name|docount
operator|++
expr_stmt|;
break|break;
case|case
name|SKENDDO
case|:
if|if
condition|(
operator|--
name|docount
operator|==
literal|1
condition|)
block|{
comment|/* 	       * Remove redundant stores to memory. 	       */
name|sp1
operator|=
name|sp
operator|->
name|nullslot
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|sp1
condition|)
block|{
if|if
condition|(
name|regtomem
argument_list|(
name|sp1
argument_list|)
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|sp1
operator|->
name|expr
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
name|sp2
operator|=
name|sp1
operator|->
name|next
expr_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|2
init|;
name|i
operator|<=
name|toptrack
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regtab
index|[
name|i
index|]
operator|&&
operator|(
name|regnum
index|[
name|i
index|]
operator|==
name|ap
operator|->
name|memno
operator|)
condition|)
block|{
name|deleteslot
argument_list|(
name|sp1
argument_list|)
expr_stmt|;
break|break;
block|}
name|sp1
operator|=
name|sp2
expr_stmt|;
block|}
else|else
name|sp1
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	       * Restore register variables (complement to DOHEAD code). 	       */
name|sp1
operator|=
name|sp
operator|->
name|nullslot
operator|->
name|next
expr_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
condition|)
if|if
condition|(
operator|!
name|regdefined
index|[
name|i
index|]
condition|)
if|if
condition|(
name|i
operator|>=
name|dqp
operator|->
name|nregvars
operator|||
operator|!
name|samevar
argument_list|(
name|rp
argument_list|,
name|dqp
operator|->
name|reg
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|changetoreg
argument_list|(
name|ap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|insertassign
argument_list|(
name|sp1
argument_list|,
name|ap
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
argument_list|)
expr_stmt|;
name|regdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
block|}
name|clearmems
argument_list|()
expr_stmt|;
if|if
condition|(
name|toplcv
operator|+
literal|1
operator|<
name|maxregvar
condition|)
name|memdefined
index|[
name|toplcv
operator|+
literal|1
index|]
operator|=
name|YES
expr_stmt|;
name|sp
operator|=
name|sp1
operator|->
name|prev
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
name|setregs
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXREGVAR
condition|;
name|i
operator|++
control|)
name|regaltered
index|[
name|i
index|]
operator|=
name|NO
expr_stmt|;
name|globalbranch
operator|=
name|NO
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|type
condition|)
block|{
case|case
name|SKLABEL
case|:
name|clearmems
argument_list|()
expr_stmt|;
break|break;
case|case
name|SKGOTO
case|:
if|if
condition|(
operator|!
name|locallabel
argument_list|(
name|sp
operator|->
name|label
argument_list|)
condition|)
name|gensetall
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKENDDO
case|:
name|docount
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SKRETURN
case|:
name|gensetreturn
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|linearcode
operator|=
name|YES
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
name|linearcode
operator|=
name|NO
expr_stmt|;
break|break;
case|case
name|SKDOHEAD
case|:
comment|/* 	       * If one of the current loop's register variables is not in 	       * register in an inner loop, we must save it.  It's a pity 	       * we don't save enough info to optimize this properly... 	       */
for|for
control|(
name|dqp
operator|=
name|dqptr
operator|->
name|down
init|;
name|dqp
condition|;
name|dqp
operator|=
name|dqp
operator|->
name|down
control|)
if|if
condition|(
name|dqp
operator|->
name|dohead
operator|==
name|sp
condition|)
break|break;
if|if
condition|(
name|dqp
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"confused in alreg loop analysis"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
condition|)
if|if
condition|(
operator|!
name|memdefined
index|[
name|i
index|]
condition|)
if|if
condition|(
name|i
operator|>=
name|dqp
operator|->
name|nregvars
operator|||
operator|!
name|samevar
argument_list|(
name|rp
argument_list|,
name|dqp
operator|->
name|reg
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|changetoreg
argument_list|(
name|ap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|insertassign
argument_list|(
name|sp
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|memdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
name|regdefined
index|[
name|i
index|]
operator|=
name|NO
expr_stmt|;
block|}
name|docount
operator|++
expr_stmt|;
name|globalbranch
operator|=
name|YES
expr_stmt|;
break|break;
case|case
name|SKEQ
case|:
case|case
name|SKCALL
case|:
case|case
name|SKSTOP
case|:
case|case
name|SKPAUSE
case|:
name|linearcode
operator|=
name|YES
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|regdefined
index|[
name|i
index|]
operator|&&
operator|(
operator|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
operator|)
operator|&&
name|rp
operator|->
name|isset
operator|)
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|changetoreg
argument_list|(
name|ap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|appendassign
argument_list|(
name|sp
argument_list|,
name|ap
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|regdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
block|}
name|linearcode
operator|=
name|NO
expr_stmt|;
comment|/* 	       * Eliminate redundant register moves. 	       */
if|if
condition|(
name|regtoreg
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|sp
operator|->
name|expr
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|sp1
operator|=
name|sp
operator|->
name|prev
expr_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|toptrack
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regtab
index|[
name|i
index|]
operator|&&
operator|(
name|regnum
index|[
name|i
index|]
operator|==
name|ap
operator|->
name|memno
operator|)
condition|)
block|{
name|deleteslot
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sp1
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|SKARIF
case|:
if|if
condition|(
operator|!
name|locallabel
argument_list|(
name|LM
argument_list|)
operator|||
operator|!
name|locallabel
argument_list|(
name|LZ
argument_list|)
operator|||
operator|!
name|locallabel
argument_list|(
name|LP
argument_list|)
condition|)
block|{
name|gensetall
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|globalbranch
operator|=
name|YES
expr_stmt|;
block|}
name|regwrite
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKASGOTO
case|:
name|gensetall
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|globalbranch
operator|=
name|YES
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKCMGOTO
case|:
name|lp
operator|=
operator|(
expr|struct
name|Labelblock
operator|*
operator|*
operator|)
name|sp
operator|->
name|ctlinfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|label
condition|;
name|i
operator|++
operator|,
name|lp
operator|++
control|)
if|if
condition|(
operator|!
name|locallabel
argument_list|(
operator|(
operator|*
name|lp
operator|)
operator|->
name|labelno
argument_list|)
condition|)
block|{
name|gensetall
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|globalbranch
operator|=
name|YES
expr_stmt|;
break|break;
block|}
name|regwrite
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKIFN
case|:
case|case
name|SKIOIFN
case|:
if|if
condition|(
operator|!
name|locallabel
argument_list|(
name|sp
operator|->
name|label
argument_list|)
condition|)
block|{
name|gensetall
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|globalbranch
operator|=
name|YES
expr_stmt|;
block|}
name|regwrite
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKNULL
case|:
case|case
name|SKASSIGN
case|:
break|break;
default|default:
name|badthing
argument_list|(
literal|"SKtype"
argument_list|,
literal|"alreg-3"
argument_list|,
name|sp
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regaltered
index|[
name|i
index|]
condition|)
name|memdefined
index|[
name|i
index|]
operator|=
name|NO
expr_stmt|;
block|}
if|if
condition|(
name|topregvar
operator|+
literal|1
operator|>
name|highregvar
condition|)
name|highregvar
operator|=
name|topregvar
operator|+
literal|1
expr_stmt|;
name|dqptr
operator|->
name|nregvars
operator|=
name|topregvar
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
condition|)
block|{
name|dqptr
operator|->
name|reg
index|[
name|i
index|]
operator|=
name|regp
operator|=
name|ALLOC
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
name|regp
operator|->
name|vstg
operator|=
name|rp
operator|->
name|vstg
expr_stmt|;
name|regp
operator|->
name|vtype
operator|=
name|rp
operator|->
name|vtype
expr_stmt|;
name|regp
operator|->
name|memno
operator|=
name|rp
operator|->
name|memno
expr_stmt|;
name|regp
operator|->
name|memoffset
operator|=
name|rp
operator|->
name|memoffset
expr_stmt|;
name|regp
operator|->
name|isarrayarg
operator|=
name|rp
operator|->
name|isarrayarg
expr_stmt|;
name|frexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|)
expr_stmt|;
name|regtab
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|tabletop
operator|>=
literal|0
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rt
index|[
name|tabletop
operator|--
index|]
argument_list|)
expr_stmt|;
name|freelabtab
argument_list|()
expr_stmt|;
name|freevartab
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|scanvars
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|Addrp
name|ap
decl_stmt|;
name|ADDRNODE
modifier|*
name|addrinfo
decl_stmt|;
name|VARNODE
modifier|*
name|varinfo
decl_stmt|;
name|chainp
name|args
decl_stmt|;
name|VARNODE
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return;
case|case
name|TEXPR
case|:
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
case|case
name|OPASSIGN
case|:
name|scanassign
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
name|scanopeq
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|OPCALL
case|:
name|scancall
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
default|default:
name|scanvars
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|scanvars
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|scanvars
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|TADDR
case|:
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|p
expr_stmt|;
name|scanvars
argument_list|(
name|ap
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|scanvars
argument_list|(
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISVAR
argument_list|(
name|ap
argument_list|)
condition|)
return|return;
name|addrinfo
operator|=
name|getaddr
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixedaddress
argument_list|(
name|ap
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISREGTYPE
argument_list|(
name|ap
operator|->
name|vtype
argument_list|)
condition|)
block|{
name|varinfo
operator|=
name|getvar
argument_list|(
name|addrinfo
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|varinfo
operator|->
name|isused
operator|=
name|YES
expr_stmt|;
block|}
block|}
else|else
block|{
name|addrinfo
operator|->
name|freeuse
operator|=
name|YES
expr_stmt|;
for|for
control|(
name|q
operator|=
name|addrinfo
operator|->
name|varlist
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|link
control|)
name|q
operator|->
name|isused
operator|=
name|YES
expr_stmt|;
block|}
return|return;
case|case
name|TLIST
case|:
for|for
control|(
name|args
operator|=
name|p
operator|->
name|listblock
operator|.
name|listp
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
name|scanvars
argument_list|(
name|args
operator|->
name|datap
argument_list|)
expr_stmt|;
return|return;
default|default:
name|badtag
argument_list|(
literal|"regalloc:scanvars"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|scanassign
parameter_list|(
name|ep
parameter_list|)
name|Exprp
name|ep
decl_stmt|;
block|{
name|Addrp
name|lhs
decl_stmt|;
name|VARNODE
modifier|*
name|varinfo
decl_stmt|;
name|ADDRNODE
modifier|*
name|addrinfo
decl_stmt|;
name|scanvars
argument_list|(
name|ep
operator|->
name|rightp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|leftp
operator|->
name|tag
operator|==
name|TADDR
condition|)
block|{
name|lhs
operator|=
operator|(
name|Addrp
operator|)
name|ep
operator|->
name|leftp
expr_stmt|;
name|scanvars
argument_list|(
name|lhs
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|scanvars
argument_list|(
name|lhs
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lhs
operator|->
name|vstg
operator|==
name|STGREG
operator|)
operator|||
operator|(
name|lhs
operator|->
name|vstg
operator|==
name|STGPREG
operator|)
condition|)
return|return;
if|if
condition|(
name|ISVAR
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|addrinfo
operator|=
name|getaddr
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|addrinfo
operator|->
name|isset
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|fixedaddress
argument_list|(
name|lhs
argument_list|)
operator|&&
name|ISREGTYPE
argument_list|(
name|lhs
operator|->
name|vtype
argument_list|)
condition|)
block|{
name|varinfo
operator|=
name|getvar
argument_list|(
name|addrinfo
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrinfo
operator|->
name|freeuse
condition|)
name|varinfo
operator|->
name|isused
operator|=
name|YES
expr_stmt|;
name|varinfo
operator|->
name|isset
operator|=
name|YES
expr_stmt|;
if|if
condition|(
operator|!
name|addrinfo
operator|->
name|freeuse
operator|&&
operator|!
name|varinfo
operator|->
name|isused
condition|)
name|varinfo
operator|->
name|setfirst
operator|=
name|YES
expr_stmt|;
block|}
block|}
block|}
else|else
name|badtag
argument_list|(
literal|"regalloc:scanassign"
argument_list|,
name|ep
operator|->
name|leftp
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|scanopeq
parameter_list|(
name|ep
parameter_list|)
name|Exprp
name|ep
decl_stmt|;
block|{
name|Addrp
name|lhs
decl_stmt|;
name|ADDRNODE
modifier|*
name|addrinfo
decl_stmt|;
name|VARNODE
modifier|*
name|varinfo
decl_stmt|;
name|scanvars
argument_list|(
name|ep
operator|->
name|rightp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|leftp
operator|->
name|tag
operator|==
name|TADDR
condition|)
block|{
name|lhs
operator|=
operator|(
name|Addrp
operator|)
name|ep
operator|->
name|leftp
expr_stmt|;
name|scanvars
argument_list|(
name|lhs
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|scanvars
argument_list|(
name|lhs
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lhs
operator|->
name|vstg
operator|==
name|STGREG
operator|)
operator|||
operator|(
name|lhs
operator|->
name|vstg
operator|==
name|STGPREG
operator|)
condition|)
return|return;
if|if
condition|(
name|ISVAR
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|addrinfo
operator|=
name|getaddr
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|addrinfo
operator|->
name|isset
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|fixedaddress
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISREGTYPE
argument_list|(
name|lhs
operator|->
name|vtype
argument_list|)
condition|)
block|{
name|varinfo
operator|=
name|getvar
argument_list|(
name|addrinfo
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|varinfo
operator|->
name|isused
operator|=
name|YES
expr_stmt|;
name|varinfo
operator|->
name|isset
operator|=
name|YES
expr_stmt|;
block|}
block|}
block|}
else|else
name|addrinfo
operator|->
name|freeuse
operator|=
name|YES
expr_stmt|;
block|}
else|else
name|badtag
argument_list|(
literal|"regalloc:scanopeq"
argument_list|,
name|ep
operator|->
name|leftp
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|scancall
parameter_list|(
name|ep
parameter_list|)
name|Exprp
name|ep
decl_stmt|;
block|{
name|Addrp
name|lhs
decl_stmt|;
name|chainp
name|args
decl_stmt|;
name|Addrp
name|ap
decl_stmt|;
name|VARNODE
modifier|*
name|varinfo
decl_stmt|;
name|ADDRNODE
modifier|*
name|addrinfo
decl_stmt|;
name|lhs
operator|=
operator|(
name|Addrp
operator|)
name|ep
operator|->
name|leftp
expr_stmt|;
name|scanvars
argument_list|(
name|lhs
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|scanvars
argument_list|(
name|lhs
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rightp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|lhs
operator|->
name|vstg
operator|!=
name|STGINTR
condition|)
block|{
name|args
operator|=
name|ep
operator|->
name|rightp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
block|{
if|if
condition|(
name|args
operator|->
name|datap
operator|->
name|tag
operator|==
name|TADDR
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|args
operator|->
name|datap
expr_stmt|;
name|scanvars
argument_list|(
name|ap
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|scanvars
argument_list|(
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISVAR
argument_list|(
name|ap
argument_list|)
condition|)
continue|continue;
name|addrinfo
operator|=
name|getaddr
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|addrinfo
operator|->
name|isset
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|fixedaddress
argument_list|(
name|ap
argument_list|)
condition|)
block|{
name|varinfo
operator|=
name|getvar
argument_list|(
name|addrinfo
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|vstg
operator|!=
name|STGCONST
condition|)
name|varinfo
operator|->
name|isset
operator|=
name|YES
expr_stmt|;
name|varinfo
operator|->
name|isused
operator|=
name|YES
expr_stmt|;
block|}
else|else
name|addrinfo
operator|->
name|freeuse
operator|=
name|YES
expr_stmt|;
block|}
else|else
name|scanvars
argument_list|(
name|args
operator|->
name|datap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|scanvars
argument_list|(
name|ep
operator|->
name|rightp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|int
name|fixedaddress
parameter_list|(
name|ap
parameter_list|)
name|Addrp
name|ap
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ap
operator|->
name|memoffset
condition|)
return|return
name|NO
return|;
return|return
operator|(
name|ISCONST
argument_list|(
name|ap
operator|->
name|memoffset
argument_list|)
operator|&&
name|ISINT
argument_list|(
name|ap
operator|->
name|memoffset
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|countrefs
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|Addrp
name|ap
decl_stmt|;
name|ADDRNODE
modifier|*
name|addrinfo
decl_stmt|;
name|VARNODE
modifier|*
name|varinfo
decl_stmt|;
name|VARNODE
modifier|*
name|vp
decl_stmt|;
name|chainp
name|args
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return;
case|case
name|TEXPR
case|:
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
case|case
name|OPCALL
case|:
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|tag
operator|!=
name|TADDR
condition|)
name|badtag
argument_list|(
literal|"regalloc:countrefs"
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|tag
argument_list|)
expr_stmt|;
name|countrefs
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|addrblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|countrefs
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|addrblock
operator|.
name|vstg
operator|!=
name|STGINTR
condition|)
block|{
if|if
condition|(
operator|!
name|commonunusable
condition|)
if|if
condition|(
name|linearcode
condition|)
name|setcommon
argument_list|()
expr_stmt|;
else|else
name|commonunusable
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|==
name|NULL
condition|)
return|return;
name|args
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
if|if
condition|(
name|args
operator|->
name|datap
operator|->
name|tag
operator|==
name|TADDR
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|args
operator|->
name|datap
expr_stmt|;
name|countrefs
argument_list|(
name|ap
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|countrefs
argument_list|(
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISVAR
argument_list|(
name|ap
argument_list|)
operator|||
name|ap
operator|->
name|vstg
operator|==
name|STGCONST
condition|)
continue|continue;
name|addrinfo
operator|=
name|lookupaddr
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|vstg
operator|==
name|STGARG
condition|)
name|addrinfo
operator|->
name|refs
operator|++
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|addrinfo
operator|->
name|varlist
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|link
control|)
if|if
condition|(
name|linearcode
condition|)
if|if
condition|(
operator|!
name|insetlist
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|,
name|vp
operator|->
name|memoffset
argument_list|)
condition|)
if|if
condition|(
name|addrinfo
operator|->
name|istemp
condition|)
name|vp
operator|->
name|refs
operator|--
expr_stmt|;
else|else
block|{
name|vp
operator|->
name|refs
operator|-=
literal|2
expr_stmt|;
name|insertset
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|,
name|vp
operator|->
name|memoffset
argument_list|)
expr_stmt|;
block|}
else|else
name|vp
operator|->
name|refs
operator|--
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|addrinfo
operator|->
name|istemp
condition|)
name|vp
operator|->
name|unusable
operator|=
name|YES
expr_stmt|;
block|}
block|}
else|else
name|countrefs
argument_list|(
name|args
operator|->
name|datap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|==
name|NULL
condition|)
return|return;
name|args
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
if|if
condition|(
name|args
operator|->
name|datap
operator|->
name|tag
operator|==
name|TADDR
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|args
operator|->
name|datap
expr_stmt|;
name|countrefs
argument_list|(
name|ap
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|countrefs
argument_list|(
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISVAR
argument_list|(
name|ap
argument_list|)
operator|||
name|ap
operator|->
name|vstg
operator|==
name|STGCONST
condition|)
continue|continue;
name|addrinfo
operator|=
name|lookupaddr
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|)
expr_stmt|;
name|addrinfo
operator|->
name|refs
operator|++
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|addrinfo
operator|->
name|varlist
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|link
control|)
if|if
condition|(
operator|!
name|insetlist
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|,
name|vp
operator|->
name|memoffset
argument_list|)
condition|)
block|{
name|vp
operator|->
name|refs
operator|--
expr_stmt|;
name|insertset
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|,
name|vp
operator|->
name|memoffset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|countrefs
argument_list|(
name|args
operator|->
name|datap
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|OPASSIGN
case|:
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
name|countrefs
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|countrefs
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
if|if
condition|(
name|fixedaddress
argument_list|(
name|ap
argument_list|)
condition|)
if|if
condition|(
name|globalbranch
condition|)
block|{
name|countrefs
argument_list|(
name|ap
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|countrefs
argument_list|(
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
block|}
else|else
name|countrefs
argument_list|(
name|ap
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|linearcode
condition|)
block|{
name|countrefs
argument_list|(
name|ap
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|lookupaddr
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|)
operator|->
name|varlist
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|link
control|)
name|vp
operator|->
name|refs
operator|--
expr_stmt|;
block|}
else|else
block|{
name|countrefs
argument_list|(
name|ap
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|lookupaddr
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|)
operator|->
name|varlist
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|link
control|)
name|vp
operator|->
name|unusable
operator|=
name|YES
expr_stmt|;
block|}
return|return;
default|default:
name|countrefs
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|countrefs
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|countrefs
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|TADDR
case|:
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|p
expr_stmt|;
name|countrefs
argument_list|(
name|ap
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|countrefs
argument_list|(
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISVAR
argument_list|(
name|ap
argument_list|)
condition|)
return|return;
name|addrinfo
operator|=
name|lookupaddr
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|vstg
operator|==
name|STGARG
condition|)
name|addrinfo
operator|->
name|refs
operator|++
expr_stmt|;
if|if
condition|(
name|fixedaddress
argument_list|(
name|ap
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISREGTYPE
argument_list|(
name|ap
operator|->
name|vtype
argument_list|)
condition|)
block|{
name|varinfo
operator|=
name|lookupvar
argument_list|(
name|addrinfo
argument_list|,
name|ap
operator|->
name|memoffset
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
argument_list|)
expr_stmt|;
name|varinfo
operator|->
name|refs
operator|++
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|vp
operator|=
name|addrinfo
operator|->
name|varlist
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|link
control|)
if|if
condition|(
operator|!
name|insetlist
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|,
name|vp
operator|->
name|memoffset
argument_list|)
condition|)
block|{
name|vp
operator|->
name|refs
operator|--
expr_stmt|;
name|insertset
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|,
name|vp
operator|->
name|memoffset
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|TLIST
case|:
name|args
operator|=
name|p
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
name|countrefs
argument_list|(
name|args
operator|->
name|datap
argument_list|)
expr_stmt|;
return|return;
default|default:
name|badtag
argument_list|(
literal|"regalloc:countrefs"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|regwrite
parameter_list|(
name|sp
parameter_list|,
name|p
parameter_list|)
name|Slotp
name|sp
decl_stmt|;
name|expptr
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|REGDATA
modifier|*
name|rp
decl_stmt|;
name|chainp
name|args
decl_stmt|;
name|Addrp
name|ap
decl_stmt|,
name|ap1
decl_stmt|;
name|int
name|memoffset
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return;
case|case
name|TEXPR
case|:
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
case|case
name|OPCALL
case|:
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|ap
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|vstg
operator|!=
name|STGINTR
condition|)
block|{
if|if
condition|(
name|linearcode
condition|)
block|{
name|gensetcommon
argument_list|(
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
operator|)
operator|&&
operator|(
name|rp
operator|->
name|vstg
operator|==
name|STGCOMMON
operator|)
condition|)
name|regdefined
index|[
name|i
index|]
operator|=
name|NO
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|==
name|NULL
condition|)
return|return;
name|args
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
if|if
condition|(
name|args
operator|->
name|datap
operator|->
name|tag
operator|==
name|TADDR
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|args
operator|->
name|datap
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|ap
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
operator|)
operator|&&
operator|!
name|rp
operator|->
name|isarrayarg
operator|&&
operator|!
name|rp
operator|->
name|istemp
operator|&&
operator|(
name|rp
operator|->
name|vstg
operator|==
name|ap
operator|->
name|vstg
operator|)
operator|&&
operator|(
name|rp
operator|->
name|memno
operator|==
name|ap
operator|->
name|memno
operator|)
condition|)
block|{
name|regdefined
index|[
name|i
index|]
operator|=
name|NO
expr_stmt|;
if|if
condition|(
operator|!
name|memdefined
index|[
name|i
index|]
condition|)
block|{
name|ap1
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|changetoreg
argument_list|(
name|ap1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|insertassign
argument_list|(
name|sp
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
argument_list|,
name|ap1
argument_list|)
expr_stmt|;
name|memdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|isarrayarg
operator|&&
operator|(
name|ap
operator|->
name|vstg
operator|==
name|STGARG
operator|)
operator|&&
operator|(
name|ap
operator|->
name|memno
operator|==
name|rp
operator|->
name|memno
operator|)
condition|)
block|{
name|ap
operator|->
name|vstg
operator|=
name|STGPREG
expr_stmt|;
name|ap
operator|->
name|memno
operator|=
name|regnum
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
name|regwrite
argument_list|(
name|sp
argument_list|,
name|args
operator|->
name|datap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|==
name|NULL
condition|)
return|return;
name|args
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
if|if
condition|(
name|args
operator|->
name|datap
operator|->
name|tag
operator|==
name|TADDR
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|args
operator|->
name|datap
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|ap
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
operator|)
operator|&&
operator|!
name|rp
operator|->
name|isarrayarg
operator|&&
operator|!
name|rp
operator|->
name|istemp
operator|&&
operator|(
name|rp
operator|->
name|vstg
operator|==
name|ap
operator|->
name|vstg
operator|)
operator|&&
operator|(
name|rp
operator|->
name|memno
operator|==
name|ap
operator|->
name|memno
operator|)
operator|&&
operator|!
name|memdefined
index|[
name|i
index|]
condition|)
block|{
name|ap1
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|changetoreg
argument_list|(
name|ap1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|insertassign
argument_list|(
name|sp
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
argument_list|,
name|ap1
argument_list|)
expr_stmt|;
name|memdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|isarrayarg
operator|&&
operator|(
name|ap
operator|->
name|vstg
operator|==
name|STGARG
operator|)
operator|&&
operator|(
name|rp
operator|->
name|memno
operator|==
name|ap
operator|->
name|memno
operator|)
condition|)
block|{
name|ap
operator|->
name|vstg
operator|=
name|STGPREG
expr_stmt|;
name|ap
operator|->
name|memno
operator|=
name|regnum
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|regwrite
argument_list|(
name|sp
argument_list|,
name|args
operator|->
name|datap
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
case|case
name|OPASSIGN
case|:
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
name|regwrite
argument_list|(
name|sp
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|ap
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|vstg
operator|==
name|STGARG
condition|)
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
operator|)
operator|&&
name|rp
operator|->
name|isarrayarg
operator|&&
operator|(
name|rp
operator|->
name|memno
operator|==
name|ap
operator|->
name|memno
operator|)
condition|)
block|{
name|ap
operator|->
name|vstg
operator|=
name|STGPREG
expr_stmt|;
name|ap
operator|->
name|memno
operator|=
name|regnum
index|[
name|i
index|]
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fixedaddress
argument_list|(
name|ap
argument_list|)
condition|)
block|{
name|memoffset
operator|=
name|ap
operator|->
name|memoffset
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
operator|)
operator|&&
operator|!
name|rp
operator|->
name|isarrayarg
operator|&&
operator|(
name|rp
operator|->
name|vstg
operator|==
name|ap
operator|->
name|vstg
operator|)
operator|&&
operator|(
name|rp
operator|->
name|memno
operator|==
name|ap
operator|->
name|memno
operator|)
operator|&&
operator|(
name|rp
operator|->
name|memoffset
operator|==
name|memoffset
operator|)
condition|)
block|{
name|changetoreg
argument_list|(
name|ap
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|globalbranch
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPASSIGN
expr_stmt|;
name|memdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
block|}
else|else
block|{
name|regaltered
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
name|regdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
name|linearcode
condition|)
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
operator|)
operator|&&
operator|!
name|rp
operator|->
name|isarrayarg
operator|&&
operator|(
name|rp
operator|->
name|vstg
operator|==
name|ap
operator|->
name|vstg
operator|)
operator|&&
operator|(
name|rp
operator|->
name|memno
operator|==
name|ap
operator|->
name|memno
operator|)
condition|)
name|regdefined
index|[
name|i
index|]
operator|=
name|NO
expr_stmt|;
return|return;
default|default:
name|regwrite
argument_list|(
name|sp
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|TADDR
case|:
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|p
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|ap
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|regwrite
argument_list|(
name|sp
argument_list|,
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|vstg
operator|==
name|STGARG
condition|)
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
operator|)
operator|&&
name|rp
operator|->
name|isarrayarg
operator|&&
operator|(
name|rp
operator|->
name|memno
operator|==
name|ap
operator|->
name|memno
operator|)
condition|)
block|{
name|ap
operator|->
name|vstg
operator|=
name|STGPREG
expr_stmt|;
name|ap
operator|->
name|memno
operator|=
name|regnum
index|[
name|i
index|]
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fixedaddress
argument_list|(
name|ap
argument_list|)
condition|)
block|{
name|memoffset
operator|=
name|ap
operator|->
name|memoffset
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
operator|)
operator|&&
operator|!
name|rp
operator|->
name|isarrayarg
operator|&&
operator|(
name|rp
operator|->
name|vstg
operator|==
name|ap
operator|->
name|vstg
operator|)
operator|&&
operator|(
name|rp
operator|->
name|memno
operator|==
name|ap
operator|->
name|memno
operator|)
operator|&&
operator|(
name|rp
operator|->
name|memoffset
operator|==
name|memoffset
operator|)
condition|)
block|{
name|changetoreg
argument_list|(
name|ap
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
operator|)
operator|&&
operator|!
name|rp
operator|->
name|isarrayarg
operator|&&
operator|(
name|rp
operator|->
name|vstg
operator|==
name|ap
operator|->
name|vstg
operator|)
operator|&&
operator|(
name|rp
operator|->
name|memno
operator|==
name|ap
operator|->
name|memno
operator|)
operator|&&
operator|!
name|memdefined
index|[
name|i
index|]
condition|)
block|{
name|ap1
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|changetoreg
argument_list|(
name|ap1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|insertassign
argument_list|(
name|sp
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
argument_list|,
name|ap1
argument_list|)
expr_stmt|;
name|memdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
block|}
block|}
return|return;
case|case
name|TLIST
case|:
for|for
control|(
name|args
operator|=
name|p
operator|->
name|listblock
operator|.
name|listp
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
name|regwrite
argument_list|(
name|sp
argument_list|,
name|args
operator|->
name|datap
argument_list|)
expr_stmt|;
return|return;
default|default:
name|badtag
argument_list|(
literal|"regalloc:regwrite"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|setcommon
parameter_list|()
block|{
name|ADDRNODE
modifier|*
name|ap
decl_stmt|;
name|VARNODE
modifier|*
name|vp
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|commonvars
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|commonlink
control|)
for|for
control|(
name|vp
operator|=
name|ap
operator|->
name|varlist
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|link
control|)
if|if
condition|(
operator|!
name|insetlist
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|,
name|vp
operator|->
name|memoffset
argument_list|)
condition|)
block|{
name|vp
operator|->
name|refs
operator|-=
literal|2
expr_stmt|;
name|insertset
argument_list|(
name|ap
operator|->
name|vstg
argument_list|,
name|ap
operator|->
name|memno
argument_list|,
name|vp
operator|->
name|memoffset
argument_list|)
expr_stmt|;
block|}
else|else
name|vp
operator|->
name|refs
operator|--
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|LOCAL
name|setall
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|ADDRNODE
modifier|*
name|p
decl_stmt|;
specifier|register
name|VARNODE
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARTABSIZE
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|vartable
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
if|if
condition|(
name|p
operator|->
name|istemp
operator|||
operator|!
name|p
operator|->
name|isset
condition|)
break|break;
else|else
for|for
control|(
name|q
operator|=
name|p
operator|->
name|varlist
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|link
control|)
if|if
condition|(
name|q
operator|->
name|isset
operator|&&
operator|!
name|insetlist
argument_list|(
name|p
operator|->
name|vstg
argument_list|,
name|p
operator|->
name|memno
argument_list|,
name|q
operator|->
name|memoffset
argument_list|)
condition|)
name|q
operator|->
name|refs
operator|--
expr_stmt|;
name|allset
operator|=
name|YES
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|int
name|samevar
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
specifier|register
name|REGDATA
modifier|*
name|r1
decl_stmt|;
specifier|register
name|REGNODE
modifier|*
name|r2
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|r1
operator|->
name|vstg
operator|!=
name|r2
operator|->
name|vstg
operator|)
operator|||
operator|(
name|r1
operator|->
name|memno
operator|!=
name|r2
operator|->
name|memno
operator|)
operator|||
operator|(
name|r1
operator|->
name|isarrayarg
operator|!=
name|r2
operator|->
name|isarrayarg
operator|)
condition|)
return|return
name|NO
return|;
if|if
condition|(
name|r1
operator|->
name|isarrayarg
condition|)
return|return
name|YES
return|;
return|return
operator|(
name|r1
operator|->
name|memoffset
operator|==
name|r2
operator|->
name|memoffset
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|entableaddr
parameter_list|(
name|p
parameter_list|)
name|ADDRNODE
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|refs
decl_stmt|;
name|Addrp
name|ap
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|vstg
operator|!=
name|STGARG
condition|)
block|{
name|currentaddr
operator|=
name|p
expr_stmt|;
return|return;
block|}
name|refs
operator|=
name|p
operator|->
name|refs
expr_stmt|;
if|if
condition|(
name|refs
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|tabletop
operator|<
literal|0
condition|)
name|tabletop
operator|=
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|refs
operator|>
name|rt
index|[
name|tabletop
index|]
operator|->
name|refs
condition|)
block|{
if|if
condition|(
name|tabletop
operator|+
literal|1
operator|<
name|TABLELIMIT
condition|)
name|tabletop
operator|++
expr_stmt|;
else|else
block|{
name|frexpr
argument_list|(
name|rt
index|[
name|tabletop
index|]
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rt
index|[
name|tabletop
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|tabletop
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|refs
operator|>
name|rt
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|refs
condition|)
name|rt
index|[
name|i
index|]
operator|=
name|rt
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|tabletop
operator|+
literal|1
operator|<
name|TABLELIMIT
condition|)
name|i
operator|=
operator|++
name|tabletop
expr_stmt|;
else|else
return|return;
name|rt
index|[
name|i
index|]
operator|=
name|ALLOC
argument_list|(
name|regdata
argument_list|)
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|vstg
operator|=
name|p
operator|->
name|vstg
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|vtype
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|memno
operator|=
name|p
operator|->
name|memno
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|refs
operator|=
name|refs
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|isarrayarg
operator|=
name|YES
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|entablevar
parameter_list|(
name|p
parameter_list|)
name|VARNODE
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|refs
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|unusable
condition|)
return|return;
name|refs
operator|=
name|p
operator|->
name|refs
operator|-
name|loopcost
expr_stmt|;
if|if
condition|(
name|refs
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|tabletop
operator|<
literal|0
condition|)
name|tabletop
operator|=
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|refs
operator|>
name|rt
index|[
name|tabletop
index|]
operator|->
name|refs
condition|)
block|{
if|if
condition|(
name|tabletop
operator|+
literal|1
operator|<
name|TABLELIMIT
condition|)
name|tabletop
operator|++
expr_stmt|;
else|else
block|{
name|frexpr
argument_list|(
name|rt
index|[
name|tabletop
index|]
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rt
index|[
name|tabletop
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|tabletop
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|refs
operator|>
name|rt
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|refs
condition|)
name|rt
index|[
name|i
index|]
operator|=
name|rt
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|tabletop
operator|+
literal|1
operator|<
name|TABLELIMIT
condition|)
name|i
operator|=
operator|++
name|tabletop
expr_stmt|;
else|else
return|return;
name|rt
index|[
name|i
index|]
operator|=
name|ALLOC
argument_list|(
name|regdata
argument_list|)
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|vstg
operator|=
name|currentaddr
operator|->
name|vstg
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|vtype
operator|=
name|currentaddr
operator|->
name|vtype
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|memno
operator|=
name|currentaddr
operator|->
name|memno
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|memoffset
operator|=
name|p
operator|->
name|memoffset
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|refs
operator|=
name|refs
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|stgp
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|isarrayarg
operator|=
name|NO
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|istemp
operator|=
name|currentaddr
operator|->
name|istemp
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|isset
operator|=
name|p
operator|->
name|isset
expr_stmt|;
name|rt
index|[
name|i
index|]
operator|->
name|setfirst
operator|=
name|p
operator|->
name|setfirst
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|int
name|inregtab
parameter_list|(
name|p
parameter_list|)
specifier|register
name|REGDATA
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|REGDATA
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
condition|)
if|if
condition|(
operator|(
name|rp
operator|->
name|vstg
operator|==
name|p
operator|->
name|vstg
operator|)
operator|&&
operator|(
name|rp
operator|->
name|memno
operator|==
name|p
operator|->
name|memno
operator|)
operator|&&
operator|(
name|rp
operator|->
name|isarrayarg
operator|==
name|p
operator|->
name|isarrayarg
operator|)
condition|)
if|if
condition|(
name|rp
operator|->
name|isarrayarg
condition|)
return|return
name|YES
return|;
elseif|else
if|if
condition|(
name|rp
operator|->
name|memoffset
operator|==
name|p
operator|->
name|memoffset
condition|)
return|return
name|YES
return|;
return|return
name|NO
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|changetoreg
parameter_list|(
name|ap
parameter_list|,
name|i
parameter_list|)
specifier|register
name|Addrp
name|ap
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|ap
operator|->
name|vstg
operator|=
name|STGREG
expr_stmt|;
name|ap
operator|->
name|memno
operator|=
name|regnum
index|[
name|i
index|]
expr_stmt|;
name|frexpr
argument_list|(
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
name|ap
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|FAMILY
operator|==
name|PCC
operator|&&
name|SZSHORT
operator|<
name|SZINT
comment|/*    * Handle PCC bogosity that values in registers must be at least INT width.    */
if|if
condition|(
name|ap
operator|->
name|vtype
operator|==
name|TYSHORT
condition|)
name|ap
operator|->
name|vtype
operator|=
name|TYINT
expr_stmt|;
endif|#
directive|endif
name|ap
operator|->
name|istemp
operator|=
name|NO
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|insertassign
parameter_list|(
name|sp
parameter_list|,
name|dest
parameter_list|,
name|src
parameter_list|)
name|Slotp
name|sp
decl_stmt|;
name|Addrp
name|dest
decl_stmt|;
name|expptr
name|src
decl_stmt|;
block|{
name|Slotp
name|newslot
decl_stmt|;
name|expptr
name|p
decl_stmt|;
name|p
operator|=
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|newslot
operator|=
name|optinsert
argument_list|(
name|SKEQ
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|dohead
condition|)
if|if
condition|(
operator|!
name|newcode
condition|)
name|newcode
operator|=
name|newslot
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|LOCAL
name|appendassign
parameter_list|(
name|sp
parameter_list|,
name|dest
parameter_list|,
name|src
parameter_list|)
name|Slotp
name|sp
decl_stmt|;
name|Addrp
name|dest
decl_stmt|;
name|expptr
name|src
decl_stmt|;
block|{
name|Slotp
name|newslot
decl_stmt|;
name|expptr
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
name|fatal
argument_list|(
literal|"regalloc:appendassign"
argument_list|)
expr_stmt|;
name|p
operator|=
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|newslot
operator|=
name|optinsert
argument_list|(
name|SKEQ
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sp
operator|->
name|next
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|int
name|regtomem
parameter_list|(
name|sp
parameter_list|)
name|Slotp
name|sp
decl_stmt|;
block|{
name|expptr
name|p
decl_stmt|,
name|l
decl_stmt|,
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|SKEQ
condition|)
return|return
name|NO
return|;
name|p
operator|=
name|sp
operator|->
name|expr
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
operator|)
operator|||
operator|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|!=
name|OPASSIGN
operator|)
condition|)
return|return
name|NO
return|;
name|r
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|tag
operator|!=
name|TADDR
operator|)
operator|||
operator|(
name|r
operator|->
name|addrblock
operator|.
name|vstg
operator|!=
name|STGREG
operator|)
condition|)
return|return
name|NO
return|;
name|l
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|tag
operator|!=
name|TADDR
condition|)
return|return
name|NO
return|;
name|i
operator|=
name|r
operator|->
name|addrblock
operator|.
name|memno
expr_stmt|;
if|if
condition|(
name|regtab
index|[
name|i
index|]
operator|&&
operator|(
name|l
operator|->
name|addrblock
operator|.
name|vstg
operator|==
name|regtab
index|[
name|i
index|]
operator|->
name|vstg
operator|)
operator|&&
operator|(
name|l
operator|->
name|addrblock
operator|.
name|memno
operator|==
name|regtab
index|[
name|i
index|]
operator|->
name|memno
operator|)
operator|&&
name|fixedaddress
argument_list|(
name|l
argument_list|)
operator|&&
operator|(
name|l
operator|->
name|addrblock
operator|.
name|memoffset
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|==
name|regtab
index|[
name|i
index|]
operator|->
name|memoffset
operator|)
condition|)
return|return
name|YES
return|;
return|return
name|NO
return|;
block|}
end_function

begin_function
name|LOCAL
name|int
name|regtoreg
parameter_list|(
name|sp
parameter_list|)
name|Slotp
name|sp
decl_stmt|;
block|{
name|expptr
name|p
decl_stmt|,
name|l
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|SKEQ
condition|)
return|return
name|NO
return|;
name|p
operator|=
name|sp
operator|->
name|expr
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
operator|)
operator|||
operator|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|!=
name|OPASSIGN
operator|)
condition|)
return|return
name|NO
return|;
name|l
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|->
name|tag
operator|!=
name|TADDR
operator|)
operator|||
operator|(
name|l
operator|->
name|addrblock
operator|.
name|vstg
operator|!=
name|STGREG
operator|)
condition|)
return|return
name|NO
return|;
name|r
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|tag
operator|==
name|TADDR
operator|)
operator|&&
operator|(
name|r
operator|->
name|addrblock
operator|.
name|vstg
operator|==
name|STGREG
operator|)
operator|&&
operator|(
name|r
operator|->
name|addrblock
operator|.
name|memno
operator|==
name|l
operator|->
name|addrblock
operator|.
name|memno
operator|)
condition|)
return|return
name|YES
return|;
return|return
name|NO
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|deleteslot
parameter_list|(
name|sp
parameter_list|)
name|Slotp
name|sp
decl_stmt|;
block|{
if|if
condition|(
name|newcode
operator|==
name|sp
condition|)
block|{
name|newcode
operator|=
name|sp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|newcode
operator|==
name|dohead
condition|)
name|newcode
operator|=
name|NULL
expr_stmt|;
block|}
name|delslot
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|gensetall
parameter_list|(
name|sp
parameter_list|)
name|Slotp
name|sp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|REGDATA
modifier|*
name|rp
decl_stmt|;
specifier|register
name|Addrp
name|ap
decl_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
condition|)
if|if
condition|(
name|rp
operator|->
name|isset
operator|&&
operator|!
operator|(
name|rp
operator|->
name|istemp
operator|||
name|rp
operator|->
name|isarrayarg
operator|)
condition|)
if|if
condition|(
operator|!
name|memdefined
index|[
name|i
index|]
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|changetoreg
argument_list|(
name|ap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|insertassign
argument_list|(
name|sp
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|memdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|LOCAL
name|gensetcommon
parameter_list|(
name|sp
parameter_list|)
name|Slotp
name|sp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|REGDATA
modifier|*
name|rp
decl_stmt|;
specifier|register
name|Addrp
name|ap
decl_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
condition|)
if|if
condition|(
operator|(
name|rp
operator|->
name|vstg
operator|==
name|STGCOMMON
operator|)
operator|&&
operator|!
name|rp
operator|->
name|isarrayarg
condition|)
if|if
condition|(
operator|!
name|memdefined
index|[
name|i
index|]
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|changetoreg
argument_list|(
name|ap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|insertassign
argument_list|(
name|sp
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|memdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|LOCAL
name|gensetreturn
parameter_list|(
name|sp
parameter_list|)
name|Slotp
name|sp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|REGDATA
modifier|*
name|rp
decl_stmt|;
specifier|register
name|Addrp
name|ap
decl_stmt|;
for|for
control|(
name|i
operator|=
name|toplcv
operator|+
literal|1
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
condition|)
if|if
condition|(
operator|(
operator|(
name|rp
operator|->
name|vstg
operator|==
name|STGCOMMON
operator|)
operator|&&
operator|!
name|rp
operator|->
name|isarrayarg
operator|)
operator|||
operator|(
name|rp
operator|->
name|isset
operator|&&
operator|(
name|saveall
operator|||
name|rp
operator|->
name|stgp
operator|->
name|issaved
operator|)
operator|&&
operator|!
operator|(
name|rp
operator|->
name|istemp
operator|||
name|rp
operator|->
name|isarrayarg
operator|)
operator|)
condition|)
if|if
condition|(
operator|!
name|memdefined
index|[
name|i
index|]
condition|)
block|{
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
expr_stmt|;
name|changetoreg
argument_list|(
name|ap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|insertassign
argument_list|(
name|sp
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|stgp
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|memdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|clearmems
parameter_list|()
block|{
name|REGDATA
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|toplcv
condition|;
name|i
operator|++
control|)
name|memdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rp
operator|=
name|regtab
index|[
name|i
index|]
operator|)
operator|&&
name|rp
operator|->
name|isset
condition|)
name|memdefined
index|[
name|i
index|]
operator|=
name|NO
expr_stmt|;
else|else
name|memdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|LOCAL
name|setregs
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|topregvar
condition|;
name|i
operator|++
control|)
name|regdefined
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_macro
name|regalloc
argument_list|()
end_macro

begin_block
block|{
name|int
name|match
decl_stmt|;
name|Slotp
name|nextslot
decl_stmt|;
name|Slotp
name|sl1
decl_stmt|,
name|sl2
decl_stmt|;
name|Slotp
name|lastlabslot
decl_stmt|;
if|if
condition|(
operator|!
name|optimflag
condition|)
return|return;
name|lastlabslot
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sl1
operator|=
name|firstslot
init|;
name|sl1
condition|;
name|sl1
operator|=
name|nextslot
control|)
block|{
name|nextslot
operator|=
name|sl1
operator|->
name|next
expr_stmt|;
switch|switch
condition|(
name|sl1
operator|->
name|type
condition|)
block|{
comment|/* temporarily commented out ----- 	    case SKLABEL: 		lastlabslot = sl1; 		break;  	    case SKGOTO: 		if (lastlabslot&& sl1->label == lastlabslot->label) 			{ 			dohead = lastlabslot; 			doend = sl1; 			alreg (); 			} 		break; ----- */
case|case
name|SKDOHEAD
case|:
name|pushq
argument_list|(
name|sl1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKENDDO
case|:
name|match
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sl2
operator|=
name|sl1
init|;
name|sl2
condition|;
name|sl2
operator|=
name|sl2
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|sl2
operator|->
name|type
operator|==
name|SKDOHEAD
condition|)
name|match
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|sl2
operator|->
name|type
operator|==
name|SKENDDO
condition|)
name|match
operator|--
expr_stmt|;
if|if
condition|(
name|match
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|sl2
condition|)
name|dohead
operator|=
name|sl2
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"unmatched enddo in code buffer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl2
operator|->
name|type
operator|!=
name|SKDOHEAD
condition|)
name|fatal
argument_list|(
literal|"internal error in regalloc"
argument_list|)
expr_stmt|;
for|for
control|(
name|dqptr
operator|=
name|dqbottom
init|;
name|dqptr
condition|;
name|dqptr
operator|=
name|dqptr
operator|->
name|up
control|)
block|{
if|if
condition|(
name|dqptr
operator|->
name|dohead
operator|==
name|dohead
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|dqptr
condition|)
name|fatal
argument_list|(
literal|"garbled doqueue in regalloc"
argument_list|)
expr_stmt|;
comment|/*  sl1 now points to the SKENDDO slot; the SKNULL slot 		 *  is reached through sl1->nullslot 		 */
name|doend
operator|=
operator|(
name|Slotp
operator|)
name|sl1
operator|->
name|nullslot
expr_stmt|;
name|alreg
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
while|while
condition|(
name|dqtop
condition|)
name|popq
argument_list|(
name|dqtop
operator|->
name|dohead
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_function
name|LOCAL
name|pushq
parameter_list|(
name|sp
parameter_list|)
name|Slotp
name|sp
decl_stmt|;
block|{
name|DOQUEUE
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|SKDOHEAD
condition|)
name|fatal
argument_list|(
literal|"regalloc:pushq:  DO statement expected"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dqbottom
condition|)
block|{
name|t
operator|=
name|ALLOC
argument_list|(
name|doqueue
argument_list|)
expr_stmt|;
name|t
operator|->
name|up
operator|=
name|dqbottom
expr_stmt|;
name|dqbottom
operator|->
name|down
operator|=
name|t
expr_stmt|;
name|dqbottom
operator|=
name|t
expr_stmt|;
block|}
else|else
name|dqtop
operator|=
name|dqbottom
operator|=
name|ALLOC
argument_list|(
name|doqueue
argument_list|)
expr_stmt|;
name|dqbottom
operator|->
name|dohead
operator|=
name|sp
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|popq
parameter_list|(
name|sp
parameter_list|)
name|Slotp
name|sp
decl_stmt|;
block|{
name|DOQUEUE
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dqtop
condition|)
name|fatal
argument_list|(
literal|"regalloc:popq:  empty DO queue"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dqtop
operator|->
name|dohead
operator|!=
name|sp
condition|)
name|fatal
argument_list|(
literal|"regalloc:popq:  garbled DO queue"
argument_list|)
expr_stmt|;
name|t
operator|=
name|dqtop
expr_stmt|;
name|dqtop
operator|=
name|t
operator|->
name|down
expr_stmt|;
if|if
condition|(
name|dqtop
condition|)
name|dqtop
operator|->
name|up
operator|=
name|NULL
expr_stmt|;
else|else
name|dqbottom
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXREGVAR
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|reg
index|[
name|i
index|]
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

