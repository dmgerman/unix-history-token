begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980 The Regents of the University of California.  * All rights reserved.  *  * This module is believed to contain source code proprietary to AT&T.  * Use and redistribution is subject to the Berkeley Software License  * Agreement and your Software Agreement with AT&T (Western Electric).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)conv.c	5.3 (Berkeley) 4/12/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * conv.c  *  * Routines for type conversions, f77 compiler pass 1.  *  * University of Utah CS Dept modification history:  *  * $Log:	conv.c,v $  * Revision 2.2  85/06/07  21:09:29  root  * Add copyright  *   * Revision 2.1  84/07/19  12:02:29  donn  * Changed comment headers for UofU.  *   * Revision 1.2  84/04/13  01:07:02  donn  * Fixed value of dminreal to be -1.7e38 + epsilon instead of -2.59e33, per  * Bob Corbett's approval.  *   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"conv.h"
end_include

begin_decl_stmt
name|int
name|badvalue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  The following constants are used to check the limits of  */
end_comment

begin_comment
comment|/*  conversions.  Dmaxword is the largest double precision   */
end_comment

begin_comment
comment|/*  number which can be converted to a two-byte integer      */
end_comment

begin_comment
comment|/*  without overflow.  Dminword is the smallest double       */
end_comment

begin_comment
comment|/*  precision value which can be converted to a two-byte     */
end_comment

begin_comment
comment|/*  integer without overflow.  Dmaxint and dminint are the   */
end_comment

begin_comment
comment|/*  analogous values for four-byte integers.                 */
end_comment

begin_decl_stmt
name|LOCAL
name|long
name|dmaxword
index|[]
init|=
block|{
literal|0xfeff47ff
block|,
literal|0xffffffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|dminword
index|[]
init|=
block|{
literal|0x00ffc800
block|,
literal|0xffffffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|dmaxint
index|[]
init|=
block|{
literal|0xffff4fff
block|,
literal|0xfffffeff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|dminint
index|[]
init|=
block|{
literal|0x0000d000
block|,
literal|0xffff00ff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|dmaxreal
index|[]
init|=
block|{
literal|0xffff7fff
block|,
literal|0xffff7fff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|dminreal
index|[]
init|=
block|{
literal|0xffffffff
block|,
literal|0xffff7fff
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  The routines which follow are used to convert  */
end_comment

begin_comment
comment|/*  constants into constants of other types.       */
end_comment

begin_function
name|LOCAL
name|char
modifier|*
name|grabbits
parameter_list|(
name|len
parameter_list|,
name|cp
parameter_list|)
name|int
name|len
decl_stmt|;
name|Constp
name|cp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|toobig
init|=
literal|"bit value too large"
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|bits
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|lenb
decl_stmt|;
name|bits
operator|=
name|cp
operator|->
name|constant
operator|.
name|ccp
expr_stmt|;
name|lenb
operator|=
name|cp
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|lenb
condition|)
name|k
operator|=
name|lenb
expr_stmt|;
else|else
block|{
name|k
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|badvalue
operator|==
literal|0
condition|)
block|{
if|#
directive|if
operator|(
name|TARGET
operator|==
name|PDP11
operator|||
name|TARGET
operator|==
name|VAX
operator|)
name|i
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|lenb
operator|&&
name|bits
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|lenb
condition|)
name|badvalue
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|i
operator|=
name|lenb
operator|-
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|bits
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|badvalue
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|badvalue
condition|)
name|warn
argument_list|(
name|toobig
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|(
name|TARGET
operator|==
name|PDP11
operator|||
name|TARGET
operator|==
name|VAX
operator|)
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|k
condition|)
block|{
name|p
index|[
name|i
index|]
operator|=
name|bits
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|#
directive|else
name|i
operator|=
name|lenb
expr_stmt|;
while|while
condition|(
name|k
operator|>
literal|0
condition|)
name|p
index|[
operator|--
name|k
index|]
operator|=
name|bits
index|[
operator|--
name|i
index|]
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|char
modifier|*
name|grabbytes
parameter_list|(
name|len
parameter_list|,
name|cp
parameter_list|)
name|int
name|len
decl_stmt|;
name|Constp
name|cp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|bytes
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|lenb
decl_stmt|;
name|bytes
operator|=
name|cp
operator|->
name|constant
operator|.
name|ccp
expr_stmt|;
name|lenb
operator|=
name|cp
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|lenb
condition|)
name|k
operator|=
name|lenb
expr_stmt|;
else|else
name|k
operator|=
name|len
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|k
condition|)
block|{
name|p
index|[
name|i
index|]
operator|=
name|bytes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|len
condition|)
name|p
index|[
name|i
operator|++
index|]
operator|=
name|BLANK
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|expptr
name|cshort
parameter_list|(
name|cp
parameter_list|)
name|Constp
name|cp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|toobig
init|=
literal|"data value too large"
decl_stmt|;
specifier|static
name|char
modifier|*
name|reserved
init|=
literal|"reserved operand assigned to an integer"
decl_stmt|;
specifier|static
name|char
modifier|*
name|compat1
init|=
literal|"logical datum assigned to an integer variable"
decl_stmt|;
specifier|static
name|char
modifier|*
name|compat2
init|=
literal|"character datum assigned to an integer variable"
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
specifier|register
name|short
modifier|*
name|shortp
decl_stmt|;
specifier|register
name|ftnint
name|value
decl_stmt|;
specifier|register
name|long
modifier|*
name|rp
decl_stmt|;
specifier|register
name|double
modifier|*
name|minp
decl_stmt|;
specifier|register
name|double
modifier|*
name|maxp
decl_stmt|;
name|realvalue
name|x
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|vtype
condition|)
block|{
case|case
name|TYBITSTR
case|:
name|shortp
operator|=
operator|(
name|short
operator|*
operator|)
name|grabbits
argument_list|(
literal|2
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYSHORT
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
operator|*
name|shortp
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|shortp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYSHORT
case|:
name|p
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYLONG
case|:
name|value
operator|=
name|cp
operator|->
name|constant
operator|.
name|ci
expr_stmt|;
if|if
condition|(
name|value
operator|>=
name|MINWORD
operator|&&
name|value
operator|<=
name|MAXWORD
condition|)
block|{
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYSHORT
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|toobig
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|minp
operator|=
operator|(
name|double
operator|*
operator|)
name|dminword
expr_stmt|;
name|maxp
operator|=
operator|(
name|double
operator|*
operator|)
name|dmaxword
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|cp
operator|->
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|x
operator|.
name|q
operator|.
name|word1
operator|=
name|rp
index|[
literal|0
index|]
expr_stmt|;
name|x
operator|.
name|q
operator|.
name|word2
operator|=
name|rp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|f
operator|.
name|sign
operator|==
literal|1
operator|&&
name|x
operator|.
name|f
operator|.
name|exp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|reserved
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|.
name|d
operator|>=
operator|*
name|minp
operator|&&
name|x
operator|.
name|d
operator|<=
operator|*
name|maxp
condition|)
block|{
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYSHORT
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
name|x
operator|.
name|d
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|toobig
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TYLOGICAL
case|:
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|compat1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
if|if
condition|(
operator|!
name|ftn66flag
operator|&&
name|badvalue
operator|==
literal|0
condition|)
block|{
name|badvalue
operator|=
literal|1
expr_stmt|;
name|warn
argument_list|(
name|compat2
argument_list|)
expr_stmt|;
block|}
case|case
name|TYHOLLERITH
case|:
name|shortp
operator|=
operator|(
name|short
operator|*
operator|)
name|grabbytes
argument_list|(
literal|2
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYSHORT
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
operator|*
name|shortp
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|shortp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYERROR
case|:
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|expptr
name|clong
parameter_list|(
name|cp
parameter_list|)
name|Constp
name|cp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|toobig
init|=
literal|"data value too large"
decl_stmt|;
specifier|static
name|char
modifier|*
name|reserved
init|=
literal|"reserved operand assigned to an integer"
decl_stmt|;
specifier|static
name|char
modifier|*
name|compat1
init|=
literal|"logical datum assigned to an integer variable"
decl_stmt|;
specifier|static
name|char
modifier|*
name|compat2
init|=
literal|"character datum assigned to an integer variable"
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
specifier|register
name|ftnint
modifier|*
name|longp
decl_stmt|;
specifier|register
name|long
modifier|*
name|rp
decl_stmt|;
specifier|register
name|double
modifier|*
name|minp
decl_stmt|;
specifier|register
name|double
modifier|*
name|maxp
decl_stmt|;
name|realvalue
name|x
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|vtype
condition|)
block|{
case|case
name|TYBITSTR
case|:
name|longp
operator|=
operator|(
name|ftnint
operator|*
operator|)
name|grabbits
argument_list|(
literal|4
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYLONG
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
operator|*
name|longp
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYSHORT
case|:
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYLONG
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
name|cp
operator|->
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|TYLONG
case|:
name|p
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|minp
operator|=
operator|(
name|double
operator|*
operator|)
name|dminint
expr_stmt|;
name|maxp
operator|=
operator|(
name|double
operator|*
operator|)
name|dmaxint
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|cp
operator|->
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|x
operator|.
name|q
operator|.
name|word1
operator|=
name|rp
index|[
literal|0
index|]
expr_stmt|;
name|x
operator|.
name|q
operator|.
name|word2
operator|=
name|rp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|f
operator|.
name|sign
operator|==
literal|1
operator|&&
name|x
operator|.
name|f
operator|.
name|exp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|reserved
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|.
name|d
operator|>=
operator|*
name|minp
operator|&&
name|x
operator|.
name|d
operator|<=
operator|*
name|maxp
condition|)
block|{
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYLONG
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
name|x
operator|.
name|d
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|toobig
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TYLOGICAL
case|:
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|compat1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
if|if
condition|(
operator|!
name|ftn66flag
operator|&&
name|badvalue
operator|==
literal|0
condition|)
block|{
name|badvalue
operator|=
literal|1
expr_stmt|;
name|warn
argument_list|(
name|compat2
argument_list|)
expr_stmt|;
block|}
case|case
name|TYHOLLERITH
case|:
name|longp
operator|=
operator|(
name|ftnint
operator|*
operator|)
name|grabbytes
argument_list|(
literal|4
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYLONG
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
operator|*
name|longp
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYERROR
case|:
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|expptr
name|creal
parameter_list|(
name|cp
parameter_list|)
name|Constp
name|cp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|toobig
init|=
literal|"data value too large"
decl_stmt|;
specifier|static
name|char
modifier|*
name|compat1
init|=
literal|"logical datum assigned to a real variable"
decl_stmt|;
specifier|static
name|char
modifier|*
name|compat2
init|=
literal|"character datum assigned to a real variable"
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
specifier|register
name|long
modifier|*
name|longp
decl_stmt|;
specifier|register
name|long
modifier|*
name|rp
decl_stmt|;
specifier|register
name|double
modifier|*
name|minp
decl_stmt|;
specifier|register
name|double
modifier|*
name|maxp
decl_stmt|;
name|realvalue
name|x
decl_stmt|;
name|float
name|y
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|vtype
condition|)
block|{
case|case
name|TYBITSTR
case|:
name|longp
operator|=
operator|(
name|long
operator|*
operator|)
name|grabbits
argument_list|(
literal|4
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYREAL
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
operator|*
name|longp
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYREAL
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|=
name|cp
operator|->
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|minp
operator|=
operator|(
name|double
operator|*
operator|)
name|dminreal
expr_stmt|;
name|maxp
operator|=
operator|(
name|double
operator|*
operator|)
name|dmaxreal
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|cp
operator|->
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|x
operator|.
name|q
operator|.
name|word1
operator|=
name|rp
index|[
literal|0
index|]
expr_stmt|;
name|x
operator|.
name|q
operator|.
name|word2
operator|=
name|rp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|f
operator|.
name|sign
operator|==
literal|1
operator|&&
name|x
operator|.
name|f
operator|.
name|exp
operator|==
literal|0
condition|)
block|{
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYREAL
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|x
operator|.
name|q
operator|.
name|word1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|.
name|d
operator|>=
operator|*
name|minp
operator|&&
name|x
operator|.
name|d
operator|<=
operator|*
name|maxp
condition|)
block|{
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYREAL
argument_list|)
expr_stmt|;
name|y
operator|=
name|x
operator|.
name|d
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|toobig
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TYLOGICAL
case|:
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|compat1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
if|if
condition|(
operator|!
name|ftn66flag
operator|&&
name|badvalue
operator|==
literal|0
condition|)
block|{
name|badvalue
operator|=
literal|1
expr_stmt|;
name|warn
argument_list|(
name|compat2
argument_list|)
expr_stmt|;
block|}
case|case
name|TYHOLLERITH
case|:
name|longp
operator|=
operator|(
name|long
operator|*
operator|)
name|grabbytes
argument_list|(
literal|4
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYREAL
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
operator|*
name|longp
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYERROR
case|:
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|expptr
name|cdreal
parameter_list|(
name|cp
parameter_list|)
name|Constp
name|cp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|compat1
init|=
literal|"logical datum assigned to a double precision variable"
decl_stmt|;
specifier|static
name|char
modifier|*
name|compat2
init|=
literal|"character datum assigned to a double precision variable"
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
specifier|register
name|long
modifier|*
name|longp
decl_stmt|;
specifier|register
name|long
modifier|*
name|rp
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|vtype
condition|)
block|{
case|case
name|TYBITSTR
case|:
name|longp
operator|=
operator|(
name|long
operator|*
operator|)
name|grabbits
argument_list|(
literal|8
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYDREAL
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|longp
index|[
literal|0
index|]
expr_stmt|;
name|rp
index|[
literal|1
index|]
operator|=
name|longp
index|[
literal|1
index|]
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYDREAL
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|=
name|cp
operator|->
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYDREAL
argument_list|)
expr_stmt|;
name|longp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|cp
operator|->
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|longp
index|[
literal|0
index|]
expr_stmt|;
name|rp
index|[
literal|1
index|]
operator|=
name|longp
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|TYLOGICAL
case|:
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|compat1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
if|if
condition|(
operator|!
name|ftn66flag
operator|&&
name|badvalue
operator|==
literal|0
condition|)
block|{
name|badvalue
operator|=
literal|1
expr_stmt|;
name|warn
argument_list|(
name|compat2
argument_list|)
expr_stmt|;
block|}
case|case
name|TYHOLLERITH
case|:
name|longp
operator|=
operator|(
name|long
operator|*
operator|)
name|grabbytes
argument_list|(
literal|8
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYDREAL
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|longp
index|[
literal|0
index|]
expr_stmt|;
name|rp
index|[
literal|1
index|]
operator|=
name|longp
index|[
literal|1
index|]
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYERROR
case|:
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|expptr
name|ccomplex
parameter_list|(
name|cp
parameter_list|)
name|Constp
name|cp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|toobig
init|=
literal|"data value too large"
decl_stmt|;
specifier|static
name|char
modifier|*
name|compat1
init|=
literal|"logical datum assigned to a complex variable"
decl_stmt|;
specifier|static
name|char
modifier|*
name|compat2
init|=
literal|"character datum assigned to a complex variable"
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
specifier|register
name|long
modifier|*
name|longp
decl_stmt|;
specifier|register
name|long
modifier|*
name|rp
decl_stmt|;
specifier|register
name|double
modifier|*
name|minp
decl_stmt|;
specifier|register
name|double
modifier|*
name|maxp
decl_stmt|;
name|realvalue
name|re
decl_stmt|,
name|im
decl_stmt|;
name|int
name|overflow
decl_stmt|;
name|float
name|x
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|vtype
condition|)
block|{
case|case
name|TYBITSTR
case|:
name|longp
operator|=
operator|(
name|long
operator|*
operator|)
name|grabbits
argument_list|(
literal|8
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYCOMPLEX
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|longp
index|[
literal|0
index|]
expr_stmt|;
name|rp
index|[
literal|2
index|]
operator|=
name|longp
index|[
literal|1
index|]
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYCOMPLEX
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|=
name|cp
operator|->
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|overflow
operator|=
literal|0
expr_stmt|;
name|minp
operator|=
operator|(
name|double
operator|*
operator|)
name|dminreal
expr_stmt|;
name|maxp
operator|=
operator|(
name|double
operator|*
operator|)
name|dmaxreal
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|cp
operator|->
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|re
operator|.
name|q
operator|.
name|word1
operator|=
name|rp
index|[
literal|0
index|]
expr_stmt|;
name|re
operator|.
name|q
operator|.
name|word2
operator|=
name|rp
index|[
literal|1
index|]
expr_stmt|;
name|im
operator|.
name|q
operator|.
name|word1
operator|=
name|rp
index|[
literal|2
index|]
expr_stmt|;
name|im
operator|.
name|q
operator|.
name|word2
operator|=
name|rp
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|re
operator|.
name|f
operator|.
name|sign
operator|==
literal|0
operator|||
name|re
operator|.
name|f
operator|.
name|exp
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|re
operator|.
name|d
operator|<
operator|*
name|minp
operator|||
name|re
operator|.
name|d
operator|>
operator|*
name|maxp
operator|)
operator|)
operator|||
operator|(
operator|(
name|im
operator|.
name|f
operator|.
name|sign
operator|==
literal|0
operator|||
name|re
operator|.
name|f
operator|.
name|exp
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|im
operator|.
name|d
operator|<
operator|*
name|minp
operator|||
name|re
operator|.
name|d
operator|>
operator|*
name|maxp
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|toobig
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYCOMPLEX
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|.
name|f
operator|.
name|sign
operator|==
literal|1
operator|&&
name|re
operator|.
name|f
operator|.
name|exp
operator|==
literal|0
condition|)
name|re
operator|.
name|q
operator|.
name|word2
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|x
operator|=
name|re
operator|.
name|d
expr_stmt|;
name|re
operator|.
name|d
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|im
operator|.
name|f
operator|.
name|sign
operator|==
literal|1
operator|&&
name|im
operator|.
name|f
operator|.
name|exp
operator|==
literal|0
condition|)
name|im
operator|.
name|q
operator|.
name|word2
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|x
operator|=
name|im
operator|.
name|d
expr_stmt|;
name|im
operator|.
name|d
operator|=
name|x
expr_stmt|;
block|}
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|re
operator|.
name|q
operator|.
name|word1
expr_stmt|;
name|rp
index|[
literal|1
index|]
operator|=
name|re
operator|.
name|q
operator|.
name|word2
expr_stmt|;
name|rp
index|[
literal|2
index|]
operator|=
name|im
operator|.
name|q
operator|.
name|word1
expr_stmt|;
name|rp
index|[
literal|3
index|]
operator|=
name|im
operator|.
name|q
operator|.
name|word2
expr_stmt|;
block|}
break|break;
case|case
name|TYLOGICAL
case|:
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|compat1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYCHAR
case|:
if|if
condition|(
operator|!
name|ftn66flag
operator|&&
name|badvalue
operator|==
literal|0
condition|)
block|{
name|badvalue
operator|=
literal|1
expr_stmt|;
name|warn
argument_list|(
name|compat2
argument_list|)
expr_stmt|;
block|}
case|case
name|TYHOLLERITH
case|:
name|longp
operator|=
operator|(
name|long
operator|*
operator|)
name|grabbytes
argument_list|(
literal|8
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYCOMPLEX
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|longp
index|[
literal|0
index|]
expr_stmt|;
name|rp
index|[
literal|2
index|]
operator|=
name|longp
index|[
literal|1
index|]
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYERROR
case|:
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|expptr
name|cdcomplex
parameter_list|(
name|cp
parameter_list|)
name|Constp
name|cp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|compat1
init|=
literal|"logical datum assigned to a complex variable"
decl_stmt|;
specifier|static
name|char
modifier|*
name|compat2
init|=
literal|"character datum assigned to a complex variable"
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
specifier|register
name|long
modifier|*
name|longp
decl_stmt|;
specifier|register
name|long
modifier|*
name|rp
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|vtype
condition|)
block|{
case|case
name|TYBITSTR
case|:
name|longp
operator|=
operator|(
name|long
operator|*
operator|)
name|grabbits
argument_list|(
literal|16
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYDCOMPLEX
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|longp
index|[
literal|0
index|]
expr_stmt|;
name|rp
index|[
literal|1
index|]
operator|=
name|longp
index|[
literal|1
index|]
expr_stmt|;
name|rp
index|[
literal|2
index|]
operator|=
name|longp
index|[
literal|2
index|]
expr_stmt|;
name|rp
index|[
literal|3
index|]
operator|=
name|longp
index|[
literal|3
index|]
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYDCOMPLEX
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|=
name|cp
operator|->
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYDCOMPLEX
argument_list|)
expr_stmt|;
name|longp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|cp
operator|->
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|longp
index|[
literal|0
index|]
expr_stmt|;
name|rp
index|[
literal|1
index|]
operator|=
name|longp
index|[
literal|1
index|]
expr_stmt|;
name|rp
index|[
literal|2
index|]
operator|=
name|longp
index|[
literal|2
index|]
expr_stmt|;
name|rp
index|[
literal|3
index|]
operator|=
name|longp
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|TYLOGICAL
case|:
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|compat1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
if|if
condition|(
operator|!
name|ftn66flag
operator|&&
name|badvalue
operator|==
literal|0
condition|)
block|{
name|badvalue
operator|=
literal|1
expr_stmt|;
name|warn
argument_list|(
name|compat2
argument_list|)
expr_stmt|;
block|}
case|case
name|TYHOLLERITH
case|:
name|longp
operator|=
operator|(
name|long
operator|*
operator|)
name|grabbytes
argument_list|(
literal|16
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|TYDCOMPLEX
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|longp
index|[
literal|0
index|]
expr_stmt|;
name|rp
index|[
literal|1
index|]
operator|=
name|longp
index|[
literal|1
index|]
expr_stmt|;
name|rp
index|[
literal|2
index|]
operator|=
name|longp
index|[
literal|2
index|]
expr_stmt|;
name|rp
index|[
literal|3
index|]
operator|=
name|longp
index|[
literal|3
index|]
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYERROR
case|:
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|expptr
name|clogical
parameter_list|(
name|cp
parameter_list|)
name|Constp
name|cp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|compat1
init|=
literal|"numeric datum assigned to a logical variable"
decl_stmt|;
specifier|static
name|char
modifier|*
name|compat2
init|=
literal|"character datum assigned to a logical variable"
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
specifier|register
name|long
modifier|*
name|longp
decl_stmt|;
specifier|register
name|short
modifier|*
name|shortp
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|size
operator|=
name|typesize
index|[
name|tylogical
index|]
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|vtype
condition|)
block|{
case|case
name|TYBITSTR
case|:
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|tylogical
argument_list|)
expr_stmt|;
if|if
condition|(
name|tylogical
operator|==
name|TYSHORT
condition|)
block|{
name|shortp
operator|=
operator|(
name|short
operator|*
operator|)
name|grabbits
argument_list|(
name|size
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
operator|(
name|int
operator|)
operator|*
name|shortp
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|shortp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|longp
operator|=
operator|(
name|long
operator|*
operator|)
name|grabbits
argument_list|(
name|size
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
operator|*
name|longp
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|compat1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
case|case
name|TYLOGICAL
case|:
name|p
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|vtype
operator|=
name|tylogical
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
if|if
condition|(
operator|!
name|ftn66flag
operator|&&
name|badvalue
operator|==
literal|0
condition|)
block|{
name|badvalue
operator|=
literal|1
expr_stmt|;
name|warn
argument_list|(
name|compat2
argument_list|)
expr_stmt|;
block|}
case|case
name|TYHOLLERITH
case|:
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|tylogical
argument_list|)
expr_stmt|;
if|if
condition|(
name|tylogical
operator|==
name|TYSHORT
condition|)
block|{
name|shortp
operator|=
operator|(
name|short
operator|*
operator|)
name|grabbytes
argument_list|(
name|size
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
operator|(
name|int
operator|)
operator|*
name|shortp
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|shortp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|longp
operator|=
operator|(
name|long
operator|*
operator|)
name|grabbytes
argument_list|(
literal|4
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
operator|*
name|longp
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|longp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYERROR
case|:
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|expptr
name|cchar
parameter_list|(
name|len
parameter_list|,
name|cp
parameter_list|)
name|int
name|len
decl_stmt|;
name|Constp
name|cp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|compat1
init|=
literal|"numeric datum assigned to a character variable"
decl_stmt|;
specifier|static
name|char
modifier|*
name|compat2
init|=
literal|"logical datum assigned to a character variable"
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|value
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|vtype
condition|)
block|{
case|case
name|TYBITSTR
case|:
name|value
operator|=
name|grabbits
argument_list|(
name|len
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkstrcon
argument_list|(
name|len
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|compat1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
case|case
name|TYLOGICAL
case|:
if|if
condition|(
name|badvalue
operator|<=
literal|1
condition|)
block|{
name|badvalue
operator|=
literal|2
expr_stmt|;
name|err
argument_list|(
name|compat2
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
case|case
name|TYHOLLERITH
case|:
name|value
operator|=
name|grabbytes
argument_list|(
name|len
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkstrcon
argument_list|(
name|len
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYERROR
case|:
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|expptr
name|convconst
parameter_list|(
name|type
parameter_list|,
name|len
parameter_list|,
name|constant
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
name|len
decl_stmt|;
name|Constp
name|constant
decl_stmt|;
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYSHORT
case|:
name|p
operator|=
name|cshort
argument_list|(
name|constant
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYLONG
case|:
name|p
operator|=
name|clong
argument_list|(
name|constant
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
name|p
operator|=
name|creal
argument_list|(
name|constant
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYDREAL
case|:
name|p
operator|=
name|cdreal
argument_list|(
name|constant
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
name|p
operator|=
name|ccomplex
argument_list|(
name|constant
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYDCOMPLEX
case|:
name|p
operator|=
name|cdcomplex
argument_list|(
name|constant
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYLOGICAL
case|:
name|p
operator|=
name|clogical
argument_list|(
name|constant
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
name|p
operator|=
name|cchar
argument_list|(
name|len
argument_list|,
name|constant
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYERROR
case|:
case|case
name|TYUNKNOWN
case|:
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
break|break;
default|default:
name|badtype
argument_list|(
literal|"convconst"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

end_unit

