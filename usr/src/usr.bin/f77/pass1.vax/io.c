begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)io.c	5.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * io.c  *  * Routines to generate code for I/O statements.  * Some corrections and improvements due to David Wasley, U. C. Berkeley  *  * University of Utah CS Dept modification history:  *  * $Header: io.c,v 5.3 86/03/04 17:45:33 donn Exp $  * $Log:	io.c,v $  * Revision 5.3  86/03/04  17:45:33  donn  * Change the order of length and offset code in startrw() -- always emit  * the memoffset first, since it may define a temporary which is used in  * the length expression.  *   * Revision 5.2  85/12/19  17:22:35  donn  * Don't permit more than one 'positional iocontrol' parameter unless we  * are doing a READ or a WRITE.  *   * Revision 5.1  85/08/10  03:47:42  donn  * 4.3 alpha  *   * Revision 2.4  85/02/23  21:09:02  donn  * Jerry Berkman's compiled format fixes move setfmt into a separate file.  *   * Revision 2.3  85/01/10  22:33:41  donn  * Added some strategic cpexpr()s to prevent memory management bugs.  *   * Revision 2.2  84/08/04  21:15:47  donn  * Removed code that creates extra statement labels, per Jerry Berkman's  * fixes to make ASSIGNs work right.  *   * Revision 2.1  84/07/19  12:03:33  donn  * Changed comment headers for UofU.  *   * Revision 1.2  84/02/26  06:35:57  donn  * Added Berkeley changes necessary for shortening offsets to data.  *   */
end_comment

begin_comment
comment|/* TEMPORARY */
end_comment

begin_define
define|#
directive|define
name|TYIOINT
value|TYLONG
end_define

begin_define
define|#
directive|define
name|SZIOINT
value|SZLONG
end_define

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_decl_stmt
name|LOCAL
name|char
name|ioroutine
index|[
name|XL
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|ioendlab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|ioerrlab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|endbit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|errbit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|jumplab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|skiplab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|ioformatted
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|statstruct
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|ftnint
name|blklen
decl_stmt|;
end_decl_stmt

begin_function_decl
name|LOCAL
name|offsetlist
modifier|*
name|mkiodata
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|UNFORMATTED
value|0
end_define

begin_define
define|#
directive|define
name|FORMATTED
value|1
end_define

begin_define
define|#
directive|define
name|LISTDIRECTED
value|2
end_define

begin_define
define|#
directive|define
name|NAMEDIRECTED
value|3
end_define

begin_define
define|#
directive|define
name|V
parameter_list|(
name|z
parameter_list|)
value|ioc[z].iocval
end_define

begin_define
define|#
directive|define
name|IOALL
value|07777
end_define

begin_macro
name|LOCAL
end_macro

begin_struct
struct|struct
name|Ioclist
block|{
name|char
modifier|*
name|iocname
decl_stmt|;
name|int
name|iotype
decl_stmt|;
name|expptr
name|iocval
decl_stmt|;
block|}
name|ioc
index|[ ]
init|=
block|{
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|"unit"
block|,
name|IOALL
block|}
block|,
block|{
literal|"fmt"
block|,
name|M
argument_list|(
name|IOREAD
argument_list|)
operator||
name|M
argument_list|(
argument|IOWRITE
argument_list|)
block|}
block|,
block|{
literal|"err"
block|,
name|IOALL
block|}
block|,
block|{
literal|"end"
block|,
name|M
argument_list|(
argument|IOREAD
argument_list|)
block|}
block|,
block|{
literal|"iostat"
block|,
name|IOALL
block|}
block|,
block|{
literal|"rec"
block|,
name|M
argument_list|(
name|IOREAD
argument_list|)
operator||
name|M
argument_list|(
argument|IOWRITE
argument_list|)
block|}
block|,
block|{
literal|"recl"
block|,
name|M
argument_list|(
name|IOOPEN
argument_list|)
operator||
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"file"
block|,
name|M
argument_list|(
name|IOOPEN
argument_list|)
operator||
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"status"
block|,
name|M
argument_list|(
name|IOOPEN
argument_list|)
operator||
name|M
argument_list|(
argument|IOCLOSE
argument_list|)
block|}
block|,
block|{
literal|"access"
block|,
name|M
argument_list|(
name|IOOPEN
argument_list|)
operator||
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"form"
block|,
name|M
argument_list|(
name|IOOPEN
argument_list|)
operator||
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"blank"
block|,
name|M
argument_list|(
name|IOOPEN
argument_list|)
operator||
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"exist"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"opened"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"number"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"named"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"name"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"sequential"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"direct"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"formatted"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"unformatted"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"nextrec"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NIOS
value|(sizeof(ioc)/sizeof(struct Ioclist) - 1)
end_define

begin_define
define|#
directive|define
name|MAXIO
value|SZFLAG + 10*SZIOINT + 15*SZADDR
end_define

begin_define
define|#
directive|define
name|IOSUNIT
value|1
end_define

begin_define
define|#
directive|define
name|IOSFMT
value|2
end_define

begin_define
define|#
directive|define
name|IOSERR
value|3
end_define

begin_define
define|#
directive|define
name|IOSEND
value|4
end_define

begin_define
define|#
directive|define
name|IOSIOSTAT
value|5
end_define

begin_define
define|#
directive|define
name|IOSREC
value|6
end_define

begin_define
define|#
directive|define
name|IOSRECL
value|7
end_define

begin_define
define|#
directive|define
name|IOSFILE
value|8
end_define

begin_define
define|#
directive|define
name|IOSSTATUS
value|9
end_define

begin_define
define|#
directive|define
name|IOSACCESS
value|10
end_define

begin_define
define|#
directive|define
name|IOSFORM
value|11
end_define

begin_define
define|#
directive|define
name|IOSBLANK
value|12
end_define

begin_define
define|#
directive|define
name|IOSEXISTS
value|13
end_define

begin_define
define|#
directive|define
name|IOSOPENED
value|14
end_define

begin_define
define|#
directive|define
name|IOSNUMBER
value|15
end_define

begin_define
define|#
directive|define
name|IOSNAMED
value|16
end_define

begin_define
define|#
directive|define
name|IOSNAME
value|17
end_define

begin_define
define|#
directive|define
name|IOSSEQUENTIAL
value|18
end_define

begin_define
define|#
directive|define
name|IOSDIRECT
value|19
end_define

begin_define
define|#
directive|define
name|IOSFORMATTED
value|20
end_define

begin_define
define|#
directive|define
name|IOSUNFORMATTED
value|21
end_define

begin_define
define|#
directive|define
name|IOSNEXTREC
value|22
end_define

begin_define
define|#
directive|define
name|IOSTP
value|V(IOSIOSTAT)
end_define

begin_comment
comment|/* offsets in generated structures */
end_comment

begin_define
define|#
directive|define
name|SZFLAG
value|SZIOINT
end_define

begin_comment
comment|/* offsets for external READ and WRITE statements */
end_comment

begin_define
define|#
directive|define
name|XERR
value|0
end_define

begin_define
define|#
directive|define
name|XUNIT
value|SZFLAG
end_define

begin_define
define|#
directive|define
name|XEND
value|SZFLAG + SZIOINT
end_define

begin_define
define|#
directive|define
name|XFMT
value|2*SZFLAG + SZIOINT
end_define

begin_define
define|#
directive|define
name|XREC
value|2*SZFLAG + SZIOINT + SZADDR
end_define

begin_define
define|#
directive|define
name|XRLEN
value|2*SZFLAG + 2*SZADDR
end_define

begin_define
define|#
directive|define
name|XRNUM
value|2*SZFLAG + 2*SZADDR + SZIOINT
end_define

begin_comment
comment|/* offsets for internal READ and WRITE statements */
end_comment

begin_define
define|#
directive|define
name|XIERR
value|0
end_define

begin_define
define|#
directive|define
name|XIUNIT
value|SZFLAG
end_define

begin_define
define|#
directive|define
name|XIEND
value|SZFLAG + SZADDR
end_define

begin_define
define|#
directive|define
name|XIFMT
value|2*SZFLAG + SZADDR
end_define

begin_define
define|#
directive|define
name|XIRLEN
value|2*SZFLAG + 2*SZADDR
end_define

begin_define
define|#
directive|define
name|XIRNUM
value|2*SZFLAG + 2*SZADDR + SZIOINT
end_define

begin_define
define|#
directive|define
name|XIREC
value|2*SZFLAG + 2*SZADDR + 2*SZIOINT
end_define

begin_comment
comment|/* offsets for OPEN statements */
end_comment

begin_define
define|#
directive|define
name|XFNAME
value|SZFLAG + SZIOINT
end_define

begin_define
define|#
directive|define
name|XFNAMELEN
value|SZFLAG + SZIOINT + SZADDR
end_define

begin_define
define|#
directive|define
name|XSTATUS
value|SZFLAG + 2*SZIOINT + SZADDR
end_define

begin_define
define|#
directive|define
name|XACCESS
value|SZFLAG + 2*SZIOINT + 2*SZADDR
end_define

begin_define
define|#
directive|define
name|XFORMATTED
value|SZFLAG + 2*SZIOINT + 3*SZADDR
end_define

begin_define
define|#
directive|define
name|XRECLEN
value|SZFLAG + 2*SZIOINT + 4*SZADDR
end_define

begin_define
define|#
directive|define
name|XBLANK
value|SZFLAG + 3*SZIOINT + 4*SZADDR
end_define

begin_comment
comment|/* offset for CLOSE statement */
end_comment

begin_define
define|#
directive|define
name|XCLSTATUS
value|SZFLAG + SZIOINT
end_define

begin_comment
comment|/* offsets for INQUIRE statement */
end_comment

begin_define
define|#
directive|define
name|XFILE
value|SZFLAG + SZIOINT
end_define

begin_define
define|#
directive|define
name|XFILELEN
value|SZFLAG + SZIOINT + SZADDR
end_define

begin_define
define|#
directive|define
name|XEXISTS
value|SZFLAG + 2*SZIOINT + SZADDR
end_define

begin_define
define|#
directive|define
name|XOPEN
value|SZFLAG + 2*SZIOINT + 2*SZADDR
end_define

begin_define
define|#
directive|define
name|XNUMBER
value|SZFLAG + 2*SZIOINT + 3*SZADDR
end_define

begin_define
define|#
directive|define
name|XNAMED
value|SZFLAG + 2*SZIOINT + 4*SZADDR
end_define

begin_define
define|#
directive|define
name|XNAME
value|SZFLAG + 2*SZIOINT + 5*SZADDR
end_define

begin_define
define|#
directive|define
name|XNAMELEN
value|SZFLAG + 2*SZIOINT + 6*SZADDR
end_define

begin_define
define|#
directive|define
name|XQACCESS
value|SZFLAG + 3*SZIOINT + 6*SZADDR
end_define

begin_define
define|#
directive|define
name|XQACCLEN
value|SZFLAG + 3*SZIOINT + 7*SZADDR
end_define

begin_define
define|#
directive|define
name|XSEQ
value|SZFLAG + 4*SZIOINT + 7*SZADDR
end_define

begin_define
define|#
directive|define
name|XSEQLEN
value|SZFLAG + 4*SZIOINT + 8*SZADDR
end_define

begin_define
define|#
directive|define
name|XDIRECT
value|SZFLAG + 5*SZIOINT + 8*SZADDR
end_define

begin_define
define|#
directive|define
name|XDIRLEN
value|SZFLAG + 5*SZIOINT + 9*SZADDR
end_define

begin_define
define|#
directive|define
name|XFORM
value|SZFLAG + 6*SZIOINT + 9*SZADDR
end_define

begin_define
define|#
directive|define
name|XFORMLEN
value|SZFLAG + 6*SZIOINT + 10*SZADDR
end_define

begin_define
define|#
directive|define
name|XFMTED
value|SZFLAG + 7*SZIOINT + 10*SZADDR
end_define

begin_define
define|#
directive|define
name|XFMTEDLEN
value|SZFLAG + 7*SZIOINT + 11*SZADDR
end_define

begin_define
define|#
directive|define
name|XUNFMT
value|SZFLAG + 8*SZIOINT + 11*SZADDR
end_define

begin_define
define|#
directive|define
name|XUNFMTLEN
value|SZFLAG + 8*SZIOINT + 12*SZADDR
end_define

begin_define
define|#
directive|define
name|XQRECL
value|SZFLAG + 9*SZIOINT + 12*SZADDR
end_define

begin_define
define|#
directive|define
name|XNEXTREC
value|SZFLAG + 9*SZIOINT + 13*SZADDR
end_define

begin_define
define|#
directive|define
name|XQBLANK
value|SZFLAG + 9*SZIOINT + 14*SZADDR
end_define

begin_define
define|#
directive|define
name|XQBLANKLEN
value|SZFLAG + 9*SZIOINT + 15*SZADDR
end_define

begin_escape
end_escape

begin_expr_stmt
name|fmtstmt
argument_list|(
name|lp
argument_list|)
specifier|register
expr|struct
name|Labelblock
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
block|{
name|execerr
argument_list|(
literal|"unlabeled format statement"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lp
operator|->
name|labtype
operator|==
name|LABUNKNOWN
condition|)
name|lp
operator|->
name|labtype
operator|=
name|LABFORMAT
expr_stmt|;
elseif|else
if|if
condition|(
name|lp
operator|->
name|labtype
operator|!=
name|LABFORMAT
condition|)
block|{
name|execerr
argument_list|(
literal|"bad format number"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|lp
operator|->
name|labelno
operator|)
return|;
block|}
end_block

begin_macro
name|startioctl
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|inioctl
operator|=
name|YES
expr_stmt|;
name|nioctl
operator|=
literal|0
expr_stmt|;
name|ioformatted
operator|=
name|UNFORMATTED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NIOS
condition|;
operator|++
name|i
control|)
name|V
argument_list|(
name|i
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|endioctl
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|expptr
name|p
decl_stmt|;
name|inioctl
operator|=
name|NO
expr_stmt|;
comment|/* set up for error recovery */
name|ioerrlab
operator|=
name|ioendlab
operator|=
name|skiplab
operator|=
name|jumplab
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSEND
argument_list|)
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|p
argument_list|)
condition|)
name|ioendlab
operator|=
name|execlab
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
argument_list|)
operator|->
name|labelno
expr_stmt|;
else|else
name|err
argument_list|(
literal|"bad end= clause"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSERR
argument_list|)
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|p
argument_list|)
condition|)
name|ioerrlab
operator|=
name|execlab
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
argument_list|)
operator|->
name|labelno
expr_stmt|;
else|else
name|err
argument_list|(
literal|"bad err= clause"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IOSTP
condition|)
if|if
condition|(
name|IOSTP
operator|->
name|tag
operator|!=
name|TADDR
operator|||
operator|!
name|ISINT
argument_list|(
name|IOSTP
operator|->
name|addrblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"iostat must be an integer variable"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|IOSTP
argument_list|)
expr_stmt|;
name|IOSTP
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iostmt
operator|==
name|IOREAD
condition|)
block|{
if|if
condition|(
name|IOSTP
condition|)
block|{
if|if
condition|(
name|ioerrlab
operator|&&
name|ioendlab
operator|&&
name|ioerrlab
operator|==
name|ioendlab
condition|)
name|jumplab
operator|=
name|ioerrlab
expr_stmt|;
else|else
name|skiplab
operator|=
name|jumplab
operator|=
name|newlabel
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioerrlab
operator|&&
name|ioendlab
operator|&&
name|ioerrlab
operator|!=
name|ioendlab
condition|)
block|{
name|IOSTP
operator|=
operator|(
name|expptr
operator|)
name|mktemp
argument_list|(
name|TYINT
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|skiplab
operator|=
name|jumplab
operator|=
name|newlabel
argument_list|()
expr_stmt|;
block|}
else|else
name|jumplab
operator|=
operator|(
name|ioerrlab
condition|?
name|ioerrlab
else|:
name|ioendlab
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|iostmt
operator|==
name|IOWRITE
condition|)
block|{
if|if
condition|(
name|IOSTP
operator|&&
operator|!
name|ioerrlab
condition|)
name|skiplab
operator|=
name|jumplab
operator|=
name|newlabel
argument_list|()
expr_stmt|;
else|else
name|jumplab
operator|=
name|ioerrlab
expr_stmt|;
block|}
else|else
name|jumplab
operator|=
name|ioerrlab
expr_stmt|;
name|endbit
operator|=
name|IOSTP
operator|!=
name|NULL
operator|||
name|ioendlab
operator|!=
literal|0
expr_stmt|;
comment|/* for use in startrw() */
name|errbit
operator|=
name|IOSTP
operator|!=
name|NULL
operator|||
name|ioerrlab
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|iostmt
operator|!=
name|IOREAD
operator|&&
name|iostmt
operator|!=
name|IOWRITE
condition|)
block|{
if|if
condition|(
name|ioblkp
operator|==
name|NULL
condition|)
name|ioblkp
operator|=
name|autovar
argument_list|(
operator|(
name|MAXIO
operator|+
name|SZIOINT
operator|-
literal|1
operator|)
operator|/
name|SZIOINT
argument_list|,
name|TYIOINT
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XERR
argument_list|,
name|ICON
argument_list|(
name|errbit
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|iostmt
condition|)
block|{
case|case
name|IOOPEN
case|:
name|dofopen
argument_list|()
expr_stmt|;
break|break;
case|case
name|IOCLOSE
case|:
name|dofclose
argument_list|()
expr_stmt|;
break|break;
case|case
name|IOINQUIRE
case|:
name|dofinquire
argument_list|()
expr_stmt|;
break|break;
case|case
name|IOBACKSPACE
case|:
name|dofmove
argument_list|(
literal|"f_back"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOREWIND
case|:
name|dofmove
argument_list|(
literal|"f_rew"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOENDFILE
case|:
name|dofmove
argument_list|(
literal|"f_end"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOREAD
case|:
case|case
name|IOWRITE
case|:
name|startrw
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fatali
argument_list|(
literal|"impossible iostmt %d"
argument_list|,
name|iostmt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NIOS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|!=
name|IOSIOSTAT
operator|&&
name|V
argument_list|(
name|i
argument_list|)
operator|!=
name|NULL
condition|)
name|frexpr
argument_list|(
name|V
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|iocname
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|found
decl_stmt|,
name|mask
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
name|M
argument_list|(
name|iostmt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NIOS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|toklen
operator|==
name|strlen
argument_list|(
name|ioc
index|[
name|i
index|]
operator|.
name|iocname
argument_list|)
operator|&&
name|eqn
argument_list|(
name|toklen
argument_list|,
name|token
argument_list|,
name|ioc
index|[
name|i
index|]
operator|.
name|iocname
argument_list|)
condition|)
if|if
condition|(
name|ioc
index|[
name|i
index|]
operator|.
name|iotype
operator|&
name|mask
condition|)
return|return
operator|(
name|i
operator|)
return|;
else|else
name|found
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|found
condition|)
name|errstr
argument_list|(
literal|"invalid control %s for statement"
argument_list|,
name|ioc
index|[
name|found
index|]
operator|.
name|iocname
argument_list|)
expr_stmt|;
else|else
name|errstr
argument_list|(
literal|"unknown iocontrol %s"
argument_list|,
name|varstr
argument_list|(
name|toklen
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|IOSBAD
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|ioclause
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|expptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|Ioclist
modifier|*
name|iocp
decl_stmt|;
operator|++
name|nioctl
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|IOSBAD
condition|)
return|return;
if|if
condition|(
name|n
operator|==
name|IOSPOSITIONAL
condition|)
block|{
if|if
condition|(
name|nioctl
operator|>
name|IOSFMT
operator|||
name|nioctl
operator|>
name|IOSUNIT
operator|&&
operator|!
operator|(
name|iostmt
operator|==
name|IOREAD
operator|||
name|iostmt
operator|==
name|IOWRITE
operator|)
condition|)
block|{
name|err
argument_list|(
literal|"illegal positional iocontrol"
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|nioctl
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|IOSUNIT
condition|)
name|p
operator|=
call|(
name|expptr
call|)
argument_list|(
name|iostmt
operator|==
name|IOREAD
condition|?
name|IOSTDIN
else|:
name|IOSTDOUT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|!=
name|IOSFMT
condition|)
block|{
name|err
argument_list|(
literal|"illegal * iocontrol"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|n
operator|==
name|IOSFMT
condition|)
name|ioformatted
operator|=
operator|(
name|p
operator|==
name|NULL
condition|?
name|LISTDIRECTED
else|:
name|FORMATTED
operator|)
expr_stmt|;
name|iocp
operator|=
operator|&
name|ioc
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|iocp
operator|->
name|iocval
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|IOSFMT
operator|&&
operator|(
name|n
operator|!=
name|IOSUNIT
operator|||
operator|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|!=
name|TYCHAR
operator|)
operator|)
condition|)
name|p
operator|=
name|fixtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|ISCONST
argument_list|(
name|p
argument_list|)
operator|&&
name|p
operator|->
name|constblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
name|p
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|iocp
operator|->
name|iocval
operator|=
name|p
expr_stmt|;
block|}
else|else
name|errstr
argument_list|(
literal|"iocontrol %s repeated"
argument_list|,
name|iocp
operator|->
name|iocname
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* io list item */
end_comment

begin_macro
name|doio
argument_list|(
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|chainp
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|expptr
name|call0
parameter_list|()
function_decl|;
if|if
condition|(
name|ioformatted
operator|==
name|NAMEDIRECTED
condition|)
block|{
if|if
condition|(
name|list
condition|)
name|err
argument_list|(
literal|"no I/O list allowed in NAMELIST read/write"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doiolist
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|ioroutine
index|[
literal|0
index|]
operator|=
literal|'e'
expr_stmt|;
name|putiocall
argument_list|(
name|call0
argument_list|(
name|TYINT
argument_list|,
name|ioroutine
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|LOCAL
name|doiolist
parameter_list|(
name|p0
parameter_list|)
name|chainp
name|p0
decl_stmt|;
block|{
name|chainp
name|p
decl_stmt|;
specifier|register
name|tagptr
name|q
decl_stmt|;
specifier|register
name|expptr
name|qe
decl_stmt|;
specifier|register
name|Namep
name|qn
decl_stmt|;
name|Addrp
name|tp
decl_stmt|,
name|mkscalar
argument_list|()
decl_stmt|;
name|int
name|range
decl_stmt|;
name|expptr
name|expr
decl_stmt|;
for|for
control|(
name|p
operator|=
name|p0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
name|q
operator|=
name|p
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TIMPLDO
condition|)
block|{
name|exdo
argument_list|(
name|range
operator|=
name|newlabel
argument_list|()
argument_list|,
name|q
operator|->
name|impldoblock
operator|.
name|impdospec
argument_list|)
expr_stmt|;
name|doiolist
argument_list|(
name|q
operator|->
name|impldoblock
operator|.
name|datalist
argument_list|)
expr_stmt|;
name|enddo
argument_list|(
name|range
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TPRIM
operator|&&
name|q
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
operator|&&
name|q
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vdim
operator|!=
name|NULL
condition|)
block|{
name|vardcl
argument_list|(
name|qn
operator|=
name|q
operator|->
name|primblock
operator|.
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|qn
operator|->
name|vdim
operator|->
name|nelt
condition|)
name|putio
argument_list|(
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|qn
operator|->
name|vdim
operator|->
name|nelt
argument_list|)
argument_list|)
argument_list|,
name|mkscalar
argument_list|(
name|qn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"attempt to i/o array of unknown size"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TPRIM
operator|&&
name|q
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
operator|&&
operator|(
name|qe
operator|=
operator|(
name|expptr
operator|)
name|memversion
argument_list|(
name|q
operator|->
name|primblock
operator|.
name|namep
argument_list|)
operator|)
condition|)
name|putio
argument_list|(
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|,
name|qe
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|qe
operator|=
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|q
argument_list|)
argument_list|)
operator|)
operator|->
name|tag
operator|==
name|TADDR
condition|)
name|putio
argument_list|(
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|,
name|qe
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qe
operator|->
name|headblock
operator|.
name|vtype
operator|!=
name|TYERROR
condition|)
block|{
if|if
condition|(
name|iostmt
operator|==
name|IOWRITE
condition|)
block|{
name|ftnint
name|lencat
parameter_list|()
function_decl|;
name|expptr
name|qvl
decl_stmt|;
name|qvl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ISCHAR
argument_list|(
name|qe
argument_list|)
condition|)
block|{
name|qvl
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|qe
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|tp
operator|=
name|mktemp
argument_list|(
name|qe
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|ICON
argument_list|(
name|lencat
argument_list|(
name|qe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tp
operator|=
name|mktemp
argument_list|(
name|qe
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|qe
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimflag
condition|)
block|{
name|expr
operator|=
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|qe
argument_list|)
expr_stmt|;
name|optbuff
argument_list|(
name|SKEQ
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|puteq
argument_list|(
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|qe
argument_list|)
expr_stmt|;
if|if
condition|(
name|qvl
condition|)
comment|/* put right length on block */
block|{
name|frexpr
argument_list|(
name|tp
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|tp
operator|->
name|vleng
operator|=
name|qvl
expr_stmt|;
block|}
name|putio
argument_list|(
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"non-left side in READ list"
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
name|frchain
argument_list|(
operator|&
name|p0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putio
parameter_list|(
name|nelt
parameter_list|,
name|addr
parameter_list|)
name|expptr
name|nelt
decl_stmt|;
specifier|register
name|expptr
name|addr
decl_stmt|;
block|{
name|int
name|type
decl_stmt|;
specifier|register
name|expptr
name|q
decl_stmt|;
name|type
operator|=
name|addr
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|ioformatted
operator|!=
name|LISTDIRECTED
operator|&&
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|nelt
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|ICON
argument_list|(
literal|2
argument_list|)
argument_list|,
name|nelt
argument_list|)
expr_stmt|;
name|type
operator|-=
operator|(
name|TYCOMPLEX
operator|-
name|TYREAL
operator|)
expr_stmt|;
block|}
comment|/* pass a length with every item.  for noncharacter data, fake one */
if|if
condition|(
name|type
operator|!=
name|TYCHAR
condition|)
block|{
name|addr
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|TYCHAR
expr_stmt|;
name|addr
operator|->
name|headblock
operator|.
name|vleng
operator|=
name|ICON
argument_list|(
name|typesize
index|[
name|type
index|]
argument_list|)
expr_stmt|;
block|}
name|nelt
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|TYLENG
argument_list|,
name|nelt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioformatted
operator|==
name|LISTDIRECTED
condition|)
name|q
operator|=
name|call3
argument_list|(
name|TYINT
argument_list|,
literal|"do_lio"
argument_list|,
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|ICON
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|nelt
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
name|call2
argument_list|(
name|TYINT
argument_list|,
operator|(
name|ioformatted
operator|==
name|FORMATTED
condition|?
literal|"do_fio"
else|:
literal|"do_uio"
operator|)
argument_list|,
name|nelt
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|putiocall
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|endio
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|skiplab
condition|)
block|{
if|if
condition|(
name|optimflag
condition|)
name|optbuff
argument_list|(
name|SKLABEL
argument_list|,
literal|0
argument_list|,
name|skiplab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|putlabel
argument_list|(
name|skiplab
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioendlab
condition|)
block|{
name|expptr
name|test
decl_stmt|;
name|test
operator|=
name|mkexpr
argument_list|(
name|OPGE
argument_list|,
name|cpexpr
argument_list|(
name|IOSTP
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimflag
condition|)
name|optbuff
argument_list|(
name|SKIOIFN
argument_list|,
name|test
argument_list|,
name|ioendlab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|putif
argument_list|(
name|test
argument_list|,
name|ioendlab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioerrlab
condition|)
block|{
name|expptr
name|test
decl_stmt|;
name|test
operator|=
name|mkexpr
argument_list|(
operator|(
operator|(
name|iostmt
operator|==
name|IOREAD
operator|||
name|iostmt
operator|==
name|IOWRITE
operator|)
condition|?
name|OPLE
else|:
name|OPEQ
operator|)
argument_list|,
name|cpexpr
argument_list|(
name|IOSTP
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimflag
condition|)
name|optbuff
argument_list|(
name|SKIOIFN
argument_list|,
name|test
argument_list|,
name|ioerrlab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|putif
argument_list|(
name|test
argument_list|,
name|ioerrlab
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IOSTP
condition|)
name|frexpr
argument_list|(
name|IOSTP
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|LOCAL
name|putiocall
parameter_list|(
name|q
parameter_list|)
specifier|register
name|expptr
name|q
decl_stmt|;
block|{
if|if
condition|(
name|IOSTP
condition|)
block|{
name|q
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|TYINT
expr_stmt|;
name|q
operator|=
name|fixexpr
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|IOSTP
argument_list|)
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|jumplab
condition|)
if|if
condition|(
name|optimflag
condition|)
name|optbuff
argument_list|(
name|SKIOIFN
argument_list|,
name|mkexpr
argument_list|(
name|OPEQ
argument_list|,
name|q
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|jumplab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|putif
argument_list|(
name|mkexpr
argument_list|(
name|OPEQ
argument_list|,
name|q
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|jumplab
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optimflag
condition|)
name|optbuff
argument_list|(
name|SKEQ
argument_list|,
name|q
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|putexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|startrw
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|Addrp
name|unitp
decl_stmt|,
name|fmtp
decl_stmt|,
name|recp
decl_stmt|,
name|tioblkp
decl_stmt|;
specifier|register
name|expptr
name|nump
decl_stmt|;
specifier|register
name|ioblock
modifier|*
name|t
decl_stmt|;
name|Addrp
name|mkscalar
parameter_list|()
function_decl|;
name|expptr
name|mkaddcon
parameter_list|()
function_decl|;
name|int
name|k
decl_stmt|;
name|flag
name|intfile
decl_stmt|,
name|sequential
decl_stmt|,
name|ok
decl_stmt|,
name|varfmt
decl_stmt|;
comment|/* First look at all the parameters and determine what is to be done */
name|ok
operator|=
name|YES
expr_stmt|;
name|statstruct
operator|=
name|YES
expr_stmt|;
name|intfile
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSUNIT
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|unitp
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
name|intfile
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TPRIM
operator|&&
name|p
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
operator|&&
operator|(
name|np
operator|=
name|p
operator|->
name|primblock
operator|.
name|namep
operator|)
operator|->
name|vdim
operator|!=
name|NULL
condition|)
block|{
name|vardcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vdim
operator|->
name|nelt
condition|)
block|{
name|nump
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|np
operator|->
name|vdim
operator|->
name|nelt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|nump
argument_list|)
condition|)
name|statstruct
operator|=
name|NO
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"attempt to use internal unit array of unknown size"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
name|nump
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|unitp
operator|=
name|mkscalar
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nump
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|unitp
operator|=
operator|(
name|Addrp
operator|)
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isstatic
argument_list|(
name|unitp
argument_list|)
condition|)
name|statstruct
operator|=
name|NO
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"bad unit specifier type"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
block|}
else|else
block|{
name|err
argument_list|(
literal|"bad unit specifier"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
name|sequential
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSREC
argument_list|)
condition|)
if|if
condition|(
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|recp
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sequential
operator|=
name|NO
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"bad REC= clause"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
else|else
name|recp
operator|=
name|NULL
expr_stmt|;
name|varfmt
operator|=
name|YES
expr_stmt|;
name|fmtp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSFMT
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TPRIM
operator|&&
name|p
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|primblock
operator|.
name|namep
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vclass
operator|==
name|CLNAMELIST
condition|)
block|{
name|ioformatted
operator|=
name|NAMEDIRECTED
expr_stmt|;
name|fmtp
operator|=
operator|(
name|Addrp
operator|)
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|endfmt
goto|;
block|}
name|vardcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vdim
condition|)
block|{
if|if
condition|(
operator|!
name|ONEOF
argument_list|(
name|np
operator|->
name|vstg
argument_list|,
name|MSKSTATIC
argument_list|)
condition|)
name|statstruct
operator|=
name|NO
expr_stmt|;
name|fmtp
operator|=
name|mkscalar
argument_list|(
name|np
argument_list|)
expr_stmt|;
goto|goto
name|endfmt
goto|;
block|}
if|if
condition|(
name|ISINT
argument_list|(
name|np
operator|->
name|vtype
argument_list|)
condition|)
comment|/* ASSIGNed label */
block|{
name|statstruct
operator|=
name|NO
expr_stmt|;
name|varfmt
operator|=
name|NO
expr_stmt|;
name|fmtp
operator|=
operator|(
name|Addrp
operator|)
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|endfmt
goto|;
block|}
block|}
name|p
operator|=
name|V
argument_list|(
name|IOSFMT
argument_list|)
operator|=
name|fixtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TCONST
condition|)
name|p
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isstatic
argument_list|(
name|p
argument_list|)
condition|)
name|statstruct
operator|=
name|NO
expr_stmt|;
name|fmtp
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISICON
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|fmtstmt
argument_list|(
name|mklabel
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|fmtp
operator|=
operator|(
name|Addrp
operator|)
name|mkaddcon
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|varfmt
operator|=
name|NO
expr_stmt|;
block|}
else|else
name|ioformatted
operator|=
name|UNFORMATTED
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"bad format descriptor"
argument_list|)
expr_stmt|;
name|ioformatted
operator|=
name|UNFORMATTED
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
block|}
else|else
name|fmtp
operator|=
name|NULL
expr_stmt|;
name|endfmt
label|:
if|if
condition|(
name|intfile
operator|&&
name|ioformatted
operator|==
name|UNFORMATTED
condition|)
block|{
name|err
argument_list|(
literal|"unformatted internal I/O not allowed"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sequential
operator|&&
name|ioformatted
operator|==
name|LISTDIRECTED
condition|)
block|{
name|err
argument_list|(
literal|"direct list-directed I/O not allowed"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sequential
operator|&&
name|ioformatted
operator|==
name|NAMEDIRECTED
condition|)
block|{
name|err
argument_list|(
literal|"direct namelist I/O not allowed"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
return|return;
if|if
condition|(
name|optimflag
operator|&&
name|ISCONST
argument_list|(
name|fmtp
argument_list|)
condition|)
name|fmtp
operator|=
name|putconst
argument_list|(
operator|(
name|expptr
operator|)
name|fmtp
argument_list|)
expr_stmt|;
comment|/*    Now put out the I/O structure, statically if all the clauses    are constants, dynamically otherwise */
if|if
condition|(
name|statstruct
condition|)
block|{
name|tioblkp
operator|=
name|ioblkp
expr_stmt|;
name|ioblkp
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|ioblkp
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|ioblkp
operator|->
name|vtype
operator|=
name|TYIOINT
expr_stmt|;
name|ioblkp
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
name|ioblkp
operator|->
name|vstg
operator|=
name|STGINIT
expr_stmt|;
name|ioblkp
operator|->
name|memno
operator|=
operator|++
name|lastvarno
expr_stmt|;
name|ioblkp
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|blklen
operator|=
operator|(
name|intfile
condition|?
name|XIREC
operator|+
name|SZIOINT
else|:
operator|(
name|sequential
condition|?
name|XFMT
operator|+
name|SZADDR
else|:
name|XRNUM
operator|+
name|SZIOINT
operator|)
operator|)
expr_stmt|;
name|t
operator|=
name|ALLOC
argument_list|(
name|IoBlock
argument_list|)
expr_stmt|;
name|t
operator|->
name|blkno
operator|=
name|ioblkp
operator|->
name|memno
expr_stmt|;
name|t
operator|->
name|len
operator|=
name|blklen
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|iodata
expr_stmt|;
name|iodata
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioblkp
operator|==
name|NULL
condition|)
name|ioblkp
operator|=
name|autovar
argument_list|(
operator|(
name|MAXIO
operator|+
name|SZIOINT
operator|-
literal|1
operator|)
operator|/
name|SZIOINT
argument_list|,
name|TYIOINT
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XERR
argument_list|,
name|ICON
argument_list|(
name|errbit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iostmt
operator|==
name|IOREAD
condition|)
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
operator|(
name|intfile
condition|?
name|XIEND
else|:
name|XEND
operator|)
argument_list|,
name|ICON
argument_list|(
name|endbit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intfile
condition|)
block|{
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XIRNUM
argument_list|,
name|nump
argument_list|)
expr_stmt|;
name|ioseta
argument_list|(
name|XIUNIT
argument_list|,
name|cpexpr
argument_list|(
name|unitp
argument_list|)
argument_list|)
expr_stmt|;
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XIRLEN
argument_list|,
name|cpexpr
argument_list|(
name|unitp
operator|->
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|unitp
argument_list|)
expr_stmt|;
block|}
else|else
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XUNIT
argument_list|,
operator|(
name|expptr
operator|)
name|unitp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recp
condition|)
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
operator|(
name|intfile
condition|?
name|XIREC
else|:
name|XREC
operator|)
argument_list|,
operator|(
name|expptr
operator|)
name|recp
argument_list|)
expr_stmt|;
if|if
condition|(
name|varfmt
condition|)
name|ioseta
argument_list|(
name|intfile
condition|?
name|XIFMT
else|:
name|XFMT
argument_list|,
name|fmtp
argument_list|)
expr_stmt|;
else|else
name|ioset
argument_list|(
name|TYADDR
argument_list|,
name|intfile
condition|?
name|XIFMT
else|:
name|XFMT
argument_list|,
operator|(
name|expptr
operator|)
name|fmtp
argument_list|)
expr_stmt|;
name|ioroutine
index|[
literal|0
index|]
operator|=
literal|'s'
expr_stmt|;
name|ioroutine
index|[
literal|1
index|]
operator|=
literal|'_'
expr_stmt|;
name|ioroutine
index|[
literal|2
index|]
operator|=
operator|(
name|iostmt
operator|==
name|IOREAD
condition|?
literal|'r'
else|:
literal|'w'
operator|)
expr_stmt|;
name|ioroutine
index|[
literal|3
index|]
operator|=
operator|(
name|sequential
condition|?
literal|'s'
else|:
literal|'d'
operator|)
expr_stmt|;
name|ioroutine
index|[
literal|4
index|]
operator|=
literal|"ufln"
index|[
name|ioformatted
index|]
expr_stmt|;
name|ioroutine
index|[
literal|5
index|]
operator|=
operator|(
name|intfile
condition|?
literal|'i'
else|:
literal|'e'
operator|)
expr_stmt|;
name|ioroutine
index|[
literal|6
index|]
operator|=
literal|'\0'
expr_stmt|;
name|putiocall
argument_list|(
name|call1
argument_list|(
name|TYINT
argument_list|,
name|ioroutine
argument_list|,
name|cpexpr
argument_list|(
name|ioblkp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|statstruct
condition|)
block|{
name|frexpr
argument_list|(
name|ioblkp
argument_list|)
expr_stmt|;
name|ioblkp
operator|=
name|tioblkp
expr_stmt|;
name|statstruct
operator|=
name|NO
expr_stmt|;
block|}
block|}
end_block

begin_function
name|LOCAL
name|dofopen
parameter_list|()
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|V
argument_list|(
name|IOSUNIT
argument_list|)
operator|)
operator|&&
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XUNIT
argument_list|,
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"bad unit in open"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|V
argument_list|(
name|IOSFILE
argument_list|)
operator|)
condition|)
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XFNAMELEN
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"bad file in open"
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|XFNAME
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSRECL
argument_list|)
condition|)
if|if
condition|(
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XRECLEN
argument_list|,
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"bad recl"
argument_list|)
expr_stmt|;
else|else
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XRECLEN
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|XSTATUS
argument_list|,
name|V
argument_list|(
name|IOSSTATUS
argument_list|)
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|XACCESS
argument_list|,
name|V
argument_list|(
name|IOSACCESS
argument_list|)
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|XFORMATTED
argument_list|,
name|V
argument_list|(
name|IOSFORM
argument_list|)
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|XBLANK
argument_list|,
name|V
argument_list|(
name|IOSBLANK
argument_list|)
argument_list|)
expr_stmt|;
name|putiocall
argument_list|(
name|call1
argument_list|(
name|TYINT
argument_list|,
literal|"f_open"
argument_list|,
name|cpexpr
argument_list|(
name|ioblkp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|dofclose
parameter_list|()
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|V
argument_list|(
name|IOSUNIT
argument_list|)
operator|)
operator|&&
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XUNIT
argument_list|,
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|XCLSTATUS
argument_list|,
name|V
argument_list|(
name|IOSSTATUS
argument_list|)
argument_list|)
expr_stmt|;
name|putiocall
argument_list|(
name|call1
argument_list|(
name|TYINT
argument_list|,
literal|"f_clos"
argument_list|,
name|cpexpr
argument_list|(
name|ioblkp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"bad unit in close statement"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|dofinquire
parameter_list|()
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSUNIT
argument_list|)
condition|)
block|{
if|if
condition|(
name|V
argument_list|(
name|IOSFILE
argument_list|)
condition|)
name|err
argument_list|(
literal|"inquire by unit or by file, not both"
argument_list|)
expr_stmt|;
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XUNIT
argument_list|,
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|V
argument_list|(
name|IOSFILE
argument_list|)
condition|)
name|err
argument_list|(
literal|"must inquire by unit or by file"
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSFILE
argument_list|,
name|XFILE
argument_list|,
name|XFILELEN
argument_list|)
expr_stmt|;
name|iosetip
argument_list|(
name|IOSEXISTS
argument_list|,
name|XEXISTS
argument_list|)
expr_stmt|;
name|iosetip
argument_list|(
name|IOSOPENED
argument_list|,
name|XOPEN
argument_list|)
expr_stmt|;
name|iosetip
argument_list|(
name|IOSNUMBER
argument_list|,
name|XNUMBER
argument_list|)
expr_stmt|;
name|iosetip
argument_list|(
name|IOSNAMED
argument_list|,
name|XNAMED
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSNAME
argument_list|,
name|XNAME
argument_list|,
name|XNAMELEN
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSACCESS
argument_list|,
name|XQACCESS
argument_list|,
name|XQACCLEN
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSSEQUENTIAL
argument_list|,
name|XSEQ
argument_list|,
name|XSEQLEN
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSDIRECT
argument_list|,
name|XDIRECT
argument_list|,
name|XDIRLEN
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSFORM
argument_list|,
name|XFORM
argument_list|,
name|XFORMLEN
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSFORMATTED
argument_list|,
name|XFMTED
argument_list|,
name|XFMTEDLEN
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSUNFORMATTED
argument_list|,
name|XUNFMT
argument_list|,
name|XUNFMTLEN
argument_list|)
expr_stmt|;
name|iosetip
argument_list|(
name|IOSRECL
argument_list|,
name|XQRECL
argument_list|)
expr_stmt|;
name|iosetip
argument_list|(
name|IOSNEXTREC
argument_list|,
name|XNEXTREC
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSBLANK
argument_list|,
name|XQBLANK
argument_list|,
name|XQBLANKLEN
argument_list|)
expr_stmt|;
name|putiocall
argument_list|(
name|call1
argument_list|(
name|TYINT
argument_list|,
literal|"f_inqu"
argument_list|,
name|cpexpr
argument_list|(
name|ioblkp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|dofmove
parameter_list|(
name|subname
parameter_list|)
name|char
modifier|*
name|subname
decl_stmt|;
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|V
argument_list|(
name|IOSUNIT
argument_list|)
operator|)
operator|&&
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XUNIT
argument_list|,
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|putiocall
argument_list|(
name|call1
argument_list|(
name|TYINT
argument_list|,
name|subname
argument_list|,
name|cpexpr
argument_list|(
name|ioblkp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"bad unit in I/O motion statement"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|ioset
parameter_list|(
name|type
parameter_list|,
name|offset
parameter_list|,
name|p
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
name|offset
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badoffset
init|=
literal|"badoffset in ioset"
decl_stmt|;
specifier|register
name|Addrp
name|q
decl_stmt|;
specifier|register
name|offsetlist
modifier|*
name|op
decl_stmt|;
name|q
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|ioblkp
argument_list|)
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|type
expr_stmt|;
name|q
operator|->
name|memoffset
operator|=
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|q
operator|->
name|memoffset
argument_list|,
name|ICON
argument_list|(
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|statstruct
operator|&&
name|ISCONST
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|q
operator|->
name|memoffset
argument_list|)
condition|)
name|fatal
argument_list|(
name|badoffset
argument_list|)
expr_stmt|;
name|op
operator|=
name|mkiodata
argument_list|(
name|q
operator|->
name|memno
argument_list|,
name|q
operator|->
name|memoffset
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
argument_list|,
name|blklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|tag
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|badoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYADDR
condition|)
block|{
name|op
operator|->
name|tag
operator|=
name|NDLABEL
expr_stmt|;
name|op
operator|->
name|val
operator|.
name|label
operator|=
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
block|}
else|else
block|{
name|op
operator|->
name|tag
operator|=
name|NDDATA
expr_stmt|;
name|op
operator|->
name|val
operator|.
name|cp
operator|=
operator|(
name|Constp
operator|)
name|convconst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optimflag
condition|)
name|optbuff
argument_list|(
name|SKEQ
argument_list|,
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|q
argument_list|,
name|p
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|puteq
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|LOCAL
name|iosetc
parameter_list|(
name|offset
parameter_list|,
name|p
parameter_list|)
name|int
name|offset
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|ioset
argument_list|(
name|TYADDR
argument_list|,
name|offset
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
name|ioset
argument_list|(
name|TYADDR
argument_list|,
name|offset
argument_list|,
name|addrof
argument_list|(
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"non-character control clause"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|ioseta
parameter_list|(
name|offset
parameter_list|,
name|p
parameter_list|)
name|int
name|offset
decl_stmt|;
specifier|register
name|Addrp
name|p
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badoffset
init|=
literal|"bad offset in ioseta"
decl_stmt|;
name|int
name|blkno
decl_stmt|;
specifier|register
name|offsetlist
modifier|*
name|op
decl_stmt|;
if|if
condition|(
name|statstruct
condition|)
block|{
name|blkno
operator|=
name|ioblkp
operator|->
name|memno
expr_stmt|;
name|op
operator|=
name|mkiodata
argument_list|(
name|blkno
argument_list|,
name|offset
argument_list|,
name|blklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|tag
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|badoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|op
operator|->
name|tag
operator|=
name|NDNULL
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TADDR
condition|)
block|{
name|op
operator|->
name|tag
operator|=
name|NDADDR
expr_stmt|;
name|op
operator|->
name|val
operator|.
name|addr
operator|.
name|stg
operator|=
name|p
operator|->
name|vstg
expr_stmt|;
name|op
operator|->
name|val
operator|.
name|addr
operator|.
name|memno
operator|=
name|p
operator|->
name|memno
expr_stmt|;
name|op
operator|->
name|val
operator|.
name|addr
operator|.
name|offset
operator|=
name|p
operator|->
name|memoffset
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
block|}
else|else
name|badtag
argument_list|(
literal|"ioseta"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
name|ioset
argument_list|(
name|TYADDR
argument_list|,
name|offset
argument_list|,
name|p
condition|?
name|addrof
argument_list|(
name|p
argument_list|)
else|:
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|LOCAL
name|iosetip
parameter_list|(
name|i
parameter_list|,
name|offset
parameter_list|)
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|i
argument_list|)
condition|)
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|ONEOF
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|vtype
argument_list|,
name|M
argument_list|(
name|TYLONG
argument_list|)
operator||
name|M
argument_list|(
name|TYLOGICAL
argument_list|)
argument_list|)
condition|)
name|ioset
argument_list|(
name|TYADDR
argument_list|,
name|offset
argument_list|,
name|addrof
argument_list|(
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|errstr
argument_list|(
literal|"impossible inquire parameter %s"
argument_list|,
name|ioc
index|[
name|i
index|]
operator|.
name|iocname
argument_list|)
expr_stmt|;
else|else
name|ioset
argument_list|(
name|TYADDR
argument_list|,
name|offset
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|iosetlc
parameter_list|(
name|i
parameter_list|,
name|offp
parameter_list|,
name|offl
parameter_list|)
name|int
name|i
decl_stmt|,
name|offp
decl_stmt|,
name|offl
decl_stmt|;
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|V
argument_list|(
name|i
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|offl
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|offp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|offsetlist
modifier|*
name|mkiodata
parameter_list|(
name|blkno
parameter_list|,
name|offset
parameter_list|,
name|len
parameter_list|)
name|int
name|blkno
decl_stmt|;
name|ftnint
name|offset
decl_stmt|;
name|ftnint
name|len
decl_stmt|;
block|{
specifier|register
name|offsetlist
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|ioblock
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|found
decl_stmt|;
name|found
operator|=
name|NO
expr_stmt|;
name|t
operator|=
name|iodata
expr_stmt|;
while|while
condition|(
name|found
operator|==
name|NO
operator|&&
name|t
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|blkno
operator|==
name|blkno
condition|)
name|found
operator|=
name|YES
expr_stmt|;
else|else
name|t
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
name|NO
condition|)
block|{
name|t
operator|=
name|ALLOC
argument_list|(
name|IoBlock
argument_list|)
expr_stmt|;
name|t
operator|->
name|blkno
operator|=
name|blkno
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|iodata
expr_stmt|;
name|iodata
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|t
operator|->
name|len
condition|)
name|t
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|t
operator|->
name|olist
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|ALLOC
argument_list|(
name|OffsetList
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|t
operator|->
name|olist
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|->
name|offset
operator|==
name|offset
condition|)
return|return
operator|(
name|p
operator|)
return|;
elseif|else
if|if
condition|(
name|p
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|next
operator|->
name|offset
operator|<=
name|offset
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
block|{
name|q
operator|=
name|ALLOC
argument_list|(
name|OffsetList
argument_list|)
expr_stmt|;
name|q
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
block|}
block|}
end_function

begin_macro
name|outiodata
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
modifier|*
name|varfmt
init|=
literal|"v.%d:\n"
decl_stmt|;
specifier|register
name|ioblock
modifier|*
name|p
decl_stmt|;
specifier|register
name|ioblock
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|iodata
operator|==
name|NULL
condition|)
return|return;
name|p
operator|=
name|iodata
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|pralign
argument_list|(
name|ALIDOUBLE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|initfile
argument_list|,
name|varfmt
argument_list|,
name|p
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|outolist
argument_list|(
name|p
operator|->
name|olist
argument_list|,
name|p
operator|->
name|len
argument_list|)
expr_stmt|;
name|t
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
name|iodata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_block

begin_function
name|LOCAL
name|outolist
parameter_list|(
name|op
parameter_list|,
name|len
parameter_list|)
specifier|register
name|offsetlist
modifier|*
name|op
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|overlap
init|=
literal|"overlapping i/o fields in outolist"
decl_stmt|;
specifier|static
name|char
modifier|*
name|toolong
init|=
literal|"offset too large in outolist"
decl_stmt|;
specifier|register
name|offsetlist
modifier|*
name|t
decl_stmt|;
specifier|register
name|ftnint
name|clen
decl_stmt|;
specifier|register
name|Constp
name|cp
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
name|clen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|op
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|clen
operator|>
name|op
operator|->
name|offset
condition|)
name|fatal
argument_list|(
name|overlap
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|<
name|op
operator|->
name|offset
condition|)
block|{
name|prspace
argument_list|(
name|op
operator|->
name|offset
operator|-
name|clen
argument_list|)
expr_stmt|;
name|clen
operator|=
name|op
operator|->
name|offset
expr_stmt|;
block|}
switch|switch
condition|(
name|op
operator|->
name|tag
condition|)
block|{
default|default:
name|badtag
argument_list|(
literal|"outolist"
argument_list|,
name|op
operator|->
name|tag
argument_list|)
expr_stmt|;
case|case
name|NDDATA
case|:
name|cp
operator|=
name|op
operator|->
name|val
operator|.
name|cp
expr_stmt|;
name|type
operator|=
name|cp
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TYIOINT
condition|)
name|badtype
argument_list|(
literal|"outolist"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|prconi
argument_list|(
name|initfile
argument_list|,
name|type
argument_list|,
name|cp
operator|->
name|constant
operator|.
name|ci
argument_list|)
expr_stmt|;
name|clen
operator|+=
name|typesize
index|[
name|type
index|]
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NDLABEL
case|:
name|prcona
argument_list|(
name|initfile
argument_list|,
name|op
operator|->
name|val
operator|.
name|label
argument_list|)
expr_stmt|;
name|clen
operator|+=
name|typesize
index|[
name|TYADDR
index|]
expr_stmt|;
break|break;
case|case
name|NDADDR
case|:
name|praddr
argument_list|(
name|initfile
argument_list|,
name|op
operator|->
name|val
operator|.
name|addr
operator|.
name|stg
argument_list|,
name|op
operator|->
name|val
operator|.
name|addr
operator|.
name|memno
argument_list|,
name|op
operator|->
name|val
operator|.
name|addr
operator|.
name|offset
argument_list|)
expr_stmt|;
name|clen
operator|+=
name|typesize
index|[
name|TYADDR
index|]
expr_stmt|;
break|break;
case|case
name|NDNULL
case|:
name|praddr
argument_list|(
name|initfile
argument_list|,
name|STGNULL
argument_list|,
literal|0
argument_list|,
operator|(
name|ftnint
operator|)
literal|0
argument_list|)
expr_stmt|;
name|clen
operator|+=
name|typesize
index|[
name|TYADDR
index|]
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|op
expr_stmt|;
name|op
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|>
name|len
condition|)
name|fatal
argument_list|(
name|toolong
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|<
name|len
condition|)
name|prspace
argument_list|(
name|len
operator|-
name|clen
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

