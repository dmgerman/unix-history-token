begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)proc.c	5.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * proc.c  *  * Routines for handling procedures, f77 compiler, pass 1.  *  * University of Utah CS Dept modification history:  *  * $Header: proc.c,v 5.3 85/09/30 23:21:07 donn Exp $  * $Log:	proc.c,v $  * Revision 5.3  85/09/30  23:21:07  donn  * Print space with prspace() in outlocvars() so that alignment is preserved.  *   * Revision 5.2  85/08/10  05:03:34  donn  * Support for NAMELIST i/o from Jerry Berkman.  *   * Revision 5.1  85/08/10  03:49:14  donn  * 4.3 alpha  *   * Revision 3.11  85/06/04  03:45:29  donn  * Changed retval() to recognize that a function declaration might have  * bombed out earlier, leaving an error node behind...  *   * Revision 3.10  85/03/08  23:13:06  donn  * Finally figured out why function calls and array elements are not legal  * dummy array dimension declarator elements.  Hacked safedim() to stop 'em.  *   * Revision 3.9  85/02/02  00:26:10  donn  * Removed the call to entrystab() in enddcl() -- this was redundant (it was  * also done in startproc()) and confusing to dbx to boot.  *   * Revision 3.8  85/01/14  04:21:53  donn  * Added changes to implement Jerry's '-q' option.  *   * Revision 3.7  85/01/11  21:10:35  donn  * In conjunction with other changes to implement SAVE statements, function  * nameblocks were changed to make it appear that they are 'saved' too --  * this arranges things so that function return values are forced out of  * register before a return.  *   * Revision 3.6  84/12/10  19:27:20  donn  * comblock() signals an illegal common block name by returning a null pointer,  * but incomm() wasn't able to handle it, leading to core dumps.  I put the  * fix in incomm() to pick up null common blocks.  *   * Revision 3.5  84/11/21  20:33:31  donn  * It seems that I/O elements are treated as character strings so that their  * length can be passed to the I/O routines...  Unfortunately the compiler  * assumes that no temporaries can be of type CHARACTER and casually tosses  * length and type info away when removing TEMP blocks.  This has been fixed...  *   * Revision 3.4  84/11/05  22:19:30  donn  * Fixed a silly bug in the last fix.  *   * Revision 3.3  84/10/29  08:15:23  donn  * Added code to check the type and shape of subscript declarations,  * per Jerry Berkman's suggestion.  *   * Revision 3.2  84/10/29  05:52:07  donn  * Added change suggested by Jerry Berkman to report an error when an array  * is redimensioned.  *   * Revision 3.1  84/10/13  02:12:31  donn  * Merged Jerry Berkman's version into mine.  *   * Revision 2.1  84/07/19  12:04:09  donn  * Changed comment headers for UofU.  *   * Revision 1.6  84/07/19  11:32:15  donn  * Incorporated fix to setbound() to detect backward array subscript limits.  * The fix is by Bob Corbett, donated by Jerry Berkman.  *   * Revision 1.5  84/07/18  18:25:50  donn  * Fixed problem with doentry() where a placeholder for a return value  * was not allocated if the first entry didn't require one but a later  * entry did.  *   * Revision 1.4  84/05/24  20:52:09  donn  * Installed firewall #ifdef around the code that recycles stack temporaries,  * since it seems to be broken and lacks a good fix for the time being.  *   * Revision 1.3  84/04/16  09:50:46  donn  * Fixed mkargtemp() so that it only passes back a copy of a temporary, keeping  * the original for its own use.  This fixes a set of bugs that are caused by  * elements in the argtemplist getting stomped on.  *   * Revision 1.2  84/02/28  21:12:58  donn  * Added Berkeley changes for subroutine call argument temporaries fix.  *   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SDB
end_ifdef

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|N_SO
end_ifndef

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|flag
name|namesflag
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|SizeList
block|{
name|struct
name|SizeList
modifier|*
name|next
decl_stmt|;
name|ftnint
name|size
decl_stmt|;
name|struct
name|VarList
modifier|*
name|vars
decl_stmt|;
block|}
name|sizelist
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|VarList
block|{
name|struct
name|VarList
modifier|*
name|next
decl_stmt|;
name|Namep
name|np
decl_stmt|;
name|struct
name|Equivblock
modifier|*
name|ep
decl_stmt|;
block|}
name|varlist
typedef|;
end_typedef

begin_decl_stmt
name|LOCAL
name|sizelist
modifier|*
name|varsizes
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* start a new procedure */
end_comment

begin_macro
name|newproc
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|parstate
operator|!=
name|OUTSIDE
condition|)
block|{
name|execerr
argument_list|(
literal|"missing end statement"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|endproc
argument_list|()
expr_stmt|;
block|}
name|parstate
operator|=
name|INSIDE
expr_stmt|;
name|procclass
operator|=
name|CLMAIN
expr_stmt|;
comment|/* default */
block|}
end_block

begin_comment
comment|/* end of procedure. generate variables, epilogs, and prologs */
end_comment

begin_macro
name|endproc
argument_list|()
end_macro

begin_block
block|{
name|struct
name|Labelblock
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|parstate
operator|<
name|INDATA
condition|)
name|enddcl
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctlstack
operator|>=
name|ctls
condition|)
name|err
argument_list|(
literal|"DO loop or BLOCK IF not closed"
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|labeltab
init|;
name|lp
operator|<
name|labtabend
condition|;
operator|++
name|lp
control|)
if|if
condition|(
name|lp
operator|->
name|stateno
operator|!=
literal|0
operator|&&
name|lp
operator|->
name|labdefined
operator|==
name|NO
condition|)
name|errstr
argument_list|(
literal|"missing statement number %s"
argument_list|,
name|convic
argument_list|(
name|lp
operator|->
name|stateno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimflag
condition|)
name|optimize
argument_list|()
expr_stmt|;
name|outiodata
argument_list|()
expr_stmt|;
name|epicode
argument_list|()
expr_stmt|;
name|procode
argument_list|()
expr_stmt|;
name|donmlist
argument_list|()
expr_stmt|;
name|dobss
argument_list|()
expr_stmt|;
if|#
directive|if
name|FAMILY
operator|==
name|PCC
name|putbracket
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|fixlwm
argument_list|()
expr_stmt|;
name|procinit
argument_list|()
expr_stmt|;
comment|/* clean up for next procedure */
block|}
end_block

begin_comment
comment|/* End of declaration section of procedure.  Allocate storage. */
end_comment

begin_macro
name|enddcl
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|Entrypoint
modifier|*
name|ep
decl_stmt|;
name|parstate
operator|=
name|INEXEC
expr_stmt|;
name|docommon
argument_list|()
expr_stmt|;
name|doequiv
argument_list|()
expr_stmt|;
name|docomleng
argument_list|()
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|entries
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|entnextp
control|)
block|{
name|doentry
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ROUTINES CALLED WHEN ENCOUNTERING ENTRY POINTS */
end_comment

begin_comment
comment|/* Main program or Block data */
end_comment

begin_macro
name|startproc
argument_list|(
argument|prgname
argument_list|,
argument|class
argument_list|)
end_macro

begin_decl_stmt
name|Namep
name|prgname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|Extsym
modifier|*
name|progname
decl_stmt|;
specifier|register
name|struct
name|Entrypoint
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|prgname
condition|)
name|procname
operator|=
name|prgname
operator|->
name|varname
expr_stmt|;
if|if
condition|(
name|namesflag
operator|==
name|YES
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"   %s"
argument_list|,
operator|(
name|class
operator|==
name|CLMAIN
condition|?
literal|"MAIN"
else|:
literal|"BLOCK DATA"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prgname
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" %s"
argument_list|,
name|varstr
argument_list|(
name|XL
argument_list|,
name|procname
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prgname
condition|)
name|progname
operator|=
name|newentry
argument_list|(
name|prgname
argument_list|)
expr_stmt|;
else|else
name|progname
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Entrypoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLMAIN
condition|)
name|puthead
argument_list|(
literal|"MAIN_"
argument_list|,
name|CLMAIN
argument_list|)
expr_stmt|;
else|else
name|puthead
argument_list|(
name|CNULL
argument_list|,
name|CLBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLMAIN
condition|)
name|newentry
argument_list|(
name|mkname
argument_list|(
literal|5
argument_list|,
literal|"MAIN"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|entryname
operator|=
name|progname
expr_stmt|;
name|p
operator|->
name|entrylabel
operator|=
name|newlabel
argument_list|()
expr_stmt|;
name|entries
operator|=
name|p
expr_stmt|;
name|procclass
operator|=
name|class
expr_stmt|;
name|retlabel
operator|=
name|newlabel
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
block|{
name|entrystab
argument_list|(
name|p
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* subroutine or function statement */
end_comment

begin_function
name|struct
name|Extsym
modifier|*
name|newentry
parameter_list|(
name|v
parameter_list|)
specifier|register
name|Namep
name|v
decl_stmt|;
block|{
specifier|register
name|struct
name|Extsym
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|mkext
argument_list|(
name|varunder
argument_list|(
name|VL
argument_list|,
name|v
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|extinit
operator|||
operator|!
name|ONEOF
argument_list|(
name|p
operator|->
name|extstg
argument_list|,
name|M
argument_list|(
name|STGUNKNOWN
argument_list|)
operator||
name|M
argument_list|(
name|STGEXT
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|dclerr
argument_list|(
literal|"invalid entry name"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|dclerr
argument_list|(
literal|"external name already used"
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|v
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|v
operator|->
name|vprocclass
operator|=
name|PTHISPROC
expr_stmt|;
name|v
operator|->
name|vclass
operator|=
name|CLPROC
expr_stmt|;
name|p
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
name|p
operator|->
name|extinit
operator|=
name|YES
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|entrypt
argument_list|(
argument|class
argument_list|,
argument|type
argument_list|,
argument|length
argument_list|,
argument|entname
argument_list|,
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ftnint
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Namep
name|entname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|chainp
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|Extsym
modifier|*
name|entry
decl_stmt|;
specifier|register
name|Namep
name|q
decl_stmt|;
specifier|register
name|struct
name|Entrypoint
modifier|*
name|p
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|namesflag
operator|==
name|YES
condition|)
block|{
if|if
condition|(
name|class
operator|==
name|CLENTRY
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"       entry "
argument_list|)
expr_stmt|;
if|if
condition|(
name|entname
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"   %s"
argument_list|,
name|varstr
argument_list|(
name|XL
argument_list|,
name|entname
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entname
operator|->
name|vclass
operator|==
name|CLPARAM
condition|)
block|{
name|errstr
argument_list|(
literal|"entry name %s used in 'parameter' statement"
argument_list|,
name|varstr
argument_list|(
name|XL
argument_list|,
name|entname
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|type
operator|==
name|TYSUBR
operator|)
operator|||
operator|(
name|class
operator|==
name|CLENTRY
operator|&&
name|proctype
operator|==
name|TYSUBR
operator|)
operator|)
operator|&&
operator|(
name|entname
operator|->
name|vtype
operator|!=
name|TYUNKNOWN
operator|&&
name|entname
operator|->
name|vtype
operator|!=
name|TYSUBR
operator|)
condition|)
block|{
name|errstr
argument_list|(
literal|"subroutine entry %s previously declared"
argument_list|,
name|varstr
argument_list|(
name|XL
argument_list|,
name|entname
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|entname
operator|->
name|vstg
operator|!=
name|STGEXT
operator|&&
name|entname
operator|->
name|vstg
operator|!=
name|STGUNKNOWN
operator|)
operator|||
operator|(
name|entname
operator|->
name|vdim
operator|!=
name|NULL
operator|)
condition|)
block|{
name|errstr
argument_list|(
literal|"subroutine or function entry %s previously declared"
argument_list|,
name|varstr
argument_list|(
name|XL
argument_list|,
name|entname
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|class
operator|==
name|CLPROC
operator|||
name|class
operator|==
name|CLENTRY
operator|)
operator|&&
name|type
operator|!=
name|TYSUBR
condition|)
comment|/* arrange to save function return values */
name|entname
operator|->
name|vsave
operator|=
name|YES
expr_stmt|;
name|entry
operator|=
name|newentry
argument_list|(
name|entname
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|CLENTRY
condition|)
name|puthead
argument_list|(
name|varstr
argument_list|(
name|XL
argument_list|,
name|procname
operator|=
name|entry
operator|->
name|extname
argument_list|)
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkname
argument_list|(
name|VL
argument_list|,
name|nounder
argument_list|(
name|XL
argument_list|,
name|entry
operator|->
name|extname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|lengtype
argument_list|(
name|type
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|)
operator|)
operator|!=
name|TYCHAR
condition|)
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLPROC
condition|)
block|{
name|procclass
operator|=
name|CLPROC
expr_stmt|;
name|proctype
operator|=
name|type
expr_stmt|;
name|procleng
operator|=
name|length
expr_stmt|;
name|retlabel
operator|=
name|newlabel
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYSUBR
condition|)
name|ret0label
operator|=
name|newlabel
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|ALLOC
argument_list|(
name|Entrypoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
condition|)
comment|/* put new block at end of entries list */
block|{
for|for
control|(
name|ep
operator|=
name|entries
init|;
name|ep
operator|->
name|entnextp
condition|;
name|ep
operator|=
name|ep
operator|->
name|entnextp
control|)
empty_stmt|;
name|ep
operator|->
name|entnextp
operator|=
name|p
expr_stmt|;
block|}
else|else
name|entries
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|entryname
operator|=
name|entry
expr_stmt|;
name|p
operator|->
name|arglist
operator|=
name|args
expr_stmt|;
name|p
operator|->
name|entrylabel
operator|=
name|newlabel
argument_list|()
expr_stmt|;
name|p
operator|->
name|enamep
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLENTRY
condition|)
block|{
name|class
operator|=
name|CLPROC
expr_stmt|;
if|if
condition|(
name|proctype
operator|==
name|TYSUBR
condition|)
name|type
operator|=
name|TYSUBR
expr_stmt|;
block|}
name|q
operator|->
name|vclass
operator|=
name|class
expr_stmt|;
name|q
operator|->
name|vprocclass
operator|=
name|PTHISPROC
expr_stmt|;
name|settype
argument_list|(
name|q
argument_list|,
name|type
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|)
expr_stmt|;
comment|/* hold all initial entry points till end of declarations */
if|if
condition|(
name|parstate
operator|>=
name|INDATA
condition|)
block|{
name|doentry
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
block|{
comment|/* may need to preserve CLENTRY here */
name|entrystab
argument_list|(
name|p
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* generate epilogs */
end_comment

begin_function
name|LOCAL
name|epicode
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|procclass
operator|==
name|CLPROC
condition|)
block|{
if|if
condition|(
name|proctype
operator|==
name|TYSUBR
condition|)
block|{
name|putlabel
argument_list|(
name|ret0label
argument_list|)
expr_stmt|;
if|if
condition|(
name|substars
condition|)
name|putforce
argument_list|(
name|TYINT
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|putlabel
argument_list|(
name|retlabel
argument_list|)
expr_stmt|;
name|goret
argument_list|(
name|TYSUBR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putlabel
argument_list|(
name|retlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|multitype
condition|)
block|{
name|typeaddr
operator|=
name|autovar
argument_list|(
literal|1
argument_list|,
name|TYADDR
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|putbranch
argument_list|(
name|cpexpr
argument_list|(
name|typeaddr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTYPES
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|rtvlabel
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|putlabel
argument_list|(
name|rtvlabel
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|retval
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|retval
argument_list|(
name|proctype
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|procclass
operator|!=
name|CLBLOCK
condition|)
block|{
name|putlabel
argument_list|(
name|retlabel
argument_list|)
expr_stmt|;
name|goret
argument_list|(
name|TYSUBR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* generate code to return value of type  t */
end_comment

begin_function
name|LOCAL
name|retval
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
specifier|register
name|Addrp
name|p
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|TYCHAR
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
break|break;
case|case
name|TYLOGICAL
case|:
name|t
operator|=
name|tylogical
expr_stmt|;
case|case
name|TYADDR
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
name|p
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|retslot
argument_list|)
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
name|putforce
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|p
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|retslot
argument_list|)
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
name|putforce
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYERROR
case|:
return|return;
comment|/* someone else already complained */
default|default:
name|badtype
argument_list|(
literal|"retval"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|goret
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate extra argument array if needed. Generate prologs. */
end_comment

begin_function
name|LOCAL
name|procode
parameter_list|()
block|{
specifier|register
name|struct
name|Entrypoint
modifier|*
name|p
decl_stmt|;
name|Addrp
name|argvec
decl_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|GCOS
name|argvec
operator|=
name|autovar
argument_list|(
name|lastargslot
operator|/
name|SZADDR
argument_list|,
name|TYADDR
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|lastargslot
operator|>
literal|0
operator|&&
name|nentry
operator|>
literal|1
condition|)
if|#
directive|if
name|TARGET
operator|==
name|VAX
name|argvec
operator|=
name|autovar
argument_list|(
literal|1
operator|+
name|lastargslot
operator|/
name|SZADDR
argument_list|,
name|TYADDR
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|argvec
operator|=
name|autovar
argument_list|(
name|lastargslot
operator|/
name|SZADDR
argument_list|,
name|TYADDR
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|argvec
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|PDP11
comment|/* for the optimizer */
if|if
condition|(
name|fudgelabel
condition|)
name|putlabel
argument_list|(
name|fudgelabel
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|entries
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|entnextp
control|)
name|prolog
argument_list|(
name|p
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
if|#
directive|if
name|FAMILY
operator|==
name|PCC
name|putrbrack
argument_list|(
name|procno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|prendproc
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*    manipulate argument lists (allocate argument slot positions)  * keep track of return types and labels  */
end_comment

begin_function
name|LOCAL
name|doentry
parameter_list|(
name|ep
parameter_list|)
name|struct
name|Entrypoint
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
name|chainp
name|p
decl_stmt|;
specifier|register
name|Namep
name|q
decl_stmt|;
name|Addrp
name|mkarg
parameter_list|()
function_decl|;
operator|++
name|nentry
expr_stmt|;
if|if
condition|(
name|procclass
operator|==
name|CLMAIN
condition|)
block|{
if|if
condition|(
name|optimflag
condition|)
name|optbuff
argument_list|(
name|SKLABEL
argument_list|,
literal|0
argument_list|,
name|ep
operator|->
name|entrylabel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|putlabel
argument_list|(
name|ep
operator|->
name|entrylabel
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|procclass
operator|==
name|CLBLOCK
condition|)
return|return;
name|impldcl
argument_list|(
name|np
operator|=
name|mkname
argument_list|(
name|VL
argument_list|,
name|nounder
argument_list|(
name|XL
argument_list|,
name|ep
operator|->
name|entryname
operator|->
name|extname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|np
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|proctype
operator|==
name|TYUNKNOWN
condition|)
if|if
condition|(
operator|(
name|proctype
operator|=
name|type
operator|)
operator|==
name|TYCHAR
condition|)
name|procleng
operator|=
operator|(
name|np
operator|->
name|vleng
condition|?
name|np
operator|->
name|vleng
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
else|:
call|(
name|ftnint
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|proctype
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|TYCHAR
condition|)
name|err
argument_list|(
literal|"noncharacter entry of character function"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|np
operator|->
name|vleng
condition|?
name|np
operator|->
name|vleng
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
else|:
call|(
name|ftnint
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|procleng
condition|)
name|err
argument_list|(
literal|"mismatched character entry lengths"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|err
argument_list|(
literal|"character entry of noncharacter function"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|proctype
condition|)
name|multitype
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|rtvlabel
index|[
name|type
index|]
operator|==
literal|0
condition|)
name|rtvlabel
index|[
name|type
index|]
operator|=
name|newlabel
argument_list|()
expr_stmt|;
name|ep
operator|->
name|typelabel
operator|=
name|rtvlabel
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|chslot
operator|<
literal|0
condition|)
block|{
name|chslot
operator|=
name|nextarg
argument_list|(
name|TYADDR
argument_list|)
expr_stmt|;
name|chlgslot
operator|=
name|nextarg
argument_list|(
name|TYLENG
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|vstg
operator|=
name|STGARG
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|chslot
expr_stmt|;
if|if
condition|(
name|procleng
operator|<
literal|0
condition|)
name|np
operator|->
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|mkarg
argument_list|(
name|TYLENG
argument_list|,
name|chlgslot
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|np
operator|->
name|vstg
operator|=
name|STGARG
expr_stmt|;
if|if
condition|(
name|cxslot
operator|<
literal|0
condition|)
name|cxslot
operator|=
name|nextarg
argument_list|(
name|TYADDR
argument_list|)
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|cxslot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|TYSUBR
condition|)
block|{
if|if
condition|(
name|retslot
operator|==
name|NULL
condition|)
name|retslot
operator|=
name|autovar
argument_list|(
literal|1
argument_list|,
name|TYDREAL
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|np
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|np
operator|->
name|voffset
operator|=
name|retslot
operator|->
name|memoffset
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|ep
operator|->
name|arglist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|q
operator|=
call|(
name|Namep
call|)
argument_list|(
name|p
operator|->
name|datap
argument_list|)
operator|)
operator|->
name|vdcldone
operator|)
condition|)
name|q
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|nextarg
argument_list|(
name|TYADDR
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ep
operator|->
name|arglist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|q
operator|=
call|(
name|Namep
call|)
argument_list|(
name|p
operator|->
name|datap
argument_list|)
operator|)
operator|->
name|vdcldone
operator|)
condition|)
block|{
name|impldcl
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|vdcldone
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|vleng
operator|==
name|NULL
condition|)
comment|/* character*(*) */
name|q
operator|->
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|mkarg
argument_list|(
name|TYLENG
argument_list|,
name|nextarg
argument_list|(
name|TYLENG
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nentry
operator|==
literal|1
condition|)
name|nextarg
argument_list|(
name|TYLENG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|vclass
operator|==
name|CLPROC
operator|&&
name|nentry
operator|==
literal|1
condition|)
name|nextarg
argument_list|(
name|TYLENG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
block|{
name|namestab
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|optimflag
condition|)
name|optbuff
argument_list|(
name|SKLABEL
argument_list|,
literal|0
argument_list|,
name|ep
operator|->
name|entrylabel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|putlabel
argument_list|(
name|ep
operator|->
name|entrylabel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|nextarg
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|int
name|k
decl_stmt|;
name|k
operator|=
name|lastargslot
expr_stmt|;
name|lastargslot
operator|+=
name|typesize
index|[
name|type
index|]
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* generate variable references */
end_comment

begin_function
name|LOCAL
name|dobss
parameter_list|()
block|{
specifier|register
name|struct
name|Hashentry
modifier|*
name|p
decl_stmt|;
specifier|register
name|Namep
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|align
decl_stmt|;
name|ftnint
name|leng
decl_stmt|,
name|iarrl
decl_stmt|;
name|char
modifier|*
name|memname
parameter_list|()
function_decl|;
name|int
name|qstg
decl_stmt|,
name|qclass
decl_stmt|,
name|qtype
decl_stmt|;
name|pruse
argument_list|(
name|asmfile
argument_list|,
name|USEBSS
argument_list|)
expr_stmt|;
name|varsizes
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|hashtab
init|;
name|p
operator|<
name|lasthash
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|q
operator|=
name|p
operator|->
name|varp
condition|)
block|{
name|qstg
operator|=
name|q
operator|->
name|vstg
expr_stmt|;
name|qtype
operator|=
name|q
operator|->
name|vtype
expr_stmt|;
name|qclass
operator|=
name|q
operator|->
name|vclass
expr_stmt|;
if|if
condition|(
operator|(
name|qclass
operator|==
name|CLUNKNOWN
operator|&&
name|qstg
operator|!=
name|STGARG
operator|)
operator|||
operator|(
name|qclass
operator|==
name|CLVAR
operator|&&
name|qstg
operator|==
name|STGUNKNOWN
operator|)
condition|)
name|warn1
argument_list|(
literal|"local variable %s never used"
argument_list|,
name|varstr
argument_list|(
name|VL
argument_list|,
name|q
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qclass
operator|==
name|CLPROC
operator|&&
name|q
operator|->
name|vprocclass
operator|==
name|PEXTERNAL
operator|&&
name|qstg
operator|!=
name|STGARG
condition|)
name|mkext
argument_list|(
name|varunder
argument_list|(
name|VL
argument_list|,
name|q
operator|->
name|varname
argument_list|)
argument_list|)
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
if|if
condition|(
name|qclass
operator|==
name|CLVAR
operator|&&
name|qstg
operator|==
name|STGBSS
condition|)
block|{
if|if
condition|(
name|SMALLVAR
argument_list|(
name|q
operator|->
name|varsize
argument_list|)
condition|)
block|{
name|enlist
argument_list|(
name|q
operator|->
name|varsize
argument_list|,
name|q
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|inlcomm
operator|=
name|NO
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|q
operator|->
name|init
operator|==
name|NO
condition|)
block|{
name|preven
argument_list|(
name|ALIDOUBLE
argument_list|)
expr_stmt|;
name|prlocvar
argument_list|(
name|memname
argument_list|(
name|qstg
argument_list|,
name|q
operator|->
name|vardesc
operator|.
name|varno
argument_list|)
argument_list|,
name|q
operator|->
name|varsize
argument_list|)
expr_stmt|;
name|q
operator|->
name|inlcomm
operator|=
name|YES
expr_stmt|;
block|}
else|else
name|prlocdata
argument_list|(
name|memname
argument_list|(
name|qstg
argument_list|,
name|q
operator|->
name|vardesc
operator|.
name|varno
argument_list|)
argument_list|,
name|q
operator|->
name|varsize
argument_list|,
name|q
operator|->
name|vtype
argument_list|,
name|q
operator|->
name|initoffset
argument_list|,
operator|&
operator|(
name|q
operator|->
name|inlcomm
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|qclass
operator|==
name|CLVAR
operator|&&
name|qstg
operator|!=
name|STGARG
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|vdim
operator|&&
operator|!
name|ISICON
argument_list|(
name|q
operator|->
name|vdim
operator|->
name|nelt
argument_list|)
condition|)
name|dclerr
argument_list|(
literal|"adjustable dimension on non-argument"
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|TYCHAR
operator|&&
operator|(
name|q
operator|->
name|vleng
operator|==
name|NULL
operator|||
operator|!
name|ISICON
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
operator|)
condition|)
name|dclerr
argument_list|(
literal|"adjustable leng on nonargument"
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|chkdim
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nequiv
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|leng
operator|=
name|eqvclass
index|[
name|i
index|]
operator|.
name|eqvleng
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SMALLVAR
argument_list|(
name|leng
argument_list|)
condition|)
name|enlist
argument_list|(
name|leng
argument_list|,
name|NULL
argument_list|,
name|eqvclass
operator|+
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eqvclass
index|[
name|i
index|]
operator|.
name|init
operator|==
name|NO
condition|)
block|{
name|preven
argument_list|(
name|ALIDOUBLE
argument_list|)
expr_stmt|;
name|prlocvar
argument_list|(
name|memname
argument_list|(
name|STGEQUIV
argument_list|,
name|i
argument_list|)
argument_list|,
name|leng
argument_list|)
expr_stmt|;
name|eqvclass
index|[
name|i
index|]
operator|.
name|inlcomm
operator|=
name|YES
expr_stmt|;
block|}
else|else
name|prlocdata
argument_list|(
name|memname
argument_list|(
name|STGEQUIV
argument_list|,
name|i
argument_list|)
argument_list|,
name|leng
argument_list|,
name|TYDREAL
argument_list|,
name|eqvclass
index|[
name|i
index|]
operator|.
name|initoffset
argument_list|,
operator|&
operator|(
name|eqvclass
index|[
name|i
index|]
operator|.
name|inlcomm
operator|)
argument_list|)
expr_stmt|;
block|}
name|outlocvars
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
block|{
for|for
control|(
name|p
operator|=
name|hashtab
init|;
name|p
operator|<
name|lasthash
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|q
operator|=
name|p
operator|->
name|varp
condition|)
block|{
name|qstg
operator|=
name|q
operator|->
name|vstg
expr_stmt|;
name|qclass
operator|=
name|q
operator|->
name|vclass
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|qclass
argument_list|,
name|M
argument_list|(
name|CLVAR
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ONEOF
argument_list|(
name|qstg
argument_list|,
name|M
argument_list|(
name|STGCOMMON
argument_list|)
operator||
name|M
argument_list|(
name|STGARG
argument_list|)
argument_list|)
condition|)
name|namestab
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|close
argument_list|(
name|vdatafile
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|vchkfile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|vdatafname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|vchkfname
argument_list|)
expr_stmt|;
name|vdatahwm
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_macro
name|donmlist
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|Hashentry
modifier|*
name|p
decl_stmt|;
specifier|register
name|Namep
name|q
decl_stmt|;
name|pruse
argument_list|(
name|asmfile
argument_list|,
name|USEINIT
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|hashtab
init|;
name|p
operator|<
name|lasthash
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|(
name|q
operator|=
name|p
operator|->
name|varp
operator|)
operator|&&
name|q
operator|->
name|vclass
operator|==
name|CLNAMELIST
condition|)
name|namelist
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|doext
argument_list|()
end_macro

begin_block
block|{
name|struct
name|Extsym
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|extsymtab
init|;
name|p
operator|<
name|nextext
condition|;
operator|++
name|p
control|)
name|prext
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|ftnint
name|iarrlen
parameter_list|(
name|q
parameter_list|)
specifier|register
name|Namep
name|q
decl_stmt|;
block|{
name|ftnint
name|leng
decl_stmt|;
name|leng
operator|=
name|typesize
index|[
name|q
operator|->
name|vtype
index|]
expr_stmt|;
if|if
condition|(
name|leng
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|q
operator|->
name|vdim
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|q
operator|->
name|vdim
operator|->
name|nelt
argument_list|)
condition|)
name|leng
operator|*=
name|q
operator|->
name|vdim
operator|->
name|nelt
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|q
operator|->
name|vleng
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
condition|)
name|leng
operator|*=
name|q
operator|->
name|vleng
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|leng
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This routine creates a static block representing the namelist.    An equivalent declaration of the structure produced is: 	struct namelist 		{ 		char namelistname[16]; 		struct namelistentry 			{ 			char varname[16]; #  16 plus null padding -> 20 			char *varaddr; 			short int type; 			short int len;	# length of type 			struct dimensions *dimp; # null means scalar 			} names[]; 		};  	struct dimensions 		{ 		int numberofdimensions; 		int numberofelements 		int baseoffset; 		int span[numberofdimensions]; 		};    where the namelistentry list terminates with a null varname    If dimp is not null, then the corner element of the array is at    varaddr.  However,  the element with subscripts (i1,...,in) is at    varaddr - dimp->baseoffset + sizeoftype * (i1+span[0]*(i2+span[1]*...) */
end_comment

begin_macro
name|namelist
argument_list|(
argument|np
argument_list|)
end_macro

begin_decl_stmt
name|Namep
name|np
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|chainp
name|q
decl_stmt|;
specifier|register
name|Namep
name|v
decl_stmt|;
specifier|register
name|struct
name|Dimblock
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|memname
parameter_list|()
function_decl|;
name|int
name|type
decl_stmt|,
name|dimno
decl_stmt|,
name|dimoffset
decl_stmt|;
name|flag
name|bad
decl_stmt|;
name|preven
argument_list|(
name|ALILONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
name|LABELFMT
argument_list|,
name|memname
argument_list|(
name|STGINIT
argument_list|,
name|np
operator|->
name|vardesc
operator|.
name|varno
argument_list|)
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|asmfile
argument_list|,
name|varstr
argument_list|(
name|VL
argument_list|,
name|np
operator|->
name|varname
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|dimno
operator|=
operator|++
name|lastvarno
expr_stmt|;
name|dimoffset
operator|=
literal|0
expr_stmt|;
name|bad
operator|=
name|NO
expr_stmt|;
for|for
control|(
name|q
operator|=
name|np
operator|->
name|varxptr
operator|.
name|namelist
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
block|{
name|vardcl
argument_list|(
name|v
operator|=
call|(
name|Namep
call|)
argument_list|(
name|q
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|v
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|v
operator|->
name|vstg
argument_list|,
name|MSKSTATIC
argument_list|)
condition|)
block|{
name|preven
argument_list|(
name|ALILONG
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|asmfile
argument_list|,
name|varstr
argument_list|(
name|VL
argument_list|,
name|v
operator|->
name|varname
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|praddr
argument_list|(
name|asmfile
argument_list|,
name|v
operator|->
name|vstg
argument_list|,
name|v
operator|->
name|vardesc
operator|.
name|varno
argument_list|,
name|v
operator|->
name|voffset
argument_list|)
expr_stmt|;
name|prconi
argument_list|(
name|asmfile
argument_list|,
name|TYSHORT
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|prconi
argument_list|(
name|asmfile
argument_list|,
name|TYSHORT
argument_list|,
name|type
operator|==
name|TYCHAR
condition|?
operator|(
name|v
operator|->
name|vleng
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|)
else|:
operator|(
name|ftnint
operator|)
name|typesize
index|[
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vdim
condition|)
block|{
name|praddr
argument_list|(
name|asmfile
argument_list|,
name|STGINIT
argument_list|,
name|dimno
argument_list|,
operator|(
name|ftnint
operator|)
name|dimoffset
argument_list|)
expr_stmt|;
name|dimoffset
operator|+=
operator|(
literal|3
operator|+
name|v
operator|->
name|vdim
operator|->
name|ndim
operator|)
operator|*
name|SZINT
expr_stmt|;
block|}
else|else
name|praddr
argument_list|(
name|asmfile
argument_list|,
name|STGNULL
argument_list|,
literal|0
argument_list|,
operator|(
name|ftnint
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dclerr
argument_list|(
literal|"may not appear in namelist"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|bad
operator|=
name|YES
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bad
condition|)
return|return;
name|putstr
argument_list|(
name|asmfile
argument_list|,
literal|""
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|dimoffset
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
name|LABELFMT
argument_list|,
name|memname
argument_list|(
name|STGINIT
argument_list|,
name|dimno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|np
operator|->
name|varxptr
operator|.
name|namelist
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
if|if
condition|(
name|dp
operator|=
name|q
operator|->
name|datap
operator|->
name|nameblock
operator|.
name|vdim
condition|)
block|{
name|int
name|i
decl_stmt|;
name|prconi
argument_list|(
name|asmfile
argument_list|,
name|TYINT
argument_list|,
call|(
name|ftnint
call|)
argument_list|(
name|dp
operator|->
name|ndim
argument_list|)
argument_list|)
expr_stmt|;
name|prconi
argument_list|(
name|asmfile
argument_list|,
name|TYINT
argument_list|,
call|(
name|ftnint
call|)
argument_list|(
name|dp
operator|->
name|nelt
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
argument_list|)
argument_list|)
expr_stmt|;
name|prconi
argument_list|(
name|asmfile
argument_list|,
name|TYINT
argument_list|,
call|(
name|ftnint
call|)
argument_list|(
name|dp
operator|->
name|baseoffset
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|ndim
condition|;
operator|++
name|i
control|)
name|prconi
argument_list|(
name|asmfile
argument_list|,
name|TYINT
argument_list|,
name|dp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_function
name|LOCAL
name|docommon
parameter_list|()
block|{
specifier|register
name|struct
name|Extsym
modifier|*
name|p
decl_stmt|;
specifier|register
name|chainp
name|q
decl_stmt|;
name|struct
name|Dimblock
modifier|*
name|t
decl_stmt|;
name|expptr
name|neltp
decl_stmt|;
specifier|register
name|Namep
name|v
decl_stmt|;
name|ftnint
name|size
decl_stmt|;
name|int
name|type
decl_stmt|;
for|for
control|(
name|p
operator|=
name|extsymtab
init|;
name|p
operator|<
name|nextext
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
operator|->
name|extstg
operator|==
name|STGCOMMON
condition|)
block|{
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
name|prstab
argument_list|(
name|varstr
argument_list|(
name|XL
argument_list|,
name|p
operator|->
name|extname
argument_list|)
argument_list|,
name|N_BCOMM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|q
operator|=
name|p
operator|->
name|extp
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
block|{
name|v
operator|=
call|(
name|Namep
call|)
argument_list|(
name|q
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vdcldone
operator|==
name|NO
condition|)
name|vardcl
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|type
operator|=
name|v
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|extleng
operator|%
name|typealign
index|[
name|type
index|]
operator|!=
literal|0
condition|)
block|{
name|dclerr
argument_list|(
literal|"common alignment"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|p
operator|->
name|extleng
operator|=
name|roundup
argument_list|(
name|p
operator|->
name|extleng
argument_list|,
name|typealign
index|[
name|type
index|]
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|voffset
operator|=
name|p
operator|->
name|extleng
expr_stmt|;
name|v
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|p
operator|-
name|extsymtab
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|size
operator|=
name|v
operator|->
name|vleng
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
else|else
name|size
operator|=
name|typesize
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|=
name|v
operator|->
name|vdim
condition|)
if|if
condition|(
operator|(
name|neltp
operator|=
name|t
operator|->
name|nelt
operator|)
operator|&&
name|ISCONST
argument_list|(
name|neltp
argument_list|)
condition|)
name|size
operator|*=
name|neltp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
else|else
name|dclerr
argument_list|(
literal|"adjustable array in common"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|p
operator|->
name|extleng
operator|+=
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
block|{
name|namestab
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|frchain
argument_list|(
operator|&
operator|(
name|p
operator|->
name|extp
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
name|prstab
argument_list|(
name|varstr
argument_list|(
name|XL
argument_list|,
name|p
operator|->
name|extname
argument_list|)
argument_list|,
name|N_ECOMM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|LOCAL
name|docomleng
parameter_list|()
block|{
specifier|register
name|struct
name|Extsym
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|extsymtab
init|;
name|p
operator|<
name|nextext
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
operator|->
name|extstg
operator|==
name|STGCOMMON
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|maxleng
operator|!=
literal|0
operator|&&
name|p
operator|->
name|extleng
operator|!=
literal|0
operator|&&
name|p
operator|->
name|maxleng
operator|!=
name|p
operator|->
name|extleng
operator|&&
operator|!
name|eqn
argument_list|(
name|XL
argument_list|,
literal|"_BLNK__ "
argument_list|,
name|p
operator|->
name|extname
argument_list|)
condition|)
name|warn1
argument_list|(
literal|"incompatible lengths for common block %s"
argument_list|,
name|nounder
argument_list|(
name|XL
argument_list|,
name|p
operator|->
name|extname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|maxleng
operator|<
name|p
operator|->
name|extleng
condition|)
name|p
operator|->
name|maxleng
operator|=
name|p
operator|->
name|extleng
expr_stmt|;
name|p
operator|->
name|extleng
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ROUTINES DEALING WITH AUTOMATIC AND TEMPORARY STORAGE */
end_comment

begin_comment
comment|/*  frees a temporary block  */
end_comment

begin_macro
name|frtemp
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|Tempp
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Addrp
name|t
decl_stmt|;
if|if
condition|(
name|optimflag
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TTEMP
condition|)
name|badtag
argument_list|(
literal|"frtemp"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|t
operator|=
name|p
operator|->
name|memalloc
expr_stmt|;
block|}
else|else
name|t
operator|=
operator|(
name|Addrp
operator|)
name|p
expr_stmt|;
comment|/* restore clobbered character string lengths */
if|if
condition|(
name|t
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
name|t
operator|->
name|varleng
operator|!=
literal|0
condition|)
block|{
name|frexpr
argument_list|(
name|t
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|t
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|t
operator|->
name|varleng
argument_list|)
expr_stmt|;
block|}
comment|/* put block on chain of temps to be reclaimed */
name|holdtemps
operator|=
name|mkchain
argument_list|(
name|t
argument_list|,
name|holdtemps
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* allocate an automatic variable slot */
end_comment

begin_function
name|Addrp
name|autovar
parameter_list|(
name|nelt
parameter_list|,
name|t
parameter_list|,
name|lengp
parameter_list|)
specifier|register
name|int
name|nelt
decl_stmt|,
name|t
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
block|{
name|ftnint
name|leng
decl_stmt|;
specifier|register
name|Addrp
name|q
decl_stmt|;
if|if
condition|(
name|lengp
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|lengp
argument_list|)
condition|)
name|leng
operator|=
name|lengp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|fatal
argument_list|(
literal|"automatic variable of nonconstant length"
argument_list|)
expr_stmt|;
block|}
else|else
name|leng
operator|=
name|typesize
index|[
name|t
index|]
expr_stmt|;
name|autoleng
operator|=
name|roundup
argument_list|(
name|autoleng
argument_list|,
name|typealign
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|q
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|lengp
condition|)
block|{
name|q
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|leng
argument_list|)
expr_stmt|;
name|q
operator|->
name|varleng
operator|=
name|leng
expr_stmt|;
block|}
name|q
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|q
operator|->
name|memno
operator|=
name|newlabel
argument_list|()
expr_stmt|;
name|q
operator|->
name|ntempelt
operator|=
name|nelt
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
operator|||
name|TARGET
operator|==
name|VAX
comment|/* stack grows downward */
name|autoleng
operator|+=
name|nelt
operator|*
name|leng
expr_stmt|;
name|q
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
operator|-
name|autoleng
argument_list|)
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
name|autoleng
argument_list|)
expr_stmt|;
name|autoleng
operator|+=
name|nelt
operator|*
name|leng
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  create a temporary block (TTEMP) when optimizing,  *  an ordinary TADDR block when not optimizing  */
end_comment

begin_function
name|Tempp
name|mktmpn
parameter_list|(
name|nelt
parameter_list|,
name|type
parameter_list|,
name|lengp
parameter_list|)
name|int
name|nelt
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
block|{
name|ftnint
name|leng
decl_stmt|;
name|chainp
name|p
decl_stmt|,
name|oldp
decl_stmt|;
specifier|register
name|Tempp
name|q
decl_stmt|;
name|Addrp
name|altemp
decl_stmt|;
if|if
condition|(
operator|!
name|optimflag
condition|)
return|return
operator|(
operator|(
name|Tempp
operator|)
name|mkaltmpn
argument_list|(
name|nelt
argument_list|,
name|type
argument_list|,
name|lengp
argument_list|)
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|TYUNKNOWN
operator|||
name|type
operator|==
name|TYERROR
condition|)
name|badtype
argument_list|(
literal|"mktmpn"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|lengp
argument_list|)
condition|)
name|leng
operator|=
name|lengp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|err
argument_list|(
literal|"adjustable length"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Tempp
operator|)
name|errnode
argument_list|()
operator|)
return|;
block|}
else|else
name|leng
operator|=
name|typesize
index|[
name|type
index|]
expr_stmt|;
name|q
operator|=
name|ALLOC
argument_list|(
name|Tempblock
argument_list|)
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TTEMP
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
name|q
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|leng
argument_list|)
expr_stmt|;
name|q
operator|->
name|varleng
operator|=
name|leng
expr_stmt|;
block|}
name|altemp
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|altemp
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|altemp
operator|->
name|vstg
operator|=
name|STGUNKNOWN
expr_stmt|;
name|q
operator|->
name|memalloc
operator|=
name|altemp
expr_stmt|;
name|q
operator|->
name|ntempelt
operator|=
name|nelt
expr_stmt|;
name|q
operator|->
name|istemp
operator|=
name|YES
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|Addrp
name|mktemp
parameter_list|(
name|type
parameter_list|,
name|lengp
parameter_list|)
name|int
name|type
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|Addrp
operator|)
name|mktmpn
argument_list|(
literal|1
argument_list|,
name|type
argument_list|,
name|lengp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  allocate a temporary location for the given temporary block;     if already allocated, return its location  */
end_comment

begin_function
name|Addrp
name|altmpn
parameter_list|(
name|tp
parameter_list|)
name|Tempp
name|tp
decl_stmt|;
block|{
name|Addrp
name|t
decl_stmt|,
name|q
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|tag
operator|!=
name|TTEMP
condition|)
name|badtag
argument_list|(
literal|"altmpn"
argument_list|,
name|tp
operator|->
name|tag
argument_list|)
expr_stmt|;
name|t
operator|=
name|tp
operator|->
name|memalloc
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|vstg
operator|!=
name|STGUNKNOWN
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
comment|/* 		 * Unformatted I/O parameters are treated like character 		 *	strings (sigh) -- propagate type and length. 		 */
name|t
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|vtype
operator|=
name|tp
operator|->
name|vtype
expr_stmt|;
name|t
operator|->
name|vleng
operator|=
name|tp
operator|->
name|vleng
expr_stmt|;
name|t
operator|->
name|varleng
operator|=
name|tp
operator|->
name|varleng
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
name|q
operator|=
name|mkaltmpn
argument_list|(
name|tp
operator|->
name|ntempelt
argument_list|,
name|tp
operator|->
name|vtype
argument_list|,
name|tp
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|cpn
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Addrblock
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|q
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  create and allocate space immediately for a temporary  */
end_comment

begin_function
name|Addrp
name|mkaltemp
parameter_list|(
name|type
parameter_list|,
name|lengp
parameter_list|)
name|int
name|type
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
block|{
return|return
operator|(
name|mkaltmpn
argument_list|(
literal|1
argument_list|,
name|type
argument_list|,
name|lengp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Addrp
name|mkaltmpn
parameter_list|(
name|nelt
parameter_list|,
name|type
parameter_list|,
name|lengp
parameter_list|)
name|int
name|nelt
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
block|{
name|ftnint
name|leng
decl_stmt|;
name|chainp
name|p
decl_stmt|,
name|oldp
decl_stmt|;
specifier|register
name|Addrp
name|q
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYUNKNOWN
operator|||
name|type
operator|==
name|TYERROR
condition|)
name|badtype
argument_list|(
literal|"mkaltmpn"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|lengp
argument_list|)
condition|)
name|leng
operator|=
name|lengp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|err
argument_list|(
literal|"adjustable length"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Addrp
operator|)
name|errnode
argument_list|()
operator|)
return|;
block|}
comment|/*  * if a temporary of appropriate shape is on the templist,  * remove it from the list and return it  */
ifdef|#
directive|ifdef
name|notdef
comment|/*  * This code is broken until SKFRTEMP slots can be processed in putopt()  *	instead of in optimize() -- all kinds of things in putpcc.c can  *	bomb because of this.  Sigh.  */
for|for
control|(
name|oldp
operator|=
name|CHNULL
operator|,
name|p
operator|=
name|templist
init|;
name|p
condition|;
name|oldp
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
name|q
operator|=
call|(
name|Addrp
call|)
argument_list|(
name|p
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|vtype
operator|==
name|type
operator|&&
name|q
operator|->
name|ntempelt
operator|==
name|nelt
operator|&&
operator|(
name|type
operator|!=
name|TYCHAR
operator|||
name|q
operator|->
name|vleng
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|==
name|leng
operator|)
condition|)
block|{
if|if
condition|(
name|oldp
condition|)
name|oldp
operator|->
name|nextp
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
else|else
name|templist
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflag
index|[
literal|14
index|]
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"mkaltmpn reusing offset %d\n"
argument_list|,
name|q
operator|->
name|memoffset
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
block|}
endif|#
directive|endif
endif|notdef
name|q
operator|=
name|autovar
argument_list|(
name|nelt
argument_list|,
name|type
argument_list|,
name|lengp
argument_list|)
expr_stmt|;
name|q
operator|->
name|istemp
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|debugflag
index|[
literal|14
index|]
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"mkaltmpn new offset %d\n"
argument_list|,
name|q
operator|->
name|memoffset
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  The following routine is a patch which is only needed because the	*/
end_comment

begin_comment
comment|/*  code for processing actual arguments for calls does not allocate	*/
end_comment

begin_comment
comment|/*  the temps it needs before optimization takes place.  A better	*/
end_comment

begin_comment
comment|/*  solution is possible, but I do not have the time to implement it	*/
end_comment

begin_comment
comment|/*  now.								*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*					Robert P. Corbett		*/
end_comment

begin_function
name|Addrp
name|mkargtemp
parameter_list|(
name|type
parameter_list|,
name|lengp
parameter_list|)
name|int
name|type
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
block|{
name|ftnint
name|leng
decl_stmt|;
name|chainp
name|oldp
decl_stmt|,
name|p
decl_stmt|;
name|Addrp
name|q
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYUNKNOWN
operator|||
name|type
operator|==
name|TYERROR
condition|)
name|badtype
argument_list|(
literal|"mkargtemp"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|ISICON
argument_list|(
name|lengp
argument_list|)
condition|)
name|leng
operator|=
name|lengp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|err
argument_list|(
literal|"adjustable length"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Addrp
operator|)
name|errnode
argument_list|()
operator|)
return|;
block|}
block|}
name|oldp
operator|=
name|CHNULL
expr_stmt|;
name|p
operator|=
name|argtemplist
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|q
operator|=
call|(
name|Addrp
call|)
argument_list|(
name|p
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|vtype
operator|==
name|type
operator|&&
operator|(
name|type
operator|!=
name|TYCHAR
operator|||
name|q
operator|->
name|vleng
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|==
name|leng
operator|)
condition|)
block|{
if|if
condition|(
name|oldp
condition|)
name|oldp
operator|->
name|nextp
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
else|else
name|argtemplist
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
name|p
operator|->
name|nextp
operator|=
name|activearglist
expr_stmt|;
name|activearglist
operator|=
name|p
expr_stmt|;
return|return
operator|(
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|q
argument_list|)
operator|)
return|;
block|}
name|oldp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
block|}
name|q
operator|=
name|autovar
argument_list|(
literal|1
argument_list|,
name|type
argument_list|,
name|lengp
argument_list|)
expr_stmt|;
name|activearglist
operator|=
name|mkchain
argument_list|(
name|q
argument_list|,
name|activearglist
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|q
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* VARIOUS ROUTINES FOR PROCESSING DECLARATIONS */
end_comment

begin_function
name|struct
name|Extsym
modifier|*
name|comblock
parameter_list|(
name|len
parameter_list|,
name|s
parameter_list|)
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|Extsym
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|BLANKCOMMON
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|mkext
argument_list|(
name|varunder
argument_list|(
name|len
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|extstg
operator|==
name|STGUNKNOWN
condition|)
name|p
operator|->
name|extstg
operator|=
name|STGCOMMON
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|extstg
operator|!=
name|STGCOMMON
condition|)
block|{
name|errstr
argument_list|(
literal|"%s cannot be a common block name"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|incomm
argument_list|(
argument|c
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|Extsym
modifier|*
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Namep
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|v
operator|->
name|vstg
operator|!=
name|STGUNKNOWN
condition|)
name|dclerr
argument_list|(
literal|"incompatible common declaration"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|Extsym
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* Illegal common block name upstream */
name|v
operator|->
name|vstg
operator|=
name|STGCOMMON
expr_stmt|;
name|c
operator|->
name|extp
operator|=
name|hookup
argument_list|(
name|c
operator|->
name|extp
argument_list|,
name|mkchain
argument_list|(
name|v
argument_list|,
name|CHNULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|settype
argument_list|(
name|v
argument_list|,
name|type
argument_list|,
name|length
argument_list|)
specifier|register
name|Namep
name|v
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|type
operator|==
name|TYUNKNOWN
condition|)
return|return;
if|if
condition|(
name|type
operator|==
name|TYSUBR
operator|&&
name|v
operator|->
name|vtype
operator|!=
name|TYUNKNOWN
operator|&&
name|v
operator|->
name|vstg
operator|==
name|STGARG
condition|)
block|{
name|v
operator|->
name|vtype
operator|=
name|TYSUBR
expr_stmt|;
name|frexpr
argument_list|(
name|v
operator|->
name|vleng
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|<
literal|0
condition|)
comment|/* storage class set */
block|{
if|if
condition|(
name|v
operator|->
name|vstg
operator|==
name|STGUNKNOWN
condition|)
name|v
operator|->
name|vstg
operator|=
operator|-
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vstg
operator|!=
operator|-
name|type
condition|)
name|dclerr
argument_list|(
literal|"incompatible storage declarations"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|vtype
operator|==
name|TYUNKNOWN
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|->
name|vtype
operator|=
name|lengtype
argument_list|(
name|type
argument_list|,
name|length
argument_list|)
operator|)
operator|==
name|TYCHAR
operator|&&
name|length
operator|>=
literal|0
condition|)
name|v
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|vtype
operator|!=
name|type
operator|||
operator|(
name|type
operator|==
name|TYCHAR
operator|&&
name|v
operator|->
name|vleng
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|!=
name|length
operator|)
condition|)
name|dclerr
argument_list|(
literal|"incompatible type declarations"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|lengtype
argument_list|(
name|type
argument_list|,
name|length
argument_list|)
specifier|register
name|int
name|type
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYREAL
case|:
if|if
condition|(
name|length
operator|==
literal|8
condition|)
return|return
operator|(
name|TYDREAL
operator|)
return|;
if|if
condition|(
name|length
operator|==
literal|4
condition|)
goto|goto
name|ret
goto|;
break|break;
case|case
name|TYCOMPLEX
case|:
if|if
condition|(
name|length
operator|==
literal|16
condition|)
return|return
operator|(
name|TYDCOMPLEX
operator|)
return|;
if|if
condition|(
name|length
operator|==
literal|8
condition|)
goto|goto
name|ret
goto|;
break|break;
case|case
name|TYSHORT
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYDCOMPLEX
case|:
case|case
name|TYCHAR
case|:
case|case
name|TYUNKNOWN
case|:
case|case
name|TYSUBR
case|:
case|case
name|TYERROR
case|:
goto|goto
name|ret
goto|;
case|case
name|TYLOGICAL
case|:
if|if
condition|(
name|length
operator|==
name|typesize
index|[
name|TYLOGICAL
index|]
condition|)
goto|goto
name|ret
goto|;
break|break;
case|case
name|TYLONG
case|:
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
operator|(
name|tyint
operator|)
return|;
if|if
condition|(
name|length
operator|==
literal|2
condition|)
return|return
operator|(
name|TYSHORT
operator|)
return|;
if|if
condition|(
name|length
operator|==
literal|4
condition|)
goto|goto
name|ret
goto|;
break|break;
default|default:
name|badtype
argument_list|(
literal|"lengtype"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|"incompatible type-length combination"
argument_list|)
expr_stmt|;
name|ret
label|:
return|return
operator|(
name|type
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|setintr
argument_list|(
name|v
argument_list|)
specifier|register
name|Namep
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|vstg
operator|==
name|STGUNKNOWN
condition|)
name|v
operator|->
name|vstg
operator|=
name|STGINTR
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vstg
operator|!=
name|STGINTR
condition|)
name|dclerr
argument_list|(
literal|"incompatible use of intrinsic function"
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|v
operator|->
name|vclass
operator|=
name|CLPROC
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|==
name|PUNKNOWN
condition|)
name|v
operator|->
name|vprocclass
operator|=
name|PINTRINSIC
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|!=
name|PINTRINSIC
condition|)
name|dclerr
argument_list|(
literal|"invalid intrinsic declaration"
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|=
name|intrfunct
argument_list|(
name|v
operator|->
name|varname
argument_list|)
condition|)
name|v
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|k
expr_stmt|;
else|else
name|dclerr
argument_list|(
literal|"unknown intrinsic function"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|setext
argument_list|(
name|v
argument_list|)
specifier|register
name|Namep
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|v
operator|->
name|vclass
operator|=
name|CLPROC
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vclass
operator|!=
name|CLPROC
condition|)
name|dclerr
argument_list|(
literal|"conflicting declarations"
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|==
name|PUNKNOWN
condition|)
name|v
operator|->
name|vprocclass
operator|=
name|PEXTERNAL
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|!=
name|PEXTERNAL
condition|)
name|dclerr
argument_list|(
literal|"conflicting declarations"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* create dimensions block for array variable */
end_comment

begin_expr_stmt
name|setbound
argument_list|(
name|v
argument_list|,
name|nd
argument_list|,
name|dims
argument_list|)
specifier|register
name|Namep
name|v
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|nd
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|expptr
name|lb
decl_stmt|,
name|ub
decl_stmt|;
block|}
name|dims
index|[ ]
struct|;
end_struct

begin_block
block|{
specifier|register
name|expptr
name|q
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|struct
name|Dimblock
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|v
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vclass
operator|!=
name|CLVAR
condition|)
block|{
name|dclerr
argument_list|(
literal|"only variables may be arrays"
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|v
operator|->
name|vdim
condition|)
block|{
name|dclerr
argument_list|(
literal|"redimensioned array"
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|->
name|vdim
operator|=
name|p
operator|=
operator|(
expr|struct
name|Dimblock
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
operator|(
literal|3
operator|+
literal|6
operator|*
name|nd
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|expptr
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|ndim
operator|=
name|nd
expr_stmt|;
name|p
operator|->
name|nelt
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nd
condition|;
operator|++
name|i
control|)
block|{
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
block|{
comment|/* Save the bounds trees built up by the grammar routines for use in stabs */
if|if
condition|(
name|dims
index|[
name|i
index|]
operator|.
name|lb
operator|==
name|NULL
condition|)
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|lb
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|lb
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|dims
index|[
name|i
index|]
operator|.
name|lb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|lb
argument_list|)
condition|)
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|lbaddr
operator|=
operator|(
name|expptr
operator|)
name|PNULL
expr_stmt|;
else|else
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|lbaddr
operator|=
operator|(
name|expptr
operator|)
name|autovar
argument_list|(
literal|1
argument_list|,
name|tyint
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dims
index|[
name|i
index|]
operator|.
name|ub
operator|==
name|NULL
condition|)
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|ub
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|ub
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|dims
index|[
name|i
index|]
operator|.
name|ub
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|ub
argument_list|)
condition|)
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|ubaddr
operator|=
operator|(
name|expptr
operator|)
name|PNULL
expr_stmt|;
else|else
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|ubaddr
operator|=
operator|(
name|expptr
operator|)
name|autovar
argument_list|(
literal|1
argument_list|,
name|tyint
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|q
operator|=
name|dims
index|[
name|i
index|]
operator|.
name|ub
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|nd
operator|-
literal|1
condition|)
block|{
name|frexpr
argument_list|(
name|p
operator|->
name|nelt
argument_list|)
expr_stmt|;
name|p
operator|->
name|nelt
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"only last bound may be asterisk"
argument_list|)
expr_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
empty_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dims
index|[
name|i
index|]
operator|.
name|lb
condition|)
block|{
name|q
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|q
argument_list|,
name|cpexpr
argument_list|(
name|dims
index|[
name|i
index|]
operator|.
name|lb
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|q
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|dclerr
argument_list|(
literal|"dimension bounds must be integer expression"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|<=
literal|0
condition|)
block|{
name|dclerr
argument_list|(
literal|"array bounds out of sequence"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
operator|=
operator|(
name|expptr
operator|)
name|PNULL
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|=
operator|(
name|expptr
operator|)
name|autovar
argument_list|(
literal|1
argument_list|,
name|tyint
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|nelt
condition|)
name|p
operator|->
name|nelt
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|p
operator|->
name|nelt
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|q
operator|=
name|dims
index|[
name|nd
operator|-
literal|1
index|]
operator|.
name|lb
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|q
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nd
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|t
operator|=
name|dims
index|[
name|i
index|]
operator|.
name|lb
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|t
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
condition|)
name|q
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|t
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
argument_list|)
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|p
operator|->
name|baseoffset
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|basexpr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|baseoffset
operator|=
operator|(
name|expptr
operator|)
name|autovar
argument_list|(
literal|1
argument_list|,
name|tyint
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|p
operator|->
name|basexpr
operator|=
name|q
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Check the dimensions of q to ensure that they are appropriately defined.  */
end_comment

begin_function
name|LOCAL
name|chkdim
parameter_list|(
name|q
parameter_list|)
specifier|register
name|Namep
name|q
decl_stmt|;
block|{
specifier|register
name|struct
name|Dimblock
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|expptr
name|e
decl_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|q
operator|->
name|vclass
operator|!=
name|CLVAR
condition|)
return|return;
if|if
condition|(
name|q
operator|->
name|vdim
operator|==
name|NULL
condition|)
return|return;
name|p
operator|=
name|q
operator|->
name|vdim
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|ndim
condition|;
operator|++
name|i
control|)
block|{
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
block|{
if|if
condition|(
name|e
operator|=
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|lb
condition|)
name|chkdime
argument_list|(
name|e
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|=
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|ub
condition|)
name|chkdime
argument_list|(
name|e
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
endif|SDB
if|if
condition|(
name|e
operator|=
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
condition|)
name|chkdime
argument_list|(
name|e
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The actual checking for chkdim() -- examines each expression.  */
end_comment

begin_function
name|LOCAL
name|chkdime
parameter_list|(
name|expr
parameter_list|,
name|q
parameter_list|)
name|expptr
name|expr
decl_stmt|;
name|Namep
name|q
decl_stmt|;
block|{
specifier|register
name|expptr
name|e
decl_stmt|;
name|e
operator|=
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
name|dclerr
argument_list|(
literal|"non-integer dimension"
argument_list|,
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|safedim
argument_list|(
name|e
argument_list|)
condition|)
name|dclerr
argument_list|(
literal|"undefined dimension"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * A recursive routine to find undefined variables in dimension expressions.  */
end_comment

begin_function
name|LOCAL
name|safedim
parameter_list|(
name|e
parameter_list|)
name|expptr
name|e
decl_stmt|;
block|{
name|chainp
name|cp
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|e
operator|->
name|tag
condition|)
block|{
case|case
name|TEXPR
case|:
if|if
condition|(
name|e
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCALL
operator|||
name|e
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCCALL
condition|)
return|return
literal|0
return|;
return|return
name|safedim
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
operator|&&
name|safedim
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
return|;
case|case
name|TADDR
case|:
switch|switch
condition|(
name|e
operator|->
name|addrblock
operator|.
name|vstg
condition|)
block|{
case|case
name|STGCOMMON
case|:
case|case
name|STGARG
case|:
case|case
name|STGCONST
case|:
case|case
name|STGEQUIV
case|:
if|if
condition|(
name|e
operator|->
name|addrblock
operator|.
name|isarray
condition|)
return|return
literal|0
return|;
return|return
name|safedim
argument_list|(
name|e
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
case|case
name|TCONST
case|:
case|case
name|TTEMP
case|:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|LOCAL
name|enlist
parameter_list|(
name|size
parameter_list|,
name|np
parameter_list|,
name|ep
parameter_list|)
name|ftnint
name|size
decl_stmt|;
name|Namep
name|np
decl_stmt|;
name|struct
name|Equivblock
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|sizelist
modifier|*
name|sp
decl_stmt|;
specifier|register
name|sizelist
modifier|*
name|t
decl_stmt|;
specifier|register
name|varlist
modifier|*
name|p
decl_stmt|;
name|sp
operator|=
name|varsizes
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|sp
operator|=
name|ALLOC
argument_list|(
name|SizeList
argument_list|)
expr_stmt|;
name|sp
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|varsizes
operator|=
name|sp
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|sp
operator|->
name|size
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|sp
operator|->
name|next
operator|->
name|size
operator|<=
name|size
condition|)
name|sp
operator|=
name|sp
operator|->
name|next
expr_stmt|;
else|else
block|{
name|t
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|ALLOC
argument_list|(
name|SizeList
argument_list|)
expr_stmt|;
name|sp
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|sp
operator|->
name|next
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|sp
expr_stmt|;
block|}
block|}
block|}
name|p
operator|=
name|ALLOC
argument_list|(
name|VarList
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|sp
operator|->
name|vars
expr_stmt|;
name|p
operator|->
name|np
operator|=
name|np
expr_stmt|;
name|p
operator|->
name|ep
operator|=
name|ep
expr_stmt|;
name|sp
operator|->
name|vars
operator|=
name|p
expr_stmt|;
return|return;
block|}
end_function

begin_macro
name|outlocvars
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|varlist
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
specifier|register
name|varlist
modifier|*
name|vp
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|sizelist
modifier|*
name|sp
decl_stmt|,
modifier|*
name|sp1
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|struct
name|Equivblock
modifier|*
name|ep
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|alt
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
name|char
name|sname
index|[
literal|100
index|]
decl_stmt|;
name|char
name|setbuff
index|[
literal|100
index|]
decl_stmt|;
name|sp
operator|=
name|varsizes
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return;
name|vp
operator|=
name|sp
operator|->
name|vars
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|np
operator|!=
name|NULL
condition|)
block|{
name|np
operator|=
name|vp
operator|->
name|np
expr_stmt|;
name|sprintf
argument_list|(
name|setbuff
argument_list|,
literal|"\t.set\tv.%d,v.%d\n"
argument_list|,
name|bsslabel
argument_list|,
name|np
operator|->
name|vardesc
operator|.
name|varno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|vp
operator|->
name|ep
operator|-
name|eqvclass
expr_stmt|;
name|sprintf
argument_list|(
name|setbuff
argument_list|,
literal|"\t.set\tv.%d,q.%d\n"
argument_list|,
name|bsslabel
argument_list|,
name|i
operator|+
name|eqvstart
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
name|last
operator|=
name|NULL
expr_stmt|;
name|alt
operator|=
name|NO
expr_stmt|;
while|while
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|vp
operator|=
name|sp
operator|->
name|vars
expr_stmt|;
while|while
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
name|t
operator|=
name|vp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|alt
operator|==
name|YES
condition|)
block|{
name|alt
operator|=
name|NO
expr_stmt|;
name|vp
operator|->
name|next
operator|=
name|first
expr_stmt|;
name|first
operator|=
name|vp
expr_stmt|;
block|}
else|else
block|{
name|alt
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
name|last
operator|->
name|next
operator|=
name|vp
expr_stmt|;
else|else
name|first
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|last
operator|=
name|vp
expr_stmt|;
block|}
name|vp
operator|=
name|t
expr_stmt|;
block|}
name|sp1
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp1
argument_list|)
expr_stmt|;
block|}
name|vp
operator|=
name|first
expr_stmt|;
while|while
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|np
operator|!=
name|NULL
condition|)
block|{
name|np
operator|=
name|vp
operator|->
name|np
expr_stmt|;
name|sprintf
argument_list|(
name|sname
argument_list|,
literal|"v.%d"
argument_list|,
name|np
operator|->
name|vardesc
operator|.
name|varno
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|init
condition|)
name|prlocdata
argument_list|(
name|sname
argument_list|,
name|np
operator|->
name|varsize
argument_list|,
name|np
operator|->
name|vtype
argument_list|,
name|np
operator|->
name|initoffset
argument_list|,
operator|&
operator|(
name|np
operator|->
name|inlcomm
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|pralign
argument_list|(
name|typealign
index|[
name|np
operator|->
name|vtype
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|initfile
argument_list|,
literal|"%s:\n"
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|prspace
argument_list|(
name|np
operator|->
name|varsize
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|inlcomm
operator|=
name|NO
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|=
name|vp
operator|->
name|ep
expr_stmt|;
name|i
operator|=
name|ep
operator|-
name|eqvclass
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|eqvleng
operator|>=
literal|8
condition|)
name|type
operator|=
name|TYDREAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ep
operator|->
name|eqvleng
operator|>=
literal|4
condition|)
name|type
operator|=
name|TYLONG
expr_stmt|;
elseif|else
if|if
condition|(
name|ep
operator|->
name|eqvleng
operator|>=
literal|2
condition|)
name|type
operator|=
name|TYSHORT
expr_stmt|;
else|else
name|type
operator|=
name|TYCHAR
expr_stmt|;
name|sprintf
argument_list|(
name|sname
argument_list|,
literal|"q.%d"
argument_list|,
name|i
operator|+
name|eqvstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|init
condition|)
name|prlocdata
argument_list|(
name|sname
argument_list|,
name|ep
operator|->
name|eqvleng
argument_list|,
name|type
argument_list|,
name|ep
operator|->
name|initoffset
argument_list|,
operator|&
operator|(
name|ep
operator|->
name|inlcomm
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|pralign
argument_list|(
name|typealign
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|initfile
argument_list|,
literal|"%s:\n"
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|prspace
argument_list|(
name|ep
operator|->
name|eqvleng
argument_list|)
expr_stmt|;
block|}
name|ep
operator|->
name|inlcomm
operator|=
name|NO
expr_stmt|;
block|}
name|t
operator|=
name|vp
expr_stmt|;
name|vp
operator|=
name|vp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|initfile
argument_list|,
literal|"%s\n"
argument_list|,
name|setbuff
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

end_unit

