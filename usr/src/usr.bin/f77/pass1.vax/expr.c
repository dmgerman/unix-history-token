begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
index|[]
init|=
literal|"@(#)expr.c	5.9 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * expr.c  *  * Routines for handling expressions, f77 compiler pass 1.  *  * University of Utah CS Dept modification history:  *  * $Log:	expr.c,v $  * Revision 5.13  86/05/07  18:54:23  donn  * Adjusted the warning for OPEQ with logical operands -- this is now printed  * in mkexpr since cktype can be called several times on the same operands  * (argh -- how slow can this compiler get?!).  *   * Revision 5.12  86/05/07  17:40:54  donn  * Make the lengths of expr nodes be copied by cpexpr and freed by frexpr.  *   * Revision 5.11  86/05/07  16:57:17  donn  * Logical data is supposed to be compared using .eqv. and .neqv., but we  * will support .eq. and .ne. with a warning.  Other relational operators  * now provoke errors when used with logical operands.  *   * Revision 5.10  86/04/26  13:24:30  donn  * Someone forgot about comparisons of logical constants in consbinop() --  * the results of such tests were garbage.  *   * Revision 5.9  86/02/20  23:38:31  donn  * Fix memory management problem with reordering of array dimension and  * substring code in mklhs().  *   * Revision 5.8  85/12/20  21:37:58  donn  * Fix bug in mklhs() that caused the 'first character' substring parameter  * to be evaluated twice.  *   * Revision 5.7  85/12/20  19:42:05  donn  * Be more specfic -- name the offending subroutine when it's used as a  * function.  *   * Revision 5.6  85/12/19  20:08:12  donn  * Don't optimize first/last char values when they contain function calls  * or array references.  *   * Revision 5.5  85/12/19  00:35:22  donn  * Lots of changes for handling hardware errors which can crop up when  * evaluating constant expressions.  *   * Revision 5.4  85/11/25  00:23:53  donn  * 4.3 beta  *   * Revision 5.3  85/08/10  05:48:16  donn  * Fixed another of my goofs in the substring parameter conversion code.  *   * Revision 5.2  85/08/10  04:13:51  donn  * Jerry Berkman's change to call pow() directly rather than indirectly  * through pow_dd, in mkpower().  *   * Revision 5.1  85/08/10  03:44:19  donn  * 4.3 alpha  *   * Revision 3.16  85/06/21  16:38:09  donn  * The fix to mkprim() didn't handle null substring parameters (sigh).  *   * Revision 3.15  85/06/04  04:37:03  donn  * Changed mkprim() to force substring parameters to be integral types.  *   * Revision 3.14  85/06/04  03:41:52  donn  * Change impldcl() to handle functions of type 'undefined'.  *   * Revision 3.13  85/05/06  23:14:55  donn  * Changed mkconv() so that it calls mkaltemp() instead of mktemp() to get  * a temporary when converting character strings to integers; previously we  * were having problems because mkconv() was called after tempalloc().  *   * Revision 3.12  85/03/18  08:07:47  donn  * Fixes to help out with short integers -- if integers are by default short,  * then so are constants; and if addresses can't be stored in shorts, complain.  *   * Revision 3.11  85/03/16  22:31:27  donn  * Added hack to mkconv() to allow character values of length> 1 to be  * converted to numeric types, for Helge Skrivervik.  Note that this does  * not affect use of the intrinsic ichar() conversion.  *   * Revision 3.10  85/01/15  21:06:47  donn  * Changed mkconv() to comment on implicit conversions; added intrconv() for  * use with explicit conversions by intrinsic functions.  *   * Revision 3.9  85/01/11  21:05:49  donn  * Added changes to implement SAVE statements.  *   * Revision 3.8  84/12/17  02:21:06  donn  * Added a test to prevent constant folding from being done on expressions  * whose type is not known at that point in mkexpr().  *   * Revision 3.7  84/12/11  21:14:17  donn  * Removed obnoxious 'excess precision' warning.  *   * Revision 3.6  84/11/23  01:00:36  donn  * Added code to trim excess precision from single-precision constants, and  * to warn the user when this occurs.  *   * Revision 3.5  84/11/23  00:10:39  donn  * Changed stfcall() to remark on argument type clashes in 'calls' to  * statement functions.  *   * Revision 3.4  84/11/22  21:21:17  donn  * Fixed bug in fix to mkexpr() that caused IMPLICIT to affect intrinsics.  *   * Revision 3.3  84/11/12  18:26:14  donn  * Shuffled some code around so that the compiler remembers to free some vleng  * structures which used to just sit around.  *   * Revision 3.2  84/10/16  19:24:15  donn  * Fix for Peter Montgomery's bug with -C and invalid subscripts -- prevent  * core dumps by replacing bad subscripts with good ones.  *   * Revision 3.1  84/10/13  01:31:32  donn  * Merged Jerry Berkman's version into mine.  *   * Revision 2.7  84/09/27  15:42:52  donn  * The last fix for multiplying undeclared variables by 0 isn't sufficient,  * since the type of the 0 may not be the (implicit) type of the variable.  * I added a hack to check the implicit type of implicitly declared  * variables...  *   * Revision 2.6  84/09/14  19:34:03  donn  * Problem noted by Mike Vevea -- mkexpr will sometimes attempt to convert  * 0 to type UNKNOWN, which is illegal.  Fix is to use native type instead.  * Not sure how correct (or important) this is...  *   * Revision 2.5  84/08/05  23:05:27  donn  * Added fixes to prevent fixexpr() from slicing and dicing complex conversions  * with two operands.  *   * Revision 2.4  84/08/05  17:34:48  donn  * Added an optimization to mklhs() to detect substrings of the form ch(i:i)  * and assign constant length 1 to them.  *   * Revision 2.3  84/07/19  19:38:33  donn  * Added a typecast to the last fix.  Somehow I missed it the first time...  *   * Revision 2.2  84/07/19  17:19:57  donn  * Caused OPPAREN expressions to inherit the length of their operands, so  * that parenthesized character expressions work correctly.  *   * Revision 2.1  84/07/19  12:03:02  donn  * Changed comment headers for UofU.  *   * Revision 1.2  84/04/06  20:12:17  donn  * Fixed bug which caused programs with mixed-type multiplications involving  * the constant 0 to choke the compiler.  *   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* little routines to create constant blocks */
end_comment

begin_function
name|Constp
name|mkconst
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Constblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TCONST
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|mklogcon
parameter_list|(
name|l
parameter_list|)
specifier|register
name|int
name|l
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
name|p
operator|=
name|mkconst
argument_list|(
name|TYLOGICAL
argument_list|)
expr_stmt|;
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
name|l
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|mkintcon
parameter_list|(
name|l
parameter_list|)
name|ftnint
name|l
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
name|int
name|usetype
decl_stmt|;
if|if
condition|(
name|tyint
operator|==
name|TYSHORT
condition|)
block|{
name|short
name|s
init|=
name|l
decl_stmt|;
if|if
condition|(
name|l
operator|!=
name|s
condition|)
name|usetype
operator|=
name|TYLONG
expr_stmt|;
else|else
name|usetype
operator|=
name|TYSHORT
expr_stmt|;
block|}
else|else
name|usetype
operator|=
name|tyint
expr_stmt|;
name|p
operator|=
name|mkconst
argument_list|(
name|usetype
argument_list|)
expr_stmt|;
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
name|l
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|mkaddcon
parameter_list|(
name|l
parameter_list|)
specifier|register
name|int
name|l
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
name|p
operator|=
name|mkconst
argument_list|(
name|TYADDR
argument_list|)
expr_stmt|;
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
name|l
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|mkrealcon
parameter_list|(
name|t
parameter_list|,
name|d
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
name|double
name|d
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|TYREAL
condition|)
block|{
name|float
name|f
init|=
name|d
decl_stmt|;
if|if
condition|(
name|f
operator|!=
name|d
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
name|warn
argument_list|(
literal|"excess precision in real constant lost"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|notdef
name|d
operator|=
name|f
expr_stmt|;
block|}
block|}
name|p
operator|=
name|mkconst
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|p
operator|->
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|=
name|d
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|mkbitcon
parameter_list|(
name|shift
parameter_list|,
name|leng
parameter_list|,
name|s
parameter_list|)
name|int
name|shift
decl_stmt|;
specifier|register
name|int
name|leng
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|Constp
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
operator|(
name|shift
operator|*
name|leng
operator|+
name|BYTESIZE
operator|-
literal|1
operator|)
operator|/
name|BYTESIZE
expr_stmt|;
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|TARGET
operator|==
name|PDP11
operator|||
name|TARGET
operator|==
name|VAX
operator|)
name|j
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|j
operator|=
name|size
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|leng
operator|>
literal|0
condition|)
block|{
name|k
operator||=
operator|(
name|hextoi
argument_list|(
name|s
index|[
operator|--
name|leng
index|]
argument_list|)
operator|<<
name|i
operator|)
expr_stmt|;
name|i
operator|+=
name|shift
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|BYTESIZE
condition|)
block|{
if|#
directive|if
operator|(
name|TARGET
operator|==
name|PDP11
operator|||
name|TARGET
operator|==
name|VAX
operator|)
name|bp
index|[
name|j
operator|++
index|]
operator|=
name|k
operator|&
name|MAXBYTE
expr_stmt|;
else|#
directive|else
name|bp
index|[
operator|--
name|j
index|]
operator|=
name|k
operator|&
name|MAXBYTE
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
name|k
operator|>>
name|BYTESIZE
expr_stmt|;
name|i
operator|-=
name|BYTESIZE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k
operator|!=
literal|0
condition|)
if|#
directive|if
operator|(
name|TARGET
operator|==
name|PDP11
operator|||
name|TARGET
operator|==
name|VAX
operator|)
name|bp
index|[
name|j
operator|++
index|]
operator|=
name|k
expr_stmt|;
else|#
directive|else
name|bp
index|[
operator|--
name|j
index|]
operator|=
name|k
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|mkconst
argument_list|(
name|TYBITSTR
argument_list|)
expr_stmt|;
name|p
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|p
operator|->
name|constant
operator|.
name|ccp
operator|=
name|bp
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|mkstrcon
parameter_list|(
name|l
parameter_list|,
name|v
parameter_list|)
name|int
name|l
decl_stmt|;
specifier|register
name|char
modifier|*
name|v
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|p
operator|=
name|mkconst
argument_list|(
name|TYCHAR
argument_list|)
expr_stmt|;
name|p
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|p
operator|->
name|constant
operator|.
name|ccp
operator|=
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|l
operator|>=
literal|0
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|v
operator|++
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|mkcxcon
parameter_list|(
name|realp
parameter_list|,
name|imagp
parameter_list|)
specifier|register
name|expptr
name|realp
decl_stmt|,
name|imagp
decl_stmt|;
block|{
name|int
name|rtype
decl_stmt|,
name|itype
decl_stmt|;
specifier|register
name|Constp
name|p
decl_stmt|;
name|rtype
operator|=
name|realp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|itype
operator|=
name|imagp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|realp
argument_list|)
operator|&&
name|ISNUMERIC
argument_list|(
name|rtype
argument_list|)
operator|&&
name|ISCONST
argument_list|(
name|imagp
argument_list|)
operator|&&
name|ISNUMERIC
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|p
operator|=
name|mkconst
argument_list|(
operator|(
name|rtype
operator|==
name|TYDREAL
operator|||
name|itype
operator|==
name|TYDREAL
operator|)
condition|?
name|TYDCOMPLEX
else|:
name|TYCOMPLEX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
name|p
operator|->
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|=
name|realp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
else|else
name|p
operator|->
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|=
name|realp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ISINT
argument_list|(
name|itype
argument_list|)
condition|)
name|p
operator|->
name|constant
operator|.
name|cd
index|[
literal|1
index|]
operator|=
name|imagp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
else|else
name|p
operator|->
name|constant
operator|.
name|cd
index|[
literal|1
index|]
operator|=
name|imagp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"invalid complex constant"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|Constp
operator|)
name|errnode
argument_list|()
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|realp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|imagp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|errnode
parameter_list|()
block|{
name|struct
name|Errorblock
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Errorblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TERROR
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|TYERROR
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|mkconv
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
specifier|register
name|expptr
name|q
decl_stmt|;
name|Addrp
name|r
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|int
name|pt
decl_stmt|;
name|expptr
name|opconv
parameter_list|()
function_decl|;
if|if
condition|(
name|t
operator|==
name|TYUNKNOWN
operator|||
name|t
operator|==
name|TYERROR
condition|)
name|badtype
argument_list|(
literal|"mkconv"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pt
operator|=
name|p
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|pt
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
name|pt
operator|==
name|TYCHAR
operator|&&
name|ISNUMERIC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"implicit conversion of character to numeric type"
argument_list|)
expr_stmt|;
comment|/* 	 * Ugly kluge to copy character values into numerics. 	 */
name|s
operator|=
name|mkaltemp
argument_list|(
name|t
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|r
operator|->
name|vtype
operator|=
name|TYCHAR
expr_stmt|;
name|r
operator|->
name|varleng
operator|=
name|typesize
index|[
name|t
index|]
expr_stmt|;
name|r
operator|->
name|vleng
operator|=
name|mkintcon
argument_list|(
name|r
operator|->
name|varleng
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|r
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|q
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
if|#
directive|if
name|SZADDR
operator|>
name|SZSHORT
if|if
condition|(
name|pt
operator|==
name|TYADDR
operator|&&
name|t
operator|==
name|TYSHORT
condition|)
block|{
name|err
argument_list|(
literal|"insufficient precision to hold address type"
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pt
operator|==
name|TYADDR
operator|&&
name|ISNUMERIC
argument_list|(
name|t
argument_list|)
condition|)
name|warn
argument_list|(
literal|"implicit conversion of address to numeric type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|p
argument_list|)
operator|&&
name|pt
operator|!=
name|TYADDR
condition|)
block|{
name|q
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|consconv
argument_list|(
name|t
argument_list|,
operator|&
operator|(
name|q
operator|->
name|constblock
operator|.
name|constant
operator|)
argument_list|,
name|p
operator|->
name|constblock
operator|.
name|vtype
argument_list|,
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|TARGET
operator|==
name|PDP11
elseif|else
if|if
condition|(
name|ISINT
argument_list|(
name|t
argument_list|)
operator|&&
name|pt
operator|==
name|TYCHAR
condition|)
block|{
name|q
operator|=
name|mkexpr
argument_list|(
name|OPBITAND
argument_list|,
name|opconv
argument_list|(
name|p
argument_list|,
name|TYSHORT
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|255
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TYLONG
condition|)
name|q
operator|=
name|opconv
argument_list|(
name|q
argument_list|,
name|TYLONG
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
name|q
operator|=
name|opconv
argument_list|(
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TYCHAR
condition|)
name|q
operator|->
name|constblock
operator|.
name|vleng
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/* intrinsic conversions */
end_comment

begin_function
name|expptr
name|intrconv
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
specifier|register
name|expptr
name|q
decl_stmt|;
specifier|register
name|int
name|pt
decl_stmt|;
name|expptr
name|opconv
parameter_list|()
function_decl|;
if|if
condition|(
name|t
operator|==
name|TYUNKNOWN
operator|||
name|t
operator|==
name|TYERROR
condition|)
name|badtype
argument_list|(
literal|"intrconv"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pt
operator|=
name|p
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|pt
condition|)
return|return
operator|(
name|p
operator|)
return|;
elseif|else
if|if
condition|(
name|ISCONST
argument_list|(
name|p
argument_list|)
operator|&&
name|pt
operator|!=
name|TYADDR
condition|)
block|{
name|q
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|consconv
argument_list|(
name|t
argument_list|,
operator|&
operator|(
name|q
operator|->
name|constblock
operator|.
name|constant
operator|)
argument_list|,
name|p
operator|->
name|constblock
operator|.
name|vtype
argument_list|,
operator|&
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|TARGET
operator|==
name|PDP11
elseif|else
if|if
condition|(
name|ISINT
argument_list|(
name|t
argument_list|)
operator|&&
name|pt
operator|==
name|TYCHAR
condition|)
block|{
name|q
operator|=
name|mkexpr
argument_list|(
name|OPBITAND
argument_list|,
name|opconv
argument_list|(
name|p
argument_list|,
name|TYSHORT
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|255
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TYLONG
condition|)
name|q
operator|=
name|opconv
argument_list|(
name|q
argument_list|,
name|TYLONG
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
name|q
operator|=
name|opconv
argument_list|(
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TYCHAR
condition|)
name|q
operator|->
name|constblock
operator|.
name|vleng
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|opconv
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|)
name|expptr
name|p
decl_stmt|;
name|int
name|t
decl_stmt|;
block|{
specifier|register
name|expptr
name|q
decl_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|OPCONV
argument_list|,
name|p
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|addrof
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
return|return
operator|(
name|mkexpr
argument_list|(
name|OPADDR
argument_list|,
name|p
argument_list|,
name|PNULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|tagptr
name|cpexpr
parameter_list|(
name|p
parameter_list|)
specifier|register
name|tagptr
name|p
decl_stmt|;
block|{
specifier|register
name|tagptr
name|e
decl_stmt|;
name|int
name|tag
decl_stmt|;
specifier|register
name|chainp
name|ep
decl_stmt|,
name|pp
decl_stmt|;
name|tagptr
name|cpblock
parameter_list|()
function_decl|;
specifier|static
name|int
name|blksize
index|[ ]
init|=
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Nameblock
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Constblock
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Exprblock
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Addrblock
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Tempblock
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Primblock
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Listblock
argument_list|)
block|,
expr|sizeof
operator|(
expr|struct
name|Errorblock
operator|)
block|}
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|tag
operator|=
name|p
operator|->
name|tag
operator|)
operator|==
name|TNAME
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|e
operator|=
name|cpblock
argument_list|(
name|blksize
index|[
name|p
operator|->
name|tag
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
if|if
condition|(
name|e
operator|->
name|constblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
name|e
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ccp
operator|=
name|copyn
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|e
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ccp
argument_list|)
argument_list|,
name|e
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ccp
argument_list|)
expr_stmt|;
name|e
operator|->
name|constblock
operator|.
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|constblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
block|}
case|case
name|TERROR
case|:
break|break;
case|case
name|TEXPR
case|:
name|e
operator|->
name|exprblock
operator|.
name|leftp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|rightp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|e
operator|->
name|addrblock
operator|.
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|addrblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLIST
case|:
if|if
condition|(
name|pp
operator|=
name|p
operator|->
name|listblock
operator|.
name|listp
condition|)
block|{
name|ep
operator|=
name|e
operator|->
name|listblock
operator|.
name|listp
operator|=
name|mkchain
argument_list|(
name|cpexpr
argument_list|(
name|pp
operator|->
name|datap
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|pp
operator|->
name|nextp
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|nextp
control|)
name|ep
operator|=
name|ep
operator|->
name|nextp
operator|=
name|mkchain
argument_list|(
name|cpexpr
argument_list|(
name|pp
operator|->
name|datap
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TADDR
case|:
name|e
operator|->
name|addrblock
operator|.
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|addrblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|e
operator|->
name|addrblock
operator|.
name|memoffset
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
name|e
operator|->
name|addrblock
operator|.
name|istemp
operator|=
name|NO
expr_stmt|;
break|break;
case|case
name|TTEMP
case|:
name|e
operator|->
name|tempblock
operator|.
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|tempblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|e
operator|->
name|tempblock
operator|.
name|istemp
operator|=
name|NO
expr_stmt|;
break|break;
case|case
name|TPRIM
case|:
name|e
operator|->
name|primblock
operator|.
name|argsp
operator|=
operator|(
expr|struct
name|Listblock
operator|*
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|primblock
operator|.
name|argsp
argument_list|)
expr_stmt|;
name|e
operator|->
name|primblock
operator|.
name|fcharp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|primblock
operator|.
name|fcharp
argument_list|)
expr_stmt|;
name|e
operator|->
name|primblock
operator|.
name|lcharp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|primblock
operator|.
name|lcharp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badtag
argument_list|(
literal|"cpexpr"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_expr_stmt
name|frexpr
argument_list|(
name|p
argument_list|)
specifier|register
name|tagptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|chainp
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
switch|switch
condition|(
name|p
operator|->
name|constblock
operator|.
name|vtype
condition|)
block|{
case|case
name|TYBITSTR
case|:
case|case
name|TYCHAR
case|:
case|case
name|TYHOLLERITH
case|:
name|free
argument_list|(
call|(
name|charptr
call|)
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ccp
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TADDR
case|:
if|if
condition|(
operator|!
name|optimflag
operator|&&
name|p
operator|->
name|addrblock
operator|.
name|istemp
condition|)
block|{
name|frtemp
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|frexpr
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TTEMP
case|:
name|frexpr
argument_list|(
name|p
operator|->
name|tempblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
break|break;
case|case
name|TERROR
case|:
break|break;
case|case
name|TNAME
case|:
return|return;
case|case
name|TPRIM
case|:
name|frexpr
argument_list|(
name|p
operator|->
name|primblock
operator|.
name|argsp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|primblock
operator|.
name|fcharp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|primblock
operator|.
name|lcharp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEXPR
case|:
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
condition|)
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
condition|)
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLIST
case|:
for|for
control|(
name|q
operator|=
name|p
operator|->
name|listblock
operator|.
name|listp
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
name|frexpr
argument_list|(
name|q
operator|->
name|datap
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
operator|(
name|p
operator|->
name|listblock
operator|.
name|listp
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badtag
argument_list|(
literal|"frexpr"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* fix up types in expression; replace subtrees and convert    names to address blocks */
end_comment

begin_function
name|expptr
name|fixtype
parameter_list|(
name|p
parameter_list|)
specifier|register
name|tagptr
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
case|case
name|TADDR
case|:
name|p
operator|->
name|addrblock
operator|.
name|memoffset
operator|=
name|fixtype
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
case|case
name|TTEMP
case|:
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
case|case
name|TERROR
case|:
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
default|default:
name|badtag
argument_list|(
literal|"fixtype"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
case|case
name|TEXPR
case|:
return|return
operator|(
name|fixexpr
argument_list|(
name|p
argument_list|)
operator|)
return|;
case|case
name|TLIST
case|:
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
case|case
name|TPRIM
case|:
if|if
condition|(
name|p
operator|->
name|primblock
operator|.
name|argsp
operator|&&
name|p
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vclass
operator|!=
name|CLVAR
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vtype
operator|==
name|TYSUBR
condition|)
block|{
name|dclerr
argument_list|(
literal|"function invocation of subroutine"
argument_list|,
name|p
operator|->
name|primblock
operator|.
name|namep
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
else|else
return|return
operator|(
name|mkfunct
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|mklhs
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* special case tree transformations and cleanups of expression trees */
end_comment

begin_function
name|expptr
name|fixexpr
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Exprp
name|p
decl_stmt|;
block|{
name|expptr
name|lp
decl_stmt|;
specifier|register
name|expptr
name|rp
decl_stmt|;
specifier|register
name|expptr
name|q
decl_stmt|;
name|int
name|opcode
decl_stmt|,
name|ltype
decl_stmt|,
name|rtype
decl_stmt|,
name|ptype
decl_stmt|,
name|mtype
decl_stmt|;
name|expptr
name|lconst
decl_stmt|,
name|rconst
decl_stmt|;
name|expptr
name|mkpower
parameter_list|()
function_decl|;
if|if
condition|(
name|ISERROR
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
elseif|else
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"fixexpr"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|p
operator|->
name|opcode
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
condition|)
name|lconst
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
expr_stmt|;
else|else
name|lconst
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rightp
operator|&&
name|ISCONST
argument_list|(
name|p
operator|->
name|rightp
argument_list|)
condition|)
name|rconst
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|rightp
argument_list|)
expr_stmt|;
else|else
name|rconst
operator|=
name|NULL
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|leftp
operator|=
name|fixtype
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|ltype
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OPASSIGN
operator|&&
name|lp
operator|->
name|tag
operator|!=
name|TADDR
operator|&&
name|lp
operator|->
name|tag
operator|!=
name|TTEMP
condition|)
block|{
name|err
argument_list|(
literal|"left side of assignment must be variable"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|rightp
condition|)
block|{
name|rp
operator|=
name|p
operator|->
name|rightp
operator|=
name|fixtype
argument_list|(
name|p
operator|->
name|rightp
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|rp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|=
name|NULL
expr_stmt|;
name|rtype
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ltype
operator|==
name|TYERROR
operator|||
name|rtype
operator|==
name|TYERROR
condition|)
block|{
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|lconst
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rconst
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
comment|/* force folding if possible */
if|if
condition|(
name|ISCONST
argument_list|(
name|lp
argument_list|)
operator|&&
operator|(
name|rp
operator|==
name|NULL
operator|||
name|ISCONST
argument_list|(
name|rp
argument_list|)
operator|)
condition|)
block|{
name|q
operator|=
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|frexpr
argument_list|(
name|lconst
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rconst
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
comment|/* constants did not fold */
block|}
if|if
condition|(
operator|(
name|ptype
operator|=
name|cktype
argument_list|(
name|opcode
argument_list|,
name|ltype
argument_list|,
name|rtype
argument_list|)
operator|)
operator|==
name|TYERROR
condition|)
block|{
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|lconst
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rconst
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPCONCAT
case|:
if|if
condition|(
name|p
operator|->
name|vleng
operator|==
name|NULL
condition|)
name|p
operator|->
name|vleng
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|cpexpr
argument_list|(
name|lp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPASSIGN
case|:
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
if|if
condition|(
name|ltype
operator|==
name|rtype
condition|)
break|break;
if|if
condition|(
operator|!
name|rconst
operator|&&
name|ISREAL
argument_list|(
name|ltype
argument_list|)
operator|&&
name|ISREAL
argument_list|(
name|rtype
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|ltype
argument_list|)
operator|||
name|ISCOMPLEX
argument_list|(
name|rtype
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ONEOF
argument_list|(
name|ltype
argument_list|,
name|MSKADDR
operator||
name|MSKINT
argument_list|)
operator|&&
name|ONEOF
argument_list|(
name|rtype
argument_list|,
name|MSKADDR
operator||
name|MSKINT
argument_list|)
if|#
directive|if
name|FAMILY
operator|==
name|PCC
operator|&&
name|typesize
index|[
name|ltype
index|]
operator|>=
name|typesize
index|[
name|rtype
index|]
condition|)
else|#
directive|else
operator|&&
name|typesize
index|[
name|ltype
index|]
operator|==
name|typesize
index|[
name|rtype
index|]
block|)
endif|#
directive|endif
break|break;
if|if
condition|(
name|rconst
condition|)
block|{
name|p
operator|->
name|rightp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|cpexpr
argument_list|(
name|rconst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|rightp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPSLASH
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|rtype
argument_list|)
condition|)
block|{
name|p
operator|=
operator|(
name|Exprp
operator|)
name|call2
argument_list|(
name|ptype
argument_list|,
name|ptype
operator|==
name|TYCOMPLEX
condition|?
literal|"c_div"
else|:
literal|"z_div"
argument_list|,
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|lp
argument_list|)
argument_list|,
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
case|case
name|OPSTAR
case|:
case|case
name|OPMOD
case|:
if|if
condition|(
name|ptype
operator|==
name|TYDREAL
operator|&&
operator|(
operator|(
name|ltype
operator|==
name|TYREAL
operator|&&
operator|!
name|lconst
operator|)
operator|||
operator|(
name|rtype
operator|==
name|TYREAL
operator|&&
operator|!
name|rconst
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|ptype
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ltype
operator|!=
name|ptype
condition|)
if|if
condition|(
name|lconst
condition|)
block|{
name|p
operator|->
name|leftp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|cpexpr
argument_list|(
name|lconst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|leftp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|lp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|!=
name|ptype
condition|)
if|if
condition|(
name|rconst
condition|)
block|{
name|p
operator|->
name|rightp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|cpexpr
argument_list|(
name|rconst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|rightp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPPOWER
case|:
return|return
operator|(
name|mkpower
argument_list|(
name|p
argument_list|)
operator|)
return|;
case|case
name|OPLT
case|:
case|case
name|OPLE
case|:
case|case
name|OPGT
case|:
case|case
name|OPGE
case|:
case|case
name|OPEQ
case|:
case|case
name|OPNE
case|:
if|if
condition|(
name|ltype
operator|==
name|rtype
condition|)
break|break;
name|mtype
operator|=
name|cktype
argument_list|(
name|OPMINUS
argument_list|,
name|ltype
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtype
operator|==
name|TYDREAL
operator|&&
operator|(
operator|(
name|ltype
operator|==
name|TYREAL
operator|&&
operator|!
name|lconst
operator|)
operator|||
operator|(
name|rtype
operator|==
name|TYREAL
operator|&&
operator|!
name|rconst
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|mtype
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ltype
operator|!=
name|mtype
condition|)
if|if
condition|(
name|lconst
condition|)
block|{
name|p
operator|->
name|leftp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|mtype
argument_list|,
name|cpexpr
argument_list|(
name|lconst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|leftp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|mtype
argument_list|,
name|lp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|!=
name|mtype
condition|)
if|if
condition|(
name|rconst
condition|)
block|{
name|p
operator|->
name|rightp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|mtype
argument_list|,
name|cpexpr
argument_list|(
name|rconst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|rightp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|mtype
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONV
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
block|{
name|ptype
operator|=
name|cktype
argument_list|(
name|OPCONV
argument_list|,
name|p
operator|->
name|vtype
argument_list|,
name|ltype
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rightp
condition|)
name|ptype
operator|=
name|cktype
argument_list|(
name|OPCONV
argument_list|,
name|ptype
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
break|break;
block|}
name|ptype
operator|=
name|cktype
argument_list|(
name|OPCONV
argument_list|,
name|p
operator|->
name|vtype
argument_list|,
name|ltype
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCOMMA
condition|)
block|{
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|Exprp
operator|)
name|lp
expr_stmt|;
block|}
break|break;
case|case
name|OPADDR
case|:
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPADDR
condition|)
name|fatal
argument_list|(
literal|"addr of addr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCOMMA
case|:
case|case
name|OPQUEST
case|:
case|case
name|OPCOLON
case|:
break|break;
case|case
name|OPPAREN
case|:
name|p
operator|->
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|lp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPMIN
case|:
case|case
name|OPMAX
case|:
name|ptype
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
break|break;
default|default:
break|break;
block|}
end_function

begin_expr_stmt
name|p
operator|->
name|vtype
operator|=
name|ptype
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frexpr
argument_list|(
name|lconst
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frexpr
argument_list|(
name|rconst
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
end_return

begin_escape
unit|}
end_escape

begin_if
if|#
directive|if
name|SZINT
operator|<
name|SZLONG
end_if

begin_comment
comment|/*    for efficient subscripting, replace long ints by shorts    in easy places */
end_comment

begin_expr_stmt
unit|expptr
name|shorten
argument_list|(
name|p
argument_list|)
specifier|register
name|expptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|expptr
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|!=
name|TYLONG
condition|)
return|return
operator|(
name|p
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TERROR
case|:
case|case
name|TLIST
case|:
return|return
operator|(
name|p
operator|)
return|;
case|case
name|TCONST
case|:
case|case
name|TADDR
case|:
return|return
operator|(
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|p
argument_list|)
operator|)
return|;
case|case
name|TEXPR
case|:
break|break;
default|default:
name|badtag
argument_list|(
literal|"shorten"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
case|case
name|OPSTAR
case|:
name|q
operator|=
name|shorten
argument_list|(
name|cpexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYINT
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|shorten
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYLONG
condition|)
name|frexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
block|{
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|vtype
operator|=
name|TYINT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OPNEG
case|:
case|case
name|OPPAREN
case|:
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|shorten
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYINT
condition|)
name|p
operator|->
name|exprblock
operator|.
name|vtype
operator|=
name|TYINT
expr_stmt|;
break|break;
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
name|p
operator|=
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* fix an argument list, taking due care for special first level cases */
end_comment

begin_macro
name|fixargs
argument_list|(
argument|doput
argument_list|,
argument|p0
argument_list|)
end_macro

begin_decl_stmt
name|int
name|doput
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* doput is true if the function is not intrinsic; 		   was used to decide whether to do a putconst, 		   but this is no longer done here (Feb82)*/
end_comment

begin_decl_stmt
name|struct
name|Listblock
modifier|*
name|p0
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|chainp
name|p
decl_stmt|;
specifier|register
name|tagptr
name|q
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|int
name|qtag
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|Addrp
name|mkscalar
parameter_list|()
function_decl|;
name|nargs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p0
condition|)
for|for
control|(
name|p
operator|=
name|p0
operator|->
name|listp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
operator|++
name|nargs
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|datap
expr_stmt|;
name|qtag
operator|=
name|q
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|qtag
operator|==
name|TCONST
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|constblock
operator|.
name|vtype
operator|==
name|TYSHORT
condition|)
name|q
operator|=
operator|(
name|tagptr
operator|)
name|mkconv
argument_list|(
name|tyint
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|p
operator|->
name|datap
operator|=
name|q
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtag
operator|==
name|TPRIM
operator|&&
name|q
operator|->
name|primblock
operator|.
name|argsp
operator|==
literal|0
operator|&&
name|q
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vclass
operator|==
name|CLPROC
condition|)
name|p
operator|->
name|datap
operator|=
operator|(
name|tagptr
operator|)
name|mkaddr
argument_list|(
name|q
operator|->
name|primblock
operator|.
name|namep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qtag
operator|==
name|TPRIM
operator|&&
name|q
operator|->
name|primblock
operator|.
name|argsp
operator|==
literal|0
operator|&&
name|q
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vdim
operator|!=
name|NULL
condition|)
name|p
operator|->
name|datap
operator|=
operator|(
name|tagptr
operator|)
name|mkscalar
argument_list|(
name|q
operator|->
name|primblock
operator|.
name|namep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qtag
operator|==
name|TPRIM
operator|&&
name|q
operator|->
name|primblock
operator|.
name|argsp
operator|==
literal|0
operator|&&
name|q
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vdovar
operator|&&
operator|(
name|t
operator|=
operator|(
name|tagptr
operator|)
name|memversion
argument_list|(
name|q
operator|->
name|primblock
operator|.
name|namep
argument_list|)
operator|)
condition|)
name|p
operator|->
name|datap
operator|=
operator|(
name|tagptr
operator|)
name|fixtype
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|datap
operator|=
operator|(
name|tagptr
operator|)
name|fixtype
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nargs
operator|)
return|;
block|}
end_block

begin_function
name|Addrp
name|mkscalar
parameter_list|(
name|np
parameter_list|)
specifier|register
name|Namep
name|np
decl_stmt|;
block|{
specifier|register
name|Addrp
name|ap
decl_stmt|;
name|vardcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|ap
operator|=
name|mkaddr
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|VAX
comment|/* on the VAX, prolog causes array arguments 	   to point at the (0,...,0) element, except when 	   subscript checking is on 	*/
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
operator|!
name|checksubs
operator|&&
operator|!
name|sdbflag
operator|&&
name|np
operator|->
name|vstg
operator|==
name|STGARG
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|checksubs
operator|&&
name|np
operator|->
name|vstg
operator|==
name|STGARG
condition|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Dimblock
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|np
operator|->
name|vdim
expr_stmt|;
name|frexpr
argument_list|(
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
name|ap
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
operator|(
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
condition|?
name|cpexpr
argument_list|(
name|np
operator|->
name|vleng
argument_list|)
else|:
operator|(
name|tagptr
operator|)
name|ICON
argument_list|(
name|typesize
index|[
name|np
operator|->
name|vtype
index|]
argument_list|)
operator|)
argument_list|,
name|cpexpr
argument_list|(
name|dp
operator|->
name|baseoffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|ap
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|mkfunct
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Primblock
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|Entrypoint
modifier|*
name|ep
decl_stmt|;
name|Addrp
name|ap
decl_stmt|;
name|struct
name|Extsym
modifier|*
name|extp
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|expptr
name|q
decl_stmt|;
name|expptr
name|intrcall
argument_list|()
decl_stmt|,
name|stfcall
argument_list|()
decl_stmt|;
name|int
name|k
decl_stmt|,
name|nargs
decl_stmt|;
name|int
name|class
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TPRIM
condition|)
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
name|np
operator|=
name|p
operator|->
name|namep
expr_stmt|;
name|class
operator|=
name|np
operator|->
name|vclass
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLUNKNOWN
condition|)
block|{
name|np
operator|->
name|vclass
operator|=
name|class
operator|=
name|CLPROC
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vstg
operator|==
name|STGUNKNOWN
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|vtype
operator|!=
name|TYSUBR
operator|&&
operator|(
name|k
operator|=
name|intrfunct
argument_list|(
name|np
operator|->
name|varname
argument_list|)
operator|)
condition|)
block|{
name|np
operator|->
name|vstg
operator|=
name|STGINTR
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|k
expr_stmt|;
name|np
operator|->
name|vprocclass
operator|=
name|PINTRINSIC
expr_stmt|;
block|}
else|else
block|{
name|extp
operator|=
name|mkext
argument_list|(
name|varunder
argument_list|(
name|VL
argument_list|,
name|np
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
name|extp
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
name|np
operator|->
name|vstg
operator|=
name|STGEXT
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|extp
operator|-
name|extsymtab
expr_stmt|;
name|np
operator|->
name|vprocclass
operator|=
name|PEXTERNAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|np
operator|->
name|vstg
operator|==
name|STGARG
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|vtype
operator|!=
name|TYCHAR
operator|&&
operator|!
name|ftn66flag
condition|)
name|warn
argument_list|(
literal|"Dummy procedure not declared EXTERNAL. Code may be wrong."
argument_list|)
expr_stmt|;
name|np
operator|->
name|vprocclass
operator|=
name|PEXTERNAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|class
operator|!=
name|CLPROC
condition|)
name|fatali
argument_list|(
literal|"invalid class code %d for function"
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fcharp
operator|||
name|p
operator|->
name|lcharp
condition|)
block|{
name|err
argument_list|(
literal|"no substring of function call"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|impldcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|fixargs
argument_list|(
name|np
operator|->
name|vprocclass
operator|!=
name|PINTRINSIC
argument_list|,
name|p
operator|->
name|argsp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|np
operator|->
name|vprocclass
condition|)
block|{
case|case
name|PEXTERNAL
case|:
name|ap
operator|=
name|mkaddr
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|call
label|:
name|q
operator|=
name|mkexpr
argument_list|(
name|OPCALL
argument_list|,
name|ap
argument_list|,
name|p
operator|->
name|argsp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|->
name|exprblock
operator|.
name|vtype
operator|=
name|np
operator|->
name|vtype
operator|)
operator|==
name|TYUNKNOWN
condition|)
block|{
name|err
argument_list|(
literal|"attempt to use untyped function"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|np
operator|->
name|vleng
condition|)
name|q
operator|->
name|exprblock
operator|.
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|np
operator|->
name|vleng
argument_list|)
expr_stmt|;
break|break;
case|case
name|PINTRINSIC
case|:
name|q
operator|=
name|intrcall
argument_list|(
name|np
argument_list|,
name|p
operator|->
name|argsp
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
break|break;
case|case
name|PSTFUNCT
case|:
name|q
operator|=
name|stfcall
argument_list|(
name|np
argument_list|,
name|p
operator|->
name|argsp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTHISPROC
case|:
name|warn
argument_list|(
literal|"recursive call"
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|entries
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|entnextp
control|)
if|if
condition|(
name|ep
operator|->
name|enamep
operator|==
name|np
condition|)
break|break;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"mkfunct: impossible recursion"
argument_list|)
expr_stmt|;
name|ap
operator|=
name|builtin
argument_list|(
name|np
operator|->
name|vtype
argument_list|,
name|varstr
argument_list|(
name|XL
argument_list|,
name|ep
operator|->
name|entryname
operator|->
name|extname
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|call
goto|;
default|default:
name|fatali
argument_list|(
literal|"mkfunct: impossible vprocclass %d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|np
operator|->
name|vprocclass
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
name|error
label|:
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|expptr
name|stfcall
parameter_list|(
name|np
parameter_list|,
name|actlist
parameter_list|)
name|Namep
name|np
decl_stmt|;
name|struct
name|Listblock
modifier|*
name|actlist
decl_stmt|;
block|{
specifier|register
name|chainp
name|actuals
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|chainp
name|oactp
decl_stmt|,
name|formals
decl_stmt|;
name|int
name|type
decl_stmt|;
name|expptr
name|q
decl_stmt|,
name|rhs
decl_stmt|,
name|ap
decl_stmt|;
name|Namep
name|tnp
decl_stmt|;
specifier|register
name|struct
name|Rplblock
modifier|*
name|rp
decl_stmt|;
name|struct
name|Rplblock
modifier|*
name|tlist
decl_stmt|;
if|if
condition|(
name|actlist
condition|)
block|{
name|actuals
operator|=
name|actlist
operator|->
name|listp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|actlist
argument_list|)
expr_stmt|;
block|}
else|else
name|actuals
operator|=
name|NULL
expr_stmt|;
name|oactp
operator|=
name|actuals
expr_stmt|;
name|nargs
operator|=
literal|0
expr_stmt|;
name|tlist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|np
operator|->
name|vtype
operator|)
operator|==
name|TYUNKNOWN
condition|)
block|{
name|err
argument_list|(
literal|"attempt to use untyped statement function"
argument_list|)
expr_stmt|;
name|q
operator|=
name|errnode
argument_list|()
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|formals
operator|=
call|(
name|chainp
call|)
argument_list|(
name|np
operator|->
name|varxptr
operator|.
name|vstfdesc
operator|->
name|datap
argument_list|)
expr_stmt|;
name|rhs
operator|=
call|(
name|expptr
call|)
argument_list|(
name|np
operator|->
name|varxptr
operator|.
name|vstfdesc
operator|->
name|nextp
argument_list|)
expr_stmt|;
comment|/* copy actual arguments into temporaries */
while|while
condition|(
name|actuals
operator|!=
name|NULL
operator|&&
name|formals
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|=
name|ALLOC
argument_list|(
name|Rplblock
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rplnp
operator|=
name|tnp
operator|=
call|(
name|Namep
call|)
argument_list|(
name|formals
operator|->
name|datap
argument_list|)
expr_stmt|;
name|ap
operator|=
name|fixtype
argument_list|(
name|actuals
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tnp
operator|->
name|vtype
operator|==
name|ap
operator|->
name|headblock
operator|.
name|vtype
operator|&&
name|tnp
operator|->
name|vtype
operator|!=
name|TYCHAR
operator|&&
operator|(
name|ap
operator|->
name|tag
operator|==
name|TCONST
operator|||
name|ap
operator|->
name|tag
operator|==
name|TADDR
operator|||
name|ap
operator|->
name|tag
operator|==
name|TTEMP
operator|)
condition|)
block|{
name|rp
operator|->
name|rplvp
operator|=
operator|(
name|expptr
operator|)
name|ap
expr_stmt|;
name|rp
operator|->
name|rplxp
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|rpltag
operator|=
name|ap
operator|->
name|tag
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|->
name|rplvp
operator|=
operator|(
name|expptr
operator|)
name|mktemp
argument_list|(
name|tnp
operator|->
name|vtype
argument_list|,
name|tnp
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rplxp
operator|=
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|rplvp
argument_list|)
argument_list|,
name|ap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rp
operator|->
name|rpltag
operator|=
name|rp
operator|->
name|rplxp
operator|->
name|tag
operator|)
operator|==
name|TERROR
condition|)
name|err
argument_list|(
literal|"disagreement of argument types in statement function call"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tnp
operator|->
name|vtype
operator|!=
name|ap
operator|->
name|headblock
operator|.
name|vtype
condition|)
name|warn
argument_list|(
literal|"argument type mismatch in statement function"
argument_list|)
expr_stmt|;
block|}
name|rp
operator|->
name|rplnextp
operator|=
name|tlist
expr_stmt|;
name|tlist
operator|=
name|rp
expr_stmt|;
name|actuals
operator|=
name|actuals
operator|->
name|nextp
expr_stmt|;
name|formals
operator|=
name|formals
operator|->
name|nextp
expr_stmt|;
operator|++
name|nargs
expr_stmt|;
block|}
if|if
condition|(
name|actuals
operator|!=
name|NULL
operator|||
name|formals
operator|!=
name|NULL
condition|)
name|err
argument_list|(
literal|"statement function definition and argument list differ"
argument_list|)
expr_stmt|;
comment|/*    now push down names involved in formal argument list, then    evaluate rhs of statement function definition in this environment */
if|if
condition|(
name|tlist
condition|)
comment|/* put tlist in front of the rpllist */
block|{
for|for
control|(
name|rp
operator|=
name|tlist
init|;
name|rp
operator|->
name|rplnextp
condition|;
name|rp
operator|=
name|rp
operator|->
name|rplnextp
control|)
empty_stmt|;
name|rp
operator|->
name|rplnextp
operator|=
name|rpllist
expr_stmt|;
name|rpllist
operator|=
name|tlist
expr_stmt|;
block|}
name|q
operator|=
operator|(
name|expptr
operator|)
name|mkconv
argument_list|(
name|type
argument_list|,
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now generate the tree ( t1=a1, (t2=a2,... , f))))) */
while|while
condition|(
operator|--
name|nargs
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|rpllist
operator|->
name|rplxp
condition|)
name|q
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|rpllist
operator|->
name|rplxp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rpllist
operator|->
name|rplnextp
expr_stmt|;
name|frexpr
argument_list|(
name|rpllist
operator|->
name|rplvp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rpllist
argument_list|)
expr_stmt|;
name|rpllist
operator|=
name|rp
expr_stmt|;
block|}
name|ret
label|:
name|frchain
argument_list|(
operator|&
name|oactp
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|Addrp
name|mkplace
parameter_list|(
name|np
parameter_list|)
specifier|register
name|Namep
name|np
decl_stmt|;
block|{
specifier|register
name|Addrp
name|s
decl_stmt|;
specifier|register
name|struct
name|Rplblock
modifier|*
name|rp
decl_stmt|;
name|int
name|regn
decl_stmt|;
comment|/* is name on the replace list? */
for|for
control|(
name|rp
operator|=
name|rpllist
init|;
name|rp
condition|;
name|rp
operator|=
name|rp
operator|->
name|rplnextp
control|)
block|{
if|if
condition|(
name|np
operator|==
name|rp
operator|->
name|rplnp
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|rpltag
operator|==
name|TNAME
condition|)
block|{
name|np
operator|=
call|(
name|Namep
call|)
argument_list|(
name|rp
operator|->
name|rplvp
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
return|return
operator|(
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|rplvp
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* is variable a DO index in a register ? */
if|if
condition|(
name|np
operator|->
name|vdovar
operator|&&
operator|(
operator|(
name|regn
operator|=
name|inregister
argument_list|(
name|np
argument_list|)
operator|)
operator|>=
literal|0
operator|)
condition|)
if|if
condition|(
name|np
operator|->
name|vtype
operator|==
name|TYERROR
condition|)
return|return
operator|(
operator|(
name|Addrp
operator|)
name|errnode
argument_list|()
operator|)
return|;
else|else
block|{
name|s
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|s
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|s
operator|->
name|vstg
operator|=
name|STGREG
expr_stmt|;
name|s
operator|->
name|vtype
operator|=
name|TYIREG
expr_stmt|;
name|s
operator|->
name|issaved
operator|=
name|np
operator|->
name|vsave
expr_stmt|;
name|s
operator|->
name|memno
operator|=
name|regn
expr_stmt|;
name|s
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
name|vardcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
name|mkaddr
argument_list|(
name|np
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|mklhs
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Primblock
modifier|*
name|p
decl_stmt|;
block|{
name|expptr
name|suboffset
parameter_list|()
function_decl|;
name|expptr
name|ep
init|=
name|ENULL
decl_stmt|;
specifier|register
name|Addrp
name|s
decl_stmt|;
name|Namep
name|np
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TPRIM
condition|)
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
name|np
operator|=
name|p
operator|->
name|namep
expr_stmt|;
name|s
operator|=
name|mkplace
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tag
operator|!=
name|TADDR
operator|||
name|s
operator|->
name|vstg
operator|==
name|STGREG
condition|)
block|{
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|s
operator|)
return|;
block|}
comment|/* do the substring part */
if|if
condition|(
name|p
operator|->
name|fcharp
operator|||
name|p
operator|->
name|lcharp
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|vtype
operator|!=
name|TYCHAR
condition|)
name|errstr
argument_list|(
literal|"substring of noncharacter %s"
argument_list|,
name|varstr
argument_list|(
name|VL
argument_list|,
name|np
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
operator|->
name|lcharp
operator|==
name|NULL
condition|)
name|p
operator|->
name|lcharp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|s
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|s
operator|->
name|vleng
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fcharp
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|fcharp
operator|->
name|tag
operator|==
name|TPRIM
operator|&&
name|p
operator|->
name|lcharp
operator|->
name|tag
operator|==
name|TPRIM
operator|&&
name|p
operator|->
name|fcharp
operator|->
name|primblock
operator|.
name|namep
operator|==
name|p
operator|->
name|lcharp
operator|->
name|primblock
operator|.
name|namep
operator|&&
name|p
operator|->
name|fcharp
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
operator|&&
name|p
operator|->
name|lcharp
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
condition|)
comment|/* A trivial optimization -- upper == lower */
name|s
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
operator|->
name|fcharp
operator|->
name|tag
operator|==
name|TEXPR
operator|||
operator|(
name|p
operator|->
name|fcharp
operator|->
name|tag
operator|==
name|TPRIM
operator|&&
name|p
operator|->
name|fcharp
operator|->
name|primblock
operator|.
name|argsp
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ep
operator|=
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|p
operator|->
name|fcharp
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|fcharp
operator|=
operator|(
name|expptr
operator|)
name|mktemp
argument_list|(
name|ep
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|vleng
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|p
operator|->
name|lcharp
argument_list|,
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|fcharp
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|s
operator|->
name|vleng
operator|=
name|p
operator|->
name|lcharp
expr_stmt|;
block|}
block|}
comment|/* compute the address modified by subscripts */
name|s
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|s
operator|->
name|memoffset
argument_list|,
name|suboffset
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|argsp
argument_list|)
expr_stmt|;
name|p
operator|->
name|argsp
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|vleng
operator|=
name|fixtype
argument_list|(
name|s
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|s
operator|->
name|memoffset
operator|=
name|fixtype
argument_list|(
name|s
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
condition|)
comment|/* this code depends on memoffset being evaluated before vleng */
name|s
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|fcharp
argument_list|)
argument_list|,
name|ep
argument_list|)
argument_list|,
name|s
operator|->
name|memoffset
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|fcharp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|s
operator|)
return|;
block|}
end_function

begin_macro
name|deregister
argument_list|(
argument|np
argument_list|)
end_macro

begin_decl_stmt
name|Namep
name|np
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|nregvar
operator|>
literal|0
operator|&&
name|regnamep
index|[
name|nregvar
operator|-
literal|1
index|]
operator|==
name|np
condition|)
block|{
operator|--
name|nregvar
expr_stmt|;
if|#
directive|if
name|FAMILY
operator|==
name|DMR
name|putnreg
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_function
name|Addrp
name|memversion
parameter_list|(
name|np
parameter_list|)
specifier|register
name|Namep
name|np
decl_stmt|;
block|{
specifier|register
name|Addrp
name|s
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|vdovar
operator|==
name|NO
operator|||
operator|(
name|inregister
argument_list|(
name|np
argument_list|)
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|np
operator|->
name|vdovar
operator|=
name|NO
expr_stmt|;
name|s
operator|=
name|mkplace
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|vdovar
operator|=
name|YES
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|inregister
argument_list|(
name|np
argument_list|)
specifier|register
name|Namep
name|np
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregvar
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|regnamep
index|[
name|i
index|]
operator|==
name|np
condition|)
return|return
operator|(
name|regnum
index|[
name|i
index|]
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|enregister
argument_list|(
argument|np
argument_list|)
end_macro

begin_decl_stmt
name|Namep
name|np
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|inregister
argument_list|(
name|np
argument_list|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|YES
operator|)
return|;
if|if
condition|(
name|nregvar
operator|>=
name|maxregvar
condition|)
return|return
operator|(
name|NO
operator|)
return|;
name|vardcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|np
operator|->
name|vtype
argument_list|,
name|MSKIREG
argument_list|)
condition|)
block|{
name|regnamep
index|[
name|nregvar
operator|++
index|]
operator|=
name|np
expr_stmt|;
if|if
condition|(
name|nregvar
operator|>
name|highregvar
condition|)
name|highregvar
operator|=
name|nregvar
expr_stmt|;
if|#
directive|if
name|FAMILY
operator|==
name|DMR
name|putnreg
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|YES
operator|)
return|;
block|}
else|else
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_function
name|expptr
name|suboffset
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Primblock
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|expptr
name|size
decl_stmt|;
name|expptr
name|oftwo
parameter_list|()
function_decl|;
name|chainp
name|cp
decl_stmt|;
name|expptr
name|offp
decl_stmt|,
name|prod
decl_stmt|;
name|expptr
name|subcheck
parameter_list|()
function_decl|;
name|struct
name|Dimblock
modifier|*
name|dimp
decl_stmt|;
name|expptr
name|sub
index|[
name|MAXDIM
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
name|np
operator|=
name|p
operator|->
name|namep
expr_stmt|;
name|offp
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|argsp
condition|)
for|for
control|(
name|cp
operator|=
name|p
operator|->
name|argsp
operator|->
name|listp
init|;
name|cp
condition|;
operator|++
name|n
operator|,
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|sub
index|[
name|n
index|]
operator|=
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|cp
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|sub
index|[
name|n
index|]
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|errstr
argument_list|(
literal|"%s: non-integer subscript expression"
argument_list|,
name|varstr
argument_list|(
name|VL
argument_list|,
name|np
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Provide a substitute -- go on to find more errors */
name|frexpr
argument_list|(
name|sub
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|sub
index|[
name|n
index|]
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
name|maxdim
condition|)
block|{
name|char
name|str
index|[
literal|28
operator|+
name|VL
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s: more than %d subscripts"
argument_list|,
name|varstr
argument_list|(
name|VL
argument_list|,
name|np
operator|->
name|varname
argument_list|)
argument_list|,
name|maxdim
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|dimp
operator|=
name|np
operator|->
name|vdim
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|dimp
operator|==
name|NULL
condition|)
name|errstr
argument_list|(
literal|"%s: subscripts on scalar variable"
argument_list|,
name|varstr
argument_list|(
name|VL
argument_list|,
name|np
operator|->
name|varname
argument_list|)
argument_list|,
name|maxdim
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dimp
operator|&&
name|dimp
operator|->
name|ndim
operator|!=
name|n
condition|)
name|errstr
argument_list|(
literal|"wrong number of subscripts on %s"
argument_list|,
name|varstr
argument_list|(
name|VL
argument_list|,
name|np
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|prod
operator|=
name|sub
index|[
operator|--
name|n
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|prod
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|sub
index|[
name|n
index|]
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|prod
argument_list|,
name|cpexpr
argument_list|(
name|dimp
operator|->
name|dims
index|[
name|n
index|]
operator|.
name|dimsize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|VAX
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|checksubs
operator|||
name|np
operator|->
name|vstg
operator|!=
name|STGARG
operator|||
name|sdbflag
condition|)
else|#
directive|else
if|if
condition|(
name|checksubs
operator|||
name|np
operator|->
name|vstg
operator|!=
name|STGARG
condition|)
endif|#
directive|endif
name|prod
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|prod
argument_list|,
name|cpexpr
argument_list|(
name|dimp
operator|->
name|baseoffset
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|prod
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|prod
argument_list|,
name|cpexpr
argument_list|(
name|dimp
operator|->
name|baseoffset
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|checksubs
condition|)
name|prod
operator|=
name|subcheck
argument_list|(
name|np
argument_list|,
name|prod
argument_list|)
expr_stmt|;
name|size
operator|=
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
condition|?
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|np
operator|->
name|vleng
argument_list|)
else|:
name|ICON
argument_list|(
name|typesize
index|[
name|np
operator|->
name|vtype
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oftwo
argument_list|(
name|size
argument_list|)
condition|)
name|prod
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|prod
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|prod
operator|=
name|mkexpr
argument_list|(
name|OPLSHIFT
argument_list|,
name|prod
argument_list|,
name|oftwo
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|offp
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|offp
argument_list|,
name|prod
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|fcharp
operator|&&
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
name|offp
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|offp
argument_list|,
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|fcharp
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|offp
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|subcheck
parameter_list|(
name|np
parameter_list|,
name|p
parameter_list|)
name|Namep
name|np
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
name|struct
name|Dimblock
modifier|*
name|dimp
decl_stmt|;
name|expptr
name|t
decl_stmt|,
name|checkvar
decl_stmt|,
name|checkcond
decl_stmt|,
name|badcall
decl_stmt|;
name|dimp
operator|=
name|np
operator|->
name|vdim
expr_stmt|;
if|if
condition|(
name|dimp
operator|->
name|nelt
operator|==
name|NULL
condition|)
return|return
operator|(
name|p
operator|)
return|;
comment|/* don't check arrays with * bounds */
name|checkvar
operator|=
name|NULL
expr_stmt|;
name|checkcond
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ISICON
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|<
literal|0
condition|)
goto|goto
name|badsub
goto|;
if|if
condition|(
name|ISICON
argument_list|(
name|dimp
operator|->
name|nelt
argument_list|)
condition|)
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|<
name|dimp
operator|->
name|nelt
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
condition|)
return|return
operator|(
name|p
operator|)
return|;
else|else
goto|goto
name|badsub
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|p
operator|->
name|addrblock
operator|.
name|vstg
operator|==
name|STGREG
condition|)
block|{
name|checkvar
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|t
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|checkvar
operator|=
operator|(
name|expptr
operator|)
name|mktemp
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|checkvar
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|checkcond
operator|=
name|mkexpr
argument_list|(
name|OPLT
argument_list|,
name|t
argument_list|,
name|cpexpr
argument_list|(
name|dimp
operator|->
name|nelt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|p
argument_list|)
condition|)
name|checkcond
operator|=
name|mkexpr
argument_list|(
name|OPAND
argument_list|,
name|checkcond
argument_list|,
name|mkexpr
argument_list|(
name|OPLE
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|checkvar
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|badcall
operator|=
name|call4
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
literal|"s_rnge"
argument_list|,
name|mkstrcon
argument_list|(
name|VL
argument_list|,
name|np
operator|->
name|varname
argument_list|)
argument_list|,
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|cpexpr
argument_list|(
name|checkvar
argument_list|)
argument_list|)
argument_list|,
name|mkstrcon
argument_list|(
name|XL
argument_list|,
name|procname
argument_list|)
argument_list|,
name|ICON
argument_list|(
name|lineno
argument_list|)
argument_list|)
expr_stmt|;
name|badcall
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPCCALL
expr_stmt|;
name|p
operator|=
name|mkexpr
argument_list|(
name|OPQUEST
argument_list|,
name|checkcond
argument_list|,
name|mkexpr
argument_list|(
name|OPCOLON
argument_list|,
name|checkvar
argument_list|,
name|badcall
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
name|badsub
label|:
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|errstr
argument_list|(
literal|"subscript on variable %s out of range"
argument_list|,
name|varstr
argument_list|(
name|VL
argument_list|,
name|np
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ICON
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Addrp
name|mkaddr
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Namep
name|p
decl_stmt|;
block|{
name|struct
name|Extsym
modifier|*
name|extp
decl_stmt|;
specifier|register
name|Addrp
name|t
decl_stmt|;
name|Addrp
name|intraddr
parameter_list|()
function_decl|;
switch|switch
condition|(
name|p
operator|->
name|vstg
condition|)
block|{
case|case
name|STGUNKNOWN
case|:
if|if
condition|(
name|p
operator|->
name|vclass
operator|!=
name|CLPROC
condition|)
break|break;
name|extp
operator|=
name|mkext
argument_list|(
name|varunder
argument_list|(
name|VL
argument_list|,
name|p
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
name|extp
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
name|p
operator|->
name|vstg
operator|=
name|STGEXT
expr_stmt|;
name|p
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|extp
operator|-
name|extsymtab
expr_stmt|;
name|p
operator|->
name|vprocclass
operator|=
name|PEXTERNAL
expr_stmt|;
case|case
name|STGCOMMON
case|:
case|case
name|STGEXT
case|:
case|case
name|STGBSS
case|:
case|case
name|STGINIT
case|:
case|case
name|STGEQUIV
case|:
case|case
name|STGARG
case|:
case|case
name|STGLENG
case|:
case|case
name|STGAUTO
case|:
name|t
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|t
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|vclass
operator|==
name|CLPROC
operator|&&
name|p
operator|->
name|vprocclass
operator|==
name|PTHISPROC
condition|)
name|t
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
else|else
name|t
operator|->
name|vclass
operator|=
name|p
operator|->
name|vclass
expr_stmt|;
name|t
operator|->
name|vtype
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
name|t
operator|->
name|vstg
operator|=
name|p
operator|->
name|vstg
expr_stmt|;
name|t
operator|->
name|memno
operator|=
name|p
operator|->
name|vardesc
operator|.
name|varno
expr_stmt|;
name|t
operator|->
name|issaved
operator|=
name|p
operator|->
name|vsave
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|vdim
condition|)
name|t
operator|->
name|isarray
operator|=
name|YES
expr_stmt|;
name|t
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
name|p
operator|->
name|voffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|vleng
condition|)
block|{
name|t
operator|->
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISICON
argument_list|(
name|t
operator|->
name|vleng
argument_list|)
condition|)
name|t
operator|->
name|varleng
operator|=
name|t
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|vstg
operator|==
name|STGBSS
condition|)
name|t
operator|->
name|varsize
operator|=
name|p
operator|->
name|varsize
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|vstg
operator|==
name|STGEQUIV
condition|)
name|t
operator|->
name|varsize
operator|=
name|eqvclass
index|[
name|t
operator|->
name|memno
index|]
operator|.
name|eqvleng
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
case|case
name|STGINTR
case|:
return|return
operator|(
name|intraddr
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
comment|/*debug*/
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"mkaddr. vtype=%d, vclass=%d\n"
argument_list|,
name|p
operator|->
name|vtype
argument_list|,
name|p
operator|->
name|vclass
argument_list|)
expr_stmt|;
name|badstg
argument_list|(
literal|"mkaddr"
argument_list|,
name|p
operator|->
name|vstg
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|Addrp
name|mkarg
parameter_list|(
name|type
parameter_list|,
name|argno
parameter_list|)
name|int
name|type
decl_stmt|,
name|argno
decl_stmt|;
block|{
specifier|register
name|Addrp
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
name|p
operator|->
name|vstg
operator|=
operator|(
name|type
operator|==
name|TYLENG
condition|?
name|STGLENG
else|:
name|STGARG
operator|)
expr_stmt|;
name|p
operator|->
name|memno
operator|=
name|argno
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|expptr
name|mkprim
argument_list|(
name|v
argument_list|,
name|args
argument_list|,
name|substr
argument_list|)
decl|register union
block|{
name|struct
name|Paramblock
name|paramblock
decl_stmt|;
name|struct
name|Nameblock
name|nameblock
decl_stmt|;
name|struct
name|Headblock
name|headblock
decl_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|Listblock
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|chainp
name|substr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|Primblock
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|headblock
operator|.
name|vclass
operator|==
name|CLPARAM
condition|)
block|{
if|if
condition|(
name|args
operator|||
name|substr
condition|)
block|{
name|errstr
argument_list|(
literal|"no qualifiers on parameter name %s"
argument_list|,
name|varstr
argument_list|(
name|VL
argument_list|,
name|v
operator|->
name|paramblock
operator|.
name|varname
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|substr
condition|)
block|{
name|frexpr
argument_list|(
name|substr
operator|->
name|datap
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|substr
operator|->
name|nextp
operator|->
name|datap
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|substr
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|v
operator|->
name|paramblock
operator|.
name|paramval
argument_list|)
operator|)
return|;
block|}
name|p
operator|=
name|ALLOC
argument_list|(
name|Primblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TPRIM
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|v
operator|->
name|nameblock
operator|.
name|vtype
expr_stmt|;
name|p
operator|->
name|namep
operator|=
operator|(
name|Namep
operator|)
name|v
expr_stmt|;
name|p
operator|->
name|argsp
operator|=
name|args
expr_stmt|;
if|if
condition|(
name|substr
condition|)
block|{
name|p
operator|->
name|fcharp
operator|=
operator|(
name|expptr
operator|)
name|substr
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fcharp
operator|!=
name|ENULL
operator|&&
operator|!
name|ISINT
argument_list|(
name|p
operator|->
name|fcharp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|p
operator|->
name|fcharp
operator|=
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|p
operator|->
name|fcharp
argument_list|)
expr_stmt|;
name|p
operator|->
name|lcharp
operator|=
operator|(
name|expptr
operator|)
name|substr
operator|->
name|nextp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lcharp
operator|!=
name|ENULL
operator|&&
operator|!
name|ISINT
argument_list|(
name|p
operator|->
name|lcharp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|p
operator|->
name|lcharp
operator|=
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|p
operator|->
name|lcharp
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|substr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|vardcl
argument_list|(
name|v
argument_list|)
specifier|register
name|Namep
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|nelt
decl_stmt|;
name|struct
name|Dimblock
modifier|*
name|t
decl_stmt|;
name|Addrp
name|p
decl_stmt|;
name|expptr
name|neltp
decl_stmt|;
name|int
name|eltsize
decl_stmt|;
name|int
name|varsize
decl_stmt|;
name|int
name|tsize
decl_stmt|;
name|int
name|align
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|vdcldone
condition|)
return|return;
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLNAMELIST
condition|)
return|return;
if|if
condition|(
name|v
operator|->
name|vtype
operator|==
name|TYUNKNOWN
condition|)
name|impldcl
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|v
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vclass
operator|!=
name|CLVAR
operator|&&
name|v
operator|->
name|vprocclass
operator|!=
name|PTHISPROC
condition|)
block|{
name|dclerr
argument_list|(
literal|"used both as variable and non-variable"
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|v
operator|->
name|vstg
operator|==
name|STGUNKNOWN
condition|)
name|v
operator|->
name|vstg
operator|=
name|implstg
index|[
name|letter
argument_list|(
name|v
operator|->
name|varname
index|[
literal|0
index|]
argument_list|)
index|]
expr_stmt|;
switch|switch
condition|(
name|v
operator|->
name|vstg
condition|)
block|{
case|case
name|STGBSS
case|:
name|v
operator|->
name|vardesc
operator|.
name|varno
operator|=
operator|++
name|lastvarno
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vclass
operator|!=
name|CLVAR
condition|)
break|break;
name|nelt
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|v
operator|->
name|vdim
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|neltp
operator|=
name|t
operator|->
name|nelt
expr_stmt|;
if|if
condition|(
name|neltp
operator|&&
name|ISICON
argument_list|(
name|neltp
argument_list|)
condition|)
name|nelt
operator|=
name|neltp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
else|else
name|dclerr
argument_list|(
literal|"improperly dimensioned array"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
name|v
operator|->
name|vleng
operator|=
name|fixtype
argument_list|(
name|v
operator|->
name|vleng
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vleng
operator|==
name|NULL
condition|)
name|eltsize
operator|=
name|typesize
index|[
name|TYCHAR
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|ISICON
argument_list|(
name|v
operator|->
name|vleng
argument_list|)
condition|)
name|eltsize
operator|=
name|typesize
index|[
name|TYCHAR
index|]
operator|*
name|v
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vleng
operator|->
name|tag
operator|!=
name|TERROR
condition|)
block|{
name|errstr
argument_list|(
literal|"nonconstant string length on %s"
argument_list|,
name|varstr
argument_list|(
name|VL
argument_list|,
name|v
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
name|eltsize
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|eltsize
operator|=
name|typesize
index|[
name|v
operator|->
name|vtype
index|]
expr_stmt|;
name|v
operator|->
name|varsize
operator|=
name|nelt
operator|*
name|eltsize
expr_stmt|;
break|break;
case|case
name|STGAUTO
case|:
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLPROC
operator|&&
name|v
operator|->
name|vprocclass
operator|==
name|PTHISPROC
condition|)
break|break;
name|nelt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|=
name|v
operator|->
name|vdim
condition|)
if|if
condition|(
operator|(
name|neltp
operator|=
name|t
operator|->
name|nelt
operator|)
operator|&&
name|ISCONST
argument_list|(
name|neltp
argument_list|)
condition|)
name|nelt
operator|=
name|neltp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
else|else
name|dclerr
argument_list|(
literal|"adjustable automatic array"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|p
operator|=
name|autovar
argument_list|(
name|nelt
argument_list|,
name|v
operator|->
name|vtype
argument_list|,
name|v
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|v
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|p
operator|->
name|memno
expr_stmt|;
name|v
operator|->
name|voffset
operator|=
name|p
operator|->
name|memoffset
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|v
operator|->
name|vdcldone
operator|=
name|YES
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|impldcl
argument_list|(
name|p
argument_list|)
specifier|register
name|Namep
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
name|int
name|type
decl_stmt|,
name|leng
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|vdcldone
operator|||
operator|(
name|p
operator|->
name|vclass
operator|==
name|CLPROC
operator|&&
name|p
operator|->
name|vprocclass
operator|==
name|PINTRINSIC
operator|)
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|vtype
operator|==
name|TYUNKNOWN
condition|)
block|{
name|k
operator|=
name|letter
argument_list|(
name|p
operator|->
name|varname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
name|impltype
index|[
name|k
index|]
expr_stmt|;
name|leng
operator|=
name|implleng
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYUNKNOWN
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|vclass
operator|==
name|CLPROC
condition|)
name|dclerr
argument_list|(
literal|"attempt to use function of undefined type"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|dclerr
argument_list|(
literal|"attempt to use undefined variable"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYERROR
expr_stmt|;
name|leng
operator|=
literal|1
expr_stmt|;
block|}
name|settype
argument_list|(
name|p
argument_list|,
name|type
argument_list|,
name|leng
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|LOCAL
name|letter
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|-
literal|'a'
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ICONEQ
parameter_list|(
name|z
parameter_list|,
name|c
parameter_list|)
value|(ISICON(z)&& z->constblock.constant.ci==c)
end_define

begin_define
define|#
directive|define
name|COMMUTE
value|{ e = lp;  lp = rp;  rp = e; }
end_define

begin_function
name|expptr
name|mkexpr
parameter_list|(
name|opcode
parameter_list|,
name|lp
parameter_list|,
name|rp
parameter_list|)
name|int
name|opcode
decl_stmt|;
specifier|register
name|expptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
block|{
specifier|register
name|expptr
name|e
decl_stmt|,
name|e1
decl_stmt|;
name|int
name|etype
decl_stmt|;
name|int
name|ltype
decl_stmt|,
name|rtype
decl_stmt|;
name|int
name|ltag
decl_stmt|,
name|rtag
decl_stmt|;
name|expptr
name|q
decl_stmt|,
name|q1
decl_stmt|;
name|expptr
name|fold
parameter_list|()
function_decl|;
name|int
name|k
decl_stmt|;
name|ltype
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|ltag
operator|=
name|lp
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|rp
operator|&&
name|opcode
operator|!=
name|OPCALL
operator|&&
name|opcode
operator|!=
name|OPCCALL
condition|)
block|{
name|rtype
operator|=
name|rp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|rtag
operator|=
name|rp
operator|->
name|tag
expr_stmt|;
block|}
else|else
block|{
name|rtype
operator|=
literal|0
expr_stmt|;
name|rtag
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * Yuck.  Why can't we fold constants AFTER  * variables are implicitly declared???  */
if|if
condition|(
name|ltype
operator|==
name|TYUNKNOWN
operator|&&
name|ltag
operator|==
name|TPRIM
operator|&&
name|lp
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
condition|)
block|{
name|k
operator|=
name|letter
argument_list|(
name|lp
operator|->
name|primblock
operator|.
name|namep
operator|->
name|varname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ltype
operator|=
name|impltype
index|[
name|k
index|]
expr_stmt|;
block|}
if|if
condition|(
name|rtype
operator|==
name|TYUNKNOWN
operator|&&
name|rtag
operator|==
name|TPRIM
operator|&&
name|rp
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
condition|)
block|{
name|k
operator|=
name|letter
argument_list|(
name|rp
operator|->
name|primblock
operator|.
name|namep
operator|->
name|varname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|impltype
index|[
name|k
index|]
expr_stmt|;
block|}
comment|/*  * Eliminate all but the topmost OPPAREN operator when folding constants.  */
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPPAREN
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|tag
operator|==
name|TCONST
condition|)
block|{
name|q
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|lp
operator|=
name|q
expr_stmt|;
name|ltag
operator|=
name|TCONST
expr_stmt|;
name|ltype
operator|=
name|lp
operator|->
name|constblock
operator|.
name|vtype
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|&&
name|rp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|rp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPPAREN
operator|&&
name|rp
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|tag
operator|==
name|TCONST
condition|)
block|{
name|q
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|rp
operator|=
name|q
expr_stmt|;
name|rtag
operator|=
name|TCONST
expr_stmt|;
name|rtype
operator|=
name|rp
operator|->
name|constblock
operator|.
name|vtype
expr_stmt|;
block|}
name|etype
operator|=
name|cktype
argument_list|(
name|opcode
argument_list|,
name|ltype
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|etype
operator|==
name|TYERROR
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|ltag
operator|==
name|TCONST
operator|&&
operator|(
name|rp
operator|==
literal|0
operator|||
name|rtag
operator|==
name|TCONST
operator|)
condition|)
goto|goto
name|makenode
goto|;
if|if
condition|(
name|etype
operator|==
name|TYUNKNOWN
condition|)
goto|goto
name|makenode
goto|;
switch|switch
condition|(
name|opcode
condition|)
block|{
comment|/* check for multiplication by 0 and 1 and addition to 0 */
case|case
name|OPSTAR
case|:
if|if
condition|(
name|ISCONST
argument_list|(
name|lp
argument_list|)
condition|)
name|COMMUTE
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|etype
operator|==
name|TYUNKNOWN
condition|)
break|break;
name|rp
operator|=
name|mkconv
argument_list|(
name|etype
argument_list|,
name|rp
argument_list|)
expr_stmt|;
goto|goto
name|retright
goto|;
block|}
if|if
condition|(
operator|(
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|)
operator|&&
operator|(
operator|(
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPPLUS
operator|)
operator|||
operator|(
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPMINUS
operator|)
operator|)
operator|&&
name|ISCONST
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|&&
name|ISINT
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|q1
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|lp
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|opcode
argument_list|,
name|q
argument_list|,
name|q1
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lp
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
else|else
goto|goto
name|mulop
goto|;
block|}
break|break;
case|case
name|OPSLASH
case|:
case|case
name|OPMOD
case|:
if|if
condition|(
name|ICONEQ
argument_list|(
name|rp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"attempted division by zero"
argument_list|)
expr_stmt|;
name|rp
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opcode
operator|==
name|OPMOD
condition|)
break|break;
name|mulop
label|:
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|==
literal|1
condition|)
goto|goto
name|retleft
goto|;
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|==
operator|-
literal|1
condition|)
block|{
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
return|return
operator|(
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|lp
argument_list|,
name|PNULL
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ISSTAROP
argument_list|(
name|lp
argument_list|)
operator|&&
name|ISICON
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OPSTAR
condition|)
name|e
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
operator|&&
operator|(
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|%
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|)
operator|==
literal|0
condition|)
name|e
operator|=
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
else|else
break|break;
name|e1
operator|=
name|lp
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|e1
argument_list|,
name|e
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|OPPLUS
case|:
if|if
condition|(
name|ISCONST
argument_list|(
name|lp
argument_list|)
condition|)
name|COMMUTE
goto|goto
name|addop
goto|;
case|case
name|OPMINUS
case|:
if|if
condition|(
name|ICONEQ
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|rp
argument_list|,
name|ENULL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ISCONST
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|opcode
operator|=
name|OPPLUS
expr_stmt|;
name|consnegop
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
name|addop
label|:
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|==
literal|0
condition|)
goto|goto
name|retleft
goto|;
if|if
condition|(
name|ISPLUSOP
argument_list|(
name|lp
argument_list|)
operator|&&
name|ISICON
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
block|{
name|e
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|e1
operator|=
name|lp
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|e1
argument_list|,
name|e
argument_list|)
operator|)
return|;
block|}
block|}
break|break;
case|case
name|OPPOWER
case|:
break|break;
case|case
name|OPNEG
case|:
if|if
condition|(
name|ltag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPNEG
condition|)
block|{
name|e
operator|=
name|lp
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
break|break;
case|case
name|OPNOT
case|:
if|if
condition|(
name|ltag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPNOT
condition|)
block|{
name|e
operator|=
name|lp
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
break|break;
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
name|etype
operator|=
name|ltype
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|NULL
operator|&&
name|rp
operator|->
name|listblock
operator|.
name|listp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|rp
argument_list|)
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|OPAND
case|:
case|case
name|OPOR
case|:
if|if
condition|(
name|ISCONST
argument_list|(
name|lp
argument_list|)
condition|)
name|COMMUTE
if|if
condition|(
name|ISCONST
argument_list|(
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|==
literal|0
condition|)
if|if
condition|(
name|opcode
operator|==
name|OPOR
condition|)
goto|goto
name|retleft
goto|;
else|else
goto|goto
name|retright
goto|;
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OPOR
condition|)
goto|goto
name|retright
goto|;
else|else
goto|goto
name|retleft
goto|;
block|}
case|case
name|OPLSHIFT
case|:
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|==
literal|0
condition|)
goto|goto
name|retleft
goto|;
if|if
condition|(
operator|(
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|)
operator|&&
operator|(
operator|(
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPPLUS
operator|)
operator|||
operator|(
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPMINUS
operator|)
operator|)
operator|&&
name|ISICON
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
block|{
name|q1
operator|=
name|mkexpr
argument_list|(
name|OPLSHIFT
argument_list|,
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|OPLSHIFT
argument_list|,
name|lp
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|opcode
argument_list|,
name|q
argument_list|,
name|q1
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lp
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
block|}
case|case
name|OPEQV
case|:
case|case
name|OPNEQV
case|:
case|case
name|OPBITAND
case|:
case|case
name|OPBITOR
case|:
case|case
name|OPBITXOR
case|:
case|case
name|OPBITNOT
case|:
case|case
name|OPRSHIFT
case|:
case|case
name|OPLT
case|:
case|case
name|OPGT
case|:
case|case
name|OPLE
case|:
case|case
name|OPGE
case|:
break|break;
case|case
name|OPEQ
case|:
case|case
name|OPNE
case|:
comment|/* 		 * This warning is here instead of in cktype because 		 * cktype repeats warnings (it can be run more 		 * than once on an expression). 		 */
if|if
condition|(
name|ltype
operator|==
name|TYLOGICAL
condition|)
name|warn
argument_list|(
literal|"logical operand of nonlogical operator"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONCAT
case|:
case|case
name|OPMIN
case|:
case|case
name|OPMAX
case|:
case|case
name|OPASSIGN
case|:
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
case|case
name|OPCONV
case|:
case|case
name|OPADDR
case|:
case|case
name|OPCOMMA
case|:
case|case
name|OPQUEST
case|:
case|case
name|OPCOLON
case|:
case|case
name|OPPAREN
case|:
break|break;
default|default:
name|badop
argument_list|(
literal|"mkexpr"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|makenode
label|:
name|e
operator|=
operator|(
name|expptr
operator|)
name|ALLOC
argument_list|(
name|Exprblock
argument_list|)
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|tag
operator|=
name|TEXPR
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|vtype
operator|=
name|etype
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|lp
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|rp
expr_stmt|;
if|if
condition|(
name|ltag
operator|==
name|TCONST
operator|&&
operator|(
name|rp
operator|==
literal|0
operator|||
name|rtag
operator|==
name|TCONST
operator|)
condition|)
name|e
operator|=
name|fold
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
name|retleft
label|:
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
name|retright
label|:
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rp
operator|)
return|;
name|error
label|:
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|&&
name|opcode
operator|!=
name|OPCALL
operator|&&
name|opcode
operator|!=
name|OPCCALL
condition|)
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ERR
parameter_list|(
name|s
parameter_list|)
value|{ errs = s; goto error; }
end_define

begin_expr_stmt
name|cktype
argument_list|(
name|op
argument_list|,
name|lt
argument_list|,
name|rt
argument_list|)
specifier|register
name|int
name|op
operator|,
name|lt
operator|,
name|rt
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|errs
decl_stmt|;
if|if
condition|(
name|lt
operator|==
name|TYERROR
operator|||
name|rt
operator|==
name|TYERROR
condition|)
goto|goto
name|error1
goto|;
if|if
condition|(
name|lt
operator|==
name|TYUNKNOWN
condition|)
return|return
operator|(
name|TYUNKNOWN
operator|)
return|;
if|if
condition|(
name|rt
operator|==
name|TYUNKNOWN
condition|)
if|if
condition|(
name|op
operator|!=
name|OPNOT
operator|&&
name|op
operator|!=
name|OPBITNOT
operator|&&
name|op
operator|!=
name|OPNEG
operator|&&
name|op
operator|!=
name|OPCALL
operator|&&
name|op
operator|!=
name|OPCCALL
operator|&&
name|op
operator|!=
name|OPADDR
operator|&&
name|op
operator|!=
name|OPPAREN
condition|)
return|return
operator|(
name|TYUNKNOWN
operator|)
return|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
case|case
name|OPSTAR
case|:
case|case
name|OPSLASH
case|:
case|case
name|OPPOWER
case|:
case|case
name|OPMOD
case|:
if|if
condition|(
name|ISNUMERIC
argument_list|(
name|lt
argument_list|)
operator|&&
name|ISNUMERIC
argument_list|(
name|rt
argument_list|)
condition|)
return|return
operator|(
name|maxtype
argument_list|(
name|lt
argument_list|,
name|rt
argument_list|)
operator|)
return|;
name|ERR
argument_list|(
literal|"nonarithmetic operand of arithmetic operator"
argument_list|)
case|case
name|OPNEG
case|:
if|if
condition|(
name|ISNUMERIC
argument_list|(
name|lt
argument_list|)
condition|)
return|return
operator|(
name|lt
operator|)
return|;
name|ERR
argument_list|(
literal|"nonarithmetic operand of negation"
argument_list|)
case|case
name|OPNOT
case|:
if|if
condition|(
name|lt
operator|==
name|TYLOGICAL
condition|)
return|return
operator|(
name|TYLOGICAL
operator|)
return|;
name|ERR
argument_list|(
literal|"NOT of nonlogical"
argument_list|)
case|case
name|OPAND
case|:
case|case
name|OPOR
case|:
case|case
name|OPEQV
case|:
case|case
name|OPNEQV
case|:
if|if
condition|(
name|lt
operator|==
name|TYLOGICAL
operator|&&
name|rt
operator|==
name|TYLOGICAL
condition|)
return|return
operator|(
name|TYLOGICAL
operator|)
return|;
name|ERR
argument_list|(
literal|"nonlogical operand of logical operator"
argument_list|)
case|case
name|OPLT
case|:
case|case
name|OPGT
case|:
case|case
name|OPLE
case|:
case|case
name|OPGE
case|:
case|case
name|OPEQ
case|:
case|case
name|OPNE
case|:
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|||
name|rt
operator|==
name|TYCHAR
operator|||
name|lt
operator|==
name|TYLOGICAL
operator|||
name|rt
operator|==
name|TYLOGICAL
condition|)
block|{
if|if
condition|(
name|lt
operator|!=
name|rt
condition|)
name|ERR
argument_list|(
literal|"illegal comparison"
argument_list|)
if|if
condition|(
name|lt
operator|==
name|TYLOGICAL
condition|)
block|{
if|if
condition|(
name|op
operator|!=
name|OPEQ
operator|&&
name|op
operator|!=
name|OPNE
condition|)
name|ERR
argument_list|(
literal|"order comparison of complex data"
argument_list|)
block|}
block|}
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|lt
argument_list|)
operator|||
name|ISCOMPLEX
argument_list|(
name|rt
argument_list|)
condition|)
block|{
if|if
condition|(
name|op
operator|!=
name|OPEQ
operator|&&
name|op
operator|!=
name|OPNE
condition|)
name|ERR
argument_list|(
literal|"order comparison of complex data"
argument_list|)
block|}
elseif|else
if|if
condition|(
operator|!
name|ISNUMERIC
argument_list|(
name|lt
argument_list|)
operator|||
operator|!
name|ISNUMERIC
argument_list|(
name|rt
argument_list|)
condition|)
name|ERR
argument_list|(
literal|"comparison of nonarithmetic data"
argument_list|)
return|return
operator|(
name|TYLOGICAL
operator|)
return|;
case|case
name|OPCONCAT
case|:
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|&&
name|rt
operator|==
name|TYCHAR
condition|)
return|return
operator|(
name|TYCHAR
operator|)
return|;
name|ERR
argument_list|(
literal|"concatenation of nonchar data"
argument_list|)
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
return|return
operator|(
name|lt
operator|)
return|;
case|case
name|OPADDR
case|:
return|return
operator|(
name|TYADDR
operator|)
return|;
case|case
name|OPCONV
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|lt
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISNUMERIC
argument_list|(
name|rt
argument_list|)
condition|)
return|return
operator|(
name|lt
operator|)
return|;
name|ERR
argument_list|(
literal|"impossible conversion"
argument_list|)
block|}
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|&&
name|ISINT
argument_list|(
name|rt
argument_list|)
condition|)
return|return
operator|(
name|TYCHAR
operator|)
return|;
case|case
name|OPASSIGN
case|:
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
if|if
condition|(
name|ISINT
argument_list|(
name|lt
argument_list|)
operator|&&
name|rt
operator|==
name|TYCHAR
condition|)
return|return
operator|(
name|lt
operator|)
return|;
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|||
name|rt
operator|==
name|TYCHAR
operator|||
name|lt
operator|==
name|TYLOGICAL
operator|||
name|rt
operator|==
name|TYLOGICAL
condition|)
if|if
condition|(
name|op
operator|!=
name|OPASSIGN
operator|||
name|lt
operator|!=
name|rt
condition|)
block|{
comment|/* debug fprintf(diagfile, " lt=%d, rt=%d, op=%d\n", lt, rt, op); */
comment|/* debug fatal("impossible conversion.  possible compiler bug"); */
name|ERR
argument_list|(
literal|"impossible conversion"
argument_list|)
block|}
return|return
operator|(
name|lt
operator|)
return|;
case|case
name|OPMIN
case|:
case|case
name|OPMAX
case|:
case|case
name|OPBITOR
case|:
case|case
name|OPBITAND
case|:
case|case
name|OPBITXOR
case|:
case|case
name|OPBITNOT
case|:
case|case
name|OPLSHIFT
case|:
case|case
name|OPRSHIFT
case|:
case|case
name|OPPAREN
case|:
return|return
operator|(
name|lt
operator|)
return|;
case|case
name|OPCOMMA
case|:
case|case
name|OPQUEST
case|:
case|case
name|OPCOLON
case|:
return|return
operator|(
name|rt
operator|)
return|;
default|default:
name|badop
argument_list|(
literal|"cktype"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|error
label|:
name|err
argument_list|(
name|errs
argument_list|)
expr_stmt|;
name|error1
label|:
return|return
operator|(
name|TYERROR
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_if
if|#
directive|if
name|HERE
operator|==
name|VAX
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_define
define|#
directive|define
name|setfpe
parameter_list|()
value|;asm("bispsw	$0x60")
end_define

begin_decl_stmt
name|jmp_buf
name|jmp_fpe
decl_stmt|;
end_decl_stmt

begin_function
name|LOCAL
name|int
name|fold_fpe_handler
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|)
name|int
name|sig
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|char
modifier|*
name|message
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FPE_INTOVF_TRAP
case|:
name|message
operator|=
literal|"integer overflow"
expr_stmt|;
break|break;
case|case
name|FPE_INTDIV_TRAP
case|:
name|message
operator|=
literal|"integer divide by zero"
expr_stmt|;
break|break;
case|case
name|FPE_FLTOVF_TRAP
case|:
case|case
name|FPE_FLTOVF_FAULT
case|:
name|message
operator|=
literal|"floating overflow"
expr_stmt|;
break|break;
case|case
name|FPE_FLTDIV_TRAP
case|:
case|case
name|FPE_FLTDIV_FAULT
case|:
name|message
operator|=
literal|"floating divide by zero"
expr_stmt|;
break|break;
case|case
name|FPE_FLTUND_TRAP
case|:
case|case
name|FPE_FLTUND_FAULT
case|:
name|message
operator|=
literal|"floating underflow"
expr_stmt|;
break|break;
default|default:
name|message
operator|=
literal|"arithmetic exception"
expr_stmt|;
block|}
name|errstr
argument_list|(
literal|"%s in constant expression"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|jmp_fpe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|setfpe
end_ifndef

begin_define
define|#
directive|define
name|setfpe
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|LOCAL
name|expptr
name|fold
parameter_list|(
name|e
parameter_list|)
specifier|register
name|expptr
name|e
decl_stmt|;
block|{
name|Constp
name|p
decl_stmt|;
specifier|register
name|expptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|int
name|etype
decl_stmt|,
name|mtype
decl_stmt|,
name|ltype
decl_stmt|,
name|rtype
decl_stmt|,
name|opcode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ll
decl_stmt|,
name|lr
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|union
name|Constant
name|lcon
decl_stmt|,
name|rcon
decl_stmt|;
if|#
directive|if
name|HERE
operator|==
name|VAX
name|int
function_decl|(
modifier|*
name|fpe_handler
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmp_fpe
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|fpe_handler
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
name|fpe_handler
operator|=
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|fold_fpe_handler
argument_list|)
expr_stmt|;
name|setfpe
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|opcode
operator|=
name|e
operator|->
name|exprblock
operator|.
name|opcode
expr_stmt|;
name|etype
operator|=
name|e
operator|->
name|exprblock
operator|.
name|vtype
expr_stmt|;
name|lp
operator|=
name|e
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|ltype
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|rp
operator|=
name|e
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|rp
operator|==
literal|0
condition|)
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPNOT
case|:
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
operator|!
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
case|case
name|OPBITNOT
case|:
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
operator|~
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
case|case
name|OPNEG
case|:
name|consnegop
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
case|case
name|OPCONV
case|:
case|case
name|OPADDR
case|:
case|case
name|OPPAREN
case|:
return|return
operator|(
name|e
operator|)
return|;
default|default:
name|badop
argument_list|(
literal|"fold"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|rtype
operator|=
name|rp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Constblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TCONST
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|etype
expr_stmt|;
name|p
operator|->
name|vleng
operator|=
name|e
operator|->
name|exprblock
operator|.
name|vleng
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPCOMMA
case|:
case|case
name|OPQUEST
case|:
case|case
name|OPCOLON
case|:
return|return
operator|(
name|e
operator|)
return|;
case|case
name|OPAND
case|:
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|&&
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPOR
case|:
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|||
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPEQV
case|:
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|==
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPNEQV
case|:
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|!=
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPBITAND
case|:
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|&
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPBITOR
case|:
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator||
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPBITXOR
case|:
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|^
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPLSHIFT
case|:
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|<<
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPRSHIFT
case|:
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|>>
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPCONCAT
case|:
name|ll
operator|=
name|lp
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
name|lr
operator|=
name|rp
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
name|p
operator|->
name|constant
operator|.
name|ccp
operator|=
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|ll
operator|+
name|lr
argument_list|)
expr_stmt|;
name|p
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|ll
operator|+
name|lr
argument_list|)
expr_stmt|;
name|s
operator|=
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ccp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ll
condition|;
operator|++
name|i
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ccp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lr
condition|;
operator|++
name|i
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
break|break;
case|case
name|OPPOWER
case|:
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|conspower
argument_list|(
operator|&
operator|(
name|p
operator|->
name|constant
operator|)
argument_list|,
name|lp
argument_list|,
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ltype
operator|==
name|TYCHAR
condition|)
block|{
name|lcon
operator|.
name|ci
operator|=
name|cmpstr
argument_list|(
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ccp
argument_list|,
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ccp
argument_list|,
name|lp
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
argument_list|,
name|rp
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
argument_list|)
expr_stmt|;
name|rcon
operator|.
name|ci
operator|=
literal|0
expr_stmt|;
name|mtype
operator|=
name|tyint
expr_stmt|;
block|}
else|else
block|{
name|mtype
operator|=
name|maxtype
argument_list|(
name|ltype
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
name|consconv
argument_list|(
name|mtype
argument_list|,
operator|&
name|lcon
argument_list|,
name|ltype
argument_list|,
operator|&
operator|(
name|lp
operator|->
name|constblock
operator|.
name|constant
operator|)
argument_list|)
expr_stmt|;
name|consconv
argument_list|(
name|mtype
argument_list|,
operator|&
name|rcon
argument_list|,
name|rtype
argument_list|,
operator|&
operator|(
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|)
argument_list|)
expr_stmt|;
block|}
name|consbinop
argument_list|(
name|opcode
argument_list|,
name|mtype
argument_list|,
operator|&
operator|(
name|p
operator|->
name|constant
operator|)
argument_list|,
operator|&
name|lcon
argument_list|,
operator|&
name|rcon
argument_list|)
expr_stmt|;
break|break;
block|}
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* assign constant l = r , doing coercion */
end_comment

begin_macro
name|consconv
argument_list|(
argument|lt
argument_list|,
argument|lv
argument_list|,
argument|rt
argument_list|,
argument|rv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lt
decl_stmt|,
name|rt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|union
name|Constant
modifier|*
name|lv
decl_stmt|,
modifier|*
name|rv
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|lt
condition|)
block|{
case|case
name|TYCHAR
case|:
operator|*
operator|(
name|lv
operator|->
name|ccp
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
literal|1
argument_list|)
operator|)
operator|=
name|rv
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
if|if
condition|(
name|rt
operator|==
name|TYCHAR
condition|)
name|lv
operator|->
name|ci
operator|=
name|rv
operator|->
name|ccp
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|ISINT
argument_list|(
name|rt
argument_list|)
condition|)
name|lv
operator|->
name|ci
operator|=
name|rv
operator|->
name|ci
expr_stmt|;
else|else
name|lv
operator|->
name|ci
operator|=
name|rv
operator|->
name|cd
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
switch|switch
condition|(
name|rt
condition|)
block|{
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
comment|/* fall through and do real assignment of 				   first element 				*/
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|lv
operator|->
name|cd
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|lv
operator|->
name|cd
index|[
literal|1
index|]
operator|=
name|rv
operator|->
name|cd
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
if|if
condition|(
name|ISINT
argument_list|(
name|rt
argument_list|)
condition|)
name|lv
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|rv
operator|->
name|ci
expr_stmt|;
else|else
name|lv
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|rv
operator|->
name|cd
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|lt
operator|==
name|TYREAL
condition|)
block|{
name|float
name|f
init|=
name|lv
operator|->
name|cd
index|[
literal|0
index|]
decl_stmt|;
name|lv
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|f
expr_stmt|;
block|}
break|break;
case|case
name|TYLOGICAL
case|:
name|lv
operator|->
name|ci
operator|=
name|rv
operator|->
name|ci
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_expr_stmt
name|consnegop
argument_list|(
name|p
argument_list|)
specifier|register
name|Constp
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|setfpe
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|vtype
condition|)
block|{
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
name|p
operator|->
name|constant
operator|.
name|ci
operator|=
operator|-
name|p
operator|->
name|constant
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|p
operator|->
name|constant
operator|.
name|cd
index|[
literal|1
index|]
operator|=
operator|-
name|p
operator|->
name|constant
operator|.
name|cd
index|[
literal|1
index|]
expr_stmt|;
comment|/* fall through and do the real parts */
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|p
operator|->
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|=
operator|-
name|p
operator|->
name|constant
operator|.
name|cd
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|badtype
argument_list|(
literal|"consnegop"
argument_list|,
name|p
operator|->
name|vtype
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|LOCAL
name|conspower
parameter_list|(
name|powp
parameter_list|,
name|ap
parameter_list|,
name|n
parameter_list|)
specifier|register
name|union
name|Constant
modifier|*
name|powp
decl_stmt|;
name|Constp
name|ap
decl_stmt|;
name|ftnint
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|type
decl_stmt|;
name|union
name|Constant
name|x
decl_stmt|;
switch|switch
condition|(
name|type
operator|=
name|ap
operator|->
name|vtype
condition|)
comment|/* pow = 1 */
block|{
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
name|powp
operator|->
name|ci
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|powp
operator|->
name|cd
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|powp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|badtype
argument_list|(
literal|"conspower"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|constant
operator|.
name|ci
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"zero raised to a negative power"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|constant
operator|.
name|ci
operator|==
literal|1
condition|)
return|return;
elseif|else
if|if
condition|(
name|ap
operator|->
name|constant
operator|.
name|ci
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|n
operator|<
operator|-
literal|2
condition|)
name|n
operator|=
name|n
operator|+
literal|2
expr_stmt|;
name|n
operator|=
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|2
operator|==
literal|1
condition|)
name|powp
operator|->
name|ci
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|powp
operator|->
name|ci
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|n
operator|=
operator|-
name|n
expr_stmt|;
name|consbinop
argument_list|(
name|OPSLASH
argument_list|,
name|type
argument_list|,
operator|&
name|x
argument_list|,
name|powp
argument_list|,
operator|&
operator|(
name|ap
operator|->
name|constant
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|consbinop
argument_list|(
name|OPSTAR
argument_list|,
name|type
argument_list|,
operator|&
name|x
argument_list|,
name|powp
argument_list|,
operator|&
operator|(
name|ap
operator|->
name|constant
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|n
operator|&
literal|01
condition|)
name|consbinop
argument_list|(
name|OPSTAR
argument_list|,
name|type
argument_list|,
name|powp
argument_list|,
name|powp
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>>=
literal|1
condition|)
name|consbinop
argument_list|(
name|OPSTAR
argument_list|,
name|type
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
end_function

begin_comment
comment|/* do constant operation cp = a op b */
end_comment

begin_function
name|LOCAL
name|consbinop
parameter_list|(
name|opcode
parameter_list|,
name|type
parameter_list|,
name|cp
parameter_list|,
name|ap
parameter_list|,
name|bp
parameter_list|)
name|int
name|opcode
decl_stmt|,
name|type
decl_stmt|;
specifier|register
name|union
name|Constant
modifier|*
name|ap
decl_stmt|,
decl|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|k
decl_stmt|;
name|double
name|temp
decl_stmt|;
name|setfpe
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPPLUS
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
name|cp
operator|->
name|ci
operator|=
name|ap
operator|->
name|ci
operator|+
name|bp
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|cp
operator|->
name|cd
index|[
literal|1
index|]
operator|=
name|ap
operator|->
name|cd
index|[
literal|1
index|]
operator|+
name|bp
operator|->
name|cd
index|[
literal|1
index|]
expr_stmt|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|cp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|ap
operator|->
name|cd
index|[
literal|0
index|]
operator|+
name|bp
operator|->
name|cd
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OPMINUS
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
name|cp
operator|->
name|ci
operator|=
name|ap
operator|->
name|ci
operator|-
name|bp
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|cp
operator|->
name|cd
index|[
literal|1
index|]
operator|=
name|ap
operator|->
name|cd
index|[
literal|1
index|]
operator|-
name|bp
operator|->
name|cd
index|[
literal|1
index|]
expr_stmt|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|cp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|ap
operator|->
name|cd
index|[
literal|0
index|]
operator|-
name|bp
operator|->
name|cd
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OPSTAR
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
name|cp
operator|->
name|ci
operator|=
name|ap
operator|->
name|ci
operator|*
name|bp
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|cp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|ap
operator|->
name|cd
index|[
literal|0
index|]
operator|*
name|bp
operator|->
name|cd
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|temp
operator|=
name|ap
operator|->
name|cd
index|[
literal|0
index|]
operator|*
name|bp
operator|->
name|cd
index|[
literal|0
index|]
operator|-
name|ap
operator|->
name|cd
index|[
literal|1
index|]
operator|*
name|bp
operator|->
name|cd
index|[
literal|1
index|]
expr_stmt|;
name|cp
operator|->
name|cd
index|[
literal|1
index|]
operator|=
name|ap
operator|->
name|cd
index|[
literal|0
index|]
operator|*
name|bp
operator|->
name|cd
index|[
literal|1
index|]
operator|+
name|ap
operator|->
name|cd
index|[
literal|1
index|]
operator|*
name|bp
operator|->
name|cd
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|temp
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OPSLASH
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
name|cp
operator|->
name|ci
operator|=
name|ap
operator|->
name|ci
operator|/
name|bp
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|cp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|ap
operator|->
name|cd
index|[
literal|0
index|]
operator|/
name|bp
operator|->
name|cd
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|zdiv
argument_list|(
name|cp
argument_list|,
name|ap
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OPMOD
case|:
if|if
condition|(
name|ISINT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cp
operator|->
name|ci
operator|=
name|ap
operator|->
name|ci
operator|%
name|bp
operator|->
name|ci
expr_stmt|;
break|break;
block|}
else|else
name|fatal
argument_list|(
literal|"inline mod of noninteger"
argument_list|)
expr_stmt|;
default|default:
comment|/* relational ops */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
if|if
condition|(
name|ap
operator|->
name|ci
operator|<
name|bp
operator|->
name|ci
condition|)
name|k
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|ci
operator|==
name|bp
operator|->
name|ci
condition|)
name|k
operator|=
literal|0
expr_stmt|;
else|else
name|k
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
if|if
condition|(
name|ap
operator|->
name|cd
index|[
literal|0
index|]
operator|<
name|bp
operator|->
name|cd
index|[
literal|0
index|]
condition|)
name|k
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|cd
index|[
literal|0
index|]
operator|==
name|bp
operator|->
name|cd
index|[
literal|0
index|]
condition|)
name|k
operator|=
literal|0
expr_stmt|;
else|else
name|k
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
if|if
condition|(
name|ap
operator|->
name|cd
index|[
literal|0
index|]
operator|==
name|bp
operator|->
name|cd
index|[
literal|0
index|]
operator|&&
name|ap
operator|->
name|cd
index|[
literal|1
index|]
operator|==
name|bp
operator|->
name|cd
index|[
literal|1
index|]
condition|)
name|k
operator|=
literal|0
expr_stmt|;
else|else
name|k
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TYLOGICAL
case|:
if|if
condition|(
name|ap
operator|->
name|ci
operator|==
name|bp
operator|->
name|ci
condition|)
name|k
operator|=
literal|0
expr_stmt|;
else|else
name|k
operator|=
literal|1
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPEQ
case|:
name|cp
operator|->
name|ci
operator|=
operator|(
name|k
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|OPNE
case|:
name|cp
operator|->
name|ci
operator|=
operator|(
name|k
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|OPGT
case|:
name|cp
operator|->
name|ci
operator|=
operator|(
name|k
operator|==
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|OPLT
case|:
name|cp
operator|->
name|ci
operator|=
operator|(
name|k
operator|==
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|OPGE
case|:
name|cp
operator|->
name|ci
operator|=
operator|(
name|k
operator|>=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|OPLE
case|:
name|cp
operator|->
name|ci
operator|=
operator|(
name|k
operator|<=
literal|0
operator|)
expr_stmt|;
break|break;
default|default:
name|badop
argument_list|(
literal|"consbinop"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_expr_stmt
name|conssgn
argument_list|(
name|p
argument_list|)
specifier|register
name|expptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|p
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"sgn(nonconstant)"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|headblock
operator|.
name|vtype
condition|)
block|{
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
return|return
operator|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
return|;
default|default:
name|badtype
argument_list|(
literal|"conssgn"
argument_list|,
name|p
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|char
modifier|*
name|powint
index|[ ]
init|=
block|{
literal|"pow_ii"
block|,
literal|"pow_ri"
block|,
literal|"pow_di"
block|,
literal|"pow_ci"
block|,
literal|"pow_zi"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|LOCAL
name|expptr
name|mkpower
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
specifier|register
name|expptr
name|q
decl_stmt|,
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|int
name|ltype
decl_stmt|,
name|rtype
decl_stmt|,
name|mtype
decl_stmt|;
name|struct
name|Listblock
modifier|*
name|args
decl_stmt|,
modifier|*
name|mklist
argument_list|()
decl_stmt|;
name|Addrp
name|ap
decl_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
name|ltype
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|rtype
operator|=
name|rp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|==
literal|0
condition|)
block|{
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISINT
argument_list|(
name|ltype
argument_list|)
condition|)
return|return
operator|(
name|ICON
argument_list|(
literal|1
argument_list|)
operator|)
return|;
else|else
block|{
name|expptr
name|pp
decl_stmt|;
name|pp
operator|=
name|mkconv
argument_list|(
name|ltype
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pp
operator|)
return|;
block|}
block|}
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|ltype
argument_list|)
condition|)
block|{
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|"integer**negative"
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
operator|-
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|lp
operator|=
name|fixexpr
argument_list|(
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|,
name|lp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|==
literal|1
condition|)
block|{
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
if|if
condition|(
name|ONEOF
argument_list|(
name|ltype
argument_list|,
name|MSKINT
operator||
name|MSKREAL
argument_list|)
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|vtype
operator|=
name|ltype
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
block|{
if|if
condition|(
name|ltype
operator|==
name|TYSHORT
operator|&&
name|rtype
operator|==
name|TYSHORT
operator|&&
operator|(
operator|!
name|ISCONST
argument_list|(
name|lp
argument_list|)
operator|||
name|tyint
operator|==
name|TYSHORT
operator|)
condition|)
name|q
operator|=
name|call2
argument_list|(
name|TYSHORT
argument_list|,
literal|"pow_hh"
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ltype
operator|==
name|TYSHORT
condition|)
block|{
name|ltype
operator|=
name|TYLONG
expr_stmt|;
name|lp
operator|=
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
name|q
operator|=
name|call2
argument_list|(
name|ltype
argument_list|,
name|powint
index|[
name|ltype
operator|-
name|TYLONG
index|]
argument_list|,
name|lp
argument_list|,
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ISREAL
argument_list|(
operator|(
name|mtype
operator|=
name|maxtype
argument_list|(
name|ltype
argument_list|,
name|rtype
argument_list|)
operator|)
argument_list|)
condition|)
block|{
name|args
operator|=
name|mklist
argument_list|(
name|mkchain
argument_list|(
name|mkconv
argument_list|(
name|TYDREAL
argument_list|,
name|lp
argument_list|)
argument_list|,
name|mkchain
argument_list|(
name|mkconv
argument_list|(
name|TYDREAL
argument_list|,
name|rp
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fixargs
argument_list|(
name|YES
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|ap
operator|=
name|builtin
argument_list|(
name|TYDREAL
argument_list|,
literal|"pow"
argument_list|)
expr_stmt|;
name|ap
operator|->
name|vstg
operator|=
name|STGINTR
expr_stmt|;
name|q
operator|=
name|fixexpr
argument_list|(
name|mkexpr
argument_list|(
name|OPCCALL
argument_list|,
name|ap
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|exprblock
operator|.
name|vtype
operator|=
name|mtype
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|call2
argument_list|(
name|TYDCOMPLEX
argument_list|,
literal|"pow_zz"
argument_list|,
name|mkconv
argument_list|(
name|TYDCOMPLEX
argument_list|,
name|lp
argument_list|)
argument_list|,
name|mkconv
argument_list|(
name|TYDCOMPLEX
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtype
operator|==
name|TYCOMPLEX
condition|)
name|q
operator|=
name|mkconv
argument_list|(
name|TYCOMPLEX
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Complex Division.  Same code as in Runtime Library */
end_comment

begin_struct
struct|struct
name|dcomplex
block|{
name|double
name|dreal
decl_stmt|,
name|dimag
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|LOCAL
name|zdiv
parameter_list|(
name|c
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|struct
name|dcomplex
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
name|double
name|ratio
decl_stmt|,
name|den
decl_stmt|;
name|double
name|abr
decl_stmt|,
name|abi
decl_stmt|;
name|setfpe
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|abr
operator|=
name|b
operator|->
name|dreal
operator|)
operator|<
literal|0.
condition|)
name|abr
operator|=
operator|-
name|abr
expr_stmt|;
if|if
condition|(
operator|(
name|abi
operator|=
name|b
operator|->
name|dimag
operator|)
operator|<
literal|0.
condition|)
name|abi
operator|=
operator|-
name|abi
expr_stmt|;
if|if
condition|(
name|abr
operator|<=
name|abi
condition|)
block|{
if|if
condition|(
name|abi
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"complex division by zero"
argument_list|)
expr_stmt|;
name|ratio
operator|=
name|b
operator|->
name|dreal
operator|/
name|b
operator|->
name|dimag
expr_stmt|;
name|den
operator|=
name|b
operator|->
name|dimag
operator|*
operator|(
literal|1
operator|+
name|ratio
operator|*
name|ratio
operator|)
expr_stmt|;
name|c
operator|->
name|dreal
operator|=
operator|(
name|a
operator|->
name|dreal
operator|*
name|ratio
operator|+
name|a
operator|->
name|dimag
operator|)
operator|/
name|den
expr_stmt|;
name|c
operator|->
name|dimag
operator|=
operator|(
name|a
operator|->
name|dimag
operator|*
name|ratio
operator|-
name|a
operator|->
name|dreal
operator|)
operator|/
name|den
expr_stmt|;
block|}
else|else
block|{
name|ratio
operator|=
name|b
operator|->
name|dimag
operator|/
name|b
operator|->
name|dreal
expr_stmt|;
name|den
operator|=
name|b
operator|->
name|dreal
operator|*
operator|(
literal|1
operator|+
name|ratio
operator|*
name|ratio
operator|)
expr_stmt|;
name|c
operator|->
name|dreal
operator|=
operator|(
name|a
operator|->
name|dreal
operator|+
name|a
operator|->
name|dimag
operator|*
name|ratio
operator|)
operator|/
name|den
expr_stmt|;
name|c
operator|->
name|dimag
operator|=
operator|(
name|a
operator|->
name|dimag
operator|-
name|a
operator|->
name|dreal
operator|*
name|ratio
operator|)
operator|/
name|den
expr_stmt|;
block|}
block|}
end_block

begin_function
name|expptr
name|oftwo
parameter_list|(
name|e
parameter_list|)
name|expptr
name|e
decl_stmt|;
block|{
name|int
name|val
decl_stmt|,
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|e
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator|=
name|e
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|2
case|:
name|res
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|res
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|res
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|res
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|res
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|res
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|128
case|:
name|res
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|res
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ICON
argument_list|(
name|res
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

