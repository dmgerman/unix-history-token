begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * f77.c  *  * Driver program for the 4.2 BSD f77 compiler.  *  * University of Utah CS Dept modification history:  *  * $Log:	f77.c,v $  * Revision 1.14  85/03/01  00:07:57  donn  * Portability fix from Ralph Campbell.  *   * Revision 1.13  85/02/12  19:31:47  donn  * Use CATNAME to get the name of a concatenation command instead of  * explicitly running 'cat' -- you can get the wrong 'cat' the old way!  *   * Revision 1.12  85/01/14  06:42:30  donn  * Changed to call the peephole optimizer with the '-f' flag, so that  * floating point moves are translated to integer moves.  *   * Revision 1.11  85/01/14  04:38:59  donn  * Jerry's change to pass -O to f1 so it knows whether the peephole optimizer  * will be run.  This is necessary in order to handle movf/movl translation.  *   * Revision 1.10  85/01/14  03:59:12  donn  * Added Jerry Berkman's fix for the '-q' flag.  *   * Revision 1.9  84/11/09  01:51:26  donn  * Cosmetic change to stupid() suggested by John McCarthy at Memorial  * University, St. Johns.  *   * Revision 1.8  84/09/14  16:02:34  donn  * Added changes to notice when people do 'f77 -c foo.f -o bar.o' and tell  * them why it doesn't do what they think it does.  *   * Revision 1.7  84/08/24  21:08:31  donn  * Added call to setrlimit() to prevent core dumps when not debugging.  * Reorganized the include file arrangment somewhat.  *   * Revision 1.6  84/08/24  20:20:24  donn  * Changed stupidity check on Jerry Berkman's suggestion -- now it balks if  * the load file exists and has a sensitive suffix.  *   * Revision 1.5  84/08/15  18:56:44  donn  * Added test for -O combined with -g, suggested by Raleigh Romine.  To keep  * things simple, if both are specified then the second in the list is thrown  * out and the user is warned.  *   * Revision 1.4  84/08/05  21:33:15  donn  * Added stupidity check -- f77 won't load on a file that it's asked to  * compile as well.  *   * Revision 1.3  84/08/04  22:58:24  donn  * Improved error reporting -- we now explain why we died and what we did.  * Only works on 4.2.  Added at the instigation of Jerry Berkman.  *   * Revision 1.2  84/07/28  13:11:24  donn  * Added Ralph Campbell's changes to reduce offsets to data.  *   */
end_comment

begin_decl_stmt
name|char
modifier|*
name|xxxvers
index|[]
init|=
literal|"\n@(#) F77 DRIVER, VERSION 4.2,   1984 JULY 28\n"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SIGPROF
end_ifdef

begin_comment
comment|/*  * Some 4.2 BSD capabilities.  */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_define
define|#
directive|define
name|NOCORE
value|1
end_define

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_define
define|#
directive|define
name|PSIGNAL
value|1
end_define

begin_define
define|#
directive|define
name|INLINE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defines.h"
end_include

begin_include
include|#
directive|include
file|"machdefs.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_decl_stmt
specifier|static
name|FILEP
name|diagfile
init|=
block|{
name|stderr
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigivalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigqvalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sighvalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigtvalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pass1name
init|=
name|PASS1NAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pass2name
init|=
name|PASS2NAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pass2opt
init|=
name|PASS2OPT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|asmname
init|=
name|ASMNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ldname
init|=
name|LDNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|footname
init|=
name|FOOTNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|proffoot
init|=
name|PROFFOOT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|macroname
init|=
literal|"m4"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|shellname
init|=
name|_PATH_BSHELL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cppname
init|=
name|_PATH_CPP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|aoutname
init|=
literal|"a.out"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temppref
init|=
name|TEMPPREF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|infname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|textfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|asmfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|asmpass2
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|initfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sortfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|prepfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|objfdefault
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|optzfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|setfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|fflags
index|[
literal|50
index|]
init|=
literal|"-"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|f2flags
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cflags
index|[
literal|50
index|]
init|=
literal|"-c"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|TARGET
operator|==
name|GCOS
end_if

begin_decl_stmt
specifier|static
name|char
name|eflags
index|[
literal|30
index|]
init|=
literal|"system=gcos "
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|eflags
index|[
literal|30
index|]
init|=
literal|"system=unix "
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|rflags
index|[
literal|30
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|lflag
index|[
literal|3
index|]
init|=
literal|"-x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fflagp
init|=
name|fflags
operator|+
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|f2flagp
init|=
name|f2flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cflagp
init|=
name|cflags
operator|+
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|eflagp
init|=
name|eflags
operator|+
literal|12
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rflagp
init|=
name|rflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cppflags
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|cppargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|loadargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|loadp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|erred
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|loadflag
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|saveasmflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|profileflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|optimflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|debugflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|verbose
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|nofloating
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|fortonly
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|macroflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|sdbflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|namesflag
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ncpp
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|status
decl_stmt|;
name|char
modifier|*
name|setdoto
argument_list|()
decl_stmt|,
modifier|*
name|lastchar
argument_list|()
decl_stmt|,
modifier|*
name|lastfield
argument_list|()
decl_stmt|,
modifier|*
name|copys
argument_list|()
decl_stmt|,
modifier|*
name|argvtos
argument_list|()
decl_stmt|;
name|ptr
name|ckalloc
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|fortfile
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|int
name|intrupt
parameter_list|()
function_decl|;
name|int
name|new_aoutname
init|=
name|NO
decl_stmt|;
name|sigivalue
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_IGN
expr_stmt|;
name|sigqvalue
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_IGN
expr_stmt|;
name|sighvalue
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_IGN
expr_stmt|;
name|sigtvalue
operator|=
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_IGN
expr_stmt|;
name|enbint
argument_list|(
name|intrupt
argument_list|)
expr_stmt|;
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|crfnames
argument_list|()
expr_stmt|;
name|cppargs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cppargs
argument_list|)
argument_list|)
expr_stmt|;
name|loadargs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|argc
operator|+
literal|20
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|loadargs
argument_list|)
argument_list|)
expr_stmt|;
name|loadargs
index|[
literal|1
index|]
operator|=
literal|"-X"
expr_stmt|;
name|loadargs
index|[
literal|2
index|]
operator|=
literal|"-u"
expr_stmt|;
if|#
directive|if
name|HERE
operator|==
name|PDP11
operator|||
name|HERE
operator|==
name|VAX
operator|||
name|HERE
operator|==
name|TAHOE
name|loadargs
index|[
literal|3
index|]
operator|=
literal|"_MAIN_"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HERE
operator|==
name|INTERDATA
name|loadargs
index|[
literal|3
index|]
operator|=
literal|"main"
expr_stmt|;
endif|#
directive|endif
name|loadp
operator|=
name|loadargs
operator|+
literal|4
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|s
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|1
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'T'
case|:
comment|/* use special passes */
switch|switch
condition|(
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'1'
case|:
name|pass1name
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'2'
case|:
name|pass2name
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'p'
case|:
name|pass2opt
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'a'
case|:
name|asmname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'l'
case|:
name|ldname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'F'
case|:
name|footname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'m'
case|:
name|macroname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'t'
case|:
name|temppref
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
default|default:
name|fatali
argument_list|(
literal|"bad option -T%c"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'6'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'6'
condition|)
block|{
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
goto|goto
name|copyfflag
goto|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"invalid flag 6%c\n"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
case|case
literal|'w'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'6'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|copyfflag
label|:
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
case|case
literal|'1'
case|:
case|case
literal|'C'
case|:
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|sdbflag
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"-O and -g are incompatible; -O ignored\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|optimflag
operator|=
name|YES
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
operator|*
name|loadp
operator|++
operator|=
literal|"-r"
expr_stmt|;
operator|*
name|loadp
operator|++
operator|=
literal|"-d"
expr_stmt|;
endif|#
directive|endif
operator|*
name|fflagp
operator|++
operator|=
literal|'O'
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
operator|*
name|fflagp
operator|++
operator|=
literal|'N'
expr_stmt|;
if|if
condition|(
name|oneof
argument_list|(
operator|*
operator|++
name|s
argument_list|,
literal|"qxscn"
argument_list|)
condition|)
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"invalid flag -N%c\n"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
literal|'X'
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'m'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'4'
condition|)
operator|++
name|s
expr_stmt|;
name|macroflag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|strcat
argument_list|(
name|cflags
argument_list|,
literal|" -S"
argument_list|)
expr_stmt|;
name|saveasmflag
operator|=
name|YES
expr_stmt|;
case|case
literal|'c'
case|:
if|if
condition|(
name|new_aoutname
operator|==
name|YES
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"-c prevents loading, -o %s ignored\n"
argument_list|,
name|aoutname
argument_list|)
expr_stmt|;
name|new_aoutname
operator|=
name|NO
expr_stmt|;
block|}
name|loadflag
operator|=
name|NO
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|YES
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\nBerkeley F77, version %s\n"
argument_list|,
name|VERSIONNUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debugflag
operator|=
name|YES
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
literal|'d'
expr_stmt|;
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|','
condition|)
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
literal|'X'
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'M'
case|:
operator|*
name|loadp
operator|++
operator|=
literal|"-M"
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|optimflag
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"-g and -O are incompatible; -g ignored\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcat
argument_list|(
name|cflags
argument_list|,
literal|" -g"
argument_list|)
expr_stmt|;
name|sdbflag
operator|=
name|YES
expr_stmt|;
goto|goto
name|copyfflag
goto|;
case|case
literal|'p'
case|:
name|profileflag
operator|=
name|YES
expr_stmt|;
name|strcat
argument_list|(
name|cflags
argument_list|,
literal|" -p"
argument_list|)
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
literal|'p'
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'g'
condition|)
block|{
name|proffoot
operator|=
name|GPRFFOOT
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
name|namesflag
operator|=
name|NO
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"onetrip"
argument_list|)
condition|)
block|{
operator|*
name|fflagp
operator|++
operator|=
literal|'1'
expr_stmt|;
goto|goto
name|endfor
goto|;
block|}
name|new_aoutname
operator|=
name|YES
expr_stmt|;
name|aoutname
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
if|if
condition|(
name|loadflag
operator|==
name|NO
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"-c prevents loading, -o %s ignored\n"
argument_list|,
name|aoutname
argument_list|)
expr_stmt|;
name|new_aoutname
operator|=
name|NO
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
case|case
literal|'f'
case|:
name|nofloating
operator|=
name|YES
expr_stmt|;
name|pass2name
operator|=
name|NOFLPASS2
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'F'
case|:
name|fortonly
operator|=
name|YES
expr_stmt|;
name|loadflag
operator|=
name|NO
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'I'
case|:
name|cppargs
index|[
name|ncpp
operator|++
index|]
operator|=
operator|*
name|argv
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'i'
case|:
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'2'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'4'
operator|)
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
goto|goto
name|copyfflag
goto|;
block|}
ifdef|#
directive|ifdef
name|INLINE
operator|*
name|f2flagp
operator|++
operator|=
literal|'-'
expr_stmt|;
while|while
condition|(
operator|*
name|f2flagp
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
operator|*
name|f2flagp
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pass2name
argument_list|,
name|PASS2NAME
argument_list|)
operator|==
literal|0
condition|)
name|pass2name
operator|=
name|PASS2INAME
expr_stmt|;
goto|goto
name|endfor
goto|;
else|#
directive|else
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"invalid flag -i%c\n"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
literal|'l'
case|:
comment|/* letter ell--library */
name|s
index|[
operator|-
literal|1
index|]
operator|=
literal|'-'
expr_stmt|;
operator|*
name|loadp
operator|++
operator|=
name|s
operator|-
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'E'
case|:
comment|/* EFL flag argument */
while|while
condition|(
operator|*
name|eflagp
operator|++
operator|=
operator|*
operator|++
name|s
condition|)
empty_stmt|;
operator|*
name|eflagp
operator|++
operator|=
literal|' '
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'R'
case|:
while|while
condition|(
operator|*
name|rflagp
operator|++
operator|=
operator|*
operator|++
name|s
condition|)
empty_stmt|;
operator|*
name|rflagp
operator|++
operator|=
literal|' '
expr_stmt|;
goto|goto
name|endfor
goto|;
default|default:
name|lflag
index|[
literal|1
index|]
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|loadp
operator|++
operator|=
name|copys
argument_list|(
name|lflag
argument_list|)
expr_stmt|;
break|break;
block|}
name|endfor
label|:
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOCORE
if|if
condition|(
operator|!
name|debugflag
condition|)
block|{
name|struct
name|rlimit
name|r
decl_stmt|;
name|r
operator|.
name|rlim_cur
operator|=
name|r
operator|.
name|rlim_max
operator|=
literal|0
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_CORE
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|NOCORE
operator|*
name|fflagp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ncpp
operator|>
literal|0
condition|)
name|cppflags
operator|=
name|argvtos
argument_list|(
name|ncpp
argument_list|,
name|cppargs
argument_list|)
expr_stmt|;
name|loadargs
index|[
literal|0
index|]
operator|=
name|ldname
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
if|if
condition|(
name|nofloating
condition|)
operator|*
name|loadp
operator|++
operator|=
operator|(
name|profileflag
condition|?
name|NOFLPROF
else|:
name|NOFLFOOT
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|*
name|loadp
operator|++
operator|=
operator|(
name|profileflag
condition|?
name|proffoot
else|:
name|footname
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
switch|switch
condition|(
name|c
operator|=
name|dotchar
argument_list|(
name|infname
operator|=
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* Ratfor file */
case|case
literal|'e'
case|:
comment|/* EFL file */
if|if
condition|(
name|unreadable
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|fortfile
expr_stmt|;
name|t
operator|=
name|lastfield
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
condition|)
empty_stmt|;
name|s
index|[
operator|-
literal|2
index|]
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|macroflag
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s>%s"
argument_list|,
name|macroname
argument_list|,
name|infname
argument_list|,
name|prepfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
block|{
name|rmf
argument_list|(
name|prepfname
argument_list|)
expr_stmt|;
name|erred
operator|=
name|YES
expr_stmt|;
break|break;
block|}
name|infname
operator|=
name|prepfname
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'e'
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"efl %s %s>%s"
argument_list|,
name|eflags
argument_list|,
name|infname
argument_list|,
name|fortfile
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"ratfor %s %s>%s"
argument_list|,
name|rflags
argument_list|,
name|infname
argument_list|,
name|fortfile
argument_list|)
expr_stmt|;
name|status
operator|=
name|sys
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|macroflag
condition|)
name|rmf
argument_list|(
name|infname
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
name|rmf
argument_list|(
name|fortfile
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|fortonly
condition|)
block|{
name|infname
operator|=
name|argv
index|[
name|i
index|]
operator|=
name|lastfield
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|lastchar
argument_list|(
name|infname
argument_list|)
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|dofort
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
else|else
block|{
if|if
condition|(
name|nodup
argument_list|(
name|t
operator|=
name|setdoto
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|t
expr_stmt|;
name|rmf
argument_list|(
name|fortfile
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* C preprocessor -> Fortran file */
if|if
condition|(
name|unreadable
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|fortfile
expr_stmt|;
name|t
operator|=
name|lastfield
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
condition|)
empty_stmt|;
name|s
index|[
operator|-
literal|2
index|]
operator|=
literal|'f'
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s>%s"
argument_list|,
name|cppname
argument_list|,
name|cppflags
argument_list|,
name|infname
argument_list|,
name|fortfile
argument_list|)
expr_stmt|;
name|status
operator|=
name|sys
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
name|rmf
argument_list|(
name|fortfile
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|fortonly
condition|)
block|{
name|infname
operator|=
name|argv
index|[
name|i
index|]
operator|=
name|lastfield
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|lastchar
argument_list|(
name|infname
argument_list|)
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|dofort
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
else|else
block|{
if|if
condition|(
name|nodup
argument_list|(
name|t
operator|=
name|setdoto
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|t
expr_stmt|;
name|rmf
argument_list|(
name|fortfile
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'f'
case|:
comment|/* Fortran file */
if|if
condition|(
name|unreadable
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|dofort
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|nodup
argument_list|(
name|t
operator|=
name|setdoto
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|t
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* C file */
case|case
literal|'s'
case|:
comment|/* Assembler file */
if|if
condition|(
name|unreadable
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HERE
operator|==
name|PDP11
operator|||
name|HERE
operator|==
name|VAX
operator|||
name|HERE
operator|==
name|TAHOE
if|if
condition|(
name|namesflag
operator|==
name|YES
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%s:\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"cc %s %s"
argument_list|,
name|cflags
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|nodup
argument_list|(
name|t
operator|=
name|setdoto
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|t
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|nodup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-o"
argument_list|)
condition|)
block|{
name|aoutname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|new_aoutname
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|loadflag
operator|==
name|NO
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"-c prevents loading, -o %s ignored\n"
argument_list|,
name|aoutname
argument_list|)
expr_stmt|;
name|new_aoutname
operator|=
name|NO
expr_stmt|;
block|}
block|}
else|else
operator|*
name|loadp
operator|++
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|loadflag
operator|&&
name|stupid
argument_list|(
name|aoutname
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|loadflag
operator|&&
operator|!
name|erred
condition|)
name|doload
argument_list|(
name|loadargs
argument_list|,
name|loadp
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|erred
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * argvtos() copies a list of arguments contained in an array of character  * strings to a single dynamically allocated string. Each argument is  * separated by one blank space. Returns a pointer to the string or null  * if out of memory.  */
end_comment

begin_define
define|#
directive|define
name|SBUFINCR
value|1024
end_define

begin_define
define|#
directive|define
name|SBUFMAX
value|10240
end_define

begin_function
name|char
modifier|*
name|argvtos
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* string pointer */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* string buffer pointer */
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/* memory allocator */
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
comment|/* increase size of storage */
name|char
modifier|*
name|sbuf
decl_stmt|;
comment|/* string buffer */
name|int
name|nbytes
decl_stmt|;
comment|/* bytes of memory required */
name|int
name|nu
decl_stmt|;
comment|/* no. of SBUFINCR units required */
name|int
name|sbufsize
decl_stmt|;
comment|/* current size of sbuf */
name|int
name|strlen
parameter_list|()
function_decl|;
comment|/* string length */
name|sbufsize
operator|=
name|SBUFINCR
expr_stmt|;
if|if
condition|(
operator|(
name|sbuf
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|sbufsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"out of memory (argvtos)"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argc
operator|--
operator|>
literal|0
condition|;
operator|++
name|argv
control|)
block|{
if|if
condition|(
operator|(
name|nbytes
operator|=
operator|(
name|i
operator|+
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
operator|+
literal|1
operator|-
name|sbufsize
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
name|nu
operator|=
operator|(
name|nbytes
operator|+
name|SBUFINCR
operator|-
literal|1
operator|)
operator|/
name|SBUFINCR
expr_stmt|;
name|sbufsize
operator|+=
name|nu
operator|*
name|SBUFINCR
expr_stmt|;
if|if
condition|(
name|sbufsize
operator|>
name|SBUFMAX
condition|)
block|{
name|fatal
argument_list|(
literal|"argument length exceeded (argvtos)"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|(
name|sbuf
operator|=
name|realloc
argument_list|(
name|sbuf
argument_list|,
operator|(
name|unsigned
operator|)
name|sbufsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"out of memory (argvtos)"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
for|for
control|(
name|s
operator|=
operator|*
name|argv
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|i
operator|++
operator|,
name|s
operator|++
control|)
name|sbuf
index|[
name|i
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|sbuf
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|sbuf
index|[
operator|--
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|sbuf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|dofort
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retcode
decl_stmt|;
name|char
name|buff
index|[
literal|200
index|]
decl_stmt|;
name|infname
operator|=
name|s
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s %s %s %s"
argument_list|,
name|pass1name
argument_list|,
name|fflags
argument_list|,
name|s
argument_list|,
name|asmfname
argument_list|,
name|initfname
argument_list|,
name|textfname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
goto|goto
name|error
goto|;
case|case
literal|0
case|:
break|break;
default|default:
goto|goto
name|comperror
goto|;
block|}
if|if
condition|(
name|dopass2
argument_list|()
condition|)
goto|goto
name|comperror
goto|;
name|doasm
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
name|ret
label|:
name|rmf
argument_list|(
name|asmfname
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|initfname
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|textfname
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
name|error
label|:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\nError.  No assembly.\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
name|comperror
label|:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\ncompiler error.\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|2
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
end_block

begin_macro
name|dopass2
argument_list|()
end_macro

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"PASS2."
argument_list|)
expr_stmt|;
if|#
directive|if
name|FAMILY
operator|==
name|DMR
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s - %s"
argument_list|,
name|pass2name
argument_list|,
name|textfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
return|return
operator|(
name|sys
argument_list|(
name|buff
argument_list|)
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FAMILY
operator|==
name|PCC
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -A%s<%s>%s"
argument_list|,
name|pass2name
argument_list|,
name|setfname
argument_list|,
name|textfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s>%s"
argument_list|,
name|pass2name
argument_list|,
name|f2flags
argument_list|,
name|textfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|sys
argument_list|(
name|buff
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|doasm
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|lastc
decl_stmt|;
name|char
modifier|*
name|obj
decl_stmt|;
name|char
name|buff
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|lastchar
argument_list|()
decl_stmt|,
modifier|*
name|setdoto
argument_list|()
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|s
operator|=
name|objfdefault
expr_stmt|;
name|lastc
operator|=
name|lastchar
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|obj
operator|=
name|setdoto
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
operator|||
name|TARGET
operator|==
name|VAX
operator|||
name|TARGET
operator|==
name|TAHOE
ifdef|#
directive|ifdef
name|PASS2OPT
if|if
condition|(
name|optimflag
condition|)
block|{
if|#
directive|if
name|TARGET
operator|==
name|TAHOE
name|sprintf
argument_list|(
argument|buff
argument_list|,
literal|"%s -f %s %s"
argument_list|,
else|#
directive|else
argument|sprintf(buff,
literal|"%s %s %s"
argument|,
endif|#
directive|endif
argument|pass2opt, asmpass2, optzfname); 		if( sys(buff) ) 			rmf(optzfname); 		else 			(void)rename(optzfname, asmpass2); 		}
endif|#
directive|endif
endif|#
directive|endif
argument|if(saveasmflag) 	{ 	*lastc =
literal|'s'
argument|;
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
argument|sprintf(buff,
literal|"%s %s %s %s %s>%s"
argument|, CATNAME, asmfname, initfname, 		setfname, asmpass2, obj);
else|#
directive|else
if|#
directive|if
name|TARGET
operator|==
name|VAX
operator|||
name|TARGET
operator|==
name|TAHOE
argument|sprintf(buff,
literal|"%s %s %s %s>%s"
argument|, 		CATNAME, asmfname, asmpass2, initfname, obj);
else|#
directive|else
argument|sprintf(buff,
literal|"%s %s %s %s>%s"
argument|, 		CATNAME, asmfname, initfname, asmpass2, obj);
endif|#
directive|endif
endif|#
directive|endif
argument|sys(buff); 	*lastc =
literal|'o'
argument|; 	} else 	{ 	if(verbose) 		fprintf(diagfile,
literal|"  ASM."
argument|);
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
argument|sprintf(buff,
literal|"%s -o %s %s %s %s %s"
argument|, asmname, obj, asmfname, 		initfname, setfname, asmpass2);
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|VAX
operator|||
name|TARGET
operator|==
name|TAHOE
comment|/* vax assembler currently accepts only one input file */
argument|sprintf(buff,
literal|"%s %s %s>>%s"
argument|, 	CATNAME, asmpass2, initfname, asmfname); 	sys(buff);
ifdef|#
directive|ifdef
name|UCBVAXASM
argument|sprintf(buff,
literal|"%s -J -o %s %s"
argument|, asmname, obj, asmfname);
else|#
directive|else
argument|sprintf(buff,
literal|"%s -o %s %s"
argument|, asmname, obj, asmfname);
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|PDP11
argument|sprintf(buff,
literal|"%s -u -o %s %s %s"
argument|, asmname, obj, asmfname, asmpass2);
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|!=
name|INTERDATA
operator|&&
name|TARGET
operator|!=
name|PDP11
operator|&&
name|TARGET
operator|!=
name|VAX
operator|&&
name|TARGET
operator|!=
name|TAHOE
argument|sprintf(buff,
literal|"%s -o %s %s %s"
argument|, asmname, obj, asmfname, asmpass2);
endif|#
directive|endif
argument|if( sys(buff) ) 		fatal(
literal|"assembler error"
argument|); 	if(verbose) 		fprintf(diagfile,
literal|"\n"
argument|);
if|#
directive|if
name|HERE
operator|==
name|PDP11
operator|&&
name|TARGET
operator|!=
name|PDP11
argument|rmf(obj);
endif|#
directive|endif
argument|}  rmf(asmpass2); }    doload(v0, v) register char *v0[]
argument_list|,
argument|*v[]; { char **p; int waitpid;  if(sdbflag) 	*v++ =
literal|"-lg"
argument|; if (profileflag) 	{ 	for(p = p_liblist ; *p ; *v++ = *p++) 		; 	} else	{ 	for(p = liblist ; *p ; *v++ = *p++) 		; 	}  *v++ =
literal|"-o"
argument|; *v++ = aoutname; *v = NULL;  if(verbose) 	fprintf(diagfile,
literal|"LOAD."
argument|); if(debugflag) 	{ 	for(p = v0 ; p<v ; ++p) 		fprintf(diagfile,
literal|"%s "
argument|, *p); 	fprintf(diagfile,
literal|"\n"
argument|); 	}
if|#
directive|if
name|HERE
operator|==
name|PDP11
operator|||
name|HERE
operator|==
name|INTERDATA
operator|||
name|HERE
operator|==
name|VAX
operator|||
name|HERE
operator|==
name|TAHOE
argument|if( (waitpid = fork()) ==
literal|0
argument|) 		{ 		enbint(SIG_DFL); 		execv(ldname, v0); 		fatalstr(
literal|"couldn't load %s"
argument|, ldname); 		} 	await(waitpid);
endif|#
directive|endif
if|#
directive|if
name|HERE
operator|==
name|INTERDATA
argument|if(optimflag) 		{ 		char buff1[
literal|100
argument|]
argument_list|,
argument|buff2[
literal|100
argument|]; 		sprintf(buff1,
literal|"nopt %s -o junk.%d"
argument|, aoutname, pid); 		sprintf(buff2,
literal|"mv junk.%d %s"
argument|, pid, aoutname); 		if( sys(buff1) || sys(buff2) ) 			err(
literal|"bad optimization"
argument|); 		}
endif|#
directive|endif
argument|if(verbose) 	fprintf(diagfile,
literal|"\n"
argument|); }
comment|/* Process control and Shell-simulating routines */
argument|sys(str) char *str; { register char *s
argument_list|,
argument|*t; char *argv[
literal|100
argument|]; char *inname
argument_list|,
argument|*outname; int append; int waitpid; int argc;   if(debugflag) 	fprintf(diagfile,
literal|"%s\n"
argument|, str); inname  = NULL; outname = NULL; argv[
literal|0
argument|] = shellname; argc =
literal|1
argument|;  t = str; while( isspace(*t) ) 	++t; while(*t) 	{ 	if(*t ==
literal|'<'
argument|) 		inname = t+
literal|1
argument|; 	else if(*t ==
literal|'>'
argument|) 		{ 		if(t[
literal|1
argument|] ==
literal|'>'
argument|) 			{ 			append = YES; 			outname = t+
literal|2
argument|; 			} 		else	{ 			append = NO; 			outname = t+
literal|1
argument|; 			} 		} 	else 		argv[argc++] = t; 	while( !isspace(*t)&& *t!=
literal|'\0'
argument|) 		++t; 	if(*t) 		{ 		*t++ =
literal|'\0'
argument|; 		while( isspace(*t) ) 			++t; 		} 	}  if(argc ==
literal|1
argument|)
comment|/* no command */
argument|return(-
literal|1
argument|); argv[argc] =
literal|0
argument|;  if((waitpid = fork()) ==
literal|0
argument|) 	{ 	if(inname) 		freopen(inname,
literal|"r"
argument|, stdin); 	if(outname) 		freopen(outname, (append ?
literal|"a"
argument|:
literal|"w"
argument|), stdout); 	enbint(SIG_DFL);  	texec(argv[
literal|1
argument|]  , argv);  	fatalstr(
literal|"Cannot load %s"
argument|, argv[
literal|1
argument|]); 	}  return( await(waitpid) ); }
include|#
directive|include
file|"errno.h"
comment|/* modified version from the Shell */
argument|texec(f, av) char *f; char **av; { extern int errno;  execv(f, av+
literal|1
argument|);  if (errno==ENOEXEC) 	{ 	av[
literal|1
argument|] = f; 	execv(shellname, av); 	fatal(
literal|"No shell!"
argument|); 	} if (errno==ENOMEM) 	fatalstr(
literal|"%s: too large"
argument|, f); }       done(k) int k; { static int recurs	= NO;  if(recurs == NO) 	{ 	recurs = YES; 	rmfiles(); 	} exit(k); }       enbint(k) int (*k)(); { if(sigivalue ==
literal|0
argument|) 	signal(SIGINT,k); if(sigqvalue ==
literal|0
argument|) 	signal(SIGQUIT,k); if(sighvalue ==
literal|0
argument|) 	signal(SIGHUP,k); if(sigtvalue ==
literal|0
argument|) 	signal(SIGTERM,k); }     intrupt() { done(
literal|2
argument|); }
ifdef|#
directive|ifdef
name|PSIGNAL
comment|/*  * Fancy 4.2 BSD signal printing stuff.  */
argument|char harmless[NSIG] = {
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument|};
endif|#
directive|endif
argument|await(waitpid) int waitpid; {
ifdef|#
directive|ifdef
name|PSIGNAL
argument|extern char *sys_siglist[]; union wait status;
else|#
directive|else
else|PSIGNAL
argument|int status;
endif|#
directive|endif
endif|PSIGNAL
argument|int w;  enbint(SIG_IGN); while ( (w = wait(&status)) != waitpid) 	if(w == -
literal|1
argument|) 		fatal(
literal|"bad wait code"
argument|); enbint(intrupt);
ifdef|#
directive|ifdef
name|PSIGNAL
argument|if(status.w_termsig) 	{ 	debugflag =
literal|0
argument|;
comment|/* Prevent us from dumping core ourselves */
argument|if(status.w_termsig != SIGINT&& status.w_termsig< NSIG) 		fprintf(diagfile,
literal|"%s%s\n"
argument|, sys_siglist[status.w_termsig], 			status.w_coredump ?
literal|" -- core dumped"
argument|:
literal|""
argument|); 	if(status.w_termsig< NSIG&& ! harmless[status.w_termsig]) 		fatal(
literal|"see a system manager"
argument|); 	else 		done(
literal|3
argument|); 	} return(status.w_retcode);
else|#
directive|else
else|PSIGNAL
argument|if(status&
literal|0377
argument|) 	{ 	if(status != SIGINT) 		fprintf(diagfile,
literal|"Termination code %d\n"
argument|, status); 	done(
literal|3
argument|); 	} return(status>>
literal|8
argument|);
endif|#
directive|endif
endif|PSIGNAL
argument|}
comment|/* File Name and File Manipulation Routines */
argument|unreadable(s) register char *s; { register FILE *fp;  if(fp = fopen(s,
literal|"r"
argument|)) 	{ 	fclose(fp); 	return(NO); 	}  else 	{ 	fprintf(diagfile,
literal|"Error: Cannot read file %s\n"
argument|, s); 	return(YES); 	} }    stupid(s) char *s; { char c;  if( (c = dotchar(s))&& index(
literal|"focsreF"
argument|, c)&& access(s,
literal|0
argument|) ==
literal|0
argument|) 	{ 	fprintf(diagfile,
literal|"Loading on %s would destroy it\n"
argument|, s); 	return(YES); 	} return(NO); }    clf(p) FILEP *p; { if(p!=NULL&& *p!=NULL&& *p!=stdout) 	{ 	if(ferror(*p)) 		fatal(
literal|"writing error"
argument|); 	fclose(*p); 	} *p = NULL; }  rmfiles() { rmf(textfname); rmf(asmfname); rmf(initfname); rmf(asmpass2);
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
argument|rmf(setfname);
endif|#
directive|endif
argument|}
comment|/* return -1 if file does not exist, 0 if it is of zero length    and 1 if of positive length */
argument|content(filename) char *filename; {
ifdef|#
directive|ifdef
name|VERSION6
argument|struct stat 		{ 		char cjunk[
literal|9
argument|]; 		char size0; 		int size1; 		int ijunk[
literal|12
argument|]; 		} buf;
else|#
directive|else
argument|struct stat buf;
endif|#
directive|endif
argument|if(stat(filename,&buf)<
literal|0
argument|) 	return(-
literal|1
argument|);
ifdef|#
directive|ifdef
name|VERSION6
argument|return(buf.size0 || buf.size1);
else|#
directive|else
argument|return( buf.st_size>
literal|0
argument|);
endif|#
directive|endif
argument|}     crfnames() { fname(textfname,
literal|"x"
argument|); fname(asmfname,
literal|"s"
argument|); fname(asmpass2,
literal|"a"
argument|); fname(initfname,
literal|"d"
argument|); fname(sortfname,
literal|"S"
argument|); fname(objfdefault,
literal|"o"
argument|); fname(prepfname,
literal|"p"
argument|); fname(optzfname,
literal|"z"
argument|); fname(setfname,
literal|"A"
argument|); }     rmf(fn) register char *fn; {
comment|/* if(!debugflag&& fn!=NULL&& *fn!='\0') */
argument|if(fn!=NULL&& *fn!=
literal|'\0'
argument|) 	unlink(fn); }      LOCAL fname(name, suff) char *name
argument_list|,
argument|*suff; { sprintf(name,
literal|"%s/%s%d.%s"
argument|, _PATH_TMP, temppref, pid, suff); }     dotchar(s) register char *s; { for( ; *s ; ++s) 	if(s[
literal|0
argument|]==
literal|'.'
argument|&& s[
literal|1
argument|]!=
literal|'\0'
argument|&& s[
literal|2
argument|]==
literal|'\0'
argument|) 		return( s[
literal|1
argument|] ); return(NO); }    char *lastfield(s) register char *s; { register char *t; for(t = s; *s ; ++s) 	if(*s ==
literal|'/'
argument|) 		t = s+
literal|1
argument|; return(t); }    char *lastchar(s) register char *s; { while(*s) 	++s; return(s-
literal|1
argument|); }  char *setdoto(s) register char *s; { *lastchar(s) =
literal|'o'
argument|; return( lastfield(s) ); }    badfile(s) char *s; { fatalstr(
literal|"cannot open intermediate file %s"
argument|, s); }    ptr ckalloc(n) int n; { ptr p
argument_list|,
argument|calloc();  if( p = calloc(
literal|1
argument|, (unsigned) n) ) 	return(p);  fatal(
literal|"out of memory"
argument|);
comment|/* NOTREACHED */
argument|}      char *copyn(n, s) register int n; register char *s; { register char *p
argument_list|,
argument|*q;  p = q = (char *) ckalloc(n); while(n-->
literal|0
argument|) 	*q++ = *s++; return(p); }    char *copys(s) char *s; { return( copyn( strlen(s)+
literal|1
argument|, s) ); }      oneof(c,s) register c; register char *s; { while( *s ) 	if(*s++ == c) 		return(YES); return(NO); }    nodup(s) char *s; { register char **p;  for(p = loadargs ; p< loadp ; ++p) 	if( !strcmp(*p, s) ) 		return(NO);  return(YES); }    static fatal(t) char *t; { fprintf(diagfile,
literal|"Compiler error in file %s: %s\n"
argument|, infname, t); if(debugflag) 	abort(); done(
literal|1
argument|); exit(
literal|1
argument|); }     static fatali(t,d) char *t; int d; { char buff[
literal|100
argument|]; sprintf(buff, t, d); fatal(buff); }     static fatalstr(t, s) char *t
argument_list|,
argument|*s; { char buff[
literal|100
argument|]; sprintf(buff, t, s); fatal(buff); } err(s) char *s; { fprintf(diagfile,
literal|"Error in file %s: %s\n"
argument|, infname, s); }
end_block

end_unit

