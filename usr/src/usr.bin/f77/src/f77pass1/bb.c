begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bb.c	5.2 (Berkeley) 3/9/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * bb.c  *  * Basic block optimizations.  *  * University of Utah CS Dept modification history:  *  * $Log:	bb.c,v $  * Revision 5.2  86/03/09  18:13:56  donn  * In tempalloc(), don't forget to treat the vleng tree of a temp block  * before allocating it with altmpn.  *   * Revision 2.1  84/07/19  12:01:20  donn  * Changed comment headers for UofU.  *   * Revision 1.2  84/04/02  14:22:49  donn  * Bug in copy propagation missed places where temporaries are assigned to  * by OPSTAREQ or OPPLUSEQ, e.g. exponentiation with an integer constant  * power, expanded inline.  *   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"optim.h"
end_include

begin_comment
comment|/*  *  This file contains code for determination of basic blocks,  *  as well as some other optimization supporting routines  *  [including the main routine 'optimize()'].  *  *  The compiler's general debugging flag ['debugflag'] has been  *  extended to provide the capability of having multiple flags  *  which are contained in an array.  If the option -d is used,  *  then the flag debugflag[0] is set.  If a sequence of one or more  *  numbers are given (e.g, -d3,7,12), then the flags debugflag[3],  *  debugflag[7], and debugflag[12] are set.  The maximum number of  *  flags available is specified in the defines.h file.  */
end_comment

begin_decl_stmt
name|Bblockp
name|firstblock
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first block in buffer */
end_comment

begin_decl_stmt
name|Bblockp
name|lastblock
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last block in buffer */
end_comment

begin_function_decl
name|expptr
name|tempalloc
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|optimize
argument_list|()
end_macro

begin_block
block|{
name|Bblockp
name|bb
decl_stmt|;
name|Slotp
name|sl
decl_stmt|,
name|nextsl
decl_stmt|;
if|if
condition|(
name|debugflag
index|[
literal|2
index|]
condition|)
name|showbuffer
argument_list|()
expr_stmt|;
name|optloops
argument_list|()
expr_stmt|;
if|if
condition|(
name|debugflag
index|[
literal|3
index|]
condition|)
name|showbuffer
argument_list|()
expr_stmt|;
name|formbblock
argument_list|()
expr_stmt|;
name|optcse
argument_list|()
expr_stmt|;
if|if
condition|(
name|debugflag
index|[
literal|4
index|]
condition|)
name|showbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|debugflag
index|[
literal|7
index|]
condition|)
name|copyprop
argument_list|()
expr_stmt|;
if|if
condition|(
name|debugflag
index|[
literal|9
index|]
condition|)
name|showbuffer
argument_list|()
expr_stmt|;
for|for
control|(
name|sl
operator|=
name|firstslot
init|;
name|sl
condition|;
name|sl
operator|=
name|nextsl
control|)
block|{
name|nextsl
operator|=
name|sl
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|sl
operator|->
name|type
operator|==
name|SKFRTEMP
condition|)
block|{
name|templist
operator|=
name|mkchain
argument_list|(
name|sl
operator|->
name|expr
argument_list|,
name|templist
argument_list|)
expr_stmt|;
name|sl
operator|->
name|expr
operator|=
name|NULL
expr_stmt|;
name|delslot
argument_list|(
name|sl
argument_list|)
expr_stmt|;
block|}
else|else
name|sl
operator|->
name|expr
operator|=
name|tempalloc
argument_list|(
name|sl
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|debugflag
index|[
literal|10
index|]
condition|)
name|regalloc
argument_list|()
expr_stmt|;
name|flushopt
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  creates a new basic block record  */
end_comment

begin_function
name|LOCAL
name|Bblockp
name|newblock
parameter_list|(
name|sl
parameter_list|)
name|Slotp
name|sl
decl_stmt|;
block|{
specifier|register
name|Bblockp
name|bb
decl_stmt|;
name|bb
operator|=
name|ALLOC
argument_list|(
name|bblock
argument_list|)
expr_stmt|;
name|bb
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lastblock
condition|)
block|{
name|bb
operator|->
name|prev
operator|=
name|lastblock
expr_stmt|;
name|lastblock
operator|->
name|next
operator|=
name|bb
expr_stmt|;
name|lastblock
operator|=
name|bb
expr_stmt|;
block|}
else|else
block|{
name|firstblock
operator|=
name|lastblock
operator|=
name|bb
expr_stmt|;
name|bb
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
name|bb
operator|->
name|first
operator|=
name|sl
expr_stmt|;
return|return
operator|(
name|bb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  scans slot buffer, creating basic block records  */
end_comment

begin_macro
name|formbblock
argument_list|()
end_macro

begin_block
block|{
name|Slotp
name|sl
decl_stmt|;
name|field
name|type
decl_stmt|;
name|Bblockp
name|newbb
decl_stmt|;
name|newbb
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sl
operator|=
name|firstslot
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
block|{
name|type
operator|=
name|sl
operator|->
name|type
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SKEQ
case|:
if|if
condition|(
operator|!
name|newbb
condition|)
name|newbb
operator|=
name|newblock
argument_list|(
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
name|containscall
argument_list|(
name|sl
operator|->
name|expr
argument_list|)
condition|)
block|{
name|newbb
operator|->
name|last
operator|=
name|sl
expr_stmt|;
name|newbb
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|SKNULL
case|:
case|case
name|SKASSIGN
case|:
case|case
name|SKFRTEMP
case|:
if|if
condition|(
operator|!
name|newbb
condition|)
name|newbb
operator|=
name|newblock
argument_list|(
name|sl
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKPAUSE
case|:
case|case
name|SKSTOP
case|:
case|case
name|SKIFN
case|:
case|case
name|SKGOTO
case|:
case|case
name|SKCMGOTO
case|:
case|case
name|SKARIF
case|:
case|case
name|SKASGOTO
case|:
case|case
name|SKIOIFN
case|:
case|case
name|SKCALL
case|:
case|case
name|SKRETURN
case|:
if|if
condition|(
operator|!
name|newbb
condition|)
name|newbb
operator|=
name|newblock
argument_list|(
name|sl
argument_list|)
expr_stmt|;
name|newbb
operator|->
name|last
operator|=
name|sl
expr_stmt|;
name|newbb
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|SKLABEL
case|:
if|if
condition|(
name|newbb
condition|)
name|newbb
operator|->
name|last
operator|=
name|sl
operator|->
name|prev
expr_stmt|;
name|newbb
operator|=
name|newblock
argument_list|(
name|sl
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKDOHEAD
case|:
case|case
name|SKENDDO
case|:
if|if
condition|(
operator|!
name|newbb
condition|)
name|newbb
operator|=
name|newblock
argument_list|(
name|sl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badthing
argument_list|(
literal|"SKtype"
argument_list|,
literal|"formbblock"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|newbb
condition|)
name|newbb
operator|->
name|last
operator|=
name|lastslot
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  frees all basic block records  *  as well as the id and value node chains hanging off the bb and their  *  respective cross link chains (IDlist, DUPlist and NODElist structs)   */
end_comment

begin_macro
name|clearbb
argument_list|()
end_macro

begin_block
block|{
name|Bblockp
name|bb
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|bb
operator|=
name|firstblock
init|;
name|bb
condition|;
name|bb
operator|=
name|next
control|)
block|{
name|next
operator|=
name|bb
operator|->
name|next
expr_stmt|;
block|{
name|idptr
name|idp
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|idp
operator|=
name|bb
operator|->
name|headid
init|;
name|idp
condition|;
name|idp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|idp
operator|->
name|next
expr_stmt|;
block|{
name|nodelptr
name|nodelp
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|nodelp
operator|=
name|idp
operator|->
name|headnodelist
init|;
name|nodelp
condition|;
name|nodelp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|nodelp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|nodelp
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|idp
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|valuen
name|vp
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|vp
operator|=
name|bb
operator|->
name|headnode
init|;
name|vp
condition|;
name|vp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|vp
operator|->
name|next
expr_stmt|;
block|{
name|idlptr
name|idlp
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|idlp
operator|=
name|vp
operator|->
name|headdeplist
init|;
name|idlp
condition|;
name|idlp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|idlp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|idlp
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|duplptr
name|duplp
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|duplp
operator|=
name|vp
operator|->
name|headduplist
init|;
name|duplp
condition|;
name|duplp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|duplp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|duplp
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|bb
argument_list|)
expr_stmt|;
block|}
name|firstblock
operator|=
name|lastblock
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* structure for maintaining records on copy statements */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Subrec
block|{
name|Addrp
name|lmem
decl_stmt|;
name|Addrp
name|rmem
decl_stmt|;
name|int
name|sets
decl_stmt|;
block|}
typedef|*
name|Subrecp
typedef|;
end_typedef

begin_decl_stmt
name|LOCAL
name|chainp
name|sublist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of copy statements */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|prop1count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of number of temporaries eliminated */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|prop2count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of number of uses of temporaries replaced */
end_comment

begin_function_decl
name|expptr
name|rmcommaop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Addrp
name|subfor
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *  eliminates copy statements of the form T1 = T2 from the intermediate  *  code, where T1 and T2 are temporary variables which are each  *  set only once;  eliminates the copy statement and replaces each  *  use of T1 by T2 (T1 is therefore totally eliminated).  */
end_comment

begin_function
name|LOCAL
name|copyprop
parameter_list|()
block|{
name|Slotp
name|sl
decl_stmt|,
name|nextsl
decl_stmt|;
name|expptr
name|expr
decl_stmt|;
name|Tempp
name|lp
decl_stmt|,
name|rp
decl_stmt|;
for|for
control|(
name|sl
operator|=
name|firstslot
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
name|sl
operator|->
name|expr
operator|=
name|rmcommaop
argument_list|(
name|sl
operator|->
name|expr
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|prop1count
operator|=
name|prop2count
operator|=
literal|0
expr_stmt|;
name|findcopies
argument_list|()
expr_stmt|;
for|for
control|(
name|sl
operator|=
name|firstslot
init|;
name|sl
condition|;
name|sl
operator|=
name|nextsl
control|)
block|{
name|nextsl
operator|=
name|sl
operator|->
name|next
expr_stmt|;
name|expr
operator|=
name|sl
operator|->
name|expr
expr_stmt|;
if|if
condition|(
operator|(
name|sl
operator|->
name|type
operator|==
name|SKFRTEMP
operator|)
operator|&&
name|subfor
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|delslot
argument_list|(
name|sl
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ENULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|&&
name|expr
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|expr
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPASSIGN
condition|)
block|{
name|lp
operator|=
operator|(
name|Tempp
operator|)
name|expr
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
operator|(
name|Tempp
operator|)
name|expr
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TTEMP
operator|&&
name|rp
operator|->
name|tag
operator|==
name|TTEMP
condition|)
if|if
condition|(
name|subfor
argument_list|(
name|lp
operator|->
name|memalloc
argument_list|)
operator|==
name|rp
operator|->
name|memalloc
operator|&&
operator|!
name|subfor
argument_list|(
name|rp
operator|->
name|memalloc
argument_list|)
condition|)
block|{
name|frexpr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|sl
operator|->
name|expr
operator|=
name|ENULL
expr_stmt|;
name|prop1count
operator|++
expr_stmt|;
block|}
block|}
name|propagate
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debugflag
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%d temporarie%s replaced by copy propagation (%d use%s)\n"
argument_list|,
name|prop1count
argument_list|,
operator|(
name|prop1count
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|,
name|prop2count
argument_list|,
operator|(
name|prop2count
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  finds copy statements and enters information in table  */
end_comment

begin_function
name|LOCAL
name|findcopies
parameter_list|()
block|{
name|Slotp
name|sl
decl_stmt|;
name|expptr
name|expr
decl_stmt|;
name|chainp
name|cp
decl_stmt|;
for|for
control|(
name|sl
operator|=
name|firstslot
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
block|{
name|expr
operator|=
name|sl
operator|->
name|expr
expr_stmt|;
if|if
condition|(
name|expr
condition|)
switch|switch
condition|(
name|expr
operator|->
name|tag
condition|)
block|{
case|case
name|TEXPR
case|:
name|ckexpr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLIST
case|:
for|for
control|(
name|cp
operator|=
name|expr
operator|->
name|listblock
operator|.
name|listp
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|expr
operator|=
operator|(
name|expptr
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
name|ckexpr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  checks an individual expression  */
end_comment

begin_macro
name|ckexpr
argument_list|(
argument|expr
argument_list|)
end_macro

begin_decl_stmt
name|expptr
name|expr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Tempp
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|int
name|oc
init|=
name|expr
operator|->
name|exprblock
operator|.
name|opcode
decl_stmt|;
if|if
condition|(
name|oc
operator|==
name|OPASSIGN
operator|||
name|oc
operator|==
name|OPPLUSEQ
operator|||
name|oc
operator|==
name|OPSTAREQ
condition|)
block|{
name|lp
operator|=
operator|(
name|Tempp
operator|)
name|expr
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
operator|(
name|Tempp
operator|)
name|expr
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TTEMP
condition|)
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TTEMP
operator|&&
name|oc
operator|==
name|OPASSIGN
condition|)
name|enter
argument_list|(
name|lp
operator|->
name|memalloc
argument_list|,
name|rp
operator|->
name|memalloc
argument_list|)
expr_stmt|;
else|else
name|enter
argument_list|(
name|lp
operator|->
name|memalloc
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *  Enters the given memalloc values in the table (or update if they  *  are already there), for the assignment statement m1 = m2.  *  If m2 is NULL, this indicates that the assignment is not a copy  *  statement.  */
end_comment

begin_function
name|LOCAL
name|enter
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
name|Addrp
name|m1
decl_stmt|,
name|m2
decl_stmt|;
block|{
name|chainp
name|cp
decl_stmt|;
name|Subrecp
name|old
decl_stmt|,
name|new
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|sublist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|old
operator|=
operator|(
name|Subrecp
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|lmem
operator|==
name|m1
condition|)
block|{
name|old
operator|->
name|sets
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|new
operator|=
name|ALLOC
argument_list|(
name|Subrec
argument_list|)
expr_stmt|;
name|new
operator|->
name|lmem
operator|=
name|m1
expr_stmt|;
name|new
operator|->
name|rmem
operator|=
name|m2
expr_stmt|;
name|new
operator|->
name|sets
operator|=
literal|1
expr_stmt|;
name|sublist
operator|=
name|mkchain
argument_list|(
name|new
argument_list|,
name|sublist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  looks for record for the given memalloc value  */
end_comment

begin_function
name|LOCAL
name|Subrecp
name|lookup
parameter_list|(
name|mem
parameter_list|)
name|Addrp
name|mem
decl_stmt|;
block|{
name|chainp
name|cp
decl_stmt|;
name|Subrecp
name|rec
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|sublist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|rec
operator|=
operator|(
name|Subrecp
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|lmem
operator|==
name|mem
condition|)
return|return
name|rec
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  *  checks to see if there is a substitute for given memalloc value  */
end_comment

begin_function
name|LOCAL
name|Addrp
name|subfor
parameter_list|(
name|mem
parameter_list|)
name|Addrp
name|mem
decl_stmt|;
block|{
name|Subrecp
name|rec
decl_stmt|,
name|rec2
decl_stmt|;
name|Addrp
name|sub
decl_stmt|;
name|rec
operator|=
name|lookup
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|&&
name|rec
operator|->
name|sets
operator|==
literal|1
condition|)
block|{
name|sub
operator|=
name|rec
operator|->
name|rmem
expr_stmt|;
name|rec2
operator|=
name|lookup
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec2
operator|&&
name|rec2
operator|->
name|sets
operator|==
literal|1
condition|)
return|return
name|sub
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  *  actually propagates the information  */
end_comment

begin_function
name|LOCAL
name|propagate
parameter_list|(
name|expr
parameter_list|)
name|expptr
name|expr
decl_stmt|;
block|{
name|chainp
name|t
decl_stmt|;
name|Addrp
name|new
decl_stmt|;
if|if
condition|(
operator|!
name|expr
condition|)
return|return;
switch|switch
condition|(
name|expr
operator|->
name|tag
condition|)
block|{
case|case
name|TEXPR
case|:
name|propagate
argument_list|(
name|expr
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|propagate
argument_list|(
name|expr
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TADDR
case|:
name|propagate
argument_list|(
name|expr
operator|->
name|addrblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|propagate
argument_list|(
name|expr
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLIST
case|:
for|for
control|(
name|t
operator|=
name|expr
operator|->
name|listblock
operator|.
name|listp
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|nextp
control|)
name|propagate
argument_list|(
name|t
operator|->
name|datap
argument_list|)
expr_stmt|;
break|break;
case|case
name|TTEMP
case|:
name|new
operator|=
name|subfor
argument_list|(
name|expr
operator|->
name|tempblock
operator|.
name|memalloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|expr
operator|->
name|tempblock
operator|.
name|memalloc
operator|=
name|new
expr_stmt|;
name|prop2count
operator|++
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *  allocates ADDR blocks for each TEMP in the expression  */
end_comment

begin_function
name|LOCAL
name|expptr
name|tempalloc
parameter_list|(
name|expr
parameter_list|)
name|expptr
name|expr
decl_stmt|;
block|{
name|chainp
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|expr
operator|->
name|tag
condition|)
block|{
case|case
name|TEXPR
case|:
name|expr
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|tempalloc
argument_list|(
name|expr
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|expr
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|tempalloc
argument_list|(
name|expr
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TADDR
case|:
name|expr
operator|->
name|addrblock
operator|.
name|vleng
operator|=
name|tempalloc
argument_list|(
name|expr
operator|->
name|addrblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|expr
operator|->
name|addrblock
operator|.
name|memoffset
operator|=
name|tempalloc
argument_list|(
name|expr
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLIST
case|:
for|for
control|(
name|t
operator|=
name|expr
operator|->
name|listblock
operator|.
name|listp
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|nextp
control|)
name|t
operator|->
name|datap
operator|=
operator|(
name|tagptr
operator|)
name|tempalloc
argument_list|(
name|t
operator|->
name|datap
argument_list|)
expr_stmt|;
break|break;
case|case
name|TTEMP
case|:
name|expr
operator|->
name|tempblock
operator|.
name|vleng
operator|=
name|tempalloc
argument_list|(
name|expr
operator|->
name|tempblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
return|return
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|altmpn
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/********************* debugging routines *********************/
end_comment

begin_macro
name|Announce
argument_list|(
argument|s
argument_list|,
argument|q
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|expptr
name|q
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\nAn expression [%s]----->\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|showexpr
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n-------------end of expr--------------\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  dump the basic block buffer, including expressions, mnemonically  */
end_comment

begin_macro
name|showbuffer
argument_list|()
end_macro

begin_block
block|{
name|Slotp
name|sl
decl_stmt|;
name|Bblockp
name|bb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Basic blocks with first and last slots ----------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|bb
operator|=
name|firstblock
init|;
name|bb
condition|;
name|i
operator|++
operator|,
name|bb
operator|=
name|bb
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%2d.  %d  %d\n"
argument_list|,
name|i
argument_list|,
name|bb
operator|->
name|first
argument_list|,
name|bb
operator|->
name|last
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Slots and expressions ----------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"tag pointer vtype vclass vstg vleng\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"          ADDR memno memoffset istemp ntempelt varleng\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"          TEMP memalloc istemp ntempelt varleng\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"          EXPR opcode leftp rightp\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"          LIST type listp\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|sl
operator|=
name|firstslot
init|;
name|sl
condition|;
name|i
operator|++
operator|,
name|sl
operator|=
name|sl
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%2d.  "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|showslt
argument_list|(
name|sl
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"---------- End of showbuffer ----------\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  dumps a single slot in the code buffer  */
end_comment

begin_decl_stmt
name|LOCAL
name|charptr
name|Zslot
index|[]
init|=
block|{
literal|"NULL"
block|,
literal|"IFN"
block|,
literal|"GOTO"
block|,
literal|"LABEL"
block|,
literal|"EQ"
block|,
literal|"CALL"
block|,
literal|"CMGOTO"
block|,
literal|"STOP"
block|,
literal|"DOHEAD"
block|,
literal|"ENDDO"
block|,
literal|"ARIF"
block|,
literal|"RETURN"
block|,
literal|"ASGOTO"
block|,
literal|"PAUSE"
block|,
literal|"ASSIGN"
block|,
literal|"IOIFN"
block|,
literal|"FRTEMP"
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|showslt
argument_list|(
argument|sl
argument_list|)
end_macro

begin_decl_stmt
name|Slotp
name|sl
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"(%2d)  %d  %s  %d\n"
argument_list|,
name|sl
operator|->
name|lineno
argument_list|,
name|sl
argument_list|,
name|Zslot
index|[
name|sl
operator|->
name|type
index|]
argument_list|,
name|sl
operator|->
name|label
argument_list|)
expr_stmt|;
name|showexpr
argument_list|(
name|sl
operator|->
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|showslottype
argument_list|(
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%s\n"
argument_list|,
name|Zslot
index|[
name|type
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  displays the given expression at the given indentation, showing  *  its subexpressions at further indentations  */
end_comment

begin_decl_stmt
name|LOCAL
name|charptr
name|Ztag
index|[]
init|=
block|{
literal|"----"
block|,
literal|"NAME"
block|,
literal|"CONST"
block|,
literal|"EXPR"
block|,
literal|"ADDR"
block|,
literal|"TEMP"
block|,
literal|"PRIM"
block|,
literal|"LIST"
block|,
literal|"IMPLDO"
block|,
literal|"ERROR"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|charptr
name|Zstg
index|[]
init|=
block|{
literal|"unk"
block|,
literal|"ARG"
block|,
literal|"AUTO"
block|,
literal|"BSS"
block|,
literal|"INIT"
block|,
literal|"CONST"
block|,
literal|"EXT"
block|,
literal|"INTR"
block|,
literal|"STFUNCT"
block|,
literal|"COMMON"
block|,
literal|"EQUIV"
block|,
literal|"REG"
block|,
literal|"LENG"
block|,
literal|"NULL"
block|,
literal|"PREG"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|charptr
name|Zclass
index|[]
init|=
block|{
literal|"unk"
block|,
literal|"PARAM"
block|,
literal|"VAR"
block|,
literal|"ENTRY"
block|,
literal|"MAIN"
block|,
literal|"BLOCK"
block|,
literal|"PROC"
block|,
literal|"NAMELIST"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|charptr
name|Zop
index|[]
init|=
block|{
literal|"----"
block|,
literal|"PLUS"
block|,
literal|"MINUS"
block|,
literal|"STAR"
block|,
literal|"SLASH"
block|,
literal|"POWER"
block|,
literal|"NEG"
block|,
literal|"OR"
block|,
literal|"AND"
block|,
literal|"EQV"
block|,
literal|"NEQV"
block|,
literal|"NOT"
block|,
literal|"CONCAT"
block|,
literal|"LT"
block|,
literal|"EQ"
block|,
literal|"GT"
block|,
literal|"LE"
block|,
literal|"NE"
block|,
literal|"GE"
block|,
literal|"CALL"
block|,
literal|"CCALL"
block|,
literal|"ASSIGN"
block|,
literal|"PLUSEQ"
block|,
literal|"STAREQ"
block|,
literal|"CONV"
block|,
literal|"LSHIFT"
block|,
literal|"MOD"
block|,
literal|"COMMA"
block|,
literal|"QUEST"
block|,
literal|"COLON"
block|,
literal|"ABS"
block|,
literal|"MIN"
block|,
literal|"MAX"
block|,
literal|"ADDR"
block|,
literal|"INDIRECT"
block|,
literal|"BITOR"
block|,
literal|"BITAND"
block|,
literal|"BITXOR"
block|,
literal|"BITNOT"
block|,
literal|"RSHIFT"
block|,
literal|"PAREN"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|charptr
name|Ztype
index|[]
init|=
block|{
literal|"unk"
block|,
literal|"ADDR"
block|,
literal|"SHORT"
block|,
literal|"LONG"
block|,
literal|"REAL"
block|,
literal|"DREAL"
block|,
literal|"COMPLEX"
block|,
literal|"DCOMPLEX"
block|,
literal|"LOGICAL"
block|,
literal|"CHAR"
block|,
literal|"SUBR"
block|,
literal|"ERROR"
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|showexpr
argument_list|(
argument|p
argument_list|,
argument|indent
argument_list|)
end_macro

begin_decl_stmt
name|tagptr
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|indent
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|type
decl_stmt|;
name|chainp
name|q
decl_stmt|;
define|#
directive|define
name|PRHEAD
parameter_list|(
name|q
parameter_list|)
value|fprintf(diagfile,"%s %d %s %s %s %d", \ 	Ztag[q->tag], q, Ztype[q->headblock.vtype], \ 	Zclass[q->headblock.vclass], Zstg[q->headblock.vstg], \ 	q->headblock.vleng);
define|#
directive|define
name|SHOWEXPR
parameter_list|(
name|p
parameter_list|)
value|showexpr(p,indent+2)
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|diagfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
name|PRHEAD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|type
operator|=
name|p
operator|->
name|constblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|ISCHAR
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" ISCHAR ccp= %d\n"
argument_list|,
name|p
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ccp
argument_list|)
expr_stmt|;
name|SHOWEXPR
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISINT
argument_list|(
name|type
argument_list|)
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" ci= %d\n"
argument_list|,
name|p
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISREAL
argument_list|(
name|type
argument_list|)
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" cd[0]= %e\n"
argument_list|,
name|p
operator|->
name|constblock
operator|.
expr|const
operator|.
name|cd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" cd[0]= %e  cd[1]= %e\n"
argument_list|,
name|p
operator|->
name|constblock
operator|.
expr|const
operator|.
name|cd
index|[
literal|0
index|]
argument_list|,
name|p
operator|->
name|constblock
operator|.
expr|const
operator|.
name|cd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TADDR
case|:
name|PRHEAD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" memno= %d %d %d %d %d\n"
argument_list|,
name|p
operator|->
name|addrblock
operator|.
name|memno
argument_list|,
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|,
name|p
operator|->
name|addrblock
operator|.
name|istemp
argument_list|,
name|p
operator|->
name|addrblock
operator|.
name|ntempelt
argument_list|,
name|p
operator|->
name|addrblock
operator|.
name|varleng
argument_list|)
expr_stmt|;
name|SHOWEXPR
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|SHOWEXPR
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TTEMP
case|:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%s %d %s %s %d"
argument_list|,
name|Ztag
index|[
name|p
operator|->
name|tag
index|]
argument_list|,
name|p
argument_list|,
name|Ztype
index|[
name|p
operator|->
name|headblock
operator|.
name|vtype
index|]
argument_list|,
name|Zclass
index|[
name|p
operator|->
name|headblock
operator|.
name|vclass
index|]
argument_list|,
name|p
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" memalloc= %d %d %d %d\n"
argument_list|,
name|p
operator|->
name|tempblock
operator|.
name|memalloc
argument_list|,
name|p
operator|->
name|tempblock
operator|.
name|istemp
argument_list|,
name|p
operator|->
name|tempblock
operator|.
name|ntempelt
argument_list|,
name|p
operator|->
name|tempblock
operator|.
name|varleng
argument_list|)
expr_stmt|;
name|SHOWEXPR
argument_list|(
name|p
operator|->
name|tempblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|SHOWEXPR
argument_list|(
name|p
operator|->
name|tempblock
operator|.
name|memalloc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TERROR
case|:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"ERROR %d\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TNAME
case|:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"NAME %d\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|TPRIM
case|:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"PRIM %d --- not implemented\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEXPR
case|:
name|PRHEAD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" opcode= %s %d %d\n"
argument_list|,
name|Zop
index|[
name|p
operator|->
name|exprblock
operator|.
name|opcode
index|]
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|SHOWEXPR
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
condition|)
name|SHOWEXPR
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLIST
case|:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"LIST %d %s %d\n"
argument_list|,
name|p
argument_list|,
name|Ztype
index|[
name|p
operator|->
name|listblock
operator|.
name|vtype
index|]
argument_list|,
name|p
operator|->
name|listblock
operator|.
name|listp
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|listblock
operator|.
name|listp
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
name|SHOWEXPR
argument_list|(
name|q
operator|->
name|datap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|diagfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"END LIST %d\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"showexpr BAD TAG= %d at %d \n"
argument_list|,
name|p
operator|->
name|tag
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|selective
argument_list|()
end_macro

begin_comment
comment|/************************************/
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
name|Slotp
name|sl
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SELECTIVE OUTPUT\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|sl
operator|=
name|firstslot
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|176
operator|&&
name|i
operator|<
literal|184
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d.  "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|showslt
argument_list|(
name|sl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_function
name|LOCAL
name|containscall
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|chainp
name|cp
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NO
return|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TADDR
case|:
if|if
condition|(
name|containscall
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|vleng
argument_list|)
operator|||
name|containscall
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
condition|)
return|return
name|YES
return|;
else|else
return|return
name|NO
return|;
case|case
name|TCONST
case|:
return|return
name|NO
return|;
case|case
name|TERROR
case|:
return|return
name|NO
return|;
case|case
name|TEXPR
case|:
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCALL
operator|||
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCCALL
condition|)
return|return
name|YES
return|;
if|if
condition|(
name|containscall
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
operator|||
name|containscall
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
operator|||
name|containscall
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
return|return
name|YES
return|;
else|else
return|return
name|NO
return|;
case|case
name|TLIST
case|:
name|cp
operator|=
name|p
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|containscall
argument_list|(
name|cp
operator|->
name|datap
argument_list|)
condition|)
return|return
name|YES
return|;
name|cp
operator|=
name|cp
operator|->
name|nextp
expr_stmt|;
block|}
return|return
name|NO
return|;
default|default:
return|return
name|YES
return|;
block|}
block|}
end_function

end_unit

