begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)putpcc.c	5.3 (Berkeley) 1/3/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * putpcc.c  *  * Intermediate code generation for S. C. Johnson C compilers  * New version using binary polish postfix intermediate  *  * University of Utah CS Dept modification history:  *  * $Header: putpcc.c,v 5.2 86/03/04 17:49:38 donn Exp $  * $Log:	putpcc.c,v $  * Revision 5.2  86/03/04  17:49:38  donn  * Change putct1() to emit the memoffset before the vleng -- the memoffset  * may define a temporary which is used by the vleng to avoid repeated  * evaluation of an expression with side effects.  *   * Revision 5.1  85/08/10  03:49:26  donn  * 4.3 alpha  *   * Revision 3.2  85/03/25  09:35:57  root  * fseek return -1 on error.  *   * Revision 3.1  85/02/27  19:06:55  donn  * Changed to use pcc.h instead of pccdefs.h.  *   * Revision 2.12  85/02/22  01:05:54  donn  * putaddr() didn't know about intrinsic functions...  *   * Revision 2.11  84/11/28  21:28:49  donn  * Hacked putop() to handle any character expression being converted to int,  * not just function calls.  Previously it bombed on concatenations.  *   * Revision 2.10  84/11/01  22:07:07  donn  * Yet another try at getting putop() to work right.  It appears that the  * second pass can't abide certain explicit conversions (e.g. short to long)  * so the conversion code in putop() tries to remove them.  I think this  * version (finally) works.  *   * Revision 2.9  84/10/29  02:30:57  donn  * Earlier fix to putop() for conversions was insufficient -- we NEVER want to  * see the type of the left operand of the thing left over from stripping off  * conversions...  *   * Revision 2.8  84/09/18  03:09:21  donn  * Fixed bug in putop() where the left operand of an addrblock was being  * extracted...  This caused an extremely obscure conversion error when  * an array of longs was subscripted by a short.  *   * Revision 2.7  84/08/19  20:10:19  donn  * Removed stuff in putbranch that treats STGARG parameters specially -- the  * bug in the code generation pass that motivated it has been fixed.  *   * Revision 2.6  84/08/07  21:32:23  donn  * Bumped the size of the buffer for the intermediate code file from 0.5K  * to 4K on a VAX.  *   * Revision 2.5  84/08/04  20:26:43  donn  * Fixed a goof in the new putbranch() -- it now calls mkaltemp instead of  * mktemp().  Correction due to Jerry Berkman.  *   * Revision 2.4  84/07/24  19:07:15  donn  * Fixed bug reported by Craig Leres in which putmnmx() mistakenly assumed  * that mkaltemp() returns tempblocks, and tried to free them with frtemp().  *   * Revision 2.3  84/07/19  17:22:09  donn  * Changed putch1() so that OPPAREN expressions of type CHARACTER are legal.  *   * Revision 2.2  84/07/19  12:30:38  donn  * Fixed a type clash in Bob Corbett's new putbranch().  *   * Revision 2.1  84/07/19  12:04:27  donn  * Changed comment headers for UofU.  *   * Revision 1.8  84/07/19  11:38:23  donn  * Replaced putbranch() routine so that you can ASSIGN into argument variables.  * The code is from Bob Corbett, donated by Jerry Berkman.  *   * Revision 1.7  84/05/31  00:48:32  donn  * Fixed an extremely obscure bug dealing with the comparison of CHARACTER*1  * expressions -- a foulup in the order of COMOP and the comparison caused  * one operand of the comparison to be garbage.  *   * Revision 1.6  84/04/16  09:54:19  donn  * Backed out earlier fix for bug where items in the argtemplist were  * (incorrectly) being given away; this is now fixed in mkargtemp().  *   * Revision 1.5  84/03/23  22:49:48  donn  * Took out the initialization of the subroutine argument temporary list in  * putcall() -- it needs to be done once per statement instead of once per call.  *   * Revision 1.4  84/03/01  06:48:05  donn  * Fixed bug in Bob Corbett's code for argument temporaries that caused an  * addrblock to get thrown out inadvertently when it was needed for recycling  * purposes later on.  *   * Revision 1.3  84/02/26  06:32:38  donn  * Added Berkeley changes to move data definitions around and reduce offsets.  *   * Revision 1.2  84/02/26  06:27:45  donn  * Added code to catch TTEMP values passed to putx().  *   */
end_comment

begin_if
if|#
directive|if
name|FAMILY
operator|!=
name|PCC
end_if

begin_expr_stmt
name|WRONG
name|put
name|FILE
operator|!
operator|!
operator|!
operator|!
endif|#
directive|endif
include|#
directive|include
file|"defs.h"
include|#
directive|include
file|<pcc.h>
name|Addrp
name|putcall
argument_list|()
operator|,
name|putcxeq
argument_list|()
operator|,
name|putcx1
argument_list|()
operator|,
name|realpart
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
name|expptr
name|imagpart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|ftnint
name|lencat
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FOUR
value|4
end_define

begin_decl_stmt
specifier|extern
name|int
name|ops2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|types2
index|[]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HERE
operator|==
name|VAX
end_if

begin_define
define|#
directive|define
name|PCC_BUFFMAX
value|1024
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PCC_BUFFMAX
value|128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|long
name|int
name|p2buff
index|[
name|PCC_BUFFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
modifier|*
name|p2bufp
init|=
operator|&
name|p2buff
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
modifier|*
name|p2bufend
init|=
operator|&
name|p2buff
index|[
name|PCC_BUFFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|puthead
argument_list|(
argument|s
argument_list|,
argument|class
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|VAX
if|if
condition|(
name|s
condition|)
name|p2ps
argument_list|(
literal|"\t.globl\t_%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* put out fake copy of left bracket line, to be redone later */
if|if
condition|(
operator|!
name|headerdone
condition|)
block|{
if|#
directive|if
name|FAMILY
operator|==
name|PCC
name|p2flush
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|headoffset
operator|=
name|ftell
argument_list|(
name|textfile
argument_list|)
expr_stmt|;
name|prhead
argument_list|(
name|textfile
argument_list|)
expr_stmt|;
name|headerdone
operator|=
name|YES
expr_stmt|;
name|p2triple
argument_list|(
name|PCCF_FEXPR
argument_list|,
operator|(
name|strlen
argument_list|(
name|infname
argument_list|)
operator|+
name|FOUR
operator|-
literal|1
operator|)
operator|/
name|FOUR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2str
argument_list|(
name|infname
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
comment|/* fake jump to start the optimizer */
if|if
condition|(
name|class
operator|!=
name|CLBLOCK
condition|)
name|putgoto
argument_list|(
name|fudgelabel
operator|=
name|newlabel
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|VAX
comment|/* jump from top to bottom */
if|if
condition|(
name|s
operator|!=
name|CNULL
operator|&&
name|class
operator|!=
name|CLBLOCK
condition|)
block|{
name|int
name|proflab
init|=
name|newlabel
argument_list|()
decl_stmt|;
name|p2ps
argument_list|(
literal|"_%s:"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|p2pi
argument_list|(
literal|"\t.word\tLWM%d"
argument_list|,
name|procno
argument_list|)
expr_stmt|;
name|prsave
argument_list|(
name|proflab
argument_list|)
expr_stmt|;
name|p2pi
argument_list|(
literal|"\tjbr\tL%d"
argument_list|,
name|fudgelabel
operator|=
name|newlabel
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_block

begin_comment
comment|/* It is necessary to precede each procedure with a "left bracket"  * line that tells pass 2 how many register variables and how  * much automatic space is required for the function.  This compiler  * does not know how much automatic space is needed until the  * entire procedure has been processed.  Therefore, "puthead"  * is called at the begining to record the current location in textfile,  * then to put out a placeholder left bracket line.  This procedure  * repositions the file and rewrites that line, then puts the  * file pointer back to the end of the file.  */
end_comment

begin_macro
name|putbracket
argument_list|()
end_macro

begin_block
block|{
name|long
name|int
name|hereoffset
decl_stmt|;
if|#
directive|if
name|FAMILY
operator|==
name|PCC
name|p2flush
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|hereoffset
operator|=
name|ftell
argument_list|(
name|textfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|textfile
argument_list|,
name|headoffset
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"fseek failed"
argument_list|)
expr_stmt|;
name|prhead
argument_list|(
name|textfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|textfile
argument_list|,
name|hereoffset
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"fseek failed 2"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putrbrack
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2op
argument_list|(
name|PCCF_FRBRAC
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putnreg
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_macro
name|puteof
argument_list|()
end_macro

begin_block
block|{
name|p2op
argument_list|(
name|PCCF_FEOF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|putstmt
argument_list|()
end_macro

begin_block
block|{
name|p2triple
argument_list|(
name|PCCF_FEXPR
argument_list|,
literal|0
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* put out code for if( ! p) goto l  */
end_comment

begin_expr_stmt
name|putif
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
specifier|register
name|expptr
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
operator|(
name|p
operator|=
name|fixtype
argument_list|(
name|p
argument_list|)
operator|)
operator|->
name|headblock
operator|.
name|vtype
operator|)
operator|!=
name|TYLOGICAL
condition|)
block|{
if|if
condition|(
name|k
operator|!=
name|TYERROR
condition|)
name|err
argument_list|(
literal|"non-logical expression in IF statement"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putex1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p2icon
argument_list|(
operator|(
name|long
name|int
operator|)
name|l
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_CBRANCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* put out code for  goto l   */
end_comment

begin_macro
name|putgoto
argument_list|(
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|int
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2triple
argument_list|(
name|PCC_GOTO
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* branch to address constant or integer variable */
end_comment

begin_expr_stmt
name|putbranch
argument_list|(
name|p
argument_list|)
specifier|register
name|Addrp
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|putex1
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_GOTO
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* put out label  l:     */
end_comment

begin_macro
name|putlabel
argument_list|(
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|int
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2op
argument_list|(
name|PCCF_FLABEL
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putexpr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|expptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putex1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|putcmgo
argument_list|(
argument|index
argument_list|,
argument|nlab
argument_list|,
argument|labs
argument_list|)
end_macro

begin_decl_stmt
name|expptr
name|index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nlab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Labelblock
modifier|*
name|labs
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|labarray
decl_stmt|,
name|skiplabel
decl_stmt|;
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|index
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|execerr
argument_list|(
literal|"computed goto index must be integer"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|TARGET
operator|==
name|VAX
comment|/* use special case instruction */
name|vaxgoto
argument_list|(
name|index
argument_list|,
name|nlab
argument_list|,
name|labs
argument_list|)
expr_stmt|;
else|#
directive|else
name|labarray
operator|=
name|newlabel
argument_list|()
expr_stmt|;
name|preven
argument_list|(
name|ALIADDR
argument_list|)
expr_stmt|;
name|prlabel
argument_list|(
name|asmfile
argument_list|,
name|labarray
argument_list|)
expr_stmt|;
name|prcona
argument_list|(
name|asmfile
argument_list|,
call|(
name|ftnint
call|)
argument_list|(
name|skiplabel
operator|=
name|newlabel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlab
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|labs
index|[
name|i
index|]
condition|)
name|prcona
argument_list|(
name|asmfile
argument_list|,
call|(
name|ftnint
call|)
argument_list|(
name|labs
index|[
name|i
index|]
operator|->
name|labelno
argument_list|)
argument_list|)
expr_stmt|;
name|prcmgoto
argument_list|(
name|index
argument_list|,
name|nlab
argument_list|,
name|skiplabel
argument_list|,
name|labarray
argument_list|)
expr_stmt|;
name|putlabel
argument_list|(
name|skiplabel
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_macro
name|putx
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|expptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|memname
parameter_list|()
function_decl|;
name|int
name|opc
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
name|int
name|type
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TERROR
case|:
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCONST
case|:
switch|switch
condition|(
name|type
operator|=
name|p
operator|->
name|constblock
operator|.
name|vtype
condition|)
block|{
case|case
name|TYLOGICAL
case|:
name|type
operator|=
name|tyint
expr_stmt|;
case|case
name|TYLONG
case|:
case|case
name|TYSHORT
case|:
name|p2icon
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
argument_list|,
name|types2
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYADDR
case|:
name|p2triple
argument_list|(
name|PCC_ICON
argument_list|,
literal|1
argument_list|,
name|PCCT_INT
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|p2name
argument_list|(
name|memname
argument_list|(
name|STGCONST
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putx
argument_list|(
name|putconst
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|TEXPR
case|:
switch|switch
condition|(
name|opc
operator|=
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|putcall
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPMIN
case|:
case|case
name|OPMAX
case|:
name|putmnmx
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPASSIGN
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|||
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|frexpr
argument_list|(
name|putcxeq
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCHAR
argument_list|(
name|p
argument_list|)
condition|)
name|putcheq
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPEQ
case|:
case|case
name|OPNE
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|||
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|putcxcmp
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPLT
case|:
case|case
name|OPLE
case|:
case|case
name|OPGT
case|:
case|case
name|OPGE
case|:
if|if
condition|(
name|ISCHAR
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
condition|)
block|{
name|putchcmp
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|putopp
goto|;
case|case
name|OPPOWER
case|:
name|putpower
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPSTAR
case|:
if|#
directive|if
name|FAMILY
operator|==
name|PCC
comment|/*   m * (2**k) -> m<<k   */
if|if
condition|(
name|INT
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|&&
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|&&
operator|(
operator|(
name|k
operator|=
name|log2
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPLSHIFT
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|ICON
argument_list|(
name|k
argument_list|)
expr_stmt|;
goto|goto
name|putopp
goto|;
block|}
endif|#
directive|endif
case|case
name|OPMOD
case|:
goto|goto
name|putopp
goto|;
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
case|case
name|OPSLASH
case|:
case|case
name|OPNEG
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPCONV
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putx
argument_list|(
name|mkconv
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|,
name|realpart
argument_list|(
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPNOT
case|:
case|case
name|OPOR
case|:
case|case
name|OPAND
case|:
case|case
name|OPEQV
case|:
case|case
name|OPNEQV
case|:
case|case
name|OPADDR
case|:
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
case|case
name|OPCOMMA
case|:
case|case
name|OPQUEST
case|:
case|case
name|OPCOLON
case|:
case|case
name|OPBITOR
case|:
case|case
name|OPBITAND
case|:
case|case
name|OPBITXOR
case|:
case|case
name|OPBITNOT
case|:
case|case
name|OPLSHIFT
case|:
case|case
name|OPRSHIFT
case|:
name|putopp
label|:
name|putop
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPPAREN
case|:
name|putx
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badop
argument_list|(
literal|"putx"
argument_list|,
name|opc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TADDR
case|:
name|putaddr
argument_list|(
name|p
argument_list|,
name|YES
argument_list|)
expr_stmt|;
break|break;
case|case
name|TTEMP
case|:
comment|/* 		 * This type is sometimes passed to putx when errors occur 		 *	upstream, I don't know why. 		 */
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badtag
argument_list|(
literal|"putx"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|LOCAL
name|putop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|k
decl_stmt|;
name|expptr
name|lp
decl_stmt|,
name|tp
decl_stmt|;
name|int
name|pt
decl_stmt|,
name|lt
decl_stmt|,
name|tt
decl_stmt|;
name|int
name|comma
decl_stmt|;
name|Addrp
name|putch1
parameter_list|()
function_decl|;
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
comment|/* check for special cases and rewrite */
block|{
case|case
name|OPCONV
case|:
name|tt
operator|=
name|pt
operator|=
name|p
operator|->
name|exprblock
operator|.
name|vtype
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|lt
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|pt
operator|==
name|TYREAL
operator|&&
name|lt
operator|==
name|TYDREAL
condition|)
block|{
name|putx
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_SCONV
argument_list|,
name|PCCT_FLOAT
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONV
operator|&&
operator|(
operator|(
name|ISREAL
argument_list|(
name|pt
argument_list|)
operator|&&
name|ISREAL
argument_list|(
name|lt
argument_list|)
operator|)
operator|||
operator|(
name|INT
argument_list|(
name|pt
argument_list|)
operator|&&
operator|(
name|ONEOF
argument_list|(
name|lt
argument_list|,
name|MSKINT
operator||
name|MSKADDR
operator||
name|MSKCHAR
operator||
name|M
argument_list|(
name|TYSUBR
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
if|#
directive|if
name|SZINT
operator|<
name|SZLONG
if|if
condition|(
name|lp
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
block|{
if|if
condition|(
name|pt
operator|==
name|TYINT
operator|&&
name|lt
operator|==
name|TYLONG
condition|)
break|break;
if|if
condition|(
name|lt
operator|==
name|TYINT
operator|&&
name|pt
operator|==
name|TYLONG
condition|)
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|VAX
if|if
condition|(
name|pt
operator|==
name|TYDREAL
operator|&&
name|lt
operator|==
name|TYREAL
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONV
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYDREAL
condition|)
block|{
name|putx
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_SCONV
argument_list|,
name|PCCT_FLOAT
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_SCONV
argument_list|,
name|PCCT_DOUBLE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|&&
name|lp
operator|->
name|tag
operator|==
name|TEXPR
condition|)
block|{
name|int
name|ncomma
init|=
literal|0
decl_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
operator|(
name|expptr
operator|)
name|putch1
argument_list|(
name|lp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|pt
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|lp
expr_stmt|;
name|pt
operator|=
name|lt
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
condition|)
block|{
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|lt
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONV
condition|)
break|break;
name|putx
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|types2
index|[
name|tt
index|]
operator|!=
name|types2
index|[
name|pt
index|]
operator|&&
operator|!
operator|(
operator|(
name|ISREAL
argument_list|(
name|tt
argument_list|)
operator|&&
name|ISREAL
argument_list|(
name|pt
argument_list|)
operator|)
operator|||
operator|(
name|INT
argument_list|(
name|tt
argument_list|)
operator|&&
operator|(
name|ONEOF
argument_list|(
name|pt
argument_list|,
name|MSKINT
operator||
name|MSKADDR
operator||
name|MSKCHAR
operator||
name|M
argument_list|(
name|TYSUBR
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|p2op
argument_list|(
name|PCC_SCONV
argument_list|,
name|types2
index|[
name|tt
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|OPADDR
case|:
name|comma
operator|=
name|NO
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|tag
operator|!=
name|TADDR
condition|)
block|{
name|tp
operator|=
operator|(
name|expptr
operator|)
name|mkaltemp
argument_list|(
name|lp
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|lp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|=
name|tp
expr_stmt|;
name|comma
operator|=
name|YES
expr_stmt|;
block|}
name|putaddr
argument_list|(
name|lp
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma
condition|)
name|putcomma
argument_list|(
literal|1
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return;
if|#
directive|if
name|TARGET
operator|==
name|VAX
comment|/* take advantage of a glitch in the code generator that does not check    the type clash in an assignment or comparison of an integer zero and    a floating left operand, and generates optimal code for the correct    type.  (The PCC has no floating-constant node to encode this correctly.) */
case|case
name|OPASSIGN
case|:
case|case
name|OPLT
case|:
case|case
name|OPLE
case|:
case|case
name|OPGT
case|:
case|case
name|OPGE
case|:
case|case
name|OPEQ
case|:
case|case
name|OPNE
case|:
if|if
condition|(
name|ISREAL
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|&&
name|ISREAL
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|&&
name|ISCONST
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|cd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|vtype
operator|=
name|TYINT
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|k
operator|=
name|ops2
index|[
name|p
operator|->
name|exprblock
operator|.
name|opcode
index|]
operator|)
operator|<=
literal|0
condition|)
name|badop
argument_list|(
literal|"putop"
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
condition|)
name|putx
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|k
argument_list|,
name|types2
index|[
name|p
operator|->
name|exprblock
operator|.
name|vtype
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
condition|)
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|putforce
argument_list|(
argument|t
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|expptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p
operator|=
name|mkconv
argument_list|(
name|t
argument_list|,
name|fixtype
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_FORCE
argument_list|,
operator|(
name|t
operator|==
name|TYSHORT
condition|?
name|PCCT_SHORT
else|:
operator|(
name|t
operator|==
name|TYLONG
condition|?
name|PCCT_LONG
else|:
name|PCCT_DOUBLE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|LOCAL
name|putpower
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|expptr
name|base
decl_stmt|;
name|Addrp
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|ftnint
name|k
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|||
operator|(
name|k
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|)
operator|<
literal|2
condition|)
name|fatal
argument_list|(
literal|"putpower: bad call"
argument_list|)
expr_stmt|;
name|base
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|type
operator|=
name|base
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|==
literal|2
operator|)
operator|&&
name|base
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|ISCONST
argument_list|(
name|base
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
condition|)
block|{
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|base
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|t1
operator|=
name|mkaltemp
argument_list|(
name|type
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|t2
operator|=
name|NULL
expr_stmt|;
name|ncomma
operator|=
literal|1
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|k
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|k
operator|>
literal|2
condition|;
name|k
operator|>>=
literal|1
control|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putsteq
argument_list|(
name|t1
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
literal|2
condition|)
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|t2
operator|=
name|mkaltemp
argument_list|(
name|type
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t2
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|>>=
literal|1
init|;
name|k
operator|>
literal|1
condition|;
name|k
operator|>>=
literal|1
control|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putsteq
argument_list|(
name|t1
argument_list|,
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&
literal|1
condition|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putsteq
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
block|}
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|t2
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|type
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
condition|)
name|frexpr
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|Addrp
name|intdouble
parameter_list|(
name|p
parameter_list|,
name|ncommap
parameter_list|)
name|Addrp
name|p
decl_stmt|;
name|int
modifier|*
name|ncommap
decl_stmt|;
block|{
specifier|register
name|Addrp
name|t
decl_stmt|;
name|t
operator|=
name|mkaltemp
argument_list|(
name|TYDREAL
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
operator|++
operator|*
name|ncommap
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|Addrp
name|putcxeq
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
specifier|register
name|Addrp
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putcxeq"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYREAL
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putcxop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|Addrp
name|putcx1
parameter_list|()
function_decl|;
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putaddr
argument_list|(
name|putcx1
argument_list|(
name|p
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|Addrp
name|putcx1
parameter_list|(
name|p
parameter_list|,
name|ncommap
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
name|int
modifier|*
name|ncommap
decl_stmt|;
block|{
name|expptr
name|q
decl_stmt|;
name|Addrp
name|lp
decl_stmt|,
name|rp
decl_stmt|;
specifier|register
name|Addrp
name|resp
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|int
name|ltype
decl_stmt|,
name|rtype
decl_stmt|;
name|expptr
name|mkrealcon
parameter_list|()
function_decl|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
name|p
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Addrp
operator|)
name|p
operator|)
return|;
case|case
name|TADDR
case|:
if|if
condition|(
operator|!
name|addressable
argument_list|(
name|p
argument_list|)
condition|)
block|{
operator|++
operator|*
name|ncommap
expr_stmt|;
name|resp
operator|=
name|mkaltemp
argument_list|(
name|tyint
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|resp
argument_list|)
argument_list|,
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
name|p
operator|->
name|addrblock
operator|.
name|memoffset
operator|=
operator|(
name|expptr
operator|)
name|resp
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|Addrp
operator|)
name|p
operator|)
return|;
case|case
name|TEXPR
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
break|break;
operator|++
operator|*
name|ncommap
expr_stmt|;
name|resp
operator|=
name|mkaltemp
argument_list|(
name|TYDREAL
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|resp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|resp
operator|)
return|;
default|default:
name|badtag
argument_list|(
literal|"putcx1"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
name|opcode
operator|=
name|p
operator|->
name|exprblock
operator|.
name|opcode
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OPCALL
operator|||
name|opcode
operator|==
name|OPCCALL
condition|)
block|{
operator|++
operator|*
name|ncommap
expr_stmt|;
return|return
operator|(
name|putcall
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OPASSIGN
condition|)
block|{
operator|++
operator|*
name|ncommap
expr_stmt|;
return|return
operator|(
name|putcxeq
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
name|resp
operator|=
name|mkaltemp
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|ncommap
argument_list|)
condition|)
name|ltype
operator|=
name|lp
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|ncommap
argument_list|)
condition|)
name|rtype
operator|=
name|rp
operator|->
name|vtype
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPPAREN
case|:
name|frexpr
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|resp
operator|=
name|lp
expr_stmt|;
name|lp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPCOMMA
case|:
name|frexpr
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|resp
operator|=
name|rp
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPNEG
case|:
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|ENULL
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|ENULL
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|<
name|TYCOMPLEX
condition|)
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ltype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OPPLUS
condition|)
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|,
name|ENULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPSTAR
case|:
if|if
condition|(
name|ltype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|ltype
argument_list|)
condition|)
name|lp
operator|=
name|intdouble
argument_list|(
name|lp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
name|rp
operator|=
name|intdouble
argument_list|(
name|rp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPSLASH
case|:
comment|/* fixexpr has already replaced all divisions 		 * by a complex by a function call 		 */
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
name|rp
operator|=
name|intdouble
argument_list|(
name|rp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPCONV
case|:
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|lp
operator|->
name|vtype
argument_list|)
condition|)
name|q
operator|=
name|imagpart
argument_list|(
name|lp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
name|q
operator|=
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|rp
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
name|mkrealcon
argument_list|(
name|TYDREAL
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|badop
argument_list|(
literal|"putcx1"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|resp
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putcxcmp
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|opcode
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
specifier|register
name|Addrp
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|expptr
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putcxcmp"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|opcode
operator|=
name|p
operator|->
name|exprblock
operator|.
name|opcode
expr_stmt|;
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|opcode
operator|==
name|OPEQ
condition|?
name|OPAND
else|:
name|OPOR
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|fixexpr
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|lp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|Addrp
name|putch1
parameter_list|(
name|p
parameter_list|,
name|ncommap
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
name|int
modifier|*
name|ncommap
decl_stmt|;
block|{
specifier|register
name|Addrp
name|t
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return
operator|(
name|putconst
argument_list|(
name|p
argument_list|)
operator|)
return|;
case|case
name|TADDR
case|:
return|return
operator|(
operator|(
name|Addrp
operator|)
name|p
operator|)
return|;
case|case
name|TEXPR
case|:
operator|++
operator|*
name|ncommap
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
name|expptr
name|q
decl_stmt|;
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
name|t
operator|=
name|putcall
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPPAREN
case|:
operator|--
operator|*
name|ncommap
expr_stmt|;
name|t
operator|=
name|putch1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONCAT
case|:
name|t
operator|=
name|mkaltemp
argument_list|(
name|TYCHAR
argument_list|,
name|ICON
argument_list|(
name|lencat
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|putcat
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* put the correct length on the block */
name|frexpr
argument_list|(
name|t
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|t
operator|->
name|vleng
operator|=
name|q
expr_stmt|;
break|break;
case|case
name|OPCONV
case|:
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
operator|||
name|p
operator|->
name|exprblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|!=
literal|1
operator|||
operator|!
name|INT
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"putch1: bad character conversion"
argument_list|)
expr_stmt|;
name|t
operator|=
name|mkaltemp
argument_list|(
name|TYCHAR
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badop
argument_list|(
literal|"putch1"
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
default|default:
name|badtag
argument_list|(
literal|"putch1"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|putchop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|p
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYCHAR
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putcheq
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|ncomma
decl_stmt|;
name|expptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putcheq"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|rp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONCAT
condition|)
name|putcat
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISONE
argument_list|(
name|lp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
operator|&&
name|ISONE
argument_list|(
name|rp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
condition|)
block|{
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|lp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|rp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_ASSIGN
argument_list|,
name|PCCT_CHAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putx
argument_list|(
name|call2
argument_list|(
name|TYINT
argument_list|,
literal|"s_copy"
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putchcmp
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|ncomma
decl_stmt|;
name|expptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putchcmp"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|ISONE
argument_list|(
name|lp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
operator|&&
name|ISONE
argument_list|(
name|rp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
condition|)
block|{
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|lp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|rp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|ops2
index|[
name|p
operator|->
name|exprblock
operator|.
name|opcode
index|]
argument_list|,
name|PCCT_CHAR
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|call2
argument_list|(
name|TYINT
argument_list|,
literal|"s_cmp"
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|putcat
parameter_list|(
name|lhs
parameter_list|,
name|rhs
parameter_list|)
specifier|register
name|Addrp
name|lhs
decl_stmt|;
specifier|register
name|expptr
name|rhs
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|ncomma
decl_stmt|;
name|Addrp
name|lp
decl_stmt|,
name|cp
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|ncat
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|lp
operator|=
name|mkaltmpn
argument_list|(
name|n
argument_list|,
name|TYLENG
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|mkaltmpn
argument_list|(
name|n
argument_list|,
name|TYADDR
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|putct1
argument_list|(
name|rhs
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|call4
argument_list|(
name|TYSUBR
argument_list|,
literal|"s_cat"
argument_list|,
name|lhs
argument_list|,
name|cp
argument_list|,
name|lp
argument_list|,
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|ICON
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putct1
parameter_list|(
name|q
parameter_list|,
name|lp
parameter_list|,
name|cp
parameter_list|,
name|ip
parameter_list|,
name|ncommap
parameter_list|)
specifier|register
name|expptr
name|q
decl_stmt|;
specifier|register
name|Addrp
name|lp
decl_stmt|,
name|cp
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|,
decl|*
name|ncommap
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|Addrp
name|lp1
decl_stmt|,
name|cp1
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|q
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONCAT
condition|)
block|{
name|putct1
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|,
name|ip
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putct1
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|,
name|ip
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|(
operator|*
name|ip
operator|)
operator|++
expr_stmt|;
name|cp1
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp1
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|cp1
operator|->
name|memoffset
argument_list|,
name|ICON
argument_list|(
name|i
operator|*
name|SZADDR
argument_list|)
argument_list|)
expr_stmt|;
name|lp1
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|lp1
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|lp1
operator|->
name|memoffset
argument_list|,
name|ICON
argument_list|(
name|i
operator|*
name|SZLENG
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cp1
argument_list|,
name|addrof
argument_list|(
name|putch1
argument_list|(
name|cpexpr
argument_list|(
name|q
argument_list|)
argument_list|,
name|ncommap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|lp1
argument_list|,
name|q
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_function
name|LOCAL
name|putaddr
parameter_list|(
name|p
parameter_list|,
name|indir
parameter_list|)
specifier|register
name|Addrp
name|p
decl_stmt|;
name|int
name|indir
decl_stmt|;
block|{
name|int
name|type
decl_stmt|,
name|type2
decl_stmt|,
name|funct
decl_stmt|;
name|ftnint
name|offset
decl_stmt|,
name|simoffset
argument_list|()
decl_stmt|;
name|expptr
name|offp
decl_stmt|,
name|shorten
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TERROR
operator|||
operator|(
name|p
operator|->
name|memoffset
operator|!=
name|NULL
operator|&&
name|ISERROR
argument_list|(
name|p
operator|->
name|memoffset
argument_list|)
operator|)
condition|)
block|{
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TADDR
condition|)
name|badtag
argument_list|(
literal|"putaddr"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|type
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
name|type2
operator|=
name|types2
index|[
name|type
index|]
expr_stmt|;
name|funct
operator|=
operator|(
name|p
operator|->
name|vclass
operator|==
name|CLPROC
condition|?
name|PCCTM_FTN
operator|<<
literal|2
else|:
literal|0
operator|)
expr_stmt|;
name|offp
operator|=
operator|(
name|p
operator|->
name|memoffset
condition|?
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|memoffset
argument_list|)
else|:
operator|(
name|expptr
operator|)
name|NULL
operator|)
expr_stmt|;
if|#
directive|if
operator|(
name|FUDGEOFFSET
operator|!=
literal|1
operator|)
if|if
condition|(
name|offp
condition|)
name|offp
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|ICON
argument_list|(
name|FUDGEOFFSET
argument_list|)
argument_list|,
name|offp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|offset
operator|=
name|simoffset
argument_list|(
operator|&
name|offp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SZINT
operator|<
name|SZLONG
if|if
condition|(
name|offp
condition|)
if|if
condition|(
name|shortsubs
condition|)
name|offp
operator|=
name|shorten
argument_list|(
name|offp
argument_list|)
expr_stmt|;
else|else
name|offp
operator|=
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|offp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|offp
condition|)
name|offp
operator|=
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|offp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|vclass
operator|==
name|CLVAR
operator|&&
operator|(
name|p
operator|->
name|vstg
operator|==
name|STGBSS
operator|||
name|p
operator|->
name|vstg
operator|==
name|STGEQUIV
operator|)
operator|&&
name|SMALLVAR
argument_list|(
name|p
operator|->
name|varsize
argument_list|)
operator|&&
name|offset
operator|>=
operator|-
literal|32768
operator|&&
name|offset
operator|<=
literal|32767
condition|)
block|{
name|anylocals
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|indir
operator|&&
operator|!
name|offp
condition|)
name|p2ldisp
argument_list|(
name|offset
argument_list|,
name|memname
argument_list|(
name|p
operator|->
name|vstg
argument_list|,
name|p
operator|->
name|memno
argument_list|)
argument_list|,
name|type2
argument_list|)
expr_stmt|;
else|else
block|{
name|p2reg
argument_list|(
literal|11
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
name|p2triple
argument_list|(
name|PCC_ICON
argument_list|,
literal|1
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|p2ndisp
argument_list|(
name|memname
argument_list|(
name|p
operator|->
name|vstg
argument_list|,
name|p
operator|->
name|memno
argument_list|)
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
condition|)
block|{
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indir
condition|)
name|p2op
argument_list|(
name|PCC_DEREF
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|p
operator|->
name|vstg
condition|)
block|{
case|case
name|STGAUTO
case|:
if|if
condition|(
name|indir
operator|&&
operator|!
name|offp
condition|)
block|{
name|p2oreg
argument_list|(
name|offset
argument_list|,
name|AUTOREG
argument_list|,
name|type2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|indir
operator|&&
operator|!
name|offp
operator|&&
operator|!
name|offset
condition|)
block|{
name|p2reg
argument_list|(
name|AUTOREG
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
break|break;
block|}
name|p2reg
argument_list|(
name|AUTOREG
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
condition|)
block|{
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|p2icon
argument_list|(
name|offset
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
block|}
else|else
name|p2icon
argument_list|(
name|offset
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
operator|&&
name|offset
condition|)
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|p2op
argument_list|(
name|PCC_DEREF
argument_list|,
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGARG
case|:
name|p2oreg
argument_list|(
ifdef|#
directive|ifdef
name|ARGOFFSET
name|ARGOFFSET
operator|+
endif|#
directive|endif
call|(
name|ftnint
call|)
argument_list|(
name|FUDGEOFFSET
operator|*
name|p
operator|->
name|memno
argument_list|)
argument_list|,
name|ARGREG
argument_list|,
name|type2
operator||
name|PCCTM_PTR
operator||
name|funct
argument_list|)
expr_stmt|;
name|based
label|:
if|if
condition|(
name|offset
condition|)
block|{
name|p2icon
argument_list|(
name|offset
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offp
condition|)
block|{
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indir
condition|)
name|p2op
argument_list|(
name|PCC_DEREF
argument_list|,
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGLENG
case|:
if|if
condition|(
name|indir
condition|)
block|{
name|p2oreg
argument_list|(
ifdef|#
directive|ifdef
name|ARGOFFSET
name|ARGOFFSET
operator|+
endif|#
directive|endif
call|(
name|ftnint
call|)
argument_list|(
name|FUDGEOFFSET
operator|*
name|p
operator|->
name|memno
argument_list|)
argument_list|,
name|ARGREG
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p2reg
argument_list|(
name|ARGREG
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
name|p2icon
argument_list|(
ifdef|#
directive|ifdef
name|ARGOFFSET
name|ARGOFFSET
operator|+
endif|#
directive|endif
call|(
name|ftnint
call|)
argument_list|(
name|FUDGEOFFSET
operator|*
name|p
operator|->
name|memno
argument_list|)
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STGBSS
case|:
case|case
name|STGINIT
case|:
case|case
name|STGEXT
case|:
case|case
name|STGINTR
case|:
case|case
name|STGCOMMON
case|:
case|case
name|STGEQUIV
case|:
case|case
name|STGCONST
case|:
if|if
condition|(
name|offp
condition|)
block|{
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
name|putmem
argument_list|(
name|p
argument_list|,
name|PCC_ICON
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|p2op
argument_list|(
name|PCC_DEREF
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
else|else
name|putmem
argument_list|(
name|p
argument_list|,
operator|(
name|indir
condition|?
name|PCC_NAME
else|:
name|PCC_ICON
operator|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGREG
case|:
if|if
condition|(
name|indir
condition|)
name|p2reg
argument_list|(
name|p
operator|->
name|memno
argument_list|,
name|type2
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"attempt to take address of a register"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGPREG
case|:
if|if
condition|(
name|indir
operator|&&
operator|!
name|offp
condition|)
name|p2oreg
argument_list|(
name|offset
argument_list|,
name|p
operator|->
name|memno
argument_list|,
name|type2
argument_list|)
expr_stmt|;
else|else
block|{
name|p2reg
argument_list|(
name|p
operator|->
name|memno
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
goto|goto
name|based
goto|;
block|}
break|break;
default|default:
name|badstg
argument_list|(
literal|"putaddr"
argument_list|,
name|p
operator|->
name|vstg
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putmem
parameter_list|(
name|p
parameter_list|,
name|class
parameter_list|,
name|offset
parameter_list|)
name|expptr
name|p
decl_stmt|;
name|int
name|class
decl_stmt|;
name|ftnint
name|offset
decl_stmt|;
block|{
name|int
name|type2
decl_stmt|;
name|int
name|funct
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|memname
argument_list|()
decl_stmt|;
name|funct
operator|=
operator|(
name|p
operator|->
name|headblock
operator|.
name|vclass
operator|==
name|CLPROC
condition|?
name|PCCTM_FTN
operator|<<
literal|2
else|:
literal|0
operator|)
expr_stmt|;
name|type2
operator|=
name|types2
index|[
name|p
operator|->
name|headblock
operator|.
name|vtype
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vclass
operator|==
name|CLPROC
condition|)
name|type2
operator||=
operator|(
name|PCCTM_FTN
operator|<<
literal|2
operator|)
expr_stmt|;
name|name
operator|=
name|memname
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|vstg
argument_list|,
name|p
operator|->
name|addrblock
operator|.
name|memno
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|PCC_ICON
condition|)
block|{
name|p2triple
argument_list|(
name|PCC_ICON
argument_list|,
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
condition|)
name|p2name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p2triple
argument_list|(
name|PCC_NAME
argument_list|,
name|offset
operator|!=
literal|0
argument_list|,
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|p2name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|Addrp
name|putcall
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Exprp
name|p
decl_stmt|;
block|{
name|chainp
name|arglist
decl_stmt|,
name|charsp
decl_stmt|,
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|first
decl_stmt|;
name|Addrp
name|t
decl_stmt|;
specifier|register
name|expptr
name|q
decl_stmt|;
name|Addrp
name|fval
decl_stmt|,
name|mkargtemp
argument_list|()
decl_stmt|;
name|int
name|type
decl_stmt|,
name|type2
decl_stmt|,
name|ctype
decl_stmt|,
name|qtype
decl_stmt|,
name|indir
decl_stmt|;
name|type2
operator|=
name|types2
index|[
name|type
operator|=
name|p
operator|->
name|vtype
index|]
expr_stmt|;
name|charsp
operator|=
name|NULL
expr_stmt|;
name|indir
operator|=
operator|(
name|p
operator|->
name|opcode
operator|==
name|OPCCALL
operator|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rightp
condition|)
block|{
name|arglist
operator|=
name|p
operator|->
name|rightp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
name|free
argument_list|(
call|(
name|charptr
call|)
argument_list|(
name|p
operator|->
name|rightp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|arglist
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|q
operator|=
operator|(
name|expptr
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|indir
condition|)
operator|++
name|n
expr_stmt|;
else|else
block|{
name|q
operator|=
call|(
name|expptr
call|)
argument_list|(
name|cp
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|q
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|cp
operator|->
name|datap
operator|=
operator|(
name|tagptr
operator|)
name|q
expr_stmt|;
block|}
if|if
condition|(
name|ISCHAR
argument_list|(
name|q
argument_list|)
operator|&&
name|q
operator|->
name|headblock
operator|.
name|vclass
operator|!=
name|CLPROC
condition|)
block|{
name|charsp
operator|=
name|hookup
argument_list|(
name|charsp
argument_list|,
name|mkchain
argument_list|(
name|cpexpr
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|n
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|ISICON
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
condition|)
block|{
name|fval
operator|=
name|mkargtemp
argument_list|(
name|TYCHAR
argument_list|,
name|p
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"adjustable character function"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fval
operator|=
name|mkargtemp
argument_list|(
name|type
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|fval
operator|=
name|NULL
expr_stmt|;
name|ctype
operator|=
operator|(
name|fval
condition|?
name|PCCT_INT
else|:
name|type2
operator|)
expr_stmt|;
name|putaddr
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|fval
condition|)
block|{
name|first
operator|=
name|NO
expr_stmt|;
name|putaddr
argument_list|(
name|cpexpr
argument_list|(
name|fval
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
name|putx
argument_list|(
name|mkconv
argument_list|(
name|TYLENG
argument_list|,
name|p
operator|->
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_CM
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|q
operator|=
call|(
name|expptr
call|)
argument_list|(
name|cp
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TADDR
operator|&&
operator|(
name|indir
operator|||
name|q
operator|->
name|addrblock
operator|.
name|vstg
operator|!=
name|STGREG
operator|)
condition|)
name|putaddr
argument_list|(
name|q
argument_list|,
name|indir
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|vtype
operator|!=
name|TYCHAR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCHAR
argument_list|(
name|q
argument_list|)
condition|)
name|putchop
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ISERROR
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|indir
condition|)
name|putx
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|=
name|mkargtemp
argument_list|(
name|qtype
operator|=
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|q
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|putaddr
argument_list|(
name|t
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
literal|1
argument_list|,
name|qtype
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
condition|)
name|first
operator|=
name|NO
expr_stmt|;
else|else
name|p2op
argument_list|(
name|PCC_CM
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arglist
condition|)
name|frchain
argument_list|(
operator|&
name|arglist
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|charsp
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|putx
argument_list|(
name|mkconv
argument_list|(
name|TYLENG
argument_list|,
name|cp
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_CM
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
name|frchain
argument_list|(
operator|&
name|charsp
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|n
operator|>
literal|0
condition|?
name|PCC_CALL
else|:
name|PCC_UCALL
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|fval
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putmnmx
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|op
decl_stmt|,
name|type
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
name|expptr
name|qp
decl_stmt|;
name|chainp
name|p0
decl_stmt|,
name|p1
decl_stmt|;
name|Addrp
name|sp
decl_stmt|,
name|tp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putmnmx"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|type
operator|=
name|p
operator|->
name|exprblock
operator|.
name|vtype
expr_stmt|;
name|op
operator|=
operator|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPMIN
condition|?
name|OPLT
else|:
name|OPGT
operator|)
expr_stmt|;
name|p0
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
name|free
argument_list|(
call|(
name|charptr
call|)
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|sp
operator|=
name|mkaltemp
argument_list|(
name|type
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|tp
operator|=
name|mkaltemp
argument_list|(
name|type
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|qp
operator|=
name|mkexpr
argument_list|(
name|OPCOLON
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|=
name|mkexpr
argument_list|(
name|OPQUEST
argument_list|,
name|mkexpr
argument_list|(
name|op
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|)
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qp
operator|=
name|fixexpr
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|1
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|,
name|p0
operator|->
name|datap
argument_list|)
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|p0
operator|->
name|nextp
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|nextp
control|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|p1
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|nextp
condition|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|putx
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|type
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|p0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putcomma
parameter_list|(
name|n
parameter_list|,
name|type
parameter_list|,
name|indir
parameter_list|)
name|int
name|n
decl_stmt|,
name|type
decl_stmt|,
name|indir
decl_stmt|;
block|{
name|type
operator|=
name|types2
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|type
operator||=
name|PCCTM_PTR
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|p2op
argument_list|(
name|PCC_COMOP
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ftnint
name|simoffset
parameter_list|(
name|p0
parameter_list|)
name|expptr
modifier|*
name|p0
decl_stmt|;
block|{
name|ftnint
name|offset
decl_stmt|,
name|prod
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|,
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|*
name|p0
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPSTAR
condition|)
block|{
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
operator|&&
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPPLUS
operator|&&
name|ISICON
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPPLUS
expr_stmt|;
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPSTAR
expr_stmt|;
name|prod
operator|=
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|*
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|=
name|prod
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPPLUS
operator|&&
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
block|{
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|offset
operator|+=
name|rp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
operator|*
name|p0
operator|=
name|lp
expr_stmt|;
block|}
if|if
condition|(
name|ISCONST
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|offset
operator|+=
name|p
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p0
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|p2op
argument_list|(
argument|op
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2triple
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2icon
argument_list|(
argument|offset
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|ftnint
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2triple
argument_list|(
name|PCC_ICON
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2oreg
argument_list|(
argument|offset
argument_list|,
argument|reg
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|ftnint
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reg
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2triple
argument_list|(
name|PCC_OREG
argument_list|,
name|reg
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|p2name
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2reg
argument_list|(
argument|reg
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|reg
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2triple
argument_list|(
name|PCC_REG
argument_list|,
name|reg
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2pi
argument_list|(
argument|s
argument_list|,
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p2pass
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2pij
argument_list|(
argument|s
argument_list|,
argument|i
argument_list|,
argument|j
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|s
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|p2pass
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2ps
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|p2pass
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2pass
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2triple
argument_list|(
name|PCCF_FTEXT
argument_list|,
operator|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|FOUR
operator|-
literal|1
operator|)
operator|/
name|FOUR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2str
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|p2str
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
union|union
block|{
name|long
name|int
name|word
decl_stmt|;
name|char
name|str
index|[
name|FOUR
index|]
decl_stmt|;
block|}
name|u
union|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|word
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|u
operator|.
name|str
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|FOUR
condition|)
block|{
name|p2word
argument_list|(
name|u
operator|.
name|word
argument_list|)
expr_stmt|;
name|u
operator|.
name|word
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|p2word
argument_list|(
name|u
operator|.
name|word
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2triple
argument_list|(
argument|op
argument_list|,
argument|var
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|var
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|word
decl_stmt|;
name|word
operator|=
name|PCCM_TRIPLE
argument_list|(
name|op
argument_list|,
name|var
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|p2name
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|UCBPASS2
comment|/* arbitrary length names, terminated by a null, 	   padded to a full word */
define|#
directive|define
name|WL
value|sizeof(long int)
union|union
block|{
name|long
name|int
name|word
decl_stmt|;
name|char
name|str
index|[
name|WL
index|]
decl_stmt|;
block|}
name|w
union|;
name|w
operator|.
name|word
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|w
operator|.
name|str
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
operator|++
condition|)
if|if
condition|(
name|i
operator|==
name|WL
condition|)
block|{
name|p2word
argument_list|(
name|w
operator|.
name|word
argument_list|)
expr_stmt|;
name|w
operator|.
name|word
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|p2word
argument_list|(
name|w
operator|.
name|word
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* standard intermediate, names are 8 characters long */
union|union
block|{
name|long
name|int
name|word
index|[
literal|2
index|]
decl_stmt|;
name|char
name|str
index|[
literal|8
index|]
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|word
index|[
literal|0
index|]
operator|=
name|u
operator|.
name|word
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|&&
operator|*
name|s
condition|;
operator|++
name|i
control|)
name|u
operator|.
name|str
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|p2word
argument_list|(
name|u
operator|.
name|word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|u
operator|.
name|word
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|p2word
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|long
name|int
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|p2bufp
operator|++
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|p2bufp
operator|>=
name|p2bufend
condition|)
name|p2flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|p2flush
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|p2bufp
operator|>
name|p2buff
condition|)
name|write
argument_list|(
name|fileno
argument_list|(
name|textfile
argument_list|)
argument_list|,
name|p2buff
argument_list|,
operator|(
name|p2bufp
operator|-
name|p2buff
operator|)
operator|*
expr|sizeof
operator|(
name|long
name|int
operator|)
argument_list|)
expr_stmt|;
name|p2bufp
operator|=
name|p2buff
expr_stmt|;
block|}
end_block

begin_function
name|LOCAL
name|p2ldisp
parameter_list|(
name|offset
parameter_list|,
name|vname
parameter_list|,
name|type
parameter_list|)
name|ftnint
name|offset
decl_stmt|;
name|char
modifier|*
name|vname
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s-v.%d"
argument_list|,
name|vname
argument_list|,
name|bsslabel
argument_list|)
expr_stmt|;
name|p2triple
argument_list|(
name|PCC_OREG
argument_list|,
literal|11
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|p2name
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|p2ndisp
argument_list|(
argument|vname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|vname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s-v.%d"
argument_list|,
name|vname
argument_list|,
name|bsslabel
argument_list|)
expr_stmt|;
name|p2name
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

