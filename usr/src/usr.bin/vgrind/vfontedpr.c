begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*  * Vfontedpr.  *  * Bill Joy, Apr. 1979.  * (made somewhat table driven - Dave Presotto 11/17/80)  *  * To add a new language:  *	1) add a new keyword table  *	2) add a new entry to "struct langdef ld[]" to  *	   describe comments, strings, etc.  *	3) add two routines to recognize start and end of   *	   procedures  *  */
end_comment

begin_define
define|#
directive|define
name|NOLANG
value|-1
end_define

begin_comment
comment|/* indicates no language chosen */
end_comment

begin_define
define|#
directive|define
name|C
value|0
end_define

begin_define
define|#
directive|define
name|PASCAL
value|1
end_define

begin_define
define|#
directive|define
name|MODEL
value|2
end_define

begin_define
define|#
directive|define
name|NLANG
value|4
end_define

begin_comment
comment|/* total number of languages */
end_comment

begin_define
define|#
directive|define
name|STRLEN
value|10
end_define

begin_comment
comment|/* length of strings introducing things */
end_comment

begin_define
define|#
directive|define
name|PNAMELEN
value|40
end_define

begin_comment
comment|/* length of a function/procedure name */
end_comment

begin_comment
comment|/* routines used by the different languages */
end_comment

begin_function_decl
name|int
name|cprbegin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cprend
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iprbegin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iprend
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pprbegin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pprend
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mprbegin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mprend
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* keywords for the model language */
end_comment

begin_decl_stmt
name|char
modifier|*
name|mkw
index|[]
init|=
block|{
literal|"abs"
block|,
literal|"and"
block|,
literal|"array"
block|,
literal|"beginproc"
block|,
literal|"boolean"
block|,
literal|"by"
block|,
literal|"case"
block|,
literal|"cdnl"
block|,
literal|"char"
block|,
literal|"copied"
block|,
literal|"dispose"
block|,
literal|"div"
block|,
literal|"do"
block|,
literal|"dynamic"
block|,
literal|"else"
block|,
literal|"elsif"
block|,
literal|"end"
block|,
literal|"endproc"
block|,
literal|"entry"
block|,
literal|"external"
block|,
literal|"f"
block|,
literal|"FALSE"
block|,
literal|"false"
block|,
literal|"fi"
block|,
literal|"file"
block|,
literal|"for"
block|,
literal|"formal"
block|,
literal|"fortran"
block|,
literal|"global"
block|,
literal|"if"
block|,
literal|"in"
block|,
literal|"include"
block|,
literal|"inline"
block|,
literal|"is"
block|,
literal|"lbnd"
block|,
literal|"max"
block|,
literal|"min"
block|,
literal|"mod"
block|,
literal|"new"
block|,
literal|"NIL"
block|,
literal|"nil"
block|,
literal|"noresult"
block|,
literal|"not"
block|,
literal|"notin"
block|,
literal|"od"
block|,
literal|"of"
block|,
literal|"or"
block|,
literal|"procedure"
block|,
literal|"public"
block|,
literal|"read"
block|,
literal|"readln"
block|,
literal|"readonly"
block|,
literal|"record"
block|,
literal|"recursive"
block|,
literal|"rem"
block|,
literal|"rep"
block|,
literal|"repeat"
block|,
literal|"result"
block|,
literal|"return"
block|,
literal|"set"
block|,
literal|"space"
block|,
literal|"string"
block|,
literal|"subscript"
block|,
literal|"such"
block|,
literal|"then"
block|,
literal|"TRUE"
block|,
literal|"true"
block|,
literal|"type"
block|,
literal|"ubnd"
block|,
literal|"union"
block|,
literal|"until"
block|,
literal|"varies"
block|,
literal|"while"
block|,
literal|"width"
block|,
literal|"write"
block|,
literal|"writeln"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keywords for the pascal language */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pkw
index|[]
init|=
block|{
literal|"and"
block|,
literal|"array"
block|,
literal|"assert"
block|,
literal|"begin"
block|,
literal|"case"
block|,
literal|"const"
block|,
literal|"div"
block|,
literal|"do"
block|,
literal|"downto"
block|,
literal|"else"
block|,
literal|"end"
block|,
literal|"file"
block|,
literal|"for"
block|,
literal|"forward"
block|,
literal|"function"
block|,
literal|"goto"
block|,
literal|"if"
block|,
literal|"in"
block|,
literal|"label"
block|,
literal|"mod"
block|,
literal|"nil"
block|,
literal|"not"
block|,
literal|"of"
block|,
literal|"or"
block|,
literal|"packed"
block|,
literal|"procedure"
block|,
literal|"program"
block|,
literal|"record"
block|,
literal|"repeat"
block|,
literal|"set"
block|,
literal|"then"
block|,
literal|"to"
block|,
literal|"type"
block|,
literal|"until"
block|,
literal|"var"
block|,
literal|"while"
block|,
literal|"with"
block|,
literal|"oct"
block|,
literal|"hex"
block|,
literal|"external"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keywords for the C language */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ckw
index|[]
init|=
block|{
literal|"asm"
block|,
literal|"auto"
block|,
literal|"break"
block|,
literal|"case"
block|,
literal|"char"
block|,
literal|"continue"
block|,
literal|"default"
block|,
literal|"do"
block|,
literal|"double"
block|,
literal|"else"
block|,
literal|"enum"
block|,
literal|"extern"
block|,
literal|"float"
block|,
literal|"for"
block|,
literal|"fortran"
block|,
literal|"goto"
block|,
literal|"if"
block|,
literal|"int"
block|,
literal|"long"
block|,
literal|"register"
block|,
literal|"return"
block|,
literal|"short"
block|,
literal|"sizeof"
block|,
literal|"static"
block|,
literal|"struct"
block|,
literal|"switch"
block|,
literal|"typedef"
block|,
literal|"union"
block|,
literal|"unsigned"
block|,
literal|"while"
block|,
literal|"#define"
block|,
literal|"#else"
block|,
literal|"#endif"
block|,
literal|"#if"
block|,
literal|"#ifdef"
block|,
literal|"#ifndef"
block|,
literal|"#include"
block|,
literal|"#undef"
block|,
literal|"#"
block|,
literal|"define"
block|,
literal|"else"
block|,
literal|"endif"
block|,
literal|"if"
block|,
literal|"ifdef"
block|,
literal|"ifndef"
block|,
literal|"include"
block|,
literal|"undef"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keywords for the ISP language */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ikw
index|[]
init|=
block|{
literal|"and"
block|,
literal|"begin"
block|,
literal|"decode"
block|,
literal|"define"
block|,
literal|"end"
block|,
literal|"eql"
block|,
literal|"eqv"
block|,
literal|"geq"
block|,
literal|"gtr"
block|,
literal|"if"
block|,
literal|"leave"
block|,
literal|"leq"
block|,
literal|"lss"
block|,
literal|"mod"
block|,
literal|"neq"
block|,
literal|"next"
block|,
literal|"not"
block|,
literal|"or"
block|,
literal|"otherwise"
block|,
literal|"repeat"
block|,
literal|"restart"
block|,
literal|"resume"
block|,
literal|"sr0"
block|,
literal|"sr1"
block|,
literal|"srd"
block|,
literal|"srr"
block|,
literal|"sl0"
block|,
literal|"sl1"
block|,
literal|"sld"
block|,
literal|"slr"
block|,
literal|"tst"
block|,
literal|"xor"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * the following structure defines a language  */
end_comment

begin_struct
struct|struct
name|langdef
block|{
name|char
modifier|*
name|option
decl_stmt|;
comment|/* its option switch */
name|char
modifier|*
modifier|*
name|kwd
decl_stmt|;
comment|/* address of its keyword table */
name|int
function_decl|(
modifier|*
name|isproc
function_decl|)
parameter_list|()
function_decl|;
comment|/* test for procedure begin */
name|int
function_decl|(
modifier|*
name|ispend
function_decl|)
parameter_list|()
function_decl|;
comment|/* test for procedure end */
name|char
modifier|*
name|combeg
decl_stmt|;
comment|/* string introducing a comment */
name|char
modifier|*
name|comend
decl_stmt|;
comment|/* string ending a comment */
name|char
modifier|*
name|comout
decl_stmt|;
comment|/* string output in place of combeg string */
name|char
modifier|*
name|acmbeg
decl_stmt|;
comment|/* alternate comment start */
name|char
modifier|*
name|acmend
decl_stmt|;
comment|/* alternate comment end */
name|char
modifier|*
name|acmout
decl_stmt|;
comment|/* alternate comment start preface */
name|char
name|strdel
decl_stmt|;
comment|/* delimiter for string constant */
name|char
name|chrdel
decl_stmt|;
comment|/* delimiter for character constant */
name|int
name|onelncom
decl_stmt|;
comment|/* comments do not continue on next line */
name|int
name|onelnstr
decl_stmt|;
comment|/* string constants do not continue on next */
name|int
name|onecase
decl_stmt|;
comment|/* upper and lower case are equivalent */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|langdef
name|ld
index|[]
init|=
block|{
comment|/* the C language */
literal|"-c"
block|,
name|ckw
block|,
comment|/* kwd */
name|cprbegin
block|,
comment|/* isproc */
name|cprend
block|,
comment|/* ispend */
literal|"/*"
block|,
comment|/* combeg */
literal|"*/"
block|,
comment|/* comend */
literal|"\\*(/*"
block|,
comment|/* comout */
literal|0
block|,
comment|/* acmbeg */
literal|0
block|,
comment|/* acmend */
literal|0
block|,
comment|/* acmout */
literal|'"'
block|,
comment|/* strdel */
literal|'\''
block|,
comment|/* chrdel */
literal|0
block|,
comment|/* onelncom */
literal|0
block|,
comment|/* onelnstr */
literal|0
block|,
comment|/* onecase */
comment|/* the ISP language */
literal|"-i"
block|,
name|ikw
block|,
comment|/* kwd */
name|iprbegin
block|,
comment|/* isproc */
name|iprend
block|,
comment|/* ispend */
literal|"!"
block|,
comment|/* combeg */
literal|0
block|,
comment|/* comend */
literal|"!"
block|,
comment|/* comout */
literal|0
block|,
comment|/* acmbeg */
literal|0
block|,
comment|/* acmend */
literal|0
block|,
comment|/* acmout */
literal|0
block|,
comment|/* strdel */
literal|0
block|,
comment|/* chrdel */
literal|1
block|,
comment|/* onelncom */
literal|1
block|,
comment|/* onelnstr */
literal|1
block|,
comment|/* onecase */
comment|/* the pascal language */
literal|"-p"
block|,
name|pkw
block|,
comment|/* kwd */
name|pprbegin
block|,
comment|/* isproc */
name|pprend
block|,
comment|/* ispend */
literal|"{"
block|,
comment|/* combeg */
literal|"}"
block|,
comment|/* comend */
literal|"{"
block|,
comment|/* comout */
literal|"(*"
block|,
comment|/* acmbeg */
literal|"*)"
block|,
comment|/* acmend */
literal|"(*"
block|,
comment|/* acmout */
literal|'\''
block|,
comment|/* strdel */
literal|0
block|,
comment|/* chrdel */
literal|0
block|,
comment|/* onelncom */
literal|0
block|,
comment|/* onelnstr */
literal|0
block|,
comment|/* onecase */
comment|/* the model language */
literal|"-m"
block|,
name|mkw
block|,
comment|/* kwd */
name|mprbegin
block|,
comment|/* isproc */
name|mprend
block|,
comment|/* ispend */
literal|"$"
block|,
comment|/* combeg */
literal|"$"
block|,
comment|/* comend */
literal|"$"
block|,
comment|/* comout */
literal|0
block|,
comment|/* acmbeg */
literal|0
block|,
comment|/* acmend */
literal|0
block|,
comment|/* acmout */
literal|'"'
block|,
comment|/* strdel */
literal|'\''
block|,
comment|/* chrdel */
literal|1
block|,
comment|/* onelncom */
literal|0
block|,
comment|/* onelnstr */
literal|0
block|,
comment|/* onecase */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|incomm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in a comment of the primary type */
end_comment

begin_decl_stmt
name|int
name|inacomm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in the alternate type of comment */
end_comment

begin_decl_stmt
name|int
name|instr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in a string constant */
end_comment

begin_decl_stmt
name|int
name|nokeyw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|margin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|comcol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character position comment starts in */
end_comment

begin_decl_stmt
name|int
name|language
init|=
name|NOLANG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the language indicator */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|keywds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keyword table address */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|isprbeg
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* test for beginning of procedure */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|isprend
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* test for end of procedure */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of comment string */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cstop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of comment string */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string to substitute for cstart */
end_comment

begin_decl_stmt
name|int
name|lcstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of comment string starter */
end_comment

begin_decl_stmt
name|int
name|lcstop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of comment string terminator */
end_comment

begin_decl_stmt
name|char
modifier|*
name|acstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of comment string */
end_comment

begin_decl_stmt
name|char
modifier|*
name|acstop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of comment string */
end_comment

begin_decl_stmt
name|char
modifier|*
name|acout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string to substitute for cstart */
end_comment

begin_decl_stmt
name|int
name|lacstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of comment string starter */
end_comment

begin_decl_stmt
name|int
name|lacstop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of comment string terminator */
end_comment

begin_decl_stmt
name|char
name|sdelim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string constant delimiter */
end_comment

begin_decl_stmt
name|char
name|cdelim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character constant delimiter */
end_comment

begin_decl_stmt
name|int
name|com1line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one line comments */
end_comment

begin_decl_stmt
name|int
name|str1line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one line strings */
end_comment

begin_decl_stmt
name|int
name|upeqlow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* upper and lower case equivalent */
end_comment

begin_decl_stmt
name|char
name|pname
index|[
name|PNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ps
parameter_list|(
name|x
parameter_list|)
value|printf("%s", x)
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|lineno
decl_stmt|;
name|char
modifier|*
name|fname
init|=
literal|""
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|needbp
init|=
literal|0
decl_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-h"
argument_list|)
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"'ds =H\n"
argument_list|)
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
goto|goto
name|rest
goto|;
block|}
name|printf
argument_list|(
literal|"'ds =H %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
continue|continue;
goto|goto
name|rest
goto|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-x"
argument_list|)
condition|)
block|{
name|index
operator|++
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
literal|"-n"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-n"
argument_list|)
condition|)
block|{
name|nokeyw
operator|++
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-s"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|i
operator|=
name|i
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"'ps %d\n'vs %d\n"
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NLANG
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|ld
index|[
name|i
index|]
operator|.
name|option
argument_list|)
condition|)
block|{
name|language
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|!=
name|NLANG
condition|)
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|freopen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
condition|)
name|printf
argument_list|(
literal|"'ta 4i 4.25i 5.5iR\n'in .5i\n"
argument_list|)
expr_stmt|;
name|fname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
name|rest
label|:
if|if
condition|(
name|language
operator|==
name|NOLANG
condition|)
name|language
operator|=
name|C
expr_stmt|;
comment|/* C is the default */
comment|/* initialize for the appropriate language */
comment|/* This is done because subscripting is too */
comment|/* damned slow to be done every reference */
name|keywds
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|kwd
expr_stmt|;
name|isprbeg
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|isproc
expr_stmt|;
name|isprend
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|ispend
expr_stmt|;
name|cstart
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|combeg
expr_stmt|;
name|cstop
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|comend
expr_stmt|;
name|cout
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|comout
expr_stmt|;
name|lcstart
operator|=
name|strlen
argument_list|(
name|cstart
argument_list|)
expr_stmt|;
name|lcstop
operator|=
name|strlen
argument_list|(
name|cstop
argument_list|)
expr_stmt|;
name|acstart
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|acmbeg
expr_stmt|;
name|acstop
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|acmend
expr_stmt|;
name|acout
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|acmout
expr_stmt|;
name|lacstart
operator|=
name|strlen
argument_list|(
name|acstart
argument_list|)
expr_stmt|;
name|lacstop
operator|=
name|strlen
argument_list|(
name|acstop
argument_list|)
expr_stmt|;
name|sdelim
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|strdel
expr_stmt|;
name|cdelim
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|chrdel
expr_stmt|;
name|com1line
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|onelncom
expr_stmt|;
name|str1line
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|onelnstr
expr_stmt|;
name|upeqlow
operator|=
name|ld
index|[
name|language
index|]
operator|.
name|onecase
expr_stmt|;
name|pname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* initialize the program */
name|incomm
operator|=
literal|0
expr_stmt|;
name|inacomm
operator|=
literal|0
expr_stmt|;
name|instr
operator|=
literal|0
expr_stmt|;
name|ps
argument_list|(
literal|"'-F\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".ds =F %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|stbuf
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|cp
index|[
literal|16
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|".ds =M %s %s\n"
argument_list|,
name|cp
operator|+
literal|4
argument_list|,
name|cp
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|needbp
condition|)
block|{
name|needbp
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|".()\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".bp\n"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\f'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|printf
argument_list|(
literal|".bp\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|com1line
operator|&&
operator|(
name|incomm
operator|||
name|inacomm
operator|)
condition|)
block|{
name|incomm
operator|=
literal|0
expr_stmt|;
name|inacomm
operator|=
literal|0
expr_stmt|;
name|ps
argument_list|(
literal|"\\c\n'-C\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str1line
condition|)
name|instr
operator|=
literal|0
expr_stmt|;
name|comcol
operator|=
name|NULL
expr_stmt|;
name|putScp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|!=
literal|'\\'
condition|)
name|instr
operator|=
literal|0
expr_stmt|;
name|margin
operator|=
literal|0
expr_stmt|;
block|}
name|needbp
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|argc
operator|>
literal|0
condition|)
do|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|isidchr
parameter_list|(
name|c
parameter_list|)
value|(isalnum(c) || (c) == '_')
end_define

begin_macro
name|putScp
argument_list|(
argument|os
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|os
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|os
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|xfld
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nokeyw
operator|||
name|incomm
operator|||
name|inacomm
operator|||
name|instr
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
call|(
modifier|*
name|isprbeg
call|)
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ps
argument_list|(
literal|"'FN "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|ps
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
modifier|*
name|isprend
call|)
argument_list|(
name|s
argument_list|)
condition|)
name|ps
argument_list|(
literal|"'-F\n"
argument_list|)
expr_stmt|;
name|skip
label|:
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\f'
condition|)
block|{
name|ps
argument_list|(
literal|"\n.bp\n"
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|index
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|xfld
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"
literal|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|xfld
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
comment|/*  		 *  for the following "really" hacked code, I 		 *  apologize. Creeping featurism got me. DLP 		 */
comment|/* check for the start of a string */
if|if
condition|(
operator|!
name|nokeyw
operator|&&
operator|!
operator|(
name|incomm
operator|||
name|inacomm
operator|)
operator|&&
operator|*
name|s
operator|==
name|sdelim
condition|)
block|{
if|if
condition|(
name|instr
condition|)
block|{
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
name|instr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|!=
name|cdelim
condition|)
name|instr
operator|=
literal|1
expr_stmt|;
block|}
comment|/* check for the end of a comment */
if|if
condition|(
name|incomm
operator|&&
name|lcstop
operator|!=
literal|0
operator|&&
name|comcol
operator|!=
name|s
operator|-
literal|1
operator|&&
name|s
operator|-
name|os
operator|>=
name|lcstop
operator|&&
operator|!
name|strncmp
argument_list|(
name|cstop
argument_list|,
name|s
operator|-
name|lcstop
argument_list|,
name|lcstop
argument_list|)
condition|)
block|{
name|incomm
operator|=
literal|0
expr_stmt|;
name|ps
argument_list|(
literal|"\\c\n'-C\n"
argument_list|)
expr_stmt|;
comment|/* check for the end of a comment of the alternate type */
block|}
elseif|else
if|if
condition|(
name|inacomm
operator|&&
name|lacstop
operator|!=
literal|0
operator|&&
name|comcol
operator|!=
name|s
operator|-
literal|1
operator|&&
name|s
operator|-
name|os
operator|>=
name|lacstop
operator|&&
operator|!
name|strncmp
argument_list|(
name|acstop
argument_list|,
name|s
operator|-
name|lacstop
argument_list|,
name|lacstop
argument_list|)
condition|)
block|{
name|inacomm
operator|=
literal|0
expr_stmt|;
name|ps
argument_list|(
literal|"\\c\n'-C\n"
argument_list|)
expr_stmt|;
comment|/* check for the start of a comment */
block|}
elseif|else
if|if
condition|(
operator|!
name|instr
operator|&&
operator|!
name|nokeyw
operator|&&
operator|!
operator|(
name|incomm
operator|||
name|inacomm
operator|)
operator|&&
name|lcstart
operator|!=
literal|0
operator|&&
operator|!
name|strncmp
argument_list|(
name|cstart
argument_list|,
name|s
argument_list|,
name|lcstart
argument_list|)
condition|)
block|{
name|comcol
operator|=
name|s
expr_stmt|;
name|incomm
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|os
condition|)
name|ps
argument_list|(
literal|"\\c"
argument_list|)
expr_stmt|;
name|ps
argument_list|(
literal|"\\c\n'+C\n"
argument_list|)
expr_stmt|;
name|margin
operator|=
name|width
argument_list|(
name|os
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|cout
argument_list|)
expr_stmt|;
name|s
operator|+=
name|lcstart
expr_stmt|;
continue|continue;
comment|/* check for the start of a comment of the alternate type */
block|}
elseif|else
if|if
condition|(
operator|!
name|instr
operator|&&
operator|!
name|nokeyw
operator|&&
operator|!
operator|(
name|incomm
operator|||
name|inacomm
operator|)
operator|&&
name|lacstart
operator|!=
literal|0
operator|&&
operator|!
name|strncmp
argument_list|(
name|acstart
argument_list|,
name|s
argument_list|,
name|lacstart
argument_list|)
condition|)
block|{
name|comcol
operator|=
name|s
expr_stmt|;
name|inacomm
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|os
condition|)
name|ps
argument_list|(
literal|"\\c"
argument_list|)
expr_stmt|;
name|ps
argument_list|(
literal|"\\c\n'+C\n"
argument_list|)
expr_stmt|;
name|margin
operator|=
name|width
argument_list|(
name|os
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|acout
argument_list|)
expr_stmt|;
name|s
operator|+=
name|lacstart
expr_stmt|;
continue|continue;
block|}
comment|/* take care of nice tab stops */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
name|i
operator|=
name|tabs
argument_list|(
name|os
argument_list|,
name|s
argument_list|)
operator|-
name|margin
operator|/
literal|8
expr_stmt|;
name|printf
argument_list|(
literal|"\\h'|%dn'"
argument_list|,
name|i
operator|*
literal|10
operator|+
literal|1
operator|-
name|margin
operator|%
literal|8
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		if (*s == '-'&& s[1] == '>') { 			s += 2; 			ps("\\(->"); 			continue; 		} */
if|if
condition|(
operator|!
name|incomm
operator|&&
operator|!
name|nokeyw
operator|&&
operator|!
name|instr
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'#'
operator|||
name|isalpha
argument_list|(
operator|*
name|s
argument_list|)
operator|)
operator|&&
operator|(
name|s
operator|==
name|os
operator|||
operator|!
name|isidchr
argument_list|(
name|s
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|i
operator|=
name|iskw
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|ps
argument_list|(
literal|"\\*(+K"
argument_list|)
expr_stmt|;
do|do
name|putcp
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
name|ps
argument_list|(
literal|"\\*(-K"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|putcp
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|tabs
argument_list|(
argument|s
argument_list|,
argument|os
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|os
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|width
argument_list|(
name|s
argument_list|,
name|os
argument_list|)
operator|/
literal|8
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|width
argument_list|(
name|s
argument_list|,
name|os
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|os
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|os
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
block|{
name|i
operator|=
operator|(
name|i
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|s
operator|<
literal|' '
condition|)
name|i
operator|+=
literal|2
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|putcp
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'{'
case|:
name|ps
argument_list|(
literal|"\\*(+K{\\*(-K"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|ps
argument_list|(
literal|"\\*(+K}\\*(-K"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|ps
argument_list|(
literal|"\\e"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
name|ps
argument_list|(
literal|"\\*_"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|ps
argument_list|(
literal|"\\*-"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
name|ps
argument_list|(
literal|"\\`"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|ps
argument_list|(
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|ps
argument_list|(
literal|"\\&."
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|<
literal|040
condition|)
name|putchar
argument_list|(
literal|'^'
argument_list|)
operator|,
name|c
operator||=
literal|'@'
expr_stmt|;
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  STRNCMP -	like strncmp except that we convert the  *	 	first string to lower case before comparing.  */
end_comment

begin_define
define|#
directive|define
name|makelower
parameter_list|(
name|c
parameter_list|)
value|(isupper((c)) ? tolower((c)) : (c))
end_define

begin_expr_stmt
name|STRNCMP
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
do|do
if|if
condition|(
operator|*
name|s2
operator|-
name|makelower
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
return|return
operator|(
operator|*
name|s2
operator|-
name|makelower
argument_list|(
operator|*
name|s1
argument_list|)
operator|)
return|;
else|else
block|{
name|s2
operator|++
expr_stmt|;
name|s1
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  iskw -	check to see if the next word is a keyword  */
end_comment

begin_expr_stmt
name|iskw
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ss
init|=
name|keywds
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|++
name|cp
operator|,
name|isidchr
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|ss
operator|++
condition|)
if|if
condition|(
operator|!
operator|(
name|upeqlow
condition|?
name|STRNCMP
argument_list|(
name|s
argument_list|,
name|cp
argument_list|,
name|i
argument_list|)
else|:
name|strncmp
argument_list|(
name|s
argument_list|,
name|cp
argument_list|,
name|i
argument_list|)
operator|)
operator|&&
operator|!
name|isidchr
argument_list|(
name|cp
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|cprbegin
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pname
expr_stmt|;
comment|/* 	 * some people like to start the names of routines that return 	 * a pointer with a '*'. 	 */
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'_'
operator|||
name|isalpha
argument_list|(
operator|*
name|s
argument_list|)
operator|)
operator|&&
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|')'
condition|)
block|{
while|while
condition|(
name|isidchr
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|cprend
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"}\n"
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|iprbegin
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|iprend
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|pprbegin
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pname
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|s
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'\t'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"procedure"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|+=
literal|9
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"function"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|+=
literal|8
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|(
operator|*
name|s
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'\t'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|s
operator|!=
literal|' '
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'\t'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'('
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|';'
operator|)
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|pprend
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"end"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mprbegin
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pname
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|10
index|]
argument_list|,
literal|"beginproc\n"
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
operator|*
name|s
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'\t'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|' '
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mprend
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|9
index|]
argument_list|,
literal|"endproc;\n"
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

