begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_re.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Entry points to open and visual from command mode processor.  * The open/visual code breaks down roughly as follows:  *  * ex_v.c	entry points, checking of terminal characteristics  *  * ex_vadj.c	logical screen control, use of intelligent operations  *		insert/delete line and coordination with screen image;  *		updating of screen after changes.  *  * ex_vget.c	input of single keys and reading of input lines  *		from the echo area, handling of \ escapes on input for  *		uppercase only terminals, handling of memory for repeated  *		commands and small saved texts from inserts and partline  *		deletes, notification of multi line changes in the echo  *		area.  *  * ex_vmain.c	main command decoding, some command processing.  *  * ex_voperate.c   decoding of operator/operand sequences and  *		contextual scans, implementation of word motions.  *  * ex_vops.c	major operator interfaces, undos, motions, deletes,  *		changes, opening new lines, shifts, replacements and yanks  *		coordinating logical and physical changes.  *  * ex_vops2.c	subroutines for operator interfaces in ex_vops.c,  *		insert mode, read input line processing at lowest level.  *  * ex_vops3.c	structured motion definitions of ( ) { } and [ ] operators,  *		indent for lisp routines, () and {} balancing.   *  * ex_vput.c	output routines, clearing, physical mapping of logical cursor  *		positioning, cursor motions, handling of insert character  *		and delete character functions of intelligent and unintelligent  *		terminals, visual mode tracing routines (for debugging),  *		control of screen image and its updating.  *  * ex_vwind.c	window level control of display, forward and backward rolls,  *		absolute motions, contextual displays, line depth determination  */
end_comment

begin_comment
comment|/*  * Enter open mode  */
end_comment

begin_macro
name|oop
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|ic
decl_stmt|;
name|char
name|atube
index|[
name|TUBESIZE
operator|+
name|LBSIZE
index|]
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
name|ovbeg
argument_list|()
expr_stmt|;
if|if
condition|(
name|peekchar
argument_list|()
operator|==
literal|'/'
condition|)
block|{
name|ignore
argument_list|(
name|compile
argument_list|(
name|getchar
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|savere
argument_list|(
name|scanre
argument_list|)
expr_stmt|;
if|if
condition|(
name|execute
argument_list|(
literal|0
argument_list|,
name|dot
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Fail|Pattern not found on addressed line"
argument_list|)
expr_stmt|;
name|ic
operator|=
name|loc1
expr_stmt|;
if|if
condition|(
name|ic
operator|>
name|linebuf
operator|&&
operator|*
name|ic
operator|==
literal|0
condition|)
name|ic
operator|--
expr_stmt|;
block|}
else|else
block|{
name|getDOT
argument_list|()
expr_stmt|;
name|ic
operator|=
name|vskipwh
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
name|newline
argument_list|()
expr_stmt|;
comment|/* 	 * If overstrike then have to HARDOPEN 	 * else if can move cursor up off current line can use CRTOPEN (~~vi1) 	 * otherwise (ugh) have to use ONEOPEN (like adm3) 	 */
if|if
condition|(
name|OS
operator|&&
operator|!
name|EO
condition|)
name|bastate
operator|=
name|HARDOPEN
expr_stmt|;
elseif|else
if|if
condition|(
name|CA
operator|||
name|UP
condition|)
name|bastate
operator|=
name|CRTOPEN
expr_stmt|;
else|else
name|bastate
operator|=
name|ONEOPEN
expr_stmt|;
name|setwind
argument_list|()
expr_stmt|;
comment|/* 	 * To avoid bombing on glass-crt's when the line is too long 	 * pretend that such terminals are 160 columns wide. 	 * If a line is too wide for display, we will dynamically 	 * switch to hardcopy open mode. 	 */
if|if
condition|(
name|state
operator|!=
name|CRTOPEN
condition|)
name|WCOLS
operator|=
name|TUBECOLS
expr_stmt|;
if|if
condition|(
operator|!
name|inglobal
condition|)
name|savevis
argument_list|()
expr_stmt|;
name|vok
argument_list|(
name|atube
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|CRTOPEN
condition|)
name|COLUMNS
operator|=
name|WCOLS
expr_stmt|;
name|Outchar
operator|=
name|vputchar
expr_stmt|;
name|f
operator|=
name|ostart
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|CRTOPEN
condition|)
block|{
if|if
condition|(
name|outcol
operator|==
name|UKCOL
condition|)
name|outcol
operator|=
literal|0
expr_stmt|;
name|vmoveitup
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|outline
operator|=
name|destline
operator|=
name|WBOT
expr_stmt|;
name|vshow
argument_list|(
name|dot
argument_list|,
name|NOLINE
argument_list|)
expr_stmt|;
name|vnline
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|vmain
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|CRTOPEN
condition|)
name|vclean
argument_list|()
expr_stmt|;
name|Command
operator|=
literal|"open"
expr_stmt|;
name|ovend
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ovbeg
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|value
argument_list|(
name|OPEN
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't use open/visual unless open option is set"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
name|error
argument_list|(
literal|"Recursive open/visual not allowed"
argument_list|)
expr_stmt|;
name|Vlines
operator|=
name|lineDOL
argument_list|()
expr_stmt|;
name|fixzero
argument_list|()
expr_stmt|;
name|setdot
argument_list|()
expr_stmt|;
name|pastwh
argument_list|()
expr_stmt|;
name|dot
operator|=
name|addr2
expr_stmt|;
block|}
end_block

begin_macro
name|ovend
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|splitw
operator|++
expr_stmt|;
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|holdcm
operator|=
literal|0
expr_stmt|;
name|splitw
operator|=
literal|0
expr_stmt|;
name|ostop
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|setoutt
argument_list|()
expr_stmt|;
name|undvis
argument_list|()
expr_stmt|;
name|COLUMNS
operator|=
name|OCOLUMNS
expr_stmt|;
name|inopen
operator|=
literal|0
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|netchHAD
argument_list|(
name|Vlines
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Enter visual mode  */
end_comment

begin_macro
name|vop
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|atube
index|[
name|TUBESIZE
operator|+
name|LBSIZE
index|]
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
if|if
condition|(
operator|!
name|CA
operator|&&
name|UP
operator|==
name|NOSTR
condition|)
block|{
if|if
condition|(
name|initev
condition|)
block|{
name|toopen
label|:
name|merror
argument_list|(
literal|"[Using open mode]"
argument_list|)
expr_stmt|;
name|putNFL
argument_list|()
expr_stmt|;
name|oop
argument_list|()
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"Visual needs addressible cursor or upline capability"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OS
operator|&&
operator|!
name|EO
condition|)
block|{
if|if
condition|(
name|initev
condition|)
goto|goto
name|toopen
goto|;
name|error
argument_list|(
literal|"Can't use visual on a terminal which overstrikes"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CL
condition|)
block|{
if|if
condition|(
name|initev
condition|)
goto|goto
name|toopen
goto|;
name|error
argument_list|(
literal|"Visual requires clear screen capability"
argument_list|)
expr_stmt|;
block|}
name|ovbeg
argument_list|()
expr_stmt|;
name|bastate
operator|=
name|VISUAL
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|any
argument_list|(
name|peekchar
argument_list|()
argument_list|,
literal|"+-^."
argument_list|)
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|pastwh
argument_list|()
expr_stmt|;
name|vsetsiz
argument_list|(
name|isdigit
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|?
name|getnum
argument_list|()
else|:
name|value
argument_list|(
name|WINDOW
argument_list|)
argument_list|)
expr_stmt|;
name|setwind
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|vok
argument_list|(
name|atube
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inglobal
condition|)
name|savevis
argument_list|()
expr_stmt|;
name|Outchar
operator|=
name|vputchar
expr_stmt|;
name|vmoving
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|ostart
argument_list|()
expr_stmt|;
if|if
condition|(
name|initev
operator|==
literal|0
condition|)
block|{
name|vcontext
argument_list|(
name|dot
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|vnline
argument_list|(
name|NOSTR
argument_list|)
expr_stmt|;
block|}
name|vmain
argument_list|()
expr_stmt|;
name|Command
operator|=
literal|"visual"
expr_stmt|;
name|ovend
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Hack to allow entry to visual with  * empty buffer since routines internally  * demand at least one line.  */
end_comment

begin_macro
name|fixzero
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|dol
operator|==
name|zero
condition|)
block|{
specifier|register
name|bool
name|ochng
init|=
name|chng
decl_stmt|;
name|vdoappend
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ochng
condition|)
name|sync
argument_list|()
expr_stmt|;
name|addr1
operator|=
name|addr2
operator|=
name|one
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addr2
operator|==
name|zero
condition|)
name|addr2
operator|=
name|one
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Save lines before visual between unddol and truedol.  * Accomplish this by throwing away current [unddol,truedol]  * and then saving all the lines in the buffer and moving  * unddol back to dol.  Don't do this if in a global.  *  * If you do  *	g/xxx/vi.  * and then do a  *	:e xxxx  * at some point, and then quit from the visual and undo  * you get the old file back.  Somewhat weird.  */
end_comment

begin_macro
name|savevis
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|inglobal
condition|)
return|return;
name|truedol
operator|=
name|unddol
expr_stmt|;
name|saveall
argument_list|()
expr_stmt|;
name|unddol
operator|=
name|dol
expr_stmt|;
name|undkind
operator|=
name|UNDNONE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Restore a sensible state after a visual/open, moving the saved  * stuff back to [unddol,dol], and killing the partial line kill indicators.  */
end_comment

begin_macro
name|undvis
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|ruptible
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
name|squish
argument_list|()
expr_stmt|;
name|pkill
index|[
literal|0
index|]
operator|=
name|pkill
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|unddol
operator|=
name|truedol
expr_stmt|;
name|unddel
operator|=
name|zero
expr_stmt|;
name|undap1
operator|=
name|one
expr_stmt|;
name|undap2
operator|=
name|dol
operator|+
literal|1
expr_stmt|;
name|undkind
operator|=
name|UNDALL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set the window parameters based on the base state bastate  * and the available buffer space.  */
end_comment

begin_macro
name|setwind
argument_list|()
end_macro

begin_block
block|{
name|WCOLS
operator|=
name|COLUMNS
expr_stmt|;
switch|switch
condition|(
name|bastate
condition|)
block|{
case|case
name|ONEOPEN
case|:
if|if
condition|(
name|AM
condition|)
name|WCOLS
operator|--
expr_stmt|;
comment|/* fall into ... */
case|case
name|HARDOPEN
case|:
name|basWTOP
operator|=
name|WTOP
operator|=
name|WBOT
operator|=
name|WECHO
operator|=
literal|0
expr_stmt|;
name|ZERO
operator|=
literal|0
expr_stmt|;
name|holdcm
operator|++
expr_stmt|;
break|break;
case|case
name|CRTOPEN
case|:
name|basWTOP
operator|=
name|LINES
operator|-
literal|2
expr_stmt|;
comment|/* fall into */
case|case
name|VISUAL
case|:
name|ZERO
operator|=
name|LINES
operator|-
name|TUBESIZE
operator|/
name|WCOLS
expr_stmt|;
if|if
condition|(
name|ZERO
operator|<
literal|0
condition|)
name|ZERO
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ZERO
operator|>
name|basWTOP
condition|)
name|error
argument_list|(
literal|"Screen too large for internal buffer"
argument_list|)
expr_stmt|;
name|WTOP
operator|=
name|basWTOP
expr_stmt|;
name|WBOT
operator|=
name|LINES
operator|-
literal|2
expr_stmt|;
name|WECHO
operator|=
name|LINES
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|state
operator|=
name|bastate
expr_stmt|;
name|basWLINES
operator|=
name|WLINES
operator|=
name|WBOT
operator|-
name|WTOP
operator|+
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Can we hack an open/visual on this terminal?  * If so, then divide the screen buffer up into lines,  * and initialize a bunch of state variables before we start.  */
end_comment

begin_expr_stmt
name|vok
argument_list|(
name|atube
argument_list|)
specifier|register
name|char
operator|*
name|atube
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|WCOLS
operator|==
literal|1000
condition|)
name|serror
argument_list|(
literal|"Don't know enough about your terminal to use %s"
argument_list|,
name|Command
argument_list|)
expr_stmt|;
if|if
condition|(
name|WCOLS
operator|>
name|TUBECOLS
condition|)
name|error
argument_list|(
literal|"Terminal too wide"
argument_list|)
expr_stmt|;
if|if
condition|(
name|WLINES
operator|>=
name|TUBELINES
operator|||
name|WCOLS
operator|*
operator|(
name|WECHO
operator|-
name|ZERO
operator|+
literal|1
operator|)
operator|>
name|TUBESIZE
condition|)
name|error
argument_list|(
literal|"Screen too large"
argument_list|)
expr_stmt|;
name|vtube0
operator|=
name|atube
expr_stmt|;
name|vclrbyte
argument_list|(
name|atube
argument_list|,
name|WCOLS
operator|*
operator|(
name|WECHO
operator|-
name|ZERO
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZERO
condition|;
name|i
operator|++
control|)
name|vtube
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|WECHO
condition|;
name|i
operator|++
control|)
name|vtube
index|[
name|i
index|]
operator|=
name|atube
operator|,
name|atube
operator|+=
name|WCOLS
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|TUBELINES
condition|;
name|i
operator|++
control|)
name|vtube
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|vutmp
operator|=
name|atube
expr_stmt|;
name|vundkind
operator|=
name|VNONE
expr_stmt|;
name|vUNDdot
operator|=
literal|0
expr_stmt|;
name|OCOLUMNS
operator|=
name|COLUMNS
expr_stmt|;
name|inopen
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|CBREAK
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|vintr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vmoving
operator|=
literal|0
expr_stmt|;
name|splitw
operator|=
literal|0
expr_stmt|;
name|doomed
operator|=
literal|0
expr_stmt|;
name|holdupd
operator|=
literal|0
expr_stmt|;
name|Peekkey
operator|=
literal|0
expr_stmt|;
name|vcnt
operator|=
name|vcline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vSCROLL
operator|==
literal|0
condition|)
name|vSCROLL
operator|=
operator|(
name|value
argument_list|(
name|WINDOW
argument_list|)
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* round up so dft=6,11 */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|CBREAK
end_ifdef

begin_macro
name|vintr
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|vintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcatch
condition|)
name|onintr
argument_list|()
expr_stmt|;
name|ungetkey
argument_list|(
name|ATTN
argument_list|)
expr_stmt|;
name|draino
argument_list|()
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set the size of the screen to size lines, to take effect the  * next time the screen is redrawn.  */
end_comment

begin_macro
name|vsetsiz
argument_list|(
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|b
decl_stmt|;
if|if
condition|(
name|bastate
operator|!=
name|VISUAL
condition|)
return|return;
name|b
operator|=
name|LINES
operator|-
literal|1
operator|-
name|size
expr_stmt|;
if|if
condition|(
name|b
operator|>=
name|LINES
operator|-
literal|1
condition|)
name|b
operator|=
name|LINES
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
name|b
operator|=
literal|0
expr_stmt|;
name|basWTOP
operator|=
name|b
expr_stmt|;
name|basWLINES
operator|=
name|WBOT
operator|-
name|b
operator|+
literal|1
expr_stmt|;
block|}
end_block

end_unit

