begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1981 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ex.c	7.2	%G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_argv.h"
end_include

begin_include
include|#
directive|include
file|"ex_temp.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_decl_stmt
name|char
name|tttrace
index|[]
init|=
block|{
literal|'/'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'v'
block|,
literal|'/'
block|,
literal|'t'
block|,
literal|'t'
block|,
literal|'y'
block|,
literal|'x'
block|,
literal|'x'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The code for ex is divided as follows:  *  * ex.c			Entry point and routines handling interrupt, hangup  *			signals; initialization code.  *  * ex_addr.c		Address parsing routines for command mode decoding.  *			Routines to set and check address ranges on commands.  *  * ex_cmds.c		Command mode command decoding.  *  * ex_cmds2.c		Subroutines for command decoding and processing of  *			file names in the argument list.  Routines to print  *			messages and reset state when errors occur.  *  * ex_cmdsub.c		Subroutines which implement command mode functions  *			such as append, delete, join.  *  * ex_data.c		Initialization of options.  *  * ex_get.c		Command mode input routines.  *  * ex_io.c		General input/output processing: file i/o, unix  *			escapes, filtering, source commands, preserving  *			and recovering.  *  * ex_put.c		Terminal driving and optimizing routines for low-level  *			output (cursor-positioning); output line formatting  *			routines.  *  * ex_re.c		Global commands, substitute, regular expression  *			compilation and execution.  *  * ex_set.c		The set command.  *  * ex_subr.c		Loads of miscellaneous subroutines.  *  * ex_temp.c		Editor buffer routines for main buffer and also  *			for named buffers (Q registers if you will.)  *  * ex_tty.c		Terminal dependent initializations from termcap  *			data base, grabbing of tty modes (at beginning  *			and after escapes).  *  * ex_unix.c		Routines for the ! command and its variations.  *  * ex_v*.c		Visual/open mode routines... see ex_v.c for a  *			guide to the overall organization.  */
end_comment

begin_comment
comment|/*  * Main procedure.  Process arguments and then  * transfer control to the main command processing loop  * in the routine commands.  We are entered as either "ex", "edit", "vi"  * or "view" and the distinction is made here.  Actually, we are "vi" if  * there is a 'v' in our name, "view" is there is a 'w', and "edit" if  * there is a 'd' in our name.  For edit we just diddle options;  * for vi we actually force an early visual command.  */
end_comment

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
specifier|register
name|int
name|ac
decl_stmt|;
specifier|register
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|VMUNIX
name|char
modifier|*
name|erpath
init|=
name|EXSTRINGS
decl_stmt|;
endif|#
directive|endif
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|bool
name|recov
init|=
literal|0
decl_stmt|;
name|bool
name|ivis
decl_stmt|;
name|bool
name|itag
init|=
literal|0
decl_stmt|;
name|bool
name|fast
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|onemt
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|TRACE
specifier|register
name|char
modifier|*
name|tracef
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Immediately grab the tty modes so that we wont 	 * get messed up if an interrupt comes in quickly. 	 */
name|gTTY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USG3TTY
name|normf
operator|=
name|tty
operator|.
name|sg_flags
expr_stmt|;
else|#
directive|else
name|normf
operator|=
name|tty
expr_stmt|;
endif|#
directive|endif
name|ppid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* 	 * Defend against d's, v's, w's, and a's in directories of 	 * path leading to our true name. 	 */
name|av
index|[
literal|0
index|]
operator|=
name|tailpath
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out how we were invoked: ex, edit, vi, view. 	 */
name|ivis
operator|=
name|any
argument_list|(
literal|'v'
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* "vi" */
if|if
condition|(
name|any
argument_list|(
literal|'w'
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
condition|)
comment|/* "view" */
name|value
argument_list|(
name|READONLY
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|any
argument_list|(
literal|'d'
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* "edit" */
name|value
argument_list|(
name|OPEN
argument_list|)
operator|=
literal|0
expr_stmt|;
name|value
argument_list|(
name|REPORT
argument_list|)
operator|=
literal|1
expr_stmt|;
name|value
argument_list|(
name|MAGIC
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|VMUNIX
comment|/* 	 * For debugging take files out of . if name is a.out. 	 */
if|if
condition|(
name|av
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'a'
condition|)
name|erpath
operator|=
name|tailpath
argument_list|(
name|erpath
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Open the error message file. 	 */
name|draino
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|VMUNIX
name|erfile
operator|=
name|open
argument_list|(
name|erpath
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|erfile
operator|<
literal|0
condition|)
block|{
name|erfile
operator|=
name|open
argument_list|(
name|erpath
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pstop
argument_list|()
expr_stmt|;
comment|/* 	 * Initialize interrupt handling. 	 */
name|oldhup
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldhup
operator|==
name|SIG_DFL
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|onhup
argument_list|)
expr_stmt|;
name|oldquit
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|ruptible
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_DFL
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_DFL
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|onhup
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_DFL
condition|)
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|onemt
argument_list|)
expr_stmt|;
comment|/* 	 * Process flag arguments. 	 */
name|ac
operator|--
operator|,
name|av
operator|++
expr_stmt|;
while|while
condition|(
name|ac
operator|&&
name|av
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|c
operator|=
name|av
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|hush
operator|=
literal|1
expr_stmt|;
name|value
argument_list|(
name|AUTOPRINT
argument_list|)
operator|=
literal|0
expr_stmt|;
name|fast
operator|++
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'R'
case|:
name|value
argument_list|(
name|READONLY
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TRACE
case|case
literal|'T'
case|:
if|if
condition|(
name|av
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|tracef
operator|=
literal|"trace"
expr_stmt|;
else|else
block|{
name|tracef
operator|=
name|tttrace
expr_stmt|;
name|tracef
index|[
literal|8
index|]
operator|=
name|av
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|tracef
index|[
literal|8
index|]
condition|)
name|tracef
index|[
literal|9
index|]
operator|=
name|av
index|[
literal|0
index|]
index|[
literal|3
index|]
expr_stmt|;
else|else
name|tracef
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|trace
operator|=
name|fopen
argument_list|(
name|tracef
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
define|#
directive|define
name|tracbuf
value|NULL
if|if
condition|(
name|trace
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"Trace create error\n"
argument_list|)
expr_stmt|;
else|else
name|setbuf
argument_list|(
name|trace
argument_list|,
name|tracbuf
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LISPCODE
case|case
literal|'l'
case|:
name|value
argument_list|(
name|LISP
argument_list|)
operator|=
literal|1
expr_stmt|;
name|value
argument_list|(
name|SHOWMATCH
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'r'
case|:
name|recov
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|ac
operator|>
literal|1
operator|&&
name|av
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|ac
operator|--
operator|,
name|av
operator|++
expr_stmt|;
name|itag
operator|=
literal|1
expr_stmt|;
comment|/* BUG: should check for too long tag. */
name|CP
argument_list|(
name|lasttag
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
name|ivis
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|defwind
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|av
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|defwind
operator|=
literal|3
expr_stmt|;
else|else
for|for
control|(
name|cp
operator|=
operator|&
name|av
index|[
literal|0
index|]
index|[
literal|2
index|]
init|;
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
name|defwind
operator|=
literal|10
operator|*
name|defwind
operator|+
operator|*
name|cp
operator|-
literal|'0'
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CRYPT
case|case
literal|'x'
case|:
comment|/* -x: encrypted mode */
name|xflag
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|smerror
argument_list|(
literal|"Unknown option %s\n"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|ac
operator|--
operator|,
name|av
operator|++
expr_stmt|;
block|}
comment|/* 	 * Initialize end of core pointers. 	 * Normally we avoid breaking back to fendcore after each 	 * file since this can be expensive (much core-core copying). 	 * If your system can scatter load processes you could do 	 * this as ed does, saving a little core, but it will probably 	 * not often make much difference. 	 */
name|fendcore
operator|=
operator|(
name|line
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|endcore
operator|=
name|fendcore
operator|-
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
if|if
condition|(
operator|!
name|hush
operator|&&
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_DFL
condition|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|onsusp
argument_list|)
operator|,
name|dosusp
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ac
operator|&&
name|av
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|firstpat
operator|=
operator|&
name|av
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|ac
operator|--
operator|,
name|av
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CRYPT
if|if
condition|(
name|xflag
condition|)
block|{
name|key
operator|=
name|getpass
argument_list|(
name|KEYPROMPT
argument_list|)
expr_stmt|;
name|kflag
operator|=
name|crinit
argument_list|(
name|key
argument_list|,
name|perm
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If we are doing a recover and no filename 	 * was given, then execute an exrecover command with 	 * the -r option to type out the list of saved file names. 	 * Otherwise set the remembered file name to the first argument 	 * file name so the "recover" initial command will find it. 	 */
if|if
condition|(
name|recov
condition|)
block|{
if|if
condition|(
name|ac
operator|==
literal|0
condition|)
block|{
name|ppid
operator|=
literal|0
expr_stmt|;
name|setrupt
argument_list|()
expr_stmt|;
name|execl
argument_list|(
name|EXRECOVER
argument_list|,
literal|"exrecover"
argument_list|,
literal|"-r"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filioerr
argument_list|(
name|EXRECOVER
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|(
name|savedfile
argument_list|,
operator|*
name|av
operator|++
argument_list|)
operator|,
name|ac
operator|--
expr_stmt|;
block|}
comment|/* 	 * Initialize the argument list. 	 */
name|argv0
operator|=
name|av
expr_stmt|;
name|argc0
operator|=
name|ac
expr_stmt|;
name|args0
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
name|erewind
argument_list|()
expr_stmt|;
comment|/* 	 * Initialize a temporary file (buffer) and 	 * set up terminal environment.  Read user startup commands. 	 */
if|if
condition|(
name|setexit
argument_list|()
operator|==
literal|0
condition|)
block|{
name|setrupt
argument_list|()
expr_stmt|;
name|intty
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|value
argument_list|(
name|PROMPT
argument_list|)
operator|=
name|intty
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
condition|)
name|CP
argument_list|(
name|shell
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fast
operator|||
operator|!
name|intty
condition|)
name|setterm
argument_list|(
literal|"dumb"
argument_list|)
expr_stmt|;
else|else
block|{
name|gettmode
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|*
name|cp
condition|)
name|setterm
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|setexit
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|fast
operator|&&
name|intty
condition|)
block|{
if|if
condition|(
operator|(
name|globp
operator|=
name|getenv
argument_list|(
literal|"EXINIT"
argument_list|)
operator|)
operator|&&
operator|*
name|globp
condition|)
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|globp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|*
name|cp
condition|)
name|source
argument_list|(
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|genbuf
argument_list|,
name|cp
argument_list|)
argument_list|,
literal|"/.exrc"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Allow local .exrc too.  This loses if . is $HOME, 		 * but nobody should notice unless they do stupid things 		 * like putting a version command in .exrc.  Besides, 		 * they should be using EXINIT, not .exrc, right? 		 */
name|source
argument_list|(
literal|".exrc"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|init
argument_list|()
expr_stmt|;
comment|/* moved after prev 2 chunks to fix directory option */
comment|/* 	 * Initial processing.  Handle tag, recover, and file argument 	 * implied next commands.  If going in as 'vi', then don't do 	 * anything, just set initev so we will do it later (from within 	 * visual). 	 */
if|if
condition|(
name|setexit
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|recov
condition|)
name|globp
operator|=
literal|"recover"
expr_stmt|;
elseif|else
if|if
condition|(
name|itag
condition|)
name|globp
operator|=
name|ivis
condition|?
literal|"tag"
else|:
literal|"tag|p"
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
condition|)
name|globp
operator|=
literal|"next"
expr_stmt|;
if|if
condition|(
name|ivis
condition|)
name|initev
operator|=
name|globp
expr_stmt|;
elseif|else
if|if
condition|(
name|globp
condition|)
block|{
name|inglobal
operator|=
literal|1
expr_stmt|;
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inglobal
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Vi command... go into visual. 	 * Strange... everything in vi usually happens 	 * before we ever "start". 	 */
if|if
condition|(
name|ivis
condition|)
block|{
comment|/* 		 * Don't have to be upward compatible with stupidity 		 * of starting editing at line $. 		 */
if|if
condition|(
name|dol
operator|>
name|zero
condition|)
name|dot
operator|=
name|one
expr_stmt|;
name|globp
operator|=
literal|"visual"
expr_stmt|;
if|if
condition|(
name|setexit
argument_list|()
operator|==
literal|0
condition|)
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear out trash in state accumulated by startup, 	 * and then do the main command loop for a normal edit. 	 * If you quit out of a 'vi' command by doing Q or ^\, 	 * you also fall through to here. 	 */
name|seenprompt
operator|=
literal|1
expr_stmt|;
name|ungetchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|globp
operator|=
literal|0
expr_stmt|;
name|initev
operator|=
literal|0
expr_stmt|;
name|setlastchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|setexit
argument_list|()
expr_stmt|;
name|commands
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialization, before editing a new file.  * Main thing here is to get a new buffer (in fileinit),  * rest is peripheral state resetting.  */
end_comment

begin_macro
name|init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fileinit
argument_list|()
expr_stmt|;
name|dot
operator|=
name|zero
operator|=
name|truedol
operator|=
name|unddol
operator|=
name|dol
operator|=
name|fendcore
expr_stmt|;
name|one
operator|=
name|zero
operator|+
literal|1
expr_stmt|;
name|undkind
operator|=
name|UNDNONE
expr_stmt|;
name|chng
operator|=
literal|0
expr_stmt|;
name|edited
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|names
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|anymarks
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPT
if|if
condition|(
name|xflag
condition|)
block|{
name|xtflag
operator|=
literal|1
expr_stmt|;
name|makekey
argument_list|(
name|key
argument_list|,
name|tperm
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Return last component of unix path name p.  */
end_comment

begin_function
name|char
modifier|*
name|tailpath
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|p
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|r
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

end_unit

