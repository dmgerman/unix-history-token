begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The pwb version this is based on */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|printf_id
init|=
literal|"@(#) printf.c:2.2 6/5/79"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The local sccs version within ex */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)printf.c	7.1	%G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"varargs.h"
end_include

begin_comment
comment|/*  * This version of printf is compatible with the Version 7 C  * printf. The differences are only minor except that this  * printf assumes it is to print through putchar. Version 7  * printf is more general (and is much larger) and includes  * provisions for floating point.  */
end_comment

begin_define
define|#
directive|define
name|MAXOCT
value|11
end_define

begin_comment
comment|/* Maximum octal digits in a long */
end_comment

begin_define
define|#
directive|define
name|MAXINT
value|32767
end_define

begin_comment
comment|/* largest normal length positive integer */
end_comment

begin_define
define|#
directive|define
name|BIG
value|1000000000
end_define

begin_comment
comment|/* largest power of 10 less than an unsigned long */
end_comment

begin_define
define|#
directive|define
name|MAXDIGS
value|10
end_define

begin_comment
comment|/* number of digits in BIG */
end_comment

begin_decl_stmt
specifier|static
name|int
name|width
decl_stmt|,
name|sign
decl_stmt|,
name|fill
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|_p_dconv
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|printf
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|char
name|fcode
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|int
name|length
decl_stmt|,
name|mask1
decl_stmt|,
name|nbits
decl_stmt|,
name|n
decl_stmt|;
name|long
name|int
name|mask2
decl_stmt|,
name|num
decl_stmt|;
specifier|register
name|char
modifier|*
name|bptr
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|buf
index|[
literal|134
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* process format string first */
while|while
condition|(
operator|(
name|fcode
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|!=
literal|'%'
condition|)
block|{
comment|/* ordinary (non-%) character */
if|if
condition|(
name|fcode
operator|==
literal|'\0'
condition|)
return|return;
name|putchar
argument_list|(
name|fcode
argument_list|)
expr_stmt|;
block|}
comment|/* length modifier: -1 for h, 1 for l, 0 for none */
name|length
operator|=
literal|0
expr_stmt|;
comment|/* check for a leading - sign */
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|++
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
comment|/* a '0' may follow the - sign */
comment|/* this is the requested fill character */
name|fill
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'0'
condition|)
block|{
name|fill
operator|--
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
comment|/* Now comes a digit string which may be a '*' */
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'*'
condition|)
block|{
name|width
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
name|width
operator|=
operator|-
name|width
expr_stmt|;
name|sign
operator|=
operator|!
name|sign
expr_stmt|;
block|}
name|fmt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|width
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|>=
literal|'0'
operator|&&
operator|*
name|fmt
operator|<=
literal|'9'
condition|)
name|width
operator|=
name|width
operator|*
literal|10
operator|+
operator|(
operator|*
name|fmt
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
comment|/* maybe a decimal point followed by more digits (or '*') */
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|fmt
operator|==
literal|'*'
condition|)
block|{
name|prec
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|prec
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|>=
literal|'0'
operator|&&
operator|*
name|fmt
operator|<=
literal|'9'
condition|)
name|prec
operator|=
name|prec
operator|*
literal|10
operator|+
operator|(
operator|*
name|fmt
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
block|}
else|else
name|prec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		 * At this point, "sign" is nonzero if there was 		 * a sign, "fill" is 0 if there was a leading 		 * zero and 1 otherwise, "width" and "prec" 		 * contain numbers corresponding to the digit 		 * strings before and after the decimal point, 		 * respectively, and "fmt" addresses the next 		 * character after the whole mess. If there was 		 * no decimal point, "prec" will be -1. 		 */
switch|switch
condition|(
operator|*
name|fmt
condition|)
block|{
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
name|length
operator|=
literal|2
expr_stmt|;
comment|/* no break!! */
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|length
operator|--
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 		 * At exit from the following switch, we will 		 * emit the characters starting at "bptr" and 		 * ending at "ptr"-1, unless fcode is '\0'. 		 */
switch|switch
condition|(
name|fcode
operator|=
operator|*
name|fmt
operator|++
condition|)
block|{
comment|/* process characters and strings first */
case|case
literal|'c'
case|:
name|buf
index|[
literal|0
index|]
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|bptr
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|ptr
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|bptr
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|bptr
operator|==
literal|0
condition|)
name|bptr
operator|=
literal|"(null pointer)"
expr_stmt|;
if|if
condition|(
name|prec
operator|<
literal|0
condition|)
name|prec
operator|=
name|MAXINT
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|*
name|bptr
operator|++
operator|&&
name|n
operator|<
name|prec
condition|;
name|n
operator|++
control|)
empty_stmt|;
name|ptr
operator|=
operator|--
name|bptr
expr_stmt|;
name|bptr
operator|-=
name|n
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|length
operator|=
literal|1
expr_stmt|;
name|fcode
operator|=
literal|'o'
expr_stmt|;
comment|/* no break */
case|case
literal|'o'
case|:
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|num
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
argument_list|)
expr_stmt|;
else|else
name|num
operator|=
operator|(
name|unsigned
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
literal|'o'
condition|)
block|{
name|mask1
operator|=
literal|0x7
expr_stmt|;
name|mask2
operator|=
literal|0x1fffffffL
expr_stmt|;
name|nbits
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|mask1
operator|=
literal|0xf
expr_stmt|;
name|mask2
operator|=
literal|0x0fffffffL
expr_stmt|;
name|nbits
operator|=
literal|4
expr_stmt|;
block|}
name|n
operator|=
operator|(
name|num
operator|!=
literal|0
operator|)
expr_stmt|;
name|bptr
operator|=
name|buf
operator|+
name|MAXOCT
operator|+
literal|3
expr_stmt|;
comment|/* shift and mask for speed */
do|do
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|num
operator|&
name|mask1
operator|)
operator|<
literal|10
condition|)
operator|*
operator|--
name|bptr
operator|=
operator|(
operator|(
name|int
operator|)
name|num
operator|&
name|mask1
operator|)
operator|+
literal|060
expr_stmt|;
else|else
operator|*
operator|--
name|bptr
operator|=
operator|(
operator|(
name|int
operator|)
name|num
operator|&
name|mask1
operator|)
operator|+
literal|0127
expr_stmt|;
do|while
condition|(
name|num
operator|=
operator|(
name|num
operator|>>
name|nbits
operator|)
operator|&
name|mask2
condition|)
do|;
if|if
condition|(
name|fcode
operator|==
literal|'o'
condition|)
block|{
if|if
condition|(
name|n
condition|)
operator|*
operator|--
name|bptr
operator|=
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sign
operator|&&
name|fill
operator|<=
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|fcode
argument_list|)
expr_stmt|;
name|width
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|--
name|bptr
operator|=
name|fcode
expr_stmt|;
operator|*
operator|--
name|bptr
operator|=
literal|'0'
expr_stmt|;
block|}
name|ptr
operator|=
name|buf
operator|+
name|MAXOCT
operator|+
literal|3
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'U'
case|:
case|case
literal|'I'
case|:
name|length
operator|=
literal|1
expr_stmt|;
name|fcode
operator|=
name|fcode
operator|+
literal|'a'
operator|-
literal|'A'
expr_stmt|;
comment|/* no break */
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|num
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
literal|'u'
condition|)
name|num
operator|=
operator|(
name|unsigned
operator|)
name|n
expr_stmt|;
else|else
name|num
operator|=
operator|(
name|long
operator|)
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|=
operator|(
name|fcode
operator|!=
literal|'u'
operator|&&
name|num
operator|<
literal|0
operator|)
condition|)
name|num
operator|=
operator|-
name|num
expr_stmt|;
comment|/* now convert to digits */
name|bptr
operator|=
name|_p_dconv
argument_list|(
name|num
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
operator|*
operator|--
name|bptr
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|fill
operator|==
literal|0
condition|)
name|fill
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr
operator|=
name|buf
operator|+
name|MAXDIGS
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* not a control character,  				 * print it. 				 */
name|ptr
operator|=
name|bptr
operator|=
operator|&
name|fcode
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fcode
operator|!=
literal|'\0'
condition|)
name|_p_emit
argument_list|(
name|bptr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* _p_dconv converts the unsigned long integer "value" to  * printable decimal and places it in "buffer", right-justified.  * The value returned is the address of the first non-zero character,  * or the address of the last character if all are zero.  * The result is NOT null terminated, and is MAXDIGS characters long,  * starting at buffer[1] (to allow for insertion of a sign).  *  * This program assumes it is running on 2's complement machine  * with reasonable overflow treatment.  */
end_comment

begin_function
name|char
modifier|*
name|_p_dconv
parameter_list|(
name|value
parameter_list|,
name|buffer
parameter_list|)
name|long
name|value
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|svalue
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|lval
decl_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
comment|/* zero is a special case */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|bp
operator|+=
name|MAXDIGS
expr_stmt|;
operator|*
name|bp
operator|=
literal|'0'
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
comment|/* develop the leading digit of the value in "n" */
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|value
operator|-=
name|BIG
expr_stmt|;
comment|/* will eventually underflow */
name|n
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|lval
operator|=
name|value
operator|-
name|BIG
operator|)
operator|>=
literal|0
condition|)
block|{
name|value
operator|=
name|lval
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
comment|/* stash it in buffer[1] to allow for a sign */
name|bp
index|[
literal|1
index|]
operator|=
name|n
operator|+
literal|'0'
expr_stmt|;
comment|/* 	 * Now develop the rest of the digits. Since speed counts here, 	 * we do it in two loops. The first gets "value" down until it 	 * is no larger than MAXINT. The second one uses integer divides 	 * rather than long divides to speed it up. 	 */
name|bp
operator|+=
name|MAXDIGS
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|value
operator|>
name|MAXINT
condition|)
block|{
operator|*
operator|--
name|bp
operator|=
call|(
name|int
call|)
argument_list|(
name|value
operator|%
literal|10
argument_list|)
operator|+
literal|'0'
expr_stmt|;
name|value
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* cannot lose precision */
name|svalue
operator|=
name|value
expr_stmt|;
while|while
condition|(
name|svalue
operator|>
literal|0
condition|)
block|{
operator|*
operator|--
name|bp
operator|=
operator|(
name|svalue
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|svalue
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* fill in intermediate zeroes if needed */
if|if
condition|(
name|buffer
index|[
literal|1
index|]
operator|!=
literal|'0'
condition|)
block|{
while|while
condition|(
name|bp
operator|>
name|buffer
operator|+
literal|2
condition|)
operator|*
operator|--
name|bp
operator|=
literal|'0'
expr_stmt|;
operator|--
name|bp
expr_stmt|;
block|}
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This program sends string "s" to putchar. The character after  * the end of "s" is given by "send". This allows the size of the  * field to be computed; it is stored in "alen". "width" contains the  * user specified length. If width<alen, the width will be taken to  * be alen. "sign" is zero if the string is to be right-justified  * in the field, nonzero if it is to be left-justified. "fill" is  * 0 if the string is to be padded with '0', positive if it is to be  * padded with ' ', and negative if an initial '-' should appear before  * any padding in right-justification (to avoid printing "-3" as  * "000-3" where "-0003" was intended).  */
end_comment

begin_expr_stmt
name|_p_emit
argument_list|(
name|s
argument_list|,
name|send
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|send
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cfill
decl_stmt|;
specifier|register
name|int
name|alen
decl_stmt|;
name|int
name|npad
decl_stmt|;
name|alen
operator|=
name|send
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|alen
operator|>
name|width
condition|)
name|width
operator|=
name|alen
expr_stmt|;
name|cfill
operator|=
name|fill
operator|>
literal|0
condition|?
literal|' '
else|:
literal|'0'
expr_stmt|;
comment|/* we may want to print a leading '-' before anything */
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|fill
operator|<
literal|0
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|alen
operator|--
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
name|npad
operator|=
name|width
operator|-
name|alen
expr_stmt|;
comment|/* emit any leading pad characters */
if|if
condition|(
operator|!
name|sign
condition|)
while|while
condition|(
operator|--
name|npad
operator|>=
literal|0
condition|)
name|putchar
argument_list|(
name|cfill
argument_list|)
expr_stmt|;
comment|/* emit the string itself */
while|while
condition|(
operator|--
name|alen
operator|>=
literal|0
condition|)
name|putchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
comment|/* emit trailing pad characters */
if|if
condition|(
name|sign
condition|)
while|while
condition|(
operator|--
name|npad
operator|>=
literal|0
condition|)
name|putchar
argument_list|(
name|cfill
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

