begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * This file defines the operation sequences which interface the  * logical changes to the file buffer with the internal and external  * display representations.  */
end_comment

begin_comment
comment|/*  * Undo.  *  * Undo is accomplished in two ways.  We often for small changes in the  * current line know how (in terms of a change operator) how the change  * occurred.  Thus on an intelligent terminal we can undo the operation  * by another such operation, using insert and delete character  * stuff.  The pointers vU[AD][12] index the buffer vutmp when this  * is possible and provide the necessary information.  *  * The other case is that the change involved multiple lines or that  * we have moved away from the line or forgotten how the change was  * accomplished.  In this case we do a redisplay and hope that the  * low level optimization routines (which don't look for winning  * via insert/delete character) will not lose too badly.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|vUA1
decl_stmt|,
modifier|*
name|vUA2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|vUD1
decl_stmt|,
modifier|*
name|vUD2
decl_stmt|;
end_decl_stmt

begin_macro
name|vUndo
argument_list|()
end_macro

begin_block
block|{
comment|/* 	 * Avoid UU which clobbers ability to do u. 	 */
if|if
condition|(
name|vundkind
operator|==
name|VCAPU
operator|||
name|vUNDdot
operator|!=
name|dot
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|CP
argument_list|(
name|vutmp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|vUD1
operator|=
name|linebuf
expr_stmt|;
name|vUD2
operator|=
name|strend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|putmk1
argument_list|(
name|dot
argument_list|,
name|vUNDsav
argument_list|)
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
name|vUA1
operator|=
name|linebuf
expr_stmt|;
name|vUA2
operator|=
name|strend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|vundkind
operator|=
name|VCAPU
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|ONEOPEN
operator|||
name|state
operator|==
name|HARDOPEN
condition|)
block|{
name|vjumpto
argument_list|(
name|dot
argument_list|,
name|vUNDcurs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|vdirty
argument_list|(
name|vcline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vsyncCL
argument_list|()
expr_stmt|;
name|vfixcurs
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|vundo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|temp
index|[
name|LBSIZE
index|]
decl_stmt|;
name|bool
name|savenote
decl_stmt|;
name|int
function_decl|(
modifier|*
name|OO
function_decl|)
parameter_list|()
function_decl|;
name|short
name|oldhold
init|=
name|hold
decl_stmt|;
switch|switch
condition|(
name|vundkind
condition|)
block|{
case|case
name|VMANYINS
case|:
name|wcursor
operator|=
literal|0
expr_stmt|;
name|addr1
operator|=
name|undap1
expr_stmt|;
name|addr2
operator|=
name|undap2
operator|-
literal|1
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|YANKreg
argument_list|(
literal|'1'
argument_list|)
expr_stmt|;
name|notecnt
operator|=
literal|0
expr_stmt|;
comment|/* fall into ... */
case|case
name|VMANY
case|:
case|case
name|VMCHNG
case|:
name|vsave
argument_list|()
expr_stmt|;
name|addr
operator|=
name|dot
operator|-
name|vcline
expr_stmt|;
name|notecnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|undkind
operator|==
name|UNDPUT
operator|&&
name|undap1
operator|==
name|undap2
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* 		 * Undo() call below basically replaces undap1 to undap2-1 		 * with dol through unddol-1.  Hack screen image to 		 * reflect this replacement. 		 */
name|vreplace
argument_list|(
name|undap1
operator|-
name|addr
argument_list|,
name|undap2
operator|-
name|undap1
argument_list|,
name|undkind
operator|==
name|UNDPUT
condition|?
literal|0
else|:
name|unddol
operator|-
name|dol
argument_list|)
expr_stmt|;
name|savenote
operator|=
name|notecnt
expr_stmt|;
name|undo
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vundkind
operator|!=
name|VMCHNG
operator|||
name|addr
operator|!=
name|dot
condition|)
name|killU
argument_list|()
expr_stmt|;
name|vundkind
operator|=
name|VMANY
expr_stmt|;
name|cnt
operator|=
name|dot
operator|-
name|addr
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
operator|||
name|cnt
operator|>
name|vcnt
operator|||
name|state
operator|!=
name|VISUAL
condition|)
block|{
name|vjumpto
argument_list|(
name|dot
argument_list|,
name|NOSTR
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|savenote
condition|)
name|notecnt
operator|=
literal|0
expr_stmt|;
name|vcline
operator|=
name|cnt
expr_stmt|;
name|vrepaint
argument_list|(
name|vmcurs
argument_list|)
expr_stmt|;
name|vmcurs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VCHNG
case|:
case|case
name|VCAPU
case|:
name|vundkind
operator|=
name|VCHNG
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|vutmp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|vutmp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|doomed
operator|=
name|column
argument_list|(
name|vUA2
operator|-
literal|1
argument_list|)
operator|-
name|column
argument_list|(
name|vUA1
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strcLIN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|vUA1
expr_stmt|;
name|vUA1
operator|=
name|vUD1
expr_stmt|;
name|vUD1
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|vUA2
expr_stmt|;
name|vUA2
operator|=
name|vUD2
expr_stmt|;
name|vUD2
operator|=
name|cp
expr_stmt|;
name|cursor
operator|=
name|vUD1
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|HARDOPEN
condition|)
block|{
name|doomed
operator|=
literal|0
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|vopen
argument_list|(
name|dot
argument_list|,
name|WBOT
argument_list|)
expr_stmt|;
name|vnline
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Pseudo insert command. 		 */
name|vcursat
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|OO
operator|=
name|Outchar
expr_stmt|;
name|Outchar
operator|=
name|vinschar
expr_stmt|;
name|hold
operator||=
name|HOLDQIK
expr_stmt|;
name|vprepins
argument_list|()
expr_stmt|;
name|temp
index|[
name|vUA2
operator|-
name|linebuf
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|&
name|temp
index|[
name|vUA1
operator|-
name|linebuf
index|]
init|;
operator|*
name|cp
condition|;
control|)
name|putchar
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
name|Outchar
operator|=
name|OO
expr_stmt|;
name|hold
operator|=
name|oldhold
expr_stmt|;
name|endim
argument_list|()
expr_stmt|;
name|physdc
argument_list|(
name|cindent
argument_list|()
argument_list|,
name|cindent
argument_list|()
operator|+
name|doomed
argument_list|)
expr_stmt|;
name|doomed
operator|=
literal|0
expr_stmt|;
name|vdirty
argument_list|(
name|vcline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vsyncCL
argument_list|()
expr_stmt|;
if|if
condition|(
name|cursor
operator|>
name|linebuf
operator|&&
name|cursor
operator|>=
name|strend
argument_list|(
name|linebuf
argument_list|)
condition|)
name|cursor
operator|--
expr_stmt|;
name|vfixcurs
argument_list|()
expr_stmt|;
break|break;
case|case
name|VNONE
case|:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * Initialize undo information before an append.  */
end_comment

begin_macro
name|vnoapp
argument_list|()
end_macro

begin_block
block|{
name|vUD1
operator|=
name|vUD2
operator|=
name|cursor
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * All the rest of the motion sequences have one or more  * cases to deal with.  In the case wdot == 0, operation  * is totally within current line, from cursor to wcursor.  * If wdot is given, but wcursor is 0, then operation affects  * the inclusive line range.  The hardest case is when both wdot  * and wcursor are given, then operation affects from line dot at  * cursor to line wdot at wcursor.  */
end_comment

begin_comment
comment|/*  * Move is simple, except for moving onto new lines in hardcopy open mode.  */
end_comment

begin_macro
name|vmove
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
if|if
condition|(
name|wdot
condition|)
block|{
if|if
condition|(
name|wdot
operator|<
name|one
operator|||
name|wdot
operator|>
name|dol
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|cnt
operator|=
name|wdot
operator|-
name|dot
expr_stmt|;
name|wdot
operator|=
name|NOLINE
expr_stmt|;
if|if
condition|(
name|cnt
condition|)
name|killU
argument_list|()
expr_stmt|;
name|vupdown
argument_list|(
name|cnt
argument_list|,
name|wcursor
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * When we move onto a new line, save information for U undo. 	 */
if|if
condition|(
name|vUNDdot
operator|!=
name|dot
condition|)
block|{
name|vUNDsav
operator|=
operator|*
name|dot
expr_stmt|;
name|vUNDcurs
operator|=
name|wcursor
expr_stmt|;
name|vUNDdot
operator|=
name|dot
expr_stmt|;
block|}
comment|/* 	 * In hardcopy open, type characters to left of cursor 	 * on new line, or back cursor up if its to left of where we are. 	 * In any case if the current line is ``rubbled'' i.e. has trashy 	 * looking overstrikes on it or \'s from deletes, we reprint 	 * so it is more comprehensible (and also because we can't work 	 * if we let it get more out of sync since column() won't work right. 	 */
if|if
condition|(
name|state
operator|==
name|HARDOPEN
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|rubble
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|oldhold
init|=
name|hold
decl_stmt|;
name|sethard
argument_list|()
expr_stmt|;
name|cp
operator|=
name|wcursor
expr_stmt|;
name|c
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|hold
operator||=
name|HOLDDOL
expr_stmt|;
name|vreopen
argument_list|(
name|WTOP
argument_list|,
name|lineDOT
argument_list|()
argument_list|,
name|vcline
argument_list|)
expr_stmt|;
name|hold
operator|=
name|oldhold
expr_stmt|;
operator|*
name|cp
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wcursor
operator|>
name|cursor
condition|)
block|{
name|vfixcurs
argument_list|()
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cursor
init|;
operator|*
name|cp
operator|&&
name|cp
operator|<
name|wcursor
condition|;
control|)
block|{
specifier|register
name|int
name|c
init|=
operator|*
name|cp
operator|++
operator|&
name|TRIM
decl_stmt|;
name|putchar
argument_list|(
name|c
condition|?
name|c
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|vsetcurs
argument_list|(
name|wcursor
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Delete operator.  *  * Hard case of deleting a range where both wcursor and wdot  * are specified is treated as a special case of change and handled  * by vchange (although vchange may pass it back if it degenerates  * to a full line range delete.)  */
end_comment

begin_macro
name|vdelete
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wdot
condition|)
block|{
if|if
condition|(
name|wcursor
condition|)
block|{
name|vchange
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|xdw
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
block|{
name|vgoto
argument_list|(
name|LINE
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vputchar
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
block|}
name|wdot
operator|=
name|dot
expr_stmt|;
name|vremote
argument_list|(
name|i
argument_list|,
name|delete
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|notenam
operator|=
literal|"delete"
expr_stmt|;
name|DEL
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|killU
argument_list|()
expr_stmt|;
name|vreplace
argument_list|(
name|vcline
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdot
operator|>
name|dol
condition|)
name|vcline
operator|--
expr_stmt|;
name|vrepaint
argument_list|(
name|NOSTR
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wcursor
operator|<
name|linebuf
condition|)
name|wcursor
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
name|cursor
operator|==
name|wcursor
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|vdcMID
argument_list|()
expr_stmt|;
name|cp
operator|=
name|cursor
expr_stmt|;
name|setDEL
argument_list|()
expr_stmt|;
name|CP
argument_list|(
name|cp
argument_list|,
name|wcursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|linebuf
operator|&&
operator|(
name|cp
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|c
operator|==
literal|'#'
operator|)
condition|)
name|cp
operator|--
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|HARDOPEN
condition|)
block|{
name|bleep
argument_list|(
name|i
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|cp
expr_stmt|;
return|return;
block|}
name|physdc
argument_list|(
name|column
argument_list|(
name|cursor
operator|-
literal|1
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|DEPTH
argument_list|(
name|vcline
argument_list|)
operator|=
literal|0
expr_stmt|;
name|vreopen
argument_list|(
name|LINE
argument_list|(
name|vcline
argument_list|)
argument_list|,
name|lineDOT
argument_list|()
argument_list|,
name|vcline
argument_list|)
expr_stmt|;
name|vsyncCL
argument_list|()
expr_stmt|;
name|vsetcurs
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Change operator.  *  * In a single line we mark the end of the changed area with '$'.  * On multiple whole lines, we clear the lines first.  * Across lines with both wcursor and wdot given, we delete  * and sync then append (but one operation for undo).  */
end_comment

begin_macro
name|vchange
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|ind
decl_stmt|,
name|cnt
decl_stmt|;
name|line
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|wdot
condition|)
block|{
comment|/* 		 * Change/delete of lines or across line boundaries. 		 */
if|if
condition|(
operator|(
name|cnt
operator|=
name|xdw
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return;
name|getDOT
argument_list|()
expr_stmt|;
if|if
condition|(
name|wcursor
operator|&&
name|cnt
operator|==
literal|1
condition|)
block|{
comment|/* 			 * Not really. 			 */
name|wdot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
name|vdelete
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|smallchange
goto|;
block|}
if|if
condition|(
name|cursor
operator|&&
name|wcursor
condition|)
block|{
comment|/* 			 * Across line boundaries, but not 			 * necessarily whole lines. 			 * Construct what will be left. 			 */
operator|*
name|cursor
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|genbuf
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|getline
argument_list|(
operator|*
name|wdot
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|genbuf
argument_list|)
operator|+
name|strlen
argument_list|(
name|wcursor
argument_list|)
operator|>
name|LBSIZE
operator|-
literal|2
condition|)
block|{
name|getDOT
argument_list|()
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|strcat
argument_list|(
name|genbuf
argument_list|,
name|wcursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'d'
operator|&&
operator|*
name|vpastwh
argument_list|(
name|genbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Although this is a delete 				 * spanning line boundaries, what 				 * would be left is all white space, 				 * so take it all away. 				 */
name|wcursor
operator|=
literal|0
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
name|op
operator|=
literal|0
expr_stmt|;
name|notpart
argument_list|(
name|lastreg
argument_list|)
expr_stmt|;
name|notpart
argument_list|(
literal|'1'
argument_list|)
expr_stmt|;
name|vdelete
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|ind
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
operator|&&
name|wcursor
operator|==
literal|0
condition|)
block|{
name|vdelete
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
ifdef|#
directive|ifdef
name|LISPCODE
comment|/* 			 * We are just substituting text for whole lines, 			 * so determine the first autoindent. 			 */
if|if
condition|(
name|value
argument_list|(
name|LISP
argument_list|)
operator|&&
name|value
argument_list|(
name|AUTOINDENT
argument_list|)
condition|)
name|ind
operator|=
name|lindent
argument_list|(
name|dot
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ind
operator|=
name|whitecnt
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|i
operator|=
name|vcline
operator|>=
literal|0
condition|?
name|LINE
argument_list|(
name|vcline
argument_list|)
else|:
name|WTOP
expr_stmt|;
comment|/* 		 * Delete the lines from the buffer, 		 * and remember how the partial stuff came about in 		 * case we are told to put. 		 */
name|addr
operator|=
name|dot
expr_stmt|;
name|vremote
argument_list|(
name|cnt
argument_list|,
name|delete
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setpk
argument_list|()
expr_stmt|;
name|notenam
operator|=
literal|"delete"
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'d'
condition|)
name|notenam
operator|=
literal|"change"
expr_stmt|;
comment|/* 		 * If DEL[0] were nonzero, put would put it back 		 * rather than the deleted lines. 		 */
name|DEL
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|1
condition|)
name|killU
argument_list|()
expr_stmt|;
comment|/* 		 * Now hack the screen image coordination. 		 */
name|vreplace
argument_list|(
name|vcline
argument_list|,
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wdot
operator|=
name|NOLINE
expr_stmt|;
name|noteit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vcline
operator|--
expr_stmt|;
if|if
condition|(
name|addr
operator|<=
name|dol
condition|)
name|dot
operator|--
expr_stmt|;
comment|/* 		 * If this is a across line delete/change, 		 * cursor stays where it is; just splice together the pieces 		 * of the new line.  Otherwise generate a autoindent 		 * after a S command. 		 */
if|if
condition|(
name|ind
operator|>=
literal|0
condition|)
block|{
operator|*
name|genindent
argument_list|(
name|ind
argument_list|)
operator|=
literal|0
expr_stmt|;
name|vdoappend
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vmcurs
operator|=
name|cursor
expr_stmt|;
name|strcLIN
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
name|vdoappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Indicate a change on hardcopies by 		 * erasing the current line. 		 */
if|if
condition|(
name|c
operator|!=
literal|'d'
operator|&&
name|state
operator|!=
name|VISUAL
operator|&&
name|state
operator|!=
name|HARDOPEN
condition|)
block|{
name|int
name|oldhold
init|=
name|hold
decl_stmt|;
name|hold
operator||=
name|HOLDAT
operator|,
name|vclrlin
argument_list|(
name|i
argument_list|,
name|dot
argument_list|)
operator|,
name|hold
operator|=
name|oldhold
expr_stmt|;
block|}
comment|/* 		 * Open the line (logically) on the screen, and  		 * update the screen tail.  Unless we are really a delete 		 * go off and gather up inserted characters. 		 */
name|vcline
operator|++
expr_stmt|;
if|if
condition|(
name|vcline
operator|<
literal|0
condition|)
name|vcline
operator|=
literal|0
expr_stmt|;
name|vopen
argument_list|(
name|dot
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vsyncCL
argument_list|()
expr_stmt|;
name|noteit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'d'
condition|)
block|{
if|if
condition|(
name|ind
operator|>=
literal|0
condition|)
block|{
name|cursor
operator|=
name|linebuf
expr_stmt|;
name|linebuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|vfixcurs
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ind
operator|=
literal|0
expr_stmt|;
name|vcursat
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
name|vappend
argument_list|(
literal|'x'
argument_list|,
literal|1
argument_list|,
name|ind
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|cursor
operator|==
literal|0
operator|&&
name|cursor
operator|>
name|linebuf
condition|)
name|cursor
operator|--
expr_stmt|;
name|vrepaint
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
return|return;
block|}
name|smallchange
label|:
comment|/* 	 * The rest of this is just low level hacking on changes 	 * of small numbers of characters. 	 */
if|if
condition|(
name|wcursor
operator|<
name|linebuf
condition|)
name|wcursor
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
name|cursor
operator|==
name|wcursor
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|vdcMID
argument_list|()
expr_stmt|;
name|cp
operator|=
name|cursor
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|HARDOPEN
condition|)
name|vfixcurs
argument_list|()
expr_stmt|;
comment|/* 	 * Put out the \\'s indicating changed text in hardcopy, 	 * or mark the end of the change with $ if not hardcopy. 	 */
if|if
condition|(
name|state
operator|==
name|HARDOPEN
condition|)
name|bleep
argument_list|(
name|i
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
block|{
name|vcursbef
argument_list|(
name|wcursor
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|i
operator|=
name|cindent
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Remember the deleted text for possible put, 	 * and then prepare and execute the input portion of the change. 	 */
name|cursor
operator|=
name|cp
expr_stmt|;
name|setDEL
argument_list|()
expr_stmt|;
name|CP
argument_list|(
name|cursor
argument_list|,
name|wcursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|HARDOPEN
condition|)
block|{
name|vcursaft
argument_list|(
name|cursor
operator|-
literal|1
argument_list|)
expr_stmt|;
name|doomed
operator|=
name|i
operator|-
name|cindent
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		sethard(); 		wcursor = cursor; 		cursor = linebuf; 		vgoto(outline, value(NUMBER)<< 3); 		vmove(); */
name|doomed
operator|=
literal|0
expr_stmt|;
block|}
name|prepapp
argument_list|()
expr_stmt|;
name|vappend
argument_list|(
literal|'c'
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Open new lines.  *  * Tricky thing here is slowopen.  This causes display updating  * to be held off so that 300 baud dumb terminals don't lose badly.  * This also suppressed counts, which otherwise say how many blank  * space to open up.  Counts are also suppressed on intelligent terminals.  * Actually counts are obsoleted, since if your terminal is slow  * you are better off with slowopen.  */
end_comment

begin_macro
name|voOpen
argument_list|(
argument|c
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|ind
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|short
name|oldhold
init|=
name|hold
decl_stmt|;
if|if
condition|(
name|value
argument_list|(
name|SLOWOPEN
argument_list|)
operator|||
name|value
argument_list|(
name|REDRAW
argument_list|)
operator|&&
name|AL
operator|&&
name|DL
condition|)
name|cnt
operator|=
literal|1
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|setLAST
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
argument_list|(
name|AUTOINDENT
argument_list|)
condition|)
name|ind
operator|=
name|whitecnt
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'O'
condition|)
block|{
name|vcline
operator|--
expr_stmt|;
name|dot
operator|--
expr_stmt|;
if|if
condition|(
name|dot
operator|>
name|zero
condition|)
name|getDOT
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|value
argument_list|(
name|AUTOINDENT
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|LISPCODE
if|if
condition|(
name|value
argument_list|(
name|LISP
argument_list|)
condition|)
name|ind
operator|=
name|lindent
argument_list|(
name|dot
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|killU
argument_list|()
expr_stmt|;
name|prepapp
argument_list|()
expr_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
name|vundkind
operator|=
name|VMANY
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
name|c
operator|=
name|WBOT
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|c
operator|=
name|vcline
operator|<
literal|0
condition|?
name|WTOP
operator|-
name|cnt
else|:
name|LINE
argument_list|(
name|vcline
argument_list|)
operator|+
name|DEPTH
argument_list|(
name|vcline
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|ZERO
condition|)
name|c
operator|=
name|ZERO
expr_stmt|;
name|i
operator|=
name|LINE
argument_list|(
name|vcline
operator|+
literal|1
argument_list|)
operator|-
name|c
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|cnt
operator|&&
name|c
operator|<=
name|WBOT
operator|&&
operator|(
operator|!
name|AL
operator|||
operator|!
name|DL
operator|)
condition|)
name|vinslin
argument_list|(
name|c
argument_list|,
name|cnt
operator|-
name|i
argument_list|,
name|vcline
argument_list|)
expr_stmt|;
block|}
operator|*
name|genindent
argument_list|(
name|ind
argument_list|)
operator|=
literal|0
expr_stmt|;
name|vdoappend
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
name|vcline
operator|++
expr_stmt|;
name|oldhold
operator|=
name|hold
expr_stmt|;
name|hold
operator||=
name|HOLDROL
expr_stmt|;
name|vopen
argument_list|(
name|dot
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|hold
operator|=
name|oldhold
expr_stmt|;
if|if
condition|(
name|value
argument_list|(
name|SLOWOPEN
argument_list|)
condition|)
comment|/* 		 * Oh, so lazy! 		 */
name|vscrap
argument_list|()
expr_stmt|;
else|else
name|vsync1
argument_list|(
name|LINE
argument_list|(
name|vcline
argument_list|)
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|linebuf
expr_stmt|;
name|linebuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|vappend
argument_list|(
literal|'o'
argument_list|,
literal|1
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *>< and = shift operators.  *  * Note that =, which aligns lisp, is just a ragged sort of shift,  * since it never distributes text between lines.  */
end_comment

begin_decl_stmt
name|char
name|vshnam
index|[
literal|2
index|]
init|=
block|{
literal|'x'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|vshftop
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|=
name|xdw
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return;
name|addr
operator|=
name|dot
expr_stmt|;
name|vremote
argument_list|(
name|cnt
argument_list|,
name|vshift
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vshnam
index|[
literal|0
index|]
operator|=
name|op
expr_stmt|;
name|notenam
operator|=
name|vshnam
expr_stmt|;
name|dot
operator|=
name|addr
expr_stmt|;
name|vreplace
argument_list|(
name|vcline
argument_list|,
name|cnt
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|HARDOPEN
condition|)
name|vcnt
operator|=
literal|0
expr_stmt|;
name|vrepaint
argument_list|(
name|NOSTR
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * !.  *  * Filter portions of the buffer through unix commands.  */
end_comment

begin_macro
name|vfilter
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|oglobp
decl_stmt|,
name|d
decl_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|=
name|xdw
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|vglobp
condition|)
name|vglobp
operator|=
name|uxb
expr_stmt|;
if|if
condition|(
name|readecho
argument_list|(
literal|'!'
argument_list|)
condition|)
return|return;
name|oglobp
operator|=
name|globp
expr_stmt|;
name|globp
operator|=
name|genbuf
operator|+
literal|1
expr_stmt|;
name|d
operator|=
name|peekc
expr_stmt|;
name|ungetchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|CATCH
name|fixech
parameter_list|()
function_decl|;
name|unix0
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ONERR
name|splitw
init|=
literal|0
decl_stmt|;
name|ungetchar
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|vrepaint
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|globp
operator|=
name|oglobp
expr_stmt|;
return|return;
name|ENDCATCH
name|ungetchar
parameter_list|(
name|d
parameter_list|)
function_decl|;
name|globp
operator|=
name|oglobp
expr_stmt|;
name|addr
operator|=
name|dot
expr_stmt|;
name|CATCH
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|vremote
argument_list|(
name|cnt
argument_list|,
name|filter
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ONERR
name|vdirty
argument_list|(
literal|0
argument_list|,
name|LINES
argument_list|)
decl_stmt|;
name|ENDCATCH
if|if
condition|(
name|dot
operator|==
name|zero
operator|&&
name|dol
operator|>
name|zero
condition|)
name|dot
operator|=
name|one
expr_stmt|;
name|splitw
operator|=
literal|0
expr_stmt|;
name|notenam
operator|=
literal|""
expr_stmt|;
comment|/* 	 * BUG: we shouldn't be depending on what undap2 and undap1 are, 	 * since we may be inside a macro.  What's really wanted is the 	 * number of lines we read from the filter.  However, the mistake 	 * will be an overestimate so it only results in extra work, 	 * it shouldn't cause any real screwups. 	 */
name|vreplace
argument_list|(
name|vcline
argument_list|,
name|cnt
argument_list|,
name|undap2
operator|-
name|undap1
argument_list|)
expr_stmt|;
name|dot
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|dot
operator|>
name|dol
condition|)
block|{
name|dot
operator|--
expr_stmt|;
name|vcline
operator|--
expr_stmt|;
block|}
name|vrepaint
argument_list|(
name|NOSTR
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Xdw exchanges dot and wdot if appropriate and also checks  * that wdot is reasonable.  Its name comes from  *	xchange dotand wdot  */
end_comment

begin_macro
name|xdw
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
comment|/* 	register int notp = 0;  */
if|if
condition|(
name|wdot
operator|==
name|NOLINE
operator|||
name|wdot
operator|<
name|one
operator|||
name|wdot
operator|>
name|dol
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|vsave
argument_list|()
expr_stmt|;
name|setLAST
argument_list|()
expr_stmt|;
if|if
condition|(
name|dot
operator|>
name|wdot
condition|)
block|{
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
name|vcline
operator|-=
name|dot
operator|-
name|wdot
expr_stmt|;
name|addr
operator|=
name|dot
expr_stmt|;
name|dot
operator|=
name|wdot
expr_stmt|;
name|wdot
operator|=
name|addr
expr_stmt|;
name|cp
operator|=
name|cursor
expr_stmt|;
name|cursor
operator|=
name|wcursor
expr_stmt|;
name|wcursor
operator|=
name|cp
expr_stmt|;
block|}
comment|/* 	 * If a region is specified but wcursor is at the begining 	 * of the last line, then we move it to be the end of the 	 * previous line (actually off the end). 	 */
if|if
condition|(
name|cursor
operator|&&
name|wcursor
operator|==
name|linebuf
operator|&&
name|wdot
operator|>
name|dot
condition|)
block|{
name|wdot
operator|--
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
if|if
condition|(
name|vpastwh
argument_list|(
name|linebuf
argument_list|)
operator|>=
name|cursor
condition|)
name|wcursor
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|getline
argument_list|(
operator|*
name|wdot
argument_list|)
expr_stmt|;
name|wcursor
operator|=
name|strend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * Should prepare in caller for possible dot == wdot. 		 */
block|}
name|cnt
operator|=
name|wdot
operator|-
name|dot
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|vreg
condition|)
block|{
name|vremote
argument_list|(
name|cnt
argument_list|,
name|YANKreg
argument_list|,
name|vreg
argument_list|)
expr_stmt|;
comment|/* 		if (notp) 			notpart(vreg);  */
block|}
comment|/* 	 * Kill buffer code.  If delete operator is c or d, then save 	 * the region in numbered buffers. 	 * 	 * BUG:			This may be somewhat inefficient due 	 *			to the way named buffer are implemented, 	 *			necessitating some optimization. 	 */
name|vreg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|any
argument_list|(
name|op
argument_list|,
literal|"cd"
argument_list|)
condition|)
block|{
name|vremote
argument_list|(
name|cnt
argument_list|,
name|YANKreg
argument_list|,
literal|'1'
argument_list|)
expr_stmt|;
comment|/* 		if (notp) 			notpart('1');  */
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Routine for vremote to call to implement shifts.  */
end_comment

begin_macro
name|vshift
argument_list|()
end_macro

begin_block
block|{
name|shift
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Replace a single character with the next input character.  * A funny kind of insert.  */
end_comment

begin_expr_stmt
name|vrep
argument_list|(
name|cnt
argument_list|)
specifier|register
name|int
name|cnt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|cnt
operator|>
name|strlen
argument_list|(
name|cursor
argument_list|)
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|column
argument_list|(
name|cursor
operator|+
name|cnt
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vcursat
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|doomed
operator|=
name|i
operator|-
name|cindent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|vglobp
condition|)
block|{
name|c
operator|=
name|getesc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|vfixcurs
argument_list|()
expr_stmt|;
return|return;
block|}
name|ungetkey
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|(
name|vutmp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
name|vundkind
operator|=
name|VCHNG
expr_stmt|;
name|wcursor
operator|=
name|cursor
operator|+
name|cnt
expr_stmt|;
name|vUD1
operator|=
name|cursor
expr_stmt|;
name|vUD2
operator|=
name|wcursor
expr_stmt|;
name|CP
argument_list|(
name|cursor
argument_list|,
name|wcursor
argument_list|)
expr_stmt|;
name|prepapp
argument_list|()
expr_stmt|;
name|vappend
argument_list|(
literal|'r'
argument_list|,
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|lastcp
operator|++
operator|=
name|INS
index|[
literal|0
index|]
expr_stmt|;
name|setLAST
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Yank.  *  * Yanking to string registers occurs for free (essentially)  * in the routine xdw().  */
end_comment

begin_macro
name|vyankit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
if|if
condition|(
name|wdot
condition|)
block|{
if|if
condition|(
operator|(
name|cnt
operator|=
name|xdw
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return;
name|vremote
argument_list|(
name|cnt
argument_list|,
name|yank
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setpk
argument_list|()
expr_stmt|;
name|notenam
operator|=
literal|"yank"
expr_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
name|vundkind
operator|=
name|VNONE
expr_stmt|;
name|DEL
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|wdot
operator|=
name|NOLINE
expr_stmt|;
if|if
condition|(
name|notecnt
operator|<=
name|vcnt
operator|-
name|vcline
operator|&&
name|notecnt
operator|<
name|value
argument_list|(
name|REPORT
argument_list|)
condition|)
name|notecnt
operator|=
literal|0
expr_stmt|;
name|vrepaint
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
return|return;
block|}
name|takeout
argument_list|(
name|DEL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set pkill variables so a put can  * know how to put back partial text.  * This is necessary because undo needs the complete  * line images to be saved, while a put wants to trim  * the first and last lines.  The compromise  * is for put to be more clever.  */
end_comment

begin_macro
name|setpk
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|wcursor
condition|)
block|{
name|pkill
index|[
literal|0
index|]
operator|=
name|cursor
expr_stmt|;
name|pkill
index|[
literal|1
index|]
operator|=
name|wcursor
expr_stmt|;
block|}
block|}
end_block

end_unit

