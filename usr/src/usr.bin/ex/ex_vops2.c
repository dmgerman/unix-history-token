begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ex_vops2.c	8.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Low level routines for operations sequences,  * and mostly, insert mode (and a subroutine  * to read an input line, including in the echo area.)  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|vUA1
decl_stmt|,
modifier|*
name|vUA2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mjm: extern; also in ex_vops.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|vUD1
decl_stmt|,
modifier|*
name|vUD2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mjm: extern; also in ex_vops.c */
end_comment

begin_comment
comment|/*  * Obleeperate characters in hardcopy  * open with \'s.  */
end_comment

begin_expr_stmt
name|bleep
argument_list|(
name|i
argument_list|,
name|cp
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|i
operator|-=
name|column
argument_list|(
name|cp
argument_list|)
expr_stmt|;
do|do
name|ex_putchar
argument_list|(
literal|'\\'
operator||
name|QUOTE
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
do|;
name|rubble
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Common code for middle part of delete  * and change operating on parts of lines.  */
end_comment

begin_macro
name|vdcMID
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|squish
argument_list|()
expr_stmt|;
name|setLAST
argument_list|()
expr_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
name|vundkind
operator|=
name|VCHNG
operator|,
name|CP
argument_list|(
name|vutmp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcursor
operator|<
name|cursor
condition|)
name|cp
operator|=
name|wcursor
operator|,
name|wcursor
operator|=
name|cursor
operator|,
name|cursor
operator|=
name|cp
expr_stmt|;
name|vUD1
operator|=
name|vUA1
operator|=
name|vUA2
operator|=
name|cursor
expr_stmt|;
name|vUD2
operator|=
name|wcursor
expr_stmt|;
return|return
operator|(
name|column
argument_list|(
name|wcursor
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Take text from linebuf and stick it  * in the VBSIZE buffer BUF.  Used to save  * deleted text of part of line.  */
end_comment

begin_macro
name|takeout
argument_list|(
argument|BUF
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|BUF
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|wcursor
operator|<
name|linebuf
condition|)
name|wcursor
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
name|cursor
operator|==
name|wcursor
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wcursor
operator|<
name|cursor
condition|)
block|{
name|cp
operator|=
name|wcursor
expr_stmt|;
name|wcursor
operator|=
name|cursor
expr_stmt|;
name|cursor
operator|=
name|cp
expr_stmt|;
block|}
name|ex_setBUF
argument_list|(
name|BUF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BUF
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|OVERBUF
condition|)
name|beep
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Are we at the end of the printed representation of the  * line?  Used internally in hardcopy open.  */
end_comment

begin_macro
name|ateopr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|vtube
index|[
name|destline
index|]
operator|+
name|destcol
decl_stmt|;
for|for
control|(
name|i
operator|=
name|WCOLS
operator|-
name|destcol
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
operator|(
name|c
operator|&
name|QUOTE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Append.  *  * This routine handles the top level append, doing work  * as each new line comes in, and arranging repeatability.  * It also handles append with repeat counts, and calculation  * of autoindents for new lines.  */
end_comment

begin_decl_stmt
name|bool
name|vaifirst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|gobbled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ogcursor
decl_stmt|;
end_decl_stmt

begin_macro
name|vappend
argument_list|(
argument|ch
argument_list|,
argument|cnt
argument_list|,
argument|indent
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mjm: char --> int */
end_comment

begin_decl_stmt
name|int
name|cnt
decl_stmt|,
name|indent
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|gcursor
decl_stmt|;
name|bool
name|escape
decl_stmt|;
name|int
name|repcnt
decl_stmt|,
name|savedoomed
decl_stmt|;
name|short
name|oldhold
init|=
name|hold
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
name|int
name|oldmask
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Before a move in hardopen when the line is dirty 	 * or we are in the middle of the printed representation, 	 * we retype the line to the left of the cursor so the 	 * insert looks clean. 	 */
if|if
condition|(
name|ch
operator|!=
literal|'o'
operator|&&
name|state
operator|==
name|HARDOPEN
operator|&&
operator|(
name|rubble
operator|||
operator|!
name|ateopr
argument_list|()
operator|)
condition|)
block|{
name|rubble
operator|=
literal|1
expr_stmt|;
name|gcursor
operator|=
name|cursor
expr_stmt|;
name|i
operator|=
operator|*
name|gcursor
expr_stmt|;
operator|*
name|gcursor
operator|=
literal|' '
expr_stmt|;
name|wcursor
operator|=
name|gcursor
expr_stmt|;
name|vmove
argument_list|()
expr_stmt|;
operator|*
name|gcursor
operator|=
name|i
expr_stmt|;
block|}
name|vaifirst
operator|=
name|indent
operator|==
literal|0
expr_stmt|;
comment|/* 	 * Handle replace character by (eventually) 	 * limiting the number of input characters allowed 	 * in the vgetline routine. 	 */
if|if
condition|(
name|ch
operator|==
literal|'r'
condition|)
name|repcnt
operator|=
literal|2
expr_stmt|;
else|else
name|repcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If an autoindent is specified, then 	 * generate a mixture of blanks to tabs to implement 	 * it and place the cursor after the indent. 	 * Text read by the vgetline routine will be placed in genbuf, 	 * so the indent is generated there. 	 */
if|if
condition|(
name|value
argument_list|(
name|AUTOINDENT
argument_list|)
operator|&&
name|indent
operator|!=
literal|0
condition|)
block|{
name|gcursor
operator|=
name|genindent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
operator|*
name|gcursor
operator|=
literal|0
expr_stmt|;
name|vgotoCL
argument_list|(
name|qcolumn
argument_list|(
name|cursor
operator|-
literal|1
argument_list|,
name|genbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcursor
operator|=
name|genbuf
expr_stmt|;
operator|*
name|gcursor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'o'
condition|)
name|vfixcurs
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Prepare for undo.  Pointers delimit inserted portion of line. 	 */
name|vUA1
operator|=
name|vUA2
operator|=
name|cursor
expr_stmt|;
comment|/* 	 * If we are not in a repeated command and a ^@ comes in 	 * then this means the previous inserted text. 	 * If there is none or it was too long to be saved, 	 * then beep() and also arrange to undo any damage done 	 * so far (e.g. if we are a change.) 	 */
if|if
condition|(
operator|(
name|vglobp
operator|&&
operator|*
name|vglobp
operator|==
literal|0
operator|)
operator|||
name|peekbr
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|INS
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|OVERBUF
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|splitw
condition|)
name|ungetkey
argument_list|(
literal|'u'
argument_list|)
expr_stmt|;
name|doomed
operator|=
literal|0
expr_stmt|;
name|hold
operator|=
name|oldhold
expr_stmt|;
return|return;
block|}
comment|/* 		 * Unread input from INS. 		 * An escape will be generated at end of string. 		 * Hold off n^^2 type update on dumb terminals. 		 */
name|vglobp
operator|=
name|INS
expr_stmt|;
name|hold
operator||=
name|HOLDQIK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vglobp
operator|==
literal|0
condition|)
comment|/* 		 * Not a repeated command, get 		 * a new inserted text for repeat. 		 */
name|INS
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * For wrapmargin to hack away second space after a '.' 	 * when the first space caused a line break we keep 	 * track that this happened in gobblebl, which says 	 * to gobble up a blank silently. 	 */
name|gobblebl
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
name|oldmask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGWINCH
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Text gathering loop. 	 * New text goes into genbuf starting at gcursor. 	 * cursor preserves place in linebuf where text will eventually go. 	 */
if|if
condition|(
operator|*
name|cursor
operator|==
literal|0
operator|||
name|state
operator|==
name|CRTOPEN
condition|)
name|hold
operator||=
name|HOLDROL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'r'
operator|&&
name|repcnt
operator|==
literal|0
condition|)
name|escape
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|gcursor
operator|=
name|vgetline
argument_list|(
name|repcnt
argument_list|,
name|gcursor
argument_list|,
operator|&
name|escape
argument_list|,
name|ch
argument_list|)
expr_stmt|;
comment|/* 			 * After an append, stick information 			 * about the ^D's and ^^D's and 0^D's in 			 * the repeated text buffer so repeated 			 * inserts of stuff indented with ^D as backtab's 			 * can work. 			 */
if|if
condition|(
name|HADUP
condition|)
name|addtext
argument_list|(
literal|"^"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HADZERO
condition|)
name|addtext
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
while|while
condition|(
name|CDCNT
operator|>
literal|0
condition|)
name|addtext
argument_list|(
literal|"\204"
argument_list|)
operator|,
name|CDCNT
operator|--
expr_stmt|;
if|if
condition|(
name|gobbled
condition|)
name|addtext
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|addtext
argument_list|(
name|ogcursor
argument_list|)
expr_stmt|;
block|}
name|repcnt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Smash the generated and preexisting indents together 		 * and generate one cleanly made out of tabs and spaces 		 * if we are using autoindent. 		 */
if|if
condition|(
operator|!
name|vaifirst
operator|&&
name|value
argument_list|(
name|AUTOINDENT
argument_list|)
condition|)
block|{
name|i
operator|=
name|fixindent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HADUP
condition|)
name|indent
operator|=
name|i
expr_stmt|;
name|gcursor
operator|=
name|strend
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Limit the repetition count based on maximum 		 * possible line length; do output implied 		 * by further count (> 1) and cons up the new line 		 * in linebuf. 		 */
name|cnt
operator|=
name|vmaxrep
argument_list|(
name|ch
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|gcursor
operator|+
literal|1
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
do|do
block|{
name|CP
argument_list|(
name|cursor
argument_list|,
name|genbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|1
condition|)
block|{
name|int
name|oldhold
init|=
name|hold
decl_stmt|;
name|Outchar
operator|=
name|vinschar
expr_stmt|;
name|hold
operator||=
name|HOLDQIK
expr_stmt|;
name|ex_printf
argument_list|(
literal|"%s"
argument_list|,
name|genbuf
argument_list|)
expr_stmt|;
name|hold
operator|=
name|oldhold
expr_stmt|;
name|Outchar
operator|=
name|vputchar
expr_stmt|;
block|}
name|cursor
operator|+=
name|gcursor
operator|-
name|genbuf
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|cnt
operator|>
literal|0
condition|)
do|;
name|endim
argument_list|()
expr_stmt|;
name|vUA2
operator|=
name|cursor
expr_stmt|;
if|if
condition|(
name|escape
operator|!=
literal|'\n'
condition|)
name|CP
argument_list|(
name|cursor
argument_list|,
name|gcursor
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If doomed characters remain, clobber them, 		 * and reopen the line to get the display exact. 		 */
if|if
condition|(
name|state
operator|!=
name|HARDOPEN
condition|)
block|{
name|DEPTH
argument_list|(
name|vcline
argument_list|)
operator|=
literal|0
expr_stmt|;
name|savedoomed
operator|=
name|doomed
expr_stmt|;
if|if
condition|(
name|doomed
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|cind
init|=
name|cindent
argument_list|()
decl_stmt|;
name|physdc
argument_list|(
name|cind
argument_list|,
name|cind
operator|+
name|doomed
argument_list|)
expr_stmt|;
name|doomed
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|=
name|vreopen
argument_list|(
name|LINE
argument_list|(
name|vcline
argument_list|)
argument_list|,
name|lineDOT
argument_list|()
argument_list|,
name|vcline
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"restoring doomed from %d to %d\n"
argument_list|,
name|doomed
argument_list|,
name|savedoomed
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ch
operator|==
literal|'R'
condition|)
name|doomed
operator|=
name|savedoomed
expr_stmt|;
block|}
comment|/* 		 * All done unless we are continuing on to another line. 		 */
if|if
condition|(
name|escape
operator|!=
literal|'\n'
condition|)
break|break;
comment|/* 		 * Set up for the new line. 		 * First save the current line, then construct a new 		 * first image for the continuation line consisting 		 * of any new autoindent plus the pushed ahead text. 		 */
name|killU
argument_list|()
expr_stmt|;
name|addtext
argument_list|(
name|gobblebl
condition|?
literal|" "
else|:
literal|"\n"
argument_list|)
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|cnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|value
argument_list|(
name|AUTOINDENT
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|LISPCODE
if|if
condition|(
name|value
argument_list|(
name|LISP
argument_list|)
condition|)
name|indent
operator|=
name|lindent
argument_list|(
name|dot
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|HADUP
operator|&&
name|vaifirst
condition|)
name|indent
operator|=
name|whitecnt
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|vaifirst
operator|=
literal|0
expr_stmt|;
name|strcLIN
argument_list|(
name|vpastwh
argument_list|(
name|gcursor
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|gcursor
operator|=
name|genindent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
operator|*
name|gcursor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gcursor
operator|+
name|strlen
argument_list|(
name|linebuf
argument_list|)
operator|>
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
name|gcursor
operator|=
name|genbuf
expr_stmt|;
name|CP
argument_list|(
name|gcursor
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CP
argument_list|(
name|genbuf
argument_list|,
name|gcursor
operator|+
literal|1
argument_list|)
expr_stmt|;
name|gcursor
operator|=
name|genbuf
expr_stmt|;
block|}
comment|/* 		 * If we started out as a single line operation and are now 		 * turning into a multi-line change, then we had better yank 		 * out dot before it changes so that undo will work 		 * correctly later. 		 */
if|if
condition|(
name|FIXUNDO
operator|&&
name|vundkind
operator|==
name|VCHNG
condition|)
block|{
name|vremote
argument_list|(
literal|1
argument_list|,
name|yank
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|undap1
operator|--
expr_stmt|;
block|}
comment|/* 		 * Now do the append of the new line in the buffer, 		 * and update the display.  If slowopen 		 * we don't do very much. 		 */
name|vdoappend
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
name|vundkind
operator|=
name|VMANYINS
expr_stmt|;
name|vcline
operator|++
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
name|vshow
argument_list|(
name|dot
argument_list|,
name|NOLINE
argument_list|)
expr_stmt|;
else|else
block|{
name|i
operator|+=
name|LINE
argument_list|(
name|vcline
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vopen
argument_list|(
name|dot
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
argument_list|(
name|SLOWOPEN
argument_list|)
condition|)
name|vscrap
argument_list|()
expr_stmt|;
else|else
name|vsync1
argument_list|(
name|LINE
argument_list|(
name|vcline
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strcLIN
argument_list|(
name|gcursor
argument_list|)
expr_stmt|;
operator|*
name|gcursor
operator|=
literal|0
expr_stmt|;
name|cursor
operator|=
name|linebuf
expr_stmt|;
name|vgotoCL
argument_list|(
name|qcolumn
argument_list|(
name|cursor
operator|-
literal|1
argument_list|,
name|genbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * All done with insertion, position the cursor 	 * and sync the screen. 	 */
name|hold
operator|=
name|oldhold
expr_stmt|;
if|if
condition|(
name|cursor
operator|>
name|linebuf
condition|)
name|cursor
operator|--
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|HARDOPEN
condition|)
name|vsyncCL
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|cursor
operator|>
name|linebuf
condition|)
name|back1
argument_list|()
expr_stmt|;
name|doomed
operator|=
literal|0
expr_stmt|;
name|wcursor
operator|=
name|cursor
expr_stmt|;
name|vmove
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Subroutine for vgetline to back up a single character position,  * backwards around end of lines (vgoto can't hack columns which are  * less than 0 in general).  */
end_comment

begin_macro
name|back1
argument_list|()
end_macro

begin_block
block|{
name|vgoto
argument_list|(
name|destline
operator|-
literal|1
argument_list|,
name|WCOLS
operator|+
name|destcol
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get a line into genbuf after gcursor.  * Cnt limits the number of input characters  * accepted and is used for handling the replace  * single character command.  Aescaped is the location  * where we stick a termination indicator (whether we  * ended with an ESCAPE or a newline/return.  *  * We do erase-kill type processing here and also  * are careful about the way we do this so that it is  * repeatable.  (I.e. so that your kill doesn't happen,  * when you repeat an insert if it was escaped with \ the  * first time you did it.  commch is the command character  * involved, including the prompt for readline.  */
end_comment

begin_function
name|char
modifier|*
name|vgetline
parameter_list|(
name|cnt
parameter_list|,
name|gcursor
parameter_list|,
name|aescaped
parameter_list|,
name|commch
parameter_list|)
name|int
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
name|gcursor
decl_stmt|;
name|bool
modifier|*
name|aescaped
decl_stmt|;
name|char
name|commch
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|ch
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|iwhite
decl_stmt|,
name|backsl
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|iglobp
decl_stmt|;
name|char
name|cstr
index|[
literal|2
index|]
decl_stmt|;
name|int
function_decl|(
modifier|*
name|OO
function_decl|)
parameter_list|()
init|=
name|Outchar
function_decl|;
comment|/* 	 * Clear the output state and counters 	 * for autoindent backwards motion (counts of ^D, etc.) 	 * Remember how much white space at beginning of line so 	 * as not to allow backspace over autoindent. 	 */
operator|*
name|aescaped
operator|=
literal|0
expr_stmt|;
name|ogcursor
operator|=
name|gcursor
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|CDCNT
operator|=
literal|0
expr_stmt|;
name|HADUP
operator|=
literal|0
expr_stmt|;
name|HADZERO
operator|=
literal|0
expr_stmt|;
name|gobbled
operator|=
literal|0
expr_stmt|;
name|iwhite
operator|=
name|whitecnt
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
name|iglobp
operator|=
name|vglobp
expr_stmt|;
comment|/* 	 * Carefully avoid using vinschar in the echo area. 	 */
if|if
condition|(
name|splitw
condition|)
name|Outchar
operator|=
name|vputchar
expr_stmt|;
else|else
block|{
name|Outchar
operator|=
name|vinschar
expr_stmt|;
name|vprepins
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|backsl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gobblebl
condition|)
name|gobblebl
operator|--
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
block|{
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
goto|goto
name|vadone
goto|;
block|}
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|ATTN
condition|)
name|c
operator|&=
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
expr_stmt|;
name|ch
operator|=
name|c
expr_stmt|;
name|maphopcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vglobp
operator|==
literal|0
operator|&&
name|Peek_key
operator|==
literal|0
operator|&&
name|commch
operator|!=
literal|'r'
condition|)
while|while
condition|(
operator|(
name|ch
operator|=
name|map
argument_list|(
name|c
argument_list|,
name|immacs
argument_list|)
operator|)
operator|!=
name|c
condition|)
block|{
name|c
operator|=
name|ch
expr_stmt|;
if|if
condition|(
operator|!
name|value
argument_list|(
name|REMAP
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|++
name|maphopcnt
operator|>
literal|256
condition|)
name|error
argument_list|(
literal|"Infinite macro loop"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|iglobp
condition|)
block|{
comment|/* 			 * Erase-kill type processing. 			 * Only happens if we were not reading 			 * from untyped input when we started. 			 * Map users erase to ^H, kill to -1 for switch. 			 */
ifndef|#
directive|ifndef
name|USG3TTY
if|if
condition|(
name|c
operator|==
name|tty
operator|.
name|sg_erase
condition|)
name|c
operator|=
name|CTRL
argument_list|(
literal|'h'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|tty
operator|.
name|sg_kill
condition|)
name|c
operator|=
operator|-
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|c
operator|==
name|tty
operator|.
name|c_cc
index|[
name|VERASE
index|]
condition|)
name|c
operator|=
name|CTRL
argument_list|(
literal|'h'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|tty
operator|.
name|c_cc
index|[
name|VKILL
index|]
condition|)
name|c
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* 			 * ^?		Interrupt drops you back to visual 			 *		command mode with an unread interrupt 			 *		still in the input buffer. 			 * 			 * ^\		Quit does the same as interrupt. 			 *		If you are a ex command rather than 			 *		a vi command this will drop you 			 *		back to command mode for sure. 			 */
case|case
name|ATTN
case|:
case|case
name|QUIT
case|:
name|ungetkey
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|vadone
goto|;
comment|/* 			 * ^H		Backs up a character in the input. 			 * 			 * BUG:		Can't back around line boundaries. 			 *		This is hard because stuff has 			 *		already been saved for repeat. 			 */
case|case
name|CTRL
argument_list|(
literal|'h'
argument_list|)
case|:
name|bakchar
label|:
name|cp
operator|=
name|gcursor
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|ogcursor
condition|)
block|{
if|if
condition|(
name|splitw
condition|)
block|{
comment|/* 						 * Backspacing over readecho 						 * prompt. Pretend delete but 						 * don't beep. 						 */
name|ungetkey
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|vadone
goto|;
block|}
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
goto|goto
name|vbackup
goto|;
comment|/* 			 * ^W		Back up a white/non-white word. 			 */
case|case
name|CTRL
argument_list|(
literal|'w'
argument_list|)
case|:
name|wdkind
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|gcursor
init|;
name|cp
operator|>
name|ogcursor
operator|&&
name|isspace
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|;
name|cp
operator|--
control|)
continue|continue;
for|for
control|(
name|c
operator|=
name|wordch
argument_list|(
name|cp
operator|-
literal|1
argument_list|)
init|;
name|cp
operator|>
name|ogcursor
operator|&&
name|wordof
argument_list|(
name|c
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
condition|;
name|cp
operator|--
control|)
continue|continue;
goto|goto
name|vbackup
goto|;
comment|/* 			 * users kill	Kill input on this line, back to 			 *		the autoindent. 			 */
case|case
operator|-
literal|1
case|:
name|cp
operator|=
name|ogcursor
expr_stmt|;
name|vbackup
label|:
if|if
condition|(
name|cp
operator|==
name|gcursor
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|endim
argument_list|()
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|cindent
argument_list|()
expr_stmt|;
name|vgotoCL
argument_list|(
name|qcolumn
argument_list|(
name|cursor
operator|-
literal|1
argument_list|,
name|genbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doomed
operator|>=
literal|0
condition|)
name|doomed
operator|+=
name|c
operator|-
name|cindent
argument_list|()
expr_stmt|;
name|gcursor
operator|=
name|cp
expr_stmt|;
continue|continue;
comment|/* 			 * \		Followed by erase or kill 			 *		maps to just the erase or kill. 			 */
case|case
literal|'\\'
case|:
name|x
operator|=
name|destcol
operator|,
name|y
operator|=
name|destline
expr_stmt|;
name|ex_putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|vcsync
argument_list|()
expr_stmt|;
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|USG3TTY
if|if
condition|(
name|c
operator|==
name|tty
operator|.
name|sg_erase
operator|||
name|c
operator|==
name|tty
operator|.
name|sg_kill
condition|)
else|#
directive|else
if|if
condition|(
name|c
operator|==
name|tty
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|||
name|c
operator|==
name|tty
operator|.
name|c_cc
index|[
name|VKILL
index|]
condition|)
endif|#
directive|endif
block|{
name|vgoto
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|doomed
operator|>=
literal|0
condition|)
name|doomed
operator|++
expr_stmt|;
goto|goto
name|def
goto|;
block|}
name|ungetkey
argument_list|(
name|c
argument_list|)
operator|,
name|c
operator|=
literal|'\\'
expr_stmt|;
name|backsl
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* 			 * ^Q		Super quote following character 			 *		Only ^@ is verboten (trapped at 			 *		a lower level) and \n forces a line 			 *		split so doesn't really go in. 			 * 			 * ^V		Synonym for ^Q 			 */
case|case
name|CTRL
argument_list|(
literal|'q'
argument_list|)
case|:
case|case
name|CTRL
argument_list|(
literal|'v'
argument_list|)
case|:
name|x
operator|=
name|destcol
operator|,
name|y
operator|=
name|destline
expr_stmt|;
name|ex_putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSETC
if|if
condition|(
name|c
operator|==
name|ATTN
condition|)
name|c
operator|=
name|nttyc
operator|.
name|t_intrc
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|!=
name|NL
condition|)
block|{
if|if
condition|(
name|doomed
operator|>=
literal|0
condition|)
name|doomed
operator|++
expr_stmt|;
goto|goto
name|def
goto|;
block|}
break|break;
block|}
block|}
comment|/* 		 * If we get a blank not in the echo area 		 * consider splitting the window in the wrapmargin. 		 */
if|if
condition|(
name|c
operator|!=
name|NL
operator|&&
operator|!
name|splitw
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|gobblebl
condition|)
block|{
name|gobbled
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|value
argument_list|(
name|WRAPMARGIN
argument_list|)
operator|&&
operator|(
name|outcol
operator|>=
name|OCOLUMNS
operator|-
name|value
argument_list|(
name|WRAPMARGIN
argument_list|)
operator|||
name|backsl
operator|&&
name|outcol
operator|==
literal|0
operator|)
operator|&&
name|commch
operator|!=
literal|'r'
condition|)
block|{
comment|/* 				 * At end of word and hit wrapmargin. 				 * Move the word to next line and keep going. 				 */
name|wdkind
operator|=
literal|1
expr_stmt|;
operator|*
name|gcursor
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|backsl
condition|)
operator|*
name|gcursor
operator|++
operator|=
name|getkey
argument_list|()
expr_stmt|;
operator|*
name|gcursor
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Find end of previous word if we are past it. 				 */
for|for
control|(
name|cp
operator|=
name|gcursor
init|;
name|cp
operator|>
name|ogcursor
operator|&&
name|isspace
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|;
name|cp
operator|--
control|)
empty_stmt|;
if|if
condition|(
name|outcol
operator|+
operator|(
name|backsl
condition|?
name|OCOLUMNS
else|:
literal|0
operator|)
operator|-
operator|(
name|gcursor
operator|-
name|cp
operator|)
operator|>=
name|OCOLUMNS
operator|-
name|value
argument_list|(
name|WRAPMARGIN
argument_list|)
condition|)
block|{
comment|/* 					 * Find beginning of previous word. 					 */
for|for
control|(
init|;
name|cp
operator|>
name|ogcursor
operator|&&
operator|!
name|isspace
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|;
name|cp
operator|--
control|)
empty_stmt|;
if|if
condition|(
name|cp
operator|<=
name|ogcursor
condition|)
block|{
comment|/* 						 * There is a single word that 						 * is too long to fit.  Just 						 * let it pass, but beep for 						 * each new letter to warn 						 * the luser. 						 */
name|c
operator|=
operator|*
operator|--
name|gcursor
expr_stmt|;
operator|*
name|gcursor
operator|=
literal|0
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
goto|goto
name|dontbreak
goto|;
block|}
comment|/* 					 * Save it for next line. 					 */
name|macpush
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|--
expr_stmt|;
block|}
name|macpush
argument_list|(
literal|"\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * Erase white space before the word. 				 */
while|while
condition|(
name|cp
operator|>
name|ogcursor
operator|&&
name|isspace
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* skip blank */
name|gobblebl
operator|=
literal|3
expr_stmt|;
goto|goto
name|vbackup
goto|;
block|}
name|dontbreak
label|:
empty_stmt|;
block|}
comment|/* 		 * Word abbreviation mode. 		 */
name|cstr
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|anyabbrs
operator|&&
name|gcursor
operator|>
name|ogcursor
operator|&&
operator|!
name|wordch
argument_list|(
name|cstr
argument_list|)
operator|&&
name|wordch
argument_list|(
name|gcursor
operator|-
literal|1
argument_list|)
condition|)
block|{
name|int
name|wdtype
decl_stmt|,
name|abno
decl_stmt|;
name|cstr
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|wdkind
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|gcursor
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|wdtype
operator|=
name|wordch
argument_list|(
name|cp
operator|-
literal|1
argument_list|)
init|;
name|cp
operator|>
name|ogcursor
operator|&&
name|wordof
argument_list|(
name|wdtype
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
condition|;
name|cp
operator|--
control|)
empty_stmt|;
operator|*
name|gcursor
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|abno
operator|=
literal|0
init|;
name|abbrevs
index|[
name|abno
index|]
operator|.
name|mapto
condition|;
name|abno
operator|++
control|)
block|{
if|if
condition|(
name|eq
argument_list|(
name|cp
argument_list|,
name|abbrevs
index|[
name|abno
index|]
operator|.
name|cap
argument_list|)
condition|)
block|{
name|macpush
argument_list|(
name|cstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macpush
argument_list|(
name|abbrevs
index|[
name|abno
index|]
operator|.
name|mapto
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|vbackup
goto|;
block|}
block|}
block|}
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* 		 * ^M		Except in repeat maps to \n. 		 */
case|case
name|CR
case|:
if|if
condition|(
name|vglobp
condition|)
goto|goto
name|def
goto|;
name|c
operator|=
literal|'\n'
expr_stmt|;
comment|/* presto chango ... */
comment|/* 		 * \n		Start new line. 		 */
case|case
name|NL
case|:
operator|*
name|aescaped
operator|=
name|c
expr_stmt|;
goto|goto
name|vadone
goto|;
comment|/* 		 * escape	End insert unless repeat and more to repeat. 		 */
case|case
name|ESCAPE
case|:
if|if
condition|(
name|lastvgk
condition|)
goto|goto
name|def
goto|;
goto|goto
name|vadone
goto|;
comment|/* 		 * ^D		Backtab. 		 * ^T		Software forward tab. 		 * 		 *		Unless in repeat where this means these 		 *		were superquoted in. 		 */
case|case
name|CTRL
argument_list|(
literal|'d'
argument_list|)
case|:
case|case
name|CTRL
argument_list|(
literal|'t'
argument_list|)
case|:
if|if
condition|(
name|vglobp
condition|)
goto|goto
name|def
goto|;
comment|/* fall into ... */
comment|/* 		 * ^D|QUOTE	Is a backtab (in a repeated command). 		 */
case|case
name|CTRL
argument_list|(
literal|'d'
argument_list|)
operator||
name|QUOTE
case|:
operator|*
name|gcursor
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|vpastwh
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
name|c
operator|=
name|whitecnt
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|CTRL
argument_list|(
literal|'t'
argument_list|)
condition|)
block|{
comment|/* 				 * ^t just generates new indent replacing 				 * current white space rounded up to soft 				 * tab stop increment. 				 */
if|if
condition|(
name|cp
operator|!=
name|gcursor
condition|)
comment|/* 					 * BUG:		Don't hack ^T except 					 *		right after initial 					 *		white space. 					 */
continue|continue;
name|cp
operator|=
name|genindent
argument_list|(
name|iwhite
operator|=
name|backtab
argument_list|(
name|c
operator|+
name|value
argument_list|(
name|SHIFTWIDTH
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ogcursor
operator|=
name|cp
expr_stmt|;
goto|goto
name|vbackup
goto|;
block|}
comment|/* 			 * ^D works only if we are at the (end of) the 			 * generated autoindent.  We count the ^D for repeat 			 * purposes. 			 */
if|if
condition|(
name|c
operator|==
name|iwhite
operator|&&
name|c
operator|!=
literal|0
condition|)
if|if
condition|(
name|cp
operator|==
name|gcursor
condition|)
block|{
name|iwhite
operator|=
name|backtab
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|CDCNT
operator|++
expr_stmt|;
name|ogcursor
operator|=
name|cp
operator|=
name|genindent
argument_list|(
name|iwhite
argument_list|)
expr_stmt|;
goto|goto
name|vbackup
goto|;
block|}
elseif|else
if|if
condition|(
operator|&
name|cp
index|[
literal|1
index|]
operator|==
name|gcursor
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|'^'
operator|||
operator|*
name|cp
operator|==
literal|'0'
operator|)
condition|)
block|{
comment|/* 					 * ^^D moves to margin, then back 					 * to current indent on next line. 					 * 					 * 0^D moves to margin and then 					 * stays there. 					 */
name|HADZERO
operator|=
operator|*
name|cp
operator|==
literal|'0'
expr_stmt|;
name|ogcursor
operator|=
name|cp
operator|=
name|genbuf
expr_stmt|;
name|HADUP
operator|=
literal|1
operator|-
name|HADZERO
expr_stmt|;
name|CDCNT
operator|=
literal|1
expr_stmt|;
name|endim
argument_list|()
expr_stmt|;
name|back1
argument_list|()
expr_stmt|;
name|vputchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
goto|goto
name|vbackup
goto|;
block|}
if|if
condition|(
name|vglobp
operator|&&
name|vglobp
operator|-
name|iglobp
operator|>=
literal|2
operator|&&
operator|(
name|vglobp
index|[
operator|-
literal|2
index|]
operator|==
literal|'^'
operator|||
name|vglobp
index|[
operator|-
literal|2
index|]
operator|==
literal|'0'
operator|)
operator|&&
name|gcursor
operator|==
name|ogcursor
operator|+
literal|1
condition|)
goto|goto
name|bakchar
goto|;
continue|continue;
default|default:
comment|/* 			 * Possibly discard control inputs. 			 */
if|if
condition|(
operator|!
name|vglobp
operator|&&
name|junk
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|def
label|:
if|if
condition|(
operator|!
name|backsl
condition|)
block|{
name|ex_putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|gcursor
operator|>
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
name|error
argument_list|(
literal|"Line too long"
argument_list|)
expr_stmt|;
operator|*
name|gcursor
operator|++
operator|=
name|c
operator|&
name|TRIM
expr_stmt|;
name|vcsync
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
argument_list|(
name|SHOWMATCH
argument_list|)
operator|&&
operator|!
name|iglobp
condition|)
if|if
condition|(
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|'}'
condition|)
name|lsmatch
argument_list|(
name|gcursor
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|vadone
label|:
operator|*
name|gcursor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Outchar
operator|!=
name|termchar
condition|)
name|Outchar
operator|=
name|OO
expr_stmt|;
name|endim
argument_list|()
expr_stmt|;
return|return
operator|(
name|gcursor
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
name|vgetsplit
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|vsplitpt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Append the line in buffer at lp  * to the buffer after dot.  */
end_comment

begin_macro
name|vdoappend
argument_list|(
argument|lp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|oing
init|=
name|inglobal
decl_stmt|;
name|vsplitpt
operator|=
name|lp
expr_stmt|;
name|inglobal
operator|=
literal|1
expr_stmt|;
name|ignore
argument_list|(
name|append
argument_list|(
name|vgetsplit
argument_list|,
name|dot
argument_list|)
argument_list|)
expr_stmt|;
name|inglobal
operator|=
name|oing
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Subroutine for vdoappend to pass to append.  */
end_comment

begin_macro
name|vgetsplit
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|vsplitpt
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|strcLIN
argument_list|(
name|vsplitpt
argument_list|)
expr_stmt|;
name|vsplitpt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Vmaxrep determines the maximum repetitition factor  * allowed that will yield total line length less than  * LBSIZE characters and also does hacks for the R command.  */
end_comment

begin_macro
name|vmaxrep
argument_list|(
argument|ch
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|,
name|replen
decl_stmt|;
if|if
condition|(
name|cnt
operator|>
name|LBSIZE
operator|-
literal|2
condition|)
name|cnt
operator|=
name|LBSIZE
operator|-
literal|2
expr_stmt|;
name|replen
operator|=
name|strlen
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'R'
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|replen
operator|<
name|len
condition|)
name|len
operator|=
name|replen
expr_stmt|;
name|CP
argument_list|(
name|cursor
argument_list|,
name|cursor
operator|+
name|len
argument_list|)
expr_stmt|;
name|vUD2
operator|+=
name|len
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|cnt
operator|*
name|replen
operator|<=
name|LBSIZE
operator|-
literal|2
condition|)
return|return
operator|(
name|cnt
operator|)
return|;
name|cnt
operator|=
operator|(
name|LBSIZE
operator|-
literal|2
operator|-
name|len
operator|)
operator|/
name|replen
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|vsave
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Line too long"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_block

end_unit

