begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1981 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ex_subr.c	7.7	%G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_re.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Random routines, in alphabetical order.  */
end_comment

begin_macro
name|any
argument_list|(
argument|c
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
while|while
condition|(
name|x
operator|=
operator|*
name|s
operator|++
condition|)
if|if
condition|(
name|x
operator|==
name|c
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|backtab
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|j
operator|=
name|i
operator|%
name|value
argument_list|(
name|SHIFTWIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|j
operator|=
name|value
argument_list|(
name|SHIFTWIDTH
argument_list|)
expr_stmt|;
name|i
operator|-=
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|change
argument_list|()
end_macro

begin_block
block|{
name|tchng
operator|++
expr_stmt|;
name|chng
operator|=
name|tchng
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Column returns the number of  * columns occupied by printing the  * characters through position cp of the  * current line.  */
end_comment

begin_expr_stmt
name|column
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|cp
operator|=
operator|&
name|linebuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
expr_stmt|;
return|return
operator|(
name|qcolumn
argument_list|(
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Ignore a comment to the end of the line.  * This routine eats the trailing newline so don't call newline().  */
end_comment

begin_macro
name|comment
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|Copy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
specifier|register
name|char
operator|*
name|from
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|size
operator|>
literal|0
condition|)
do|do
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|size
operator|>
literal|0
condition|)
do|;
block|}
end_block

begin_expr_stmt
name|copyw
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
specifier|register
name|line
operator|*
name|from
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|size
operator|>
literal|0
condition|)
do|do
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|size
operator|>
literal|0
condition|)
do|;
block|}
end_block

begin_expr_stmt
name|copywR
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
specifier|register
name|line
operator|*
name|from
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|--
name|size
operator|>=
literal|0
condition|)
name|to
index|[
name|size
index|]
operator|=
name|from
index|[
name|size
index|]
expr_stmt|;
block|}
end_block

begin_macro
name|ctlof
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|c
operator|==
name|TRIM
condition|?
literal|'?'
else|:
name|c
operator||
operator|(
literal|'A'
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|dingdong
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|VB
condition|)
name|putpad
argument_list|(
name|VB
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
argument_list|(
name|ERRORBELLS
argument_list|)
condition|)
name|putch
argument_list|(
literal|'\207'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fixindent
argument_list|(
argument|indent
argument_list|)
end_macro

begin_decl_stmt
name|int
name|indent
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|i
operator|=
name|whitecnt
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|vpastwh
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
operator|&&
name|i
operator|==
name|indent
operator|&&
name|linebuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|genbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|CP
argument_list|(
name|genindent
argument_list|(
name|i
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|filioerr
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|oerrno
init|=
name|errno
decl_stmt|;
name|lprintf
argument_list|(
literal|"\"%s\""
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
name|syserror
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|genindent
parameter_list|(
name|indent
parameter_list|)
specifier|register
name|int
name|indent
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|genbuf
init|;
name|indent
operator|>=
name|value
argument_list|(
name|TABSTOP
argument_list|)
condition|;
name|indent
operator|-=
name|value
argument_list|(
name|TABSTOP
argument_list|)
control|)
operator|*
name|cp
operator|++
operator|=
literal|'\t'
expr_stmt|;
for|for
control|(
init|;
name|indent
operator|>
literal|0
condition|;
name|indent
operator|--
control|)
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_macro
name|getDOT
argument_list|()
end_macro

begin_block
block|{
name|getline
argument_list|(
operator|*
name|dot
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|line
modifier|*
name|getmark
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
for|for
control|(
name|addr
operator|=
name|one
init|;
name|addr
operator|<=
name|dol
condition|;
name|addr
operator|++
control|)
if|if
condition|(
name|names
index|[
name|c
operator|-
literal|'a'
index|]
operator|==
operator|(
operator|*
name|addr
operator|&
operator|~
literal|01
operator|)
condition|)
block|{
return|return
operator|(
name|addr
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|getn
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|i
operator|=
name|i
operator|*
literal|10
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|ignnEOF
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
init|=
name|getchar
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|comment
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|iswhite
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|junk
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|&&
operator|!
name|value
argument_list|(
name|BEAUTIFY
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|!=
name|TRIM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\f'
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|killed
argument_list|()
end_macro

begin_block
block|{
name|killcnt
argument_list|(
name|addr2
operator|-
name|addr1
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|killcnt
argument_list|(
name|cnt
argument_list|)
specifier|register
name|int
name|cnt
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|inopen
condition|)
block|{
name|notecnt
operator|=
name|cnt
expr_stmt|;
name|notenam
operator|=
name|notesgn
operator|=
literal|""
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|notable
argument_list|(
name|cnt
argument_list|)
condition|)
return|return;
name|printf
argument_list|(
literal|"%d lines"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
argument_list|(
name|TERSE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" %c%s"
argument_list|,
name|Command
index|[
literal|0
index|]
operator||
literal|' '
argument_list|,
name|Command
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Command
index|[
name|strlen
argument_list|(
name|Command
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'e'
condition|)
name|putchar
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
block|}
name|putNFL
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|lineno
argument_list|(
name|a
argument_list|)
name|line
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|a
operator|-
name|zero
operator|)
return|;
block|}
end_block

begin_macro
name|lineDOL
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|lineno
argument_list|(
name|dol
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|lineDOT
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|lineno
argument_list|(
name|dot
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|markDOT
argument_list|()
end_macro

begin_block
block|{
name|markpr
argument_list|(
name|dot
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|markpr
argument_list|(
name|which
argument_list|)
name|line
operator|*
name|which
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|inglobal
operator|==
literal|0
operator|||
name|inopen
operator|)
operator|&&
name|which
operator|<=
name|endcore
condition|)
block|{
name|names
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
index|]
operator|=
operator|*
name|which
operator|&
operator|~
literal|01
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
name|ncols
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
index|]
operator|=
name|cursor
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|markreg
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'`'
condition|)
return|return
operator|(
literal|'z'
operator|+
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
return|return
operator|(
name|c
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Mesg decodes the terse/verbose strings. Thus  *	'xxx@yyy' -> 'xxx' if terse, else 'xxx yyy'  *	'xxx|yyy' -> 'xxx' if terse, else 'yyy'  * All others map to themselves.  */
end_comment

begin_function
name|char
modifier|*
name|mesg
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|str
operator|=
name|strcpy
argument_list|(
name|genbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|str
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'@'
case|:
if|if
condition|(
name|value
argument_list|(
name|TERSE
argument_list|)
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|value
argument_list|(
name|TERSE
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|cp
operator|+
literal|1
operator|)
return|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*VARARGS2*/
end_comment

begin_macro
name|merror
argument_list|(
argument|seekpt
argument_list|,
argument|i
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|VMUNIX
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|seekpt
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|seekpt
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|seekpt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|linebuf
decl_stmt|;
if|if
condition|(
name|seekpt
operator|==
literal|0
condition|)
return|return;
name|merror1
argument_list|(
name|seekpt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|putnl
argument_list|()
operator|,
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|inopen
operator|>
literal|0
operator|&&
name|CE
condition|)
name|vclreol
argument_list|()
expr_stmt|;
if|if
condition|(
name|SO
operator|&&
name|SE
condition|)
name|putpad
argument_list|(
name|SO
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|mesg
argument_list|(
name|cp
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SO
operator|&&
name|SE
condition|)
name|putpad
argument_list|(
name|SE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|merror1
argument_list|(
argument|seekpt
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|VMUNIX
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|seekpt
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|seekpt
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|seekpt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
ifdef|#
directive|ifdef
name|VMUNIX
name|strcpy
argument_list|(
name|linebuf
argument_list|,
name|seekpt
argument_list|)
expr_stmt|;
else|#
directive|else
name|lseek
argument_list|(
name|erfile
argument_list|,
operator|(
name|long
operator|)
name|seekpt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|erfile
argument_list|,
name|linebuf
argument_list|,
literal|128
argument_list|)
operator|<
literal|2
condition|)
name|CP
argument_list|(
name|linebuf
argument_list|,
literal|"ERROR"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|morelines
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|sbrk
argument_list|(
literal|1024
operator|*
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|endcore
operator|+=
literal|1024
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|nonzero
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|addr1
operator|==
name|zero
condition|)
block|{
name|notempty
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Nonzero address required@on this command"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|notable
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|hush
operator|==
literal|0
operator|&&
operator|!
name|inglobal
operator|&&
name|i
operator|>
name|value
argument_list|(
name|REPORT
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|notempty
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|dol
operator|==
name|zero
condition|)
name|error
argument_list|(
literal|"No lines@in the buffer"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|netchHAD
argument_list|(
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|netchange
argument_list|(
name|lineDOL
argument_list|()
operator|-
name|cnt
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|netchange
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|notesgn
operator|=
name|cp
operator|=
literal|"more "
expr_stmt|;
else|else
name|notesgn
operator|=
name|cp
operator|=
literal|"fewer "
operator|,
name|i
operator|=
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
block|{
name|notecnt
operator|=
name|i
expr_stmt|;
name|notenam
operator|=
literal|""
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|notable
argument_list|(
name|i
argument_list|)
condition|)
return|return;
name|printf
argument_list|(
name|mesg
argument_list|(
literal|"%d %slines@in file after %s"
argument_list|)
argument_list|,
name|i
argument_list|,
name|cp
argument_list|,
name|Command
argument_list|)
expr_stmt|;
name|putNFL
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|putmark
argument_list|(
name|addr
argument_list|)
name|line
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|putmk1
argument_list|(
name|addr
argument_list|,
name|putline
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|putmk1
argument_list|(
name|addr
argument_list|,
name|n
argument_list|)
specifier|register
name|line
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|markp
decl_stmt|;
specifier|register
name|oldglobmk
expr_stmt|;
name|oldglobmk
operator|=
operator|*
name|addr
operator|&
literal|1
expr_stmt|;
operator|*
name|addr
operator|&=
operator|~
literal|1
expr_stmt|;
for|for
control|(
name|markp
operator|=
operator|(
name|anymarks
condition|?
name|names
else|:
operator|&
name|names
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
index|]
operator|)
init|;
name|markp
operator|<=
operator|&
name|names
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
index|]
condition|;
name|markp
operator|++
control|)
if|if
condition|(
operator|*
name|markp
operator|==
operator|*
name|addr
condition|)
operator|*
name|markp
operator|=
name|n
expr_stmt|;
operator|*
name|addr
operator|=
name|n
operator||
name|oldglobmk
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|plural
parameter_list|(
name|i
parameter_list|)
name|long
name|i
decl_stmt|;
block|{
return|return
operator|(
name|i
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
name|qcount
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|short
name|vcntcol
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|qcolumn
argument_list|(
name|lim
argument_list|,
name|gp
argument_list|)
specifier|register
name|char
operator|*
name|lim
operator|,
operator|*
name|gp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
function_decl|(
modifier|*
name|OO
function_decl|)
parameter_list|()
function_decl|;
name|OO
operator|=
name|Outchar
expr_stmt|;
name|Outchar
operator|=
name|qcount
expr_stmt|;
name|vcntcol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lim
operator|!=
name|NULL
condition|)
name|x
operator|=
name|lim
index|[
literal|1
index|]
operator|,
name|lim
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|!=
name|NULL
condition|)
name|lim
index|[
literal|1
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|gp
condition|)
while|while
condition|(
operator|*
name|gp
condition|)
name|putchar
argument_list|(
operator|*
name|gp
operator|++
argument_list|)
expr_stmt|;
name|Outchar
operator|=
name|OO
expr_stmt|;
return|return
operator|(
name|vcntcol
operator|)
return|;
block|}
end_block

begin_function
name|int
name|qcount
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|vcntcol
operator|+=
name|value
argument_list|(
name|TABSTOP
argument_list|)
operator|-
name|vcntcol
operator|%
name|value
argument_list|(
name|TABSTOP
argument_list|)
expr_stmt|;
return|return;
block|}
name|vcntcol
operator|++
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|reverse
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
specifier|register
name|line
operator|*
name|a1
operator|,
operator|*
name|a2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|line
name|t
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|t
operator|=
operator|*
operator|--
name|a2
expr_stmt|;
if|if
condition|(
name|a2
operator|<=
name|a1
condition|)
return|return;
operator|*
name|a2
operator|=
operator|*
name|a1
expr_stmt|;
operator|*
name|a1
operator|++
operator|=
name|t
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|save
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
name|line
operator|*
name|a1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|line
modifier|*
name|a2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|more
decl_stmt|;
if|if
condition|(
operator|!
name|FIXUNDO
condition|)
return|return;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|vudump
argument_list|(
literal|"before save"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|undkind
operator|=
name|UNDNONE
expr_stmt|;
name|undadot
operator|=
name|dot
expr_stmt|;
name|more
operator|=
operator|(
name|a2
operator|-
name|a1
operator|+
literal|1
operator|)
operator|-
operator|(
name|unddol
operator|-
name|dol
operator|)
expr_stmt|;
while|while
condition|(
name|more
operator|>
operator|(
name|endcore
operator|-
name|truedol
operator|)
condition|)
if|if
condition|(
name|morelines
argument_list|()
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Out of memory@saving lines for undo - try using ed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
operator|(
operator|*
operator|(
name|more
operator|>
literal|0
condition|?
name|copywR
else|:
name|copyw
operator|)
operator|)
operator|(
name|unddol
operator|+
name|more
operator|+
literal|1
operator|,
name|unddol
operator|+
literal|1
operator|,
operator|(
name|truedol
operator|-
name|unddol
operator|)
operator|)
expr_stmt|;
name|unddol
operator|+=
name|more
expr_stmt|;
name|truedol
operator|+=
name|more
expr_stmt|;
name|copyw
argument_list|(
name|dol
operator|+
literal|1
argument_list|,
name|a1
argument_list|,
name|a2
operator|-
name|a1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|undkind
operator|=
name|UNDALL
expr_stmt|;
name|unddel
operator|=
name|a1
operator|-
literal|1
expr_stmt|;
name|undap1
operator|=
name|a1
expr_stmt|;
name|undap2
operator|=
name|a2
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|vudump
argument_list|(
literal|"after save"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|save12
argument_list|()
end_macro

begin_block
block|{
name|save
argument_list|(
name|addr1
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|saveall
argument_list|()
end_macro

begin_block
block|{
name|save
argument_list|(
name|one
argument_list|,
name|dol
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|span
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|addr2
operator|-
name|addr1
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|sync
argument_list|()
end_macro

begin_block
block|{
name|chng
operator|=
literal|0
expr_stmt|;
name|tchng
operator|=
literal|0
expr_stmt|;
name|xchng
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|skipwh
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|wh
decl_stmt|;
name|wh
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|iswhite
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|)
block|{
name|wh
operator|++
expr_stmt|;
name|ignchar
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|wh
operator|)
return|;
block|}
end_block

begin_comment
comment|/*VARARGS2*/
end_comment

begin_macro
name|smerror
argument_list|(
argument|seekpt
argument_list|,
argument|cp
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|seekpt
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|seekpt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|seekpt
operator|==
literal|0
condition|)
return|return;
name|merror1
argument_list|(
name|seekpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
operator|&&
name|CE
condition|)
name|vclreol
argument_list|()
expr_stmt|;
if|if
condition|(
name|SO
operator|&&
name|SE
condition|)
name|putpad
argument_list|(
name|SO
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
name|mesg
argument_list|(
name|linebuf
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SO
operator|&&
name|SE
condition|)
name|putpad
argument_list|(
name|SE
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|strend
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_macro
name|strcLIN
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CP
argument_list|(
name|linebuf
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|syserror
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|e
init|=
name|errno
decl_stmt|;
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|dirtcnt
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|>=
literal|0
operator|&&
name|e
operator|<=
name|sys_nerr
condition|)
name|error
argument_list|(
name|sys_errlist
index|[
name|e
index|]
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"System error %d"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return the column number that results from being in column col and  * hitting a tab, where tabs are set every ts columns.  Work right for  * the case where col> COLUMNS, even if ts does not divide COLUMNS.  */
end_comment

begin_macro
name|tabcol
argument_list|(
argument|col
argument_list|,
argument|ts
argument_list|)
end_macro

begin_decl_stmt
name|int
name|col
decl_stmt|,
name|ts
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|offset
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|col
operator|>=
name|COLUMNS
condition|)
block|{
name|offset
operator|=
name|COLUMNS
operator|*
operator|(
name|col
operator|/
name|COLUMNS
operator|)
expr_stmt|;
name|col
operator|-=
name|offset
expr_stmt|;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|col
operator|+
name|ts
operator|-
operator|(
name|col
operator|%
name|ts
operator|)
operator|+
name|offset
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|vfindcol
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
function_decl|(
modifier|*
name|OO
function_decl|)
parameter_list|()
init|=
name|Outchar
function_decl|;
name|Outchar
operator|=
name|qcount
expr_stmt|;
name|ignore
argument_list|(
name|qcolumn
argument_list|(
name|linebuf
operator|-
literal|1
argument_list|,
name|NOSTR
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|linebuf
init|;
operator|*
name|cp
operator|&&
name|vcntcol
operator|<
name|i
condition|;
name|cp
operator|++
control|)
name|putchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|linebuf
condition|)
name|cp
operator|--
expr_stmt|;
name|Outchar
operator|=
name|OO
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|vskipwh
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
while|while
condition|(
name|iswhite
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
name|cp
index|[
literal|1
index|]
condition|)
name|cp
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|vpastwh
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
while|while
condition|(
name|iswhite
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|whitecnt
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'\t'
case|:
name|i
operator|+=
name|value
argument_list|(
name|TABSTOP
argument_list|)
operator|-
name|i
operator|%
name|value
argument_list|(
name|TABSTOP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|i
operator|++
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_macro
name|Ignore
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|a
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_function_decl
name|Ignorf
function_decl|(
name|a
function_decl|)
name|int
argument_list|(
argument|*a
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|a
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|markit
argument_list|(
name|addr
argument_list|)
name|line
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|addr
operator|!=
name|dot
operator|&&
name|addr
operator|>=
name|one
operator|&&
name|addr
operator|<=
name|dol
condition|)
name|markDOT
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The following code is defensive programming against a bug in the  * pdp-11 overlay implementation.  Sometimes it goes nuts and asks  * for an overlay with some garbage number, which generates an emt  * trap.  This is a less than elegant solution, but it is somewhat  * better than core dumping and losing your work, leaving your tty  * in a weird state, etc.  */
end_comment

begin_decl_stmt
name|int
name|_ovno
decl_stmt|;
end_decl_stmt

begin_macro
name|onemt
argument_list|()
end_macro

begin_block
block|{
name|int
name|oovno
decl_stmt|;
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|onemt
argument_list|)
expr_stmt|;
name|oovno
operator|=
name|_ovno
expr_stmt|;
comment|/* 2 and 3 are valid on 11/40 type vi, so */
if|if
condition|(
name|_ovno
operator|<
literal|0
operator|||
name|_ovno
operator|>
literal|3
condition|)
name|_ovno
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"emt trap, _ovno is %d @ - try again"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * When a hangup occurs our actions are similar to a preserve  * command.  If the buffer has not been [Modified], then we do  * nothing but remove the temporary files and exit.  * Otherwise, we sync the temp file and then attempt a preserve.  * If the preserve succeeds, we unlink our temp files.  * If the preserve fails, we leave the temp files as they are  * as they are a backup even without preservation if they  * are not removed.  */
end_comment

begin_macro
name|onhup
argument_list|()
end_macro

begin_block
block|{
comment|/* 	 * USG tty driver can send multiple HUP's!! 	 */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|chng
operator|==
literal|0
condition|)
block|{
name|cleanup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setexit
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|preserve
argument_list|()
condition|)
block|{
name|cleanup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * An interrupt occurred.  Drain any output which  * is still in the output buffering pipeline.  * Catch interrupts again.  Unless we are in visual  * reset the output state (out of -nl mode, e.g).  * Then like a normal error (with the \n before Interrupt  * suppressed in visual mode).  */
end_comment

begin_macro
name|onintr
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|CBREAK
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|inopen
condition|?
name|vintr
else|:
name|onintr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* in case we were called from map */
name|draino
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|inopen
condition|)
block|{
name|pstop
argument_list|()
expr_stmt|;
name|setlastchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CBREAK
block|}
else|#
directive|else
block|}
end_block

begin_else
else|else
name|vraw
argument_list|()
expr_stmt|;
end_else

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|error
argument_list|(
literal|"\nInterrupt"
operator|+
name|inopen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * If we are interruptible, enable interrupts again.  * In some critical sections we turn interrupts off,  * but not very often.  */
end_comment

begin_expr_stmt
unit|setrupt
operator|(
operator|)
block|{
if|if
condition|(
name|ruptible
condition|)
block|{
ifndef|#
directive|ifndef
name|CBREAK
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|inopen
condition|?
name|vintr
else|:
name|onintr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTSTP
if|if
condition|(
name|dosusp
condition|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|onsusp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_expr_stmt

begin_expr_stmt
unit|}  preserve
operator|(
operator|)
block|{
ifdef|#
directive|ifdef
name|VMUNIX
name|tflush
argument_list|()
block|;
endif|#
directive|endif
name|synctmp
argument_list|()
block|;
name|pid
operator|=
name|fork
argument_list|()
block|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|EXPRESERVE
argument_list|,
literal|"expreserve"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|waitfor
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|rpid
operator|==
name|pid
operator|&&
name|status
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
end_if

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|V6
end_ifndef

begin_expr_stmt
unit|exit
operator|(
name|i
operator|)
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|fclose
argument_list|(
name|trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_comment
comment|/*  * We have just gotten a susp.  Suspend and prepare to resume.  */
end_comment

begin_macro
name|onsusp
argument_list|()
end_macro

begin_block
block|{
name|ttymode
name|f
decl_stmt|;
name|int
name|omask
decl_stmt|;
name|struct
name|winsize
name|win
decl_stmt|;
name|f
operator|=
name|setty
argument_list|(
name|normf
argument_list|)
expr_stmt|;
name|vnfl
argument_list|()
expr_stmt|;
name|putpad
argument_list|(
name|TE
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* the pc stops here */
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|onsusp
argument_list|)
expr_stmt|;
name|vcontin
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setty
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inopen
condition|)
name|error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|win
argument_list|)
operator|>=
literal|0
condition|)
if|if
condition|(
name|win
operator|.
name|ws_row
operator|!=
name|winsz
operator|.
name|ws_row
operator|||
name|win
operator|.
name|ws_col
operator|!=
name|winsz
operator|.
name|ws_col
condition|)
name|winch
argument_list|()
expr_stmt|;
if|if
condition|(
name|vcnt
operator|<
literal|0
condition|)
block|{
name|vcnt
operator|=
operator|-
name|vcnt
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|VISUAL
condition|)
name|vclear
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|CRTOPEN
condition|)
name|vcnt
operator|=
literal|0
expr_stmt|;
block|}
name|vdirty
argument_list|(
literal|0
argument_list|,
name|LINES
argument_list|)
expr_stmt|;
name|vrepaint
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

