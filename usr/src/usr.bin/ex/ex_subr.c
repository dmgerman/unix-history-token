begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1980 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ex_subr.c	5.1 %G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_re.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Random routines, in alphabetical order.  */
end_comment

begin_macro
name|any
argument_list|(
argument|c
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
while|while
condition|(
name|x
operator|=
operator|*
name|s
operator|++
condition|)
if|if
condition|(
name|x
operator|==
name|c
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|backtab
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|j
operator|=
name|i
operator|%
name|value
argument_list|(
name|SHIFTWIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|j
operator|=
name|value
argument_list|(
name|SHIFTWIDTH
argument_list|)
expr_stmt|;
name|i
operator|-=
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|change
argument_list|()
end_macro

begin_block
block|{
name|tchng
operator|++
expr_stmt|;
name|chng
operator|=
name|tchng
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Column returns the number of  * columns occupied by printing the  * characters through position cp of the  * current line.  */
end_comment

begin_expr_stmt
name|column
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|cp
operator|=
operator|&
name|linebuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
expr_stmt|;
return|return
operator|(
name|qcolumn
argument_list|(
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Ignore a comment to the end of the line.  * This routine eats the trailing newline so don't call newline().  */
end_comment

begin_macro
name|comment
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|Copy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
specifier|register
name|char
operator|*
name|from
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|size
operator|>
literal|0
condition|)
do|do
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|size
operator|>
literal|0
condition|)
do|;
block|}
end_block

begin_expr_stmt
name|copyw
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
specifier|register
name|line
operator|*
name|from
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|size
operator|>
literal|0
condition|)
do|do
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|size
operator|>
literal|0
condition|)
do|;
block|}
end_block

begin_expr_stmt
name|copywR
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
specifier|register
name|line
operator|*
name|from
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|--
name|size
operator|>=
literal|0
condition|)
name|to
index|[
name|size
index|]
operator|=
name|from
index|[
name|size
index|]
expr_stmt|;
block|}
end_block

begin_macro
name|ctlof
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|c
operator|==
name|TRIM
condition|?
literal|'?'
else|:
name|c
operator||
operator|(
literal|'A'
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|dingdong
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|VB
condition|)
name|putpad
argument_list|(
name|VB
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
argument_list|(
name|ERRORBELLS
argument_list|)
condition|)
name|putch
argument_list|(
literal|'\207'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fixindent
argument_list|(
argument|indent
argument_list|)
end_macro

begin_decl_stmt
name|int
name|indent
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|i
operator|=
name|whitecnt
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|vpastwh
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
operator|&&
name|i
operator|==
name|indent
operator|&&
name|linebuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|genbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|CP
argument_list|(
name|genindent
argument_list|(
name|i
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|filioerr
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|oerrno
init|=
name|errno
decl_stmt|;
name|lprintf
argument_list|(
literal|"\"%s\""
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
name|syserror
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|genindent
parameter_list|(
name|indent
parameter_list|)
specifier|register
name|int
name|indent
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|genbuf
init|;
name|indent
operator|>=
name|value
argument_list|(
name|TABSTOP
argument_list|)
condition|;
name|indent
operator|-=
name|value
argument_list|(
name|TABSTOP
argument_list|)
control|)
operator|*
name|cp
operator|++
operator|=
literal|'\t'
expr_stmt|;
for|for
control|(
init|;
name|indent
operator|>
literal|0
condition|;
name|indent
operator|--
control|)
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_macro
name|getDOT
argument_list|()
end_macro

begin_block
block|{
name|getline
argument_list|(
operator|*
name|dot
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|line
modifier|*
name|getmark
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
for|for
control|(
name|addr
operator|=
name|one
init|;
name|addr
operator|<=
name|dol
condition|;
name|addr
operator|++
control|)
if|if
condition|(
name|names
index|[
name|c
operator|-
literal|'a'
index|]
operator|==
operator|(
operator|*
name|addr
operator|&
operator|~
literal|01
operator|)
condition|)
block|{
return|return
operator|(
name|addr
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|getn
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|i
operator|=
name|i
operator|*
literal|10
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|ignnEOF
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
init|=
name|getchar
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|comment
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|iswhite
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|junk
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|&&
operator|!
name|value
argument_list|(
name|BEAUTIFY
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|!=
name|TRIM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\f'
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|killed
argument_list|()
end_macro

begin_block
block|{
name|killcnt
argument_list|(
name|addr2
operator|-
name|addr1
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|killcnt
argument_list|(
name|cnt
argument_list|)
specifier|register
name|int
name|cnt
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|inopen
condition|)
block|{
name|notecnt
operator|=
name|cnt
expr_stmt|;
name|notenam
operator|=
name|notesgn
operator|=
literal|""
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|notable
argument_list|(
name|cnt
argument_list|)
condition|)
return|return;
name|printf
argument_list|(
literal|"%d lines"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
argument_list|(
name|TERSE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" %c%s"
argument_list|,
name|Command
index|[
literal|0
index|]
operator||
literal|' '
argument_list|,
name|Command
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Command
index|[
name|strlen
argument_list|(
name|Command
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'e'
condition|)
name|putchar
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
block|}
name|putNFL
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|lineno
argument_list|(
name|a
argument_list|)
name|line
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|a
operator|-
name|zero
operator|)
return|;
block|}
end_block

begin_macro
name|lineDOL
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|lineno
argument_list|(
name|dol
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|lineDOT
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|lineno
argument_list|(
name|dot
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|markDOT
argument_list|()
end_macro

begin_block
block|{
name|markpr
argument_list|(
name|dot
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|markpr
argument_list|(
name|which
argument_list|)
name|line
operator|*
name|which
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|inglobal
operator|==
literal|0
operator|||
name|inopen
operator|)
operator|&&
name|which
operator|<=
name|endcore
condition|)
block|{
name|names
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
index|]
operator|=
operator|*
name|which
operator|&
operator|~
literal|01
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
name|ncols
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
index|]
operator|=
name|cursor
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|markreg
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'`'
condition|)
return|return
operator|(
literal|'z'
operator|+
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
return|return
operator|(
name|c
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Mesg decodes the terse/verbose strings. Thus  *	'xxx@yyy' -> 'xxx' if terse, else 'xxx yyy'  *	'xxx|yyy' -> 'xxx' if terse, else 'yyy'  * All others map to themselves.  */
end_comment

begin_function
name|char
modifier|*
name|mesg
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|str
operator|=
name|strcpy
argument_list|(
name|genbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|str
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'@'
case|:
if|if
condition|(
name|value
argument_list|(
name|TERSE
argument_list|)
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|value
argument_list|(
name|TERSE
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|cp
operator|+
literal|1
operator|)
return|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*VARARGS2*/
end_comment

begin_macro
name|merror
argument_list|(
argument|seekpt
argument_list|,
argument|i
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|VMUNIX
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|seekpt
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|seekpt
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|seekpt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|linebuf
decl_stmt|;
if|if
condition|(
name|seekpt
operator|==
literal|0
condition|)
return|return;
name|merror1
argument_list|(
name|seekpt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|putnl
argument_list|()
operator|,
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|inopen
operator|&&
name|CE
condition|)
name|vclreol
argument_list|()
expr_stmt|;
if|if
condition|(
name|SO
operator|&&
name|SE
condition|)
name|putpad
argument_list|(
name|SO
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|mesg
argument_list|(
name|cp
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SO
operator|&&
name|SE
condition|)
name|putpad
argument_list|(
name|SE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|merror1
argument_list|(
argument|seekpt
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|VMUNIX
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|seekpt
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|seekpt
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|seekpt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
ifdef|#
directive|ifdef
name|VMUNIX
name|strcpy
argument_list|(
name|linebuf
argument_list|,
name|seekpt
argument_list|)
expr_stmt|;
else|#
directive|else
name|lseek
argument_list|(
name|erfile
argument_list|,
operator|(
name|long
operator|)
name|seekpt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|erfile
argument_list|,
name|linebuf
argument_list|,
literal|128
argument_list|)
operator|<
literal|2
condition|)
name|CP
argument_list|(
name|linebuf
argument_list|,
literal|"ERROR"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|morelines
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|sbrk
argument_list|(
literal|1024
operator|*
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|endcore
operator|+=
literal|1024
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|nonzero
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|addr1
operator|==
name|zero
condition|)
block|{
name|notempty
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Nonzero address required@on this command"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|notable
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|hush
operator|==
literal|0
operator|&&
operator|!
name|inglobal
operator|&&
name|i
operator|>
name|value
argument_list|(
name|REPORT
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|notempty
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|dol
operator|==
name|zero
condition|)
name|error
argument_list|(
literal|"No lines@in the buffer"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|netchHAD
argument_list|(
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|netchange
argument_list|(
name|lineDOL
argument_list|()
operator|-
name|cnt
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|netchange
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|notesgn
operator|=
name|cp
operator|=
literal|"more "
expr_stmt|;
else|else
name|notesgn
operator|=
name|cp
operator|=
literal|"fewer "
operator|,
name|i
operator|=
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
block|{
name|notecnt
operator|=
name|i
expr_stmt|;
name|notenam
operator|=
literal|""
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|notable
argument_list|(
name|i
argument_list|)
condition|)
return|return;
name|printf
argument_list|(
name|mesg
argument_list|(
literal|"%d %slines@in file after %s"
argument_list|)
argument_list|,
name|i
argument_list|,
name|cp
argument_list|,
name|Command
argument_list|)
expr_stmt|;
name|putNFL
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|putmark
argument_list|(
name|addr
argument_list|)
name|line
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|putmk1
argument_list|(
name|addr
argument_list|,
name|putline
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|putmk1
argument_list|(
name|addr
argument_list|,
name|n
argument_list|)
specifier|register
name|line
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|markp
decl_stmt|;
specifier|register
name|oldglobmk
expr_stmt|;
name|oldglobmk
operator|=
operator|*
name|addr
operator|&
literal|1
expr_stmt|;
operator|*
name|addr
operator|&=
operator|~
literal|1
expr_stmt|;
for|for
control|(
name|markp
operator|=
operator|(
name|anymarks
condition|?
name|names
else|:
operator|&
name|names
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
index|]
operator|)
init|;
name|markp
operator|<=
operator|&
name|names
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
index|]
condition|;
name|markp
operator|++
control|)
if|if
condition|(
operator|*
name|markp
operator|==
operator|*
name|addr
condition|)
operator|*
name|markp
operator|=
name|n
expr_stmt|;
operator|*
name|addr
operator|=
name|n
operator||
name|oldglobmk
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|plural
parameter_list|(
name|i
parameter_list|)
name|long
name|i
decl_stmt|;
block|{
return|return
operator|(
name|i
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
name|qcount
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|short
name|vcntcol
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|qcolumn
argument_list|(
name|lim
argument_list|,
name|gp
argument_list|)
specifier|register
name|char
operator|*
name|lim
operator|,
operator|*
name|gp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
function_decl|(
modifier|*
name|OO
function_decl|)
parameter_list|()
function_decl|;
name|OO
operator|=
name|Outchar
expr_stmt|;
name|Outchar
operator|=
name|qcount
expr_stmt|;
name|vcntcol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lim
operator|!=
name|NULL
condition|)
name|x
operator|=
name|lim
index|[
literal|1
index|]
operator|,
name|lim
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|!=
name|NULL
condition|)
name|lim
index|[
literal|1
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|gp
condition|)
while|while
condition|(
operator|*
name|gp
condition|)
name|putchar
argument_list|(
operator|*
name|gp
operator|++
argument_list|)
expr_stmt|;
name|Outchar
operator|=
name|OO
expr_stmt|;
return|return
operator|(
name|vcntcol
operator|)
return|;
block|}
end_block

begin_function
name|int
name|qcount
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|vcntcol
operator|+=
name|value
argument_list|(
name|TABSTOP
argument_list|)
operator|-
name|vcntcol
operator|%
name|value
argument_list|(
name|TABSTOP
argument_list|)
expr_stmt|;
return|return;
block|}
name|vcntcol
operator|++
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|reverse
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
specifier|register
name|line
operator|*
name|a1
operator|,
operator|*
name|a2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|line
name|t
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|t
operator|=
operator|*
operator|--
name|a2
expr_stmt|;
if|if
condition|(
name|a2
operator|<=
name|a1
condition|)
return|return;
operator|*
name|a2
operator|=
operator|*
name|a1
expr_stmt|;
operator|*
name|a1
operator|++
operator|=
name|t
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|save
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
name|line
operator|*
name|a1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|line
modifier|*
name|a2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|more
decl_stmt|;
if|if
condition|(
operator|!
name|FIXUNDO
condition|)
return|return;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|vudump
argument_list|(
literal|"before save"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|undkind
operator|=
name|UNDNONE
expr_stmt|;
name|undadot
operator|=
name|dot
expr_stmt|;
name|more
operator|=
operator|(
name|a2
operator|-
name|a1
operator|+
literal|1
operator|)
operator|-
operator|(
name|unddol
operator|-
name|dol
operator|)
expr_stmt|;
while|while
condition|(
name|more
operator|>
operator|(
name|endcore
operator|-
name|truedol
operator|)
condition|)
if|if
condition|(
name|morelines
argument_list|()
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Out of memory@saving lines for undo - try using ed or re"
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
operator|(
operator|*
operator|(
name|more
operator|>
literal|0
condition|?
name|copywR
else|:
name|copyw
operator|)
operator|)
operator|(
name|unddol
operator|+
name|more
operator|+
literal|1
operator|,
name|unddol
operator|+
literal|1
operator|,
operator|(
name|truedol
operator|-
name|unddol
operator|)
operator|)
expr_stmt|;
name|unddol
operator|+=
name|more
expr_stmt|;
name|truedol
operator|+=
name|more
expr_stmt|;
name|copyw
argument_list|(
name|dol
operator|+
literal|1
argument_list|,
name|a1
argument_list|,
name|a2
operator|-
name|a1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|undkind
operator|=
name|UNDALL
expr_stmt|;
name|unddel
operator|=
name|a1
operator|-
literal|1
expr_stmt|;
name|undap1
operator|=
name|a1
expr_stmt|;
name|undap2
operator|=
name|a2
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|vudump
argument_list|(
literal|"after save"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|save12
argument_list|()
end_macro

begin_block
block|{
name|save
argument_list|(
name|addr1
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|saveall
argument_list|()
end_macro

begin_block
block|{
name|save
argument_list|(
name|one
argument_list|,
name|dol
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|span
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|addr2
operator|-
name|addr1
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|sync
argument_list|()
end_macro

begin_block
block|{
name|chng
operator|=
literal|0
expr_stmt|;
name|tchng
operator|=
literal|0
expr_stmt|;
name|xchng
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|skipwh
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|wh
decl_stmt|;
name|wh
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|iswhite
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|)
block|{
name|wh
operator|++
expr_stmt|;
name|ignchar
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|wh
operator|)
return|;
block|}
end_block

begin_comment
comment|/*VARARGS2*/
end_comment

begin_macro
name|smerror
argument_list|(
argument|seekpt
argument_list|,
argument|cp
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|seekpt
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|seekpt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|seekpt
operator|==
literal|0
condition|)
return|return;
name|merror1
argument_list|(
name|seekpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
operator|&&
name|CE
condition|)
name|vclreol
argument_list|()
expr_stmt|;
if|if
condition|(
name|SO
operator|&&
name|SE
condition|)
name|putpad
argument_list|(
name|SO
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
name|mesg
argument_list|(
name|linebuf
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SO
operator|&&
name|SE
condition|)
name|putpad
argument_list|(
name|SE
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|std_nerrs
value|(sizeof std_errlist / sizeof std_errlist[0])
end_define

begin_define
define|#
directive|define
name|error
parameter_list|(
name|i
parameter_list|)
value|i
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|std_errlist
index|[]
init|=
block|{
else|#
directive|else
ifdef|#
directive|ifdef
name|VMUNIX
name|char
operator|*
name|std_errlist
index|[]
operator|=
block|{
else|#
directive|else
name|short
name|std_errlist
index|[]
operator|=
block|{
endif|#
directive|endif
endif|#
directive|endif
name|error
argument_list|(
literal|"Error 0"
argument_list|)
block|,
name|error
argument_list|(
literal|"Not super-user"
argument_list|)
block|,
name|error
argument_list|(
literal|"No such file or directory"
argument_list|)
block|,
name|error
argument_list|(
literal|"No such process"
argument_list|)
block|,
name|error
argument_list|(
literal|"Interrupted system call"
argument_list|)
block|,
name|error
argument_list|(
literal|"Physical I/O error"
argument_list|)
block|,
name|error
argument_list|(
literal|"No such device or address"
argument_list|)
block|,
name|error
argument_list|(
literal|"Argument list too long"
argument_list|)
block|,
name|error
argument_list|(
literal|"Exec format error"
argument_list|)
block|,
name|error
argument_list|(
literal|"Bad file number"
argument_list|)
block|,
name|error
argument_list|(
literal|"No children"
argument_list|)
block|,
name|error
argument_list|(
literal|"No more processes"
argument_list|)
block|,
name|error
argument_list|(
literal|"Not enough core"
argument_list|)
block|,
name|error
argument_list|(
literal|"Permission denied"
argument_list|)
block|,
name|error
argument_list|(
literal|"Bad address"
argument_list|)
block|,
name|error
argument_list|(
literal|"Block device required"
argument_list|)
block|,
name|error
argument_list|(
literal|"Mount device busy"
argument_list|)
block|,
name|error
argument_list|(
literal|"File exists"
argument_list|)
block|,
name|error
argument_list|(
literal|"Cross-device link"
argument_list|)
block|,
name|error
argument_list|(
literal|"No such device"
argument_list|)
block|,
name|error
argument_list|(
literal|"Not a directory"
argument_list|)
block|,
name|error
argument_list|(
literal|"Is a directory"
argument_list|)
block|,
name|error
argument_list|(
literal|"Invalid argument"
argument_list|)
block|,
name|error
argument_list|(
literal|"File table overflow"
argument_list|)
block|,
name|error
argument_list|(
literal|"Too many open files"
argument_list|)
block|,
name|error
argument_list|(
literal|"Not a typewriter"
argument_list|)
block|,
name|error
argument_list|(
literal|"Text file busy"
argument_list|)
block|,
name|error
argument_list|(
literal|"File too large"
argument_list|)
block|,
name|error
argument_list|(
literal|"No space left on device"
argument_list|)
block|,
name|error
argument_list|(
literal|"Illegal seek"
argument_list|)
block|,
name|error
argument_list|(
literal|"Read-only file system"
argument_list|)
block|,
name|error
argument_list|(
literal|"Too many links"
argument_list|)
block|,
name|error
argument_list|(
literal|"Broken pipe"
argument_list|)
ifndef|#
directive|ifndef
name|QUOTA
block|,
name|error
argument_list|(
literal|"Math argument"
argument_list|)
block|,
name|error
argument_list|(
literal|"Result too large"
argument_list|)
else|#
directive|else
block|,
name|error
argument_list|(
literal|"Quota exceeded"
argument_list|)
endif|#
directive|endif
block|}
block|;
undef|#
directive|undef
name|error
name|char
operator|*
name|strend
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
block|;
block|{
while|while
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
name|strcLIN
argument_list|(
argument|dp
argument_list|)
name|char
operator|*
name|dp
block|;
block|{
name|CP
argument_list|(
name|linebuf
argument_list|,
name|dp
argument_list|)
block|; }
name|syserror
argument_list|()
block|{
specifier|register
name|int
name|e
operator|=
name|errno
block|;
name|dirtcnt
operator|=
literal|0
block|;
name|putchar
argument_list|(
literal|' '
argument_list|)
block|;
if|if
condition|(
name|e
operator|>=
literal|0
operator|&&
name|errno
operator|<=
name|std_nerrs
condition|)
name|error
argument_list|(
name|std_errlist
index|[
name|e
index|]
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"System error %d"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/*  * Return the column number that results from being in column col and  * hitting a tab, where tabs are set every ts columns.  Work right for  * the case where col> COLUMNS, even if ts does not divide COLUMNS.  */
name|tabcol
argument_list|(
argument|col
argument_list|,
argument|ts
argument_list|)
name|int
name|col
block|,
name|ts
block|;
block|{
name|int
name|offset
block|,
name|result
block|;
if|if
condition|(
name|col
operator|>=
name|COLUMNS
condition|)
block|{
name|offset
operator|=
name|COLUMNS
operator|*
operator|(
name|col
operator|/
name|COLUMNS
operator|)
expr_stmt|;
name|col
operator|-=
name|offset
expr_stmt|;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|col
operator|+
name|ts
operator|-
operator|(
name|col
operator|%
name|ts
operator|)
operator|+
name|offset
block|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|char
modifier|*
name|vfindcol
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
function_decl|(
modifier|*
name|OO
function_decl|)
parameter_list|()
init|=
name|Outchar
function_decl|;
name|Outchar
operator|=
name|qcount
expr_stmt|;
name|ignore
argument_list|(
name|qcolumn
argument_list|(
name|linebuf
operator|-
literal|1
argument_list|,
name|NOSTR
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|linebuf
init|;
operator|*
name|cp
operator|&&
name|vcntcol
operator|<
name|i
condition|;
name|cp
operator|++
control|)
name|putchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|linebuf
condition|)
name|cp
operator|--
expr_stmt|;
name|Outchar
operator|=
name|OO
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|vskipwh
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
while|while
condition|(
name|iswhite
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
name|cp
index|[
literal|1
index|]
condition|)
name|cp
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|vpastwh
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
while|while
condition|(
name|iswhite
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|whitecnt
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'\t'
case|:
name|i
operator|+=
name|value
argument_list|(
name|TABSTOP
argument_list|)
operator|-
name|i
operator|%
name|value
argument_list|(
name|TABSTOP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|i
operator|++
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_macro
name|Ignore
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|a
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_function_decl
name|Ignorf
function_decl|(
name|a
function_decl|)
name|int
argument_list|(
argument|*a
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|a
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|markit
argument_list|(
name|addr
argument_list|)
name|line
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|addr
operator|!=
name|dot
operator|&&
name|addr
operator|>=
name|one
operator|&&
name|addr
operator|<=
name|dol
condition|)
name|markDOT
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

