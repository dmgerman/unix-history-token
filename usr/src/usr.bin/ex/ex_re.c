begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ex_re.c	7.6 (Berkeley) 3/9/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_re.h"
end_include

begin_comment
comment|/*  * Global, substitute and regular expressions.  * Very similar to ed, with some re extensions and  * confirmed substitute.  */
end_comment

begin_macro
name|global
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|gp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|line
modifier|*
name|a1
decl_stmt|;
name|char
name|globuf
index|[
name|GBSIZE
index|]
decl_stmt|,
modifier|*
name|Cwas
decl_stmt|;
name|int
name|lines
init|=
name|lineDOL
argument_list|()
decl_stmt|;
name|int
name|oinglobal
init|=
name|inglobal
decl_stmt|;
name|char
modifier|*
name|oglobp
init|=
name|globp
decl_stmt|;
name|Cwas
operator|=
name|Command
expr_stmt|;
comment|/* 	 * States of inglobal: 	 *  0: ordinary - not in a global command. 	 *  1: text coming from some buffer, not tty. 	 *  2: like 1, but the source of the buffer is a global command. 	 * Hence you're only in a global command if inglobal==2. This 	 * strange sounding convention is historically derived from 	 * everybody simulating a global command. 	 */
if|if
condition|(
name|inglobal
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"Global within global@not allowed"
argument_list|)
expr_stmt|;
name|markDOT
argument_list|()
expr_stmt|;
name|setall
argument_list|()
expr_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
if|if
condition|(
name|skipend
argument_list|()
condition|)
name|error
argument_list|(
literal|"Global needs re|Missing regular expression for global"
argument_list|)
expr_stmt|;
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
name|ignore
argument_list|(
name|compile
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|savere
argument_list|(
name|scanre
argument_list|)
expr_stmt|;
name|gp
operator|=
name|globuf
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ex_getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|brkwh
goto|;
case|case
literal|'\\'
case|:
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
break|break;
default|default:
operator|*
name|gp
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
block|}
break|break;
block|}
operator|*
name|gp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|gp
operator|>=
operator|&
name|globuf
index|[
name|GBSIZE
operator|-
literal|2
index|]
condition|)
name|error
argument_list|(
literal|"Global command too long"
argument_list|)
expr_stmt|;
block|}
name|brkwh
label|:
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
operator|*
name|gp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|gp
operator|++
operator|=
literal|0
expr_stmt|;
name|saveall
argument_list|()
expr_stmt|;
name|inglobal
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|a1
operator|=
name|one
init|;
name|a1
operator|<=
name|dol
condition|;
name|a1
operator|++
control|)
block|{
operator|*
name|a1
operator|&=
operator|~
literal|01
expr_stmt|;
if|if
condition|(
name|a1
operator|>=
name|addr1
operator|&&
name|a1
operator|<=
name|addr2
operator|&&
name|execute
argument_list|(
literal|0
argument_list|,
name|a1
argument_list|)
operator|==
name|k
condition|)
operator|*
name|a1
operator||=
literal|01
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/*  * This code is commented out for now.  The problem is that we don't  * fix up the undo area the way we should.  Basically, I think what has  * to be done is to copy the undo area down (since we shrunk everything)  * and move the various pointers into it down too.  I will do this later  * when I have time. (Mark, 10-20-80)  */
comment|/* 	 * Special case: g/.../d (avoid n^2 algorithm) 	 */
if|if
condition|(
name|globuf
index|[
literal|0
index|]
operator|==
literal|'d'
operator|&&
name|globuf
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|globuf
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|gdelete
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|inopen
condition|)
name|inopen
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Now for each marked line, set dot there and do the commands. 	 * Note the n^2 behavior here for lots of lines matching. 	 * This is really needed: in some cases you could delete lines, 	 * causing a marked line to be moved before a1 and missed if 	 * we didn't restart at zero each time. 	 */
for|for
control|(
name|a1
operator|=
name|one
init|;
name|a1
operator|<=
name|dol
condition|;
name|a1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|a1
operator|&
literal|01
condition|)
block|{
operator|*
name|a1
operator|&=
operator|~
literal|01
expr_stmt|;
name|dot
operator|=
name|a1
expr_stmt|;
name|globp
operator|=
name|globuf
expr_stmt|;
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|a1
operator|=
name|zero
expr_stmt|;
block|}
block|}
name|globp
operator|=
name|oglobp
expr_stmt|;
name|inglobal
operator|=
name|oinglobal
expr_stmt|;
name|endline
operator|=
literal|1
expr_stmt|;
name|Command
operator|=
name|Cwas
expr_stmt|;
name|netchHAD
argument_list|(
name|lines
argument_list|)
expr_stmt|;
name|setlastchar
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
block|{
name|ungetchar
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
name|inopen
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * gdelete: delete inside a global command. Handles the  * special case g/r.e./d. All lines to be deleted have  * already been marked. Squeeze the remaining lines together.  * Note that other cases such as g/r.e./p, g/r.e./s/r.e.2/rhs/,  * and g/r.e./.,/r.e.2/d are not treated specially.  There is no  * good reason for this except the question: where to you draw the line?  */
end_comment

begin_macro
name|gdelete
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|line
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|,
modifier|*
name|a3
decl_stmt|;
name|a3
operator|=
name|dol
expr_stmt|;
comment|/* find first marked line. can skip all before it */
for|for
control|(
name|a1
operator|=
name|zero
init|;
operator|(
operator|*
name|a1
operator|&
literal|01
operator|)
operator|==
literal|0
condition|;
name|a1
operator|++
control|)
if|if
condition|(
name|a1
operator|>=
name|a3
condition|)
return|return;
comment|/* copy down unmarked lines, compacting as we go. */
for|for
control|(
name|a2
operator|=
name|a1
operator|+
literal|1
init|;
name|a2
operator|<=
name|a3
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|a2
operator|&
literal|01
condition|)
block|{
name|a2
operator|++
expr_stmt|;
comment|/* line is marked, skip it */
name|dot
operator|=
name|a1
expr_stmt|;
comment|/* dot left after line deletion */
block|}
else|else
operator|*
name|a1
operator|++
operator|=
operator|*
name|a2
operator|++
expr_stmt|;
comment|/* unmarked, copy it */
block|}
name|dol
operator|=
name|a1
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dot
operator|>
name|dol
condition|)
name|dot
operator|=
name|dol
expr_stmt|;
name|change
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|bool
name|cflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scount
decl_stmt|,
name|slines
decl_stmt|,
name|stotal
decl_stmt|;
end_decl_stmt

begin_macro
name|substitute
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|gsubf
decl_stmt|,
name|hopcount
decl_stmt|;
name|gsubf
operator|=
name|compsub
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
name|save12
argument_list|()
operator|,
name|undkind
operator|=
name|UNDCHANGE
expr_stmt|;
name|stotal
operator|=
literal|0
expr_stmt|;
name|slines
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|addr1
init|;
name|addr
operator|<=
name|addr2
condition|;
name|addr
operator|++
control|)
block|{
name|scount
operator|=
name|hopcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dosubcon
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|gsubf
condition|)
block|{
comment|/* 			 * The loop can happen from s/\</&/g 			 * but we don't want to break other, reasonable cases. 			 */
while|while
condition|(
operator|*
name|loc2
condition|)
block|{
if|if
condition|(
operator|++
name|hopcount
operator|>
sizeof|sizeof
name|linebuf
condition|)
name|error
argument_list|(
literal|"substitution loop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dosubcon
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|scount
condition|)
block|{
name|stotal
operator|+=
name|scount
expr_stmt|;
name|slines
operator|++
expr_stmt|;
name|putmark
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|n
operator|=
name|append
argument_list|(
name|getsub
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|n
expr_stmt|;
name|addr2
operator|+=
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stotal
operator|==
literal|0
operator|&&
operator|!
name|inglobal
operator|&&
operator|!
name|cflag
condition|)
name|error
argument_list|(
literal|"Fail|Substitute pattern match failed"
argument_list|)
expr_stmt|;
name|snote
argument_list|(
name|stotal
argument_list|,
name|slines
argument_list|)
expr_stmt|;
return|return
operator|(
name|stotal
operator|)
return|;
block|}
end_block

begin_macro
name|compsub
argument_list|(
argument|ch
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|seof
decl_stmt|,
name|c
decl_stmt|,
name|uselastre
decl_stmt|;
specifier|static
name|int
name|gsubf
decl_stmt|;
if|if
condition|(
operator|!
name|value
argument_list|(
name|EDCOMPATIBLE
argument_list|)
condition|)
name|gsubf
operator|=
name|cflag
operator|=
literal|0
expr_stmt|;
name|uselastre
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'s'
case|:
name|ignore
argument_list|(
name|skipwh
argument_list|()
argument_list|)
expr_stmt|;
name|seof
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|endcmd
argument_list|(
name|seof
argument_list|)
operator|||
name|any
argument_list|(
name|seof
argument_list|,
literal|"gcr"
argument_list|)
condition|)
block|{
name|ungetchar
argument_list|(
name|seof
argument_list|)
expr_stmt|;
goto|goto
name|redo
goto|;
block|}
if|if
condition|(
name|isalpha
argument_list|(
name|seof
argument_list|)
operator|||
name|isdigit
argument_list|(
name|seof
argument_list|)
condition|)
name|error
argument_list|(
literal|"Substitute needs re|Missing regular expression for substitute"
argument_list|)
expr_stmt|;
name|seof
operator|=
name|compile
argument_list|(
name|seof
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|uselastre
operator|=
literal|1
expr_stmt|;
name|comprhs
argument_list|(
name|seof
argument_list|)
expr_stmt|;
name|gsubf
operator|=
literal|0
expr_stmt|;
name|cflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|uselastre
operator|=
literal|1
expr_stmt|;
comment|/* fall into ... */
case|case
literal|'&'
case|:
name|redo
label|:
if|if
condition|(
name|re
operator|.
name|Expbuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No previous re|No previous regular expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subre
operator|.
name|Expbuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No previous substitute re|No previous substitute to repeat"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'g'
case|:
name|gsubf
operator|=
operator|!
name|gsubf
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|cflag
operator|=
operator|!
name|cflag
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|uselastre
operator|=
literal|1
expr_stmt|;
continue|continue;
default|default:
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|setcount
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
name|uselastre
condition|)
name|savere
argument_list|(
name|subre
argument_list|)
expr_stmt|;
else|else
name|resre
argument_list|(
name|subre
argument_list|)
expr_stmt|;
return|return
operator|(
name|gsubf
operator|)
return|;
block|}
block|}
block|}
end_block

begin_macro
name|comprhs
argument_list|(
argument|seof
argument_list|)
end_macro

begin_decl_stmt
name|int
name|seof
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|rp
decl_stmt|,
modifier|*
name|orp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|orhsbuf
index|[
name|RHSSIZE
index|]
decl_stmt|;
name|rp
operator|=
name|rhsbuf
expr_stmt|;
name|CP
argument_list|(
name|orhsbuf
argument_list|,
name|rp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|seof
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|value
argument_list|(
name|MAGIC
argument_list|)
condition|)
block|{
comment|/* 				 * When "magic", \& turns into a plain&, 				 * and all other chars work fine quoted. 				 */
if|if
condition|(
name|c
operator|!=
literal|'&'
condition|)
name|c
operator||=
name|QUOTE
expr_stmt|;
break|break;
block|}
name|magic
label|:
if|if
condition|(
name|c
operator|==
literal|'~'
condition|)
block|{
for|for
control|(
name|orp
operator|=
name|orhsbuf
init|;
operator|*
name|orp
condition|;
operator|*
name|rp
operator|++
operator|=
operator|*
name|orp
operator|++
control|)
if|if
condition|(
name|rp
operator|>=
operator|&
name|rhsbuf
index|[
name|RHSSIZE
operator|-
literal|1
index|]
condition|)
goto|goto
name|toobig
goto|;
continue|continue;
block|}
name|c
operator||=
name|QUOTE
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
case|case
name|EOF
case|:
if|if
condition|(
operator|!
operator|(
name|globp
operator|&&
name|globp
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|endrhs
goto|;
block|}
case|case
literal|'~'
case|:
case|case
literal|'&'
case|:
if|if
condition|(
name|value
argument_list|(
name|MAGIC
argument_list|)
condition|)
goto|goto
name|magic
goto|;
break|break;
block|}
if|if
condition|(
name|rp
operator|>=
operator|&
name|rhsbuf
index|[
name|RHSSIZE
operator|-
literal|1
index|]
condition|)
block|{
name|toobig
label|:
operator|*
name|rp
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"Replacement pattern too long@- limit 256 characters"
argument_list|)
expr_stmt|;
block|}
operator|*
name|rp
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|endrhs
label|:
operator|*
name|rp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|getsub
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|linebp
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|strcLIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|linebp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|dosubcon
argument_list|(
argument|f
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|line
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|execute
argument_list|(
name|f
argument_list|,
name|a
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|confirmed
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|dosub
argument_list|()
expr_stmt|;
name|scount
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|confirmed
argument_list|(
name|a
argument_list|)
name|line
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|ch
decl_stmt|;
if|if
condition|(
name|cflag
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|pofix
argument_list|()
expr_stmt|;
name|pline
argument_list|(
name|lineno
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
name|ex_putchar
argument_list|(
literal|'\n'
operator||
name|QUOTE
argument_list|)
expr_stmt|;
name|c
operator|=
name|column
argument_list|(
name|loc1
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ugo
argument_list|(
name|c
operator|-
literal|1
operator|+
operator|(
name|inopen
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|ugo
argument_list|(
name|column
argument_list|(
name|loc2
operator|-
literal|1
argument_list|)
operator|-
name|c
argument_list|,
literal|'^'
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|ch
operator|=
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
name|again
label|:
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
name|ex_putchar
argument_list|(
name|c
argument_list|)
operator|,
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|noteinp
argument_list|()
expr_stmt|;
return|return
operator|(
name|ch
operator|==
literal|'y'
operator|)
return|;
block|}
end_block

begin_macro
name|getch
argument_list|()
end_macro

begin_block
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
literal|2
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
return|return
operator|(
name|c
operator|&
name|TRIM
operator|)
return|;
block|}
end_block

begin_macro
name|ugo
argument_list|(
argument|cnt
argument_list|,
argument|with
argument_list|)
end_macro

begin_decl_stmt
name|int
name|with
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
do|do
name|ex_putchar
argument_list|(
name|with
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|cnt
operator|>
literal|0
condition|)
do|;
block|}
end_block

begin_decl_stmt
name|int
name|casecnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|destuc
decl_stmt|;
end_decl_stmt

begin_macro
name|dosub
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
name|sp
operator|=
name|genbuf
expr_stmt|;
name|rp
operator|=
name|rhsbuf
expr_stmt|;
while|while
condition|(
name|lp
operator|<
name|loc1
condition|)
operator|*
name|sp
operator|++
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
name|casecnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|rp
operator|++
condition|)
block|{
comment|/* ^V<return> from vi to split lines */
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|QUOTE
condition|)
switch|switch
condition|(
name|c
operator|&
name|TRIM
condition|)
block|{
case|case
literal|'&'
case|:
name|sp
operator|=
name|place
argument_list|(
name|sp
argument_list|,
name|loc1
argument_list|,
name|loc2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
goto|goto
name|ovflo
goto|;
continue|continue;
case|case
literal|'l'
case|:
name|casecnt
operator|=
literal|1
expr_stmt|;
name|destuc
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'L'
case|:
name|casecnt
operator|=
name|LBSIZE
expr_stmt|;
name|destuc
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
name|casecnt
operator|=
literal|1
expr_stmt|;
name|destuc
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'U'
case|:
name|casecnt
operator|=
name|LBSIZE
expr_stmt|;
name|destuc
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|casecnt
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
operator|(
name|c
operator|&=
name|TRIM
operator|)
operator|>=
literal|'1'
operator|&&
name|c
operator|<
name|nbra
operator|+
literal|'1'
condition|)
block|{
name|sp
operator|=
name|place
argument_list|(
name|sp
argument_list|,
name|braslist
index|[
name|c
operator|-
literal|'1'
index|]
argument_list|,
name|braelist
index|[
name|c
operator|-
literal|'1'
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
goto|goto
name|ovflo
goto|;
continue|continue;
block|}
if|if
condition|(
name|casecnt
condition|)
operator|*
name|sp
operator|++
operator|=
name|fixcase
argument_list|(
name|c
operator|&
name|TRIM
argument_list|)
expr_stmt|;
else|else
operator|*
name|sp
operator|++
operator|=
name|c
operator|&
name|TRIM
expr_stmt|;
if|if
condition|(
name|sp
operator|>=
operator|&
name|genbuf
index|[
name|LBSIZE
index|]
condition|)
name|ovflo
label|:
name|error
argument_list|(
literal|"Line overflow@in substitute"
argument_list|)
expr_stmt|;
block|}
name|lp
operator|=
name|loc2
expr_stmt|;
name|loc2
operator|=
name|sp
operator|+
operator|(
name|linebuf
operator|-
name|genbuf
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|++
operator|=
operator|*
name|lp
operator|++
condition|)
if|if
condition|(
name|sp
operator|>=
operator|&
name|genbuf
index|[
name|LBSIZE
index|]
condition|)
goto|goto
name|ovflo
goto|;
name|strcLIN
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|fixcase
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|casecnt
operator|==
literal|0
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|casecnt
operator|--
expr_stmt|;
if|if
condition|(
name|destuc
condition|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|place
parameter_list|(
name|sp
parameter_list|,
name|l1
parameter_list|,
name|l2
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
decl|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|l1
operator|<
name|l2
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
name|fixcase
argument_list|(
operator|*
name|l1
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|>=
operator|&
name|genbuf
index|[
name|LBSIZE
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|snote
argument_list|(
name|total
argument_list|,
name|lines
argument_list|)
specifier|register
name|int
name|total
operator|,
name|lines
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|notable
argument_list|(
name|total
argument_list|)
condition|)
return|return;
name|ex_printf
argument_list|(
name|mesg
argument_list|(
literal|"%d subs|%d substitutions"
argument_list|)
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
operator|!=
literal|1
operator|&&
name|lines
operator|!=
name|total
condition|)
name|ex_printf
argument_list|(
literal|" on %d lines"
argument_list|,
name|lines
argument_list|)
expr_stmt|;
name|noonl
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|compile
argument_list|(
argument|eof
argument_list|,
argument|oknl
argument_list|)
end_macro

begin_decl_stmt
name|int
name|eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|oknl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|lastep
decl_stmt|;
name|char
name|bracket
index|[
name|NBRA
index|]
decl_stmt|,
modifier|*
name|bracketp
decl_stmt|,
modifier|*
name|rhsp
decl_stmt|;
name|int
name|cclcnt
decl_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|eof
argument_list|)
operator|||
name|isdigit
argument_list|(
name|eof
argument_list|)
condition|)
name|error
argument_list|(
literal|"Regular expressions cannot be delimited by letters or digits"
argument_list|)
expr_stmt|;
name|ep
operator|=
name|expbuf
expr_stmt|;
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|eof
operator|==
literal|'\\'
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
name|scanre
operator|.
name|Expbuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No previous scan re|No previous scanning regular expression"
argument_list|)
expr_stmt|;
name|resre
argument_list|(
name|scanre
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
case|case
literal|'&'
case|:
if|if
condition|(
name|subre
operator|.
name|Expbuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No previous substitute re|No previous substitute regular expression"
argument_list|)
expr_stmt|;
name|resre
argument_list|(
name|subre
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"Badly formed re|Regular expression \\ must be followed by / or ?"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|eof
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
operator|*
name|ep
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No previous re|No previous regular expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|oknl
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Missing closing delimiter@for regular expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|eof
condition|)
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|eof
operator|)
return|;
block|}
name|bracketp
operator|=
name|bracket
expr_stmt|;
name|nbra
operator|=
literal|0
expr_stmt|;
name|circfl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
name|circfl
operator|++
expr_stmt|;
block|}
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|ESIZE
operator|-
literal|2
index|]
condition|)
name|complex
label|:
name|cerror
argument_list|(
literal|"Re too complex|Regular expression too complicated"
argument_list|)
expr_stmt|;
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|eof
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|bracketp
operator|!=
name|bracket
condition|)
name|cerror
argument_list|(
literal|"Unmatched \\(|More \\('s than \\)'s in regular expression"
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CEOFC
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|eof
operator|)
return|;
block|}
if|if
condition|(
name|value
argument_list|(
name|MAGIC
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'*'
operator|||
name|ep
operator|==
name|expbuf
condition|)
name|lastep
operator|=
name|ep
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\\'
operator|||
name|peekchar
argument_list|()
operator|!=
literal|'*'
operator|||
name|ep
operator|==
name|expbuf
condition|)
name|lastep
operator|=
name|ep
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|nbra
operator|>=
name|NBRA
condition|)
name|cerror
argument_list|(
literal|"Awash in \\('s!|Too many \\('d subexressions in a regular expression"
argument_list|)
expr_stmt|;
operator|*
name|bracketp
operator|++
operator|=
name|nbra
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CBRA
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|nbra
operator|++
expr_stmt|;
continue|continue;
case|case
literal|')'
case|:
if|if
condition|(
name|bracketp
operator|<=
name|bracket
condition|)
name|cerror
argument_list|(
literal|"Extra \\)|More \\)'s than \\('s in regular expression"
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CKET
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
operator|*
operator|--
name|bracketp
expr_stmt|;
continue|continue;
case|case
literal|'<'
case|:
operator|*
name|ep
operator|++
operator|=
name|CBRC
expr_stmt|;
continue|continue;
case|case
literal|'>'
case|:
operator|*
name|ep
operator|++
operator|=
name|CLET
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|value
argument_list|(
name|MAGIC
argument_list|)
operator|==
literal|0
condition|)
name|magic
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'.'
case|:
operator|*
name|ep
operator|++
operator|=
name|CDOT
expr_stmt|;
continue|continue;
case|case
literal|'~'
case|:
name|rhsp
operator|=
name|rhsbuf
expr_stmt|;
while|while
condition|(
operator|*
name|rhsp
condition|)
block|{
if|if
condition|(
operator|*
name|rhsp
operator|&
name|QUOTE
condition|)
block|{
name|c
operator|=
operator|*
name|rhsp
operator|&
name|TRIM
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
name|error
argument_list|(
literal|"Replacement pattern contains&@- cannot use in re"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'1'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|error
argument_list|(
literal|"Replacement pattern contains \\d@- cannot use in re"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|ESIZE
operator|-
literal|2
index|]
condition|)
goto|goto
name|complex
goto|;
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
operator|*
name|rhsp
operator|++
operator|&
name|TRIM
expr_stmt|;
block|}
continue|continue;
case|case
literal|'*'
case|:
if|if
condition|(
name|ep
operator|==
name|expbuf
condition|)
break|break;
if|if
condition|(
operator|*
name|lastep
operator|==
name|CBRA
operator|||
operator|*
name|lastep
operator|==
name|CKET
condition|)
name|cerror
argument_list|(
literal|"Illegal *|Can't * a \\( ... \\) in regular expression"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|lastep
operator|==
name|CCHR
operator|&&
operator|(
name|lastep
index|[
literal|1
index|]
operator|&
name|QUOTE
operator|)
condition|)
name|cerror
argument_list|(
literal|"Illegal *|Can't * a \\n in regular expression"
argument_list|)
expr_stmt|;
operator|*
name|lastep
operator||=
name|STAR
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
operator|*
name|ep
operator|++
operator|=
name|CCL
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
literal|0
expr_stmt|;
name|cclcnt
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
name|ep
index|[
operator|-
literal|2
index|]
operator|=
name|NCCL
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
name|cerror
argument_list|(
literal|"Bad character class|Empty character class '[]' or '[^]' cannot match"
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|any
argument_list|(
name|peekchar
argument_list|()
argument_list|,
literal|"]-^\\"
argument_list|)
condition|)
name|c
operator|=
name|ex_getchar
argument_list|()
operator||
name|QUOTE
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
name|cerror
argument_list|(
literal|"Missing ]"
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
name|cclcnt
operator|++
expr_stmt|;
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|ESIZE
index|]
condition|)
goto|goto
name|complex
goto|;
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
block|}
name|lastep
index|[
literal|1
index|]
operator|=
name|cclcnt
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|ungetchar
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\\'
expr_stmt|;
goto|goto
name|defchar
goto|;
block|}
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|cerror
argument_list|(
literal|"No newlines in re's|Can't escape newlines into regular expressions"
argument_list|)
expr_stmt|;
comment|/* 			if (c< '1' || c> NBRA + '1') { */
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
comment|/* 			} 			c -= '1'; 			if (c>= nbra) cerror("Bad \\n|\\n in regular expression with n greater than the number of \\('s"); 			*ep++ = c | QUOTE; 			continue; */
case|case
literal|'\n'
case|:
if|if
condition|(
name|oknl
condition|)
block|{
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CEOFC
expr_stmt|;
return|return
operator|(
name|eof
operator|)
return|;
block|}
name|cerror
argument_list|(
literal|"Badly formed re|Missing closing delimiter for regular expression"
argument_list|)
expr_stmt|;
case|case
literal|'$'
case|:
if|if
condition|(
name|peekchar
argument_list|()
operator|==
name|eof
operator|||
name|peekchar
argument_list|()
operator|==
name|EOF
operator|||
name|oknl
operator|&&
name|peekchar
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|ep
operator|++
operator|=
name|CDOL
expr_stmt|;
continue|continue;
block|}
goto|goto
name|defchar
goto|;
case|case
literal|'.'
case|:
case|case
literal|'~'
case|:
case|case
literal|'*'
case|:
case|case
literal|'['
case|:
if|if
condition|(
name|value
argument_list|(
name|MAGIC
argument_list|)
condition|)
goto|goto
name|magic
goto|;
name|defchar
label|:
default|default:
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_block

begin_macro
name|cerror
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|expbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|same
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
specifier|register
name|int
name|a
operator|,
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|a
operator|==
name|b
operator|||
name|value
argument_list|(
name|IGNORECASE
argument_list|)
operator|&&
operator|(
operator|(
name|islower
argument_list|(
name|a
argument_list|)
operator|&&
name|toupper
argument_list|(
name|a
argument_list|)
operator|==
name|b
operator|)
operator|||
operator|(
name|islower
argument_list|(
name|b
argument_list|)
operator|&&
name|toupper
argument_list|(
name|b
argument_list|)
operator|==
name|a
operator|)
operator|)
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|locs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VARARGS1 */
end_comment

begin_expr_stmt
name|execute
argument_list|(
name|gf
argument_list|,
name|addr
argument_list|)
name|line
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|gf
condition|)
block|{
if|if
condition|(
name|circfl
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|locs
operator|=
name|p1
operator|=
name|loc2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|addr
operator|==
name|zero
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p1
operator|=
name|linebuf
expr_stmt|;
name|getline
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
name|locs
operator|=
literal|0
expr_stmt|;
block|}
name|p2
operator|=
name|expbuf
expr_stmt|;
if|if
condition|(
name|circfl
condition|)
block|{
name|loc1
operator|=
name|p1
expr_stmt|;
return|return
operator|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|)
return|;
block|}
comment|/* fast check for first character */
if|if
condition|(
operator|*
name|p2
operator|==
name|CCHR
condition|)
block|{
name|c
operator|=
name|p2
index|[
literal|1
index|]
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|!=
operator|*
name|p1
operator|&&
operator|(
operator|!
name|value
argument_list|(
name|IGNORECASE
argument_list|)
operator|||
operator|!
operator|(
operator|(
name|islower
argument_list|(
name|c
argument_list|)
operator|&&
name|toupper
argument_list|(
name|c
argument_list|)
operator|==
operator|*
name|p1
operator|)
operator|||
operator|(
name|islower
argument_list|(
operator|*
name|p1
argument_list|)
operator|&&
name|toupper
argument_list|(
operator|*
name|p1
argument_list|)
operator|==
name|c
operator|)
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|loc1
operator|=
name|p1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|*
name|p1
operator|++
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* regular algorithm */
do|do
block|{
if|if
condition|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|loc1
operator|=
name|p1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|*
name|p1
operator|++
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|uletter
parameter_list|(
name|c
parameter_list|)
value|(isalpha(c) || c == '_')
end_define

begin_expr_stmt
name|advance
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
specifier|register
name|char
operator|*
name|lp
operator|,
operator|*
name|ep
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|curlp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|ep
operator|++
condition|)
block|{
case|case
name|CCHR
case|:
comment|/* useless 		if (*ep& QUOTE) { 			c = *ep++& TRIM; 			sp = braslist[c]; 			sp1 = braelist[c]; 			while (sp< sp1) { 				if (!same(*sp, *lp)) 					return (0); 				sp++, lp++; 			} 			continue; 		} */
if|if
condition|(
operator|!
name|same
argument_list|(
operator|*
name|ep
argument_list|,
operator|*
name|lp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ep
operator|++
operator|,
name|lp
operator|++
expr_stmt|;
continue|continue;
case|case
name|CDOT
case|:
if|if
condition|(
operator|*
name|lp
operator|++
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CDOL
case|:
if|if
condition|(
operator|*
name|lp
operator|==
literal|0
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CEOFC
case|:
name|loc2
operator|=
name|lp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|CCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|NCCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CBRA
case|:
name|braslist
index|[
operator|*
name|ep
operator|++
index|]
operator|=
name|lp
expr_stmt|;
continue|continue;
case|case
name|CKET
case|:
name|braelist
index|[
operator|*
name|ep
operator|++
index|]
operator|=
name|lp
expr_stmt|;
continue|continue;
case|case
name|CDOT
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
condition|)
continue|continue;
goto|goto
name|star
goto|;
case|case
name|CCHR
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
name|same
argument_list|(
operator|*
name|lp
argument_list|,
operator|*
name|ep
argument_list|)
condition|)
name|lp
operator|++
expr_stmt|;
name|lp
operator|++
expr_stmt|;
name|ep
operator|++
expr_stmt|;
goto|goto
name|star
goto|;
case|case
name|CCL
operator||
name|STAR
case|:
case|case
name|NCCL
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
name|ep
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|CCL
operator||
name|STAR
operator|)
argument_list|)
condition|)
continue|continue;
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
goto|goto
name|star
goto|;
name|star
label|:
do|do
block|{
name|lp
operator|--
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|locs
condition|)
break|break;
if|if
condition|(
name|advance
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
name|lp
operator|>
name|curlp
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CBRC
case|:
if|if
condition|(
name|lp
operator|==
name|linebuf
condition|)
continue|continue;
if|if
condition|(
operator|(
name|isdigit
argument_list|(
operator|*
name|lp
argument_list|)
operator|||
name|uletter
argument_list|(
operator|*
name|lp
argument_list|)
operator|)
operator|&&
operator|!
name|uletter
argument_list|(
name|lp
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|isdigit
argument_list|(
name|lp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CLET
case|:
if|if
condition|(
operator|!
name|uletter
argument_list|(
operator|*
name|lp
argument_list|)
operator|&&
operator|!
name|isdigit
argument_list|(
operator|*
name|lp
argument_list|)
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"Re internal error"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|cclass
argument_list|(
name|set
argument_list|,
name|c
argument_list|,
name|af
argument_list|)
specifier|register
name|char
operator|*
name|set
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|af
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|value
argument_list|(
name|IGNORECASE
argument_list|)
operator|&&
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|set
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
condition|)
if|if
condition|(
name|n
operator|>
literal|2
operator|&&
name|set
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|c
operator|>=
operator|(
name|set
index|[
literal|0
index|]
operator|&
name|TRIM
operator|)
operator|&&
name|c
operator|<=
operator|(
name|set
index|[
literal|2
index|]
operator|&
name|TRIM
operator|)
condition|)
return|return
operator|(
name|af
operator|)
return|;
name|set
operator|+=
literal|3
expr_stmt|;
name|n
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|set
operator|++
operator|&
name|TRIM
operator|)
operator|==
name|c
condition|)
return|return
operator|(
name|af
operator|)
return|;
return|return
operator|(
operator|!
name|af
operator|)
return|;
block|}
end_block

end_unit

