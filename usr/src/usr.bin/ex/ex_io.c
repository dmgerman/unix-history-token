begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ex_io.c	7.15 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_argv.h"
end_include

begin_include
include|#
directive|include
file|"ex_temp.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FLOCKFILE
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
endif|FLOCKFILE
end_endif

begin_comment
comment|/*  * File input/output, source, preserve and recover  */
end_comment

begin_comment
comment|/*  * Following remember where . was in the previous file for return  * on file switching.  */
end_comment

begin_decl_stmt
name|int
name|altdot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|oldadot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|wasalt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|isalt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cntch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of characters on unit io */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VMUNIX
end_ifndef

begin_decl_stmt
name|short
name|cntln
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of lines " */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|cntln
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|long
name|cntnull
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of nulls " */
end_comment

begin_decl_stmt
name|long
name|cntodd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of non-ascii characters " */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FLOCKFILE
end_ifdef

begin_comment
comment|/*  * The alternate, saved and current file are locked the extent of the  * time that they are active. If the saved file is exchanged  * with the alternate file, the file descriptors are exchanged  * and the lock is not released.  */
end_comment

begin_decl_stmt
name|int
name|io_savedfile
decl_stmt|,
name|io_altfile
decl_stmt|,
name|io_curr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lock_savedfile
decl_stmt|,
name|lock_altfile
decl_stmt|,
name|lock_curr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|FLOCKFILE
end_endif

begin_comment
comment|/*  * Parse file name for command encoded by comm.  * If comm is E then command is doomed and we are  * parsing just so user won't have to retype the name.  */
end_comment

begin_macro
name|filename
argument_list|(
argument|comm
argument_list|)
end_macro

begin_decl_stmt
name|int
name|comm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
init|=
name|comm
decl_stmt|,
name|d
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|FLOCKFILE
name|int
name|lock
decl_stmt|;
name|lock
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|FLOCKFILE
name|d
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|endcmd
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|savedfile
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|comm
operator|!=
literal|'f'
condition|)
name|error
argument_list|(
literal|"No file|No current filename"
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOCKFILE
if|if
condition|(
name|io_curr
operator|&&
name|io_curr
operator|!=
name|io_savedfile
condition|)
name|close
argument_list|(
name|io_curr
argument_list|)
expr_stmt|;
name|lock
operator|=
name|lock_curr
operator|=
name|lock_savedfile
expr_stmt|;
name|io_curr
operator|=
name|io_savedfile
expr_stmt|;
endif|#
directive|endif
endif|FLOCKFILE
name|wasalt
operator|=
operator|(
name|isalt
operator|>
literal|0
operator|)
condition|?
name|isalt
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|isalt
operator|=
literal|0
expr_stmt|;
name|oldadot
operator|=
name|altdot
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
name|altdot
operator|=
name|lineDOT
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|EOF
condition|)
name|ungetchar
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ungetchar
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|getone
argument_list|()
expr_stmt|;
name|eol
argument_list|()
expr_stmt|;
if|if
condition|(
name|savedfile
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|c
operator|!=
literal|'E'
operator|&&
name|c
operator|!=
literal|'e'
condition|)
block|{
name|c
operator|=
literal|'e'
expr_stmt|;
name|edited
operator|=
literal|0
expr_stmt|;
block|}
name|wasalt
operator|=
name|strcmp
argument_list|(
name|file
argument_list|,
name|altfile
argument_list|)
operator|==
literal|0
expr_stmt|;
name|oldadot
operator|=
name|altdot
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|edited
operator|=
literal|0
expr_stmt|;
comment|/* fall into ... */
case|case
literal|'e'
case|:
if|if
condition|(
name|savedfile
index|[
literal|0
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|FLOCKFILE
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
operator|==
literal|0
condition|)
break|break ;
endif|#
directive|endif
endif|FLOCKFILE
name|altdot
operator|=
name|lineDOT
argument_list|()
expr_stmt|;
name|CP
argument_list|(
name|altfile
argument_list|,
name|savedfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOCKFILE
if|if
condition|(
name|io_altfile
condition|)
name|close
argument_list|(
name|io_altfile
argument_list|)
expr_stmt|;
name|io_altfile
operator|=
name|io_savedfile
expr_stmt|;
name|lock_altfile
operator|=
name|lock_savedfile
expr_stmt|;
name|io_savedfile
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|FLOCKFILE
block|}
name|CP
argument_list|(
name|savedfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOCKFILE
name|io_savedfile
operator|=
name|io_curr
expr_stmt|;
name|lock_savedfile
operator|=
name|lock_curr
expr_stmt|;
name|io_curr
operator|=
literal|0
expr_stmt|;
name|lock
operator|=
name|lock_curr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|FLOCKFILE
break|break;
default|default:
if|if
condition|(
name|file
index|[
literal|0
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|FLOCKFILE
if|if
condition|(
name|wasalt
condition|)
break|break ;
endif|#
directive|endif
if|if
condition|(
name|c
operator|!=
literal|'E'
condition|)
name|altdot
operator|=
name|lineDOT
argument_list|()
expr_stmt|;
name|CP
argument_list|(
name|altfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOCKFILE
if|if
condition|(
name|io_altfile
operator|&&
name|io_altfile
operator|!=
name|io_curr
condition|)
name|close
argument_list|(
name|io_altfile
argument_list|)
expr_stmt|;
name|io_altfile
operator|=
name|io_curr
expr_stmt|;
name|lock_altfile
operator|=
name|lock_curr
expr_stmt|;
name|io_curr
operator|=
literal|0
expr_stmt|;
name|lock
operator|=
name|lock_curr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|FLOCKFILE
block|}
break|break;
block|}
block|}
if|if
condition|(
name|hush
operator|&&
name|comm
operator|!=
literal|'f'
operator|||
name|comm
operator|==
literal|'E'
condition|)
return|return;
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|lprintf
argument_list|(
literal|"\"%s\""
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|comm
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
name|value
argument_list|(
name|READONLY
argument_list|)
condition|)
name|ex_printf
argument_list|(
literal|" [Read only]"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edited
condition|)
name|ex_printf
argument_list|(
literal|" [Not edited]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tchng
condition|)
name|ex_printf
argument_list|(
literal|" [Modified]"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOCKFILE
if|if
condition|(
name|lock
operator|==
name|LOCK_SH
condition|)
name|ex_printf
argument_list|(
literal|" [Shared lock]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lock
operator|==
name|LOCK_EX
condition|)
name|ex_printf
argument_list|(
literal|" [Exclusive lock]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FLOCKFILE
block|}
name|flush
argument_list|()
expr_stmt|;
block|}
else|else
name|ex_printf
argument_list|(
literal|"No file "
argument_list|)
expr_stmt|;
if|if
condition|(
name|comm
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|=
name|lineDOL
argument_list|()
operator|)
condition|)
name|i
operator|++
expr_stmt|;
name|ex_printf
argument_list|(
literal|" line %d of %d --%ld%%--"
argument_list|,
name|lineDOT
argument_list|()
argument_list|,
name|lineDOL
argument_list|()
argument_list|,
operator|(
name|long
operator|)
literal|100
operator|*
name|lineDOT
argument_list|()
operator|/
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Get the argument words for a command into genbuf  * expanding # and %.  */
end_comment

begin_macro
name|getargs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
specifier|static
name|char
name|fpatbuf
index|[
literal|32
index|]
decl_stmt|;
comment|/* hence limit on :next +/pat */
name|pastwh
argument_list|()
expr_stmt|;
if|if
condition|(
name|peekchar
argument_list|()
operator|==
literal|'+'
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|fpatbuf
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cp
operator|++
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|>=
operator|&
name|fpatbuf
index|[
sizeof|sizeof
argument_list|(
name|fpatbuf
argument_list|)
index|]
condition|)
name|error
argument_list|(
literal|"Pattern too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|isspace
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|)
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
operator|--
name|cp
operator|=
literal|0
expr_stmt|;
name|firstpat
operator|=
operator|&
name|fpatbuf
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|skipend
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|CP
argument_list|(
name|genbuf
argument_list|,
literal|"echo "
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|genbuf
index|[
literal|5
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|endcmd
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|any
argument_list|(
name|peekchar
argument_list|()
argument_list|,
literal|"#%|"
argument_list|)
condition|)
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
comment|/* fall into... */
default|default:
if|if
condition|(
name|cp
operator|>
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
name|flong
label|:
name|error
argument_list|(
literal|"Argument buffer overflow"
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|fp
operator|=
name|altfile
expr_stmt|;
if|if
condition|(
operator|*
name|fp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No alternate filename@to substitute for #"
argument_list|)
expr_stmt|;
goto|goto
name|filexp
goto|;
case|case
literal|'%'
case|:
name|fp
operator|=
name|savedfile
expr_stmt|;
if|if
condition|(
operator|*
name|fp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No current filename@to substitute for %%"
argument_list|)
expr_stmt|;
name|filexp
label|:
while|while
condition|(
operator|*
name|fp
condition|)
block|{
if|if
condition|(
name|cp
operator|>
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
goto|goto
name|flong
goto|;
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Glob the argument words in genbuf, or if no globbing  * is implied, just split them up directly.  */
end_comment

begin_macro
name|glob
argument_list|(
argument|gp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|glob
modifier|*
name|gp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pvec
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
init|=
name|gp
operator|->
name|argv
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|gp
operator|->
name|argspac
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|int
name|nleft
init|=
name|NCARGS
decl_stmt|;
name|gp
operator|->
name|argc0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gscan
argument_list|()
operator|==
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|v
init|=
name|genbuf
operator|+
literal|5
decl_stmt|;
comment|/* strlen("echo ") */
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|v
argument_list|)
condition|)
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|v
condition|)
break|break;
operator|*
name|argv
operator|++
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|v
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|v
argument_list|)
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|v
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|argc0
operator|++
expr_stmt|;
block|}
operator|*
name|argv
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|pvec
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't make pipe to glob"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
name|io
operator|=
name|pvec
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Can't fork to do glob"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|int
name|oerrno
decl_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pvec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* so errors don't mess up the screen */
name|ignore
argument_list|(
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|svalue
argument_list|(
name|SHELL
argument_list|)
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|genbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oerrno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
name|filioerr
argument_list|(
name|svalue
argument_list|(
name|SHELL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
name|argv
operator|=
name|cp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|io
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|c
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|c
operator|=
name|ch
operator|&
name|TRIM
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|--
name|nleft
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"Arg list too long"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
operator|*
name|argv
condition|)
block|{
operator|--
name|nleft
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|argc0
operator|++
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|argc0
operator|>=
name|NARGS
condition|)
name|error
argument_list|(
literal|"Arg list too long"
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|>=
literal|0
condition|)
do|;
name|waitfor
argument_list|()
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|argc0
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No match"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Scan genbuf for shell metacharacters.  * Set is union of v7 shell and csh metas.  */
end_comment

begin_macro
name|gscan
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|vms
comment|/* Never have meta-characters in vms */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|genbuf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|any
argument_list|(
operator|*
name|cp
argument_list|,
literal|"~{[*?$`'\"\\"
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Parse one filename into file.  */
end_comment

begin_decl_stmt
name|struct
name|glob
name|G
decl_stmt|;
end_decl_stmt

begin_macro
name|getone
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|getargs
argument_list|()
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Missing filename"
argument_list|)
expr_stmt|;
name|glob
argument_list|(
operator|&
name|G
argument_list|)
expr_stmt|;
if|if
condition|(
name|G
operator|.
name|argc0
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"Ambiguous|Too many file names"
argument_list|)
expr_stmt|;
name|str
operator|=
name|G
operator|.
name|argv
index|[
name|G
operator|.
name|argc0
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|>
name|FNSIZE
operator|-
literal|4
condition|)
name|error
argument_list|(
literal|"Filename too long"
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|file
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read a file from the world.  * C is command, 'e' if this really an edit (or a recover).  */
end_comment

begin_macro
name|rop
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|short
name|magic
decl_stmt|;
specifier|static
name|int
name|ovro
decl_stmt|;
comment|/* old value(READONLY) */
specifier|static
name|int
name|denied
decl_stmt|;
comment|/* 1 if READONLY was set due to file permissions */
ifdef|#
directive|ifdef
name|FLOCKFILE
name|int
modifier|*
name|lp
decl_stmt|,
modifier|*
name|iop
decl_stmt|;
endif|#
directive|endif
endif|FLOCKFILE
name|io
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|edited
operator|++
expr_stmt|;
comment|/* 			 * If the user just did "ex foo" he is probably 			 * creating a new file.  Don't be an error, since 			 * this is ugly, and it screws up the + option. 			 */
if|if
condition|(
operator|!
name|seenprompt
condition|)
block|{
name|ex_printf
argument_list|(
literal|" [New file]"
argument_list|)
expr_stmt|;
name|noonl
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|syserror
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|io
argument_list|,
operator|&
name|stbuf
argument_list|)
condition|)
name|syserror
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFBLK
case|:
name|error
argument_list|(
literal|" Block special file"
argument_list|)
expr_stmt|;
case|case
name|S_IFCHR
case|:
if|if
condition|(
name|isatty
argument_list|(
name|io
argument_list|)
condition|)
name|error
argument_list|(
literal|" Teletype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|samei
argument_list|(
operator|&
name|stbuf
argument_list|,
literal|"/dev/null"
argument_list|)
condition|)
break|break;
name|error
argument_list|(
literal|" Character special file"
argument_list|)
expr_stmt|;
case|case
name|S_IFDIR
case|:
name|error
argument_list|(
literal|" Directory"
argument_list|)
expr_stmt|;
case|case
name|S_IFREG
case|:
name|i
operator|=
name|read
argument_list|(
name|io
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|io
argument_list|,
literal|0l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
condition|)
break|break;
ifndef|#
directive|ifndef
name|vms
switch|switch
condition|(
name|magic
condition|)
block|{
case|case
literal|0405
case|:
comment|/* data overlay on exec */
case|case
literal|0407
case|:
comment|/* unshared */
case|case
literal|0410
case|:
comment|/* shared text */
case|case
literal|0411
case|:
comment|/* separate I/D */
case|case
literal|0413
case|:
comment|/* VM/Unix demand paged */
case|case
literal|0430
case|:
comment|/* PDP-11 Overlay shared */
case|case
literal|0431
case|:
comment|/* PDP-11 Overlay sep I/D */
name|error
argument_list|(
literal|" Executable"
argument_list|)
expr_stmt|;
comment|/* 		 * We do not forbid the editing of portable archives 		 * because it is reasonable to edit them, especially 		 * if they are archives of text files.  This is 		 * especially useful if you archive source files together 		 * and copy them to another system with ~%take, since 		 * the files sometimes show up munged and must be fixed. 		 */
case|case
literal|0177545
case|:
case|case
literal|0177555
case|:
name|error
argument_list|(
literal|" Archive"
argument_list|)
expr_stmt|;
default|default:
ifdef|#
directive|ifdef
name|mbb
comment|/* C/70 has a 10 bit byte */
if|if
condition|(
name|magic
operator|&
literal|03401600
condition|)
else|#
directive|else
comment|/* Everybody else has an 8 bit byte */
if|if
condition|(
name|magic
operator|&
literal|0100200
condition|)
endif|#
directive|endif
name|error
argument_list|(
literal|" Non-ascii file"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|c
operator|!=
literal|'r'
condition|)
block|{
if|if
condition|(
name|value
argument_list|(
name|READONLY
argument_list|)
operator|&&
name|denied
condition|)
block|{
name|value
argument_list|(
name|READONLY
argument_list|)
operator|=
name|ovro
expr_stmt|;
name|denied
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
literal|0222
operator|)
operator|==
literal|0
operator|||
name|access
argument_list|(
name|file
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ovro
operator|=
name|value
argument_list|(
name|READONLY
argument_list|)
expr_stmt|;
name|denied
operator|=
literal|1
expr_stmt|;
name|value
argument_list|(
name|READONLY
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
argument_list|(
name|READONLY
argument_list|)
condition|)
block|{
name|ex_printf
argument_list|(
literal|" [Read only]"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FLOCKFILE
comment|/* 	 * Attempt to lock the file. We use an sharable lock if reading 	 * the file, and an exclusive lock if editting a file. 	 * The lock will be released when the file is no longer being 	 * referenced. At any time, the editor can have as many as 	 * three files locked, and with different lock statuses. 	 */
comment|/* 	 * if this is either the saved or alternate file or current file, 	 * point to the appropriate descriptor and file lock status. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|io_savedfile
condition|)
name|io_savedfile
operator|=
name|dup
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|&
name|lock_savedfile
expr_stmt|;
name|iop
operator|=
operator|&
name|io_savedfile
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
name|altfile
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|io_altfile
condition|)
name|io_altfile
operator|=
name|dup
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|&
name|lock_altfile
expr_stmt|;
name|iop
operator|=
operator|&
name|io_altfile
expr_stmt|;
block|}
else|else
block|{
comment|/* throw away current lock, accquire new current lock */
if|if
condition|(
name|io_curr
condition|)
name|close
argument_list|(
name|io_curr
argument_list|)
expr_stmt|;
name|io_curr
operator|=
name|dup
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|&
name|lock_curr
expr_stmt|;
name|iop
operator|=
operator|&
name|io_curr
expr_stmt|;
name|lock_curr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'r'
operator|||
name|value
argument_list|(
name|READONLY
argument_list|)
operator|||
operator|*
name|lp
operator|==
literal|0
condition|)
block|{
comment|/* if we have a lock already, don't bother */
if|if
condition|(
operator|!
operator|*
name|lp
condition|)
block|{
comment|/* try for a shared lock */
if|if
condition|(
name|flock
argument_list|(
operator|*
name|iop
argument_list|,
name|LOCK_SH
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|ex_printf
argument_list|(
literal|" [FILE BEING MODIFIED BY ANOTHER PROCESS]"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
goto|goto
name|fail_lock
goto|;
block|}
else|else
operator|*
name|lp
operator|=
name|LOCK_SH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
literal|'r'
operator|&&
operator|!
name|value
argument_list|(
name|READONLY
argument_list|)
operator|&&
operator|*
name|lp
operator|!=
name|LOCK_EX
condition|)
block|{
comment|/* if we are editting the file, upgrade to an exclusive lock. */
if|if
condition|(
name|flock
argument_list|(
operator|*
name|iop
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|ex_printf
argument_list|(
literal|" [File open by another process]"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
else|else
operator|*
name|lp
operator|=
name|LOCK_EX
expr_stmt|;
block|}
name|fail_lock
label|:
endif|#
directive|endif
endif|FLOCKFILE
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
name|setdot
argument_list|()
expr_stmt|;
else|else
name|setall
argument_list|()
expr_stmt|;
if|if
condition|(
name|FIXUNDO
operator|&&
name|inopen
operator|&&
name|c
operator|==
literal|'r'
condition|)
name|undap1
operator|=
name|undap2
operator|=
name|dot
operator|+
literal|1
expr_stmt|;
name|rop2
argument_list|()
expr_stmt|;
name|rop3
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rop2
argument_list|()
end_macro

begin_block
block|{
name|line
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|a
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|deletenone
argument_list|()
expr_stmt|;
name|clrstats
argument_list|()
expr_stmt|;
name|first
operator|=
name|addr2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|io
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
name|bsize
operator|=
name|LBSIZE
expr_stmt|;
else|else
block|{
name|bsize
operator|=
name|statb
operator|.
name|st_blksize
expr_stmt|;
if|if
condition|(
name|bsize
operator|<=
literal|0
condition|)
name|bsize
operator|=
name|LBSIZE
expr_stmt|;
block|}
name|ignore
argument_list|(
name|append
argument_list|(
name|getfile
argument_list|,
name|addr2
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|dot
expr_stmt|;
comment|/* 	 *	if the modeline variable is set, 	 *	check the first and last five lines of the file 	 *	for a mode line. 	 */
if|if
condition|(
name|value
argument_list|(
name|MODELINE
argument_list|)
condition|)
block|{
for|for
control|(
name|a
operator|=
name|first
init|;
name|a
operator|<=
name|last
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|==
name|first
operator|+
literal|5
operator|&&
name|last
operator|-
name|first
operator|>
literal|10
condition|)
name|a
operator|=
name|last
operator|-
literal|4
expr_stmt|;
name|getline
argument_list|(
operator|*
name|a
argument_list|)
expr_stmt|;
name|checkmodeline
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|rop3
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|iostats
argument_list|()
operator|==
literal|0
operator|&&
name|c
operator|==
literal|'e'
condition|)
name|edited
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|wasalt
operator|||
name|firstpat
condition|)
block|{
specifier|register
name|line
modifier|*
name|addr
init|=
name|zero
operator|+
name|oldadot
decl_stmt|;
if|if
condition|(
name|addr
operator|>
name|dol
condition|)
name|addr
operator|=
name|dol
expr_stmt|;
if|if
condition|(
name|firstpat
condition|)
block|{
name|globp
operator|=
operator|(
operator|*
name|firstpat
operator|)
condition|?
name|firstpat
else|:
literal|"$"
expr_stmt|;
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|firstpat
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addr
operator|>=
name|one
condition|)
block|{
if|if
condition|(
name|inopen
condition|)
name|dot
operator|=
name|addr
expr_stmt|;
name|markpr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|other
goto|;
block|}
else|else
name|other
label|:
if|if
condition|(
name|dol
operator|>
name|zero
condition|)
block|{
if|if
condition|(
name|inopen
condition|)
name|dot
operator|=
name|one
expr_stmt|;
name|markpr
argument_list|(
name|one
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FIXUNDO
condition|)
name|undkind
operator|=
name|UNDNONE
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
block|{
name|vcline
operator|=
literal|0
expr_stmt|;
name|vreplace
argument_list|(
literal|0
argument_list|,
name|LINES
argument_list|,
name|lineDOL
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Are these two really the same inode?  */
end_comment

begin_macro
name|samei
argument_list|(
argument|sp
argument_list|,
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|stat
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|stb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
operator|||
name|sp
operator|->
name|st_dev
operator|!=
name|stb
operator|.
name|st_dev
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|sp
operator|->
name|st_ino
operator|==
name|stb
operator|.
name|st_ino
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Returns from edited() */
end_comment

begin_define
define|#
directive|define
name|EDF
value|0
end_define

begin_comment
comment|/* Edited file */
end_comment

begin_define
define|#
directive|define
name|NOTEDF
value|-1
end_define

begin_comment
comment|/* Not edited file */
end_comment

begin_define
define|#
directive|define
name|PARTBUF
value|1
end_define

begin_comment
comment|/* Write of partial buffer to Edited file */
end_comment

begin_comment
comment|/*  * Write a file.  */
end_comment

begin_macro
name|wop
argument_list|(
argument|dofname
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|dofname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if 1 call filename, else use savedfile */
end_comment

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|exclam
decl_stmt|,
name|nonexist
decl_stmt|;
name|line
modifier|*
name|saddr1
decl_stmt|,
modifier|*
name|saddr2
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
ifdef|#
directive|ifdef
name|FLOCKFILE
name|int
modifier|*
name|lp
decl_stmt|,
modifier|*
name|iop
decl_stmt|;
endif|#
directive|endif
endif|FLOCKFILE
name|c
operator|=
literal|0
expr_stmt|;
name|exclam
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dofname
condition|)
block|{
if|if
condition|(
name|peekchar
argument_list|()
operator|==
literal|'!'
condition|)
name|exclam
operator|++
operator|,
name|ignchar
argument_list|()
expr_stmt|;
name|ignore
argument_list|(
name|skipwh
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|peekchar
argument_list|()
operator|==
literal|'>'
condition|)
name|ignchar
argument_list|()
operator|,
name|c
operator|++
operator|,
name|ignore
argument_list|(
name|skipwh
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
operator|&&
name|c
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|"Write forms are 'w' and 'w>>'"
argument_list|)
expr_stmt|;
name|filename
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|savedfile
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No file|No current filename"
argument_list|)
expr_stmt|;
name|saddr1
operator|=
name|addr1
expr_stmt|;
name|saddr2
operator|=
name|addr2
expr_stmt|;
name|addr1
operator|=
name|one
expr_stmt|;
name|addr2
operator|=
name|dol
expr_stmt|;
name|CP
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
block|{
name|vclrech
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|splitw
operator|++
expr_stmt|;
block|}
name|lprintf
argument_list|(
literal|"\"%s\""
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|nonexist
operator|=
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOCKFILE
comment|/* 	 * if this is either the saved or alternate file or current file, 	 * point to the appropriate descriptor and file lock status. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
operator|==
literal|0
condition|)
block|{
name|lp
operator|=
operator|&
name|lock_savedfile
expr_stmt|;
name|iop
operator|=
operator|&
name|io_savedfile
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
name|altfile
argument_list|)
operator|==
literal|0
condition|)
block|{
name|lp
operator|=
operator|&
name|lock_altfile
expr_stmt|;
name|iop
operator|=
operator|&
name|io_altfile
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|=
operator|&
name|lock_curr
expr_stmt|;
name|iop
operator|=
operator|&
name|io_curr
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|iop
operator|&&
operator|!
name|nonexist
condition|)
block|{
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|iop
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
operator|*
name|iop
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
endif|FLOCKFILE
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|exclam
operator|&&
operator|(
operator|!
name|value
argument_list|(
name|WRITEANY
argument_list|)
operator|||
name|value
argument_list|(
name|READONLY
argument_list|)
operator|)
condition|)
switch|switch
condition|(
name|edfile
argument_list|()
condition|)
block|{
case|case
name|NOTEDF
case|:
if|if
condition|(
name|nonexist
condition|)
break|break;
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
condition|)
block|{
if|if
condition|(
name|samei
argument_list|(
operator|&
name|stbuf
argument_list|,
literal|"/dev/null"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|samei
argument_list|(
operator|&
name|stbuf
argument_list|,
literal|"/dev/tty"
argument_list|)
condition|)
break|break;
block|}
name|io
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|<
literal|0
condition|)
name|syserror
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|io
argument_list|)
condition|)
name|serror
argument_list|(
literal|" File exists| File exists - use \"w! %s\" to overwrite"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDF
case|:
if|if
condition|(
name|value
argument_list|(
name|READONLY
argument_list|)
condition|)
name|error
argument_list|(
literal|" File is read only"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARTBUF
case|:
if|if
condition|(
name|value
argument_list|(
name|READONLY
argument_list|)
condition|)
name|error
argument_list|(
literal|" File is read only"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|" Use \"w!\" to write partial buffer"
argument_list|)
expr_stmt|;
block|}
name|cre
label|:
comment|/* 		synctmp(); */
ifdef|#
directive|ifdef
name|FLOCKFILE
if|if
condition|(
operator|*
name|iop
operator|&&
operator|!
operator|*
name|lp
operator|!=
name|LOCK_EX
operator|&&
operator|!
name|exclam
condition|)
block|{
comment|/* 		 * upgrade to a exclusive lock. if can't get, someone else  		 * has the exclusive lock. bitch to the user. 		 */
if|if
condition|(
name|flock
argument_list|(
operator|*
name|iop
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|error
argument_list|(
literal|" File being modified by another process - use \"w!\" to write"
argument_list|)
expr_stmt|;
else|else
operator|*
name|lp
operator|=
name|LOCK_EX
expr_stmt|;
block|}
endif|#
directive|endif
endif|FLOCKFILE
ifdef|#
directive|ifdef
name|V6
name|io
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
else|#
directive|else
name|io
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|io
operator|<
literal|0
condition|)
name|syserror
argument_list|()
expr_stmt|;
name|writing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hush
operator|==
literal|0
condition|)
if|if
condition|(
name|nonexist
condition|)
name|ex_printf
argument_list|(
literal|" [New file]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
argument_list|(
name|WRITEANY
argument_list|)
operator|&&
name|edfile
argument_list|()
operator|!=
name|EDF
condition|)
name|ex_printf
argument_list|(
literal|" [Existing file]"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOCKFILE
if|if
condition|(
operator|!
operator|*
name|iop
condition|)
operator|*
name|iop
operator|=
name|dup
argument_list|(
name|io
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FLOCKFILE
break|break;
case|case
literal|2
case|:
name|io
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|exclam
operator|||
name|value
argument_list|(
name|WRITEANY
argument_list|)
condition|)
goto|goto
name|cre
goto|;
name|syserror
argument_list|()
expr_stmt|;
block|}
name|lseek
argument_list|(
name|io
argument_list|,
literal|0l
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOCKFILE
if|if
condition|(
operator|!
operator|*
name|iop
condition|)
operator|*
name|iop
operator|=
name|dup
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|lp
operator|!=
name|LOCK_EX
operator|&&
operator|!
name|exclam
condition|)
block|{
comment|/* 		 	 * upgrade to a exclusive lock. if can't get, 			 * someone else has the exclusive lock. 			 * bitch to the user. 		 	 */
if|if
condition|(
name|flock
argument_list|(
operator|*
name|iop
argument_list|,
name|LOCK_SH
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|error
argument_list|(
literal|" File being modified by another process - use \"w!>>\" to write"
argument_list|)
expr_stmt|;
else|else
operator|*
name|lp
operator|=
name|LOCK_EX
expr_stmt|;
block|}
endif|#
directive|endif
endif|FLOCKFILE
break|break;
block|}
ifdef|#
directive|ifdef
name|FLOCKFILE
if|if
condition|(
name|flock
argument_list|(
operator|*
name|iop
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|>=
literal|0
condition|)
operator|*
name|lp
operator|=
name|LOCK_EX
expr_stmt|;
endif|#
directive|endif
endif|FLOCKFILE
name|putfile
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|vms
operator|(
name|void
operator|)
name|fsync
argument_list|(
name|io
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ignore
argument_list|(
name|iostats
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|2
operator|&&
name|addr1
operator|==
name|one
operator|&&
name|addr2
operator|==
name|dol
condition|)
block|{
if|if
condition|(
name|eq
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
condition|)
name|edited
operator|=
literal|1
expr_stmt|;
name|ex_sync
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dofname
condition|)
block|{
name|addr1
operator|=
name|saddr1
expr_stmt|;
name|addr2
operator|=
name|saddr2
expr_stmt|;
block|}
name|writing
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Is file the edited file?  * Work here is that it is not considered edited  * if this is a partial buffer, and distinguish  * all cases.  */
end_comment

begin_macro
name|edfile
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|edited
operator|||
operator|!
name|eq
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
condition|)
return|return
operator|(
name|NOTEDF
operator|)
return|;
return|return
operator|(
name|addr1
operator|==
name|one
operator|&&
name|addr2
operator|==
name|dol
condition|?
name|EDF
else|:
name|PARTBUF
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Extract the next line from the io stream.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|nextip
decl_stmt|;
end_decl_stmt

begin_macro
name|getfile
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|short
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
name|fp
operator|=
name|nextip
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|--
name|ninbuf
operator|<
literal|0
condition|)
block|{
name|ninbuf
operator|=
name|read
argument_list|(
name|io
argument_list|,
name|genbuf
argument_list|,
operator|(
name|int
operator|)
name|bsize
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ninbuf
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|lp
operator|!=
name|linebuf
condition|)
block|{
name|lp
operator|++
expr_stmt|;
name|ex_printf
argument_list|(
literal|" [Incomplete last line]"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|EOF
operator|)
return|;
block|}
name|fp
operator|=
name|genbuf
expr_stmt|;
name|cntch
operator|+=
name|ninbuf
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lp
operator|>=
operator|&
name|linebuf
index|[
name|LBSIZE
index|]
condition|)
block|{
name|error
argument_list|(
literal|" Line too long"
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|cntnull
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|&
name|QUOTE
condition|)
block|{
name|cntodd
operator|++
expr_stmt|;
name|c
operator|&=
name|TRIM
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
continue|continue;
block|}
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
operator|*
operator|--
name|lp
operator|=
literal|0
expr_stmt|;
name|nextip
operator|=
name|fp
expr_stmt|;
name|cntln
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Write a range onto the io stream.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|putfile
argument_list|(
argument|isfilter
argument_list|)
end_macro

begin_decl_stmt
name|int
name|isfilter
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|line
modifier|*
name|a1
decl_stmt|;
specifier|register
name|char
modifier|*
name|fp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nib
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|a1
operator|=
name|addr1
expr_stmt|;
name|clrstats
argument_list|()
expr_stmt|;
name|cntln
operator|=
name|addr2
operator|-
name|a1
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cntln
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fstat
argument_list|(
name|io
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
name|bsize
operator|=
name|LBSIZE
expr_stmt|;
else|else
block|{
name|bsize
operator|=
name|statb
operator|.
name|st_blksize
expr_stmt|;
if|if
condition|(
name|bsize
operator|<=
literal|0
condition|)
name|bsize
operator|=
name|LBSIZE
expr_stmt|;
block|}
name|nib
operator|=
name|bsize
expr_stmt|;
name|fp
operator|=
name|genbuf
expr_stmt|;
do|do
block|{
name|getline
argument_list|(
operator|*
name|a1
operator|++
argument_list|)
expr_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|--
name|nib
operator|<
literal|0
condition|)
block|{
name|nib
operator|=
name|fp
operator|-
name|genbuf
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|io
argument_list|,
name|genbuf
argument_list|,
name|nib
argument_list|)
operator|!=
name|nib
condition|)
block|{
name|wrerror
argument_list|()
expr_stmt|;
block|}
name|cntch
operator|+=
name|nib
expr_stmt|;
name|nib
operator|=
name|bsize
operator|-
literal|1
expr_stmt|;
name|fp
operator|=
name|genbuf
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|fp
operator|++
operator|=
operator|*
name|lp
operator|++
operator|)
operator|==
literal|0
condition|)
block|{
name|fp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|a1
operator|<=
name|addr2
condition|)
do|;
name|nib
operator|=
name|fp
operator|-
name|genbuf
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|io
argument_list|,
name|genbuf
argument_list|,
name|nib
argument_list|)
operator|!=
name|nib
condition|)
block|{
name|wrerror
argument_list|()
expr_stmt|;
block|}
name|cntch
operator|+=
name|nib
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * A write error has occurred;  if the file being written was  * the edited file then we consider it to have changed since it is  * now likely scrambled.  */
end_comment

begin_macro
name|wrerror
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|eq
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
operator|&&
name|edited
condition|)
name|change
argument_list|()
expr_stmt|;
name|syserror
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Source command, handles nested sources.  * Traps errors since it mungs unit 0 during the source.  */
end_comment

begin_decl_stmt
name|short
name|slevel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ttyindes
decl_stmt|;
end_decl_stmt

begin_macro
name|source
argument_list|(
argument|fil
argument_list|,
argument|okfail
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|okfail
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|jmp_buf
name|osetexit
decl_stmt|;
specifier|register
name|int
name|saveinp
decl_stmt|,
name|ointty
decl_stmt|,
name|oerrno
decl_stmt|;
name|char
modifier|*
name|saveglobp
decl_stmt|;
name|short
name|savepeekc
decl_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|saveinp
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|savepeekc
operator|=
name|peekc
expr_stmt|;
name|saveglobp
operator|=
name|globp
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
name|globp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|saveinp
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Too many nested sources"
argument_list|)
expr_stmt|;
if|if
condition|(
name|slevel
operator|<=
literal|0
condition|)
name|ttyindes
operator|=
name|saveinp
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
name|fil
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
name|setrupt
argument_list|()
expr_stmt|;
name|dup
argument_list|(
name|saveinp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|saveinp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
if|if
condition|(
operator|!
name|okfail
condition|)
name|filioerr
argument_list|(
name|fil
argument_list|)
expr_stmt|;
return|return;
block|}
name|slevel
operator|++
expr_stmt|;
name|ointty
operator|=
name|intty
expr_stmt|;
name|intty
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|oprompt
operator|=
name|value
argument_list|(
name|PROMPT
argument_list|)
expr_stmt|;
name|value
argument_list|(
name|PROMPT
argument_list|)
operator|&=
name|intty
expr_stmt|;
name|getexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
name|setrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|setexit
argument_list|()
operator|==
literal|0
condition|)
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|slevel
operator|>
literal|1
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|saveinp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|saveinp
argument_list|)
expr_stmt|;
name|slevel
operator|--
expr_stmt|;
name|resexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
name|intty
operator|=
name|ointty
expr_stmt|;
name|value
argument_list|(
name|PROMPT
argument_list|)
operator|=
name|oprompt
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|saveinp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|saveinp
argument_list|)
expr_stmt|;
name|globp
operator|=
name|saveglobp
expr_stmt|;
name|peekc
operator|=
name|savepeekc
expr_stmt|;
name|slevel
operator|--
expr_stmt|;
name|resexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Clear io statistics before a read or write.  */
end_comment

begin_macro
name|clrstats
argument_list|()
end_macro

begin_block
block|{
name|ninbuf
operator|=
literal|0
expr_stmt|;
name|cntch
operator|=
literal|0
expr_stmt|;
name|cntln
operator|=
literal|0
expr_stmt|;
name|cntnull
operator|=
literal|0
expr_stmt|;
name|cntodd
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Io is finished, close the unit and print statistics.  */
end_comment

begin_macro
name|iostats
argument_list|()
end_macro

begin_block
block|{
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|hush
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
argument_list|(
name|TERSE
argument_list|)
condition|)
name|ex_printf
argument_list|(
literal|" %d/%D"
argument_list|,
name|cntln
argument_list|,
name|cntch
argument_list|)
expr_stmt|;
else|else
name|ex_printf
argument_list|(
literal|" %d line%s, %D character%s"
argument_list|,
name|cntln
argument_list|,
name|plural
argument_list|(
operator|(
name|long
operator|)
name|cntln
argument_list|)
argument_list|,
name|cntch
argument_list|,
name|plural
argument_list|(
name|cntch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntnull
operator|||
name|cntodd
condition|)
block|{
name|ex_printf
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntnull
condition|)
block|{
name|ex_printf
argument_list|(
literal|"%D null"
argument_list|,
name|cntnull
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntodd
condition|)
name|ex_printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cntodd
condition|)
name|ex_printf
argument_list|(
literal|"%D non-ASCII"
argument_list|,
name|cntodd
argument_list|)
expr_stmt|;
name|ex_putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
name|noonl
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|cntnull
operator|!=
literal|0
operator|||
name|cntodd
operator|!=
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_define
define|#
directive|define
name|rindex
value|strrchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG3TTY
end_ifdef

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_define
define|#
directive|define
name|rindex
value|strrchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vms
end_ifdef

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_define
define|#
directive|define
name|rindex
value|strrchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|checkmodeline
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|beg
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
name|cmdbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|strncpy
argument_list|()
decl_stmt|;
name|beg
operator|=
name|index
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|beg
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|&
name|beg
index|[
operator|-
literal|3
index|]
operator|<
name|line
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|beg
index|[
operator|-
literal|3
index|]
operator|==
literal|' '
operator|||
name|beg
index|[
operator|-
literal|3
index|]
operator|==
literal|'\t'
operator|)
operator|&&
name|beg
index|[
operator|-
literal|2
index|]
operator|==
literal|'e'
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|==
literal|'x'
operator|)
operator|||
operator|(
operator|(
name|beg
index|[
operator|-
literal|3
index|]
operator|==
literal|' '
operator|||
name|beg
index|[
operator|-
literal|3
index|]
operator|==
literal|'\t'
operator|)
operator|&&
name|beg
index|[
operator|-
literal|2
index|]
operator|==
literal|'v'
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|==
literal|'i'
operator|)
operator|)
condition|)
return|return;
name|strncpy
argument_list|(
name|cmdbuf
argument_list|,
name|beg
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|cmdbuf
argument_list|)
expr_stmt|;
name|end
operator|=
name|rindex
argument_list|(
name|cmdbuf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
return|return;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|globp
operator|=
name|cmdbuf
expr_stmt|;
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

