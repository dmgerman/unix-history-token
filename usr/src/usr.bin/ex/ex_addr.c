begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This module is believed to contain source code proprietary to AT&T.  * Use and redistribution is subject to the Berkeley Software License  * Agreement and your Software Agreement with AT&T (Western Electric).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ex_addr.c	8.1 (Berkeley) 6/9/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_re.h"
end_include

begin_comment
comment|/*  * Routines for address parsing and assignment and checking of address bounds  * in command mode.  The routine address is called from ex_cmds.c  * to parse each component of a command (terminated by , ; or the beginning  * of the command itself.  It is also called by the scanning routine  * in ex_voperate.c from within open/visual.  *  * Other routines here manipulate the externals addr1 and addr2.  * These are the first and last lines for the current command.  *  * The variable bigmove remembers whether a non-local glitch of . was  * involved in an address expression, so we can set the previous context  * mark '' when such a motion occurs.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|bigmove
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set up addr1 and addr2 for commands whose default address is dot.  */
end_comment

begin_macro
name|setdot
argument_list|()
end_macro

begin_block
block|{
name|setdot1
argument_list|()
expr_stmt|;
if|if
condition|(
name|bigmove
condition|)
name|markDOT
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Call setdot1 to set up default addresses without ever  * setting the previous context mark.  */
end_comment

begin_macro
name|setdot1
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|addr2
operator|==
literal|0
condition|)
name|addr1
operator|=
name|addr2
operator|=
name|dot
expr_stmt|;
if|if
condition|(
name|addr1
operator|>
name|addr2
condition|)
block|{
name|notempty
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Addr1> addr2|First address exceeds second"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Ex allows you to say  *	delete 5  * to delete 5 lines, etc.  * Such nonsense is implemented by setcount.  */
end_comment

begin_macro
name|setcount
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
name|pastwh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|)
block|{
name|setdot
argument_list|()
expr_stmt|;
return|return;
block|}
name|addr1
operator|=
name|addr2
expr_stmt|;
name|setdot
argument_list|()
expr_stmt|;
name|cnt
operator|=
name|getnum
argument_list|()
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"Bad count|Nonzero count required"
argument_list|)
expr_stmt|;
name|addr2
operator|+=
name|cnt
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|addr2
operator|>
name|dol
condition|)
name|addr2
operator|=
name|dol
expr_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Parse a number out of the command input stream.  */
end_comment

begin_macro
name|getnum
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|isdigit
argument_list|(
name|peekcd
argument_list|()
argument_list|)
condition|;
control|)
name|cnt
operator|=
name|cnt
operator|*
literal|10
operator|+
name|ex_getchar
argument_list|()
operator|-
literal|'0'
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Set the default addresses for commands which use the whole  * buffer as default, notably write.  */
end_comment

begin_macro
name|setall
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|addr2
operator|==
literal|0
condition|)
block|{
name|addr1
operator|=
name|one
expr_stmt|;
name|addr2
operator|=
name|dol
expr_stmt|;
if|if
condition|(
name|dol
operator|==
name|zero
condition|)
block|{
name|dot
operator|=
name|zero
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Don't want to set previous context mark so use setdot1(). 	 */
name|setdot1
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * No address allowed on, e.g. the file command.  */
end_comment

begin_macro
name|setnoaddr
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|addr2
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"No address allowed@on this command"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Parse an address.  * Just about any sequence of address characters is legal.  *  * If you are tricky you can use this routine and the = command  * to do simple addition and subtraction of cardinals less  * than the number of lines in the file.  */
end_comment

begin_function
name|line
modifier|*
name|address
parameter_list|(
name|inputline
parameter_list|)
name|char
modifier|*
name|inputline
decl_stmt|;
block|{
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|,
name|c
decl_stmt|;
name|short
name|lastsign
decl_stmt|;
name|bigmove
operator|=
literal|0
expr_stmt|;
name|lastsign
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|peekcd
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|addr
operator|=
name|zero
expr_stmt|;
name|bigmove
operator|=
literal|1
expr_stmt|;
block|}
name|loc1
operator|=
literal|0
expr_stmt|;
name|addr
operator|+=
name|offset
expr_stmt|;
name|offset
operator|=
name|getnum
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastsign
operator|>=
literal|0
condition|)
name|addr
operator|+=
name|offset
expr_stmt|;
else|else
name|addr
operator|-=
name|offset
expr_stmt|;
name|lastsign
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|c
operator|=
name|getcd
argument_list|()
condition|)
block|{
case|case
literal|'?'
case|:
case|case
literal|'/'
case|:
case|case
literal|'$'
case|:
case|case
literal|'\''
case|:
case|case
literal|'\\'
case|:
name|bigmove
operator|++
expr_stmt|;
case|case
literal|'.'
case|:
if|if
condition|(
name|addr
operator|||
name|offset
condition|)
name|error
argument_list|(
literal|"Badly formed address"
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|lastsign
expr_stmt|;
name|lastsign
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
continue|continue;
case|case
literal|'+'
case|:
name|lastsign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|dot
expr_stmt|;
continue|continue;
case|case
literal|'^'
case|:
case|case
literal|'-'
case|:
name|lastsign
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|dot
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
case|case
literal|'?'
case|:
case|case
literal|'/'
case|:
name|c
operator|=
name|compile
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|notempty
argument_list|()
expr_stmt|;
name|savere
argument_list|(
name|scanre
argument_list|)
expr_stmt|;
name|addr
operator|=
name|dot
expr_stmt|;
if|if
condition|(
name|inputline
operator|&&
name|execute
argument_list|(
literal|0
argument_list|,
name|dot
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
while|while
condition|(
name|loc1
operator|<=
name|inputline
condition|)
block|{
if|if
condition|(
name|loc1
operator|==
name|loc2
condition|)
name|loc2
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|execute
argument_list|(
literal|1
argument_list|)
condition|)
goto|goto
name|nope
goto|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|loc1
operator|<
name|inputline
condition|)
block|{
name|char
modifier|*
name|last
decl_stmt|;
name|doques
label|:
do|do
block|{
name|last
operator|=
name|loc1
expr_stmt|;
if|if
condition|(
name|loc1
operator|==
name|loc2
condition|)
name|loc2
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|execute
argument_list|(
literal|1
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|loc1
operator|<
name|inputline
condition|)
do|;
name|loc1
operator|=
name|last
expr_stmt|;
break|break;
block|}
block|}
name|nope
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|addr
operator|++
expr_stmt|;
if|if
condition|(
name|addr
operator|>
name|dol
condition|)
block|{
if|if
condition|(
name|value
argument_list|(
name|WRAPSCAN
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No match to BOTTOM|Address search hit BOTTOM without matching pattern"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|zero
expr_stmt|;
block|}
block|}
else|else
block|{
name|addr
operator|--
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|zero
condition|)
block|{
if|if
condition|(
name|value
argument_list|(
name|WRAPSCAN
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No match to TOP|Address search hit TOP without matching pattern"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|dol
expr_stmt|;
block|}
block|}
if|if
condition|(
name|execute
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|inputline
operator|&&
name|c
operator|==
literal|'?'
condition|)
block|{
name|inputline
operator|=
operator|&
name|linebuf
index|[
name|LBSIZE
index|]
expr_stmt|;
goto|goto
name|doques
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|addr
operator|==
name|dot
condition|)
name|error
argument_list|(
literal|"Fail|Pattern not found"
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
literal|'$'
case|:
name|addr
operator|=
name|dol
expr_stmt|;
continue|continue;
case|case
literal|'.'
case|:
name|addr
operator|=
name|dot
expr_stmt|;
continue|continue;
case|case
literal|'\''
case|:
name|c
operator|=
name|markreg
argument_list|(
name|ex_getchar
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Marks are ' and a-z"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|getmark
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Undefined mark@referenced"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|dot
expr_stmt|;
name|addr
operator|+=
name|offset
expr_stmt|;
name|loc1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|bigmove
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|addr
operator|!=
name|zero
condition|)
name|notempty
argument_list|()
expr_stmt|;
name|addr
operator|+=
name|lastsign
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|zero
condition|)
name|error
argument_list|(
literal|"Negative address@- first buffer line is 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>
name|dol
condition|)
name|error
argument_list|(
literal|"Not that many lines@in buffer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Abbreviations to make code smaller  * Left over from squashing ex version 1.1 into  * 11/34's and 11/40's.  */
end_comment

begin_macro
name|setCNL
argument_list|()
end_macro

begin_block
block|{
name|setcount
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|setNAEOL
argument_list|()
end_macro

begin_block
block|{
name|setnoaddr
argument_list|()
expr_stmt|;
name|eol
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

