begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Input routines for open/visual.  * We handle upper case only terminals in visual and reading from the  * echo area here as well as notification on large changes  * which appears in the echo area.  */
end_comment

begin_comment
comment|/*  * Return the key.  */
end_comment

begin_macro
name|ungetkey
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Peekkey
operator|!=
name|ATTN
condition|)
name|Peekkey
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return a keystroke, but never a ^@.  */
end_comment

begin_macro
name|getkey
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|getbr
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|beep
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|==
literal|0
condition|)
do|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Tell whether next keystroke would be a ^@.  */
end_comment

begin_macro
name|peekbr
argument_list|()
end_macro

begin_block
block|{
name|Peekkey
operator|=
name|getbr
argument_list|()
expr_stmt|;
return|return
operator|(
name|Peekkey
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|short
name|precbksl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get a keystroke, including a ^@.  * If an key was returned with ungetkey, that  * comes back first.  Next comes unread input (e.g.  * from repeating commands with .), and finally new  * keystrokes.  *  * The hard work here is in mapping of \ escaped  * characters on upper case only terminals.  */
end_comment

begin_macro
name|getbr
argument_list|()
end_macro

begin_block
block|{
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|colp
decl_stmt|;
name|getATTN
label|:
if|if
condition|(
name|Peekkey
condition|)
block|{
name|c
operator|=
name|Peekkey
expr_stmt|;
name|Peekkey
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
if|if
condition|(
name|vglobp
condition|)
block|{
if|if
condition|(
operator|*
name|vglobp
condition|)
return|return
operator|(
name|lastvgk
operator|=
operator|*
name|vglobp
operator|++
operator|)
return|;
name|lastvgk
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ESCAPE
operator|)
return|;
block|}
if|if
condition|(
name|vmacp
condition|)
block|{
if|if
condition|(
operator|*
name|vmacp
condition|)
return|return
operator|(
operator|*
name|vmacp
operator|++
operator|)
return|;
comment|/* End of a macro or set of nested macros */
name|vmacp
operator|=
literal|0
expr_stmt|;
name|inopen
operator|=
literal|1
expr_stmt|;
comment|/* restore old setting now that macro done */
name|vundkind
operator|=
name|VMANY
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|fflush
argument_list|(
name|trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flusho
argument_list|()
expr_stmt|;
name|again
label|:
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|getATTN
goto|;
name|error
argument_list|(
literal|"Input read error"
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|ch
operator|&
name|TRIM
expr_stmt|;
ifdef|#
directive|ifdef
name|UCVISUAL
comment|/* 	 * The algorithm here is that of the UNIX kernel. 	 * See the description in the programmers manual. 	 */
if|if
condition|(
name|UPPERCASE
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|precbksl
operator|<
literal|2
condition|)
name|precbksl
operator|++
expr_stmt|;
if|if
condition|(
name|precbksl
operator|==
literal|1
condition|)
goto|goto
name|again
goto|;
block|}
elseif|else
if|if
condition|(
name|precbksl
condition|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|d
operator|=
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|colp
operator|=
literal|"({)}!|^~'~"
expr_stmt|;
while|while
condition|(
name|d
operator|=
operator|*
name|colp
operator|++
condition|)
if|if
condition|(
name|d
operator|==
name|c
condition|)
block|{
name|d
operator|=
operator|*
name|colp
operator|++
expr_stmt|;
break|break;
block|}
else|else
name|colp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|precbksl
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|Peekkey
operator|=
name|c
expr_stmt|;
name|precbksl
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|'\\'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
condition|)
name|c
operator|=
name|d
expr_stmt|;
else|else
block|{
name|Peekkey
operator|=
name|c
expr_stmt|;
name|precbksl
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|'\\'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
name|precbksl
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
block|{
if|if
condition|(
operator|!
name|techoin
condition|)
block|{
name|tfixnl
argument_list|()
expr_stmt|;
name|techoin
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"*** Input: "
argument_list|)
expr_stmt|;
block|}
name|tracec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|lastvgk
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get a key, but if a delete, quit or attention  * is typed return 0 so we will abort a partial command.  */
end_comment

begin_macro
name|getesc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ATTN
case|:
case|case
name|QUIT
case|:
name|ungetkey
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ESCAPE
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Peek at the next keystroke.  */
end_comment

begin_macro
name|peekkey
argument_list|()
end_macro

begin_block
block|{
name|Peekkey
operator|=
name|getkey
argument_list|()
expr_stmt|;
return|return
operator|(
name|Peekkey
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read a line from the echo area, with single character prompt c.  * A return value of 1 means the user blewit or blewit away.  */
end_comment

begin_macro
name|readecho
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|sc
init|=
name|cursor
decl_stmt|;
specifier|register
name|int
function_decl|(
modifier|*
name|OP
function_decl|)
parameter_list|()
function_decl|;
name|bool
name|waste
decl_stmt|;
specifier|register
name|int
name|OPeek
decl_stmt|;
if|if
condition|(
name|WBOT
operator|==
name|WECHO
condition|)
name|vclean
argument_list|()
expr_stmt|;
else|else
name|vclrech
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|splitw
operator|++
expr_stmt|;
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|linebuf
expr_stmt|;
name|linebuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|genbuf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|peekbr
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|INS
index|[
literal|0
index|]
operator|||
operator|(
name|INS
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|OVERBUF
condition|)
goto|goto
name|blewit
goto|;
name|vglobp
operator|=
name|INS
expr_stmt|;
block|}
name|OP
operator|=
name|Pline
expr_stmt|;
name|Pline
operator|=
name|normline
expr_stmt|;
name|ignore
argument_list|(
name|vgetline
argument_list|(
literal|0
argument_list|,
name|genbuf
operator|+
literal|1
argument_list|,
operator|&
name|waste
argument_list|)
argument_list|)
expr_stmt|;
name|vscrap
argument_list|()
expr_stmt|;
name|Pline
operator|=
name|OP
expr_stmt|;
if|if
condition|(
name|Peekkey
operator|!=
name|ATTN
operator|&&
name|Peekkey
operator|!=
name|QUIT
operator|&&
name|Peekkey
operator|!=
name|CTRL
argument_list|(
name|h
argument_list|)
condition|)
block|{
name|cursor
operator|=
name|sc
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|blewit
label|:
name|OPeek
operator|=
name|Peekkey
operator|==
name|CTRL
argument_list|(
name|h
argument_list|)
condition|?
literal|0
else|:
name|Peekkey
expr_stmt|;
name|Peekkey
operator|=
literal|0
expr_stmt|;
name|splitw
operator|=
literal|0
expr_stmt|;
name|vclean
argument_list|()
expr_stmt|;
name|vshow
argument_list|(
name|dot
argument_list|,
name|NOLINE
argument_list|)
expr_stmt|;
name|vnline
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|Peekkey
operator|=
name|OPeek
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * A complete command has been defined for  * the purposes of repeat, so copy it from  * the working to the previous command buffer.  */
end_comment

begin_macro
name|setLAST
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|vglobp
condition|)
return|return;
name|lastreg
operator|=
name|vreg
expr_stmt|;
name|lasthad
operator|=
name|Xhadcnt
expr_stmt|;
name|lastcnt
operator|=
name|Xcnt
expr_stmt|;
operator|*
name|lastcp
operator|=
literal|0
expr_stmt|;
name|CP
argument_list|(
name|lastcmd
argument_list|,
name|workcmd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Gather up some more text from an insert.  * If the insertion buffer oveflows, then destroy  * the repeatability of the insert.  */
end_comment

begin_macro
name|addtext
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|vglobp
condition|)
return|return;
name|addto
argument_list|(
name|INS
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INS
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|OVERBUF
condition|)
name|lastcmd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|setDEL
argument_list|()
end_macro

begin_block
block|{
name|setBUF
argument_list|(
name|DEL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Put text from cursor upto wcursor in BUF.  */
end_comment

begin_expr_stmt
name|setBUF
argument_list|(
name|BUF
argument_list|)
specifier|register
name|char
operator|*
name|BUF
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|wp
init|=
name|wcursor
decl_stmt|;
name|c
operator|=
operator|*
name|wp
expr_stmt|;
operator|*
name|wp
operator|=
literal|0
expr_stmt|;
name|BUF
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|addto
argument_list|(
name|BUF
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
operator|*
name|wp
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|addto
argument_list|(
name|buf
argument_list|,
name|str
argument_list|)
specifier|register
name|char
operator|*
name|buf
operator|,
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|OVERBUF
condition|)
return|return;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
operator|>=
name|VBSIZE
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|OVERBUF
expr_stmt|;
return|return;
block|}
name|ignore
argument_list|(
name|strcat
argument_list|(
name|buf
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Note a change affecting a lot of lines, or non-visible  * lines.  If the parameter must is set, then we only want  * to do this for open modes now; return and save for later  * notification in visual.  */
end_comment

begin_macro
name|noteit
argument_list|(
argument|must
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|must
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|sdl
init|=
name|destline
decl_stmt|,
name|sdc
init|=
name|destcol
decl_stmt|;
if|if
condition|(
name|notecnt
operator|<
literal|2
operator|||
operator|!
name|must
operator|&&
name|state
operator|==
name|VISUAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|splitw
operator|++
expr_stmt|;
if|if
condition|(
name|WBOT
operator|==
name|WECHO
condition|)
name|vmoveitup
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vigoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d %sline"
argument_list|,
name|notecnt
argument_list|,
name|notesgn
argument_list|)
expr_stmt|;
if|if
condition|(
name|notecnt
operator|>
literal|1
condition|)
name|putchar
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|notenam
condition|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|notenam
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|strend
argument_list|(
name|notenam
argument_list|)
operator|-
literal|1
operator|)
operator|!=
literal|'e'
condition|)
name|putchar
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
block|}
name|vclreol
argument_list|()
expr_stmt|;
name|notecnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
name|vcnt
operator|=
name|vcline
operator|=
literal|0
expr_stmt|;
name|splitw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|ONEOPEN
operator|||
name|state
operator|==
name|CRTOPEN
condition|)
name|vup1
argument_list|()
expr_stmt|;
name|destline
operator|=
name|sdl
expr_stmt|;
name|destcol
operator|=
name|sdc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Rrrrringgggggg.  * If possible, use flash (VB).  */
end_comment

begin_macro
name|beep
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|VB
condition|)
name|vputp
argument_list|(
name|VB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vputc
argument_list|(
name|CTRL
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Map the command input character c,  * for keypads and labelled keys which do cursor  * motions.  I.e. on an adm3a we might map ^K to ^P.  * DM1520 for example has a lot of mappable characters.  */
end_comment

begin_expr_stmt
name|map
argument_list|(
name|c
argument_list|,
name|maps
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|maps
modifier|*
name|maps
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|b
index|[
literal|10
index|]
decl_stmt|;
comment|/* Assumption: no keypad sends string longer than 10 */
comment|/* 	 * Mapping for special keys on the terminal only. 	 * BUG: if there's a long sequence and it matches 	 * some chars and then misses, we lose some chars. 	 * 	 * For this to work, some conditions must be met. 	 * 1) Keypad sends SHORT (2 or 3 char) strings 	 * 2) All strings sent are same length& similar 	 * 3) The user is unlikely to type the first few chars of 	 *    one of these strings very fast. 	 * Note: some code has been fixed up since the above was laid out, 	 * so conditions 1& 2 are probably not required anymore. 	 * However, this hasn't been tested with any first char 	 * that means anything else except escape. 	 */
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"map(%c): "
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|b
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|maps
index|[
name|d
index|]
operator|.
name|mapto
condition|;
name|d
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"d=%d, "
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|=
name|maps
index|[
name|d
index|]
operator|.
name|cap
condition|)
block|{
for|for
control|(
name|q
operator|=
name|b
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"q->b[%d], "
argument_list|,
name|q
operator|-
name|b
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
block|{
comment|/* 					 * This test is oversimplified, but 					 * should work mostly. It handles the 					 * case where we get an ESCAPE that 					 * wasn't part of a keypad string. 					 */
if|if
condition|(
operator|(
name|c
operator|==
literal|'#'
condition|?
name|peekkey
argument_list|()
else|:
name|fastpeekkey
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"fpk=0: return %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|macpush
argument_list|(
operator|&
name|b
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
operator|*
name|q
operator|=
name|getkey
argument_list|()
expr_stmt|;
name|q
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
operator|*
name|q
condition|)
goto|goto
name|contin
goto|;
block|}
name|macpush
argument_list|(
name|maps
index|[
name|d
index|]
operator|.
name|mapto
argument_list|)
expr_stmt|;
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"Success: return %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|c
operator|)
return|;
comment|/* first char of map string */
name|contin
label|:
empty_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"Fail: return %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* DEBUG */
endif|#
directive|endif
name|macpush
argument_list|(
operator|&
name|b
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Push st onto the front of vmacp. This is tricky because we have to  * worry about where vmacp was previously pointing. We also have to  * check for overflow (which is typically from a recursive macro)  * Finally we have to set a flag so the whole thing can be undone.  */
end_comment

begin_macro
name|macpush
argument_list|(
argument|st
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|st
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|tmpbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|st
operator|==
literal|0
operator|||
operator|*
name|st
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"macpush(%s)"
argument_list|,
name|st
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strlen
argument_list|(
name|vmacp
argument_list|)
operator|+
name|strlen
argument_list|(
name|st
argument_list|)
operator|>
name|BUFSIZ
condition|)
name|error
argument_list|(
literal|"Macro too long@ - maybe recursive?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmacp
condition|)
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|vmacp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|vmacbuf
argument_list|,
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmacp
condition|)
name|strcat
argument_list|(
name|vmacbuf
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|vmacp
operator|=
name|vmacbuf
expr_stmt|;
comment|/* arrange to be able to undo the whole macro */
name|inopen
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no need to save since it had to be 1 or -1 before */
name|otchng
operator|=
name|tchng
expr_stmt|;
name|saveall
argument_list|()
expr_stmt|;
name|vundkind
operator|=
name|VMANY
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"saveall for macro: undkind=%d, unddel=%d, undap1=%d, undap2=%d, dol=%d, unddol=%d, truedol=%d\n"
argument_list|,
name|undkind
argument_list|,
name|lineno
argument_list|(
name|unddel
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|undap1
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|undap2
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|dol
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|unddol
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|truedol
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Get a count from the keyed input stream.  * A zero count is indistinguishable from no count.  */
end_comment

begin_macro
name|vgetcnt
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|cnt
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|cnt
operator|*=
literal|10
operator|,
name|cnt
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
name|ungetkey
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|Xhadcnt
operator|=
literal|1
expr_stmt|;
name|Xcnt
operator|=
name|cnt
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * fastpeekkey is just like peekkey but insists the character come in  * fast (within 1 second). This will succeed if it is the 2nd char of  * a machine generated sequence (such as a function pad from an escape  * flavor terminal) but fail for a human hitting escape then waiting.  */
end_comment

begin_macro
name|fastpeekkey
argument_list|()
end_macro

begin_block
block|{
name|int
name|trapalarm
parameter_list|()
function_decl|;
specifier|register
name|int
name|c
decl_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|trapalarm
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CATCH
name|c
init|=
name|peekkey
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"[OK]"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ONERR
name|c
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"[TOUT]"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ENDCATCH
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"[fpk:%o]"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_macro
name|trapalarm
argument_list|()
end_macro

begin_block
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|vreslab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

