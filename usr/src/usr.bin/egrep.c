begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|CHAR
value|257
end_define

begin_define
define|#
directive|define
name|DOT
value|258
end_define

begin_define
define|#
directive|define
name|CCL
value|259
end_define

begin_define
define|#
directive|define
name|NCCL
value|260
end_define

begin_define
define|#
directive|define
name|OR
value|261
end_define

begin_define
define|#
directive|define
name|CAT
value|262
end_define

begin_define
define|#
directive|define
name|STAR
value|263
end_define

begin_define
define|#
directive|define
name|PLUS
value|264
end_define

begin_define
define|#
directive|define
name|QUEST
value|265
end_define

begin_line
line|#
directive|line
number|16
file|"egrep.y"
end_line

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)egrep.y	4.2 (Berkeley) 11/8/82"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|MAXLIN
value|350
end_define

begin_define
define|#
directive|define
name|MAXPOS
value|4000
end_define

begin_define
define|#
directive|define
name|NCHARS
value|128
end_define

begin_define
define|#
directive|define
name|NSTATES
value|128
end_define

begin_define
define|#
directive|define
name|FINAL
value|-1
end_define

begin_decl_stmt
name|char
name|gotofn
index|[
name|NSTATES
index|]
index|[
name|NCHARS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|state
index|[
name|NSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|out
index|[
name|NSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|name
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|left
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|right
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|parent
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|foll
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|positions
index|[
name|MAXPOS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|chars
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nxtpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nxtchar
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tmpstat
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|initstat
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|icount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|exprfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|lnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hflag
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|blkno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|tln
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsucc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|yyclearin
value|yychar = -1
end_define

begin_define
define|#
directive|define
name|yyerrok
value|yyerrflag = 0
end_define

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|yyerrflag
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|YYMAXDEPTH
end_ifndef

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|150
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YYSTYPE
end_ifndef

begin_define
define|#
directive|define
name|YYSTYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|YYSTYPE
name|yylval
decl_stmt|,
name|yyval
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYERRCODE
value|256
end_define

begin_line
line|#
directive|line
number|107
file|"egrep.y"
end_line

begin_macro
name|yyerror
argument_list|(
argument|s
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"egrep: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|yylex
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|yylval
decl_stmt|;
name|int
name|cclcnt
decl_stmt|,
name|x
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
name|d
decl_stmt|;
switch|switch
condition|(
name|c
operator|=
name|nextch
argument_list|()
condition|)
block|{
case|case
literal|'$'
case|:
case|case
literal|'^'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|defchar
goto|;
case|case
literal|'|'
case|:
return|return
operator|(
name|OR
operator|)
return|;
case|case
literal|'*'
case|:
return|return
operator|(
name|STAR
operator|)
return|;
case|case
literal|'+'
case|:
return|return
operator|(
name|PLUS
operator|)
return|;
case|case
literal|'?'
case|:
return|return
operator|(
name|QUEST
operator|)
return|;
case|case
literal|'('
case|:
return|return
operator|(
name|c
operator|)
return|;
case|case
literal|')'
case|:
return|return
operator|(
name|c
operator|)
return|;
case|case
literal|'.'
case|:
return|return
operator|(
name|DOT
operator|)
return|;
case|case
literal|'\0'
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\n'
case|:
return|return
operator|(
name|OR
operator|)
return|;
case|case
literal|'['
case|:
name|x
operator|=
name|CCL
expr_stmt|;
name|cclcnt
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|nxtchar
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|nextch
argument_list|()
operator|)
operator|==
literal|'^'
condition|)
block|{
name|x
operator|=
name|NCCL
expr_stmt|;
name|c
operator|=
name|nextch
argument_list|()
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|synerror
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|cclcnt
operator|>
literal|0
operator|&&
name|chars
index|[
name|nxtchar
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|=
name|nextch
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
name|chars
index|[
name|nxtchar
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|c
operator|<
name|d
condition|)
block|{
if|if
condition|(
name|nxtchar
operator|>=
name|MAXLIN
condition|)
name|overflo
argument_list|()
expr_stmt|;
name|chars
index|[
name|nxtchar
operator|++
index|]
operator|=
operator|++
name|c
expr_stmt|;
name|cclcnt
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
block|}
if|if
condition|(
name|nxtchar
operator|>=
name|MAXLIN
condition|)
name|overflo
argument_list|()
expr_stmt|;
name|chars
index|[
name|nxtchar
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|cclcnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|nextch
argument_list|()
operator|)
operator|!=
literal|']'
condition|)
do|;
name|chars
index|[
name|count
index|]
operator|=
name|cclcnt
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|nextch
argument_list|()
operator|)
operator|==
literal|'\0'
condition|)
name|synerror
argument_list|()
expr_stmt|;
name|defchar
label|:
default|default:
name|yylval
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|CHAR
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|nextch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|exprfile
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
name|fclose
argument_list|(
name|exprfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
name|c
operator|=
operator|*
name|input
operator|++
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_macro
name|synerror
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"egrep: syntax error\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|enter
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|line
operator|>=
name|MAXLIN
condition|)
name|overflo
argument_list|()
expr_stmt|;
name|name
index|[
name|line
index|]
operator|=
name|x
expr_stmt|;
name|left
index|[
name|line
index|]
operator|=
literal|0
expr_stmt|;
name|right
index|[
name|line
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|line
operator|++
operator|)
return|;
block|}
end_block

begin_macro
name|cclenter
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|linno
expr_stmt|;
name|linno
operator|=
name|enter
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|right
index|[
name|linno
index|]
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|linno
operator|)
return|;
block|}
end_block

begin_macro
name|node
argument_list|(
argument|x
argument_list|,
argument|l
argument_list|,
argument|r
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|line
operator|>=
name|MAXLIN
condition|)
name|overflo
argument_list|()
expr_stmt|;
name|name
index|[
name|line
index|]
operator|=
name|x
expr_stmt|;
name|left
index|[
name|line
index|]
operator|=
name|l
expr_stmt|;
name|right
index|[
name|line
index|]
operator|=
name|r
expr_stmt|;
name|parent
index|[
name|l
index|]
operator|=
name|line
expr_stmt|;
name|parent
index|[
name|r
index|]
operator|=
name|line
expr_stmt|;
return|return
operator|(
name|line
operator|++
operator|)
return|;
block|}
end_block

begin_macro
name|unary
argument_list|(
argument|x
argument_list|,
argument|d
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|line
operator|>=
name|MAXLIN
condition|)
name|overflo
argument_list|()
expr_stmt|;
name|name
index|[
name|line
index|]
operator|=
name|x
expr_stmt|;
name|left
index|[
name|line
index|]
operator|=
name|d
expr_stmt|;
name|right
index|[
name|line
index|]
operator|=
literal|0
expr_stmt|;
name|parent
index|[
name|d
index|]
operator|=
name|line
expr_stmt|;
return|return
operator|(
name|line
operator|++
operator|)
return|;
block|}
end_block

begin_macro
name|overflo
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"egrep: regular expression too long\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cfoll
argument_list|(
argument|v
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|left
index|[
name|v
index|]
operator|==
literal|0
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|line
condition|;
name|i
operator|++
control|)
name|tmpstat
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|follow
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|foll
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|right
index|[
name|v
index|]
operator|==
literal|0
condition|)
name|cfoll
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|cfoll
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
expr_stmt|;
name|cfoll
argument_list|(
name|right
index|[
name|v
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|cgotofn
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
operator|,
name|i
operator|,
name|k
expr_stmt|;
name|int
name|n
decl_stmt|,
name|s
decl_stmt|;
name|char
name|symbol
index|[
name|NCHARS
index|]
decl_stmt|;
name|int
name|j
decl_stmt|,
name|nc
decl_stmt|,
name|pc
decl_stmt|,
name|pos
decl_stmt|;
name|int
name|curpos
decl_stmt|,
name|num
decl_stmt|;
name|int
name|number
decl_stmt|,
name|newpos
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|3
init|;
name|n
operator|<=
name|line
condition|;
name|n
operator|++
control|)
name|tmpstat
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cstate
argument_list|(
name|line
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tmpstat
index|[
name|line
index|]
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|3
init|;
name|n
operator|<=
name|line
condition|;
name|n
operator|++
control|)
name|initstat
index|[
name|n
index|]
operator|=
name|tmpstat
index|[
name|n
index|]
expr_stmt|;
name|count
operator|--
expr_stmt|;
comment|/*leave out position 1 */
name|icount
operator|=
name|count
expr_stmt|;
name|tmpstat
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|add
argument_list|(
name|state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|n
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|out
index|[
name|s
index|]
operator|==
literal|1
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
name|symbol
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|num
operator|=
name|positions
index|[
name|state
index|[
name|s
index|]
index|]
expr_stmt|;
name|count
operator|=
name|icount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|line
condition|;
name|i
operator|++
control|)
name|tmpstat
index|[
name|i
index|]
operator|=
name|initstat
index|[
name|i
index|]
expr_stmt|;
name|pos
operator|=
name|state
index|[
name|s
index|]
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|curpos
operator|=
name|positions
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|name
index|[
name|curpos
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|<
name|NCHARS
condition|)
name|symbol
index|[
name|c
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|DOT
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NCHARS
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|k
operator|!=
literal|'\n'
condition|)
name|symbol
index|[
name|k
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|CCL
condition|)
block|{
name|nc
operator|=
name|chars
index|[
name|right
index|[
name|curpos
index|]
index|]
expr_stmt|;
name|pc
operator|=
name|right
index|[
name|curpos
index|]
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nc
condition|;
name|k
operator|++
control|)
name|symbol
index|[
name|chars
index|[
name|pc
operator|++
index|]
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|NCCL
condition|)
block|{
name|nc
operator|=
name|chars
index|[
name|right
index|[
name|curpos
index|]
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NCHARS
condition|;
name|j
operator|++
control|)
block|{
name|pc
operator|=
name|right
index|[
name|curpos
index|]
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nc
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|j
operator|==
name|chars
index|[
name|pc
operator|++
index|]
condition|)
goto|goto
name|cont
goto|;
if|if
condition|(
name|j
operator|!=
literal|'\n'
condition|)
name|symbol
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|cont
label|:
empty_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"something's funny\n"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|++
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|NCHARS
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|symbol
index|[
name|c
index|]
operator|==
literal|1
condition|)
block|{
comment|/* nextstate(s,c) */
name|count
operator|=
name|icount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|line
condition|;
name|i
operator|++
control|)
name|tmpstat
index|[
name|i
index|]
operator|=
name|initstat
index|[
name|i
index|]
expr_stmt|;
name|pos
operator|=
name|state
index|[
name|s
index|]
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|curpos
operator|=
name|positions
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|name
index|[
name|curpos
index|]
operator|)
operator|>=
literal|0
condition|)
if|if
condition|(
operator|(
name|k
operator|==
name|c
operator|)
operator||
operator|(
name|k
operator|==
name|DOT
operator|)
operator||
operator|(
name|k
operator|==
name|CCL
operator|&&
name|member
argument_list|(
name|c
argument_list|,
name|right
index|[
name|curpos
index|]
argument_list|,
literal|1
argument_list|)
operator|)
operator||
operator|(
name|k
operator|==
name|NCCL
operator|&&
name|member
argument_list|(
name|c
argument_list|,
name|right
index|[
name|curpos
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|number
operator|=
name|positions
index|[
name|foll
index|[
name|curpos
index|]
index|]
expr_stmt|;
name|newpos
operator|=
name|foll
index|[
name|curpos
index|]
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|number
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|tmpstat
index|[
name|positions
index|[
name|newpos
index|]
index|]
operator|!=
literal|1
condition|)
block|{
name|tmpstat
index|[
name|positions
index|[
name|newpos
index|]
index|]
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|newpos
operator|++
expr_stmt|;
block|}
block|}
name|pos
operator|++
expr_stmt|;
block|}
comment|/* end nextstate */
if|if
condition|(
name|notin
argument_list|(
name|n
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|NSTATES
condition|)
name|overflo
argument_list|()
expr_stmt|;
name|add
argument_list|(
name|state
argument_list|,
operator|++
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpstat
index|[
name|line
index|]
operator|==
literal|1
condition|)
name|out
index|[
name|n
index|]
operator|=
literal|1
expr_stmt|;
name|gotofn
index|[
name|s
index|]
index|[
name|c
index|]
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|gotofn
index|[
name|s
index|]
index|[
name|c
index|]
operator|=
name|xstate
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

begin_macro
name|cstate
argument_list|(
argument|v
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|b
expr_stmt|;
if|if
condition|(
name|left
index|[
name|v
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tmpstat
index|[
name|v
index|]
operator|!=
literal|1
condition|)
block|{
name|tmpstat
index|[
name|v
index|]
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|right
index|[
name|v
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cstate
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|name
index|[
name|v
index|]
operator|==
name|PLUS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
name|v
index|]
operator|==
name|CAT
condition|)
block|{
if|if
condition|(
name|cstate
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|cstate
argument_list|(
name|right
index|[
name|v
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* name[v] == OR */
name|b
operator|=
name|cstate
argument_list|(
name|right
index|[
name|v
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstate
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
operator|==
literal|0
operator|||
name|b
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|member
argument_list|(
argument|symb
argument_list|,
argument|set
argument_list|,
argument|torf
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|num
operator|,
name|pos
expr_stmt|;
name|num
operator|=
name|chars
index|[
name|set
index|]
expr_stmt|;
name|pos
operator|=
name|set
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|symb
operator|==
name|chars
index|[
name|pos
operator|++
index|]
condition|)
return|return
operator|(
name|torf
operator|)
return|;
return|return
operator|(
operator|!
name|torf
operator|)
return|;
block|}
end_block

begin_macro
name|notin
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
operator|,
name|pos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|positions
index|[
name|state
index|[
name|i
index|]
index|]
operator|==
name|count
condition|)
block|{
name|pos
operator|=
name|state
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|tmpstat
index|[
name|positions
index|[
name|pos
operator|++
index|]
index|]
operator|!=
literal|1
condition|)
goto|goto
name|nxt
goto|;
name|xstate
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nxt
label|:
empty_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|add
argument_list|(
argument|array
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|nxtpos
operator|+
name|count
operator|>
name|MAXPOS
condition|)
name|overflo
argument_list|()
expr_stmt|;
name|array
index|[
name|n
index|]
operator|=
name|nxtpos
expr_stmt|;
name|positions
index|[
name|nxtpos
operator|++
index|]
operator|=
name|count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|line
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tmpstat
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
name|positions
index|[
name|nxtpos
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|follow
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|int
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|p
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|line
condition|)
return|return;
name|p
operator|=
name|parent
index|[
name|v
index|]
expr_stmt|;
switch|switch
condition|(
name|name
index|[
name|p
index|]
condition|)
block|{
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
name|cstate
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|OR
case|:
case|case
name|QUEST
case|:
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|CAT
case|:
if|if
condition|(
name|v
operator|==
name|left
index|[
name|p
index|]
condition|)
block|{
if|if
condition|(
name|cstate
argument_list|(
name|right
index|[
name|p
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|FINAL
case|:
if|if
condition|(
name|tmpstat
index|[
name|line
index|]
operator|!=
literal|1
condition|)
block|{
name|tmpstat
index|[
name|line
index|]
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return;
block|}
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|(
operator|++
name|argv
operator|)
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
name|sflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'h'
case|:
name|hflag
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
name|bflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|cflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'f'
case|:
name|fflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
name|lflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|nflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'v'
case|:
name|vflag
operator|++
expr_stmt|;
continue|continue;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"egrep: unknown flag\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|out
label|:
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|fname
operator|=
operator|*
name|argv
expr_stmt|;
name|exprfile
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprfile
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"egrep: can't open %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|input
operator|=
operator|*
name|argv
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|cfoll
argument_list|(
name|line
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cgotofn
argument_list|()
expr_stmt|;
name|nfile
operator|=
name|argc
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|lflag
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|execute
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|--
name|argc
operator|>=
literal|0
condition|)
block|{
name|execute
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|exit
argument_list|(
name|nsucc
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|execute
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|cstat
expr_stmt|;
specifier|register
name|ccount
expr_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|nlp
decl_stmt|;
name|int
name|istat
decl_stmt|;
if|if
condition|(
name|file
condition|)
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"egrep: can't open %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|f
operator|=
literal|0
expr_stmt|;
name|ccount
operator|=
literal|0
expr_stmt|;
name|lnum
operator|=
literal|1
expr_stmt|;
name|tln
operator|=
literal|0
expr_stmt|;
name|blkno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|nlp
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|ccount
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
literal|512
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|done
goto|;
name|istat
operator|=
name|cstat
operator|=
name|gotofn
index|[
literal|0
index|]
index|[
literal|'\n'
index|]
expr_stmt|;
if|if
condition|(
name|out
index|[
name|cstat
index|]
condition|)
goto|goto
name|found
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cstat
operator|=
name|gotofn
index|[
name|cstat
index|]
index|[
operator|*
name|p
operator|&
literal|0377
index|]
expr_stmt|;
comment|/* all input chars made positive */
if|if
condition|(
name|out
index|[
name|cstat
index|]
condition|)
block|{
name|found
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|vflag
operator|==
literal|0
condition|)
block|{
name|succeed
label|:
name|nsucc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cflag
condition|)
name|tln
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|sflag
condition|)
empty_stmt|;
comment|/* ugh */
elseif|else
if|if
condition|(
name|lflag
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|nfile
operator|>
literal|1
operator|&&
name|hflag
condition|)
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|bflag
condition|)
name|printf
argument_list|(
literal|"%d:"
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
name|printf
argument_list|(
literal|"%ld:"
argument_list|,
name|lnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<=
name|nlp
condition|)
block|{
while|while
condition|(
name|nlp
operator|<
operator|&
name|buf
index|[
literal|1024
index|]
condition|)
name|putchar
argument_list|(
operator|*
name|nlp
operator|++
argument_list|)
expr_stmt|;
name|nlp
operator|=
name|buf
expr_stmt|;
block|}
while|while
condition|(
name|nlp
operator|<
name|p
condition|)
name|putchar
argument_list|(
operator|*
name|nlp
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
name|lnum
operator|++
expr_stmt|;
name|nlp
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|out
index|[
operator|(
name|cstat
operator|=
name|istat
operator|)
index|]
operator|)
operator|==
literal|0
condition|)
goto|goto
name|brk2
goto|;
block|}
name|cfound
label|:
if|if
condition|(
operator|--
name|ccount
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|<=
operator|&
name|buf
index|[
literal|512
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|ccount
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
literal|512
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
operator|&
name|buf
index|[
literal|1024
index|]
condition|)
block|{
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|ccount
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
literal|512
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccount
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
operator|&
name|buf
index|[
literal|1024
index|]
operator|-
name|p
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
name|blkno
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|vflag
condition|)
goto|goto
name|succeed
goto|;
else|else
block|{
name|lnum
operator|++
expr_stmt|;
name|nlp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|out
index|[
operator|(
name|cstat
operator|=
name|istat
operator|)
index|]
condition|)
goto|goto
name|cfound
goto|;
block|}
block|}
name|brk2
label|:
if|if
condition|(
operator|--
name|ccount
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|<=
operator|&
name|buf
index|[
literal|512
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|ccount
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
literal|512
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
operator|&
name|buf
index|[
literal|1024
index|]
condition|)
block|{
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|ccount
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
literal|512
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccount
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
operator|&
name|buf
index|[
literal|1024
index|]
operator|-
name|p
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
block|}
name|blkno
operator|++
expr_stmt|;
block|}
block|}
name|done
label|:
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
condition|)
block|{
if|if
condition|(
name|nfile
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%ld\n"
argument_list|,
name|tln
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|short
name|yyexca
index|[]
init|=
block|{
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
literal|0
block|, 	}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYNPROD
value|18
end_define

begin_define
define|#
directive|define
name|YYLAST
value|261
end_define

begin_decl_stmt
name|short
name|yyact
index|[]
init|=
block|{
literal|10
block|,
literal|22
block|,
literal|4
block|,
literal|14
block|,
literal|11
block|,
literal|2
block|,
literal|1
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|0
block|,
literal|19
block|,
literal|20
block|,
literal|3
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|0
block|,
literal|20
block|,
literal|0
block|,
literal|20
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|11
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|21
block|,
literal|0
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|11
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|23
block|,
literal|0
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|11
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|13
block|,
literal|0
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|11
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|0
block|,
literal|0
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|11
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yypact
index|[]
init|=
block|{
operator|-
literal|259
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
literal|0
block|,
operator|-
literal|1000
block|,
operator|-
literal|20
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
literal|0
block|,
operator|-
literal|1000
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|252
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
operator|-
literal|40
block|,
operator|-
literal|30
block|,
operator|-
literal|10
block|,
literal|0
block|,
operator|-
literal|1000
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yypgo
index|[]
init|=
block|{
literal|0
block|,
literal|6
block|,
literal|5
block|,
literal|18
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yyr1
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yyr2
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yychk
index|[]
init|=
block|{
operator|-
literal|1000
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
operator|-
literal|3
block|,
literal|261
block|,
operator|-
literal|4
block|,
literal|257
block|,
literal|258
block|,
literal|259
block|,
literal|260
block|,
literal|40
block|,
literal|256
block|,
operator|-
literal|3
block|,
literal|261
block|,
operator|-
literal|4
block|,
literal|263
block|,
literal|264
block|,
literal|265
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
literal|261
block|,
literal|41
block|,
literal|261
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yydef
index|[]
init|=
block|{
literal|6
block|,
operator|-
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|6
block|,
literal|2
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|0
block|,
literal|17
block|,
literal|0
block|,
literal|5
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|0
block|,
literal|4
block|,
literal|11
block|,
literal|0
block|,
literal|16
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_empty
empty|#
end_empty

begin_define
define|#
directive|define
name|YYFLAG
value|-1000
end_define

begin_define
define|#
directive|define
name|YYERROR
value|goto yyerrlab
end_define

begin_define
define|#
directive|define
name|YYACCEPT
value|return(0)
end_define

begin_define
define|#
directive|define
name|YYABORT
value|return(1)
end_define

begin_comment
comment|/*	parser for yacc output	*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYDEBUG
end_ifdef

begin_decl_stmt
name|int
name|yydebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 for debugging */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|YYSTYPE
name|yyv
index|[
name|YYMAXDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where the values are stored */
end_comment

begin_decl_stmt
name|int
name|yychar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input token number */
end_comment

begin_decl_stmt
name|int
name|yynerrs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of errors */
end_comment

begin_decl_stmt
name|short
name|yyerrflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error recovery flag */
end_comment

begin_macro
name|yyparse
argument_list|()
end_macro

begin_block
block|{
name|short
name|yys
index|[
name|YYMAXDEPTH
index|]
decl_stmt|;
name|short
name|yyj
decl_stmt|,
name|yym
decl_stmt|;
specifier|register
name|YYSTYPE
modifier|*
name|yypvt
decl_stmt|;
specifier|register
name|short
name|yystate
decl_stmt|,
modifier|*
name|yyps
decl_stmt|,
name|yyn
decl_stmt|;
specifier|register
name|YYSTYPE
modifier|*
name|yypv
decl_stmt|;
specifier|register
name|short
modifier|*
name|yyxi
decl_stmt|;
name|yystate
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
operator|-
literal|1
expr_stmt|;
name|yynerrs
operator|=
literal|0
expr_stmt|;
name|yyerrflag
operator|=
literal|0
expr_stmt|;
name|yyps
operator|=
operator|&
name|yys
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|yypv
operator|=
operator|&
name|yyv
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|yystack
label|:
comment|/* put a state and value onto the stack */
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"state %d, char 0%o\n"
argument_list|,
name|yystate
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|++
name|yyps
operator|>
operator|&
name|yys
index|[
name|YYMAXDEPTH
index|]
condition|)
block|{
name|yyerror
argument_list|(
literal|"yacc stack overflow"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|yyps
operator|=
name|yystate
expr_stmt|;
operator|++
name|yypv
expr_stmt|;
operator|*
name|yypv
operator|=
name|yyval
expr_stmt|;
name|yynewstate
label|:
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|<=
name|YYFLAG
condition|)
goto|goto
name|yydefault
goto|;
comment|/* simple state */
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
if|if
condition|(
operator|(
name|yychar
operator|=
name|yylex
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|yychar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|yyn
operator|+=
name|yychar
operator|)
operator|<
literal|0
operator|||
name|yyn
operator|>=
name|YYLAST
condition|)
goto|goto
name|yydefault
goto|;
if|if
condition|(
name|yychk
index|[
name|yyn
operator|=
name|yyact
index|[
name|yyn
index|]
index|]
operator|==
name|yychar
condition|)
block|{
comment|/* valid shift */
name|yychar
operator|=
operator|-
literal|1
expr_stmt|;
name|yyval
operator|=
name|yylval
expr_stmt|;
name|yystate
operator|=
name|yyn
expr_stmt|;
if|if
condition|(
name|yyerrflag
operator|>
literal|0
condition|)
operator|--
name|yyerrflag
expr_stmt|;
goto|goto
name|yystack
goto|;
block|}
name|yydefault
label|:
comment|/* default state action */
if|if
condition|(
operator|(
name|yyn
operator|=
name|yydef
index|[
name|yystate
index|]
operator|)
operator|==
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
if|if
condition|(
operator|(
name|yychar
operator|=
name|yylex
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|yychar
operator|=
literal|0
expr_stmt|;
comment|/* look through exception table */
for|for
control|(
name|yyxi
operator|=
name|yyexca
init|;
operator|(
operator|*
name|yyxi
operator|!=
operator|(
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|yyxi
index|[
literal|1
index|]
operator|!=
name|yystate
operator|)
condition|;
name|yyxi
operator|+=
literal|2
control|)
empty_stmt|;
comment|/* VOID */
while|while
condition|(
operator|*
operator|(
name|yyxi
operator|+=
literal|2
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|yyxi
operator|==
name|yychar
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|yyn
operator|=
name|yyxi
index|[
literal|1
index|]
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* accept */
block|}
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
block|{
comment|/* error */
comment|/* error ... attempt to resume parsing */
switch|switch
condition|(
name|yyerrflag
condition|)
block|{
case|case
literal|0
case|:
comment|/* brand new error */
name|yyerror
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
name|yyerrlab
label|:
operator|++
name|yynerrs
expr_stmt|;
case|case
literal|1
case|:
case|case
literal|2
case|:
comment|/* incompletely recovered error ... try again */
name|yyerrflag
operator|=
literal|3
expr_stmt|;
comment|/* find a state where "error" is a legal shift action */
while|while
condition|(
name|yyps
operator|>=
name|yys
condition|)
block|{
name|yyn
operator|=
name|yypact
index|[
operator|*
name|yyps
index|]
operator|+
name|YYERRCODE
expr_stmt|;
if|if
condition|(
name|yyn
operator|>=
literal|0
operator|&&
name|yyn
operator|<
name|YYLAST
operator|&&
name|yychk
index|[
name|yyact
index|[
name|yyn
index|]
index|]
operator|==
name|YYERRCODE
condition|)
block|{
name|yystate
operator|=
name|yyact
index|[
name|yyn
index|]
expr_stmt|;
comment|/* simulate a shift of "error" */
goto|goto
name|yystack
goto|;
block|}
name|yyn
operator|=
name|yypact
index|[
operator|*
name|yyps
index|]
expr_stmt|;
comment|/* the current yyps has no shift onn "error", pop stack */
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"error recovery pops state %d, uncovers %d\n"
argument_list|,
operator|*
name|yyps
argument_list|,
name|yyps
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|yyps
expr_stmt|;
operator|--
name|yypv
expr_stmt|;
block|}
comment|/* there is no state on the stack with an error shift ... abort */
name|yyabort
label|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|3
case|:
comment|/* no shift yet; clobber input char */
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"error recovery discards char %d\n"
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yychar
operator|==
literal|0
condition|)
goto|goto
name|yyabort
goto|;
comment|/* don't discard EOF, quit */
name|yychar
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/* try again in the same state */
block|}
block|}
comment|/* reduction by production yyn */
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"reduce %d\n"
argument_list|,
name|yyn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yyps
operator|-=
name|yyr2
index|[
name|yyn
index|]
expr_stmt|;
name|yypvt
operator|=
name|yypv
expr_stmt|;
name|yypv
operator|-=
name|yyr2
index|[
name|yyn
index|]
expr_stmt|;
name|yyval
operator|=
name|yypv
index|[
literal|1
index|]
expr_stmt|;
name|yym
operator|=
name|yyn
expr_stmt|;
comment|/* consult goto table to find next state */
name|yyn
operator|=
name|yyr1
index|[
name|yyn
index|]
expr_stmt|;
name|yyj
operator|=
name|yypgo
index|[
name|yyn
index|]
operator|+
operator|*
name|yyps
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|yyj
operator|>=
name|YYLAST
operator|||
name|yychk
index|[
name|yystate
operator|=
name|yyact
index|[
name|yyj
index|]
index|]
operator|!=
operator|-
name|yyn
condition|)
name|yystate
operator|=
name|yyact
index|[
name|yypgo
index|[
name|yyn
index|]
index|]
expr_stmt|;
switch|switch
condition|(
name|yym
condition|)
block|{
case|case
literal|1
case|:
line|#
directive|line
number|65
file|"egrep.y"
block|{
name|unary
argument_list|(
name|FINAL
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
argument_list|)
expr_stmt|;
name|line
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
line|#
directive|line
number|70
file|"egrep.y"
block|{
name|yyval
operator|=
name|node
argument_list|(
name|CAT
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
line|#
directive|line
number|72
file|"egrep.y"
block|{
name|yyval
operator|=
name|node
argument_list|(
name|CAT
argument_list|,
name|yypvt
index|[
operator|-
literal|2
index|]
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
line|#
directive|line
number|74
file|"egrep.y"
block|{
name|yyval
operator|=
name|node
argument_list|(
name|CAT
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|5
case|:
line|#
directive|line
number|76
file|"egrep.y"
block|{
name|yyval
operator|=
name|node
argument_list|(
name|CAT
argument_list|,
name|yypvt
index|[
operator|-
literal|2
index|]
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
line|#
directive|line
number|79
file|"egrep.y"
block|{
name|yyval
operator|=
name|enter
argument_list|(
name|DOT
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|unary
argument_list|(
name|STAR
argument_list|,
name|yyval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|7
case|:
line|#
directive|line
number|83
file|"egrep.y"
block|{
name|yyval
operator|=
name|enter
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|8
case|:
line|#
directive|line
number|85
file|"egrep.y"
block|{
name|yyval
operator|=
name|enter
argument_list|(
name|DOT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|9
case|:
line|#
directive|line
number|87
file|"egrep.y"
block|{
name|yyval
operator|=
name|cclenter
argument_list|(
name|CCL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|10
case|:
line|#
directive|line
number|89
file|"egrep.y"
block|{
name|yyval
operator|=
name|cclenter
argument_list|(
name|NCCL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|11
case|:
line|#
directive|line
number|93
file|"egrep.y"
block|{
name|yyval
operator|=
name|node
argument_list|(
name|OR
argument_list|,
name|yypvt
index|[
operator|-
literal|2
index|]
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|12
case|:
line|#
directive|line
number|95
file|"egrep.y"
block|{
name|yyval
operator|=
name|node
argument_list|(
name|CAT
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|13
case|:
line|#
directive|line
number|97
file|"egrep.y"
block|{
name|yyval
operator|=
name|unary
argument_list|(
name|STAR
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|14
case|:
line|#
directive|line
number|99
file|"egrep.y"
block|{
name|yyval
operator|=
name|unary
argument_list|(
name|PLUS
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|15
case|:
line|#
directive|line
number|101
file|"egrep.y"
block|{
name|yyval
operator|=
name|unary
argument_list|(
name|QUEST
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
line|#
directive|line
number|103
file|"egrep.y"
block|{
name|yyval
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
block|}
goto|goto
name|yystack
goto|;
comment|/* stack new state and value */
block|}
end_block

end_unit

