begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Robert Paul Corbett.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)output.c	5.6 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|nvectors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nentries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
modifier|*
name|froms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
modifier|*
name|tos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|tally
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|state_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|order
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lowzero
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|high
decl_stmt|;
end_decl_stmt

begin_macro
name|output
argument_list|()
end_macro

begin_block
block|{
name|free_itemsets
argument_list|()
expr_stmt|;
name|free_shifts
argument_list|()
expr_stmt|;
name|free_reductions
argument_list|()
expr_stmt|;
name|output_stored_text
argument_list|()
expr_stmt|;
name|output_defines
argument_list|()
expr_stmt|;
name|output_rule_data
argument_list|()
expr_stmt|;
name|output_yydefred
argument_list|()
expr_stmt|;
name|output_actions
argument_list|()
expr_stmt|;
name|free_parser
argument_list|()
expr_stmt|;
name|output_debug
argument_list|()
expr_stmt|;
name|output_stype
argument_list|()
expr_stmt|;
name|write_section
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|output_trailing_text
argument_list|()
expr_stmt|;
name|write_section
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|output_semantic_actions
argument_list|()
expr_stmt|;
name|write_section
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|output_rule_data
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"short yylhs[] = {%42d,"
argument_list|,
name|symbol_value
index|[
name|start_symbol
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|nrules
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%5d,"
argument_list|,
name|symbol_value
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|outline
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"short yylen[] = {%42d,"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|nrules
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|j
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%5d,"
argument_list|,
name|rrhs
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|rrhs
index|[
name|i
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|outline
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|output_yydefred
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"short yydefred[] = {%39d,"
argument_list|,
operator|(
name|defred
index|[
literal|0
index|]
condition|?
name|defred
index|[
literal|0
index|]
operator|-
literal|2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
literal|10
condition|)
operator|++
name|j
expr_stmt|;
else|else
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%5d,"
argument_list|,
operator|(
name|defred
index|[
name|i
index|]
condition|?
name|defred
index|[
name|i
index|]
operator|-
literal|2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
name|outline
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|output_actions
argument_list|()
end_macro

begin_block
block|{
name|nvectors
operator|=
literal|2
operator|*
name|nstates
operator|+
name|nvars
expr_stmt|;
name|froms
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
name|tos
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
name|tally
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|width
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|token_actions
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|lookaheads
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|LA
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|LAruleno
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|accessing_symbol
argument_list|)
expr_stmt|;
name|goto_actions
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|goto_map
operator|+
name|ntokens
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|from_state
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|to_state
argument_list|)
expr_stmt|;
name|sort_actions
argument_list|()
expr_stmt|;
name|pack_table
argument_list|()
expr_stmt|;
name|output_base
argument_list|()
expr_stmt|;
name|output_table
argument_list|()
expr_stmt|;
name|output_check
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|token_actions
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|shiftcount
decl_stmt|,
name|reducecount
decl_stmt|;
specifier|register
name|int
name|max
decl_stmt|,
name|min
decl_stmt|;
specifier|register
name|short
modifier|*
name|actionrow
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|action
modifier|*
name|p
decl_stmt|;
name|actionrow
operator|=
name|NEW2
argument_list|(
literal|2
operator|*
name|ntokens
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|parser
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
operator|*
name|ntokens
condition|;
operator|++
name|j
control|)
name|actionrow
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|shiftcount
operator|=
literal|0
expr_stmt|;
name|reducecount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|parser
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|suppressed
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|action_code
operator|==
name|SHIFT
condition|)
block|{
operator|++
name|shiftcount
expr_stmt|;
name|actionrow
index|[
name|p
operator|->
name|symbol
index|]
operator|=
name|p
operator|->
name|number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|action_code
operator|==
name|REDUCE
operator|&&
name|p
operator|->
name|number
operator|!=
name|defred
index|[
name|i
index|]
condition|)
block|{
operator|++
name|reducecount
expr_stmt|;
name|actionrow
index|[
name|p
operator|->
name|symbol
operator|+
name|ntokens
index|]
operator|=
name|p
operator|->
name|number
expr_stmt|;
block|}
block|}
block|}
name|tally
index|[
name|i
index|]
operator|=
name|shiftcount
expr_stmt|;
name|tally
index|[
name|nstates
operator|+
name|i
index|]
operator|=
name|reducecount
expr_stmt|;
name|width
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|width
index|[
name|nstates
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|shiftcount
operator|>
literal|0
condition|)
block|{
name|froms
index|[
name|i
index|]
operator|=
name|r
operator|=
name|NEW2
argument_list|(
name|shiftcount
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|tos
index|[
name|i
index|]
operator|=
name|s
operator|=
name|NEW2
argument_list|(
name|shiftcount
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|min
operator|=
name|MAXSHORT
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ntokens
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|actionrow
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|min
operator|>
name|symbol_value
index|[
name|j
index|]
condition|)
name|min
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|symbol_value
index|[
name|j
index|]
condition|)
name|max
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
operator|*
name|r
operator|++
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|actionrow
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
name|width
index|[
name|i
index|]
operator|=
name|max
operator|-
name|min
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|reducecount
operator|>
literal|0
condition|)
block|{
name|froms
index|[
name|nstates
operator|+
name|i
index|]
operator|=
name|r
operator|=
name|NEW2
argument_list|(
name|reducecount
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|tos
index|[
name|nstates
operator|+
name|i
index|]
operator|=
name|s
operator|=
name|NEW2
argument_list|(
name|reducecount
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|min
operator|=
name|MAXSHORT
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ntokens
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|actionrow
index|[
name|ntokens
operator|+
name|j
index|]
condition|)
block|{
if|if
condition|(
name|min
operator|>
name|symbol_value
index|[
name|j
index|]
condition|)
name|min
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|symbol_value
index|[
name|j
index|]
condition|)
name|max
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
operator|*
name|r
operator|++
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|actionrow
index|[
name|ntokens
operator|+
name|j
index|]
operator|-
literal|2
expr_stmt|;
block|}
block|}
name|width
index|[
name|nstates
operator|+
name|i
index|]
operator|=
name|max
operator|-
name|min
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
name|FREE
argument_list|(
name|actionrow
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|goto_actions
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|state_count
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|k
operator|=
name|default_goto
argument_list|(
name|start_symbol
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"short yydgoto[] = {%40d,"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|save_column
argument_list|(
name|start_symbol
operator|+
literal|1
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start_symbol
operator|+
literal|2
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|k
operator|=
name|default_goto
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%5d,"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|save_column
argument_list|(
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
name|outline
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|state_count
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|default_goto
parameter_list|(
name|symbol
parameter_list|)
name|int
name|symbol
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|default_state
decl_stmt|;
specifier|register
name|int
name|max
decl_stmt|;
name|m
operator|=
name|goto_map
index|[
name|symbol
index|]
expr_stmt|;
name|n
operator|=
name|goto_map
index|[
name|symbol
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|n
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
name|state_count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|state_count
index|[
name|to_state
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
name|default_state
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|state_count
index|[
name|i
index|]
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|state_count
index|[
name|i
index|]
expr_stmt|;
name|default_state
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
operator|(
name|default_state
operator|)
return|;
block|}
end_function

begin_macro
name|save_column
argument_list|(
argument|symbol
argument_list|,
argument|default_state
argument_list|)
end_macro

begin_decl_stmt
name|int
name|symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_state
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp1
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp2
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|symno
decl_stmt|;
name|m
operator|=
name|goto_map
index|[
name|symbol
index|]
expr_stmt|;
name|n
operator|=
name|goto_map
index|[
name|symbol
operator|+
literal|1
index|]
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|to_state
index|[
name|i
index|]
operator|!=
name|default_state
condition|)
operator|++
name|count
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|symno
operator|=
name|symbol_value
index|[
name|symbol
index|]
operator|+
literal|2
operator|*
name|nstates
expr_stmt|;
name|froms
index|[
name|symno
index|]
operator|=
name|sp1
operator|=
name|sp
operator|=
name|NEW2
argument_list|(
name|count
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|tos
index|[
name|symno
index|]
operator|=
name|sp2
operator|=
name|NEW2
argument_list|(
name|count
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|to_state
index|[
name|i
index|]
operator|!=
name|default_state
condition|)
block|{
operator|*
name|sp1
operator|++
operator|=
name|from_state
index|[
name|i
index|]
expr_stmt|;
operator|*
name|sp2
operator|++
operator|=
name|to_state
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|tally
index|[
name|symno
index|]
operator|=
name|count
expr_stmt|;
name|width
index|[
name|symno
index|]
operator|=
name|sp1
index|[
operator|-
literal|1
index|]
operator|-
name|sp
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|sort_actions
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|int
name|w
decl_stmt|;
name|order
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|nentries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvectors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tally
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|t
operator|=
name|tally
index|[
name|i
index|]
expr_stmt|;
name|w
operator|=
name|width
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|nentries
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|>=
literal|0
operator|&&
operator|(
name|width
index|[
name|order
index|[
name|j
index|]
index|]
operator|<
name|w
operator|)
condition|)
name|j
operator|--
expr_stmt|;
while|while
condition|(
name|j
operator|>=
literal|0
operator|&&
operator|(
name|width
index|[
name|order
index|[
name|j
index|]
index|]
operator|==
name|w
operator|)
operator|&&
operator|(
name|tally
index|[
name|order
index|[
name|j
index|]
index|]
operator|<
name|t
operator|)
condition|)
name|j
operator|--
expr_stmt|;
for|for
control|(
name|k
operator|=
name|nentries
operator|-
literal|1
init|;
name|k
operator|>
name|j
condition|;
name|k
operator|--
control|)
name|order
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|order
index|[
name|k
index|]
expr_stmt|;
name|order
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|nentries
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|pack_table
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|place
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
name|base
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|pos
operator|=
name|NEW2
argument_list|(
name|nentries
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|maxtable
operator|=
literal|1000
expr_stmt|;
name|table
operator|=
name|NEW2
argument_list|(
name|maxtable
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|check
operator|=
name|NEW2
argument_list|(
name|maxtable
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|lowzero
operator|=
literal|0
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxtable
condition|;
name|i
operator|++
control|)
name|check
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|state
operator|=
name|matching_vector
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|<
literal|0
condition|)
name|place
operator|=
name|pack_vector
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|place
operator|=
name|base
index|[
name|state
index|]
expr_stmt|;
name|pos
index|[
name|i
index|]
operator|=
name|place
expr_stmt|;
name|base
index|[
name|order
index|[
name|i
index|]
index|]
operator|=
name|place
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvectors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|froms
index|[
name|i
index|]
condition|)
name|FREE
argument_list|(
name|froms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tos
index|[
name|i
index|]
condition|)
name|FREE
argument_list|(
name|tos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|froms
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|tos
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  The function matching_vector determines if the vector specified by	*/
end_comment

begin_comment
comment|/*  the input parameter matches a previously considered	vector.  The	*/
end_comment

begin_comment
comment|/*  test at the start of the function checks if the vector represents	*/
end_comment

begin_comment
comment|/*  a row of shifts over terminal symbols or a row of reductions, or a	*/
end_comment

begin_comment
comment|/*  column of shifts over a nonterminal symbol.  Berkeley Yacc does not	*/
end_comment

begin_comment
comment|/*  check if a column of shifts over a nonterminal symbols matches a	*/
end_comment

begin_comment
comment|/*  previously considered vector.  Because of the nature of LR parsing	*/
end_comment

begin_comment
comment|/*  tables, no two columns can match.  Therefore, the only possible	*/
end_comment

begin_comment
comment|/*  match would be between a row and a column.  Such matches are	*/
end_comment

begin_comment
comment|/*  unlikely.  Therefore, to save time, no attempt is made to see if a	*/
end_comment

begin_comment
comment|/*  column matches a previously considered vector.			*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Matching_vector is poorly designed.  The test could easily be made	*/
end_comment

begin_comment
comment|/*  faster.  Also, it depends on the vectors being in a specific	*/
end_comment

begin_comment
comment|/*  order.								*/
end_comment

begin_function
name|int
name|matching_vector
parameter_list|(
name|vector
parameter_list|)
name|int
name|vector
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|int
name|w
decl_stmt|;
specifier|register
name|int
name|match
decl_stmt|;
specifier|register
name|int
name|prev
decl_stmt|;
name|i
operator|=
name|order
index|[
name|vector
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|2
operator|*
name|nstates
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|t
operator|=
name|tally
index|[
name|i
index|]
expr_stmt|;
name|w
operator|=
name|width
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|prev
operator|=
name|vector
operator|-
literal|1
init|;
name|prev
operator|>=
literal|0
condition|;
name|prev
operator|--
control|)
block|{
name|j
operator|=
name|order
index|[
name|prev
index|]
expr_stmt|;
if|if
condition|(
name|width
index|[
name|j
index|]
operator|!=
name|w
operator|||
name|tally
index|[
name|j
index|]
operator|!=
name|t
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|match
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|match
operator|&&
name|k
operator|<
name|t
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|tos
index|[
name|j
index|]
index|[
name|k
index|]
operator|!=
name|tos
index|[
name|i
index|]
index|[
name|k
index|]
operator|||
name|froms
index|[
name|j
index|]
index|[
name|k
index|]
operator|!=
name|froms
index|[
name|i
index|]
index|[
name|k
index|]
condition|)
name|match
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|match
condition|)
return|return
operator|(
name|j
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pack_vector
parameter_list|(
name|vector
parameter_list|)
name|int
name|vector
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|int
name|loc
decl_stmt|;
specifier|register
name|int
name|ok
decl_stmt|;
specifier|register
name|short
modifier|*
name|from
decl_stmt|;
specifier|register
name|short
modifier|*
name|to
decl_stmt|;
name|int
name|newmax
decl_stmt|;
name|i
operator|=
name|order
index|[
name|vector
index|]
expr_stmt|;
name|t
operator|=
name|tally
index|[
name|i
index|]
expr_stmt|;
name|assert
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|from
operator|=
name|froms
index|[
name|i
index|]
expr_stmt|;
name|to
operator|=
name|tos
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|lowzero
operator|-
name|from
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|t
condition|;
operator|++
name|k
control|)
if|if
condition|(
name|lowzero
operator|-
name|from
index|[
name|k
index|]
operator|>
name|j
condition|)
name|j
operator|=
name|lowzero
operator|-
name|from
index|[
name|k
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
continue|continue;
name|ok
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|ok
operator|&&
name|k
operator|<
name|t
condition|;
name|k
operator|++
control|)
block|{
name|loc
operator|=
name|j
operator|+
name|from
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|loc
operator|>=
name|maxtable
condition|)
block|{
if|if
condition|(
name|loc
operator|>=
name|MAXTABLE
condition|)
name|fatal
argument_list|(
literal|"maximum table size exceeded"
argument_list|)
expr_stmt|;
name|newmax
operator|=
name|maxtable
expr_stmt|;
do|do
block|{
name|newmax
operator|+=
literal|200
expr_stmt|;
block|}
do|while
condition|(
name|newmax
operator|<=
name|loc
condition|)
do|;
name|table
operator|=
operator|(
name|short
operator|*
operator|)
name|realloc
argument_list|(
name|table
argument_list|,
name|newmax
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|check
operator|=
operator|(
name|short
operator|*
operator|)
name|realloc
argument_list|(
name|check
argument_list|,
name|newmax
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
for|for
control|(
name|l
operator|=
name|maxtable
init|;
name|l
operator|<
name|newmax
condition|;
operator|++
name|l
control|)
block|{
name|table
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
name|check
index|[
name|l
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|maxtable
operator|=
name|newmax
expr_stmt|;
block|}
if|if
condition|(
name|check
index|[
name|loc
index|]
operator|!=
operator|-
literal|1
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|ok
operator|&&
name|k
operator|<
name|vector
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|pos
index|[
name|k
index|]
operator|==
name|j
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|t
condition|;
name|k
operator|++
control|)
block|{
name|loc
operator|=
name|j
operator|+
name|from
index|[
name|k
index|]
expr_stmt|;
name|table
index|[
name|loc
index|]
operator|=
name|to
index|[
name|k
index|]
expr_stmt|;
name|check
index|[
name|loc
index|]
operator|=
name|from
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|loc
operator|>
name|high
condition|)
name|high
operator|=
name|loc
expr_stmt|;
block|}
while|while
condition|(
name|check
index|[
name|lowzero
index|]
operator|!=
operator|-
literal|1
condition|)
operator|++
name|lowzero
expr_stmt|;
return|return
operator|(
name|j
operator|)
return|;
block|}
block|}
block|}
end_function

begin_macro
name|output_base
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"short yysindex[] = {%39d,"
argument_list|,
name|base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%5d,"
argument_list|,
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|outline
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n};\nshort yyrindex[] = {%39d,"
argument_list|,
name|base
index|[
name|nstates
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nstates
operator|+
literal|1
init|;
name|i
operator|<
literal|2
operator|*
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%5d,"
argument_list|,
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|outline
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n};\nshort yygindex[] = {%39d,"
argument_list|,
name|base
index|[
literal|2
operator|*
name|nstates
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
operator|*
name|nstates
operator|+
literal|1
init|;
name|i
operator|<
name|nvectors
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%5d,"
argument_list|,
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|outline
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|output_table
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"#define YYTABLESIZE %d\n"
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"short yytable[] = {%40d,"
argument_list|,
name|table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|high
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%5d,"
argument_list|,
name|table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|outline
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|output_check
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"short yycheck[] = {%40d,"
argument_list|,
name|check
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|high
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%5d,"
argument_list|,
name|check
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|outline
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|check
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|is_C_identifier
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|s
operator|=
name|name
expr_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|c
operator|=
operator|*
operator|++
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_macro
name|output_defines
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|=
name|symbol_name
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|is_C_identifier
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"#define "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|fprintf
argument_list|(
name|defines_file
argument_list|,
literal|"#define "
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|!=
literal|'"'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|defines_file
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
do|do
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|defines_file
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|=
operator|*
operator|++
name|s
condition|)
do|;
block|}
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" %d\n"
argument_list|,
name|symbol_value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|fprintf
argument_list|(
name|defines_file
argument_list|,
literal|" %d\n"
argument_list|,
name|symbol_value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"#define YYERRCODE %d\n"
argument_list|,
name|symbol_value
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
operator|&&
name|unionized
condition|)
block|{
name|fclose
argument_list|(
name|union_file
argument_list|)
expr_stmt|;
name|union_file
operator|=
name|fopen
argument_list|(
name|union_file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|union_file
operator|==
name|NULL
condition|)
name|open_error
argument_list|(
name|union_file_name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|union_file
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|defines_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|defines_file
argument_list|,
literal|" YYSTYPE;\nextern YYSTYPE yylval;\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|output_stored_text
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|fclose
argument_list|(
name|text_file
argument_list|)
expr_stmt|;
name|text_file
operator|=
name|fopen
argument_list|(
name|text_file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_file
operator|==
name|NULL
condition|)
name|open_error
argument_list|(
name|text_file_name
argument_list|)
expr_stmt|;
name|in
operator|=
name|text_file
expr_stmt|;
name|out
operator|=
name|output_file
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lflag
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
name|line_format
argument_list|,
name|outline
operator|+
literal|1
argument_list|,
name|output_file_name
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|output_debug
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|max
decl_stmt|;
name|char
modifier|*
modifier|*
name|symnam
decl_stmt|,
modifier|*
name|s
decl_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"#define YYFINAL %d\n"
argument_list|,
name|final_state
argument_list|)
expr_stmt|;
name|outline
operator|+=
literal|3
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"#ifndef YYDEBUG\n#define YYDEBUG %d\n#endif\n"
argument_list|,
name|tflag
argument_list|)
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|symbol_value
index|[
name|i
index|]
operator|>
name|max
condition|)
name|max
operator|=
name|symbol_value
index|[
name|i
index|]
expr_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"#define YYMAXTOKEN %d\n"
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|symnam
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|MALLOC
argument_list|(
operator|(
name|max
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symnam
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
name|symnam
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
operator|-
literal|1
init|;
name|i
operator|>=
literal|2
condition|;
operator|--
name|i
control|)
name|symnam
index|[
name|symbol_value
index|[
name|i
index|]
index|]
operator|=
name|symbol_name
index|[
name|i
index|]
expr_stmt|;
name|symnam
index|[
literal|0
index|]
operator|=
literal|"end-of-file"
expr_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"#if YYDEBUG\nchar *yyname[] = {"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|80
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|s
operator|=
name|symnam
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
block|{
name|k
operator|=
literal|7
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
name|k
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'\\'
condition|)
name|k
operator|+=
literal|2
expr_stmt|;
else|else
operator|++
name|k
expr_stmt|;
block|}
else|else
operator|++
name|k
expr_stmt|;
block|}
name|j
operator|+=
name|k
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|80
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\"\\\""
argument_list|)
expr_stmt|;
name|s
operator|=
name|symnam
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'\\'
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\"\","
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
block|{
name|j
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|80
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
literal|7
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\"'\\\"'\","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|k
operator|=
literal|5
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|'\''
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
name|k
operator|+=
literal|2
expr_stmt|;
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'\\'
condition|)
name|k
operator|+=
literal|2
expr_stmt|;
else|else
operator|++
name|k
expr_stmt|;
block|}
else|else
operator|++
name|k
expr_stmt|;
block|}
name|j
operator|+=
name|k
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|80
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\"'"
argument_list|)
expr_stmt|;
name|s
operator|=
name|symnam
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|'\''
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'\\'
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"'\","
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|k
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|3
expr_stmt|;
name|j
operator|+=
name|k
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|80
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'"'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
do|do
block|{
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|s
condition|)
do|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\","
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|j
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|80
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|j
operator|=
literal|2
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"0,"
argument_list|)
expr_stmt|;
block|}
block|}
name|outline
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|symnam
argument_list|)
expr_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"char *yyrule[] = {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nrules
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\"%s :"
argument_list|,
name|symbol_name
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|rrhs
index|[
name|i
index|]
init|;
name|ritem
index|[
name|j
index|]
operator|>
literal|0
condition|;
operator|++
name|j
control|)
block|{
name|s
operator|=
name|symbol_name
index|[
name|ritem
index|[
name|j
index|]
index|]
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" \\\""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\\\\\\"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\\%c"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" '\\\"'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|==
literal|'\\'
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" '\\\\\\\\"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" '\\\\%c"
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|'\''
condition|)
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\''
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" '%c'"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\",\n"
argument_list|)
expr_stmt|;
block|}
name|outline
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n#endif\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|output_stype
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|unionized
operator|&&
name|ntags
operator|==
literal|0
condition|)
block|{
name|outline
operator|+=
literal|3
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"#ifndef YYSTYPE\ntypedef int YYSTYPE;\n#endif\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|output_trailing_text
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|lineno
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|input_file
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return;
if|if
condition|(
operator|!
name|lflag
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|last
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|lflag
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|cptr
operator|)
operator|!=
literal|'\n'
condition|)
do|;
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|last
operator|=
literal|'\n'
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|input_file
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|last
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|!=
literal|'\n'
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lflag
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
name|line_format
argument_list|,
name|outline
operator|+
literal|1
argument_list|,
name|output_file_name
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|output_semantic_actions
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|last
decl_stmt|;
name|fclose
argument_list|(
name|action_file
argument_list|)
expr_stmt|;
name|action_file
operator|=
name|fopen
argument_list|(
name|action_file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|action_file
operator|==
name|NULL
condition|)
name|open_error
argument_list|(
name|action_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|action_file
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return;
name|last
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|action_file
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|last
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|!=
literal|'\n'
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lflag
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
name|line_format
argument_list|,
name|outline
operator|+
literal|1
argument_list|,
name|output_file_name
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|free_itemsets
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|core
modifier|*
name|cp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|FREE
argument_list|(
name|state_table
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|first_state
init|;
name|cp
condition|;
name|cp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|cp
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|free_shifts
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|FREE
argument_list|(
name|shift_table
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_shift
init|;
name|sp
condition|;
name|sp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|free_reductions
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|reductions
modifier|*
name|rp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|FREE
argument_list|(
name|reduction_table
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|first_reduction
init|;
name|rp
condition|;
name|rp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|rp
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

