begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: bigmath.c 1.4 83/06/09 00:50:06 sklower Exp $ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_expr_stmt
operator|.
name|globl
name|_dmlad
comment|/* 	routine for destructive multiplication and addition to a bignum by 	two fixnums.  	from C, the invocation is dmlad(sdot,mul,add); 	where sdot is the address of the first special cell of the bignum 	mul is the multiplier, add is the fixnum to be added (The latter 	being passed by value, as is the usual case.   	Register assignments:  	r11 = current sdot 	r10 = carry 	r9  = previous sdot, for relinking. */
name|_dmlad
operator|:
operator|.
name|word
literal|0x0e00
name|movl
literal|4
operator|(
name|ap
operator|)
operator|,
name|r11
operator|#
name|initialize
name|cell
name|pointer
name|movl
literal|12
operator|(
name|ap
operator|)
operator|,
name|r10
operator|#
name|initialize
name|carry
name|loop
operator|:
name|emul
literal|8
operator|(
name|ap
operator|)
operator|,
operator|(
name|r11
operator|)
operator|,
name|r10
operator|,
name|r0
operator|#
name|r0
name|gets
name|cell
operator|->
name|car
name|times
name|mul
operator|+
name|carry
comment|/*	ediv	$0x40000000,r0,r10,(r11)#cell->car gets prod % 2**30 					#carry gets quotient */
name|extzv
name|$0
operator|,
name|$30
operator|,
name|r0
operator|,
operator|(
name|r11
operator|)
name|extv
name|$30
operator|,
name|$32
operator|,
name|r0
operator|,
name|r10
name|movl
name|r11
operator|,
name|r9
operator|#
name|save
name|last
name|cell
end_expr_stmt

begin_for
for|for fixup at end. 	movl	4
control|(
name|r11
control|)
operator|,
name|r11
operator|#
name|move
name|to
name|next
name|cell
name|bneq
name|loop
operator|#
name|done
name|indicated
name|by
literal|0
end_for

begin_for
for|for next sdot 	tstl	r10			#if carry zero no need to allocate 	beql	done			#new bigit 	mcoml	r10
operator|,
name|r3
operator|#
name|test
name|to
name|see
end_for

begin_if
if|if neg 1. 	bneq	alloc			#if not must allocate new cell. 	tstl
condition|(
name|r9
condition|)
operator|#
name|make
name|sure
name|product
name|isn
literal|'t -2**30 	beql	alloc 	movl	r0,(r9)			#save old lower half of product. 	brb	done alloc:	jsb	_qnewdot			#otherwise allocate new bigit 	movl	r10,(r0)		#store carry 	movl	r0,4(r9)		#save new link cell done:	movl	4(ap),r0 	ret 	.globl _dodiv /* 	routine to destructively divide array representation of a bignum by  	1000000000  	invocation: 		remainder = dodiv(top,bottom) 		int *top, *bottom; 	where *bottom is the address of the biggning of the array, *top is 	the top of the array.  	register assignments: 	r0 = carry 	r1& r2 = 64bit temporary 	r3 = pointer */ _dodiv:	.word	0 	clrl		r0		#no carry to begin. 	movl		8(ap),r3	#get pointer to array. loop2:	emul		$0x40000000,r0,(r3),r1 	ediv		$1000000000,r1,(r3),r0 	acbl		4(ap),$4,r3,loop2 	ret 	.globl	_dsneg /* 	dsneg(top, bot); 	int *top, *bot;  	routine to destructively negate a bignum stored in array format 	lower order stuff at higher addresses. It is assume that the 	result will be positive. */ _dsneg:	.word	0 	movl	4(ap),r1	#load up address. 	clrl	r2		#set carry loop3:	mnegl	(r1),r0		#negate and take carry into account. 	addl2	r2,r0 	extzv	$0,$30,r0,(r1) 	extv	$30,$2,r0,r2 	acbl	8(ap),$-4,r1,loop3 				#decrease r1, and branch back if appropriate. 	ret  /* 	bignum add routine 	basic data representation is each bigit is a positive number 	less than 2^30, except for the leading bigit, which is in 	the range -2^30< x< 2^30. */  	.globl	_adbig 	.globl	Bexport 	.globl	backfr /* 	Initialization section */ _adbig:	.word	0x0fc0		#save registers 6-11 	movl	4(ap),r1	#arg1 = addr of 1st bignum 	movl	8(ap),r2	#arg2 = addr of 2nd bignum 	clrl	r5		#r5   = carry 	movl	$0xC0000000,r4	#r4   = clear constant. 	movl	sp,r10		#save start address of bignum on stack. 				#note well that this is 4 above the actual 				#low order word. /* 	first loop is to waltz through both bignums adding 	bigits, pushing them onto stack.  */ loop4:	addl3	(r1),(r2),r0	#add bigits 	addl2	r5,r0		#add carry 	bicl3	r4,r0,-(sp)	#save sum, no overflow possible 	extv	$30,$2,r0,r5	#sign extend two high order bits 				#to be next carry. 	movl	4(r1),r1	#get cdr 	bleq	out1		#negative indicates end of list. 	movl	4(r2),r2	#get cdr of second bignum 	bgtr	loop4		#if neither list at end, do it again /* 	second loop propagates carries through higher order words. 	It assumes remaining list in r1. */ loop5:	addl3	(r1),r5,r0	#add bigits and carry 	bicl3	r4,r0,-(sp)	#save sum, no overflow possible 	extv	$30,$2,r0,r5	#sign extend two high order bits 				#to be next carry. 	movl	4(r1),r1	#get cdr out2:	bgtr	loop5		#negative indicates end of list. out2a:	pushl	r5 /* 	suppress unnecessary leading zeroes and -1'
name|s
name|WARNING
operator|:
name|this
name|code
name|is
name|duplicated
name|in
name|C
name|in
name|divbig
operator|.
name|c
operator|*
operator|/
name|iexport
operator|:
name|movl
name|sp
operator|,
name|r11
operator|#
name|more
name|set
name|up
end_if

begin_for
for|for output routine ckloop:	 Bexport:tstl
control|(
name|r11
control|)
operator|#
name|look
name|at
name|leading
name|bigit
name|bgtr
name|copyit
operator|#
end_for

begin_if
if|if positive
operator|,
name|can
name|allocate
name|storage
name|etc
operator|.
name|blss
name|negchk
operator|#
end_if

begin_if
if|if neg
operator|,
name|still
name|a
name|chance
name|we
name|can
name|get
name|by
name|cmpl
name|r11
decl_stmt|,
name|r10
decl|#
name|check
name|to
name|see
name|that
name|bgeq
name|copyit
decl|#
name|we
name|don
decl|'t pop everything off of stack 	tstl	(r11)+		#incr r11 	brb	ckloop		#examine next negchk: 	mcoml	(r11),r3		#r3 is junk register 	bneq	copyit		#short test for -1 	tstl	4(r11)		#examine next bigit 	beql	copyit		#if zero must must leave as is. 	cmpl	r11,r10		#check to see that 	bgeq	copyit		#we don'
name|t
name|pop
name|everything
name|off
name|of
name|stack
name|tstl
argument_list|(
name|r11
argument_list|)
decl|+		#
name|incr
name|r11
name|bisl2
name|r4
decl_stmt|,
argument_list|(
name|r11
argument_list|)
decl_stmt|#
name|set
name|high
name|order
name|two
name|bits
name|brb
name|negchk
decl|#
name|try
name|to
name|supress
name|more
name|leading
decl|-1's /* 	The following code is an error exit from the first loop  	and is out of place to avoid a jump around a jump. */ out1:	movl	4(r2),r1	#get next addr of list to continue. 	brb	out2		#if second list simult. exhausted, do 				#right thing. /* 	loop6 is a faster version of loop5 when carries are no 	longer necessary. */ loop6a: pushl	(r1)		#get datum loop6:	movl	4(r1),r1	#get cdr 	bgtr	loop6a		#if not at end get next cell 	brb	out2a  /* 	create linked list representation of bignum */ copyit:	subl3	r11,r10,r2	#see if we can get away with allocating an int 	bneq	on1		#test for having popped everything 	subl3	$4,r10,r11	#if so, fix up pointer to bottom 	brb	intout		#and allocate int. on1:	cmpl	r2,$4		#if = 4, then can do 	beql	intout 	calls	$0,_newsdot	#get new cell for new bignum backfr: #ifdef PORTABLE 	movl	r0,*_np 	addl2	$4,_np #else 	movl	r0,(r6)+	#push address of cell on 				#arg stack to save from garbage collection. 				#There is guaranteed to be slop for a least 1 				#push without checking. #endif loop7:	movl	-(r10),(r0)	#save bigit 	movl	r0,r9		#r9 = old cell, to link 	cmpl	r10,r11		#have we copy'
name|ed
name|all
name|the
name|bigits
decl|?
name|bleq
name|Edone
name|jsb
name|_qnewdot
decl|#
name|get
name|new
name|cell
decl|for
name|new
name|bignum
name|movl
name|r0
decl_stmt|,4
argument_list|(
name|r9
argument_list|)
decl_stmt|#
name|link
name|new
name|cell
name|to
name|old
name|brb
name|loop7
name|Edone
range|:
name|clrl
literal|4
operator|(
name|r9
operator|)
operator|#
name|indicate
name|end
name|of
name|list
name|with
literal|0
ifdef|#
directive|ifdef
name|PORTABLE
name|subl2
name|$4
decl_stmt|,
name|_np
name|movl
modifier|*
name|_np
decl_stmt|,
name|r0
else|#
directive|else
name|movl
decl|-
argument_list|(
name|r6
argument_list|)
decl_stmt|,
name|r0
decl|#
name|give
name|resultant
name|address
operator|.
endif|#
directive|endif
name|ret
comment|/* 	export integer */
name|intout
range|:
name|pushl
argument_list|(
argument|r11
argument_list|)
name|calls
name|$1
decl_stmt|,
name|_inewint
name|ret
operator|.
name|globl
name|_mulbig
comment|/* 	bignum multiplication routine  	Initialization section */
name|_mulbig
range|:
operator|.
name|word
literal|0x0fc0
operator|#
name|save
name|regs
literal|6
operator|-
literal|11
name|movl
literal|4
operator|(
name|ap
operator|)
decl_stmt|,
name|r1
decl|#
name|get
name|address
name|of
name|first
name|bignum
name|movl
name|sp
decl_stmt|,
name|r11
decl|#
name|save
name|top
name|of
decl|1st
name|bignum
name|mloop1
range|:
name|pushl
argument_list|(
name|r1
argument_list|)
operator|#
name|get
name|bigit
name|movl
literal|4
operator|(
name|r1
operator|)
decl_stmt|,
name|r1
decl|#
name|get
name|cdr
name|bgtr
name|mloop1
decl|#
name|repeat
decl|if
name|not
name|done
name|movl
name|sp
decl_stmt|,
name|r10
decl|#
name|save
name|bottom
name|of
decl|1st
name|bignum
decl_stmt|,
name|top
name|of
decl|2nd
name|bignum
name|movl
decl|8
argument_list|(
name|ap
argument_list|)
decl_stmt|,
name|r1
decl|#
name|get
name|address
name|of
decl|2nd
name|bignum
name|mloop2
range|:
name|pushl
argument_list|(
name|r1
argument_list|)
operator|#
name|get
name|bigit
name|movl
literal|4
operator|(
name|r1
operator|)
decl_stmt|,
name|r1
decl|#
name|get
name|cdr
name|bgtr
name|mloop2
decl|#
name|repeat
decl|if
name|not
name|done
name|movl
name|sp
decl_stmt|,
name|r9
decl|#
name|save
name|bottom
name|of
decl|2nd
name|bignum
name|subl3
name|r9
decl_stmt|,
name|r11
decl_stmt|,
name|r6
decl|#
name|r6
name|contains
name|sum
name|of
name|lengths
name|of
name|bignums
name|subl2
name|r6
decl_stmt|,
name|sp
name|movl
name|sp
decl_stmt|,
name|r8
decl|#
name|save
name|bottom
name|of
name|product
name|bignum
comment|/* 	Actual multiplication */
name|m1
range|:
name|movc5
name|$0
decl_stmt|,
argument_list|(
name|r8
argument_list|)
decl_stmt|,
name|$0
decl_stmt|,
name|r6
decl_stmt|,
argument_list|(
name|r8
argument_list|)
decl_stmt|#
name|zap
name|out
name|stack
name|space
name|movl
name|r9
decl_stmt|,
name|r7
decl|#
name|r7
init|=
operator|&
name|w
index|[
name|j
operator|+
name|n
index|]
operator|(
operator|+
literal|4
end_if

begin_for
for|for a.d.
end_for

begin_decl_stmt
unit|)
name|through
name|calculation
name|subl3
name|$4
decl_stmt|,
name|r10
decl_stmt|,
name|r4
decl|#
name|r4
init|=
operator|&
name|v
index|[
name|j
index|]
name|m3
operator|:
name|movl
name|r7
decl_stmt|,
name|r5
decl|#
name|r7
init|=
operator|&
name|w
index|[
name|j
operator|+
name|n
index|]
name|subl3
name|$4
decl_stmt|,
name|r11
decl_stmt|,
name|r3
decl|#
name|r3
init|=
operator|&
name|u
index|[
name|i
index|]
name|clrl
name|r2
operator|#
name|clear
name|carry
operator|.
name|m4
operator|:
name|addl2
operator|-
operator|(
name|r5
operator|)
decl_stmt|,
name|r2
decl|#
name|add
name|w
index|[
name|i
operator|+
name|j
index|]
name|to
name|carry
argument_list|(
name|no
name|ofl
name|poss
argument_list|)
name|emul
argument_list|(
name|r3
argument_list|)
decl_stmt|,
argument_list|(
name|r4
argument_list|)
decl_stmt|,
name|r2
decl_stmt|,
name|r0
decl|#
name|r0
init|=
name|u
index|[
name|i
index|]
operator|*
name|v
index|[
name|j
index|]
operator|+
name|sext
argument_list|(
argument|carry
argument_list|)
name|extzv
name|$0
decl_stmt|,
name|$30
decl_stmt|,
name|r0
decl_stmt|,
argument_list|(
name|r5
argument_list|)
decl_stmt|#
name|get
name|new
name|bigit
name|extv
name|$30
decl_stmt|,
name|$32
decl_stmt|,
name|r0
decl_stmt|,
name|r2
decl|#
name|get
name|new
name|carry
name|m5
range|:
name|acbl
name|r10
decl_stmt|,
name|$
decl|-4
decl_stmt|,
name|r3
decl_stmt|,
name|m4
decl|#
name|r3
init|=
operator|-
literal|4
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|r3
operator|>=
name|r10
condition|)
goto|goto
name|m4
goto|;
end_if

begin_expr_stmt
name|r10
operator|=
operator|&
index|[
name|u1
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|movl
name|r2
decl_stmt|,-
argument_list|(
name|r5
argument_list|)
decl_stmt|#
name|save
name|w
index|[
name|j
index|]
init|=
name|carry
name|m6
operator|:
name|subl2
name|$4
decl_stmt|,
name|r7
decl|#
name|add
name|just
modifier|&
name|w
index|[
name|j
operator|+
name|n
index|]
argument_list|(
operator|+
literal|4
for|for autodec
argument_list|)
name|acbl
name|r9
decl_stmt|,
name|$
decl|-4
decl_stmt|,
name|r4
decl_stmt|,
name|m3
decl|#
name|r4
init|=
operator|-
literal|4
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|r4
operator|>=
name|r9
condition|)
goto|goto
name|m5
goto|;
end_if

begin_expr_stmt
name|r9
operator|=
operator|&
name|v
index|[
literal|1
index|]
name|movl
name|r9
operator|,
name|r10
operator|#
name|set
name|up
end_expr_stmt

begin_for
for|for output routine 	movl	$0xC0000000
operator|,
name|r4
operator|#
name|r4
operator|=
name|clear
name|constant
operator|.
name|movq
literal|20
operator|(
name|fp
operator|)
operator|,
name|r6
operator|#
name|restor
name|_np
name|and
name|_lbot
operator|!
name|brw
name|iexport
operator|#
end_for

begin_do
do|do
name|it
operator|!
comment|/*  The remainder of this file are routines used in bignum division.  Interested parties should consult Knuth, Vol 2, and divbig.c.  These files are here only due to an optimizer bug. */
operator|.
name|align
literal|1
operator|.
name|globl
name|_calqhat
name|_calqhat
operator|:
operator|.
name|word
literal|0xf00
name|movl
literal|4
operator|(
name|ap
operator|)
operator|,
name|r11
operator|#
operator|&
name|u
index|[
name|j
index|]
name|into
name|r11
name|movl
literal|8
operator|(
name|ap
operator|)
operator|,
name|r10
operator|#
operator|&
name|v
index|[
literal|1
index|]
name|into
name|r10
name|cmpl
argument_list|(
name|r10
argument_list|)
operator|,
operator|(
name|r11
operator|)
operator|#
name|v
index|[
literal|1
index|]
operator|==
name|u
index|[
name|j
index|]
operator|??
name|beql
name|L102
empty|# calculate qhat and rhat simultaneously,
empty|#  qhat in r0
empty|#  rhat in r1
name|emul
argument_list|(
name|r11
argument_list|)
operator|,
name|$0x40000000
operator|,
literal|4
operator|(
name|r11
operator|)
operator|,
name|r4
operator|#
name|u
index|[
name|j
index|]
name|b
operator|+
name|u
index|[
name|j
operator|+
literal|1
index|]
name|into
name|r4
operator|,
name|r5
name|ediv
argument_list|(
name|r10
argument_list|)
operator|,
name|r4
operator|,
name|r0
operator|,
name|r1
operator|#
name|qhat
operator|=
operator|(
operator|(
name|u
index|[
name|j
index|]
name|b
operator|+
name|u
index|[
name|j
operator|+
literal|1
index|]
operator|)
operator|/
name|v
index|[
literal|1
index|]
operator|)
name|into
name|r0
empty|# (u[j]b+u[j+1] -qhat*v[1]) into r1
empty|# called rhat
name|L101
operator|:
empty|# check if v[2]*qhat> rhat*b+u[j+2]
name|emul
name|r0
operator|,
literal|4
operator|(
name|r10
operator|)
operator|,
name|$0
operator|,
name|r2
operator|#
name|qhat
operator|*
name|v
index|[
literal|2
index|]
name|into
name|r3
operator|,
name|r2
name|emul
name|r1
operator|,
name|$0x40000000
operator|,
literal|8
operator|(
name|r11
operator|)
operator|,
name|r8
operator|#
name|rhat
operator|*
name|b
operator|+
name|u
index|[
name|j
operator|+
literal|2
index|]
name|into
name|r9
operator|,
name|r8
empty|# give up if r3,r2<= r9,r8, otherwise iterate
name|subl2
name|r8
operator|,
name|r2
operator|#
name|perform
name|r3
operator|,
name|r2
operator|-
name|r9
operator|,
name|r8
name|sbwc
name|r9
operator|,
name|r3
name|bleq
name|L103
operator|#
name|give
name|up
if|if negative or equal 	decl	r0			# otherwise
operator|,
name|qhat
operator|=
name|qhat
operator|-
literal|1
name|addl2
argument_list|(
name|r10
argument_list|)
operator|,
name|r1
operator|#
name|since
name|dec
literal|'ed qhat, inc rhat by v[1] 	jbr	L101 L102:	 	# get here if v[1]==u[j] 	# set qhat to b-1 	# rhat is easily calculated since if we substitute b-1 for qhat in 	# the formula, then it simplifies to (u[j+1] + v[1]) 	#  	addl3	4(r11),(r10),r1		# rhat = u[j+1] + v[1] 	movl	$0x3fffffff,r0		# qhat = b-1 	jbr	L101 	 L103: 	ret  	.align	1 	.globl	_mlsb _mlsb: 	.word	.R2 	movl	4(ap),r11 	movl	8(ap),r10 	movl	12(ap),r9 	movl	16(ap),r8 	clrl	r0 loop8:	addl2	(r11),r0 	emul	r8,-(r9),r0,r2 	extzv	$0,$30,r2,(r11) 	extv	$30,$32,r2,r0 	acbl	r10,$-4,r11,loop8 	ret 	.set	.R2,0xf00 	.align	1 	.globl	_adback _adback: 	.word	.R3 	movl	4(ap),r11 	movl	8(ap),r10 	movl	12(ap),r9 	clrl	r0 loop9:	addl2	-(r9),r0 	addl2	(r11),r0 	extzv	$0,$30,r0,(r11) 	extv	$30,$2,r0,r0 	acbl	r10,$-4,r11,loop9 	ret 	.set	.R3,0xe00 	.align	1 	.globl	_dsdiv _dsdiv: 	.word	.R4 	movl	8(ap),r11 	clrl	r0 loopa:	emul	r0,$0x40000000,(r11),r1 	ediv	12(ap),r1,(r11),r0 	acbl	4(ap),$4,r11,loopa 	ret 	.set	.R4,0x800 	.align	1 	.globl	_dsmult _dsmult: 	.word	.R5 	movl	4(ap),r11 	clrl	r0 loopb:	emul	12(ap),(r11),r0,r1 	extzv	$0,$30,r1,(r11) 	extv	$30,$32,r1,r0 	acbl	8(ap),$-4,r11,loopb 	movl	r1,4(r11) 	ret 	.set	.R5,0x800 	.align	1 	.globl	_dsrsh _dsrsh: 	.word	.R7 	movl	8(ap),r11	# bot 	movl	16(ap),r5	# mask 	movl	12(ap),r4	# shift count 	clrl	r0 L201:	emul	r0,$0x40000000,(r11),r1 	bicl3	r5,r1,r0 	ashq	r4,r1,r1 	movl	r1,(r11) 	acbl	4(ap),$4,r11,L201 	ret 	.set	.R7,0x800 	.align	1 	.globl	_dsadd1 _dsadd1: 	.word	.R8 	movl	4(ap),r11 	movl	$1,r0 L501:	emul	$1,(r11),r0,r1 	extzv	$0,$30,r1,(r11) 	extv	$30,$32,r1,r0 	acbl	8(ap),$-4,r11,L501 	movl	r1,4(r11) 	ret 	.set	.R8,0x800 /* 	myfrexp (value, exp, hi, lo) 		double value; 		int *exp, *hi, *lo;  	myfrexp returns three values, exp, hi, lo, 	Such that value = 2**exp*tmp, where tmp = (hi*2**-23+lo*2**-53) 	is uniquely determined subect to .5< abs(tmp)<= 1.0 	  	Entry point */ 	.text 	.globl	_myfrexp _myfrexp: 	.word	0x0000		# We use r2, but do not save it  	clrl	*12(ap)		# Make for easy exit later 	clrl	*16(ap)		#  	clrl	*20(ap)		#  	movd	4(ap),r0	# Fetch "value" 	bneq	L301		# if zero return zero exponent + mantissa 	ret L301: 	extzv	$7,$8,r0,r2	# r2 := biased exponent 	movab	-129(r2),*12(ap)# subtract bias, store exp 	insv	$154,$7,$8,r0	# lie about exponent to get out 				# high 24 bits easily with emodd. /* 	This instruction does the following:  		Extend the long floating value in r0 with 0, and 		multiply it by 1.0.  Store the integer part of the result 		in hi, and the fractional part of the result in r0-r1. */ 	emodd	r0,$0,$0f1.0,*16(ap),r0	# How did you like 					# THAT, sports fans? [jfr'
name|s
name|comment
expr|]
name|tstd
name|r0
operator|#
if|if zero
operator|,
name|exit
expr_stmt|;
do|bneq	L401 	ret L401: 	insv	$158
operator|,
do|$7
operator|,
do|$8
operator|,
do|r0	# lie about exponent to get out
empty|# next 30 bits easily with emodd.
empty|# (2^29 takes 30 bits).
do|emodd	r0
operator|,
do|$0
operator|,
do|$0f1.0
operator|,
do|*20(ap
end_do

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|r0
operator|#
name|Get
name|last
name|bits
name|out
name|likewise
operator|!
name|ret
operator|#
operator|(
name|r0
name|should
name|be
name|zero
name|by
name|now
operator|!
operator|)
operator|.
name|globl
name|_inewint
name|_inewint
operator|:
operator|.
name|word
literal|0
name|movl
literal|4
operator|(
name|ap
operator|)
operator|,
name|r0
name|cmpl
name|r0
operator|,
name|$1024
name|jgeq
name|Ialloc
name|cmpl
name|r0
operator|,
name|$
operator|-
literal|1024
name|jlss
name|Ialloc
name|moval
name|_Fixzero
index|[
name|r0
index|]
operator|,
name|r0
name|ret
name|Ialloc
operator|:
name|calls
name|$0
operator|,
name|_newint
name|movl
literal|4
operator|(
name|ap
operator|)
operator|,
literal|0
operator|(
name|r0
operator|)
name|ret
operator|.
name|globl
name|_blzero
name|_blzero
operator|:
operator|#
name|blzero
argument_list|(
name|where
argument_list|,
name|howmuch
argument_list|)
empty|# char *where;
empty|# zeroes a block of length howmuch
empty|# beginning at where.
operator|.
name|word
literal|0
name|movc5
name|$0
operator|,
operator|*
literal|4
operator|(
name|ap
operator|)
operator|,
name|$0
operator|,
literal|8
operator|(
name|ap
operator|)
operator|,
operator|*
literal|4
operator|(
name|ap
operator|)
name|ret
end_expr_stmt

end_unit

