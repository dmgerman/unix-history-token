begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1979 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)READ8.c	1.11 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"h00vars.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function
name|double
name|READ8
parameter_list|(
name|curfile
parameter_list|)
specifier|register
name|struct
name|iorec
modifier|*
name|curfile
decl_stmt|;
block|{
name|double
name|data
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|curfile
operator|->
name|funit
operator|&
name|FWRITE
condition|)
block|{
name|ERROR
argument_list|(
literal|"%s: Attempt to read, but open for writing\n"
argument_list|,
name|curfile
operator|->
name|pfname
argument_list|)
expr_stmt|;
block|}
name|UNSYNC
argument_list|(
name|curfile
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|readreal
argument_list|(
name|curfile
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EOF
condition|)
block|{
name|ERROR
argument_list|(
literal|"%s: Tried to read past end of file\n"
argument_list|,
name|curfile
operator|->
name|pfname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|ERROR
argument_list|(
literal|"%s: Bad data found on real read\n"
argument_list|,
name|curfile
operator|->
name|pfname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
if|if
condition|(
name|data
operator|==
literal|0.0
condition|)
name|ERROR
argument_list|(
literal|"%s: Underflow on real read\n"
argument_list|,
name|curfile
operator|->
name|pfname
argument_list|)
expr_stmt|;
else|else
name|ERROR
argument_list|(
literal|"%s: Overflow on real read\n"
argument_list|,
name|curfile
operator|->
name|pfname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"Error encountered on real read "
argument_list|,
name|curfile
operator|->
name|pfname
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	given a file pointer, read a sequence of characters of the  *	syntax of section 6.1.5 and form them into a double.  *  *	the syntax of a signed-real is:  *	    [-|+] digit {digit} [ . digit {digit} ] [ e [+|-] digit {digit} ]  *  *	returns:  *		1	for success (with value in *doublep)  *		0	on error (with *doublep unchanged)  *	       -1	on end-of-file during read (with *doublep unchanged)  *	side effects:  *	      errno	may be set to ERANGE if atof() sets it.  */
end_comment

begin_macro
name|readreal
argument_list|(
argument|curfile
argument_list|,
argument|doublep
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iorec
modifier|*
name|curfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
modifier|*
name|doublep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|filep
init|=
name|curfile
operator|->
name|fbuf
decl_stmt|;
comment|/* current file variable */
name|char
modifier|*
name|sequencep
decl_stmt|;
comment|/* a pointer into sequence */
name|int
name|read
decl_stmt|;
comment|/* return value from fscanf() */
name|char
name|sequence
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* the character sequence */
name|double
name|atof
parameter_list|()
function_decl|;
define|#
directive|define
name|PUSHBACK
parameter_list|(
name|curfile
parameter_list|,
name|sequencep
parameter_list|)
define|\
value|if (ungetc(*--(sequencep), (curfile)->fbuf) != EOF) { \ 		*(sequencep) = '\0'; \ 	} else if ((curfile)->funit& SYNC) { \ 		(curfile)->funit&= ~SYNC; \ 		*(curfile)->fileptr = *(sequencep); \ 		*(sequencep) = '\0'; \ 	} else { \ 		return (0); \ 	}
define|#
directive|define
name|RETURN_ON_EOF
parameter_list|(
name|read
parameter_list|)
define|\
value|if (read == EOF) \ 		return (EOF); \ 	else \
comment|/* void */
value|;
define|#
directive|define
name|PUSH_TO_NULL
parameter_list|(
name|sequencep
parameter_list|)
define|\
value|while (*sequencep) \ 		sequencep++;
comment|/* general reader of the next character */
define|#
directive|define
name|NEXT_CHAR
parameter_list|(
name|read
parameter_list|,
name|filep
parameter_list|,
name|format
parameter_list|,
name|sequencep
parameter_list|)
define|\
value|read = fscanf(filep, "%c", sequencep); \ 	RETURN_ON_EOF(read); \ 	*++sequencep = '\0';
comment|/* e.g. use %[0123456789] for {digit}, and check read */
define|#
directive|define
name|SOME
parameter_list|(
name|read
parameter_list|,
name|filep
parameter_list|,
name|format
parameter_list|,
name|sequencep
parameter_list|)
define|\
value|read = fscanf(filep, format, sequencep); \ 	RETURN_ON_EOF(read); \ 	PUSH_TO_NULL(sequencep);
comment|/* e.g. use %[0123456789] for digit {digit} */
define|#
directive|define
name|AT_LEAST_ONE
parameter_list|(
name|read
parameter_list|,
name|filep
parameter_list|,
name|format
parameter_list|,
name|sequencep
parameter_list|)
define|\
value|read = fscanf(filep, format, sequencep); \ 	RETURN_ON_EOF(read); \ 	if (strlen(sequencep)< 1) \ 		return (0); \ 	PUSH_TO_NULL(sequencep);
define|#
directive|define
name|ANY_ONE_OF
parameter_list|(
name|read
parameter_list|,
name|filep
parameter_list|,
name|format
parameter_list|,
name|sequencep
parameter_list|)
define|\
value|read = fscanf(filep, format, sequencep); \ 	RETURN_ON_EOF(read); \ 	if (strlen(sequencep) != 1) \ 		return (0); \ 	PUSH_TO_NULL(sequencep);
define|#
directive|define
name|AT_MOST_ONE
parameter_list|(
name|read
parameter_list|,
name|filep
parameter_list|,
name|format
parameter_list|,
name|sequencep
parameter_list|)
define|\
value|read = fscanf(filep, format, sequencep); \ 	RETURN_ON_EOF(read); \ 	if (strlen(sequencep)> 1) \ 		return (0); \ 	PUSH_TO_NULL(sequencep);
name|sequencep
operator|=
operator|&
name|sequence
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|sequencep
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 *	skip leading whitespace 	 */
name|SOME
argument_list|(
name|read
argument_list|,
name|filep
argument_list|,
literal|"%*[ \t\n]"
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
comment|/* 	 *	this much is required: 	 *	[ "+" | "-" ] digit {digits} 	 */
name|AT_MOST_ONE
argument_list|(
name|read
argument_list|,
name|filep
argument_list|,
literal|"%[+-]"
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
name|AT_LEAST_ONE
argument_list|(
name|read
argument_list|,
name|filep
argument_list|,
literal|"%[0123456789]"
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
comment|/* 	 *	any of this is optional: 	 *	[ `.' digit {digit} ] [ `e' [ `+' | `-' ] digit {digits} ] 	 */
name|NEXT_CHAR
argument_list|(
name|read
argument_list|,
name|filep
argument_list|,
literal|"%c"
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sequencep
index|[
operator|-
literal|1
index|]
condition|)
block|{
default|default:
name|PUSHBACK
argument_list|(
name|curfile
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
goto|goto
name|convert
goto|;
case|case
literal|'.'
case|:
name|SOME
argument_list|(
name|read
argument_list|,
name|filep
argument_list|,
literal|"%[0123456789]"
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read
condition|)
block|{
name|PUSHBACK
argument_list|(
name|curfile
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
goto|goto
name|convert
goto|;
block|}
name|NEXT_CHAR
argument_list|(
name|read
argument_list|,
name|filep
argument_list|,
literal|"%c"
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequencep
index|[
operator|-
literal|1
index|]
operator|!=
literal|'e'
condition|)
block|{
name|PUSHBACK
argument_list|(
name|curfile
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
goto|goto
name|convert
goto|;
block|}
comment|/* fall through */
case|case
literal|'e'
case|:
name|NEXT_CHAR
argument_list|(
name|read
argument_list|,
name|filep
argument_list|,
literal|"%c"
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequencep
index|[
operator|-
literal|1
index|]
operator|!=
literal|'+'
operator|&&
name|sequencep
index|[
operator|-
literal|1
index|]
operator|!=
literal|'-'
condition|)
block|{
name|PUSHBACK
argument_list|(
name|curfile
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
name|SOME
argument_list|(
name|read
argument_list|,
name|filep
argument_list|,
literal|"%[0123456789]"
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read
condition|)
name|PUSHBACK
argument_list|(
name|curfile
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
goto|goto
name|convert
goto|;
block|}
name|SOME
argument_list|(
name|read
argument_list|,
name|filep
argument_list|,
literal|"%[0123456789]"
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read
condition|)
block|{
name|PUSHBACK
argument_list|(
name|curfile
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
name|PUSHBACK
argument_list|(
name|curfile
argument_list|,
name|sequencep
argument_list|)
expr_stmt|;
block|}
block|}
name|convert
label|:
comment|/* 	 * convert sequence to double 	 */
operator|*
name|doublep
operator|=
name|atof
argument_list|(
operator|&
name|sequence
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

