begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ptrace.c	8.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * routines for tracing the execution of a process  *  * The system call "ptrace" does all the work, these  * routines just try to interface easily to it.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"process.rep"
end_include

begin_include
include|#
directive|include
file|"pxinfo.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|mc68000
end_ifdef

begin_define
define|#
directive|define
name|U_PAGE
value|0x2400
end_define

begin_define
define|#
directive|define
name|U_AR0
value|(14*sizeof(int))
end_define

begin_decl_stmt
name|LOCAL
name|int
name|ar0val
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This magic macro enables us to look at the process' registers  * in its user structure.  Very gross.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_define
define|#
directive|define
name|regloc
parameter_list|(
name|reg
parameter_list|)
value|(ctob(UPAGES) + ( sizeof(int) * (reg) ))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|regloc
parameter_list|(
name|reg
parameter_list|)
value|(ar0val + ( sizeof(int) * (reg) ))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|WMASK
value|(~(sizeof(WORD) - 1))
end_define

begin_define
define|#
directive|define
name|cachehash
parameter_list|(
name|addr
parameter_list|)
value|((unsigned) ((addr>> 2) % CSIZE))
end_define

begin_define
define|#
directive|define
name|ischild
parameter_list|(
name|pid
parameter_list|)
value|((pid) == 0)
end_define

begin_define
define|#
directive|define
name|traceme
parameter_list|()
value|ptrace(0, 0, 0, 0)
end_define

begin_define
define|#
directive|define
name|setrep
parameter_list|(
name|n
parameter_list|)
value|(1<< ((n)-1))
end_define

begin_define
define|#
directive|define
name|istraced
parameter_list|(
name|p
parameter_list|)
value|(p->sigset&setrep(p->signo))
end_define

begin_comment
comment|/*  * ptrace options (specified in first argument)  */
end_comment

begin_define
define|#
directive|define
name|UREAD
value|3
end_define

begin_comment
comment|/* read from process's user structure */
end_comment

begin_define
define|#
directive|define
name|UWRITE
value|6
end_define

begin_comment
comment|/* write to process's user structure */
end_comment

begin_define
define|#
directive|define
name|IREAD
value|1
end_define

begin_comment
comment|/* read from process's instruction space */
end_comment

begin_define
define|#
directive|define
name|IWRITE
value|4
end_define

begin_comment
comment|/* write to process's instruction space */
end_comment

begin_define
define|#
directive|define
name|DREAD
value|2
end_define

begin_comment
comment|/* read from process's data space */
end_comment

begin_define
define|#
directive|define
name|DWRITE
value|5
end_define

begin_comment
comment|/* write to process's data space */
end_comment

begin_define
define|#
directive|define
name|CONT
value|7
end_define

begin_comment
comment|/* continue stopped process */
end_comment

begin_define
define|#
directive|define
name|SSTEP
value|9
end_define

begin_comment
comment|/* continue for approximately one instruction */
end_comment

begin_define
define|#
directive|define
name|PKILL
value|8
end_define

begin_comment
comment|/* terminate the process */
end_comment

begin_comment
comment|/*  * Start up a new process by forking and exec-ing the  * given argument list, returning when the process is loaded  * and ready to execute.  The PROCESS information (pointed to  * by the first argument) is appropriately filled.  *  * If the given PROCESS structure is associated with an already running  * process, we terminate it.  */
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_macro
name|pstart
argument_list|(
argument|p
argument_list|,
argument|cmd
argument_list|,
argument|argv
argument_list|,
argument|infile
argument_list|,
argument|outfile
argument_list|)
end_macro

begin_decl_stmt
name|PROCESS
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|status
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pid
operator|!=
literal|0
condition|)
block|{
comment|/* child already running? */
name|ptrace
argument_list|(
name|PKILL
argument_list|,
name|p
operator|->
name|pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... kill it! */
block|}
ifdef|#
directive|ifdef
name|tahoe
name|INTFP
operator|=
operator|(
name|ADDRESS
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
endif|tahoe
name|psigtrace
argument_list|(
name|p
argument_list|,
name|SIGTRAP
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|panic
argument_list|(
literal|"can't fork"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ischild
argument_list|(
name|p
operator|->
name|pid
argument_list|)
condition|)
block|{
name|traceme
argument_list|()
expr_stmt|;
if|if
condition|(
name|infile
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|infile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NIL
condition|)
block|{
name|printf
argument_list|(
literal|"can't read %s\n"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fswap
argument_list|(
literal|0
argument_list|,
name|fileno
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outfile
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NIL
condition|)
block|{
name|printf
argument_list|(
literal|"can't write %s\n"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fswap
argument_list|(
literal|1
argument_list|,
name|fileno
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|execvp
argument_list|(
name|cmd
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"can't exec %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|pwait
argument_list|(
name|p
operator|->
name|pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|getinfo
argument_list|(
name|p
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Continue a stopped process.  The argument points to a PROCESS structure.  * Before the process is restarted it's user area is modified according to  * the values in the structure.  When this routine finishes,  * the structure has the new values from the process's user area.  *  * Pcont terminates when the process stops with a signal pending that  * is being traced (via psigtrace), or when the process terminates.  */
end_comment

begin_macro
name|pcont
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|PROCESS
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pid
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"program not active"
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|setinfo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigs_off
argument_list|()
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|CONT
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|p
operator|->
name|pc
argument_list|,
name|p
operator|->
name|signo
argument_list|)
operator|<
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"can't continue process"
argument_list|)
expr_stmt|;
block|}
name|pwait
argument_list|(
name|p
operator|->
name|pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|sigs_on
argument_list|()
expr_stmt|;
name|getinfo
argument_list|(
name|p
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|->
name|status
operator|==
name|STOPPED
operator|&&
operator|!
name|istraced
argument_list|(
name|p
argument_list|)
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  * single step as best ptrace can  */
end_comment

begin_macro
name|pstep
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|PROCESS
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|status
decl_stmt|;
name|setinfo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigs_off
argument_list|()
expr_stmt|;
name|ptrace
argument_list|(
name|SSTEP
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|p
operator|->
name|pc
argument_list|,
name|p
operator|->
name|signo
argument_list|)
expr_stmt|;
name|pwait
argument_list|(
name|p
operator|->
name|pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|sigs_on
argument_list|()
expr_stmt|;
name|getinfo
argument_list|(
name|p
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return from execution when the given signal is pending.  */
end_comment

begin_macro
name|psigtrace
argument_list|(
argument|p
argument_list|,
argument|sig
argument_list|,
argument|sw
argument_list|)
end_macro

begin_decl_stmt
name|PROCESS
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sw
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sw
condition|)
block|{
name|p
operator|->
name|sigset
operator||=
name|setrep
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|sigset
operator|&=
operator|~
name|setrep
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Don't catch any signals.  * Particularly useful when letting a process finish uninhibited (i.e. px).  */
end_comment

begin_macro
name|unsetsigtraces
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|PROCESS
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p
operator|->
name|sigset
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * turn off attention to signals not being caught  */
end_comment

begin_decl_stmt
name|LOCAL
name|void
modifier|*
name|onintr
decl_stmt|,
modifier|*
name|onquit
decl_stmt|;
end_decl_stmt

begin_function
name|LOCAL
name|sigs_off
parameter_list|()
block|{
name|onintr
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|onquit
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * turn back on attention to signals  */
end_comment

begin_function
name|LOCAL
name|sigs_on
parameter_list|()
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get PROCESS information from process's user area  */
end_comment

begin_if
if|#
directive|if
name|vax
end_if

begin_decl_stmt
name|LOCAL
name|int
name|rloc
index|[]
init|=
block|{
name|R0
block|,
name|R1
block|,
name|R2
block|,
name|R3
block|,
name|R4
block|,
name|R5
block|,
name|R6
block|,
name|R7
block|,
name|R8
block|,
name|R9
block|,
name|R10
block|,
name|R11
block|,     }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|tahoe
end_if

begin_decl_stmt
name|LOCAL
name|int
name|rloc
index|[]
init|=
block|{
name|R0
block|,
name|R1
block|,
name|R2
block|,
name|R3
block|,
name|R4
block|,
name|R5
block|,
name|R6
block|,
name|R7
block|,
name|R8
block|,
name|R9
block|,
name|R10
block|,
name|R11
block|,
name|R12
block|,     }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|mc68000
end_if

begin_decl_stmt
name|LOCAL
name|int
name|rloc
index|[]
init|=
block|{
name|D0
block|,
name|D1
block|,
name|D2
block|,
name|D3
block|,
name|D4
block|,
name|D5
block|,
name|D6
block|,
name|D7
block|,
name|A0
block|,
name|A1
block|,
name|A2
block|,
name|A3
block|,
name|A4
block|,
name|A5
block|,     }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|LOCAL
name|getinfo
parameter_list|(
name|p
parameter_list|,
name|status
parameter_list|)
specifier|register
name|PROCESS
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|p
operator|->
name|signo
operator|=
operator|(
name|status
operator|&
literal|0177
operator|)
expr_stmt|;
name|p
operator|->
name|exitval
operator|=
operator|(
operator|(
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|signo
operator|==
name|STOPPED
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|p
operator|->
name|signo
expr_stmt|;
name|p
operator|->
name|signo
operator|=
name|p
operator|->
name|exitval
expr_stmt|;
name|p
operator|->
name|exitval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|status
operator|=
name|FINISHED
expr_stmt|;
return|return;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|vax
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|tahoe
argument_list|)
if|if
condition|(
name|ar0val
operator|<
literal|0
condition|)
block|{
name|ar0val
operator|=
name|ptrace
argument_list|(
name|UREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|U_AR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar0val
operator|-=
name|U_PAGE
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NREG
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|->
name|reg
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|UREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|rloc
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|oreg
index|[
name|i
index|]
operator|=
name|p
operator|->
name|reg
index|[
name|i
index|]
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
name|p
operator|->
name|fp
operator|=
name|p
operator|->
name|ofp
operator|=
name|ptrace
argument_list|(
name|UREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|FP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|sp
operator|=
name|p
operator|->
name|osp
operator|=
name|ptrace
argument_list|(
name|UREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|SP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|pc
operator|=
name|p
operator|->
name|opc
operator|=
name|ptrace
argument_list|(
name|UREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|PC
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|vax
name|p
operator|->
name|ap
operator|=
name|p
operator|->
name|oap
operator|=
name|ptrace
argument_list|(
name|UREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|AP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|mc68000
name|p
operator|->
name|fp
operator|=
name|p
operator|->
name|ofp
operator|=
name|ptrace
argument_list|(
name|UREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|A6
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|ap
operator|=
name|p
operator|->
name|oap
operator|=
name|p
operator|->
name|fp
expr_stmt|;
name|p
operator|->
name|sp
operator|=
name|p
operator|->
name|osp
operator|=
name|ptrace
argument_list|(
name|UREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|SP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|pc
operator|=
name|p
operator|->
name|opc
operator|=
name|ptrace
argument_list|(
name|UREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|PC
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * set process's user area information from given PROCESS structure  */
end_comment

begin_function
name|LOCAL
name|setinfo
parameter_list|(
name|p
parameter_list|)
specifier|register
name|PROCESS
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
if|if
condition|(
name|istraced
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|p
operator|->
name|signo
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NREG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|p
operator|->
name|reg
index|[
name|i
index|]
operator|)
operator|!=
name|p
operator|->
name|oreg
index|[
name|i
index|]
condition|)
block|{
name|ptrace
argument_list|(
name|UWRITE
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|rloc
index|[
name|i
index|]
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|vax
operator|||
name|tahoe
if|if
condition|(
operator|(
name|r
operator|=
name|p
operator|->
name|fp
operator|)
operator|!=
name|p
operator|->
name|ofp
condition|)
block|{
name|ptrace
argument_list|(
name|UWRITE
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|FP
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|vax
if|if
condition|(
operator|(
name|r
operator|=
name|p
operator|->
name|ap
operator|)
operator|!=
name|p
operator|->
name|oap
condition|)
block|{
name|ptrace
argument_list|(
name|UWRITE
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|AP
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|mc68000
if|if
condition|(
operator|(
name|r
operator|=
name|p
operator|->
name|fp
operator|)
operator|!=
name|p
operator|->
name|ofp
condition|)
block|{
name|ptrace
argument_list|(
name|UWRITE
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|A6
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|r
operator|=
name|p
operator|->
name|sp
operator|)
operator|!=
name|p
operator|->
name|osp
condition|)
block|{
name|ptrace
argument_list|(
name|UWRITE
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|SP
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|p
operator|->
name|pc
operator|)
operator|!=
name|p
operator|->
name|opc
condition|)
block|{
name|ptrace
argument_list|(
name|UWRITE
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|PC
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Structure for reading and writing by words, but dealing with bytes.  */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|WORD
name|pword
decl_stmt|;
name|BYTE
name|pbyte
index|[
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
index|]
decl_stmt|;
block|}
name|PWORD
typedef|;
end_typedef

begin_comment
comment|/*  * Read (write) from (to) the process' address space.  * We must deal with ptrace's inability to look anywhere other  * than at a word boundary.  */
end_comment

begin_function_decl
name|LOCAL
name|WORD
name|fetch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|LOCAL
name|store
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|pio
argument_list|(
argument|p
argument_list|,
argument|op
argument_list|,
argument|seg
argument_list|,
argument|buff
argument_list|,
argument|addr
argument_list|,
argument|nbytes
argument_list|)
end_macro

begin_decl_stmt
name|PROCESS
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PIO_OP
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PIO_SEG
name|seg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDRESS
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nbytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|ADDRESS
name|newaddr
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
name|PWORD
name|w
decl_stmt|;
name|ADDRESS
name|wordaddr
decl_stmt|;
name|int
name|byteoff
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|status
operator|!=
name|STOPPED
condition|)
block|{
name|error
argument_list|(
literal|"program is not active"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|buff
expr_stmt|;
name|newaddr
operator|=
name|addr
expr_stmt|;
name|wordaddr
operator|=
operator|(
name|newaddr
operator|&
name|WMASK
operator|)
expr_stmt|;
if|if
condition|(
name|wordaddr
operator|!=
name|newaddr
condition|)
block|{
name|w
operator|.
name|pword
operator|=
name|fetch
argument_list|(
name|p
argument_list|,
name|seg
argument_list|,
name|wordaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|newaddr
operator|-
name|wordaddr
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
operator|&&
name|nbytes
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|op
operator|==
name|PREAD
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|w
operator|.
name|pbyte
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|w
operator|.
name|pbyte
index|[
name|i
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
name|nbytes
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|PWRITE
condition|)
block|{
name|store
argument_list|(
name|p
argument_list|,
name|seg
argument_list|,
name|wordaddr
argument_list|,
name|w
operator|.
name|pword
argument_list|)
expr_stmt|;
block|}
name|newaddr
operator|=
name|wordaddr
operator|+
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
block|}
name|byteoff
operator|=
operator|(
name|nbytes
operator|&
operator|(
operator|~
name|WMASK
operator|)
operator|)
expr_stmt|;
name|nbytes
operator|-=
name|byteoff
expr_stmt|;
name|bufend
operator|=
name|cp
operator|+
name|nbytes
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|bufend
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|PREAD
condition|)
block|{
name|w
operator|.
name|pword
operator|=
name|fetch
argument_list|(
name|p
argument_list|,
name|seg
argument_list|,
name|newaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
operator|*
name|cp
operator|++
operator|=
name|w
operator|.
name|pbyte
index|[
name|k
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
name|w
operator|.
name|pbyte
index|[
name|k
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
name|store
argument_list|(
name|p
argument_list|,
name|seg
argument_list|,
name|newaddr
argument_list|,
name|w
operator|.
name|pword
argument_list|)
expr_stmt|;
block|}
name|newaddr
operator|+=
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|byteoff
operator|>
literal|0
condition|)
block|{
name|w
operator|.
name|pword
operator|=
name|fetch
argument_list|(
name|p
argument_list|,
name|seg
argument_list|,
name|newaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|byteoff
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|op
operator|==
name|PREAD
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|w
operator|.
name|pbyte
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|w
operator|.
name|pbyte
index|[
name|i
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|==
name|PWRITE
condition|)
block|{
name|store
argument_list|(
name|p
argument_list|,
name|seg
argument_list|,
name|newaddr
argument_list|,
name|w
operator|.
name|pword
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Get a word from a process at the given address.  * The address is assumed to be on a word boundary.  *  * We use a simple cache scheme to avoid redundant references to  * the instruction space (which is assumed to be pure).  In the  * case of px, the "instruction" space lies between ENDOFF and  * ENDOFF + objsize.  *  * It is necessary to use a write-through scheme so that  * breakpoints right next to each other don't interfere.  */
end_comment

begin_function
name|LOCAL
name|WORD
name|fetch
parameter_list|(
name|p
parameter_list|,
name|seg
parameter_list|,
name|addr
parameter_list|)
name|PROCESS
modifier|*
name|p
decl_stmt|;
name|PIO_SEG
name|seg
decl_stmt|;
specifier|register
name|int
name|addr
decl_stmt|;
block|{
specifier|register
name|CACHEWORD
modifier|*
name|wp
decl_stmt|;
specifier|register
name|WORD
name|w
decl_stmt|;
switch|switch
condition|(
name|seg
condition|)
block|{
case|case
name|TEXTSEG
case|:
name|panic
argument_list|(
literal|"tried to fetch from px i-space"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|DATASEG
case|:
if|if
condition|(
name|addr
operator|>=
name|ENDOFF
operator|&&
name|addr
operator|<
name|ENDOFF
operator|+
name|objsize
condition|)
block|{
name|wp
operator|=
operator|&
name|p
operator|->
name|word
index|[
name|cachehash
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
operator|||
name|wp
operator|->
name|addr
operator|!=
name|addr
condition|)
block|{
name|w
operator|=
name|ptrace
argument_list|(
name|DREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wp
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|wp
operator|->
name|val
operator|=
name|w
expr_stmt|;
block|}
else|else
block|{
name|w
operator|=
name|wp
operator|->
name|val
expr_stmt|;
block|}
block|}
else|else
block|{
name|w
operator|=
name|ptrace
argument_list|(
name|DREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"fetch: bad seg %d"
argument_list|,
name|seg
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
operator|(
name|w
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put a word into the process' address space at the given address.  * The address is assumed to be on a word boundary.  */
end_comment

begin_function
name|LOCAL
name|store
parameter_list|(
name|p
parameter_list|,
name|seg
parameter_list|,
name|addr
parameter_list|,
name|data
parameter_list|)
name|PROCESS
modifier|*
name|p
decl_stmt|;
name|PIO_SEG
name|seg
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|WORD
name|data
decl_stmt|;
block|{
specifier|register
name|CACHEWORD
modifier|*
name|wp
decl_stmt|;
switch|switch
condition|(
name|seg
condition|)
block|{
case|case
name|TEXTSEG
case|:
name|wp
operator|=
operator|&
name|p
operator|->
name|word
index|[
name|cachehash
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
name|wp
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|wp
operator|->
name|val
operator|=
name|data
expr_stmt|;
name|ptrace
argument_list|(
name|IWRITE
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATASEG
case|:
if|if
condition|(
name|addr
operator|>=
name|ENDOFF
operator|&&
name|addr
operator|<
name|ENDOFF
operator|+
name|objsize
condition|)
block|{
name|wp
operator|=
operator|&
name|p
operator|->
name|word
index|[
name|cachehash
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
name|wp
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|wp
operator|->
name|val
operator|=
name|data
expr_stmt|;
block|}
name|ptrace
argument_list|(
name|DWRITE
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"store: bad seg %d"
argument_list|,
name|seg
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the instruction cache for a process.  * This is particularly necessary after the program has been remade.  */
end_comment

begin_macro
name|initcache
argument_list|(
argument|process
argument_list|)
end_macro

begin_decl_stmt
name|PROCESS
modifier|*
name|process
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CSIZE
condition|;
name|i
operator|++
control|)
block|{
name|process
operator|->
name|word
index|[
name|i
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Swap file numbers so as to redirect standard input and output.  */
end_comment

begin_function
name|LOCAL
name|fswap
parameter_list|(
name|oldfd
parameter_list|,
name|newfd
parameter_list|)
name|int
name|oldfd
decl_stmt|;
name|int
name|newfd
decl_stmt|;
block|{
if|if
condition|(
name|oldfd
operator|!=
name|newfd
condition|)
block|{
name|close
argument_list|(
name|oldfd
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|tahoe
end_ifdef

begin_decl_stmt
name|BOOLEAN
name|didret
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|chkret
parameter_list|(
name|p
parameter_list|,
name|status
parameter_list|)
name|PROCESS
modifier|*
name|p
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
name|status
operator|==
operator|(
name|SIGILL
operator|<<
literal|8
operator|)
operator||
name|STOPPED
operator|)
operator|||
operator|(
name|status
operator|==
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
name|STOPPED
operator|)
operator|)
condition|)
block|{
name|didret
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|didret
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|doret
parameter_list|(
name|p
parameter_list|)
name|PROCESS
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|didret
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|++
name|count
operator|>
literal|5
condition|)
block|{
name|panic
argument_list|(
literal|"px would not return to interpreter"
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|pc
operator|=
name|RETLOC
expr_stmt|;
name|pstep
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|INTFP
operator|&&
name|p
operator|->
name|fp
operator|!=
name|INTFP
condition|)
do|;
name|didret
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

