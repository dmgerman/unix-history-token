begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)tree.c 1.5 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This module contains the interface between the SYM routines and  * the parse tree routines.  It would be nice if such a crude  * interface were not necessary, but some parts of tree building are  * language and hence SYM-representation dependent.  It's probably  * better to have tree-representation dependent code here than vice versa.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"btypes.h"
end_include

begin_include
include|#
directive|include
file|"classes.h"
end_include

begin_include
include|#
directive|include
file|"sym.rep"
end_include

begin_include
include|#
directive|include
file|"tree/tree.rep"
end_include

begin_typedef
typedef|typedef
name|char
modifier|*
name|ARGLIST
typedef|;
end_typedef

begin_define
define|#
directive|define
name|nextarg
parameter_list|(
name|arglist
parameter_list|,
name|type
parameter_list|)
value|((type *) (arglist += sizeof(type)))[-1]
end_define

begin_function_decl
name|LOCAL
name|SYM
modifier|*
name|mkstring
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|LOCAL
name|SYM
modifier|*
name|namenode
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Determine the type of a parse tree.  While we're at, check  * the parse tree out.  */
end_comment

begin_function
name|SYM
modifier|*
name|treetype
parameter_list|(
name|p
parameter_list|,
name|ap
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
specifier|register
name|ARGLIST
name|ap
decl_stmt|;
block|{
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|O_NAME
case|:
block|{
name|SYM
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|SYM
operator|*
argument_list|)
expr_stmt|;
name|s
operator|=
name|which
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|namenode
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
return|;
comment|/* NOTREACHED */
block|}
case|case
name|O_WHICH
case|:
name|p
operator|->
name|nameval
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|SYM
operator|*
argument_list|)
expr_stmt|;
name|p
operator|->
name|nameval
operator|=
name|which
argument_list|(
name|p
operator|->
name|nameval
argument_list|)
expr_stmt|;
return|return
name|NIL
return|;
case|case
name|O_LCON
case|:
return|return
name|t_int
return|;
case|case
name|O_FCON
case|:
return|return
name|t_real
return|;
case|case
name|O_SCON
case|:
block|{
name|char
modifier|*
name|cpy
decl_stmt|;
name|SYM
modifier|*
name|s
decl_stmt|;
name|cpy
operator|=
name|strdup
argument_list|(
name|p
operator|->
name|sconval
argument_list|)
expr_stmt|;
name|p
operator|->
name|sconval
operator|=
name|cpy
expr_stmt|;
name|s
operator|=
name|mkstring
argument_list|(
name|p
operator|->
name|sconval
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|t_char
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|O_LCON
expr_stmt|;
name|p
operator|->
name|lconval
operator|=
name|p
operator|->
name|sconval
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
case|case
name|O_INDIR
case|:
name|p
operator|->
name|left
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
name|chkclass
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
return|return
name|rtype
argument_list|(
name|p
operator|->
name|left
operator|->
name|nodetype
argument_list|)
operator|->
name|type
return|;
case|case
name|O_RVAL
case|:
block|{
name|NODE
modifier|*
name|p1
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p1
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|p1
operator|->
name|nodetype
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|O_NAME
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|nodetype
operator|->
name|class
operator|==
name|FUNC
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|O_CALL
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|NIL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|nameval
operator|->
name|class
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|nameval
operator|->
name|type
operator|==
name|t_real
operator|->
name|type
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|O_FCON
expr_stmt|;
name|p
operator|->
name|fconval
operator|=
name|p1
operator|->
name|nameval
operator|->
name|symvalue
operator|.
name|fconval
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|t_real
expr_stmt|;
name|dispose
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|O_LCON
expr_stmt|;
name|p
operator|->
name|lconval
operator|=
name|p1
operator|->
name|nameval
operator|->
name|symvalue
operator|.
name|iconval
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|p1
operator|->
name|nameval
operator|->
name|type
expr_stmt|;
name|dispose
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|p
operator|->
name|nodetype
return|;
comment|/* NOTREACHED */
block|}
case|case
name|O_CALL
case|:
block|{
name|SYM
modifier|*
name|s
decl_stmt|;
name|p
operator|->
name|left
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|left
operator|->
name|nodetype
expr_stmt|;
if|if
condition|(
name|isblock
argument_list|(
name|s
argument_list|)
operator|&&
name|isbuiltin
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|p
operator|->
name|op
operator|=
operator|(
name|OP
operator|)
name|s
operator|->
name|symvalue
operator|.
name|token
operator|.
name|tokval
expr_stmt|;
name|tfree
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|p
operator|->
name|right
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|NIL
expr_stmt|;
block|}
return|return
name|s
operator|->
name|type
return|;
block|}
case|case
name|O_ITOF
case|:
return|return
name|t_real
return|;
case|case
name|O_NEG
case|:
block|{
name|SYM
modifier|*
name|s
decl_stmt|;
name|p
operator|->
name|left
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|left
operator|->
name|nodetype
expr_stmt|;
if|if
condition|(
operator|!
name|compatible
argument_list|(
name|s
argument_list|,
name|t_int
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|compatible
argument_list|(
name|s
argument_list|,
name|t_real
argument_list|)
condition|)
block|{
name|trerror
argument_list|(
literal|"%t is improper type"
argument_list|,
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|O_NEGF
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
case|case
name|O_ADD
case|:
case|case
name|O_SUB
case|:
case|case
name|O_MUL
case|:
case|case
name|O_LT
case|:
case|case
name|O_LE
case|:
case|case
name|O_GT
case|:
case|case
name|O_GE
case|:
case|case
name|O_EQ
case|:
case|case
name|O_NE
case|:
block|{
name|BOOLEAN
name|t1real
decl_stmt|,
name|t2real
decl_stmt|;
name|SYM
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|p
operator|->
name|left
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
name|t1
operator|=
name|rtype
argument_list|(
name|p
operator|->
name|left
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|t2
operator|=
name|rtype
argument_list|(
name|p
operator|->
name|right
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|t1real
operator|=
operator|(
name|t1
operator|==
name|t_real
operator|)
expr_stmt|;
name|t2real
operator|=
operator|(
name|t2
operator|==
name|t_real
operator|)
expr_stmt|;
if|if
condition|(
name|t1real
operator|||
name|t2real
condition|)
block|{
name|p
operator|->
name|op
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|t1real
condition|)
block|{
name|p
operator|->
name|left
operator|=
name|build
argument_list|(
name|O_ITOF
argument_list|,
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|t2real
condition|)
block|{
name|p
operator|->
name|right
operator|=
name|build
argument_list|(
name|O_ITOF
argument_list|,
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|t1real
condition|)
block|{
name|convert
argument_list|(
operator|&
name|p
operator|->
name|left
argument_list|,
name|t_int
argument_list|,
name|O_NOP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t2real
condition|)
block|{
name|convert
argument_list|(
operator|&
name|p
operator|->
name|right
argument_list|,
name|t_int
argument_list|,
name|O_NOP
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|>=
name|O_LT
condition|)
block|{
return|return
name|t_boolean
return|;
block|}
else|else
block|{
if|if
condition|(
name|t1real
operator|||
name|t2real
condition|)
block|{
return|return
name|t_real
return|;
block|}
else|else
block|{
return|return
name|t_int
return|;
block|}
block|}
comment|/* NOTREACHED */
block|}
case|case
name|O_DIVF
case|:
name|p
operator|->
name|left
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
name|convert
argument_list|(
operator|&
name|p
operator|->
name|left
argument_list|,
name|t_real
argument_list|,
name|O_ITOF
argument_list|)
expr_stmt|;
name|convert
argument_list|(
operator|&
name|p
operator|->
name|right
argument_list|,
name|t_real
argument_list|,
name|O_ITOF
argument_list|)
expr_stmt|;
return|return
name|t_real
return|;
case|case
name|O_DIV
case|:
case|case
name|O_MOD
case|:
name|p
operator|->
name|left
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
name|convert
argument_list|(
operator|&
name|p
operator|->
name|left
argument_list|,
name|t_int
argument_list|,
name|O_NOP
argument_list|)
expr_stmt|;
name|convert
argument_list|(
operator|&
name|p
operator|->
name|right
argument_list|,
name|t_int
argument_list|,
name|O_NOP
argument_list|)
expr_stmt|;
return|return
name|t_int
return|;
case|case
name|O_AND
case|:
case|case
name|O_OR
case|:
name|p
operator|->
name|left
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|nextarg
argument_list|(
name|ap
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
name|chkboolean
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|chkboolean
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
return|return
name|t_boolean
return|;
default|default:
return|return
name|NIL
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create a node for a name.  The symbol for the name has already  * been chosen, either implicitly with "which" or explicitly from  * the dot routine.  */
end_comment

begin_function
name|LOCAL
name|SYM
modifier|*
name|namenode
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|NODE
modifier|*
name|p
decl_stmt|;
name|SYM
modifier|*
name|s
decl_stmt|;
block|{
name|NODE
modifier|*
name|np
decl_stmt|;
name|p
operator|->
name|nameval
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|class
operator|==
name|REF
condition|)
block|{
name|np
operator|=
name|alloc
argument_list|(
literal|1
argument_list|,
name|NODE
argument_list|)
expr_stmt|;
operator|*
name|np
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|O_INDIR
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|np
expr_stmt|;
name|np
operator|->
name|nodetype
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|class
operator|==
name|CONST
operator|||
name|s
operator|->
name|class
operator|==
name|VAR
operator|||
name|s
operator|->
name|class
operator|==
name|FVAR
condition|)
block|{
return|return
name|s
operator|->
name|type
return|;
block|}
else|else
block|{
return|return
name|s
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert a tree to a type via a conversion operator;  * if this isn't possible generate an error.  *  * Note the tree is call by address, hence the #define below.  */
end_comment

begin_function
name|LOCAL
name|convert
parameter_list|(
name|tp
parameter_list|,
name|typeto
parameter_list|,
name|op
parameter_list|)
name|NODE
modifier|*
modifier|*
name|tp
decl_stmt|;
name|SYM
modifier|*
name|typeto
decl_stmt|;
name|OP
name|op
decl_stmt|;
block|{
define|#
directive|define
name|tree
value|(*tp)
name|SYM
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|rtype
argument_list|(
name|tree
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|typeto
operator|=
name|rtype
argument_list|(
name|typeto
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeto
operator|==
name|t_real
operator|&&
name|compatible
argument_list|(
name|s
argument_list|,
name|t_int
argument_list|)
condition|)
block|{
name|tree
operator|=
name|build
argument_list|(
name|op
argument_list|,
name|tree
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|compatible
argument_list|(
name|s
argument_list|,
name|typeto
argument_list|)
condition|)
block|{
name|trerror
argument_list|(
literal|"%t is improper type"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|!=
name|O_NOP
operator|&&
name|s
operator|!=
name|typeto
condition|)
block|{
name|tree
operator|=
name|build
argument_list|(
name|op
argument_list|,
name|tree
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|tree
block|}
end_function

begin_comment
comment|/*  * Construct a node for the Pascal dot operator.  *  * If the left operand is not a record, but rather a procedure  * or function, then we interpret the "." as referencing an  * "invisible" variable; i.e. a variable within a dynamically  * active block but not within the static scope of the current procedure.  */
end_comment

begin_function
name|NODE
modifier|*
name|dot
parameter_list|(
name|record
parameter_list|,
name|field
parameter_list|)
name|NODE
modifier|*
name|record
decl_stmt|;
name|SYM
modifier|*
name|field
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
specifier|register
name|SYM
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|isblock
argument_list|(
name|record
operator|->
name|nodetype
argument_list|)
condition|)
block|{
name|s
operator|=
name|findsym
argument_list|(
name|field
argument_list|,
name|record
operator|->
name|nodetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NIL
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not defined in \"%s\""
argument_list|,
name|field
operator|->
name|symbol
argument_list|,
name|record
operator|->
name|nodetype
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|alloc
argument_list|(
literal|1
argument_list|,
name|NODE
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|O_NAME
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|namenode
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|findclass
argument_list|(
name|field
argument_list|,
name|FIELD
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NIL
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not a field"
argument_list|,
name|field
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
name|field
operator|=
name|s
expr_stmt|;
name|chkfield
argument_list|(
name|record
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|p
operator|=
name|alloc
argument_list|(
literal|1
argument_list|,
name|NODE
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|O_ADD
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|field
operator|->
name|type
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|record
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|build
argument_list|(
name|O_LCON
argument_list|,
operator|(
name|long
operator|)
name|field
operator|->
name|symvalue
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Return a tree corresponding to an array reference and do the  * error checking.  */
end_comment

begin_function
name|NODE
modifier|*
name|subscript
parameter_list|(
name|a
parameter_list|,
name|slist
parameter_list|)
name|NODE
modifier|*
name|a
decl_stmt|,
decl|*
name|slist
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|SYM
modifier|*
name|t
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
name|SYM
modifier|*
name|etype
decl_stmt|,
modifier|*
name|atype
decl_stmt|,
modifier|*
name|eltype
decl_stmt|;
name|NODE
modifier|*
name|esub
decl_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|a
operator|->
name|nodetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|class
operator|!=
name|ARRAY
condition|)
block|{
name|trerror
argument_list|(
literal|"%t is not an array"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
name|eltype
operator|=
name|t
operator|->
name|type
expr_stmt|;
name|p
operator|=
name|slist
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|chain
expr_stmt|;
for|for
control|(
init|;
name|p
operator|!=
name|NIL
operator|&&
name|t
operator|!=
name|NIL
condition|;
name|p
operator|=
name|p
operator|->
name|right
operator|,
name|t
operator|=
name|t
operator|->
name|chain
control|)
block|{
name|esub
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|etype
operator|=
name|rtype
argument_list|(
name|esub
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|atype
operator|=
name|rtype
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compatible
argument_list|(
name|atype
argument_list|,
name|etype
argument_list|)
condition|)
block|{
name|trerror
argument_list|(
literal|"subscript %t is the wrong type"
argument_list|,
name|esub
argument_list|)
expr_stmt|;
block|}
name|esub
operator|->
name|nodetype
operator|=
name|atype
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|NIL
condition|)
block|{
name|trerror
argument_list|(
literal|"too many subscripts for %t"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|NIL
condition|)
block|{
name|trerror
argument_list|(
literal|"not enough subscripts for %t"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|alloc
argument_list|(
literal|1
argument_list|,
name|NODE
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|O_INDEX
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|a
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|slist
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|eltype
expr_stmt|;
return|return
name|p
return|;
block|}
end_block

begin_comment
comment|/*  * Evaluate a subscript (possibly more than one index).  */
end_comment

begin_function
name|long
name|evalindex
parameter_list|(
name|arraytype
parameter_list|,
name|subs
parameter_list|)
name|SYM
modifier|*
name|arraytype
decl_stmt|;
name|NODE
modifier|*
name|subs
decl_stmt|;
block|{
name|long
name|lb
decl_stmt|,
name|ub
decl_stmt|,
name|index
decl_stmt|,
name|i
decl_stmt|;
name|SYM
modifier|*
name|t
decl_stmt|,
modifier|*
name|indextype
decl_stmt|;
name|NODE
modifier|*
name|p
decl_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|arraytype
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|class
operator|!=
name|ARRAY
condition|)
block|{
name|panic
argument_list|(
literal|"unexpected class %d in evalindex"
argument_list|,
name|t
operator|->
name|class
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|chain
expr_stmt|;
name|p
operator|=
name|subs
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|NIL
condition|)
block|{
name|panic
argument_list|(
literal|"unexpected end of subscript list in evalindex"
argument_list|)
expr_stmt|;
block|}
name|indextype
operator|=
name|rtype
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|lb
operator|=
name|indextype
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
expr_stmt|;
name|ub
operator|=
name|indextype
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
expr_stmt|;
name|eval
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|index
operator|=
name|popsmall
argument_list|(
name|p
operator|->
name|left
operator|->
name|nodetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|lb
operator|||
name|index
operator|>
name|ub
condition|)
block|{
name|error
argument_list|(
literal|"subscript value %d out of range %d..%d"
argument_list|,
name|index
argument_list|,
name|lb
argument_list|,
name|ub
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|i
operator|+
operator|(
name|index
operator|-
name|lb
operator|)
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|chain
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * Check that a record.field usage is proper.  */
end_comment

begin_function
name|LOCAL
name|chkfield
parameter_list|(
name|r
parameter_list|,
name|f
parameter_list|)
name|NODE
modifier|*
name|r
decl_stmt|;
name|SYM
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|SYM
modifier|*
name|s
decl_stmt|;
name|chkclass
argument_list|(
name|r
argument_list|,
name|RECORD
argument_list|)
expr_stmt|;
comment|/*      * Don't do this for compiled code.      */
if|#
directive|if
operator|(
operator|!
name|isvax
operator|)
for|for
control|(
name|s
operator|=
name|r
operator|->
name|nodetype
operator|->
name|chain
init|;
name|s
operator|!=
name|NIL
condition|;
name|s
operator|=
name|s
operator|->
name|chain
control|)
block|{
if|if
condition|(
name|s
operator|==
name|f
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|==
name|NIL
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not a field in specified record"
argument_list|,
name|f
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Check to see if a tree is boolean-valued, if not it's an error.  */
end_comment

begin_expr_stmt
name|chkboolean
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|->
name|nodetype
operator|!=
name|t_boolean
condition|)
block|{
name|trerror
argument_list|(
literal|"found %t, expected boolean expression"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Check to make sure the given tree has a type of the given class.  */
end_comment

begin_function
name|LOCAL
name|chkclass
parameter_list|(
name|p
parameter_list|,
name|class
parameter_list|)
name|NODE
modifier|*
name|p
decl_stmt|;
name|int
name|class
decl_stmt|;
block|{
name|SYM
name|tmpsym
decl_stmt|;
name|tmpsym
operator|.
name|class
operator|=
name|class
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nodetype
operator|->
name|class
operator|!=
name|class
condition|)
block|{
name|trerror
argument_list|(
literal|"%t is not a %s"
argument_list|,
name|p
argument_list|,
name|classname
argument_list|(
operator|&
name|tmpsym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Construct a node for the type of a string.  While we're at it,  * scan the string for '' that collapse to ', and chop off the ends.  */
end_comment

begin_function
name|LOCAL
name|SYM
modifier|*
name|mkstring
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|SYM
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|static
name|SYM
name|zerosym
decl_stmt|;
name|p
operator|=
name|str
expr_stmt|;
name|q
operator|=
name|str
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|q
index|[
literal|0
index|]
operator|!=
literal|'\''
operator|||
name|q
index|[
literal|1
index|]
operator|!=
literal|'\''
condition|)
block|{
operator|*
name|p
operator|=
operator|*
name|q
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|q
operator|++
expr_stmt|;
block|}
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|str
operator|+
literal|1
condition|)
block|{
return|return
name|t_char
return|;
block|}
name|s
operator|=
name|alloc
argument_list|(
literal|1
argument_list|,
name|SYM
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|zerosym
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|ARRAY
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|t_char
expr_stmt|;
name|s
operator|->
name|chain
operator|=
name|alloc
argument_list|(
literal|1
argument_list|,
name|SYM
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
operator|->
name|chain
expr_stmt|;
operator|*
name|t
operator|=
name|zerosym
expr_stmt|;
name|t
operator|->
name|class
operator|=
name|RANGE
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|t_int
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
operator|=
name|p
operator|-
name|str
operator|+
literal|1
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Free up the space allocated for a string type.  */
end_comment

begin_macro
name|unmkstring
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|SYM
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dispose
argument_list|(
name|s
operator|->
name|chain
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

