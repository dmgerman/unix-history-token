begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)yyerror.c 1.2 %G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"yy.h"
end_include

begin_comment
comment|/*  * Yerror prints an error  * message and then returns  * NIL for the tree if needed.  * The error is flagged on the  * current line which is printed  * if the listing is turned off. #ifdef PXP  *  * As is obvious from the fooling around  * with fout below, the Pascal system should  * be changed to use the new library "lS". #endif  */
end_comment

begin_macro
name|yerror
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|PI
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|static
name|yySerrs
expr_stmt|;
ifdef|#
directive|ifdef
name|PXP
name|int
name|ofout
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|errpfx
operator|==
literal|'w'
operator|&&
name|opt
argument_list|(
literal|'w'
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errpfx
operator|=
literal|'E'
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PXP
name|flush
argument_list|()
expr_stmt|;
name|ofout
operator|=
name|fout
index|[
literal|0
index|]
expr_stmt|;
name|fout
index|[
literal|0
index|]
operator|=
name|errout
expr_stmt|;
endif|#
directive|endif
name|yyResume
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PI
name|geterr
argument_list|(
name|s
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
endif|#
directive|endif
name|yysync
argument_list|()
expr_stmt|;
name|pchr
argument_list|(
name|errpfx
argument_list|)
expr_stmt|;
name|pchr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|yyecol
condition|;
name|i
operator|++
control|)
name|pchr
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"^--- "
argument_list|)
expr_stmt|;
comment|/* 	if (yyecol> 60) 		printf("\n\t"); */
name|printf
argument_list|(
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|)
expr_stmt|;
name|pchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|errpfx
operator|==
literal|'E'
condition|)
ifdef|#
directive|ifdef
name|PI
name|eflg
operator|=
name|TRUE
operator|,
name|codeoff
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PXP
name|eflg
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|errpfx
operator|=
literal|'E'
expr_stmt|;
name|yySerrs
operator|++
expr_stmt|;
if|if
condition|(
name|yySerrs
operator|>=
name|MAXSYNERR
condition|)
block|{
name|yySerrs
operator|=
literal|0
expr_stmt|;
name|yerror
argument_list|(
literal|"Too many syntax errors - QUIT"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|ERRS
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PXP
name|flush
argument_list|()
expr_stmt|;
name|fout
index|[
literal|0
index|]
operator|=
name|ofout
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * A bracketing error message  */
end_comment

begin_macro
name|brerror
argument_list|(
argument|where
argument_list|,
argument|what
argument_list|)
end_macro

begin_decl_stmt
name|int
name|where
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|what
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|where
operator|==
literal|0
condition|)
block|{
name|line
operator|=
name|yyeline
expr_stmt|;
name|setpfx
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"End matched %s on line %d"
argument_list|,
name|what
argument_list|,
name|where
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|where
operator|<
literal|0
condition|)
name|where
operator|=
operator|-
name|where
expr_stmt|;
name|yerror
argument_list|(
literal|"Inserted keyword end matching %s on line %d"
argument_list|,
name|what
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

