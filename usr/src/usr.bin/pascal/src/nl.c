begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)nl.c	5.2 (Berkeley) 4/16/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PI
end_ifdef

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_include
include|#
directive|include
file|"objfmt.h"
end_include

begin_comment
comment|/*  * NAMELIST SEGMENT DEFINITIONS  */
end_comment

begin_struct
struct|struct
name|nls
block|{
name|struct
name|nl
modifier|*
name|nls_low
decl_stmt|;
name|struct
name|nl
modifier|*
name|nls_high
decl_stmt|;
block|}
name|ntab
index|[
name|MAXNL
index|]
struct|,
modifier|*
name|nlact
struct|;
end_struct

begin_decl_stmt
name|struct
name|nl
name|nl
index|[
name|INL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nl
modifier|*
name|nlp
init|=
name|nl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nls
modifier|*
name|nlact
init|=
name|ntab
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*      *	all these strings must be places where people can find them      *	since lookup only looks at the string pointer, not the chars.      *	see, for example, pTreeInit.      */
end_comment

begin_comment
comment|/*      *	built in constants      */
end_comment

begin_decl_stmt
name|char
modifier|*
name|in_consts
index|[]
init|=
block|{
literal|"true"
block|,
literal|"false"
block|,
literal|"TRUE"
block|,
literal|"FALSE"
block|,
literal|"minint"
block|,
literal|"maxint"
block|,
literal|"minchar"
block|,
literal|"maxchar"
block|,
literal|"bell"
block|,
literal|"tab"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      *	built in simple types      */
end_comment

begin_decl_stmt
name|char
modifier|*
name|in_types
index|[]
init|=
block|{
literal|"boolean"
block|,
literal|"char"
block|,
literal|"integer"
block|,
literal|"real"
block|,
literal|"_nil"
block|,
comment|/* dummy name */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|in_rclasses
index|[]
init|=
block|{
name|TINT
block|,
name|TINT
block|,
name|TINT
block|,
name|TCHAR
block|,
name|TBOOL
block|,
name|TDOUBLE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|in_ranges
index|[]
init|=
block|{
operator|-
literal|128L
block|,
literal|127L
block|,
operator|-
literal|32768L
block|,
literal|32767L
block|,
operator|-
literal|2147483648L
block|,
literal|2147483647L
block|,
literal|0L
block|,
literal|127L
block|,
literal|0L
block|,
literal|1L
block|,
literal|0L
block|,
literal|0L
comment|/* fake for reals */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      *	built in constructed types      */
end_comment

begin_decl_stmt
name|char
modifier|*
name|in_ctypes
index|[]
init|=
block|{
literal|"Boolean"
block|,
literal|"intset"
block|,
literal|"alfa"
block|,
literal|"text"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      *	built in variables      */
end_comment

begin_decl_stmt
name|char
modifier|*
name|in_vars
index|[]
init|=
block|{
literal|"input"
block|,
literal|"output"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      *	built in functions       */
end_comment

begin_decl_stmt
name|char
modifier|*
name|in_funcs
index|[]
init|=
block|{
literal|"abs"
block|,
literal|"arctan"
block|,
literal|"card"
block|,
literal|"chr"
block|,
literal|"clock"
block|,
literal|"cos"
block|,
literal|"eof"
block|,
literal|"eoln"
block|,
literal|"eos"
block|,
literal|"exp"
block|,
literal|"expo"
block|,
literal|"ln"
block|,
literal|"odd"
block|,
literal|"ord"
block|,
literal|"pred"
block|,
literal|"round"
block|,
literal|"sin"
block|,
literal|"sqr"
block|,
literal|"sqrt"
block|,
literal|"succ"
block|,
literal|"trunc"
block|,
literal|"undefined"
block|,
comment|/* 	 * Extensions 	 */
literal|"argc"
block|,
literal|"random"
block|,
literal|"seed"
block|,
literal|"wallclock"
block|,
literal|"sysclock"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	 * Built-in procedures 	 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|in_procs
index|[]
init|=
block|{
literal|"assert"
block|,
literal|"date"
block|,
literal|"dispose"
block|,
literal|"flush"
block|,
literal|"get"
block|,
literal|"getseg"
block|,
literal|"halt"
block|,
literal|"linelimit"
block|,
literal|"message"
block|,
literal|"new"
block|,
literal|"pack"
block|,
literal|"page"
block|,
literal|"put"
block|,
literal|"putseg"
block|,
literal|"read"
block|,
literal|"readln"
block|,
literal|"remove"
block|,
literal|"reset"
block|,
literal|"rewrite"
block|,
literal|"time"
block|,
literal|"unpack"
block|,
literal|"write"
block|,
literal|"writeln"
block|,
comment|/* 	 * Extensions 	 */
literal|"argv"
block|,
literal|"null"
block|,
literal|"stlimit"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PI0
end_ifndef

begin_comment
comment|/*      *	and their opcodes      */
end_comment

begin_decl_stmt
name|int
name|in_fops
index|[]
init|=
block|{
name|O_ABS2
block|,
name|O_ATAN
block|,
name|O_CARD
operator||
name|NSTAND
block|,
name|O_CHR2
block|,
name|O_CLCK
operator||
name|NSTAND
block|,
name|O_COS
block|,
name|O_EOF
block|,
name|O_EOLN
block|,
literal|0
block|,
name|O_EXP
block|,
name|O_EXPO
operator||
name|NSTAND
block|,
name|O_LN
block|,
name|O_ODD2
block|,
name|O_ORD2
block|,
name|O_PRED2
block|,
name|O_ROUND
block|,
name|O_SIN
block|,
name|O_SQR2
block|,
name|O_SQRT
block|,
name|O_SUCC2
block|,
name|O_TRUNC
block|,
name|O_UNDEF
operator||
name|NSTAND
block|,
comment|/* 	 * Extensions 	 */
name|O_ARGC
operator||
name|NSTAND
block|,
name|O_RANDOM
operator||
name|NSTAND
block|,
name|O_SEED
operator||
name|NSTAND
block|,
name|O_WCLCK
operator||
name|NSTAND
block|,
name|O_SCLCK
operator||
name|NSTAND
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      * Built-in procedures      */
end_comment

begin_decl_stmt
name|int
name|in_pops
index|[]
init|=
block|{
name|O_ASRT
operator||
name|NSTAND
block|,
name|O_DATE
operator||
name|NSTAND
block|,
name|O_DISPOSE
block|,
name|O_FLUSH
operator||
name|NSTAND
block|,
name|O_GET
block|,
literal|0
block|,
name|O_HALT
operator||
name|NSTAND
block|,
name|O_LLIMIT
operator||
name|NSTAND
block|,
name|O_MESSAGE
operator||
name|NSTAND
block|,
name|O_NEW
block|,
name|O_PACK
block|,
name|O_PAGE
block|,
name|O_PUT
block|,
literal|0
block|,
name|O_READ4
block|,
name|O_READLN
block|,
name|O_REMOVE
operator||
name|NSTAND
block|,
name|O_RESET
block|,
name|O_REWRITE
block|,
name|O_TIME
operator||
name|NSTAND
block|,
name|O_UNPACK
block|,
name|O_WRITEF
block|,
name|O_WRITLN
block|,
comment|/* 	 * Extensions 	 */
name|O_ARGV
operator||
name|NSTAND
block|,
name|O_ABORT
operator||
name|NSTAND
block|,
name|O_STLIM
operator||
name|NSTAND
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initnl initializes the first namelist segment and then  * initializes the name list for block 0.  */
end_comment

begin_macro
name|initnl
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
name|struct
name|nl
modifier|*
name|fp
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|;
name|long
modifier|*
name|lp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hp21mx
condition|)
block|{
name|MININT
operator|=
operator|-
literal|32768.
expr_stmt|;
name|MAXINT
operator|=
literal|32767.
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
ifdef|#
directive|ifdef
name|OBJ
name|genmx
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|OBJ
endif|#
directive|endif
block|}
endif|#
directive|endif
name|ntab
index|[
literal|0
index|]
operator|.
name|nls_low
operator|=
name|nl
expr_stmt|;
name|ntab
index|[
literal|0
index|]
operator|.
name|nls_high
operator|=
operator|&
name|nl
index|[
name|INL
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|NLNIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *	Types 	 */
for|for
control|(
name|cp
operator|=
name|in_types
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|*
name|cp
argument_list|,
name|TYPE
argument_list|,
name|nlp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *	Ranges 	 */
name|lp
operator|=
name|in_ranges
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|in_rclasses
init|;
operator|*
name|ip
operator|!=
literal|0
condition|;
name|ip
operator|++
control|)
block|{
name|np
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|RANGE
argument_list|,
name|nl
operator|+
operator|(
operator|*
name|ip
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nl
index|[
operator|*
name|ip
index|]
operator|.
name|type
operator|=
name|np
expr_stmt|;
name|np
operator|->
name|range
index|[
literal|0
index|]
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
name|np
operator|->
name|range
index|[
literal|1
index|]
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 *	built in constructed types 	 */
name|cp
operator|=
name|in_ctypes
expr_stmt|;
comment|/* 	 *	Boolean = boolean; 	 */
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|TYPE
argument_list|,
operator|(
expr|struct
name|nl
operator|*
operator|)
operator|(
name|nl
operator|+
name|T1BOOL
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *	intset = set of 0 .. 127; 	 */
name|intset
operator|=
operator|(
operator|(
expr|struct
name|nl
operator|*
operator|)
operator|*
name|cp
operator|++
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|(
name|char
operator|*
operator|)
name|intset
argument_list|,
name|TYPE
argument_list|,
name|nlp
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|SET
argument_list|,
name|nlp
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|np
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|RANGE
argument_list|,
name|nl
operator|+
name|TINT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|np
operator|->
name|range
index|[
literal|0
index|]
operator|=
literal|0L
expr_stmt|;
name|np
operator|->
name|range
index|[
literal|1
index|]
operator|=
literal|127L
expr_stmt|;
comment|/* 	 *	alfa = array [ 1 .. 10 ] of char; 	 */
name|np
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|RANGE
argument_list|,
name|nl
operator|+
name|TINT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|np
operator|->
name|range
index|[
literal|0
index|]
operator|=
literal|1L
expr_stmt|;
name|np
operator|->
name|range
index|[
literal|1
index|]
operator|=
literal|10L
expr_stmt|;
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ARRAY
argument_list|,
name|nl
operator|+
name|T1CHAR
argument_list|,
literal|1
argument_list|)
operator|->
name|chain
operator|=
name|np
expr_stmt|;
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|TYPE
argument_list|,
name|nlp
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *	text = file of char; 	 */
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|TYPE
argument_list|,
name|nlp
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|np
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|FILET
argument_list|,
name|nl
operator|+
name|T1CHAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|np
operator|->
name|nl_flags
operator||=
name|NFILES
expr_stmt|;
comment|/* 	 *	input,output : text; 	 */
name|cp
operator|=
name|in_vars
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
name|input
operator|=
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|VAR
argument_list|,
name|np
argument_list|,
name|INPUT_OFF
argument_list|)
expr_stmt|;
name|output
operator|=
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|VAR
argument_list|,
name|np
argument_list|,
name|OUTPUT_OFF
argument_list|)
expr_stmt|;
else|#
directive|else
name|input
operator|=
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|VAR
argument_list|,
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output
operator|=
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|VAR
argument_list|,
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PC
name|input
operator|->
name|extra_flags
operator||=
name|NGLOBAL
expr_stmt|;
name|output
operator|->
name|extra_flags
operator||=
name|NGLOBAL
expr_stmt|;
endif|#
directive|endif
endif|PC
comment|/* 	 *	built in constants 	 */
name|cp
operator|=
name|in_consts
expr_stmt|;
name|np
operator|=
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|CONST
argument_list|,
name|nl
operator|+
name|TBOOL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|=
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|CONST
argument_list|,
name|nl
operator|+
name|TBOOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|nl
operator|+
name|TBOOL
operator|)
operator|->
name|chain
operator|=
name|fp
expr_stmt|;
name|fp
operator|->
name|chain
operator|=
name|np
expr_stmt|;
name|np
operator|=
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|CONST
argument_list|,
name|nl
operator|+
name|TBOOL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|=
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|CONST
argument_list|,
name|nl
operator|+
name|TBOOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator|->
name|chain
operator|=
name|np
expr_stmt|;
if|if
condition|(
name|opt
argument_list|(
literal|'s'
argument_list|)
condition|)
operator|(
name|nl
operator|+
name|TBOOL
operator|)
operator|->
name|chain
operator|=
name|fp
expr_stmt|;
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|CONST
argument_list|,
name|nl
operator|+
name|T4INT
argument_list|,
literal|0
argument_list|)
operator|->
name|range
index|[
literal|0
index|]
operator|=
name|MININT
expr_stmt|;
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|CONST
argument_list|,
name|nl
operator|+
name|T4INT
argument_list|,
literal|0
argument_list|)
operator|->
name|range
index|[
literal|0
index|]
operator|=
name|MAXINT
expr_stmt|;
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|CONST
argument_list|,
name|nl
operator|+
name|T1CHAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|CONST
argument_list|,
name|nl
operator|+
name|T1CHAR
argument_list|,
literal|127
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|CONST
argument_list|,
name|nl
operator|+
name|T1CHAR
argument_list|,
literal|'\007'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|CONST
argument_list|,
name|nl
operator|+
name|T1CHAR
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
comment|/* 	 * Built-in functions and procedures 	 */
ifndef|#
directive|ifndef
name|PI0
name|ip
operator|=
name|in_fops
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|in_funcs
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|*
name|cp
argument_list|,
name|FUNC
argument_list|,
name|NLNIL
argument_list|,
operator|*
name|ip
operator|++
argument_list|)
expr_stmt|;
name|ip
operator|=
name|in_pops
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|in_procs
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|*
name|cp
argument_list|,
name|PROC
argument_list|,
name|NLNIL
argument_list|,
operator|*
name|ip
operator|++
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|cp
operator|=
name|in_funcs
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|*
name|cp
argument_list|,
name|FUNC
argument_list|,
name|NLNIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|in_procs
init|;
operator|*
name|cp
operator|!=
literal|0
operator|,
name|cp
operator|++
control|)
operator|(
name|void
operator|)
name|hdefnl
argument_list|(
operator|*
name|cp
argument_list|,
name|PROC
argument_list|,
name|NLNIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PTREE
name|pTreeInit
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
name|struct
name|nl
modifier|*
name|hdefnl
parameter_list|(
name|sym
parameter_list|,
name|cls
parameter_list|,
name|typ
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|sym
decl_stmt|;
name|int
name|cls
decl_stmt|;
name|struct
name|nl
modifier|*
name|typ
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
ifndef|#
directive|ifndef
name|PI1
if|if
condition|(
name|sym
condition|)
operator|(
name|void
operator|)
name|hash
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|defnl
argument_list|(
name|sym
argument_list|,
name|cls
argument_list|,
name|typ
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
operator|(
name|void
operator|)
name|enter
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free up the name list segments  * at the end of a statement/proc/func  * All segments are freed down to the one in which  * p points.  */
end_comment

begin_macro
name|nlfree
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|nlp
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|nlact
operator|->
name|nls_low
operator|>
name|nlp
operator|||
name|nlact
operator|->
name|nls_high
operator|<
name|nlp
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nlact
operator|->
name|nls_low
argument_list|)
expr_stmt|;
name|nlact
operator|->
name|nls_low
operator|=
name|NIL
expr_stmt|;
name|nlact
operator|->
name|nls_high
operator|=
name|NIL
expr_stmt|;
operator|--
name|nlact
expr_stmt|;
if|if
condition|(
name|nlact
operator|<
operator|&
name|ntab
index|[
literal|0
index|]
condition|)
name|panic
argument_list|(
literal|"nlfree"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PI
end_endif

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|PC
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|VARIABLE
init|=
literal|"variable"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|PC
end_endif

begin_endif
endif|#
directive|endif
endif|OBJ
end_endif

begin_decl_stmt
name|char
modifier|*
name|classes
index|[ ]
init|=
block|{
literal|"undefined"
block|,
literal|"constant"
block|,
literal|"type"
block|,
literal|"variable"
block|,
comment|/*	VARIABLE	*/
literal|"array"
block|,
literal|"pointer or file"
block|,
literal|"record"
block|,
literal|"field"
block|,
literal|"procedure"
block|,
literal|"function"
block|,
literal|"variable"
block|,
comment|/*	VARIABLE	*/
literal|"variable"
block|,
comment|/*	VARIABLE	*/
literal|"pointer"
block|,
literal|"file"
block|,
literal|"set"
block|,
literal|"subrange"
block|,
literal|"label"
block|,
literal|"withptr"
block|,
literal|"scalar"
block|,
literal|"string"
block|,
literal|"program"
block|,
literal|"improper"
block|,
literal|"variant"
block|,
literal|"formal procedure"
block|,
literal|"formal function"
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PC
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|snark
init|=
literal|"SNARK"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PI
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|ctext
index|[]
init|=
block|{
literal|"BADUSE"
block|,
literal|"CONST"
block|,
literal|"TYPE"
block|,
literal|"VAR"
block|,
literal|"ARRAY"
block|,
literal|"PTRFILE"
block|,
literal|"RECORD"
block|,
literal|"FIELD"
block|,
literal|"PROC"
block|,
literal|"FUNC"
block|,
literal|"FVAR"
block|,
literal|"REF"
block|,
literal|"PTR"
block|,
literal|"FILET"
block|,
literal|"SET"
block|,
literal|"RANGE"
block|,
literal|"LABEL"
block|,
literal|"WITHPTR"
block|,
literal|"SCAL"
block|,
literal|"STR"
block|,
literal|"PROG"
block|,
literal|"IMPROPER"
block|,
literal|"VARNT"
block|,
literal|"FPROC"
block|,
literal|"FFUNC"
block|,
literal|"CRANGE"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|stars
init|=
literal|"\t***"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Dump the namelist from the  * current nlp down to 'to'.  * All the namelist is dumped if  * to is NIL.  */
end_comment

begin_comment
comment|/*VARARGS*/
end_comment

begin_macro
name|dumpnl
argument_list|(
argument|to
argument_list|,
argument|rout
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
name|struct
name|nls
modifier|*
name|nlsp
decl_stmt|;
name|int
name|v
decl_stmt|,
name|head
decl_stmt|;
if|if
condition|(
name|opt
argument_list|(
literal|'y'
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|to
operator|!=
name|NIL
condition|)
name|printf
argument_list|(
literal|"\n\"%s\" Block=%d\n"
argument_list|,
name|rout
argument_list|,
name|cbn
argument_list|)
expr_stmt|;
name|nlsp
operator|=
name|nlact
expr_stmt|;
name|head
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|nlp
init|;
name|p
operator|!=
name|to
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|==
name|nlsp
operator|->
name|nls_low
condition|)
block|{
if|if
condition|(
name|nlsp
operator|==
operator|&
name|ntab
index|[
literal|0
index|]
condition|)
break|break;
name|nlsp
operator|--
expr_stmt|;
name|p
operator|=
name|nlsp
operator|->
name|nls_high
expr_stmt|;
block|}
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NIL
condition|)
block|{
name|printf
argument_list|(
literal|"\tName\tClass  Bn+Flags\tType\tVal\tChn\n"
argument_list|)
expr_stmt|;
name|head
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%3d:"
argument_list|,
name|nloff
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|symbol
condition|)
name|printf
argument_list|(
literal|"\t%.7s"
argument_list|,
name|p
operator|->
name|symbol
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|stars
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|class
condition|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|ctext
index|[
name|p
operator|->
name|class
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|stars
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nl_flags
condition|)
block|{
name|pchr
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nl_flags
operator|&
literal|037
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|p
operator|->
name|nl_flags
operator|&
literal|037
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
if|if
condition|(
name|p
operator|->
name|nl_flags
operator|&
name|NMOD
condition|)
name|pchr
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nl_flags
operator|&
name|NUSED
condition|)
name|pchr
argument_list|(
literal|'U'
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|nl_flags
operator|&
name|NFILES
condition|)
name|pchr
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
name|stars
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
condition|)
name|printf
argument_list|(
literal|"\t[%d]"
argument_list|,
name|nloff
argument_list|(
name|p
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|stars
argument_list|)
expr_stmt|;
name|v
operator|=
name|p
operator|->
name|value
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|class
condition|)
block|{
case|case
name|TYPE
case|:
break|break;
case|case
name|VARNT
case|:
goto|goto
name|con
goto|;
case|case
name|CONST
case|:
switch|switch
condition|(
name|nloff
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"\t%d"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|TDOUBLE
case|:
name|printf
argument_list|(
literal|"\t%f"
argument_list|,
name|p
operator|->
name|real
argument_list|)
expr_stmt|;
break|break;
case|case
name|TINT
case|:
case|case
name|T4INT
case|:
name|con
label|:
name|printf
argument_list|(
literal|"\t%ld"
argument_list|,
name|p
operator|->
name|range
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSTR
case|:
name|printf
argument_list|(
literal|"\t'%s'"
argument_list|,
name|p
operator|->
name|ptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|VAR
case|:
case|case
name|REF
case|:
case|case
name|WITHPTR
case|:
case|case
name|FFUNC
case|:
case|case
name|FPROC
case|:
name|printf
argument_list|(
literal|"\t%d,%d"
argument_list|,
name|cbn
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCAL
case|:
case|case
name|RANGE
case|:
name|printf
argument_list|(
literal|"\t%ld..%ld"
argument_list|,
name|p
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
name|p
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRANGE
case|:
name|printf
argument_list|(
literal|"\t%s..%s"
argument_list|,
name|p
operator|->
name|nptr
index|[
literal|0
index|]
operator|->
name|symbol
argument_list|,
name|p
operator|->
name|nptr
index|[
literal|1
index|]
operator|->
name|symbol
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD
case|:
name|printf
argument_list|(
literal|"\t%d"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD
case|:
name|printf
argument_list|(
literal|"\t%d"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|STR
case|:
name|printf
argument_list|(
literal|"\t|%d|"
argument_list|,
name|p
operator|->
name|value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FVAR
case|:
case|case
name|FUNC
case|:
case|case
name|PROC
case|:
case|case
name|PROG
case|:
if|if
condition|(
name|cbn
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\t<%o>"
argument_list|,
name|p
operator|->
name|value
index|[
literal|0
index|]
operator|&
literal|0377
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
if|if
condition|(
name|p
operator|->
name|value
index|[
literal|0
index|]
operator|&
name|NSTAND
condition|)
name|printf
argument_list|(
literal|"\tNSTAND"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|v
operator|=
name|p
operator|->
name|value
index|[
literal|1
index|]
expr_stmt|;
default|default:
if|if
condition|(
name|v
condition|)
name|printf
argument_list|(
literal|"\t<%d>"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|stars
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|chain
condition|)
name|printf
argument_list|(
literal|"\t[%d]"
argument_list|,
name|nloff
argument_list|(
name|p
operator|->
name|chain
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|class
condition|)
block|{
case|case
name|RECORD
case|:
name|printf
argument_list|(
literal|"\tALIGN=%d"
argument_list|,
name|p
operator|->
name|align_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
condition|)
block|{
name|printf
argument_list|(
literal|" FLIST=[%d]"
argument_list|,
name|nloff
argument_list|(
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" FLIST=[]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|ptr
index|[
name|NL_TAG
index|]
condition|)
block|{
name|printf
argument_list|(
literal|" TAG=[%d]"
argument_list|,
name|nloff
argument_list|(
name|p
operator|->
name|ptr
index|[
name|NL_TAG
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" TAG=[]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|ptr
index|[
name|NL_VARNT
index|]
condition|)
block|{
name|printf
argument_list|(
literal|" VARNT=[%d]"
argument_list|,
name|nloff
argument_list|(
name|p
operator|->
name|ptr
index|[
name|NL_VARNT
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" VARNT=[]"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FIELD
case|:
if|if
condition|(
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"\tFLIST=[%d]"
argument_list|,
name|nloff
argument_list|(
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\tFLIST=[]"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VARNT
case|:
name|printf
argument_list|(
literal|"\tVTOREC=[%d]"
argument_list|,
name|nloff
argument_list|(
name|p
operator|->
name|ptr
index|[
name|NL_VTOREC
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|PC
if|if
condition|(
name|p
operator|->
name|extra_flags
operator|!=
literal|0
condition|)
block|{
name|pchr
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|extra_flags
operator|&
name|NEXTERN
condition|)
name|printf
argument_list|(
literal|"NEXTERN "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|extra_flags
operator|&
name|NLOCAL
condition|)
name|printf
argument_list|(
literal|"NLOCAL "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|extra_flags
operator|&
name|NPARAM
condition|)
name|printf
argument_list|(
literal|"NPARAM "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|extra_flags
operator|&
name|NGLOBAL
condition|)
name|printf
argument_list|(
literal|"NGLOBAL "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|extra_flags
operator|&
name|NREGVAR
condition|)
name|printf
argument_list|(
literal|"NREGVAR "
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|PC
ifdef|#
directive|ifdef
name|PTREE
name|pchr
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|pPrintPointer
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|inTree
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|head
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\tNo entries\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * Define a new name list entry  * with initial symbol, class, type  * and value[0] as given.  A new name  * list segment is allocated to hold  * the next name list slot if necessary.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|defnl
parameter_list|(
name|sym
parameter_list|,
name|cls
parameter_list|,
name|typ
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|sym
decl_stmt|;
name|int
name|cls
decl_stmt|;
name|struct
name|nl
modifier|*
name|typ
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
modifier|*
name|q
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|p
operator|=
name|nlp
expr_stmt|;
comment|/* 	 * Zero out this entry 	 */
name|q
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|i
operator|=
operator|(
sizeof|sizeof
expr|*
name|p
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
do|do
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
comment|/* 	 * Insert the values 	 */
name|p
operator|->
name|symbol
operator|=
name|sym
expr_stmt|;
name|p
operator|->
name|class
operator|=
name|cls
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|typ
expr_stmt|;
name|p
operator|->
name|nl_block
operator|=
name|cbn
expr_stmt|;
name|p
operator|->
name|value
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
comment|/* 	 * Insure that the next namelist 	 * entry actually exists. This is 	 * really not needed here, it would 	 * suffice to do it at entry if we 	 * need the slot.  It is done this 	 * way because, historically, nlp 	 * always pointed at the next namelist 	 * slot. 	 */
name|nlp
operator|++
expr_stmt|;
if|if
condition|(
name|nlp
operator|>=
name|nlact
operator|->
name|nls_high
condition|)
block|{
name|i
operator|=
name|NLINC
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|NLINC
operator|*
sizeof|sizeof
expr|*
name|nlp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|NLINC
operator|/
literal|2
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|NLINC
operator|/
literal|2
operator|)
operator|*
sizeof|sizeof
expr|*
name|nlp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Ran out of memory (defnl)"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
name|nlact
operator|++
expr_stmt|;
if|if
condition|(
name|nlact
operator|>=
operator|&
name|ntab
index|[
name|MAXNL
index|]
condition|)
block|{
name|error
argument_list|(
literal|"Ran out of name list tables"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
name|nlp
operator|=
operator|(
expr|struct
name|nl
operator|*
operator|)
name|cp
expr_stmt|;
name|nlact
operator|->
name|nls_low
operator|=
name|nlp
expr_stmt|;
name|nlact
operator|->
name|nls_high
operator|=
name|nlact
operator|->
name|nls_low
operator|+
name|i
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a duplicate of the argument  * namelist entry for, e.g., type  * declarations of the form 'type a = b'  * and array indicies.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|nlcopy
parameter_list|(
name|p
parameter_list|)
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
name|p2
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|NLNIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p2
operator|=
operator|*
name|p1
expr_stmt|;
name|p2
operator|->
name|chain
operator|=
name|NLNIL
expr_stmt|;
return|return
operator|(
name|p2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute a namelist offset  */
end_comment

begin_macro
name|nloff
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|p
operator|-
name|nl
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Enter a symbol into the block  * symbol table.  Symbols are hashed  * 64 ways based on low 6 bits of the  * character pointer into the string  * table.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|enter
parameter_list|(
name|np
parameter_list|)
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
block|{
specifier|register
name|struct
name|nl
modifier|*
name|rp
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rp
operator|=
name|np
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
ifndef|#
directive|ifndef
name|PI1
if|if
condition|(
name|cbn
operator|>
literal|0
condition|)
if|if
condition|(
name|rp
operator|->
name|symbol
operator|==
name|input
operator|->
name|symbol
operator|||
name|rp
operator|->
name|symbol
operator|==
name|output
operator|->
name|symbol
condition|)
name|error
argument_list|(
literal|"Pre-defined files input and output must not be redefined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
operator|(
name|int
operator|)
name|rp
operator|->
name|symbol
expr_stmt|;
name|i
operator|&=
literal|077
expr_stmt|;
name|hp
operator|=
name|disptab
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|class
operator|!=
name|BADUSE
operator|&&
name|rp
operator|->
name|class
operator|!=
name|FIELD
condition|)
for|for
control|(
name|p
operator|=
name|hp
init|;
name|p
operator|!=
name|NIL
operator|&&
operator|(
name|p
operator|->
name|nl_block
operator|&
literal|037
operator|)
operator|==
name|cbn
condition|;
name|p
operator|=
name|p
operator|->
name|nl_next
control|)
if|if
condition|(
name|p
operator|->
name|symbol
operator|==
name|rp
operator|->
name|symbol
operator|&&
name|p
operator|->
name|symbol
operator|!=
name|NIL
operator|&&
name|p
operator|->
name|class
operator|!=
name|BADUSE
operator|&&
name|p
operator|->
name|class
operator|!=
name|FIELD
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"%s is already defined in this block"
argument_list|,
name|rp
operator|->
name|symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|rp
operator|->
name|nl_next
operator|=
name|hp
expr_stmt|;
name|disptab
index|[
name|i
index|]
operator|=
name|rp
expr_stmt|;
return|return
operator|(
name|rp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

