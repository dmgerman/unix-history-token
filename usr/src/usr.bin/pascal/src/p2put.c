begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)p2put.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*      *	functions to help pi put out      *	polish postfix binary portable c compiler intermediate code      *	thereby becoming the portable pascal compiler      */
end_comment

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"objfmt.h"
end_include

begin_include
include|#
directive|include
file|<pcc.h>
end_include

begin_include
include|#
directive|include
file|"pc.h"
end_include

begin_include
include|#
directive|include
file|"align.h"
end_include

begin_include
include|#
directive|include
file|"tmps.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*      *	emits an ftext operator and a string to the pcstream      */
end_comment

begin_macro
name|puttext
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
init|=
name|str4len
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CGENNING
condition|)
return|return;
name|p2word
argument_list|(
name|PCCM_TRIPLE
argument_list|(
name|PCCF_FTEXT
argument_list|,
name|length
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PCCF_FTEXT | %3d | 0	"
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|p2string
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|str4len
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/*      *	put formatted text into a buffer for printing to the pcstream.      *	a call to putpflush actually puts out the text.      *	none of arg1 .. arg5 need be present.      *	and you can add more if you need them.      */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|putprintf
argument_list|(
argument|format
argument_list|,
argument|incomplete
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|incomplete
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|ppbuffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|ppbufp
init|=
name|ppbuffer
decl_stmt|;
if|if
condition|(
operator|!
name|CGENNING
condition|)
return|return;
name|sprintf
argument_list|(
name|ppbufp
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|ppbufp
operator|=
operator|&
operator|(
name|ppbuffer
index|[
name|strlen
argument_list|(
name|ppbuffer
argument_list|)
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|ppbufp
operator|>=
operator|&
operator|(
name|ppbuffer
index|[
name|BUFSIZ
index|]
operator|)
condition|)
name|panic
argument_list|(
literal|"putprintf"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|incomplete
condition|)
block|{
name|puttext
argument_list|(
name|ppbuffer
argument_list|)
expr_stmt|;
name|ppbufp
operator|=
name|ppbuffer
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	emit a left bracket operator to pcstream      *	with function number, the maximum temp register, and total local bytes      */
end_comment

begin_macro
name|putlbracket
argument_list|(
argument|ftnno
argument_list|,
argument|sizesp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ftnno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|om
modifier|*
name|sizesp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|maxtempreg
decl_stmt|;
name|int
name|alignedframesize
decl_stmt|;
ifdef|#
directive|ifdef
name|vax
name|maxtempreg
operator|=
name|sizesp
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_GENERAL
index|]
expr_stmt|;
endif|#
directive|endif
endif|vax
ifdef|#
directive|ifdef
name|mc68000
comment|/* 	     *	this is how /lib/f1 wants it. 	     */
name|maxtempreg
operator|=
operator|(
name|sizesp
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_ADDR
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|sizesp
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_DATA
index|]
operator|)
expr_stmt|;
endif|#
directive|endif
endif|mc68000
name|alignedframesize
operator|=
name|roundup
argument_list|(
call|(
name|int
call|)
argument_list|(
name|BITSPERBYTE
operator|*
operator|-
name|sizesp
operator|->
name|curtmps
operator|.
name|om_off
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|BITSPERBYTE
operator|*
name|A_STACK
argument_list|)
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|PCCM_TRIPLE
argument_list|(
name|PCCF_FLBRAC
argument_list|,
name|maxtempreg
argument_list|,
name|ftnno
argument_list|)
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|alignedframesize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PCCF_FLBRAC | %3d | %d	%d\n"
argument_list|,
name|maxtempreg
argument_list|,
name|ftnno
argument_list|,
name|alignedframesize
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	emit a right bracket operator      *	which for the binary interface      *	forces the stack allocate and register mask      */
end_comment

begin_macro
name|putrbracket
argument_list|(
argument|ftnno
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ftnno
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2word
argument_list|(
name|PCCM_TRIPLE
argument_list|(
name|PCCF_FRBRAC
argument_list|,
literal|0
argument_list|,
name|ftnno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PCCF_FRBRAC |   0 | %d\n"
argument_list|,
name|ftnno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	emit an eof operator      */
end_comment

begin_macro
name|puteof
argument_list|()
end_macro

begin_block
block|{
name|p2word
argument_list|(
name|PCCF_FEOF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PCCF_FEOF\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	emit a dot operator,      *	with a source file line number and name      *	if line is negative, there was an error on that line, but who cares?      */
end_comment

begin_macro
name|putdot
argument_list|(
argument|filename
argument_list|,
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
init|=
name|str4len
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|line
operator|<
literal|0
condition|)
block|{
name|line
operator|=
operator|-
name|line
expr_stmt|;
block|}
name|p2word
argument_list|(
name|PCCM_TRIPLE
argument_list|(
name|PCCF_FEXPR
argument_list|,
name|length
argument_list|,
name|line
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PCCF_FEXPR | %3d | %d	"
argument_list|,
name|length
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|p2string
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	put out a leaf node      */
end_comment

begin_macro
name|putleaf
argument_list|(
argument|op
argument_list|,
argument|lval
argument_list|,
argument|rval
argument_list|,
argument|type
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|CGENNING
condition|)
return|return;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
name|panic
argument_list|(
literal|"[putleaf]"
argument_list|)
expr_stmt|;
case|case
name|PCC_ICON
case|:
name|p2word
argument_list|(
name|PCCM_TRIPLE
argument_list|(
name|PCC_ICON
argument_list|,
name|name
operator|!=
name|NIL
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|lval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PCC_ICON | %3d | 0x%x	"
argument_list|,
name|name
operator|!=
name|NIL
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d\n"
argument_list|,
name|lval
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|name
condition|)
name|p2name
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCC_NAME
case|:
name|p2word
argument_list|(
name|PCCM_TRIPLE
argument_list|(
name|PCC_NAME
argument_list|,
name|lval
operator|!=
literal|0
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
condition|)
name|p2word
argument_list|(
name|lval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PCC_NAME | %3d | 0x%x	"
argument_list|,
name|lval
operator|!=
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d	"
argument_list|,
name|lval
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|p2name
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCC_REG
case|:
name|p2word
argument_list|(
name|PCCM_TRIPLE
argument_list|(
name|PCC_REG
argument_list|,
name|rval
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PCC_REG | %3d | 0x%x\n"
argument_list|,
name|rval
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
block|}
end_block

begin_comment
comment|/*      *	rvalues are just lvalues with indirection, except      *	special cases for registers and for named globals,      *	whose names are their rvalues.      */
end_comment

begin_macro
name|putRV
argument_list|(
argument|name
argument_list|,
argument|level
argument_list|,
argument|offset
argument_list|,
argument|other_flags
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|other_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|extname
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|printname
decl_stmt|;
if|if
condition|(
operator|!
name|CGENNING
condition|)
return|return;
if|if
condition|(
name|other_flags
operator|&
name|NREGVAR
condition|)
block|{
if|if
condition|(
operator|(
name|offset
operator|<
literal|0
operator|)
operator|||
operator|(
name|offset
operator|>
name|P2FP
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"putRV regvar"
argument_list|)
expr_stmt|;
block|}
name|putleaf
argument_list|(
name|PCC_REG
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|,
name|type
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|whereis
argument_list|(
name|offset
argument_list|,
name|other_flags
argument_list|)
operator|==
name|GLOBALVAR
condition|)
block|{
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
block|{
name|sprintf
argument_list|(
name|extname
argument_list|,
name|EXTFORMAT
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printname
operator|=
name|extname
expr_stmt|;
block|}
else|else
block|{
name|printname
operator|=
name|name
expr_stmt|;
block|}
name|putleaf
argument_list|(
name|PCC_NAME
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|printname
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"putRV no name"
argument_list|)
expr_stmt|;
block|}
block|}
name|putLV
argument_list|(
name|name
argument_list|,
name|level
argument_list|,
name|offset
argument_list|,
name|other_flags
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|putop
argument_list|(
argument|PCCOM_UNARY PCC_MUL
argument_list|,
argument|type
argument_list|)
empty_stmt|;
block|}
end_block

begin_comment
comment|/*      *	put out an lvalue       *	given a level and offset      *	special case for      *	    named globals, whose lvalues are just their names as constants.      */
end_comment

begin_macro
name|putLV
argument_list|(
argument|name
argument_list|,
argument|level
argument_list|,
argument|offset
argument_list|,
argument|other_flags
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|other_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|extname
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|printname
decl_stmt|;
if|if
condition|(
operator|!
name|CGENNING
condition|)
return|return;
if|if
condition|(
name|other_flags
operator|&
name|NREGVAR
condition|)
block|{
name|panic
argument_list|(
literal|"putLV regvar"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|whereis
argument_list|(
name|offset
argument_list|,
name|other_flags
argument_list|)
condition|)
block|{
case|case
name|GLOBALVAR
case|:
if|if
condition|(
operator|(
name|name
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
block|{
name|sprintf
argument_list|(
name|extname
argument_list|,
name|EXTFORMAT
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printname
operator|=
name|extname
expr_stmt|;
block|}
else|else
block|{
name|printname
operator|=
name|name
expr_stmt|;
block|}
name|putleaf
argument_list|(
name|PCC_ICON
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|PCCM_ADDTYPE
argument_list|(
name|type
argument_list|,
name|PCCTM_PTR
argument_list|)
argument_list|,
name|printname
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"putLV no name"
argument_list|)
expr_stmt|;
block|}
case|case
name|PARAMVAR
case|:
if|if
condition|(
name|level
operator|==
name|cbn
condition|)
block|{
name|putleaf
argument_list|(
name|PCC_REG
argument_list|,
literal|0
argument_list|,
name|P2AP
argument_list|,
name|PCCM_ADDTYPE
argument_list|(
name|type
argument_list|,
name|PCCTM_PTR
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putleaf
argument_list|(
name|PCC_NAME
argument_list|,
operator|(
name|level
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dispsave
argument_list|)
operator|)
operator|+
name|AP_OFFSET
argument_list|,
literal|0
argument_list|,
name|PCCTM_PTR
operator||
name|PCCT_CHAR
argument_list|,
name|DISPLAYNAME
argument_list|)
expr_stmt|;
name|parts
index|[
name|level
index|]
operator||=
name|NONLOCALVAR
expr_stmt|;
block|}
name|putleaf
argument_list|(
name|PCC_ICON
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|PCCT_INT
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|PCC_PLUS
argument_list|,
name|PCCTM_PTR
operator||
name|PCCT_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCALVAR
case|:
if|if
condition|(
name|level
operator|==
name|cbn
condition|)
block|{
name|putleaf
argument_list|(
name|PCC_REG
argument_list|,
literal|0
argument_list|,
name|P2FP
argument_list|,
name|PCCM_ADDTYPE
argument_list|(
name|type
argument_list|,
name|PCCTM_PTR
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putleaf
argument_list|(
name|PCC_NAME
argument_list|,
operator|(
name|level
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dispsave
argument_list|)
operator|)
operator|+
name|FP_OFFSET
argument_list|,
literal|0
argument_list|,
name|PCCTM_PTR
operator||
name|PCCT_CHAR
argument_list|,
name|DISPLAYNAME
argument_list|)
expr_stmt|;
name|parts
index|[
name|level
index|]
operator||=
name|NONLOCALVAR
expr_stmt|;
block|}
name|putleaf
argument_list|(
name|PCC_ICON
argument_list|,
operator|-
name|offset
argument_list|,
literal|0
argument_list|,
name|PCCT_INT
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|PCC_MINUS
argument_list|,
name|PCCTM_PTR
operator||
name|PCCT_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAMEDLOCALVAR
case|:
if|if
condition|(
name|level
operator|==
name|cbn
condition|)
block|{
name|putleaf
argument_list|(
name|PCC_REG
argument_list|,
literal|0
argument_list|,
name|P2FP
argument_list|,
name|PCCM_ADDTYPE
argument_list|(
name|type
argument_list|,
name|PCCTM_PTR
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putleaf
argument_list|(
name|PCC_NAME
argument_list|,
operator|(
name|level
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dispsave
argument_list|)
operator|)
operator|+
name|FP_OFFSET
argument_list|,
literal|0
argument_list|,
name|PCCTM_PTR
operator||
name|PCCT_CHAR
argument_list|,
name|DISPLAYNAME
argument_list|)
expr_stmt|;
name|parts
index|[
name|level
index|]
operator||=
name|NONLOCALVAR
expr_stmt|;
block|}
name|putleaf
argument_list|(
name|PCC_ICON
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PCCT_INT
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|PCC_MINUS
argument_list|,
name|PCCTM_PTR
operator||
name|PCCT_CHAR
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_block

begin_comment
comment|/*      *	put out a floating point constant leaf node      *	the constant is declared in aligned data space      *	and a PCC_NAME leaf put out for it      */
end_comment

begin_macro
name|putCON8
argument_list|(
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|double
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|char
name|name
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|CGENNING
condition|)
return|return;
name|label
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.data"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aligndot
argument_list|(
name|A_DOUBLE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putlab
argument_list|(
name|label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
name|putprintf
argument_list|(
literal|"	.double 0d%.20e"
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|vax
ifdef|#
directive|ifdef
name|mc68000
name|putprintf
argument_list|(
literal|"	.long 	0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|mc68000
name|putprintf
argument_list|(
literal|"	.text"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|PREFIXFORMAT
argument_list|,
name|LABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putleaf
argument_list|(
name|PCC_NAME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PCCT_DOUBLE
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	 * put out either an lvalue or an rvalue for a constant string. 	 * an lvalue (for assignment rhs's) is the name as a constant,  	 * an rvalue (for parameters) is just the name. 	 */
end_comment

begin_macro
name|putCONG
argument_list|(
argument|string
argument_list|,
argument|length
argument_list|,
argument|required
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|required
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|name
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|int
name|others
decl_stmt|;
if|if
condition|(
operator|!
name|CGENNING
condition|)
return|return;
name|putprintf
argument_list|(
literal|"	.data"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aligndot
argument_list|(
name|A_STRUCT
argument_list|)
expr_stmt|;
name|label
operator|=
name|getlab
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|putlab
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|cp
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.byte	0%o"
argument_list|,
literal|1
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|others
operator|=
literal|2
init|;
operator|(
name|others
operator|<=
literal|8
operator|)
operator|&&
operator|*
name|cp
condition|;
name|others
operator|++
control|)
block|{
name|putprintf
argument_list|(
literal|",0%o"
argument_list|,
literal|1
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pad
operator|=
name|length
operator|-
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
name|pad
operator|--
operator|>
literal|0
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.byte	0%o"
argument_list|,
literal|1
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|others
operator|=
literal|2
init|;
operator|(
name|others
operator|<=
literal|8
operator|)
operator|&&
operator|(
name|pad
operator|--
operator|>
literal|0
operator|)
condition|;
name|others
operator|++
control|)
block|{
name|putprintf
argument_list|(
literal|",0%o"
argument_list|,
literal|1
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|"	.byte	0"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.text"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|PREFIXFORMAT
argument_list|,
name|LABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|required
operator|==
name|RREQ
condition|)
block|{
name|putleaf
argument_list|(
name|PCC_NAME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PCCTM_ARY
operator||
name|PCCT_CHAR
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putleaf
argument_list|(
name|PCC_ICON
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PCCTM_PTR
operator||
name|PCCT_CHAR
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	map a pascal type to a c type      *	this would be tail recursive, but i unfolded it into a for (;;).      *	this is sort of like isa and lwidth      *	a note on the types used by the portable c compiler:      *	    they are divided into a basic type (char, short, int, long, etc.)      *	    and qualifications on those basic types (pointer, function, array).      *	    the basic type is kept in the low 4 bits of the type descriptor,      *	    and the qualifications are arranged in two bit chunks, with the      *	    most significant on the right,      *	    and the least significant on the left      *		e.g. int *foo();      *			(a function returning a pointer to an integer)      *		is stored as      *<ptr><ftn><int>      *	so, we build types recursively      *	also, we know that /lib/f1 can only deal with 6 qualifications      *	so we stop the recursion there.  this stops infinite type recursion      *	through mutually recursive pointer types.      */
end_comment

begin_define
define|#
directive|define
name|MAXQUALS
value|6
end_define

begin_function
name|int
name|p2type
parameter_list|(
name|np
parameter_list|)
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
block|{
return|return
name|typerecur
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_macro
name|typerecur
argument_list|(
argument|np
argument_list|,
argument|quals
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quals
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|np
operator|==
name|NIL
operator|||
name|quals
operator|>
name|MAXQUALS
condition|)
block|{
return|return
name|PCCT_UNDEF
return|;
block|}
switch|switch
condition|(
name|np
operator|->
name|class
condition|)
block|{
case|case
name|SCAL
case|:
case|case
name|RANGE
case|:
case|case
name|CRANGE
case|:
if|if
condition|(
name|np
operator|->
name|type
operator|==
operator|(
name|nl
operator|+
name|TDOUBLE
operator|)
condition|)
block|{
return|return
name|PCCT_DOUBLE
return|;
block|}
switch|switch
condition|(
name|bytes
argument_list|(
name|np
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
name|np
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|PCCT_CHAR
return|;
case|case
literal|2
case|:
return|return
name|PCCT_SHORT
return|;
case|case
literal|4
case|:
return|return
name|PCCT_INT
return|;
default|default:
name|panic
argument_list|(
literal|"p2type int"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
case|case
name|STR
case|:
return|return
operator|(
name|PCCTM_ARY
operator||
name|PCCT_CHAR
operator|)
return|;
case|case
name|RECORD
case|:
case|case
name|SET
case|:
return|return
name|PCCT_STRTY
return|;
case|case
name|FILET
case|:
return|return
operator|(
name|PCCTM_PTR
operator||
name|PCCT_STRTY
operator|)
return|;
case|case
name|CONST
case|:
case|case
name|VAR
case|:
case|case
name|FIELD
case|:
return|return
name|p2type
argument_list|(
name|np
operator|->
name|type
argument_list|)
return|;
case|case
name|TYPE
case|:
switch|switch
condition|(
name|nloff
argument_list|(
name|np
argument_list|)
condition|)
block|{
case|case
name|TNIL
case|:
return|return
operator|(
name|PCCTM_PTR
operator||
name|PCCT_UNDEF
operator|)
return|;
case|case
name|TSTR
case|:
return|return
operator|(
name|PCCTM_ARY
operator||
name|PCCT_CHAR
operator|)
return|;
case|case
name|TSET
case|:
return|return
name|PCCT_STRTY
return|;
default|default :
return|return
operator|(
name|p2type
argument_list|(
name|np
operator|->
name|type
argument_list|)
operator|)
return|;
block|}
case|case
name|REF
case|:
case|case
name|WITHPTR
case|:
case|case
name|PTR
case|:
return|return
name|PCCM_ADDTYPE
argument_list|(
name|typerecur
argument_list|(
name|np
operator|->
name|type
argument_list|,
name|quals
operator|+
literal|1
argument_list|)
argument_list|,
name|PCCTM_PTR
argument_list|)
return|;
case|case
name|ARRAY
case|:
return|return
name|PCCM_ADDTYPE
argument_list|(
name|typerecur
argument_list|(
name|np
operator|->
name|type
argument_list|,
name|quals
operator|+
literal|1
argument_list|)
argument_list|,
name|PCCTM_ARY
argument_list|)
return|;
case|case
name|FUNC
case|:
comment|/* 		     * functions are really pointers to functions 		     * which return their underlying type. 		     */
return|return
name|PCCM_ADDTYPE
argument_list|(
name|PCCM_ADDTYPE
argument_list|(
name|typerecur
argument_list|(
name|np
operator|->
name|type
argument_list|,
name|quals
operator|+
literal|2
argument_list|)
argument_list|,
name|PCCTM_FTN
argument_list|)
argument_list|,
name|PCCTM_PTR
argument_list|)
return|;
case|case
name|PROC
case|:
comment|/* 		     * procedures are pointers to functions  		     * which return integers (whether you look at them or not) 		     */
return|return
name|PCCM_ADDTYPE
argument_list|(
name|PCCM_ADDTYPE
argument_list|(
name|PCCT_INT
argument_list|,
name|PCCTM_FTN
argument_list|)
argument_list|,
name|PCCTM_PTR
argument_list|)
return|;
case|case
name|FFUNC
case|:
case|case
name|FPROC
case|:
comment|/* 		     *	formal procedures and functions are pointers 		     *	to structures which describe their environment. 		     */
return|return
operator|(
name|PCCTM_PTR
operator||
name|PCCT_STRTY
operator|)
return|;
default|default :
name|panic
argument_list|(
literal|"p2type"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_block

begin_comment
comment|/*      *	put a typed operator to the pcstream      */
end_comment

begin_macro
name|putop
argument_list|(
argument|op
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|p2opname
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|CGENNING
condition|)
return|return;
name|p2word
argument_list|(
name|PCCM_TRIPLE
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s (%d) |   0 | 0x%x\n"
argument_list|,
name|p2opname
argument_list|(
name|op
argument_list|)
argument_list|,
name|op
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	put out a structure operator (STASG, STARG, STCALL, UNARY STCALL )      *	which looks just like a regular operator, only the size and      *	alignment go in the next consecutive words      */
end_comment

begin_macro
name|putstrop
argument_list|(
argument|op
argument_list|,
argument|type
argument_list|,
argument|size
argument_list|,
argument|alignment
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alignment
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|p2opname
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|CGENNING
condition|)
return|return;
name|p2word
argument_list|(
name|PCCM_TRIPLE
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s (%d) |   0 | 0x%x	%d %d\n"
argument_list|,
name|p2opname
argument_list|(
name|op
argument_list|)
argument_list|,
name|op
argument_list|,
name|type
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	the string names of p2ops      */
end_comment

begin_struct
struct|struct
name|p2op
block|{
name|int
name|op
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|p2op
name|p2opnames
index|[]
init|=
block|{
name|PCC_ERROR
block|,
literal|"PCC_ERROR"
block|,
name|PCC_NAME
block|,
literal|"PCC_NAME"
block|,
name|PCC_STRING
block|,
literal|"PCC_STRING"
block|,
name|PCC_ICON
block|,
literal|"PCC_ICON"
block|,
name|PCC_FCON
block|,
literal|"PCC_FCON"
block|,
name|PCC_PLUS
block|,
literal|"PCC_PLUS"
block|,
name|PCC_MINUS
block|,
literal|"PCC_MINUS"
block|,
name|PCC_UMINUS
block|,
literal|"PCC_UMINUS"
block|,
name|PCC_MUL
block|,
literal|"PCC_MUL"
block|,
name|PCC_DEREF
block|,
literal|"PCC_DEREF"
block|,
name|PCC_AND
block|,
literal|"PCC_AND"
block|,
name|PCC_ADDROF
block|,
literal|"PCC_ADDROF"
block|,
name|PCC_OR
block|,
literal|"PCC_OR"
block|,
name|PCC_ER
block|,
literal|"PCC_ER"
block|,
name|PCC_QUEST
block|,
literal|"PCC_QUEST"
block|,
name|PCC_COLON
block|,
literal|"PCC_COLON"
block|,
name|PCC_ANDAND
block|,
literal|"PCC_ANDAND"
block|,
name|PCC_OROR
block|,
literal|"PCC_OROR"
block|,
name|PCC_CM
block|,
literal|"PCC_CM"
block|,
name|PCC_ASSIGN
block|,
literal|"PCC_ASSIGN"
block|,
name|PCC_COMOP
block|,
literal|"PCC_COMOP"
block|,
name|PCC_DIV
block|,
literal|"PCC_DIV"
block|,
name|PCC_MOD
block|,
literal|"PCC_MOD"
block|,
name|PCC_LS
block|,
literal|"PCC_LS"
block|,
name|PCC_RS
block|,
literal|"PCC_RS"
block|,
name|PCC_DOT
block|,
literal|"PCC_DOT"
block|,
name|PCC_STREF
block|,
literal|"PCC_STREF"
block|,
name|PCC_CALL
block|,
literal|"PCC_CALL"
block|,
name|PCC_UCALL
block|,
literal|"PCC_UCALL"
block|,
name|PCC_FORTCALL
block|,
literal|"PCC_FORTCALL"
block|,
name|PCC_UFORTCALL
block|,
literal|"PCC_UFORTCALL"
block|,
name|PCC_NOT
block|,
literal|"PCC_NOT"
block|,
name|PCC_COMPL
block|,
literal|"PCC_COMPL"
block|,
name|PCC_INCR
block|,
literal|"PCC_INCR"
block|,
name|PCC_DECR
block|,
literal|"PCC_DECR"
block|,
name|PCC_EQ
block|,
literal|"PCC_EQ"
block|,
name|PCC_NE
block|,
literal|"PCC_NE"
block|,
name|PCC_LE
block|,
literal|"PCC_LE"
block|,
name|PCC_LT
block|,
literal|"PCC_LT"
block|,
name|PCC_GE
block|,
literal|"PCC_GE"
block|,
name|PCC_GT
block|,
literal|"PCC_GT"
block|,
name|PCC_ULE
block|,
literal|"PCC_ULE"
block|,
name|PCC_ULT
block|,
literal|"PCC_ULT"
block|,
name|PCC_UGE
block|,
literal|"PCC_UGE"
block|,
name|PCC_UGT
block|,
literal|"PCC_UGT"
block|,
name|PCC_REG
block|,
literal|"PCC_REG"
block|,
name|PCC_OREG
block|,
literal|"PCC_OREG"
block|,
name|PCC_CCODES
block|,
literal|"PCC_CCODES"
block|,
name|PCC_FREE
block|,
literal|"PCC_FREE"
block|,
name|PCC_STASG
block|,
literal|"PCC_STASG"
block|,
name|PCC_STARG
block|,
literal|"PCC_STARG"
block|,
name|PCC_STCALL
block|,
literal|"PCC_STCALL"
block|,
name|PCC_USTCALL
block|,
literal|"PCC_USTCALL"
block|,
name|PCC_FLD
block|,
literal|"PCC_FLD"
block|,
name|PCC_SCONV
block|,
literal|"PCC_SCONV"
block|,
name|PCC_PCONV
block|,
literal|"PCC_PCONV"
block|,
name|PCC_PMCONV
block|,
literal|"PCC_PMCONV"
block|,
name|PCC_PVCONV
block|,
literal|"PCC_PVCONV"
block|,
name|PCC_FORCE
block|,
literal|"PCC_FORCE"
block|,
name|PCC_CBRANCH
block|,
literal|"PCC_CBRANCH"
block|,
name|PCC_INIT
block|,
literal|"PCC_INIT"
block|,
name|PCC_CAST
block|,
literal|"PCC_CAST"
block|,
operator|-
literal|1
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|p2opname
parameter_list|(
name|op
parameter_list|)
specifier|register
name|int
name|op
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|p2map
index|[
name|PCC_MAXOP
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|bool
name|mapready
init|=
name|FALSE
decl_stmt|;
specifier|register
name|struct
name|p2op
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|mapready
operator|==
name|FALSE
condition|)
block|{
for|for
control|(
name|pp
operator|=
name|p2opnames
init|;
name|pp
operator|->
name|op
operator|>=
literal|0
condition|;
name|pp
operator|++
control|)
name|p2map
index|[
name|pp
operator|->
name|op
index|]
operator|=
name|pp
operator|->
name|name
expr_stmt|;
name|mapready
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
operator|(
name|p2map
index|[
name|op
index|]
condition|?
name|p2map
index|[
name|op
index|]
else|:
literal|"unknown"
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*      *	low level routines      */
end_comment

begin_comment
comment|/*      *	puts a long word on the pcstream      */
end_comment

begin_macro
name|p2word
argument_list|(
argument|word
argument_list|)
end_macro

begin_decl_stmt
name|int
name|word
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putw
argument_list|(
name|word
argument_list|,
name|pcstream
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	put a length 0 mod 4 null padded string onto the pcstream      */
end_comment

begin_macro
name|p2string
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|slen
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|wlen
init|=
operator|(
name|slen
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|int
name|plen
init|=
operator|(
name|wlen
operator|*
literal|4
operator|)
operator|-
name|slen
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|p
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|string
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|pcstream
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|plen
condition|;
name|p
operator|++
control|)
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|pcstream
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|plen
condition|;
name|p
operator|++
control|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\\0"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	puts a name on the pcstream      */
end_comment

begin_macro
name|p2name
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pad
decl_stmt|;
name|fprintf
argument_list|(
name|pcstream
argument_list|,
name|NAMEFORMAT
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pad
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|pad
operator|<
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|;
name|pad
operator|++
control|)
block|{
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|pcstream
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|NAMEFORMAT
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pad
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|pad
operator|<
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|;
name|pad
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\\0"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	put out a jump to a label      */
end_comment

begin_macro
name|putjbr
argument_list|(
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|long
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printjbr
argument_list|(
name|LABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	put out a jump to any kind of label      */
end_comment

begin_macro
name|printjbr
argument_list|(
argument|prefix
argument_list|,
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|vax
name|putprintf
argument_list|(
literal|"	jbr	"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|0
argument_list|,
name|prefix
argument_list|,
name|label
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|vax
ifdef|#
directive|ifdef
name|mc68000
name|putprintf
argument_list|(
literal|"	jra	"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|0
argument_list|,
name|prefix
argument_list|,
name|label
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|mc68000
block|}
end_block

begin_comment
comment|/*      *	another version of put to catch calls to put      */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|put
argument_list|()
end_macro

begin_block
block|{
name|panic
argument_list|(
literal|"put()"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PC
end_endif

end_unit

