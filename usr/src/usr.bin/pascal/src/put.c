begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)put.c 1.3 %G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"objfmt.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_include
include|#
directive|include
file|"pc.h"
end_include

begin_endif
endif|#
directive|endif
endif|PC
end_endif

begin_decl_stmt
name|short
modifier|*
name|obufp
init|=
name|obuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If DEBUG is defined, include the table  * of the printing opcode names.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"OPnames.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ
end_ifdef

begin_comment
comment|/*  * Put is responsible for the interpreter equivalent of code  * generation.  Since the interpreter is specifically designed  * for Pascal, little work is required here.  */
end_comment

begin_macro
name|put
argument_list|(
argument|a
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|subop
decl_stmt|,
name|suboppr
decl_stmt|,
name|op
decl_stmt|,
name|oldlc
decl_stmt|,
name|w
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
specifier|static
name|int
name|casewrd
decl_stmt|;
comment|/* 	 * It would be nice to do some more 	 * optimizations here.  The work 	 * done to collapse offsets in lval 	 * should be done here, the IFEQ etc 	 * relational operators could be used 	 * etc. 	 */
name|oldlc
operator|=
name|lc
expr_stmt|;
if|if
condition|(
name|cgenflg
operator|<
literal|0
condition|)
comment|/* 		 * code disabled - do nothing 		 */
return|return
operator|(
name|oldlc
operator|)
return|;
name|p
operator|=
operator|&
name|a
expr_stmt|;
name|n
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|suboppr
operator|=
name|subop
operator|=
operator|(
operator|*
name|p
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
name|op
operator|=
operator|*
name|p
operator|&
literal|0377
expr_stmt|;
name|string
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|cp
operator|=
name|otext
index|[
name|op
index|]
operator|)
operator|==
name|NIL
condition|)
block|{
name|printf
argument_list|(
literal|"op= %o\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"put"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|O_ABORT
case|:
name|cp
operator|=
literal|"*"
expr_stmt|;
break|break;
case|case
name|O_LINO
case|:
comment|/***** 			if (line == codeline) 				return (oldlc); 			codeline = line; *****/
case|case
name|O_NEW
case|:
case|case
name|O_DISPOSE
case|:
case|case
name|O_AS
case|:
case|case
name|O_IND
case|:
case|case
name|O_LVCON
case|:
case|case
name|O_CON
case|:
case|case
name|O_OFF
case|:
case|case
name|O_INX2
case|:
case|case
name|O_INX4
case|:
case|case
name|O_CARD
case|:
case|case
name|O_ADDT
case|:
case|case
name|O_SUBT
case|:
case|case
name|O_MULT
case|:
case|case
name|O_IN
case|:
case|case
name|O_CASE1OP
case|:
case|case
name|O_CASE2OP
case|:
case|case
name|O_CASE4OP
case|:
case|case
name|O_FRTN
case|:
case|case
name|O_WRITES
case|:
case|case
name|O_WRITEF
case|:
case|case
name|O_MAX
case|:
case|case
name|O_MIN
case|:
case|case
name|O_PACK
case|:
case|case
name|O_UNPACK
case|:
case|case
name|O_ARGV
case|:
case|case
name|O_CTTOT
case|:
case|case
name|O_INCT
case|:
case|case
name|O_RANG2
case|:
case|case
name|O_RSNG2
case|:
case|case
name|O_RANG42
case|:
case|case
name|O_RSNG42
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
break|break;
case|case
name|O_CON2
case|:
case|case
name|O_CON24
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|<
literal|128
operator|&&
name|p
index|[
literal|1
index|]
operator|>=
operator|-
literal|128
condition|)
block|{
name|suboppr
operator|=
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|O_CON2
condition|)
block|{
name|op
operator|=
name|O_CON1
expr_stmt|;
name|cp
operator|=
name|otext
index|[
name|O_CON1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|O_CON24
condition|)
block|{
name|op
operator|=
name|O_CON14
expr_stmt|;
name|cp
operator|=
name|otext
index|[
name|O_CON14
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
name|O_CON8
case|:
block|{
name|short
modifier|*
name|sp
init|=
operator|&
name|p
index|[
literal|1
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|")#%5d\tCON8\t%10.3f\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
operator|&
name|p
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|word
argument_list|(
name|op
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|4
condition|;
name|i
operator|++
control|)
name|word
argument_list|(
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
block|}
default|default:
if|if
condition|(
name|op
operator|>=
name|O_REL2
operator|&&
name|op
operator|<=
name|O_REL84
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
operator|(
name|subop
operator|>>
literal|1
operator|)
operator|*
literal|5
operator|)
operator|>=
literal|30
condition|)
name|i
operator|-=
literal|30
expr_stmt|;
else|else
name|i
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|string
operator|=
operator|&
literal|"IFEQ\0IFNE\0IFLT\0IFGT\0IFLE\0IFGE"
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
name|suboppr
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|O_IF
case|:
case|case
name|O_TRA
case|:
comment|/***** 			codeline = 0; *****/
case|case
name|O_FOR1U
case|:
case|case
name|O_FOR2U
case|:
case|case
name|O_FOR4U
case|:
case|case
name|O_FOR1D
case|:
case|case
name|O_FOR2D
case|:
case|case
name|O_FOR4D
case|:
comment|/* relative addressing */
name|p
index|[
literal|1
index|]
operator|-=
operator|(
name|unsigned
operator|)
name|lc
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|O_CONG
case|:
name|i
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|cp
operator|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|p
index|[
literal|2
index|]
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|")#%5d\tCONG:%d\t%s\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|i
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|<=
literal|127
condition|)
name|word
argument_list|(
name|O_CON
operator||
name|i
operator|<<
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
name|word
argument_list|(
name|O_CON
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|w
operator|=
operator|*
name|cp
condition|?
operator|*
name|cp
operator|++
else|:
literal|' '
expr_stmt|;
name|w
operator||=
operator|(
operator|*
name|cp
condition|?
operator|*
name|cp
operator|++
else|:
literal|' '
operator|)
operator|<<
literal|8
expr_stmt|;
name|word
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|i
operator|-=
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_CONC
case|:
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|string
operator|=
literal|"'x'"
operator|)
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
name|suboppr
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|O_CON1
expr_stmt|;
name|cp
operator|=
name|otext
index|[
name|O_CON1
index|]
expr_stmt|;
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
goto|goto
name|around
goto|;
case|case
name|O_CONC4
case|:
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|string
operator|=
literal|"'x'"
operator|)
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
name|suboppr
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|O_CON14
expr_stmt|;
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
goto|goto
name|around
goto|;
case|case
name|O_CON1
case|:
case|case
name|O_CON14
case|:
name|suboppr
operator|=
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|around
label|:
name|n
operator|--
expr_stmt|;
break|break;
case|case
name|O_CASEBEG
case|:
name|casewrd
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_CASEEND
case|:
if|if
condition|(
operator|(
name|unsigned
operator|)
name|lc
operator|&
literal|1
condition|)
block|{
name|lc
operator|--
expr_stmt|;
name|word
argument_list|(
name|casewrd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_CASE1
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|")#%5d\tCASE1\t%d\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|p
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * this to build a byte size case table  			 * saving bytes across calls in casewrd 			 * so they can be put out by word() 			 */
name|lc
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|lc
operator|&
literal|1
condition|)
name|casewrd
operator|=
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|p
index|[
literal|1
index|]
operator|)
operator|&
literal|0377
expr_stmt|;
else|else
block|{
name|lc
operator|-=
literal|2
expr_stmt|;
name|word
argument_list|(
name|casewrd
operator||
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|p
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_CASE2
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|")#%5d\tCASE2\t%d\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|p
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|word
argument_list|(
operator|(
name|short
operator|)
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|p
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_FCALL
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
goto|goto
name|longgen
goto|;
comment|/* and fall through */
case|case
name|O_PUSH
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|oldlc
operator|)
return|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|<
literal|128
operator|&&
name|p
index|[
literal|1
index|]
operator|>=
operator|-
literal|128
condition|)
block|{
name|suboppr
operator|=
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|n
operator|--
expr_stmt|;
break|break;
block|}
goto|goto
name|longgen
goto|;
case|case
name|O_TRA4
case|:
case|case
name|O_CALL
case|:
case|case
name|O_FSAV
case|:
case|case
name|O_GOTO
case|:
case|case
name|O_NAM
case|:
case|case
name|O_READE
case|:
comment|/* absolute long addressing */
name|p
index|[
literal|1
index|]
operator|-=
name|HEADER_BYTES
expr_stmt|;
goto|goto
name|longgen
goto|;
case|case
name|O_RV1
case|:
case|case
name|O_RV14
case|:
case|case
name|O_RV2
case|:
case|case
name|O_RV24
case|:
case|case
name|O_RV4
case|:
case|case
name|O_RV8
case|:
case|case
name|O_RV
case|:
case|case
name|O_LV
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|<
name|SHORTADDR
operator|&&
name|p
index|[
literal|1
index|]
operator|>=
operator|-
name|SHORTADDR
condition|)
break|break;
else|else
block|{
name|op
operator|+=
name|O_LRV
operator|-
name|O_RV
expr_stmt|;
name|cp
operator|=
name|otext
index|[
name|op
index|]
expr_stmt|;
block|}
case|case
name|O_BEG
case|:
case|case
name|O_NODUMP
case|:
case|case
name|O_CON4
case|:
case|case
name|O_CASE4
case|:
case|case
name|O_RANG4
case|:
case|case
name|O_RANG24
case|:
case|case
name|O_RSNG4
case|:
case|case
name|O_RSNG24
case|:
name|longgen
label|:
block|{
name|short
modifier|*
name|sp
init|=
operator|&
name|p
index|[
literal|1
index|]
decl_stmt|;
name|long
modifier|*
name|lp
init|=
operator|&
name|p
index|[
literal|1
index|]
decl_stmt|;
name|n
operator|=
operator|(
name|n
operator|<<
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|O_LRV
condition|)
name|n
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|")#%5d\t%s"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|suboppr
condition|)
name|printf
argument_list|(
literal|":%1d"
argument_list|,
name|suboppr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
control|)
name|printf
argument_list|(
literal|"\t%D "
argument_list|,
operator|*
name|lp
operator|++
argument_list|)
expr_stmt|;
name|pchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|op
operator|!=
name|O_CASE4
condition|)
name|word
argument_list|(
name|op
operator||
name|subop
operator|<<
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|word
argument_list|(
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|")#%5d\t%s"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|suboppr
condition|)
name|printf
argument_list|(
literal|":%d"
argument_list|,
name|suboppr
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|pchr
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
operator|(
name|short
operator|)
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|op
operator|!=
name|NIL
condition|)
name|word
argument_list|(
name|op
operator||
name|subop
operator|<<
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|word
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|OBJ
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * listnames outputs a list of enumerated type names which  * can then be selected from to output a TSCAL  * a pointer to the address in the code of the namelist  * is kept in value[ NL_ELABEL ].  */
end_comment

begin_expr_stmt
name|listnames
argument_list|(
name|ap
argument_list|)
specifier|register
expr|struct
name|nl
operator|*
name|ap
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|nl
modifier|*
name|next
decl_stmt|;
specifier|register
name|int
name|oldlc
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|unsigned
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|strptr
decl_stmt|;
if|if
condition|(
name|cgenflg
operator|<
literal|0
condition|)
comment|/* code is off - do nothing */
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|class
operator|!=
name|TYPE
condition|)
name|ap
operator|=
name|ap
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|value
index|[
name|NL_ELABEL
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* the list already exists */
return|return
operator|(
name|ap
operator|->
name|value
index|[
name|NL_ELABEL
index|]
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|OBJ
name|oldlc
operator|=
name|lc
expr_stmt|;
name|put
argument_list|(
literal|2
argument_list|,
name|O_TRA
argument_list|,
name|lc
argument_list|)
expr_stmt|;
name|ap
operator|->
name|value
index|[
name|NL_ELABEL
index|]
operator|=
name|lc
expr_stmt|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
name|putprintf
argument_list|(
literal|"	.data"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.align 1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ap
operator|->
name|value
index|[
name|NL_ELABEL
index|]
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|putlab
argument_list|(
name|ap
operator|->
name|value
index|[
name|NL_ELABEL
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
comment|/* number of scalars */
name|next
operator|=
name|ap
operator|->
name|type
expr_stmt|;
name|len
operator|=
name|next
operator|->
name|range
index|[
literal|1
index|]
operator|-
name|next
operator|->
name|range
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ
name|put
argument_list|(
literal|2
argument_list|,
name|O_CASE2
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
name|putprintf
argument_list|(
literal|"	.word %d"
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
comment|/* offsets of each scalar name */
name|len
operator|=
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ
name|put
argument_list|(
literal|2
argument_list|,
name|O_CASE2
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
name|putprintf
argument_list|(
literal|"	.word %d"
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
name|next
operator|=
name|ap
operator|->
name|chain
expr_stmt|;
do|do
block|{
for|for
control|(
name|strptr
operator|=
name|next
operator|->
name|symbol
init|;
operator|*
name|strptr
operator|++
condition|;
name|len
operator|++
control|)
continue|continue;
name|len
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ
name|put
argument_list|(
literal|2
argument_list|,
name|O_CASE2
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
name|putprintf
argument_list|(
literal|"	.word %d"
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
block|}
do|while
condition|(
name|next
operator|=
name|next
operator|->
name|chain
condition|)
do|;
comment|/* list of scalar names */
name|strptr
operator|=
name|getnext
argument_list|(
name|ap
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ
do|do
block|{
name|w
operator|=
operator|(
name|unsigned
operator|)
operator|*
name|strptr
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|strptr
operator|++
condition|)
name|strptr
operator|=
name|getnext
argument_list|(
name|next
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
name|w
operator||=
operator|*
name|strptr
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|strptr
operator|++
condition|)
name|strptr
operator|=
name|getnext
argument_list|(
name|next
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
condition|)
do|;
comment|/* jump over the mess */
name|patch
argument_list|(
name|oldlc
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
while|while
condition|(
name|next
condition|)
block|{
while|while
condition|(
operator|*
name|strptr
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.byte	0%o"
argument_list|,
literal|1
argument_list|,
operator|*
name|strptr
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
literal|2
init|;
operator|(
name|w
operator|<=
literal|8
operator|)
operator|&&
operator|*
name|strptr
condition|;
name|w
operator|++
control|)
block|{
name|putprintf
argument_list|(
literal|",0%o"
argument_list|,
literal|1
argument_list|,
operator|*
name|strptr
operator|++
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|"	.byte	0"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strptr
operator|=
name|getnext
argument_list|(
name|next
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|"	.text"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
return|return
operator|(
name|ap
operator|->
name|value
index|[
name|NL_ELABEL
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|getnext
argument_list|(
argument|next
argument_list|,
argument|new
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|next
decl_stmt|,
modifier|*
modifier|*
name|new
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|next
operator|!=
name|NIL
condition|)
block|{
name|next
operator|=
name|next
operator|->
name|chain
expr_stmt|;
operator|*
name|new
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|==
name|NIL
condition|)
return|return
operator|(
literal|""
operator|)
return|;
ifdef|#
directive|ifdef
name|OBJ
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
operator|&&
name|cgenflg
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|")#%5d\t\t\"%s\"\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|next
operator|->
name|symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|next
operator|->
name|symbol
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ
end_ifdef

begin_comment
comment|/*  * Putspace puts out a table  * of nothing to leave space  * for the case branch table e.g.  */
end_comment

begin_macro
name|putspace
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|cgenflg
operator|<
literal|0
condition|)
comment|/* 		 * code disabled - do nothing 		 */
return|return
operator|(
name|lc
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|")#%5d\t.=.+%d\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|even
argument_list|(
name|n
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
literal|2
control|)
name|word
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putstr
argument_list|(
argument|sptr
argument_list|,
argument|padding
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|padding
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|short
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|strptr
init|=
name|sptr
decl_stmt|;
specifier|register
name|int
name|pad
init|=
name|padding
decl_stmt|;
if|if
condition|(
name|cgenflg
operator|<
literal|0
condition|)
comment|/* 		 * code disabled - do nothing 		 */
return|return
operator|(
name|lc
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|")#%5D\t\t\"%s\"\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|strptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pad
operator|==
literal|0
condition|)
block|{
do|do
block|{
name|w
operator|=
operator|(
name|unsigned
name|short
operator|)
operator|*
name|strptr
expr_stmt|;
if|if
condition|(
name|w
condition|)
name|w
operator||=
operator|*
operator|++
name|strptr
operator|<<
literal|8
expr_stmt|;
name|word
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|strptr
operator|++
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|w
operator|=
operator|(
name|unsigned
name|short
operator|)
operator|*
name|strptr
expr_stmt|;
if|if
condition|(
name|w
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|strptr
condition|)
name|w
operator||=
operator|*
name|strptr
operator|<<
literal|8
expr_stmt|;
else|else
block|{
name|w
operator||=
literal|' '
operator|<<
literal|8
expr_stmt|;
name|pad
operator|--
expr_stmt|;
block|}
name|word
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|strptr
operator|++
condition|)
do|;
while|while
condition|(
name|pad
operator|>
literal|1
condition|)
block|{
name|word
argument_list|(
literal|'  '
argument_list|)
expr_stmt|;
name|pad
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|pad
operator|==
literal|1
condition|)
name|word
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
else|else
name|word
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|OBJ
end_endif

begin_macro
name|lenstr
argument_list|(
argument|sptr
argument_list|,
argument|padding
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|padding
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
name|strptr
init|=
name|sptr
decl_stmt|;
name|cnt
operator|=
name|padding
expr_stmt|;
do|do
block|{
name|cnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|strptr
operator|++
condition|)
do|;
return|return
operator|(
operator|(
operator|++
name|cnt
operator|)
operator|&
operator|~
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Patch repairs the branch  * at location loc to come  * to the current location.  *	for PC, this puts down the label  *	and the branch just references that label.  *	lets here it for two pass assemblers.  */
end_comment

begin_macro
name|patch
argument_list|(
argument|loc
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|OBJ
name|patchfil
argument_list|(
name|loc
argument_list|,
name|lc
operator|-
name|loc
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
name|putlab
argument_list|(
name|loc
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ
end_ifdef

begin_macro
name|patch4
argument_list|(
argument|loc
argument_list|)
end_macro

begin_block
block|{
name|patchfil
argument_list|(
name|loc
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Patchfil makes loc+2 have value  * as its contents.  */
end_comment

begin_macro
name|patchfil
argument_list|(
argument|loc
argument_list|,
argument|value
argument_list|,
argument|words
argument_list|)
end_macro

begin_decl_stmt
name|PTR_DCL
name|loc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|value
decl_stmt|,
name|words
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|cgenflg
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|loc
operator|>
operator|(
name|unsigned
operator|)
name|lc
condition|)
name|panic
argument_list|(
literal|"patchfil"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|")#\tpatch %u %d\n"
argument_list|,
name|loc
operator|-
name|HEADER_BYTES
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|i
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|loc
operator|+
literal|2
operator|-
operator|(
operator|(
name|unsigned
operator|)
name|lc
operator|&
operator|~
literal|01777
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
literal|1024
condition|)
name|obuf
index|[
name|i
index|]
operator|=
name|value
expr_stmt|;
else|else
block|{
name|lseek
argument_list|(
name|ofil
argument_list|,
operator|(
name|long
operator|)
name|loc
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|ofil
argument_list|,
operator|&
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|ofil
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|loc
operator|+=
literal|2
expr_stmt|;
name|value
operator|=
name|value
operator|>>
literal|16
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|words
condition|)
do|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Put the word o into the code  */
end_comment

begin_macro
name|word
argument_list|(
argument|o
argument_list|)
end_macro

begin_decl_stmt
name|int
name|o
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|obufp
operator|=
name|o
expr_stmt|;
name|obufp
operator|++
expr_stmt|;
name|lc
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|obufp
operator|>=
name|obuf
operator|+
literal|512
condition|)
name|pflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|obj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flush the code buffer  */
end_comment

begin_macro
name|pflush
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|i
operator|=
operator|(
name|obufp
operator|-
operator|(
operator|(
name|short
operator|*
operator|)
name|obuf
operator|)
operator|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|write
argument_list|(
name|ofil
argument_list|,
name|obuf
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
name|perror
argument_list|(
name|obj
argument_list|)
operator|,
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
name|obufp
operator|=
name|obuf
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|OBJ
end_endif

begin_comment
comment|/*  * Getlab - returns the location counter.  * included here for the eventual code generator.  *	for PC, thank you!  */
end_comment

begin_macro
name|getlab
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|OBJ
return|return
operator|(
name|lc
operator|)
return|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
specifier|static
name|long
name|lastlabel
decl_stmt|;
return|return
operator|(
operator|++
name|lastlabel
operator|)
return|;
endif|#
directive|endif
endif|PC
block|}
end_block

begin_comment
comment|/*  * Putlab - lay down a label.  *	for PC, just print the label name with a colon after it.  */
end_comment

begin_macro
name|putlab
argument_list|(
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|PC
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|1
argument_list|,
name|LABELPREFIX
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|":"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
return|return
operator|(
name|l
operator|)
return|;
block|}
end_block

end_unit

