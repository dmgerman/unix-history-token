begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1983 Regents of the University of California */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)sconv.c 2.1 %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*      *	functions to help pi put out      *	polish postfix binary portable c compiler intermediate code      *	thereby becoming the portable pascal compiler      */
end_comment

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"pcops.h"
end_include

begin_comment
comment|/*      *	this routine enforces ``the usual arithmetic conversions''      *	all integral operands are converted to ints.      *	if either operand is a double, both are made to be double.      *	this routine takes struct nl *'s for the types,      *	and returns both the struct nl * and the p2type for the result.      */
end_comment

begin_macro
name|tuac
argument_list|(
argument|thistype
argument_list|,
argument|thattype
argument_list|,
argument|resulttypep
argument_list|,
argument|resultp2typep
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|thistype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nl
modifier|*
name|thattype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nl
modifier|*
modifier|*
name|resulttypep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|resultp2typep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|thisp2type
init|=
name|p2type
argument_list|(
name|thistype
argument_list|)
decl_stmt|;
name|int
name|thatp2type
init|=
name|p2type
argument_list|(
name|thattype
argument_list|)
decl_stmt|;
operator|*
name|resulttypep
operator|=
name|thistype
expr_stmt|;
operator|*
name|resultp2typep
operator|=
name|thisp2type
expr_stmt|;
comment|/* 	 *	should only be passed scalars 	 */
if|if
condition|(
name|isnta
argument_list|(
name|thistype
argument_list|,
literal|"sbcid"
argument_list|)
operator|||
name|isnta
argument_list|(
name|thattype
argument_list|,
literal|"sbcid"
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|thisp2type
operator|==
name|P2CHAR
operator|||
name|thisp2type
operator|==
name|P2SHORT
condition|)
block|{
operator|*
name|resultp2typep
operator|=
name|P2INT
expr_stmt|;
operator|*
name|resulttypep
operator|=
name|nl
operator|+
name|T4INT
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|resultp2typep
operator|==
name|P2INT
operator|&&
name|thatp2type
operator|==
name|P2DOUBLE
condition|)
block|{
operator|*
name|resultp2typep
operator|=
name|P2DOUBLE
expr_stmt|;
operator|*
name|resulttypep
operator|=
name|nl
operator|+
name|TDOUBLE
expr_stmt|;
block|}
name|sconv
argument_list|(
name|thisp2type
argument_list|,
operator|*
name|resultp2typep
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	this routine will emit sconv operators when it thinks they are needed.      *	this is code generator specific, rather than machine-specific.      *	this routine takes p2types for arguments, not struct nl *'s.      */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_comment
comment|/*      *	the vax code genrator is very good, this routine is extremely boring.      */
end_comment

begin_macro
name|sconv
argument_list|(
argument|fromp2type
argument_list|,
argument|top2type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fromp2type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|top2type
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|top2type
condition|)
block|{
case|case
name|P2CHAR
case|:
case|case
name|P2SHORT
case|:
case|case
name|P2INT
case|:
switch|switch
condition|(
name|fromp2type
condition|)
block|{
case|case
name|P2CHAR
case|:
case|case
name|P2SHORT
case|:
case|case
name|P2INT
case|:
case|case
name|P2DOUBLE
case|:
return|return;
comment|/* pass1 knows how to do these */
default|default:
return|return;
block|}
case|case
name|P2DOUBLE
case|:
switch|switch
condition|(
name|fromp2type
condition|)
block|{
case|case
name|P2CHAR
case|:
case|case
name|P2SHORT
case|:
case|case
name|P2INT
case|:
name|putop
argument_list|(
name|P2SCONV
argument_list|,
name|P2DOUBLE
argument_list|)
expr_stmt|;
return|return;
case|case
name|P2DOUBLE
case|:
return|return;
default|default:
return|return;
block|}
default|default:
return|return;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|vax
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|mc68000
end_ifdef

begin_comment
comment|/*      *	i don't know how much to trust the mc68000 compiler,      *	so this routine is full.      */
end_comment

begin_macro
name|sconv
argument_list|(
argument|fromp2type
argument_list|,
argument|top2type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fromp2type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|top2type
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|top2type
condition|)
block|{
case|case
name|P2CHAR
case|:
switch|switch
condition|(
name|fromp2type
condition|)
block|{
case|case
name|P2CHAR
case|:
return|return;
case|case
name|P2SHORT
case|:
case|case
name|P2INT
case|:
case|case
name|P2DOUBLE
case|:
name|putop
argument_list|(
name|P2SCONV
argument_list|,
name|P2CHAR
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
case|case
name|P2SHORT
case|:
switch|switch
condition|(
name|fromp2type
condition|)
block|{
case|case
name|P2SHORT
case|:
return|return;
case|case
name|P2CHAR
case|:
case|case
name|P2INT
case|:
case|case
name|P2DOUBLE
case|:
name|putop
argument_list|(
name|P2SCONV
argument_list|,
name|P2SHORT
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
case|case
name|P2INT
case|:
switch|switch
condition|(
name|fromp2type
condition|)
block|{
case|case
name|P2INT
case|:
return|return;
case|case
name|P2CHAR
case|:
case|case
name|P2SHORT
case|:
case|case
name|P2DOUBLE
case|:
name|putop
argument_list|(
name|P2SCONV
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
case|case
name|P2DOUBLE
case|:
switch|switch
condition|(
name|fromp2type
condition|)
block|{
case|case
name|P2DOUBLE
case|:
return|return;
case|case
name|P2CHAR
case|:
case|case
name|P2SHORT
case|:
case|case
name|P2INT
case|:
name|putop
argument_list|(
name|P2SCONV
argument_list|,
name|P2DOUBLE
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
default|default:
return|return;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|mc68000
end_endif

begin_endif
endif|#
directive|endif
endif|PC
end_endif

end_unit

