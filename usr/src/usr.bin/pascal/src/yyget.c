begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)yyget.c 1.4 %G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"yy.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PXP
end_ifdef

begin_decl_stmt
name|int
name|yytokcnt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Readch returns the next  * character from the current  * input line or -1 on end-of-file.  * It also maintains yycol for use in  * printing error messages.  */
end_comment

begin_macro
name|readch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|bufp
operator|==
literal|'\n'
operator|&&
name|bufp
operator|>=
name|charbuf
condition|)
block|{
ifdef|#
directive|ifdef
name|PXP
name|yytokcnt
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|getline
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|c
operator|=
operator|*
operator|++
name|bufp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|yycol
operator|=
operator|(
operator|(
name|yycol
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
else|else
name|yycol
operator|++
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Definitions of the structures used for the  * include facility.  The variable "ibp" points  * to the getc buffer of the current input file.  * There are "inclev + 1" current include files,  * and information in saved in the incs stack  * whenever a new level of include nesting occurs.  *  * Ibp in the incs structure saves the pointer  * to the previous levels input buffer;  * filename saves the previous file name;  * Printed saves whether the previous file name  * had been printed before this nesting occurred;  * and yyline is the line we were on on the previous file.  */
end_comment

begin_define
define|#
directive|define
name|MAXINC
value|10
end_define

begin_struct
struct|struct
name|inc
block|{
name|FILE
modifier|*
name|ibp
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|Printed
decl_stmt|;
name|int
name|yyline
decl_stmt|;
name|int
name|yyLinpt
decl_stmt|;
block|}
name|incs
index|[
name|MAXINC
index|]
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|char
name|printed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inclev
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PXP
end_ifdef

begin_comment
comment|/*  * These initializations survive only if  * pxp is asked to pretty print one file.  * Otherwise they are destroyed by the initial  * call to getline.  */
end_comment

begin_decl_stmt
name|char
name|charbuf
index|[
name|CBSIZE
index|]
init|=
literal|" program x(output);\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yycol
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bufp
init|=
name|charbuf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * YyLinpt is the seek pointer to the beginning of the  * next line in the file.  */
end_comment

begin_decl_stmt
name|int
name|yyLinpt
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Getline places the next line  * from the input stream in the  * line buffer, returning -1 at YEOF.  */
end_comment

begin_macro
name|getline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|CHAR
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|PXP
specifier|static
name|char
name|ateof
decl_stmt|;
endif|#
directive|endif
specifier|register
name|FILE
modifier|*
name|ib
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|opt
argument_list|(
literal|'l'
argument_list|)
operator|&&
name|yyprtd
operator|==
literal|0
condition|)
name|yyoutline
argument_list|()
expr_stmt|;
name|yyprtd
operator|=
literal|0
expr_stmt|;
name|top
label|:
name|yylinpt
operator|=
name|yyLinpt
expr_stmt|;
name|yyline
operator|++
expr_stmt|;
name|yyseqid
operator|++
expr_stmt|;
name|cp
operator|=
name|charbuf
expr_stmt|;
name|ib
operator|=
name|ibp
expr_stmt|;
name|i
operator|=
sizeof|sizeof
name|charbuf
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|ib
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|uninclud
argument_list|()
condition|)
goto|goto
name|top
goto|;
ifdef|#
directive|ifdef
name|PXP
if|if
condition|(
name|ateof
operator|==
literal|0
operator|&&
name|bracket
condition|)
block|{
name|strcpy
argument_list|(
name|charbuf
argument_list|,
literal|"begin end.\n"
argument_list|)
expr_stmt|;
name|ateof
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
name|bufp
operator|=
literal|"\n"
expr_stmt|;
name|yyline
operator|--
expr_stmt|;
name|yyseqid
operator|--
expr_stmt|;
name|yyprtd
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|--
name|i
operator|==
literal|0
condition|)
block|{
name|line
operator|=
name|yyline
expr_stmt|;
name|error
argument_list|(
literal|"Input line too long - QUIT"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|yyLinpt
operator|=
name|yylinpt
operator|+
name|cp
operator|-
name|charbuf
expr_stmt|;
if|if
condition|(
name|includ
argument_list|()
condition|)
goto|goto
name|top
goto|;
ifdef|#
directive|ifdef
name|PXP
if|if
condition|(
name|cp
operator|==
operator|&
name|charbuf
index|[
literal|1
index|]
condition|)
name|commnl
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|==
operator|&
name|charbuf
index|[
literal|2
index|]
condition|)
switch|switch
condition|(
name|charbuf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|' '
case|:
name|commnlbl
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|commform
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|opt
argument_list|(
literal|'u'
argument_list|)
condition|)
name|setuflg
argument_list|()
expr_stmt|;
name|out
label|:
name|bufp
operator|=
name|charbuf
operator|-
literal|1
expr_stmt|;
name|yycol
operator|=
literal|8
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Check an input line to see if it is a "#include" pseudo-statement.  * We allow arbitrary blanks in the line and the file name  * may be delimited by either 's or "s.  A single semicolon  * may be placed after the name, but nothing else is allowed  */
end_comment

begin_macro
name|includ
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|char
name|ch
decl_stmt|;
specifier|register
name|struct
name|inc
modifier|*
name|ip
decl_stmt|;
name|cp
operator|=
name|charbuf
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'#'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp
operator|=
name|skipbl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
literal|"include"
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
if|if
condition|(
operator|*
name|dp
operator|!=
operator|*
name|cp
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|line
operator|=
name|yyline
expr_stmt|;
name|cp
operator|=
name|skipbl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\''
operator|&&
name|ch
operator|!=
literal|'"'
condition|)
block|{
comment|/* 		 * This should be a yerror flagging the place 		 * but its not worth figuring out the column. 		 */
name|line
operator|=
name|yyline
expr_stmt|;
name|error
argument_list|(
literal|"Include syntax error - expected ' or \" not found - QUIT"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|dp
operator|=
name|cp
init|;
operator|*
name|dp
operator|!=
name|ch
condition|;
name|dp
operator|++
control|)
if|if
condition|(
operator|*
name|dp
operator|==
literal|0
condition|)
block|{
name|line
operator|=
name|yyline
expr_stmt|;
name|error
argument_list|(
literal|"Missing closing %c for include file name - QUIT"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
operator|*
name|dp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/*  *	if (*dp == ';')  *		dp++;  *	dp = skipbl(dp);  *	if (*dp != '\n') {  *		line = yyline;  *		error("Garbage after filename in include");  *		pexit(DIED);  *	}  */
if|if
condition|(
operator|!
name|dotted
argument_list|(
name|cp
argument_list|,
literal|'i'
argument_list|)
operator|&&
operator|!
name|dotted
argument_list|(
name|cp
argument_list|,
literal|'h'
argument_list|)
condition|)
block|{
name|line
operator|=
name|yyline
expr_stmt|;
name|error
argument_list|(
literal|"Include filename must end in .i or .h"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PXP
name|commincl
argument_list|(
name|cp
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|noinclude
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
name|inclev
operator|++
expr_stmt|;
if|if
condition|(
name|inclev
operator|>
name|MAXINC
condition|)
block|{
name|line
operator|=
name|yyline
expr_stmt|;
name|error
argument_list|(
literal|"Absurdly deep include nesting - QUIT"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
name|ip
operator|=
operator|&
name|incs
index|[
name|inclev
index|]
expr_stmt|;
name|ip
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|filename
operator|=
name|savestr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ
comment|/*  * For the debugger pdx, we need to note that we've changed files.  */
name|newfile
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  *	left over from before stdio  *  *	cp = malloc(518);  *	if (cp == -1) {  *		error("Ran out of memory (include)");  *		pexit(DIED);  *	}  *  */
name|ip
operator|->
name|ibp
operator|=
name|ibp
expr_stmt|;
if|if
condition|(
operator|(
name|ibp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inpflist
argument_list|(
name|filename
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PI
name|opush
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PXP
name|opush
argument_list|(
literal|'z'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ip
operator|->
name|Printed
operator|=
name|printed
expr_stmt|;
name|printed
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|yyline
operator|=
name|yyline
expr_stmt|;
name|yyline
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|yyLinpt
operator|=
name|yyLinpt
expr_stmt|;
name|yyLinpt
operator|=
literal|0
expr_stmt|;
comment|/*  *	left over from before stdio  *  *	ip->ibp = ibp;  *	ibp = cp;  *  */
ifdef|#
directive|ifdef
name|PC
name|stabinclude
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|skipbl
argument_list|(
argument|ocp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ocp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|ocp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
name|cp
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * At the end of an include,  * close the file, free the input buffer,  * and restore the environment before  * the "push", including the value of  * the z option for pxp and the l option for pi.  */
end_comment

begin_macro
name|uninclud
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|inc
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|inclev
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  *	left over from before stdio: becomes fclose ( ibp )  *  *	close(ibp[0]);  *	free(ibp);  *  */
name|fclose
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|&
name|incs
index|[
name|inclev
index|]
expr_stmt|;
name|ibp
operator|=
name|ip
operator|->
name|ibp
expr_stmt|;
name|yyline
operator|=
name|ip
operator|->
name|yyline
expr_stmt|;
if|if
condition|(
name|inpflist
argument_list|(
name|filename
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PI
name|opop
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PXP
name|opop
argument_list|(
literal|'z'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|filename
operator|=
name|ip
operator|->
name|filename
expr_stmt|;
name|yyLinpt
operator|=
name|ip
operator|->
name|yyLinpt
expr_stmt|;
comment|/* 	 * If we printed out the nested name, 	 * then we should print all covered names again. 	 * If we didn't print out the nested name 	 * we print the uncovered name only if it 	 * has not been printed before (unstack). 	 */
if|if
condition|(
name|printed
condition|)
block|{
name|printed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ip
operator|>=
name|incs
condition|)
block|{
name|ip
operator|->
name|Printed
operator|=
literal|0
expr_stmt|;
name|ip
operator|--
expr_stmt|;
block|}
block|}
else|else
name|printed
operator|=
name|ip
operator|->
name|Printed
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ
comment|/* 	 * For the debugger pdx, we need to note that we've changed files. 	 */
name|newfile
argument_list|(
name|filename
argument_list|,
name|yyline
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PC
if|if
condition|(
name|inclev
operator|==
literal|0
condition|)
block|{
name|stabsource
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stabinclude
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|PC
name|inclev
operator|--
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

