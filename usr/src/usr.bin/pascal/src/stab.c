begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)stab.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*      *	Procedures to put out symbol table information      *	and stabs for separate compilation type checking.      *	These use the .stabs, .stabn, and .stabd directives.      */
end_comment

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_comment
comment|/*	and the rest of the file */
end_comment

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"objfmt.h"
end_include

begin_include
include|#
directive|include
file|"yy.h"
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_comment
comment|/*      *  additional symbol definition for<stab.h>      *	that is used by the separate compilation facility --      *	eventually,<stab.h> should be updated to include this       */
end_comment

begin_include
include|#
directive|include
file|"pstab.h"
end_include

begin_include
include|#
directive|include
file|"pc.h"
end_include

begin_define
define|#
directive|define
name|private
value|static
end_define

begin_decl_stmt
name|int
name|oldway
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      *	absolute value: line numbers are negative if error recovery.      */
end_comment

begin_define
define|#
directive|define
name|ABS
parameter_list|(
name|x
parameter_list|)
value|( x< 0 ? -x : x )
end_define

begin_function_decl
name|long
name|checksum
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Generate information about variables.  */
end_comment

begin_macro
name|stabgvar
argument_list|(
argument|p
argument_list|,
argument|length
argument_list|,
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|,
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\"%s\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|symbol
argument_list|,
name|N_PC
argument_list|,
name|N_PGVAR
argument_list|,
name|ABS
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldway
operator|!=
literal|0
condition|)
block|{
name|oldstabgvar
argument_list|(
name|p
operator|->
name|symbol
argument_list|,
name|p2type
argument_list|(
name|p
operator|->
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
name|length
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
name|putprintf
argument_list|(
literal|"\t.stabs\t\"%s:G"
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|gentype
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0x%x,0"
argument_list|,
literal|0
argument_list|,
name|N_GSYM
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|stablvar
argument_list|(
argument|p
argument_list|,
argument|offset
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|,
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|level
decl_stmt|;
name|level
operator|=
operator|(
name|p
operator|->
name|nl_block
operator|&
literal|037
operator|)
expr_stmt|;
if|if
condition|(
name|oldway
operator|!=
literal|0
condition|)
block|{
name|oldstablvar
argument_list|(
name|p
operator|->
name|symbol
argument_list|,
name|p2type
argument_list|(
name|p
operator|->
name|type
argument_list|)
argument_list|,
name|level
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
name|putprintf
argument_list|(
literal|"\t.stabs\t\"%s:"
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|gentype
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
name|N_LSYM
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	global variables      */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|oldstabgvar
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|,
argument|offset
argument_list|,
argument|length
argument_list|,
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0x%x,0"
argument_list|,
literal|0
argument_list|,
name|N_GSYM
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0,0x%x"
argument_list|,
literal|0
argument_list|,
name|N_LENG
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	local variables      */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|oldstablvar
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|,
argument|level
argument_list|,
argument|offset
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
name|N_LSYM
argument_list|,
name|type
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0,0x%x"
argument_list|,
literal|0
argument_list|,
name|N_LENG
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|stabparam
argument_list|(
argument|p
argument_list|,
argument|offset
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|,
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|oldway
operator|!=
literal|0
condition|)
block|{
name|oldstabparam
argument_list|(
name|p
operator|->
name|symbol
argument_list|,
name|p2type
argument_list|(
name|p
operator|->
name|type
argument_list|)
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
name|putprintf
argument_list|(
literal|"\t.stabs\t\"%s:"
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|class
operator|==
name|REF
condition|)
block|{
name|putprintf
argument_list|(
literal|"v"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putprintf
argument_list|(
literal|"p"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|gentype
argument_list|(
operator|(
name|p
operator|->
name|class
operator|==
name|FPROC
operator|||
name|p
operator|->
name|class
operator|==
name|FFUNC
operator|)
condition|?
name|p
else|:
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
name|N_PSYM
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	parameters      */
end_comment

begin_macro
name|oldstabparam
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|,
argument|offset
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
name|N_PSYM
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0,0x%x"
argument_list|,
literal|0
argument_list|,
name|N_LENG
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	fields      */
end_comment

begin_comment
comment|/*      *	left brackets      *  (dbx handles module-2 without these, so we won't use them either)      */
end_comment

begin_macro
name|stablbrac
argument_list|(
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
operator|||
name|oldway
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabd	0x%x,0,0x%x"
argument_list|,
literal|0
argument_list|,
name|N_LBRAC
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	right brackets      */
end_comment

begin_macro
name|stabrbrac
argument_list|(
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
operator|||
name|oldway
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabd	0x%x,0,0x%x"
argument_list|,
literal|0
argument_list|,
name|N_RBRAC
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|stabfunc
argument_list|(
argument|p
argument_list|,
argument|name
argument_list|,
argument|line
argument_list|,
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|,
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|extname
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|nestspec
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|level
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|class
operator|==
name|FUNC
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\"%s\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|N_PC
argument_list|,
name|N_PGFUNC
argument_list|,
name|ABS
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|class
operator|==
name|PROC
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\"%s\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|N_PC
argument_list|,
name|N_PGPROC
argument_list|,
name|ABS
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldway
operator|!=
literal|0
condition|)
block|{
name|oldstabfunc
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|class
argument_list|,
name|line
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
name|putprintf
argument_list|(
literal|"\t.stabs\t\"%s:"
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|class
operator|==
name|FUNC
condition|)
block|{
name|putprintf
argument_list|(
literal|"F"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gentype
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|","
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putprintf
argument_list|(
literal|"P,"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sextname
argument_list|(
name|extname
argument_list|,
name|name
argument_list|,
name|level
argument_list|)
expr_stmt|;
comment|/* set extname to entry label */
name|putprintf
argument_list|(
literal|"%s,"
argument_list|,
literal|1
argument_list|,
operator|&
operator|(
name|extname
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* remove initial underbar */
name|snestspec
argument_list|(
name|nestspec
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"%s\",0x%x,0,0,%s"
argument_list|,
literal|0
argument_list|,
name|nestspec
argument_list|,
name|N_FUN
argument_list|,
name|extname
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      * construct the colon-separated static nesting string into a      * caller-supplied buffer      */
end_comment

begin_function
name|private
name|snestspec
parameter_list|(
name|buffer
parameter_list|,
name|level
parameter_list|)
name|char
name|buffer
index|[]
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
name|char
modifier|*
name|starthere
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|level
operator|<=
literal|1
condition|)
block|{
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|starthere
operator|=
operator|&
name|buffer
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|level
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|starthere
argument_list|,
literal|"%s:"
argument_list|,
name|enclosing
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|starthere
operator|+=
name|strlen
argument_list|(
name|enclosing
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|starthere
operator|--
operator|=
literal|'\0'
expr_stmt|;
comment|/* remove last colon */
if|if
condition|(
name|starthere
operator|>=
operator|&
name|buffer
index|[
name|BUFSIZ
operator|-
literal|1
index|]
condition|)
block|{
name|panic
argument_list|(
literal|"snestspec"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*      *	functions      */
end_comment

begin_macro
name|oldstabfunc
argument_list|(
argument|name
argument_list|,
argument|typeclass
argument_list|,
argument|line
argument_list|,
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|typeclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|extname
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* 	     *	for sdb 	     */
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|name
argument_list|)
expr_stmt|;
name|sextname
argument_list|(
name|extname
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|level
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0x%x,%s"
argument_list|,
literal|0
argument_list|,
name|N_FUN
argument_list|,
name|line
argument_list|,
operator|(
name|int
operator|)
name|extname
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	source line numbers      */
end_comment

begin_macro
name|stabline
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabd	0x%x,0,0x%x"
argument_list|,
literal|0
argument_list|,
name|N_SLINE
argument_list|,
name|ABS
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	source files get none or more of these:      *  one as they are entered,      *  and one every time they are returned to from nested #includes      */
end_comment

begin_macro
name|stabsource
argument_list|(
argument|filename
argument_list|,
argument|firsttime
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|firsttime
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|label
decl_stmt|;
comment|/* 	 *	for separate compilation 	 */
name|putprintf
argument_list|(
literal|"	.stabs	\"%s\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|filename
argument_list|,
name|N_PC
argument_list|,
name|N_PSO
argument_list|,
name|N_FLAGCHECKSUM
argument_list|)
expr_stmt|;
comment|/* 	 *	for debugger 	 */
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|oldway
operator|!=
literal|0
condition|)
block|{
name|label
operator|=
operator|(
name|int
operator|)
name|getlab
argument_list|()
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0,"
argument_list|,
literal|1
argument_list|,
name|N_SO
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|0
argument_list|,
name|LLABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|1
argument_list|,
name|LLABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|":"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|firsttime
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_SO
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*      *	included files get one or more of these:      *	one as they are entered by a #include,      *	and one every time they are returned to from nested #includes.      */
end_comment

begin_macro
name|stabinclude
argument_list|(
argument|filename
argument_list|,
argument|firsttime
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|firsttime
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|label
decl_stmt|;
name|long
name|check
decl_stmt|;
comment|/* 	 *	for separate compilation 	 */
if|if
condition|(
name|firsttime
condition|)
block|{
name|check
operator|=
name|checksum
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|check
operator|=
name|N_FLAGCHECKSUM
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\"%s\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|filename
argument_list|,
name|N_PC
argument_list|,
name|N_PSOL
argument_list|,
name|check
argument_list|)
expr_stmt|;
comment|/* 	 *	for sdb 	 */
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|oldway
operator|!=
literal|0
condition|)
block|{
name|label
operator|=
operator|(
name|int
operator|)
name|getlab
argument_list|()
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0,"
argument_list|,
literal|1
argument_list|,
name|N_SOL
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|0
argument_list|,
name|LLABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|1
argument_list|,
name|LLABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|":"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	anyone know a good checksum for ascii files?      *	this does a rotate-left and then exclusive-or's in the character.      *	also, it avoids returning checksums of 0.      *	The rotate is implemented by shifting and adding back the      *	sign bit when negative.      */
end_comment

begin_function
name|long
name|checksum
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|filep
decl_stmt|;
specifier|register
name|int
name|input
decl_stmt|;
specifier|register
name|long
name|check
decl_stmt|;
name|filep
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filep
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
name|check
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|input
operator|=
name|getc
argument_list|(
name|filep
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|check
operator|<
literal|0
condition|)
block|{
name|check
operator|<<=
literal|1
expr_stmt|;
name|check
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|check
operator|<<=
literal|1
expr_stmt|;
block|}
name|check
operator|^=
name|input
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|filep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|check
operator|<=
name|N_FLAGCHECKSUM
condition|)
block|{
return|return
name|N_FLAGCHECKSUM
operator|+
literal|1
return|;
block|}
else|else
block|{
return|return
name|check
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * global Pascal symbols :  *   labels, types, constants, and external procedure and function names:  *   These are used by the separate compilation facility  *   to be able to check for disjoint header files.  */
end_comment

begin_comment
comment|/*      *	global labels      */
end_comment

begin_macro
name|stabglabel
argument_list|(
argument|label
argument_list|,
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\"%s\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|label
argument_list|,
name|N_PC
argument_list|,
name|N_PGLABEL
argument_list|,
name|ABS
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	global constants      */
end_comment

begin_macro
name|stabgconst
argument_list|(
argument|const
argument_list|,
argument|line
argument_list|)
end_macro

begin_expr_stmt
name|char
operator|*
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\"%s\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
specifier|const
argument_list|,
name|N_PC
argument_list|,
name|N_PGCONST
argument_list|,
name|ABS
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Generate symbolic information about a constant.  */
end_comment

begin_macro
unit|} }
name|stabgtype
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|,
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nl
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\"%s\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|N_PC
argument_list|,
name|N_PGTYPE
argument_list|,
name|ABS
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldway
operator|==
literal|0
condition|)
block|{
name|stabltype
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|stabltype
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nl
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
name|putprintf
argument_list|(
literal|"\t.stabs\t\"%s:t"
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gentype
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_LSYM
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	external functions and procedures      */
end_comment

begin_macro
name|stabefunc
argument_list|(
argument|name
argument_list|,
argument|typeclass
argument_list|,
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|typeclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
if|if
condition|(
name|typeclass
operator|==
name|FUNC
condition|)
block|{
name|type
operator|=
name|N_PEFUNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeclass
operator|==
name|PROC
condition|)
block|{
name|type
operator|=
name|N_PEPROC
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\"%s\",0x%x,0,0x%x,0x%x"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|name
argument_list|,
name|N_PC
argument_list|,
name|type
argument_list|,
name|ABS
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Generate type information encoded as a string for dbx.  * The fwdptrnum field is used only when the type is a pointer  * to a type that isn't known when it was entered.  When the  * type field is filled for some such tptr, fixfwdtype should  * be called to output an equivalencing type definition.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|TypeDesc
modifier|*
name|TypeDesc
typedef|;
end_typedef

begin_struct
struct|struct
name|TypeDesc
block|{
name|struct
name|nl
modifier|*
name|tptr
decl_stmt|;
name|int
name|tnum
decl_stmt|;
name|int
name|fwdptrnum
decl_stmt|;
name|TypeDesc
name|chain
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TABLESIZE
value|2003
end_define

begin_define
define|#
directive|define
name|typehash
parameter_list|(
name|t
parameter_list|)
value|( ( ((int) t)>> 2 ) % TABLESIZE )
end_define

begin_decl_stmt
name|private
name|int
name|tcount
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|TypeDesc
name|typetable
index|[
name|TABLESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|TypeDesc
name|tdlookup
parameter_list|(
name|t
parameter_list|)
name|struct
name|nl
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|TypeDesc
name|td
decl_stmt|;
name|td
operator|=
name|typetable
index|[
name|typehash
argument_list|(
name|t
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|td
operator|!=
name|NIL
operator|&&
name|td
operator|->
name|tptr
operator|!=
name|t
condition|)
block|{
name|td
operator|=
name|td
operator|->
name|chain
expr_stmt|;
block|}
return|return
name|td
return|;
block|}
end_function

begin_function
name|private
name|int
name|typelookup
parameter_list|(
name|t
parameter_list|)
name|struct
name|nl
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|TypeDesc
name|td
decl_stmt|;
name|int
name|r
decl_stmt|;
name|td
operator|=
name|tdlookup
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NIL
condition|)
block|{
name|r
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|td
operator|->
name|tnum
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|private
name|int
name|entertype
parameter_list|(
name|type
parameter_list|)
name|struct
name|nl
modifier|*
name|type
decl_stmt|;
block|{
specifier|register
name|TypeDesc
name|td
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|td
operator|=
operator|(
name|TypeDesc
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|TypeDesc
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|tptr
operator|=
name|type
expr_stmt|;
name|td
operator|->
name|tnum
operator|=
name|tcount
expr_stmt|;
name|td
operator|->
name|fwdptrnum
operator|=
literal|0
expr_stmt|;
operator|++
name|tcount
expr_stmt|;
name|i
operator|=
name|typehash
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|td
operator|->
name|chain
operator|=
name|typetable
index|[
name|i
index|]
expr_stmt|;
name|typetable
index|[
name|i
index|]
operator|=
name|td
expr_stmt|;
return|return
name|td
operator|->
name|tnum
return|;
block|}
end_function

begin_comment
comment|/*  * The in_types table currently contains "boolean", "char", "integer",  * "real" and "_nil".  (See nl.c for definition.)  * The lookup call below will give the TYPE class nl entry for these  * types.  In each case except _nil, the type field of that entry is a RANGE  * class nl entry for the type.  Sometimes other symbol table entries  * point to the TYPE entry (e.g., when there is a range over the base type),  * and other entries point to the RANGE entry (e.g., for a variable of the  * given type).  We don't really want to distinguish between these uses  * in dbx, and since it appears that the RANGE entries are not reused if  * a range happens to coincide, we will give the two the same identifying  * dbx type number.  */
end_comment

begin_function
name|private
name|inittypes
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|extern
name|char
modifier|*
name|in_types
index|[]
decl_stmt|;
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|in_types
index|[
name|i
index|]
operator|!=
name|NIL
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|lookup
argument_list|(
name|in_types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NIL
condition|)
block|{
name|entertype
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|NIL
condition|)
block|{
operator|--
name|tcount
expr_stmt|;
comment|/* see comment above */
name|entertype
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|genarray
argument_list|(
argument|t
argument_list|)
expr|struct
name|nl
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
name|putprintf
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|t
operator|->
name|chain
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|p
operator|->
name|chain
control|)
block|{
name|gentype
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|";"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|gentype
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Really we should walk through ptr[NL_FIELDLIST] for the fields,  * and then do the variant tag and fields separately, but dbx  * doesn't support this yet.  * So, since all the fields of all the variants are on the chain,  * we walk through that.  Except that this gives the fields in the  * reverse order, so we want to print in reverse order.  */
end_comment

begin_expr_stmt
specifier|static
name|genrecord
argument_list|(
argument|t
argument_list|)
expr|struct
name|nl
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|putprintf
argument_list|(
literal|"s%d"
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|value
index|[
name|NL_OFFS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|chain
operator|!=
name|NIL
condition|)
block|{
name|genrecfield
argument_list|(
name|t
operator|->
name|chain
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|";"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|genrecfield
argument_list|(
argument|t
argument_list|,
argument|n
argument_list|)
expr|struct
name|nl
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|t
operator|->
name|chain
operator|!=
name|NULL
condition|)
block|{
name|genrecfield
argument_list|(
name|t
operator|->
name|chain
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|gencontinue
argument_list|()
expr_stmt|;
block|}
block|}
name|putprintf
argument_list|(
literal|"%s:"
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|gentype
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|",%d,%d;"
argument_list|,
literal|1
argument_list|,
literal|8
operator|*
name|t
operator|->
name|value
index|[
name|NL_OFFS
index|]
argument_list|,
literal|8
operator|*
name|lwidth
argument_list|(
name|t
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|genvarnt
argument_list|(
argument|t
argument_list|)
expr|struct
name|nl
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|genrecord
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|genptr
argument_list|(
argument|t
argument_list|)
expr|struct
name|nl
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|TypeDesc
name|td
decl_stmt|;
name|putprintf
argument_list|(
literal|"*"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|!=
name|NIL
condition|)
block|{
name|gentype
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * unresolved forward pointer: use tcount to represent what is          * begin pointed to, to be defined later 	 */
name|td
operator|=
name|tdlookup
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NIL
condition|)
block|{
name|panic
argument_list|(
literal|"nil ptr in stab.genptr"
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|fwdptrnum
operator|=
name|tcount
expr_stmt|;
name|putprintf
argument_list|(
literal|"%d"
argument_list|,
literal|1
argument_list|,
name|tcount
argument_list|)
expr_stmt|;
operator|++
name|tcount
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * The type t is a pointer which has just had its type field filled.  * We need to generate a type stab saying that the number saved  * in t's fwdptrnum is the same as the t->type's number  */
end_comment

begin_macro
name|fixfwdtype
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|TypeDesc
name|td
decl_stmt|;
if|if
condition|(
name|opt
argument_list|(
literal|'g'
argument_list|)
operator|&&
name|oldway
operator|==
literal|0
condition|)
block|{
name|td
operator|=
name|tdlookup
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|!=
name|NIL
condition|)
block|{
name|putprintf
argument_list|(
literal|"\t.stabs\t\":t%d="
argument_list|,
literal|1
argument_list|,
name|td
operator|->
name|fwdptrnum
argument_list|)
expr_stmt|;
name|gentype
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0x%x,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_LSYM
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|genenum
argument_list|(
argument|t
argument_list|)
expr|struct
name|nl
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|e
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|putprintf
argument_list|(
literal|"e"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|e
operator|=
name|t
operator|->
name|chain
expr_stmt|;
while|while
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
name|gencontinue
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|"%s:%d,"
argument_list|,
literal|1
argument_list|,
name|e
operator|->
name|symbol
argument_list|,
name|e
operator|->
name|range
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|e
operator|=
name|e
operator|->
name|chain
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|";"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|genset
argument_list|(
argument|t
argument_list|)
expr|struct
name|nl
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|putprintf
argument_list|(
literal|"S"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gentype
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|genrange
argument_list|(
argument|t
argument_list|)
expr|struct
name|nl
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|putprintf
argument_list|(
literal|"r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gentype
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|";%d;%d"
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|genfparam
argument_list|(
argument|t
argument_list|)
expr|struct
name|nl
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|!=
name|NULL
condition|)
block|{
name|putprintf
argument_list|(
literal|"f"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gentype
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|","
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putprintf
argument_list|(
literal|"p"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|t
operator|->
name|ptr
index|[
name|NL_FCHAIN
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|chain
control|)
block|{
operator|++
name|count
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|"%d;"
argument_list|,
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|t
operator|->
name|ptr
index|[
name|NL_FCHAIN
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|chain
control|)
block|{
name|gentype
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|",%d;"
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|class
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|genfile
argument_list|(
argument|t
argument_list|)
expr|struct
name|nl
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|putprintf
argument_list|(
literal|"d"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gentype
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|gentype
argument_list|(
argument|t
argument_list|)
expr|struct
name|nl
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|id
decl_stmt|;
if|if
condition|(
name|tcount
operator|==
literal|1
condition|)
block|{
name|inittypes
argument_list|()
expr_stmt|;
block|}
name|id
operator|=
name|typelookup
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
literal|0
condition|)
block|{
name|putprintf
argument_list|(
literal|"%d"
argument_list|,
literal|1
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|SCAL
operator|&&
name|t
operator|->
name|chain
operator|==
name|NULL
condition|)
block|{
name|id
operator|=
name|typelookup
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
literal|0
condition|)
block|{
name|putprintf
argument_list|(
literal|"%d"
argument_list|,
literal|1
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|genenum
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|id
operator|=
name|entertype
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"%d="
argument_list|,
literal|1
argument_list|,
name|id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|class
condition|)
block|{
case|case
name|TYPE
case|:
name|gentype
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY
case|:
name|genarray
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD
case|:
name|genrecord
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|VARNT
case|:
name|genvarnt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|REF
case|:
name|gentype
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTR
case|:
name|genptr
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
name|genset
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RANGE
case|:
name|genrange
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCAL
case|:
name|genenum
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPROC
case|:
case|case
name|FFUNC
case|:
name|genfparam
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILET
case|:
case|case
name|PTRFILE
case|:
name|genfile
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This shouldn't happen */
comment|/* Rather than bomb outright, let debugging go on */
name|warning
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Bad type class found in stab"
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"1"
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|class
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Continue stab information in a namelist new entry.  This is necessary  * to avoid overflowing putprintf's buffer.  */
end_comment

begin_expr_stmt
specifier|static
name|gencontinue
argument_list|()
block|{
name|putprintf
argument_list|(
literal|"?\",0x%x,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_LSYM
argument_list|)
block|;
name|putprintf
argument_list|(
literal|"\t.stabs\t\""
argument_list|,
literal|1
argument_list|)
block|; }
end_expr_stmt

begin_endif
endif|#
directive|endif
endif|PC
end_endif

end_unit

