begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_comment
comment|/*      *	procedures to put out sdb symbol table information      *	    these use the new .stabs, .stabn, and .stabd directives      */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)stab.c 1.1 %G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_comment
comment|/*	and the rest of the file */
end_comment

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_comment
comment|/*      *	here's that ugly name length limit of 8 characters      *	until someone fixes sdb.      */
end_comment

begin_define
define|#
directive|define
name|SNAMELENGTH
value|8
end_define

begin_define
define|#
directive|define
name|SNAMEFORMAT
value|"%.*s"
end_define

begin_comment
comment|/*  *  the file "p.a.out" has an additional symbol definition for "a.out.h"  *	that is used by the separate compilation facility --  *	eventually, "a.out.h" must be updated to include this   */
end_comment

begin_include
include|#
directive|include
file|"p.a.out.h"
end_include

begin_include
include|#
directive|include
file|"pc.h"
end_include

begin_comment
comment|/*      *	variables      */
end_comment

begin_macro
name|stabvar
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|,
argument|level
argument_list|,
argument|offset
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|nullchar
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* for separate compilation */
if|if
condition|(
operator|(
name|level
operator|==
literal|1
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|DISPLAYNAME
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|nullchar
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|nullchar
condition|)
block|{
name|nullchar
operator|++
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|name
init|;
name|cp
operator|<
name|nullchar
condition|;
name|cp
operator|+=
name|SNAMELENGTH
control|)
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|SNAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|SNAMELENGTH
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PGVAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|nullchar
condition|)
block|{
comment|/* 		 * then the name was exactly a multiple of SNAMELENGTH long, 		 * and i have to put out a null to terminate it. 		 */
name|putprintf
argument_list|(
literal|"	.stabn	0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PGVAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* for sdb */
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|1
condition|)
block|{
name|putprintf
argument_list|(
literal|"\",0%o,0,0%o,0"
argument_list|,
literal|0
argument_list|,
name|N_GSYM
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putprintf
argument_list|(
literal|"\",0%o,0,0%o,%d"
argument_list|,
literal|0
argument_list|,
name|N_LSYM
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,0%o"
argument_list|,
literal|0
argument_list|,
name|N_LENG
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	parameters      */
end_comment

begin_macro
name|stabparam
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|,
argument|offset
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0%o,%d"
argument_list|,
literal|0
argument_list|,
name|N_PSYM
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,0%o"
argument_list|,
literal|0
argument_list|,
name|N_LENG
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	fields      */
end_comment

begin_macro
name|stabfield
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|,
argument|offset
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0%o,%d"
argument_list|,
literal|0
argument_list|,
name|N_SSYM
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,0%o"
argument_list|,
literal|0
argument_list|,
name|N_LENG
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	left brackets      */
end_comment

begin_macro
name|stablbrac
argument_list|(
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabd	0%o,0,%d"
argument_list|,
literal|0
argument_list|,
name|N_LBRAC
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	right brackets      */
end_comment

begin_macro
name|stabrbrac
argument_list|(
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabd	0%o,0,%d"
argument_list|,
literal|0
argument_list|,
name|N_RBRAC
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	functions      */
end_comment

begin_macro
name|stabfunc
argument_list|(
argument|name
argument_list|,
argument|line
argument_list|,
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|nullchar
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 *	for separate compilation 	 */
name|nullchar
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|nullchar
condition|)
block|{
name|nullchar
operator|++
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|name
init|;
name|cp
operator|<
name|nullchar
condition|;
name|cp
operator|+=
name|SNAMELENGTH
control|)
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|SNAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|SNAMELENGTH
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PFUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|nullchar
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.stabn	0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PFUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* for sdb */
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,%d,"
argument_list|,
literal|1
argument_list|,
name|N_FUN
argument_list|,
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|level
condition|;
name|i
operator|++
control|)
block|{
name|putprintf
argument_list|(
name|EXTFORMAT
argument_list|,
literal|1
argument_list|,
name|enclosing
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
name|EXTFORMAT
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	source line numbers      */
end_comment

begin_macro
name|stabline
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|line
operator|<
literal|0
condition|)
block|{
comment|/* 		 *	line numbers get to be negative if there was an error. 		 */
name|line
operator|=
operator|-
name|line
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|"	.stabd	0%o,0,%d"
argument_list|,
literal|0
argument_list|,
name|N_SLINE
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	source files      */
end_comment

begin_macro
name|stabsource
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|label
init|=
name|getlab
argument_list|()
decl_stmt|;
name|char
modifier|*
name|nullchar
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|nullchar
operator|=
name|filename
expr_stmt|;
while|while
condition|(
operator|*
name|nullchar
condition|)
block|{
name|nullchar
operator|++
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|filename
init|;
name|cp
operator|<
name|nullchar
condition|;
name|cp
operator|+=
name|SNAMELENGTH
control|)
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|SNAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|SNAMELENGTH
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PSO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|nullchar
condition|)
block|{
comment|/* 	 * then the name was exactly a multiple of SNAMELENGTH long, 	 */
name|putprintf
argument_list|(
literal|"	.stabn	0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PSO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* for sdb */
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,"
argument_list|,
literal|1
argument_list|,
name|N_SO
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|0
argument_list|,
name|LLABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|1
argument_list|,
name|LLABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|":"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	included files get one or more of these:      *	one as they are entered by a #include,      *	and one every time they are returned to by nested #includes      */
end_comment

begin_macro
name|stabinclude
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|label
init|=
name|getlab
argument_list|()
decl_stmt|;
name|char
modifier|*
name|nullchar
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|nullchar
operator|=
name|filename
expr_stmt|;
while|while
condition|(
operator|*
name|nullchar
condition|)
block|{
name|nullchar
operator|++
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|filename
init|;
name|cp
operator|<
name|nullchar
condition|;
name|cp
operator|+=
name|SNAMELENGTH
control|)
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|SNAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|SNAMELENGTH
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PSOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|nullchar
condition|)
block|{
comment|/* 	 * then the name was exactly a multiple of SNAMELENGTH long, 	 */
name|putprintf
argument_list|(
literal|"	.stabn	0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PSOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* for sdb */
if|if
condition|(
operator|!
name|opt
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
return|return;
block|}
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|NAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,"
argument_list|,
literal|1
argument_list|,
name|N_SOL
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|0
argument_list|,
name|LLABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|1
argument_list|,
name|LLABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|":"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * global Pascal symbols :  *   labels, types, constants, and external procedure and function names:  *   These are used by the separate compilation facility  *   to be able to check for disjoint header files.  *   New symbol codes : (N_PGVAR, N_PFUN defined above),  *   N_PGLAB, N_PGCON, N_PGTYP    *   and N_PEFUN are defined for these additional global Pascal	  *   symbols in p.a.out.h so that   *   they can be ignored by "sdb".  The only information  *   put out for constants and types is their names.  *   For labels, the integer label is put out. For external functions  *   and procedures, the name of the function or procedure is put out.  */
end_comment

begin_comment
comment|/* global constants */
end_comment

begin_macro
name|stabcname
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|nullchar
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|nullchar
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|nullchar
condition|)
block|{
name|nullchar
operator|++
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|name
init|;
name|cp
operator|<
name|nullchar
condition|;
name|cp
operator|+=
name|SNAMELENGTH
control|)
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|SNAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|SNAMELENGTH
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PGCON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|nullchar
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.stabn	0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PGCON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* global types */
end_comment

begin_macro
name|stabtname
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|nullchar
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|nullchar
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|nullchar
condition|)
block|{
name|nullchar
operator|++
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|name
init|;
name|cp
operator|<
name|nullchar
condition|;
name|cp
operator|+=
name|SNAMELENGTH
control|)
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|SNAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|SNAMELENGTH
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PGTYP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|nullchar
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.stabn	0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PGTYP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* global labels */
end_comment

begin_macro
name|stabglab
argument_list|(
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|int
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|1
argument_list|,
name|PLABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PGLAB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* external functions and procedures */
end_comment

begin_macro
name|stabefunc
argument_list|(
argument|name
argument_list|,
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|nullchar
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|nullchar
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|nullchar
condition|)
block|{
name|nullchar
operator|++
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|name
init|;
name|cp
operator|<
name|nullchar
condition|;
name|cp
operator|+=
name|SNAMELENGTH
control|)
block|{
name|putprintf
argument_list|(
literal|"	.stabs	\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|SNAMEFORMAT
argument_list|,
literal|1
argument_list|,
name|SNAMELENGTH
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"\",0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PEFUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|nullchar
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.stabn	0%o,0,0,0"
argument_list|,
literal|0
argument_list|,
name|N_PEFUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PC
end_endif

end_unit

