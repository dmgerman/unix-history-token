begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)yyput.c	5.3 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * pi - Pascal interpreter code translator  *  * Charles Haley, Bill Joy UCB  * Version 1.2 January 1979  *  *  * pxp - Pascal execution profiler  *  * Bill Joy UCB  * Version 1.2 January 1979  */
end_comment

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"yy.h"
end_include

begin_comment
comment|/*  * Structure describing queued listing lines during the forward move  * of error recovery.  These lines will be stroed by yyoutline during  * the forward move and flushed by yyoutfl or yyflush when an  * error occurs or a program termination.  */
end_comment

begin_struct
struct|struct
name|B
block|{
name|int
name|Bmagic
decl_stmt|;
name|int
name|Bline
decl_stmt|;
name|int
name|Bseekp
decl_stmt|;
name|char
modifier|*
name|Bfile
decl_stmt|;
name|int
name|Bseqid
decl_stmt|;
name|struct
name|B
modifier|*
name|Bnext
decl_stmt|;
block|}
modifier|*
name|bottled
struct|;
end_struct

begin_comment
comment|/*  * Filename gives the current input file, lastname is  * the last filename we printed, and lastid is the seqid of the last line  * we printed, to help us avoid printing  * multiple copies of lines.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lastname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|hadsome
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|holdbl
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Print the current line in the input line  * buffer or, in a forward move of the recovery, queue it for printing.  */
end_comment

begin_macro
name|yyoutline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|B
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|Recovery
condition|)
block|{
name|bp
operator|=
name|tree
argument_list|(
literal|6
argument_list|,
name|T_BOTTLE
argument_list|,
name|yyline
argument_list|,
name|yylinpt
argument_list|,
name|filename
argument_list|,
name|yyseqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bottled
operator|!=
name|NIL
condition|)
name|bp
operator|->
name|Bnext
operator|=
name|bottled
operator|->
name|Bnext
operator|,
name|bottled
operator|->
name|Bnext
operator|=
name|bp
expr_stmt|;
else|else
name|bp
operator|->
name|Bnext
operator|=
name|bp
expr_stmt|;
name|bottled
operator|=
name|bp
expr_stmt|;
return|return;
block|}
name|yyoutfl
argument_list|(
name|yyseqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyseqid
operator|!=
name|lastid
condition|)
name|yyprline
argument_list|(
name|charbuf
argument_list|,
name|yyline
argument_list|,
name|filename
argument_list|,
name|yyseqid
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Flush all the bottled output.  */
end_comment

begin_macro
name|yyflush
argument_list|()
end_macro

begin_block
block|{
name|yyoutfl
argument_list|(
literal|32767
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Flush the listing to the sequence id toseqid  */
end_comment

begin_macro
name|yyoutfl
argument_list|(
argument|toseqid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|toseqid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|B
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|bottled
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NIL
condition|)
return|return;
name|bp
operator|=
name|bp
operator|->
name|Bnext
expr_stmt|;
while|while
condition|(
name|bp
operator|->
name|Bseqid
operator|<=
name|toseqid
condition|)
block|{
name|yygetline
argument_list|(
name|bp
operator|->
name|Bfile
argument_list|,
name|bp
operator|->
name|Bseekp
argument_list|,
name|bp
operator|->
name|Bline
argument_list|,
name|bp
operator|->
name|Bseqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|Bnext
operator|==
name|bp
condition|)
block|{
name|bottled
operator|=
name|NIL
expr_stmt|;
break|break;
block|}
name|bp
operator|=
name|bp
operator|->
name|Bnext
expr_stmt|;
name|bottled
operator|->
name|Bnext
operator|=
name|bp
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|int
name|yygetunit
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yygetfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Yysync guarantees that the line associated  * with the current token was the last line  * printed for a syntactic error message.  */
end_comment

begin_macro
name|yysync
argument_list|()
end_macro

begin_block
block|{
name|yyoutfl
argument_list|(
name|yyeseqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastid
operator|!=
name|yyeseqid
condition|)
name|yygetline
argument_list|(
name|yyefile
argument_list|,
name|yyseekp
argument_list|,
name|yyeline
argument_list|,
name|yyeseqid
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|yySsync
argument_list|()
end_macro

begin_block
block|{
name|yyoutfl
argument_list|(
name|OY
operator|.
name|Yyeseqid
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Yygetline gets a line from a file after we have  * lost it.  The pointer efile gives the name of the file,  * seekp its offset in the file, and eline its line number.  * If this routine has been called before the last file  * it worked on will be open in yygetunit, with the files  * name being given in yygetfile.  Note that this unit must  * be opened independently of the unit in use for normal i/o  * to this file; if it were a dup seeks would seek both files.  */
end_comment

begin_macro
name|yygetline
argument_list|(
argument|efile
argument_list|,
argument|seekp
argument_list|,
argument|eline
argument_list|,
argument|eseqid
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|efile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|seekp
decl_stmt|,
name|eline
decl_stmt|,
name|eseqid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|buf
index|[
name|CBSIZE
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|lastid
operator|==
name|eseqid
condition|)
return|return;
if|if
condition|(
name|eseqid
operator|==
name|yyseqid
condition|)
block|{
name|bp
operator|=
name|charbuf
expr_stmt|;
name|yyprtd
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|efile
operator|!=
name|yygetfile
condition|)
block|{
name|close
argument_list|(
name|yygetunit
argument_list|)
expr_stmt|;
name|yygetfile
operator|=
name|efile
expr_stmt|;
name|yygetunit
operator|=
name|open
argument_list|(
name|yygetfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|yygetunit
operator|<
literal|0
condition|)
name|oops
label|:
name|perror
argument_list|(
name|yygetfile
argument_list|)
operator|,
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|yygetunit
argument_list|,
operator|(
name|long
operator|)
name|seekp
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|oops
goto|;
name|cnt
operator|=
name|read
argument_list|(
name|yygetunit
argument_list|,
name|bp
argument_list|,
name|CBSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
goto|goto
name|oops
goto|;
name|bp
index|[
name|cnt
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|yyprline
argument_list|(
name|bp
argument_list|,
name|eline
argument_list|,
name|efile
argument_list|,
name|eseqid
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|yyretrieve
argument_list|()
end_macro

begin_block
block|{
name|yygetline
argument_list|(
name|OY
operator|.
name|Yyefile
argument_list|,
name|OY
operator|.
name|Yyseekp
argument_list|,
name|OY
operator|.
name|Yyeline
argument_list|,
name|OY
operator|.
name|Yyeseqid
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Print the line in the character buffer which has  * line number line.  The buffer may be terminated by a new  * line character or a null character.  We process  * form feed directives, lines with only a form feed character, and  * suppress numbering lines which are empty here.  */
end_comment

begin_expr_stmt
name|yyprline
argument_list|(
name|buf
argument_list|,
name|line
argument_list|,
name|file
argument_list|,
name|id
argument_list|)
specifier|register
name|char
operator|*
name|buf
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lastid
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\f'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|printf
argument_list|(
literal|"\f\n"
argument_list|)
expr_stmt|;
name|hadsome
operator|=
literal|0
expr_stmt|;
name|holdbl
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|holdbl
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|holdbl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
name|holdbl
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|yysetfile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|yyprintf
argument_list|(
name|buf
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|hadsome
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|yyprintf
argument_list|(
name|cp
argument_list|,
name|line
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%6d  "
argument_list|,
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|0
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
name|graphic
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|graphic
argument_list|(
name|ch
argument_list|)
specifier|register
name|CHAR
name|ch
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
default|default:
if|if
condition|(
name|ch
operator|>=
literal|' '
condition|)
return|return
operator|(
name|ch
operator|)
return|;
case|case
literal|0177
case|:
return|return
operator|(
literal|'?'
operator|)
return|;
case|case
literal|'\n'
case|:
case|case
literal|'\t'
case|:
return|return
operator|(
name|ch
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
name|nopflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|printed
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set the current file name to be file,  * printing the name, or a header on a new  * page if required.  */
end_comment

begin_expr_stmt
name|yysetfile
argument_list|(
name|file
argument_list|)
specifier|register
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|PXP
if|if
condition|(
name|nopflg
operator|==
literal|1
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|lastname
operator|==
name|file
condition|)
return|return;
if|if
condition|(
name|file
operator|==
name|filename
operator|&&
name|opt
argument_list|(
literal|'n'
argument_list|)
operator|&&
operator|(
name|printed
operator|&
literal|02
operator|)
operator|==
literal|0
condition|)
block|{
name|printed
operator||=
literal|02
expr_stmt|;
name|header
argument_list|()
expr_stmt|;
block|}
else|else
name|yyputfn
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|lastname
operator|=
name|file
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Put out an include file name  * if an error occurs but the name has  * not been printed (or if another name  * has been printed since it has).  */
end_comment

begin_expr_stmt
name|yyputfn
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|int
name|outcol
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|lastname
operator|&&
name|printed
condition|)
return|return;
name|lastname
operator|=
name|cp
expr_stmt|;
name|printed
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PXP
if|if
condition|(
name|outcol
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|hadsome
operator|=
literal|1
expr_stmt|;
block|}
end_block

end_unit

