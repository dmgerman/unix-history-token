begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS revision generation  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: rcsgen.c,v 3.8 89/08/15 21:38:51 bostic Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Walter Tichy.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Report all problems and direct all questions to:  *   rcs-bugs@cs.purdue.edu  *         */
end_comment

begin_comment
comment|/* $Log:	rcsgen.c,v $  * Revision 3.8  89/08/15  21:38:51  bostic  * Version 4 from Tom Narten at Purdue  *   * Revision 4.7  89/05/01  15:12:49  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.6  88/11/08  12:01:13  narten  * changes from  eggert@sm.unisys.com (Paul Eggert)  *   * Revision 4.6  88/08/28  14:59:10  eggert  * Shrink stdio code size; allow cc -R; remove lint; isatty() -> ttystdin()  *   * Revision 4.5  87/12/18  11:43:25  narten  * additional lint cleanups, and a bug fix from the 4.3BSD version that  * keeps "ci" from sticking a '\377' into the description if you run it  * with a zero-length file as the description. (Guy Harris)  *   * Revision 4.4  87/10/18  10:35:10  narten  * Updating version numbers. Changes relative to 1.1 actually relative to  * 4.2  *   * Revision 1.3  87/09/24  13:59:51  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.2  87/03/27  14:22:27  jenkins  * Port to suns  *   * Revision 1.1  84/01/23  14:50:28  kcs  * Initial revision  *   * Revision 4.2  83/12/02  23:01:39  wft  * merged 4.1 and 3.3.1.1 (clearerr(stdin)).  *   * Revision 4.1  83/05/10  16:03:33  wft  * Changed putamin() to abort if trying to reread redirected stdin.  * Fixed getdesc() to output a prompt on initial newline.  *   * Revision 3.3.1.1  83/10/19  04:21:51  lepreau  * Added clearerr(stdin) for re-reading description from stdin.  *   * Revision 3.3  82/11/28  21:36:49  wft  * 4.2 prerelease  *   * Revision 3.3  82/11/28  21:36:49  wft  * Replaced ferror() followed by fclose() with ffclose().  * Putdesc() now suppresses the prompts if stdin  * is not a terminal. A pointer to the current log message is now  * inserted into the corresponding delta, rather than leaving it in a  * global variable.  *  * Revision 3.2  82/10/18  21:11:26  wft  * I added checks for write errors during editing, and improved  * the prompt on putdesc().  *  * Revision 3.1  82/10/13  15:55:09  wft  * corrected type of variables assigned to by getc (char --> int)  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|getnum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern savestring(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern editstring(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|int
name|nextc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next character from lexical analyzer          */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|Ktext
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keywords from syntax analyzer                 */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|Klog
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keyword "log"                                 */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|Kdesc
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keyword for description                       */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new RCS file                                  */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|fcopy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result file during editing                    */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|resultfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file name for fcopy                           */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rewriteflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether to rewrite the input file   */
end_comment

begin_decl_stmt
name|char
name|curlogmsg
index|[
name|logsize
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for current log message                */
end_comment

begin_enum
enum|enum
name|stringwork
block|{
name|copy
block|,
name|edit
block|,
name|expand
block|,
name|edit_expand
block|}
enum|;
end_enum

begin_comment
comment|/* parameter to scandeltatext() */
end_comment

begin_function
name|char
modifier|*
name|buildrevision
parameter_list|(
name|deltas
parameter_list|,
name|target
parameter_list|,
name|dir
parameter_list|,
name|expandflag
parameter_list|)
name|struct
name|hshentry
modifier|*
modifier|*
name|deltas
decl_stmt|,
decl|*
name|target
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expandflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Generates the revision given by target  * by retrieving all deltas given by parameter deltas and combining them.  * If dir==nil, the revision is printed on the standard output,  * otherwise written into a temporary file in directory dir.  * if expandflag==true, keyword expansion is performed.  * returns false on errors, the name of the file with the revision otherwise.  *  * Algorithm: Copy inital revision unchanged. Then edit all revisions but  * the last one into it, alternating input and output files (resultfile and  * editfile). The last revision is then edited in, performing simultaneous  * keyword substitution (this saves one extra pass).  * All this simplifies if only one revision needs to be generated,  * or no keyword expansion is necessary, or if output goes to stdout.  */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|deltas
index|[
literal|0
index|]
operator|==
name|target
condition|)
block|{
comment|/* only latest revision to generate */
if|if
condition|(
name|dir
operator|==
name|nil
condition|)
block|{
comment|/* print directly to stdout */
name|fcopy
operator|=
name|stdout
expr_stmt|;
name|scandeltatext
argument_list|(
name|target
argument_list|,
name|expand
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|true
return|;
block|}
else|else
block|{
name|initeditfiles
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|scandeltatext
argument_list|(
name|target
argument_list|,
name|expandflag
condition|?
name|expand
else|:
name|copy
argument_list|)
expr_stmt|;
name|ffclose
argument_list|(
name|fcopy
argument_list|)
expr_stmt|;
return|return
operator|(
name|resultfile
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* several revisions to generate */
name|initeditfiles
argument_list|(
name|dir
condition|?
name|dir
else|:
literal|"/tmp/"
argument_list|)
expr_stmt|;
comment|/* write initial revision into fcopy, no keyword expansion */
name|scandeltatext
argument_list|(
name|deltas
index|[
literal|0
index|]
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|deltas
index|[
name|i
operator|+
literal|1
index|]
operator|!=
name|nil
condition|)
block|{
comment|/* do all deltas except last one */
name|scandeltatext
argument_list|(
name|deltas
index|[
name|i
operator|++
index|]
argument_list|,
name|edit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|expandflag
condition|)
block|{
comment|/* no keyword expansion; only invoked from ci */
name|scandeltatext
argument_list|(
name|deltas
index|[
name|i
index|]
argument_list|,
name|edit
argument_list|)
expr_stmt|;
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|)
expr_stmt|;
name|ffclose
argument_list|(
name|fcopy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* perform keyword expansion*/
comment|/* first, get to beginning of file*/
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|)
expr_stmt|;
name|swapeditfiles
argument_list|(
name|dir
operator|==
name|nil
argument_list|)
expr_stmt|;
name|scandeltatext
argument_list|(
name|deltas
index|[
name|i
index|]
argument_list|,
name|edit_expand
argument_list|)
expr_stmt|;
name|finishedit
argument_list|(
name|deltas
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|nil
condition|)
name|ffclose
argument_list|(
name|fcopy
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|resultfile
operator|)
return|;
comment|/*doesn't matter for dir==nil*/
block|}
block|}
end_block

begin_macro
name|scandeltatext
argument_list|(
argument|delta
argument_list|,
argument|func
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|stringwork
name|func
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Scans delta text nodes up to and including the one given  * by delta. For the one given by delta, the log message is saved into  * curlogmsg and the text is processed according to parameter func.  * Assumes the initial lexeme must be read in first.  * Does not advance nexttok after it is finished.  */
end_comment

begin_block
block|{
name|struct
name|hshentry
modifier|*
name|nextdelta
decl_stmt|;
do|do
block|{
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nextdelta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
block|{
name|fatserror
argument_list|(
literal|"Can't find delta for revision %s"
argument_list|,
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Klog
argument_list|)
operator|||
name|nexttok
operator|!=
name|STRING
condition|)
name|serror
argument_list|(
literal|"Missing log entry"
argument_list|)
expr_stmt|;
name|elsif
argument_list|(
argument|delta==nextdelta
argument_list|)
block|{
name|VOID
name|savestring
parameter_list|(
name|curlogmsg
parameter_list|,
name|logsize
parameter_list|)
function_decl|;
name|delta
operator|->
name|log
operator|=
name|curlogmsg
expr_stmt|;
block|}
else|else
block|{
name|readstring
argument_list|()
expr_stmt|;
name|delta
operator|->
name|log
operator|=
literal|""
expr_stmt|;
block|}
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Ktext
argument_list|)
operator|||
name|nexttok
operator|!=
name|STRING
condition|)
name|fatserror
argument_list|(
literal|"Missing delta text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
name|nextdelta
condition|)
comment|/* got the one we're looking for */
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|copy
case|:
name|copystring
argument_list|()
expr_stmt|;
break|break;
case|case
name|expand
case|:
name|xpandstring
argument_list|(
name|delta
argument_list|)
expr_stmt|;
break|break;
case|case
name|edit
case|:
name|editstring
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|)
expr_stmt|;
break|break;
case|case
name|edit_expand
case|:
name|editstring
argument_list|(
name|delta
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|readstring
argument_list|()
expr_stmt|;
comment|/* skip over it */
block|}
do|while
condition|(
name|delta
operator|!=
name|nextdelta
condition|)
do|;
block|}
end_block

begin_decl_stmt
name|int
name|stdinread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stdinread>0 if redirected stdin has been read once */
end_comment

begin_function
name|int
name|ttystdin
parameter_list|()
block|{
specifier|static
name|int
name|initialized
decl_stmt|,
name|istty
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|istty
operator|=
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|istty
return|;
block|}
end_function

begin_macro
name|putdesc
argument_list|(
argument|initflag
argument_list|,
argument|textflag
argument_list|,
argument|textfile
argument_list|,
argument|quietflag
argument_list|)
end_macro

begin_decl_stmt
name|int
name|initflag
decl_stmt|,
name|textflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|textfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quietflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: puts the descriptive text into file frewrite.  * if !initflag&& !textflag, the text is copied from the old description.  * Otherwise, if the textfile!=nil, the text is read from that  * file, or from stdin, if textfile==nil.  * Increments stdinread if text is read from redirected stdin.  * if initflag&&quietflag&&!textflag, an empty text is inserted.  * if !initflag, the old descriptive text is discarded.  */
end_comment

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|txt
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|old1
decl_stmt|,
name|old2
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
if|if
condition|(
name|quietflag
operator|==
literal|0
condition|)
name|initflag
operator|=
name|quietflag
expr_stmt|;
comment|/* silencelint */
endif|#
directive|endif
name|frew
operator|=
name|frewrite
expr_stmt|;
if|if
condition|(
operator|!
name|initflag
operator|&&
operator|!
name|textflag
condition|)
block|{
comment|/* copy old description */
name|VOID
name|fprintf
argument_list|(
name|frew
argument_list|,
literal|"\n\n%s%c"
argument_list|,
name|Kdesc
argument_list|,
name|nextc
argument_list|)
decl_stmt|;
name|rewriteflag
operator|=
name|true
expr_stmt|;
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* get new description */
if|if
condition|(
operator|!
name|initflag
condition|)
block|{
comment|/*skip old description*/
name|rewriteflag
operator|=
name|false
expr_stmt|;
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
name|VOID
name|fprintf
argument_list|(
name|frew
argument_list|,
literal|"\n\n%s\n%c"
argument_list|,
name|Kdesc
argument_list|,
name|SDELIM
argument_list|)
decl_stmt|;
if|if
condition|(
name|textfile
condition|)
block|{
name|old1
operator|=
literal|'\n'
expr_stmt|;
comment|/* copy textfile */
if|if
condition|(
operator|(
name|txt
operator|=
name|fopen
argument_list|(
name|textfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|txt
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
name|VOID
name|putc
parameter_list|(
name|c
parameter_list|,
name|frew
parameter_list|)
function_decl|;
comment|/*double up*/
name|VOID
name|putc
parameter_list|(
name|c
parameter_list|,
name|frew
parameter_list|)
function_decl|;
name|old1
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|old1
operator|!=
literal|'\n'
condition|)
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|frew
argument_list|)
decl_stmt|;
name|VOID
name|fclose
parameter_list|(
name|txt
parameter_list|)
function_decl|;
name|VOID
name|putc
parameter_list|(
name|SDELIM
parameter_list|,
name|frew
parameter_list|)
function_decl|;
name|VOID
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|frew
argument_list|)
decl_stmt|;
return|return;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Can't open file %s with description"
argument_list|,
name|textfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ttystdin
argument_list|()
condition|)
return|return;
comment|/* otherwise, get description from terminal */
block|}
block|}
comment|/* read text from stdin */
if|if
condition|(
name|ttystdin
argument_list|()
condition|)
block|{
name|VOID
name|fputs
argument_list|(
literal|"enter description, terminated with ^D or '.':\n"
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
name|VOID
name|fputs
argument_list|(
literal|"NOTE: This is NOT the log message!\n>> "
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* redirected stdin */
if|if
condition|(
name|stdinread
operator|>
literal|0
condition|)
name|faterror
argument_list|(
literal|"Can't reread redirected stdin for description; use -t<file>"
argument_list|)
expr_stmt|;
name|stdinread
operator|++
expr_stmt|;
block|}
name|c
operator|=
literal|'\0'
expr_stmt|;
name|old2
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
operator|(
name|old1
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ttystdin
argument_list|()
condition|)
block|{
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|old1
operator|==
literal|'\n'
operator|&&
name|ttystdin
argument_list|()
condition|)
name|VOID
name|fputs
argument_list|(
literal|">> "
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ttystdin
argument_list|()
condition|)
block|{
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
name|VOID
name|putc
parameter_list|(
name|old1
parameter_list|,
name|frew
parameter_list|)
function_decl|;
if|if
condition|(
name|old1
operator|!=
literal|'\n'
condition|)
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|frew
argument_list|)
decl_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|old1
operator|==
literal|'.'
operator|&&
name|old2
operator|==
literal|'\n'
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|ttystdin
argument_list|()
condition|)
name|VOID
name|fputs
argument_list|(
literal|">> "
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
if|if
condition|(
name|old1
operator|==
name|SDELIM
condition|)
name|VOID
name|putc
parameter_list|(
name|old1
parameter_list|,
name|frew
parameter_list|)
function_decl|;
comment|/* double up*/
name|VOID
name|putc
parameter_list|(
name|old1
parameter_list|,
name|frew
parameter_list|)
function_decl|;
name|old2
operator|=
name|old1
expr_stmt|;
name|old1
operator|=
name|c
expr_stmt|;
block|}
comment|/* end for */
block|}
name|VOID
name|putc
parameter_list|(
name|SDELIM
parameter_list|,
name|frew
parameter_list|)
function_decl|;
name|VOID
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|frew
argument_list|)
decl_stmt|;
block|}
block|}
end_block

end_unit

