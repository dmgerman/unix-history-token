begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS file name handling  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: rcsfnms.c,v 3.12 89/08/15 21:38:10 bostic Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************  *                     creation and deletion of semaphorefile,  *                     creation of temporary filenames and cleanup()  *                     pairing of RCS file names and working file names.  *                     Testprogram: define PAIRTEST  ****************************************************************************  */
end_comment

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Walter Tichy.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Report all problems and direct all questions to:  *   rcs-bugs@cs.purdue.edu  *         */
end_comment

begin_comment
comment|/* $Log:	rcsfnms.c,v $  * Revision 3.12  89/08/15  21:38:10  bostic  * Version 4 from Tom Narten at Purdue  *   * Revision 4.8  89/05/01  15:09:41  narten  * changed getwd to not stat empty directories.  *   * Revision 4.7  88/11/08  12:01:22  narten  * changes from  eggert@sm.unisys.com (Paul Eggert)  *   * Revision 4.7  88/08/09  19:12:53  eggert  * Fix troff macro comment leader bug; add Prolog; allow cc -R; remove lint.  *   * Revision 4.6  87/12/18  11:40:23  narten  * additional file types added from 4.3 BSD version, and SPARC assembler  * comment character added. Also, more lint cleanups. (Guy Harris)  *   * Revision 4.5  87/10/18  10:34:16  narten  * Updating version numbers. Changes relative to 1.1 actually relative  * to verion 4.3  *   * Revision 1.3  87/03/27  14:22:21  jenkins  * Port to suns  *   * Revision 1.2  85/06/26  07:34:28  svb  * Comment leader '% ' for '*.tex' files added.  *   * Revision 1.1  84/01/23  14:50:24  kcs  * Initial revision  *   * Revision 4.3  83/12/15  12:26:48  wft  * Added check for KDELIM in file names to pairfilenames().  *   * Revision 4.2  83/12/02  22:47:45  wft  * Added csh, red, and sl file name suffixes.  *   * Revision 4.1  83/05/11  16:23:39  wft  * Added initialization of Dbranch to InitAdmin(). Canged pairfilenames():  * 1. added copying of path from workfile to RCS file, if RCS file is omitted;  * 2. added getting the file status of RCS and working files;  * 3. added ignoring of directories.  *   * Revision 3.7  83/05/11  15:01:58  wft  * Added comtable[] which pairs file name suffixes with comment leaders;  * updated InitAdmin() accordingly.  *   * Revision 3.6  83/04/05  14:47:36  wft  * fixed Suffix in InitAdmin().  *   * Revision 3.5  83/01/17  18:01:04  wft  * Added getwd() and rename(); these can be removed by defining  * V4_2BSD, since they are not needed in 4.2 bsd.  * Changed sys/param.h to sys/types.h.  *  * Revision 3.4  82/12/08  21:55:20  wft  * removed unused variable.  *  * Revision 3.3  82/11/28  20:31:37  wft  * Changed mktempfile() to store the generated file names.  * Changed getfullRCSname() to store the file and pathname, and to  * delete leading "../" and "./".  *  * Revision 3.2  82/11/12  14:29:40  wft  * changed pairfilenames() to handle file.sfx,v; also deleted checkpathnosfx(),  * checksuffix(), checkfullpath(). Semaphore name generation updated.  * mktempfile() now checks for nil path; freefilename initialized properly.  * Added Suffix .h to InitAdmin. Added testprogram PAIRTEST.  * Moved rmsema, trysema, trydiraccess, getfullRCSname from rcsutil.c to here.  *  * Revision 3.1  82/10/18  14:51:28  wft  * InitAdmin() now initializes StrictLocks=STRICT_LOCKING (def. in rcsbase.h).  * renamed checkpath() to checkfullpath().  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getwd
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* get working directory; forward decl       */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stat
argument_list|()
decl_stmt|,
name|fstat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|finptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RCS input file descriptor                 */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* New RCS file descriptor                   */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|RCSfilename
decl_stmt|,
modifier|*
name|workfilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* filenames                     */
end_comment

begin_decl_stmt
name|struct
name|stat
name|RCSstat
decl_stmt|,
name|workstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file status for RCS file and working file */
end_comment

begin_decl_stmt
name|int
name|haveRCSstat
decl_stmt|,
name|haveworkstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicators if status availalble       */
end_comment

begin_decl_stmt
name|char
name|tempfilename
index|[
name|NCPFN
operator|+
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for derived file names               */
end_comment

begin_decl_stmt
name|char
name|sub1filename
index|[
name|NCPPN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for files path/file.sfx,v            */
end_comment

begin_decl_stmt
name|char
name|sub2filename
index|[
name|NCPPN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for files path/RCS/file.sfx,v        */
end_comment

begin_decl_stmt
name|char
name|semafilename
index|[
name|NCPPN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of semaphore file                    */
end_comment

begin_decl_stmt
name|int
name|madesema
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether a semaphore file has been set */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tfnames
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temp. file names to be unlinked when finished   */
end_comment

begin_decl_stmt
name|int
name|freefilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of next free file name in tfnames[]  */
end_comment

begin_struct
struct|struct
name|compair
block|{
name|char
modifier|*
name|suffix
decl_stmt|,
modifier|*
name|comlead
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|compair
name|comtable
index|[]
init|=
block|{
comment|/* comtable pairs each filename suffix with a comment leader. The comment   */
comment|/* leader is placed before each line generated by the $Log keyword. This    */
comment|/* table is used to guess the proper comment leader from the working file's */
comment|/* suffix during initial ci (see InitAdmin()). Comment leaders are needed   */
comment|/* for languages without multiline comments; for others they are optional.  */
literal|"c"
block|,
literal|" * "
block|,
comment|/* C           */
literal|"csh"
block|,
literal|"# "
block|,
comment|/* shell       */
literal|"e"
block|,
literal|"# "
block|,
comment|/* efl         */
literal|"f"
block|,
literal|"c "
block|,
comment|/* fortran     */
literal|"h"
block|,
literal|" * "
block|,
comment|/* C-header    */
literal|"l"
block|,
literal|" * "
block|,
comment|/* lex         NOTE: conflict between lex and franzlisp*/
literal|"mac"
block|,
literal|"; "
block|,
comment|/* macro       vms or dec-20 or pdp-11 macro */
literal|"me"
block|,
literal|".\\\" "
block|,
comment|/* me-macros   t/nroff*/
literal|"mm"
block|,
literal|".\\\" "
block|,
comment|/* mm-macros   t/nroff*/
literal|"ms"
block|,
literal|".\\\" "
block|,
comment|/* ms-macros   t/nroff*/
literal|"p"
block|,
literal|" * "
block|,
comment|/* pascal      */
literal|"pl"
block|,
literal|"% "
block|,
comment|/* prolog      */
literal|"r"
block|,
literal|"# "
block|,
comment|/* ratfor      */
literal|"red"
block|,
literal|"% "
block|,
comment|/* psl/rlisp   */
ifdef|#
directive|ifdef
name|sparc
literal|"s"
block|,
literal|"! "
block|,
comment|/* assembler   */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|mc68000
literal|"s"
block|,
literal|"| "
block|,
comment|/* assembler   */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|pdp11
literal|"s"
block|,
literal|"/ "
block|,
comment|/* assembler   */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|vax
literal|"s"
block|,
literal|"# "
block|,
comment|/* assembler   */
endif|#
directive|endif
literal|"sh"
block|,
literal|"# "
block|,
comment|/* shell       */
literal|"sl"
block|,
literal|"% "
block|,
comment|/* psl         */
literal|"red"
block|,
literal|"% "
block|,
comment|/* psl/rlisp   */
literal|"cl"
block|,
literal|";;; "
block|,
comment|/* common lisp   */
literal|"ml"
block|,
literal|"; "
block|,
comment|/* mocklisp    */
literal|"el"
block|,
literal|"; "
block|,
comment|/* gnulisp     */
literal|"tex"
block|,
literal|"% "
block|,
comment|/* tex	       */
literal|"y"
block|,
literal|" * "
block|,
comment|/* yacc        */
literal|"ye"
block|,
literal|" * "
block|,
comment|/* yacc-efl    */
literal|"yr"
block|,
literal|" * "
block|,
comment|/* yacc-ratfor */
literal|""
block|,
literal|"# "
block|,
comment|/* default for empty suffix */
name|nil
block|,
literal|""
comment|/* default for unknown suffix; must always be last */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|ffclose
argument_list|(
argument|fptr
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: checks ferror(fptr) and aborts the program if there were  * errors; otherwise closes fptr.  */
end_comment

begin_block
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fptr
argument_list|)
operator|||
name|fclose
argument_list|(
name|fptr
argument_list|)
operator|==
name|EOF
condition|)
name|faterror
argument_list|(
literal|"File read or write error; file system full?"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|trysema
parameter_list|(
name|RCSname
parameter_list|,
name|makesema
parameter_list|)
name|char
modifier|*
name|RCSname
decl_stmt|;
name|int
name|makesema
decl_stmt|;
comment|/* Function: Checks whether a semaphore file exists for RCSname. If yes,  * returns false. If not, creates one if makesema==true and returns true  * if successful. If a semaphore file was created, madesema is set to true.  * The name of the semaphore file is put into variable semafilename.  */
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|int
name|fdesc
decl_stmt|;
name|sp
operator|=
name|RCSname
expr_stmt|;
name|lp
operator|=
name|rindex
argument_list|(
name|sp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
block|{
name|semafilename
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|semafilename
index|[
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
name|tp
operator|=
operator|&
name|semafilename
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* copy path */
name|tp
operator|=
name|semafilename
expr_stmt|;
do|do
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
do|while
condition|(
name|sp
operator|<=
name|lp
condition|)
do|;
block|}
comment|/*now insert `,' and append file name */
operator|*
name|tp
operator|++
operator|=
literal|','
expr_stmt|;
name|lp
operator|=
name|rindex
argument_list|(
name|sp
argument_list|,
name|RCSSEP
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
operator|<
name|lp
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* will be the same length as RCSname*/
name|madesema
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|semafilename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"RCS file %s is in use"
argument_list|,
name|RCSname
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|makesema
condition|)
block|{
if|if
condition|(
operator|(
name|fdesc
operator|=
name|creat
argument_list|(
name|semafilename
argument_list|,
literal|000
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Can't create semaphore file for RCS file %s"
argument_list|,
name|RCSname
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
name|VOID
name|close
argument_list|(
name|fdesc
argument_list|)
decl_stmt|;
name|madesema
operator|=
name|true
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_macro
name|rmsema
argument_list|()
end_macro

begin_comment
comment|/* Function: delete the semaphore file if madeseam==true;  * sets madesema to false.  */
end_comment

begin_block
block|{
if|if
condition|(
name|madesema
condition|)
block|{
name|madesema
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|semafilename
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Can't find semaphore file %s"
argument_list|,
name|semafilename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|InitCleanup
argument_list|()
end_macro

begin_block
block|{
name|freefilename
operator|=
literal|0
expr_stmt|;
comment|/* initialize pointer */
block|}
end_block

begin_macro
name|cleanup
argument_list|()
end_macro

begin_comment
comment|/* Function: closes input file and rewrite file.  * Unlinks files in tfnames[], deletes semaphore file.  */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|finptr
operator|!=
name|NULL
condition|)
name|VOID
name|fclose
parameter_list|(
name|finptr
parameter_list|)
function_decl|;
if|if
condition|(
name|frewrite
operator|!=
name|NULL
condition|)
name|VOID
name|fclose
parameter_list|(
name|frewrite
parameter_list|)
function_decl|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|freefilename
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tfnames
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|VOID
name|unlink
parameter_list|(
name|tfnames
index|[
name|i
index|]
parameter_list|)
function_decl|;
block|}
name|InitCleanup
argument_list|()
expr_stmt|;
name|rmsema
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|mktempfile
parameter_list|(
name|fullpath
parameter_list|,
name|filename
parameter_list|)
specifier|register
name|char
modifier|*
name|fullpath
decl_stmt|,
decl|*
name|filename
decl_stmt|;
end_function

begin_comment
comment|/* Function: Creates a unique filename using the process id and stores it  * into a free slot in tfnames. The filename consists of the path contained  * in fullpath concatenated with filename. filename should end in "XXXXXX".  * Because of storage in tfnames, cleanup() can unlink the file later.  * freefilename indicates the lowest unoccupied slot in tfnames.  * Returns a pointer to the filename created.  * Example use: mktempfile("/tmp/", somefilename)  */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|lastslash
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|tfnames
index|[
name|freefilename
index|]
operator|)
operator|==
name|nil
condition|)
name|tp
operator|=
name|tfnames
index|[
name|freefilename
index|]
operator|=
name|talloc
argument_list|(
name|NCPPN
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullpath
operator|!=
name|nil
operator|&&
operator|(
name|lastslash
operator|=
name|rindex
argument_list|(
name|fullpath
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* copy path */
while|while
condition|(
name|fullpath
operator|<=
name|lastslash
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|fullpath
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|tp
operator|++
operator|=
operator|*
name|filename
operator|++
condition|)
empty_stmt|;
return|return
operator|(
name|mktemp
argument_list|(
name|tfnames
index|[
name|freefilename
operator|++
index|]
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|bindex
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
name|c
decl_stmt|;
comment|/* Function: Finds the last occurrence of character c in string sp  * and returns a pointer to the character just beyond it. If the  * character doesn't occur in the string, sp is returned.  */
block|{
specifier|register
name|char
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|sp
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|++
operator|==
name|c
condition|)
name|r
operator|=
name|sp
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_macro
name|InitAdmin
argument_list|()
end_macro

begin_comment
comment|/* function: initializes an admin node */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|Suffix
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|Head
operator|=
name|Dbranch
operator|=
name|nil
expr_stmt|;
name|AccessList
operator|=
name|nil
expr_stmt|;
name|Symbols
operator|=
name|nil
expr_stmt|;
name|Locks
operator|=
name|nil
expr_stmt|;
name|StrictLocks
operator|=
name|STRICT_LOCKING
expr_stmt|;
comment|/* guess the comment leader from the suffix*/
name|Suffix
operator|=
name|bindex
argument_list|(
name|workfilename
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|Suffix
operator|==
name|workfilename
condition|)
name|Suffix
operator|=
literal|""
expr_stmt|;
comment|/* empty suffix; will get default*/
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|comtable
index|[
name|i
index|]
operator|.
name|suffix
operator|==
name|nil
condition|)
block|{
name|Comment
operator|=
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
expr_stmt|;
comment|/*default*/
break|break;
block|}
name|elsif
argument_list|(
argument|strcmp(Suffix,comtable[i].suffix)==
literal|0
argument_list|)
block|{
name|Comment
operator|=
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
expr_stmt|;
comment|/*default*/
break|break;
block|}
block|}
name|Lexinit
argument_list|()
expr_stmt|;
comment|/* Note: if finptr==NULL, reads nothing; only initializes*/
block|}
end_block

begin_function
name|char
modifier|*
name|findpairfile
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|fname
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|,
decl|*
name|fname
decl_stmt|;
end_function

begin_comment
comment|/* Function: Given a filename fname, findpairfile scans argv for a pathname  * ending in fname. If found, returns a pointer to the pathname, and sets  * the corresponding pointer in argv to nil. Otherwise returns fname.  * argc indicates the number of entries in argv. Some of them may be nil.  */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|next
decl_stmt|,
modifier|*
name|match
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
for|for
control|(
name|next
operator|=
name|argv
operator|,
name|count
operator|=
name|argc
init|;
name|count
operator|>
literal|0
condition|;
name|next
operator|++
operator|,
name|count
operator|--
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|next
operator|!=
name|nil
operator|)
operator|&&
name|strcmp
argument_list|(
name|bindex
argument_list|(
operator|*
name|next
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|fname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* bindex finds the beginning of the file name stem */
name|match
operator|=
operator|*
name|next
expr_stmt|;
operator|*
name|next
operator|=
name|nil
expr_stmt|;
return|return
name|match
return|;
block|}
block|}
return|return
name|fname
return|;
block|}
end_block

begin_function
name|int
name|pairfilenames
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|mustread
parameter_list|,
name|tostdout
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|mustread
decl_stmt|,
name|tostdout
decl_stmt|;
comment|/* Function: Pairs the filenames pointed to by argv; argc indicates  * how many there are.  * Places a pointer to the RCS filename into RCSfilename,  * and a pointer to the name of the working file into workfilename.  * If both the workfilename and the RCS filename are given, and tostdout  * is true, a warning is printed.  *  * If the working file exists, places its status into workstat and  * sets haveworkstat to 0; otherwise, haveworkstat is set to -1;  * Similarly for the RCS file and the variables RCSstat and haveRCSstat.  *  * If the RCS file exists, it is opened for reading, the file pointer  * is placed into finptr, and the admin-node is read in; returns 1.  * If the RCS file does not exist and mustread==true, an error is printed  * and 0 returned.  * If the RCS file does not exist and mustread==false, the admin node  * is initialized to empty (Head, AccessList, Locks, Symbols, StrictLocks, Dbranch)  * and -1 returned.  *  * 0 is returned on all errors. Files that are directories are errors.  * Also calls InitCleanup();  */
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|lastsep
decl_stmt|,
modifier|*
name|purefname
decl_stmt|,
modifier|*
name|pureRCSname
decl_stmt|;
name|int
name|opened
decl_stmt|,
name|returncode
decl_stmt|;
name|char
modifier|*
name|RCS1
decl_stmt|;
name|char
name|prefdir
index|[
name|NCPPN
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|argv
operator|==
name|nil
condition|)
return|return
literal|0
return|;
comment|/* already paired filename */
if|if
condition|(
name|rindex
argument_list|(
operator|*
name|argv
argument_list|,
name|KDELIM
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* KDELIM causes havoc in keyword expansion    */
name|error
argument_list|(
literal|"RCS file name may not contain %c"
argument_list|,
name|KDELIM
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|InitCleanup
argument_list|()
expr_stmt|;
comment|/* first check suffix to see whether it is an RCS file or not */
name|purefname
operator|=
name|bindex
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* skip path */
name|lastsep
operator|=
name|rindex
argument_list|(
name|purefname
argument_list|,
name|RCSSEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastsep
operator|!=
literal|0
operator|&&
operator|*
operator|(
name|lastsep
operator|+
literal|1
operator|)
operator|==
name|RCSSUF
operator|&&
operator|*
operator|(
name|lastsep
operator|+
literal|2
operator|)
operator|==
literal|'\0'
condition|)
block|{
comment|/* RCS file name given*/
name|RCS1
operator|=
operator|(
operator|*
name|argv
operator|)
expr_stmt|;
name|pureRCSname
operator|=
name|purefname
expr_stmt|;
comment|/* derive workfilename*/
name|sp
operator|=
name|purefname
expr_stmt|;
name|tp
operator|=
name|tempfilename
expr_stmt|;
while|while
condition|(
name|sp
operator|<
name|lastsep
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
comment|/* try to find workfile name among arguments */
name|workfilename
operator|=
name|findpairfile
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|tempfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|pureRCSname
argument_list|)
operator|>
name|NCPFN
condition|)
block|{
name|error
argument_list|(
literal|"RCS file name %s too long"
argument_list|,
name|RCS1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* working file given; now try to find RCS file */
name|workfilename
operator|=
operator|*
name|argv
expr_stmt|;
comment|/* derive RCS file name*/
name|sp
operator|=
name|purefname
expr_stmt|;
name|tp
operator|=
name|tempfilename
expr_stmt|;
while|while
condition|(
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
condition|)
empty_stmt|;
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
operator|=
name|RCSSEP
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|RCSSUF
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Try to find RCS file name among arguments*/
name|RCS1
operator|=
name|findpairfile
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|tempfilename
argument_list|)
expr_stmt|;
name|pureRCSname
operator|=
name|bindex
argument_list|(
name|RCS1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|pureRCSname
argument_list|)
operator|>
name|NCPFN
condition|)
block|{
name|error
argument_list|(
literal|"working file name %s too long"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* now we have a (tentative) RCS filename in RCS1 and workfilename  */
comment|/* First, get status of workfilename */
name|haveworkstat
operator|=
name|stat
argument_list|(
name|workfilename
argument_list|,
operator|&
name|workstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|haveworkstat
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|workstat
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
operator|==
name|S_IFDIR
operator|)
condition|)
block|{
name|diagnose
argument_list|(
literal|"Directory %s ignored"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Second, try to find the right RCS file */
if|if
condition|(
name|pureRCSname
operator|!=
name|RCS1
condition|)
block|{
comment|/* a path for RCSfile is given; single RCS file to look for */
name|finptr
operator|=
name|fopen
argument_list|(
name|RCSfilename
operator|=
name|RCS1
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|finptr
operator|!=
name|NULL
condition|)
block|{
name|returncode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* could not open */
if|if
condition|(
name|access
argument_list|(
name|RCSfilename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't open existing %s"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mustread
condition|)
block|{
name|error
argument_list|(
literal|"Can't find %s"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* initialize if not mustread */
name|returncode
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* no path for RCS file name. Prefix it with path of work */
comment|/* file if RCS file omitted. Make a second name including */
comment|/* RCSDIR and try to open that one first.                 */
name|sub1filename
index|[
literal|0
index|]
operator|=
name|sub2filename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|RCS1
operator|==
name|tempfilename
condition|)
block|{
comment|/* RCS file name not given; prepend work path */
name|sp
operator|=
operator|*
name|argv
expr_stmt|;
name|tp
operator|=
name|sub1filename
expr_stmt|;
while|while
condition|(
name|sp
operator|<
name|purefname
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|sub2filename
argument_list|,
name|sub1filename
argument_list|)
decl_stmt|;
comment|/* second one */
block|}
name|VOID
name|strcat
argument_list|(
name|sub1filename
argument_list|,
name|RCSDIR
argument_list|)
decl_stmt|;
name|VOID
name|strcpy
argument_list|(
name|prefdir
argument_list|,
name|sub1filename
argument_list|)
decl_stmt|;
comment|/* preferred directory for RCS file*/
name|VOID
name|strcat
argument_list|(
name|sub1filename
argument_list|,
name|RCS1
argument_list|)
decl_stmt|;
name|VOID
name|strcat
argument_list|(
name|sub2filename
argument_list|,
name|RCS1
argument_list|)
decl_stmt|;
name|opened
operator|=
operator|(
operator|(
operator|(
name|finptr
operator|=
name|fopen
argument_list|(
name|RCSfilename
operator|=
name|sub1filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|finptr
operator|=
name|fopen
argument_list|(
name|RCSfilename
operator|=
name|sub2filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|opened
condition|)
block|{
comment|/* open succeeded */
name|returncode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* open failed; may be read protected */
if|if
condition|(
operator|(
name|access
argument_list|(
name|RCSfilename
operator|=
name|sub1filename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|access
argument_list|(
name|RCSfilename
operator|=
name|sub2filename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't open existing %s"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mustread
condition|)
block|{
name|error
argument_list|(
literal|"Can't find %s nor %s"
argument_list|,
name|sub1filename
argument_list|,
name|sub2filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* initialize new file. Put into ./RCS if possible, strip off suffix*/
name|RCSfilename
operator|=
operator|(
name|access
argument_list|(
name|prefdir
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|sub1filename
else|:
name|sub2filename
expr_stmt|;
name|returncode
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|returncode
operator|==
literal|1
condition|)
block|{
comment|/* RCS file open */
name|haveRCSstat
operator|=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|finptr
argument_list|)
argument_list|,
operator|&
name|RCSstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|haveRCSstat
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|RCSstat
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
operator|==
name|S_IFDIR
operator|)
condition|)
block|{
name|diagnose
argument_list|(
literal|"Directory %s ignored"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|Lexinit
argument_list|()
expr_stmt|;
name|getadmin
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* returncode == -1; RCS file nonexisting */
name|haveRCSstat
operator|=
operator|-
literal|1
expr_stmt|;
name|InitAdmin
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|tostdout
operator|&&
operator|!
operator|(
name|RCS1
operator|==
name|tempfilename
operator|||
name|workfilename
operator|==
name|tempfilename
operator|)
condition|)
comment|/*The last term determines whether a pair of        */
comment|/* file names was given in the argument list        */
name|warn
argument_list|(
literal|"Option -p is set; ignoring output file %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
return|return
name|returncode
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getfullRCSname
parameter_list|()
comment|/* Function: returns a pointer to the full path name of the RCS file.  * Calls getwd(), but only once.  * removes leading "../" and "./".  */
block|{
specifier|static
name|char
name|pathbuf
index|[
name|NCPPN
index|]
decl_stmt|;
specifier|static
name|char
name|namebuf
index|[
name|NCPPN
index|]
decl_stmt|;
specifier|static
name|int
name|pathlength
decl_stmt|;
specifier|register
name|char
modifier|*
name|realname
decl_stmt|,
modifier|*
name|lastpathchar
decl_stmt|;
specifier|register
name|int
name|dotdotcounter
decl_stmt|,
name|realpathlength
decl_stmt|;
if|if
condition|(
operator|*
name|RCSfilename
operator|==
literal|'/'
condition|)
block|{
return|return
operator|(
name|RCSfilename
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|pathlength
operator|==
literal|0
condition|)
block|{
comment|/*call curdir for the first time*/
if|if
condition|(
name|getwd
argument_list|(
name|pathbuf
argument_list|)
operator|==
name|NULL
condition|)
name|faterror
argument_list|(
literal|"Can't build current directory path"
argument_list|)
expr_stmt|;
name|pathlength
operator|=
name|strlen
argument_list|(
name|pathbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|pathlength
operator|==
literal|1
operator|)
operator|&&
operator|(
name|pathbuf
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|)
condition|)
block|{
name|pathbuf
index|[
name|pathlength
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
comment|/* Check needed because some getwd implementations */
comment|/* generate "/" for the root.                      */
block|}
block|}
comment|/*the following must be redone since RCSfilename may change*/
comment|/* find how many ../ to remvove from RCSfilename */
name|dotdotcounter
operator|=
literal|0
expr_stmt|;
name|realname
operator|=
name|RCSfilename
expr_stmt|;
while|while
condition|(
name|realname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|realname
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
operator|(
name|realname
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|realname
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|realname
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* drop leading ./ */
name|realname
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* drop leading ../ and remember */
name|dotdotcounter
operator|++
expr_stmt|;
name|realname
operator|+=
literal|3
expr_stmt|;
block|}
block|}
comment|/* now remove dotdotcounter trailing directories from pathbuf*/
name|lastpathchar
operator|=
name|pathbuf
operator|+
name|pathlength
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|dotdotcounter
operator|>
literal|0
operator|&&
name|lastpathchar
operator|>
name|pathbuf
condition|)
block|{
comment|/* move pointer backwards over trailing directory */
name|lastpathchar
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|lastpathchar
operator|==
literal|'/'
condition|)
block|{
name|dotdotcounter
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dotdotcounter
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't generate full path name for RCS file"
argument_list|)
expr_stmt|;
return|return
name|RCSfilename
return|;
block|}
else|else
block|{
comment|/* build full path name */
name|realpathlength
operator|=
name|lastpathchar
operator|-
name|pathbuf
operator|+
literal|1
expr_stmt|;
name|VOID
name|strncpy
argument_list|(
name|namebuf
argument_list|,
name|pathbuf
argument_list|,
name|realpathlength
argument_list|)
decl_stmt|;
name|VOID
name|strcpy
argument_list|(
operator|&
name|namebuf
index|[
name|realpathlength
index|]
argument_list|,
name|realname
argument_list|)
decl_stmt|;
return|return
operator|(
name|namebuf
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|trydiraccess
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* checks write permission in directory of filename and returns  * true if writable, false otherwise  */
block|{
name|char
name|pathname
index|[
name|NCPPN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
name|rindex
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
block|{
comment|/* check current directory */
if|if
condition|(
name|access
argument_list|(
literal|"."
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
else|else
block|{
name|error
argument_list|(
literal|"Current directory not writable"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* copy path */
name|sp
operator|=
name|filename
expr_stmt|;
name|tp
operator|=
name|pathname
expr_stmt|;
do|do
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
do|while
condition|(
name|sp
operator|<=
name|lp
condition|)
do|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|pathname
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
else|else
block|{
name|error
argument_list|(
literal|"Directory %s not writable"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|V4_2BSD
end_ifndef

begin_comment
comment|/* rename() and getwd() will be provided in bsd 4.2 */
end_comment

begin_function
name|int
name|rename
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_comment
comment|/* Function: renames a file with the name given by from to the name given by to.  * unlinks the to-file if it already exists. returns -1 on error, 0 otherwise.  */
end_comment

begin_block
block|{
name|VOID
name|unlink
parameter_list|(
name|to
parameter_list|)
function_decl|;
comment|/* no need to check return code; will be caught by link*/
comment|/* no harm done if file "to" does not exist            */
if|if
condition|(
name|link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|unlink
argument_list|(
name|from
argument_list|)
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|dot
value|"."
end_define

begin_define
define|#
directive|define
name|dotdot
value|".."
end_define

begin_function
name|char
modifier|*
name|getwd
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Function: places full pathname of current working directory into name and  * returns name on success, NULL on failure.  * getwd is an adaptation of pwd. May not return to the current directory on  * failure.  */
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|struct
name|stat
name|d
decl_stmt|,
name|dd
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* to NUL-terminate dir.d_name */
name|struct
name|direct
name|dir
decl_stmt|;
name|int
name|rdev
decl_stmt|,
name|rino
decl_stmt|;
name|int
name|off
decl_stmt|;
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|name
index|[
name|off
operator|=
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"/"
argument_list|,
operator|&
name|d
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|rdev
operator|=
name|d
operator|.
name|st_dev
expr_stmt|;
name|rino
operator|=
name|d
operator|.
name|st_ino
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|dot
argument_list|,
operator|&
name|d
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|d
operator|.
name|st_ino
operator|==
name|rino
operator|&&
name|d
operator|.
name|st_dev
operator|==
name|rdev
condition|)
block|{
if|if
condition|(
name|name
index|[
name|off
index|]
operator|==
literal|'/'
condition|)
name|name
index|[
name|off
index|]
operator|=
literal|'\0'
expr_stmt|;
name|chdir
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/*change back to current directory*/
return|return
name|name
return|;
block|}
if|if
condition|(
operator|(
name|file
operator|=
name|fopen
argument_list|(
name|dotdot
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|file
argument_list|)
argument_list|,
operator|&
name|dd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|chdir
argument_list|(
name|dotdot
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|st_dev
operator|==
name|dd
operator|.
name|st_dev
condition|)
block|{
if|if
condition|(
name|d
operator|.
name|st_ino
operator|==
name|dd
operator|.
name|st_ino
condition|)
block|{
if|if
condition|(
name|name
index|[
name|off
index|]
operator|==
literal|'/'
condition|)
name|name
index|[
name|off
index|]
operator|=
literal|'\0'
expr_stmt|;
name|chdir
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/*change back to current directory*/
name|VOID
name|fclose
argument_list|(
name|file
argument_list|)
decl_stmt|;
return|return
name|name
return|;
block|}
do|do
block|{
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dir
argument_list|,
sizeof|sizeof
argument_list|(
name|dir
argument_list|)
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|fail
goto|;
block|}
do|while
condition|(
name|dir
operator|.
name|d_ino
operator|!=
name|d
operator|.
name|st_ino
condition|)
do|;
block|}
else|else
do|do
block|{
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dir
argument_list|,
sizeof|sizeof
argument_list|(
name|dir
argument_list|)
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|dir
operator|.
name|d_ino
operator|==
literal|0
condition|)
name|dd
operator|.
name|st_ino
operator|=
name|d
operator|.
name|st_ino
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|dir
operator|.
name|d_name
argument_list|,
operator|&
name|dd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
do|while
condition|(
name|dd
operator|.
name|st_ino
operator|!=
name|d
operator|.
name|st_ino
operator|||
name|dd
operator|.
name|st_dev
operator|!=
name|d
operator|.
name|st_dev
condition|)
do|;
name|VOID
name|fclose
argument_list|(
name|file
argument_list|)
decl_stmt|;
comment|/* concatenate file name */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|dir
operator|.
name|d_name
index|[
operator|++
name|i
index|]
operator|!=
literal|0
condition|)
empty_stmt|;
for|for
control|(
name|j
operator|=
name|off
operator|+
literal|1
init|;
name|j
operator|>
literal|0
condition|;
operator|--
name|j
control|)
name|name
index|[
name|j
operator|+
name|i
operator|+
literal|1
index|]
operator|=
name|name
index|[
name|j
index|]
expr_stmt|;
name|off
operator|=
name|i
operator|+
name|off
operator|+
literal|1
expr_stmt|;
name|name
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
for|for
control|(
operator|--
name|i
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|name
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|dir
operator|.
name|d_name
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* end for */
name|fail
label|:
name|VOID
name|fclose
argument_list|(
name|file
argument_list|)
decl_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PAIRTEST
end_ifdef

begin_comment
comment|/* test program for pairfilenames() and getfullRCSname() */
end_comment

begin_decl_stmt
name|char
modifier|*
name|workfilename
decl_stmt|,
modifier|*
name|RCSfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|quietflag
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|int
name|initflag
decl_stmt|,
name|tostdout
decl_stmt|;
name|quietflag
operator|=
name|tostdout
operator|=
name|initflag
operator|=
name|false
expr_stmt|;
name|cmdid
operator|=
literal|"pair"
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|,
operator|++
name|argv
operator|,
name|argc
operator|>=
literal|1
operator|&&
operator|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'p'
case|:
name|tostdout
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|initflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"unknown option: %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|do
block|{
name|RCSfilename
operator|=
name|workfilename
operator|=
name|nil
expr_stmt|;
name|result
operator|=
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|!
name|initflag
argument_list|,
name|tostdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|diagnose
argument_list|(
literal|"RCSfile: %s; working file: %s"
argument_list|,
name|RCSfilename
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
name|diagnose
argument_list|(
literal|"Full RCS file name: %s"
argument_list|,
name|getfullRCSname
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|result
condition|)
block|{
case|case
literal|0
case|:
continue|continue;
comment|/* already paired file */
case|case
literal|1
case|:
if|if
condition|(
name|initflag
condition|)
block|{
name|error
argument_list|(
literal|"RCS file %s exists already"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|diagnose
argument_list|(
literal|"RCS file %s exists"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
block|}
name|VOID
name|fclose
argument_list|(
name|finptr
argument_list|)
decl_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|diagnose
argument_list|(
literal|"RCS file does not exist"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|++
name|argv
operator|,
operator|--
name|argc
operator|>=
literal|1
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

