begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)tset.c	5.13 (Berkeley) 6/1/90"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* **  TSET -- set terminal modes ** **	This program does sophisticated terminal initialization. **	I recommend that you include it in your .profile or .login **	file to initialize whatever terminal you are on. ** **	There are several features: ** **	A special file or sequence (as controlled by the termcap file) **	is sent to the terminal. ** **	Mode bits are set on a per-terminal_type basis. **	This allows special delays, automatic tabs, etc. ** **	Erase and Kill characters can be set to whatever you want. **	Default is to change erase to control-H on a terminal which **	can overstrike, and leave it alone on anything else.  Kill **	is always left alone unless specifically requested.  These **	characters can be represented as "^X" meaning control-X; **	X is any character. ** **	Terminals which are dialups or plugboard types can be aliased **	to whatever type you may have in your home or office.  Thus, **	if you know that when you dial up you will always be on a **	TI 733, you can specify that fact to tset.  You can represent **	a type as "?type".  This will ask you what type you want it **	to be -- if you reply with just a newline, it will default **	to the type given. ** **	The current terminal type can be queried. ** **	Usage: **		tset [-] [-hnrsIQS] [-eC] [-iC] [-kC] [-EC] **		[-m [port-type][test baudrate]:terminal-type] [terminal-type] ** **		In systems with environments, use: **			eval `tset -s ...` **		Actually, this doesn't work in old csh's. **		Instead, use: **			tset -s ...> tset.tmp **			source tset.tmp **			rm tset.tmp **		or: **			set noglob **			set term=(`tset -S ....`) **			setenv TERM $term[1] **			setenv TERMCAP "$term[2]" **			unset term **			unset noglob ** **	Positional Parameters: **		type -- the terminal type to force.  If this is **			specified, initialization is for this **			terminal type. ** **	Flags: **		- -- report terminal type.  Whatever type is **			decided on is reported.  If no other flags **			are stated, the only affect is to write **			the terminal type on the standard output. **		-r -- report to user in addition to other flags. **		-EC -- set the erase character to C on all terminals **			except those which cannot backspace (e.g., **			a TTY 33). **		-eC -- set the erase character to C on all terminals. **			If not specified, **			the erase character is untouched; however, if **			not specified and the erase character is NULL **			(zero byte), the erase character  is set to delete. **		-kC -- set the kill character to C on all terminals. **			If not specified, **			the kill character is untouched; however, if **			not specified and the kill character is NULL **			(zero byte), the kill character is set to control-U. **		-iC -- set the interrupt character to C on all terminals. **			If not specified, the **			interrupt character is untouched; however, if **			not specified and the interrupt character is NULL **			(zero byte), the interrupt character is set to **			control-C. **		-qC -- reserved for settable quit character. **		-m -- map the system identified type to some user **			specified type. The mapping can be baud rate **			dependent. This replaces the old -d, -p flags. **			(-d type  ->  -m dialup:type) **			(-p type  ->  -m plug:type) **			Syntax:	-m identifier [test baudrate] :type **			where: ``identifier'' is terminal type found in **			/etc/ttys for this port, (absence of an identifier **			matches any identifier); ``test'' may be any **			combination of>  =<  !  @; ``baudrate'' is as with **			stty (1); ``type'' is the actual terminal type to use **			if the mapping condition is met. Multiple maps are **			scanned in order and the first match prevails. **		-h -- don't read terminal type from environment. **		-s -- output setenv commands for TERM.  This can be **			used with **				`tset -s ...` **			and is to be prefered to: **				setenv TERM `tset - ...` **			because -s sets the TERMCAP variable also. **		-S -- Similar to -s but outputs 2 strings suitable for **			use in csh .login files as follows: **				set noglob **				set term=(`tset -S .....`) **				setenv TERM $term[1] **				setenv TERMCAP "$term[2]" **				unset term **				unset noglob **		-Q -- be quiet.  don't output 'Erase set to' etc. **		-I -- don't do terminal initialization (is& if **			strings). ** **	Files: **		/etc/ttys **			contains a terminal id -> terminal type **			mapping; used when any user mapping is specified, **			or the environment doesn't have TERM set. **		/etc/termcap **			a terminal_type -> terminal_capabilities **			mapping. ** **	Exit Codes: **		2 -- couldn't open termcap. **		1 -- invalid terminal type, or standard error not tty. **		0 -- ok. ** **	Author: **		Eric Allman **		Electronics Research Labs **		U.C. Berkeley ** **	History: **		1/81 -- Added alias checking for mapping identifiers. **		9/80 -- Added UCB_NTTY mods to setup the new tty driver. **			Added the 'reset ...' invocation. **		7/80 -- '-S' added. '-m' mapping added. TERMCAP string **			cleaned up. **		3/80 -- Changed to use tputs.  Prc& flush added. **		10/79 -- '-s' option extended to handle TERMCAP **			variable, set noglob, quote the entry, **			and know about the Bourne shell.  Terminal **			initialization moved to before any information **			output so screen clears would not screw you. **			'-Q' option added. **		8/79 -- '-' option alone changed to only output **			type.  '-s' option added.  'VERSION7' **			changed to 'V6' for compatibility. **		12/78 -- modified for eventual migration to VAX/UNIX, **			so the '-' option is changed to output only **			the terminal type to STDOUT instead of **			FILEDES. **		9/78 -- '-' and '-p' options added (now fully **			compatible with ttytype!), and spaces are **			permitted between the -d and the type. **		8/78 -- The sense of -h and -u were reversed, and the **			-f flag is dropped -- same effect is available **			by just stating the terminal type. **		10/77 -- Written. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ttyent.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* Default values for control characters. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CEOF
end_ifndef

begin_define
define|#
directive|define
name|_CTRL
parameter_list|(
name|c
parameter_list|)
value|((c)& 0x1f)
end_define

begin_define
define|#
directive|define
name|CEOF
value|_CTRL('d')
end_define

begin_define
define|#
directive|define
name|CERASE
value|0177
end_define

begin_comment
comment|/* DEL, ^? */
end_comment

begin_define
define|#
directive|define
name|CINTR
value|_CTRL('c')
end_define

begin_define
define|#
directive|define
name|CFLUSH
value|_CTRL('o')
end_define

begin_define
define|#
directive|define
name|CKILL
value|_CTRL('u')
end_define

begin_define
define|#
directive|define
name|CLNEXT
value|_CTRL('v')
end_define

begin_define
define|#
directive|define
name|CQUIT
value|034
end_define

begin_comment
comment|/* FS, ^\ */
end_comment

begin_define
define|#
directive|define
name|CRPRNT
value|_CTRL('r')
end_define

begin_define
define|#
directive|define
name|CSTART
value|_CTRL('q')
end_define

begin_define
define|#
directive|define
name|CSTOP
value|_CTRL('s')
end_define

begin_define
define|#
directive|define
name|CSUSP
value|_CTRL('z')
end_define

begin_define
define|#
directive|define
name|CWERASE
value|_CTRL('w')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This should be in<termcap.h> instead. */
end_comment

begin_function_decl
name|int
name|tgetent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tgetnum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tgetflag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tputs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This should be in<getopt.h> instead. */
end_comment

begin_function_decl
name|int
name|getopt
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|mapped
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|putbuf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|stypeof
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|baudrate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cancelled
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|isalias
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|prc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|settabs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_mapping
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_control_chars
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|get_termcap_entry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|get_tty_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|makealias
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_initializations
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|reportek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|reset_mode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_conversions
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|setdelay
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_mode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|wrtermcap
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|curerase
value|mode.c_cc[VERASE]
end_define

begin_define
define|#
directive|define
name|curkill
value|mode.c_cc[VKILL]
end_define

begin_define
define|#
directive|define
name|curintr
value|mode.c_cc[VINTR]
end_define

begin_define
define|#
directive|define
name|olderase
value|oldmode.c_cc[VERASE]
end_define

begin_define
define|#
directive|define
name|oldkill
value|oldmode.c_cc[VKILL]
end_define

begin_define
define|#
directive|define
name|oldintr
value|oldmode.c_cc[VINTR]
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_define
define|#
directive|define
name|CNTL
parameter_list|(
name|c
parameter_list|)
value|((c)&037)
end_define

begin_define
define|#
directive|define
name|BACKSPACE
value|(CNTL('H'))
end_define

begin_define
define|#
directive|define
name|CHK
parameter_list|(
name|val
parameter_list|,
name|dft
parameter_list|)
value|(val<=0 ? dft : val)
end_define

begin_define
define|#
directive|define
name|FILEDES
value|2
end_define

begin_comment
comment|/* change attrs on this descriptor */
end_comment

begin_define
define|#
directive|define
name|STDOUT
value|1
end_define

begin_comment
comment|/* output -s/-S to this descriptor */
end_comment

begin_comment
comment|/* Last resort default term type. */
end_comment

begin_define
define|#
directive|define
name|DEFTYPE
value|"unknown"
end_define

begin_comment
comment|/* Baud rate conditionals for mapping. */
end_comment

begin_define
define|#
directive|define
name|ANY
value|0
end_define

begin_define
define|#
directive|define
name|GT
value|1
end_define

begin_define
define|#
directive|define
name|EQ
value|2
end_define

begin_define
define|#
directive|define
name|LT
value|4
end_define

begin_define
define|#
directive|define
name|GE
value|(GT|EQ)
end_define

begin_define
define|#
directive|define
name|LE
value|(LT|EQ)
end_define

begin_define
define|#
directive|define
name|NE
value|(GT|LT)
end_define

begin_define
define|#
directive|define
name|ALL
value|(GT|EQ|LT)
end_define

begin_comment
comment|/* Maximum number of mappings allowed. */
end_comment

begin_define
define|#
directive|define
name|NMAP
value|10
end_define

begin_struct
struct|struct
name|map
block|{
name|char
modifier|*
name|Ident
decl_stmt|;
comment|/* Port type, or "" for any. */
name|char
name|Test
decl_stmt|;
comment|/* Baud rate conditionals bitmask. */
name|char
name|Speed
decl_stmt|;
comment|/* Baud rate to compare against. */
name|char
modifier|*
name|Type
decl_stmt|;
comment|/* Terminal type to select. */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|map
name|map
index|[
name|NMAP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next available element of `map'. */
end_comment

begin_decl_stmt
name|struct
name|map
modifier|*
name|Map
init|=
name|map
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|char
modifier|*
name|string
decl_stmt|;
comment|/* ASCII representation. */
name|int
name|speed
decl_stmt|;
comment|/* Internal form. */
name|int
name|baudrate
decl_stmt|;
comment|/* Numeric value. */
block|}
name|speeds
index|[]
init|=
block|{
literal|"0"
block|,
name|B0
block|,
literal|0
block|,
literal|"50"
block|,
name|B50
block|,
literal|50
block|,
literal|"75"
block|,
name|B75
block|,
literal|75
block|,
literal|"110"
block|,
name|B110
block|,
literal|110
block|,
literal|"134"
block|,
name|B134
block|,
literal|134
block|,
literal|"134.5"
block|,
name|B134
block|,
literal|134
block|,
literal|"150"
block|,
name|B150
block|,
literal|150
block|,
literal|"200"
block|,
name|B200
block|,
literal|200
block|,
literal|"300"
block|,
name|B300
block|,
literal|300
block|,
literal|"600"
block|,
name|B600
block|,
literal|600
block|,
literal|"1200"
block|,
name|B1200
block|,
literal|1200
block|,
literal|"1800"
block|,
name|B1800
block|,
literal|1800
block|,
literal|"2400"
block|,
name|B2400
block|,
literal|2400
block|,
literal|"4800"
block|,
name|B4800
block|,
literal|4800
block|,
literal|"9600"
block|,
name|B9600
block|,
literal|9600
block|,
literal|"19200"
block|,
name|B19200
block|,
literal|19200
block|,
literal|"38400"
block|,
name|B38400
block|,
literal|38400
block|,
literal|"exta"
block|,
name|B19200
block|,
literal|19200
block|,
literal|"extb"
block|,
name|B38400
block|,
literal|38400
block|,
name|NULL
block|}
struct|;
end_struct

begin_decl_stmt
name|char
name|Erase_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new erase character */
end_comment

begin_decl_stmt
name|char
name|Kill_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new kill character */
end_comment

begin_decl_stmt
name|char
name|Intr_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new interrupt character */
end_comment

begin_decl_stmt
name|char
name|Specialerase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set => Erase_char only on terminals with backspace (-E) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TtyPath
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal device */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TtyType
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of terminal */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DefType
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default type if none other computed */
end_comment

begin_decl_stmt
name|int
name|Mapped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mapping has been specified */
end_comment

begin_decl_stmt
name|int
name|NoTermFromEnv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't get terminal type from environ (-h) */
end_comment

begin_decl_stmt
name|int
name|DoSetenv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output TERMCAP strings (-s, -S) */
end_comment

begin_decl_stmt
name|int
name|CmndLine
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output setenv command lines (-s) */
end_comment

begin_decl_stmt
name|int
name|BeQuiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't say ctrl key settings (-Q, reset) */
end_comment

begin_decl_stmt
name|int
name|NoInit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't output initialization string (-I) */
end_comment

begin_decl_stmt
name|int
name|IsReset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* invoked as reset */
end_comment

begin_decl_stmt
name|int
name|Report
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report term type on stdout (-) */
end_comment

begin_decl_stmt
name|int
name|Ureport
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report term type to user on stderr (-r) */
end_comment

begin_decl_stmt
name|int
name|RepOnly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* only report term type (-& no other args) */
end_comment

begin_decl_stmt
name|int
name|Ask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ask user for termtype */
end_comment

begin_decl_stmt
name|int
name|PadBaud
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Min rate of padding needed, -1 if none */
end_comment

begin_decl_stmt
name|int
name|lines
decl_stmt|,
name|columns
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CAPBUFSIZ
value|1024
end_define

begin_decl_stmt
name|char
name|Capbuf
index|[
name|CAPBUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line from /etc/termcap for this TtyType */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Ttycap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* termcap line from termcap or environ */
end_comment

begin_decl_stmt
name|char
name|Aliasbuf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Null-terminated array of alternative names for the terminal.    The first element is the terminal's two-letter V6 short name.    The elements are pointers into 'Aliasbuf'. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Alias
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|termios
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|termios
name|oldmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|command
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|optc
decl_stmt|;
name|int
name|csh
init|=
name|NO
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|win
decl_stmt|;
endif|#
directive|endif
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|FILEDES
argument_list|,
operator|&
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: standard error must be a terminal\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|oldmode
operator|=
name|mode
expr_stmt|;
name|ospeed
operator|=
name|cfgetospeed
argument_list|(
operator|&
name|mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|set_mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|set_mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|set_mode
argument_list|)
expr_stmt|;
name|command
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
condition|)
name|command
operator|++
expr_stmt|;
else|else
name|command
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"reset"
argument_list|)
condition|)
block|{
name|reset_mode
argument_list|()
expr_stmt|;
name|BeQuiet
operator|=
name|YES
expr_stmt|;
name|IsReset
operator|=
name|YES
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"e:hi:k:m:nrsE:IQS"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'n'
case|:
comment|/* obsolete -- ignore */
break|break;
case|case
literal|'r'
case|:
comment|/* report to user */
name|Ureport
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* special erase: operate on all but TTY33 */
name|Specialerase
operator|=
name|YES
expr_stmt|;
comment|/* explicit fall-through to -e case */
case|case
literal|'e'
case|:
comment|/* erase character */
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'^'
operator|&&
name|optarg
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|optarg
index|[
literal|1
index|]
operator|==
literal|'?'
condition|)
name|Erase_char
operator|=
literal|'\177'
expr_stmt|;
else|else
name|Erase_char
operator|=
name|CNTL
argument_list|(
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|Erase_char
operator|=
name|optarg
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* interrupt character */
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'^'
operator|&&
name|optarg
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|optarg
index|[
literal|1
index|]
operator|==
literal|'?'
condition|)
name|Intr_char
operator|=
literal|'\177'
expr_stmt|;
else|else
name|Intr_char
operator|=
name|CNTL
argument_list|(
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|Intr_char
operator|=
name|optarg
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* kill character */
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'^'
operator|&&
name|optarg
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|optarg
index|[
literal|1
index|]
operator|==
literal|'?'
condition|)
name|Kill_char
operator|=
literal|'\177'
expr_stmt|;
else|else
name|Kill_char
operator|=
name|CNTL
argument_list|(
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|Kill_char
operator|=
name|optarg
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* map identifier to type */
name|add_mapping
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* don't get type from env */
name|NoTermFromEnv
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* output setenv commands */
name|DoSetenv
operator|=
name|YES
expr_stmt|;
name|CmndLine
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* output setenv strings */
name|DoSetenv
operator|=
name|YES
expr_stmt|;
name|CmndLine
operator|=
name|NO
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
comment|/* be quiet */
name|BeQuiet
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* no initialization */
name|NoInit
operator|=
name|YES
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|Report
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
name|RepOnly
operator|=
name|YES
expr_stmt|;
operator|++
name|optind
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
comment|/* Terminal type. */
name|DefType
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
operator|++
name|optind
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: extra arguments\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|get_tty_type
argument_list|()
expr_stmt|;
name|get_termcap_entry
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|RepOnly
condition|)
block|{
name|set_control_chars
argument_list|()
expr_stmt|;
name|set_conversions
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|columns
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
name|lines
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
comment|/* Set window size */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|.
name|ws_row
operator|==
literal|0
operator|&&
name|win
operator|.
name|ws_col
operator|==
literal|0
operator|&&
name|lines
operator|>
literal|0
operator|&&
name|columns
operator|>
literal|0
condition|)
block|{
name|win
operator|.
name|ws_row
operator|=
name|lines
expr_stmt|;
name|win
operator|.
name|ws_col
operator|=
name|columns
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|win
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|NoInit
condition|)
name|output_initializations
argument_list|()
expr_stmt|;
name|set_mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* set new modes, if they've changed */
comment|/* set up environment for the shell we are using 		   (this code is rather heuristic, checking for $SHELL 		   ending in the 3 characters "csh") */
if|if
condition|(
name|DoSetenv
condition|)
block|{
name|char
modifier|*
name|sh
decl_stmt|;
name|sh
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|3
condition|)
block|{
name|csh
operator|=
operator|!
name|strcmp
argument_list|(
operator|&
name|sh
index|[
name|i
operator|-
literal|3
index|]
argument_list|,
literal|"csh"
argument_list|)
expr_stmt|;
if|if
condition|(
name|csh
operator|&&
name|CmndLine
condition|)
name|puts
argument_list|(
literal|"set noglob;"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|csh
condition|)
comment|/* running Bourne shell */
name|puts
argument_list|(
literal|"export TERMCAP TERM;"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* report type if appropriate */
if|if
condition|(
name|DoSetenv
operator|||
name|Report
operator|||
name|Ureport
condition|)
block|{
comment|/* If 'TtyType' is the short name, use the first alias 		   (if any) instead. */
name|makealias
argument_list|(
name|Ttycap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TtyType
argument_list|,
name|Alias
index|[
literal|0
index|]
argument_list|)
operator|&&
name|Alias
index|[
literal|1
index|]
condition|)
name|TtyType
operator|=
name|Alias
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|DoSetenv
condition|)
block|{
if|if
condition|(
name|csh
condition|)
block|{
if|if
condition|(
name|CmndLine
condition|)
name|fputs
argument_list|(
literal|"setenv TERM "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|TtyType
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|CmndLine
condition|)
name|puts
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"TERM="
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|TtyType
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Report
condition|)
block|{
name|puts
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ureport
condition|)
block|{
name|prs
argument_list|(
literal|"Terminal type is "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|DoSetenv
condition|)
block|{
if|if
condition|(
name|csh
condition|)
block|{
if|if
condition|(
name|CmndLine
condition|)
name|fputs
argument_list|(
literal|"setenv TERMCAP '"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
literal|"TERMCAP='"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|wrtermcap
argument_list|(
name|Ttycap
argument_list|)
expr_stmt|;
if|if
condition|(
name|csh
condition|)
block|{
if|if
condition|(
name|CmndLine
condition|)
block|{
name|puts
argument_list|(
literal|"';\nunset noglob;"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|puts
argument_list|(
literal|"';"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|RepOnly
operator|&&
operator|!
name|BeQuiet
condition|)
block|{
comment|/* tell about changing erase, kill and interrupt characters */
name|reportek
argument_list|(
literal|"Erase"
argument_list|,
name|curerase
argument_list|,
name|olderase
argument_list|,
name|CERASE
argument_list|)
expr_stmt|;
name|reportek
argument_list|(
literal|"Kill"
argument_list|,
name|curkill
argument_list|,
name|oldkill
argument_list|,
name|CKILL
argument_list|)
expr_stmt|;
name|reportek
argument_list|(
literal|"Interrupt"
argument_list|,
name|curintr
argument_list|,
name|oldintr
argument_list|,
name|CINTR
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Syntax for P: [port-type][test baudrate]:terminal-type    The baud rate tests are:>< @/= !     The baudrate number can be preceded by a 'B', which is ignored.    The baudrate number can also be `exta' or `extb'.    This code is very loose. Almost no syntax checking is done!    However, invalid syntax will only produce weird results. */
end_comment

begin_function
name|void
name|add_mapping
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|Break
init|=
name|NO
decl_stmt|;
name|int
name|Not
init|=
name|NO
decl_stmt|;
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|Map
operator|->
name|Ident
operator|=
name|p
expr_stmt|;
comment|/* Port-type identifier. */
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
else|else
name|Map
operator|->
name|Ident
operator|=
literal|""
expr_stmt|;
comment|/* Scan for optional test and baudrate. */
while|while
condition|(
name|Break
operator|==
name|NO
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\0'
case|:
name|Break
operator|=
name|YES
expr_stmt|;
continue|continue;
case|case
literal|':'
case|:
comment|/* Mapped type. */
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|Break
operator|=
name|YES
expr_stmt|;
continue|continue;
case|case
literal|'>'
case|:
comment|/* Conditional. */
name|Map
operator|->
name|Test
operator||=
name|GT
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
case|case
literal|'<'
case|:
comment|/* Conditional. */
name|Map
operator|->
name|Test
operator||=
name|LT
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
case|case
literal|'='
case|:
comment|/* Conditional. */
case|case
literal|'@'
case|:
name|Map
operator|->
name|Test
operator||=
name|EQ
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
case|case
literal|'!'
case|:
comment|/* Invert conditions. */
name|Not
operator|=
operator|~
name|Not
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
case|case
literal|'B'
case|:
comment|/* Baud rate */
name|p
operator|++
expr_stmt|;
comment|/* Intentional fallthru. */
default|default:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'e'
condition|)
block|{
name|Map
operator|->
name|Speed
operator|=
name|baudrate
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'.'
condition|)
name|p
operator|++
expr_stmt|;
block|}
else|else
name|Break
operator|=
name|YES
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|Not
condition|)
comment|/* Invert sense of test. */
name|Map
operator|->
name|Test
operator|=
operator|(
operator|~
operator|(
name|Map
operator|->
name|Test
operator|)
operator|)
operator|&
name|ALL
expr_stmt|;
name|Map
operator|->
name|Type
operator|=
name|p
expr_stmt|;
name|Map
operator|++
expr_stmt|;
name|Mapped
operator|=
name|YES
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the terminal mode bits to a sensible state.    Very useful after crapping out in raw mode. */
end_comment

begin_function
name|void
name|reset_mode
parameter_list|()
block|{
name|tcgetattr
argument_list|(
name|FILEDES
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
name|curintr
operator|=
name|CHK
argument_list|(
name|curintr
argument_list|,
name|CINTR
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VQUIT
index|]
argument_list|,
name|CQUIT
argument_list|)
expr_stmt|;
name|curerase
operator|=
name|CHK
argument_list|(
name|curerase
argument_list|,
name|CERASE
argument_list|)
expr_stmt|;
name|curkill
operator|=
name|CHK
argument_list|(
name|curkill
argument_list|,
name|CKILL
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_cc
index|[
name|VEOF
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VEOF
index|]
argument_list|,
name|CEOF
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_cc
index|[
name|VSTART
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VSTART
index|]
argument_list|,
name|CSTART
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_cc
index|[
name|VSTOP
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VSTOP
index|]
argument_list|,
name|CSTOP
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_cc
index|[
name|VSUSP
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VSUSP
index|]
argument_list|,
name|CSUSP
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VREPRINT
argument_list|)
operator|&&
name|defined
argument_list|(
name|CRPRNT
argument_list|)
name|mode
operator|.
name|c_cc
index|[
name|VREPRINT
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VREPRINT
index|]
argument_list|,
name|CRPRNT
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|VWERASE
argument_list|)
operator|&&
name|defined
argument_list|(
name|CWERASE
argument_list|)
name|mode
operator|.
name|c_cc
index|[
name|VWERASE
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VWERASE
index|]
argument_list|,
name|CWERASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|VLNEXT
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLNEXT
argument_list|)
name|mode
operator|.
name|c_cc
index|[
name|VLNEXT
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VLNEXT
index|]
argument_list|,
name|CLNEXT
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|VFLUSH
argument_list|)
operator|&&
name|defined
argument_list|(
name|CFLUSH
argument_list|)
name|mode
operator|.
name|c_cc
index|[
name|VFLUSH
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VFLUSH
index|]
argument_list|,
name|CFLUSH
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|VDISCARD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CDISCARD
argument_list|)
name|mode
operator|.
name|c_cc
index|[
name|VDISCARD
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VDISCARD
index|]
argument_list|,
name|CDISCARD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mode
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IGNBRK
operator||
name|PARMRK
operator||
name|INPCK
operator||
name|ISTRIP
operator||
name|INLCR
operator||
name|IGNCR
ifdef|#
directive|ifdef
name|IUCLC
operator||
name|IUCLC
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IXANY
operator||
name|IXANY
endif|#
directive|endif
operator||
name|IXOFF
operator|)
expr_stmt|;
name|mode
operator|.
name|c_iflag
operator||=
operator|(
name|BRKINT
operator||
name|IGNPAR
operator||
name|ICRNL
operator||
name|IXON
ifdef|#
directive|ifdef
name|IMAXBEL
operator||
name|IMAXBEL
endif|#
directive|endif
operator|)
expr_stmt|;
name|mode
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
literal|0
ifdef|#
directive|ifdef
name|OLCUC
operator||
name|OLCUC
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OCRNL
operator||
name|OCRNL
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ONOCR
operator||
name|ONOCR
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ONLRET
operator||
name|ONLRET
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OFILL
operator||
name|OFILL
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OFDEL
operator||
name|OFDEL
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NLDLY
operator||
name|NLDLY
operator||
name|CRDLY
operator||
name|TABDLY
operator||
name|BSDLY
operator||
name|VTDLY
operator||
name|FFDLY
endif|#
directive|endif
operator|)
expr_stmt|;
name|mode
operator|.
name|c_oflag
operator||=
operator|(
name|OPOST
ifdef|#
directive|ifdef
name|ONLCR
operator||
name|ONLCR
endif|#
directive|endif
operator|)
expr_stmt|;
name|mode
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|CSTOPB
operator||
name|PARENB
operator||
name|PARODD
operator||
name|CLOCAL
operator|)
expr_stmt|;
name|mode
operator|.
name|c_cflag
operator||=
operator|(
name|CS8
operator||
name|CREAD
operator|)
expr_stmt|;
name|mode
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ECHONL
operator||
name|NOFLSH
operator||
name|TOSTOP
ifdef|#
directive|ifdef
name|ECHOPTR
operator||
name|ECHOPRT
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCASE
operator||
name|XCASE
endif|#
directive|endif
operator|)
expr_stmt|;
name|mode
operator|.
name|c_lflag
operator||=
operator|(
name|ISIG
operator||
name|ICANON
operator||
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
ifdef|#
directive|ifdef
name|ECHOCTL
operator||
name|ECHOCTL
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ECHOKE
operator||
name|ECHOKE
endif|#
directive|endif
operator|)
expr_stmt|;
name|tcsetattr
argument_list|(
name|FILEDES
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the terminal type and place it in 'TtyType'. */
end_comment

begin_function
name|void
name|get_tty_type
parameter_list|()
block|{
name|char
modifier|*
name|bufp
decl_stmt|;
if|if
condition|(
name|DefType
condition|)
block|{
if|if
condition|(
name|Mapped
condition|)
block|{
name|Map
operator|->
name|Ident
operator|=
literal|""
expr_stmt|;
comment|/* means "map any type" */
name|Map
operator|->
name|Test
operator|=
name|ALL
expr_stmt|;
comment|/* at all baud rates */
name|Map
operator|->
name|Type
operator|=
name|DefType
expr_stmt|;
comment|/* to the default type */
block|}
else|else
name|TtyType
operator|=
name|DefType
expr_stmt|;
block|}
comment|/* Get rid of $TERMCAP, if it's there, so we get a real 	   entry from /etc/termcap.  This prevents us from being 	   fooled by out of date stuff in the environment. */
name|bufp
operator|=
name|getenv
argument_list|(
literal|"TERMCAP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufp
operator|!=
name|NULL
operator|&&
operator|*
name|bufp
operator|!=
literal|'/'
condition|)
name|strcpy
argument_list|(
name|bufp
operator|-
literal|8
argument_list|,
literal|"NOTHING"
argument_list|)
expr_stmt|;
comment|/* Overwrite only "TERMCAP". */
comment|/* Get current idea of terminal type from environment. */
if|if
condition|(
operator|!
name|NoTermFromEnv
operator|&&
name|TtyType
operator|==
name|NULL
condition|)
name|TtyType
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
comment|/* Determine terminal id if needed. */
if|if
condition|(
operator|!
name|RepOnly
operator|&&
name|TtyPath
operator|==
name|NULL
operator|&&
operator|(
name|TtyType
operator|==
name|NULL
operator|||
operator|!
name|NoTermFromEnv
operator|)
condition|)
name|TtyPath
operator|=
name|ttyname
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
comment|/* If still undefined, look at /etc/ttytype. */
if|if
condition|(
name|TtyType
operator|==
name|NULL
condition|)
name|TtyType
operator|=
name|stypeof
argument_list|(
name|TtyPath
argument_list|)
expr_stmt|;
comment|/* If still undefined, use DEFTYPE. */
if|if
condition|(
name|TtyType
operator|==
name|NULL
condition|)
name|TtyType
operator|=
name|DEFTYPE
expr_stmt|;
comment|/* Check for dialup or other mapping. */
if|if
condition|(
name|Mapped
condition|)
block|{
if|if
condition|(
name|Alias
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
operator|!
name|isalias
argument_list|(
name|TtyType
argument_list|)
condition|)
block|{
if|if
condition|(
name|tgetent
argument_list|(
name|Capbuf
argument_list|,
name|TtyType
argument_list|)
operator|>
literal|0
condition|)
name|makealias
argument_list|(
name|Capbuf
argument_list|)
expr_stmt|;
block|}
name|TtyType
operator|=
name|mapped
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
block|}
comment|/* TtyType now contains a pointer to the type of the terminal. 	   If the first character is '?', ask the user. */
if|if
condition|(
name|TtyType
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
name|Ask
operator|=
name|YES
expr_stmt|;
name|TtyType
operator|++
expr_stmt|;
if|if
condition|(
name|TtyType
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|TtyType
operator|=
name|DEFTYPE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Query the user for TtyType if needed, then    read the termcap entry for TtyType into Capbuf and TTycap. */
end_comment

begin_function
name|void
name|get_termcap_entry
parameter_list|()
block|{
specifier|static
name|char
name|termbuf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Ask
condition|)
block|{
name|ask
label|:
name|prs
argument_list|(
literal|"TERM = ("
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
comment|/* Read the terminal.  If not empty, set type. */
name|i
operator|=
name|read
argument_list|(
literal|2
argument_list|,
name|termbuf
argument_list|,
sizeof|sizeof
name|termbuf
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|termbuf
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|i
operator|--
expr_stmt|;
name|termbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|termbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|TtyType
operator|=
name|termbuf
expr_stmt|;
block|}
block|}
comment|/* Get terminal capabilities. */
if|if
condition|(
name|Alias
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
operator|!
name|isalias
argument_list|(
name|TtyType
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|tgetent
argument_list|(
name|Capbuf
argument_list|,
name|TtyType
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|prs
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|": cannot find termcap\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|prs
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|": type "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|" is unknown\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|DoSetenv
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|TtyType
operator|=
name|DEFTYPE
expr_stmt|;
name|Alias
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|ask
goto|;
block|}
block|}
name|Ttycap
operator|=
name|Capbuf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the erase, interrupt, and kill characters    from the termcap entry and command line    and update their values in 'mode'. */
end_comment

begin_function
name|void
name|set_control_chars
parameter_list|()
block|{
name|char
name|buf
index|[
name|CAPBUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
name|char
name|bs_char
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|Specialerase
operator|&&
operator|!
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
name|Erase_char
operator|=
literal|0
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
name|p
operator|=
name|tgetstr
argument_list|(
literal|"kb"
argument_list|,
operator|&
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|p
operator|=
name|tgetstr
argument_list|(
literal|"bc"
argument_list|,
operator|&
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|bs_char
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
name|bs_char
operator|=
name|BACKSPACE
expr_stmt|;
else|else
name|bs_char
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Erase_char
operator|==
literal|0
operator|&&
operator|!
name|tgetflag
argument_list|(
literal|"os"
argument_list|)
operator|&&
name|curerase
operator|==
name|CERASE
condition|)
block|{
if|if
condition|(
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
operator|||
name|bs_char
operator|!=
literal|0
condition|)
name|Erase_char
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|Erase_char
operator|<
literal|0
condition|)
name|Erase_char
operator|=
operator|(
name|bs_char
operator|!=
literal|0
operator|)
condition|?
name|bs_char
else|:
name|BACKSPACE
expr_stmt|;
if|if
condition|(
name|curerase
operator|==
literal|0
condition|)
name|curerase
operator|=
name|CERASE
expr_stmt|;
if|if
condition|(
name|Erase_char
operator|!=
literal|0
condition|)
name|curerase
operator|=
name|Erase_char
expr_stmt|;
if|if
condition|(
name|curintr
operator|==
literal|0
condition|)
name|curintr
operator|=
name|CINTR
expr_stmt|;
if|if
condition|(
name|Intr_char
operator|!=
literal|0
condition|)
name|curintr
operator|=
name|Intr_char
expr_stmt|;
if|if
condition|(
name|curkill
operator|==
literal|0
condition|)
name|curkill
operator|=
name|CKILL
expr_stmt|;
if|if
condition|(
name|Kill_char
operator|!=
literal|0
condition|)
name|curkill
operator|=
name|Kill_char
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up various conversions in 'mode', including    parity, tabs, returns, echo, and case, according to    the termcap entry.    if 'command' starts with uppercase, map external uppercase    to internal lowercase. */
end_comment

begin_function
name|void
name|set_conversions
parameter_list|(
name|command
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
block|{
if|if
condition|(
name|tgetflag
argument_list|(
literal|"UC"
argument_list|)
operator|||
operator|(
name|command
index|[
literal|0
index|]
operator|&
literal|0140
operator|)
operator|==
literal|0100
condition|)
block|{
ifdef|#
directive|ifdef
name|IUCLC
name|mode
operator|.
name|c_iflag
operator||=
name|IUCLC
expr_stmt|;
name|mode
operator|.
name|c_oflag
operator||=
name|OLCUC
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|tgetflag
argument_list|(
literal|"LC"
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|IUCLC
name|mode
operator|.
name|c_iflag
operator|&=
operator|~
name|IUCLC
expr_stmt|;
name|mode
operator|.
name|c_oflag
operator|&=
operator|~
name|OLCUC
expr_stmt|;
endif|#
directive|endif
block|}
name|mode
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|PARMRK
operator||
name|INPCK
operator|)
expr_stmt|;
name|mode
operator|.
name|c_lflag
operator||=
name|ICANON
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"EP"
argument_list|)
condition|)
block|{
name|mode
operator|.
name|c_cflag
operator||=
name|PARENB
expr_stmt|;
name|mode
operator|.
name|c_cflag
operator|&=
operator|~
name|PARODD
expr_stmt|;
block|}
if|if
condition|(
name|tgetflag
argument_list|(
literal|"OP"
argument_list|)
condition|)
block|{
name|mode
operator|.
name|c_cflag
operator||=
name|PARENB
expr_stmt|;
name|mode
operator|.
name|c_cflag
operator||=
name|PARODD
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ONLCR
name|mode
operator|.
name|c_oflag
operator||=
name|ONLCR
expr_stmt|;
endif|#
directive|endif
name|mode
operator|.
name|c_iflag
operator||=
name|ICRNL
expr_stmt|;
name|mode
operator|.
name|c_lflag
operator||=
name|ECHO
expr_stmt|;
name|mode
operator|.
name|c_oflag
operator||=
name|OXTABS
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"NL"
argument_list|)
condition|)
block|{
comment|/* Newline, not linefeed. */
ifdef|#
directive|ifdef
name|ONLCR
name|mode
operator|.
name|c_oflag
operator|&=
operator|~
name|ONLCR
expr_stmt|;
endif|#
directive|endif
name|mode
operator|.
name|c_iflag
operator|&=
operator|~
name|ICRNL
expr_stmt|;
block|}
if|if
condition|(
name|tgetflag
argument_list|(
literal|"HD"
argument_list|)
condition|)
comment|/* Half duplex. */
name|mode
operator|.
name|c_lflag
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"pt"
argument_list|)
condition|)
comment|/* Print tabs. */
name|mode
operator|.
name|c_oflag
operator|&=
operator|~
name|OXTABS
expr_stmt|;
name|mode
operator|.
name|c_lflag
operator||=
operator|(
name|ECHOE
operator||
name|ECHOK
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the hardware tabs on the terminal, using the ct (clear all tabs),  * st (set one tab) and ch (horizontal cursor addressing) capabilities.  * This is done before if and is, so they can patch in case we blow this.  * Return nonzero if we set any tab stops, zero if not.  */
end_comment

begin_function
name|int
name|settabs
parameter_list|()
block|{
name|char
name|caps
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|capsp
init|=
name|caps
decl_stmt|;
name|char
modifier|*
name|clear_tabs
decl_stmt|,
modifier|*
name|set_tab
decl_stmt|,
modifier|*
name|set_column
decl_stmt|,
modifier|*
name|set_pos
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tg_out
decl_stmt|;
name|int
name|c
decl_stmt|;
name|clear_tabs
operator|=
name|tgetstr
argument_list|(
literal|"ct"
argument_list|,
operator|&
name|capsp
argument_list|)
expr_stmt|;
name|set_tab
operator|=
name|tgetstr
argument_list|(
literal|"st"
argument_list|,
operator|&
name|capsp
argument_list|)
expr_stmt|;
name|set_column
operator|=
name|tgetstr
argument_list|(
literal|"ch"
argument_list|,
operator|&
name|capsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_column
operator|==
name|NULL
condition|)
name|set_pos
operator|=
name|tgetstr
argument_list|(
literal|"cm"
argument_list|,
operator|&
name|capsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clear_tabs
operator|&&
name|set_tab
condition|)
block|{
name|prc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
comment|/* force to be at left margin */
name|tputs
argument_list|(
name|clear_tabs
argument_list|,
literal|0
argument_list|,
name|prc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_tab
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|8
init|;
name|c
operator|<
name|columns
condition|;
name|c
operator|+=
literal|8
control|)
block|{
comment|/* get to that column. */
name|tg_out
operator|=
literal|"OOPS"
expr_stmt|;
comment|/* also returned by tgoto */
if|if
condition|(
name|set_column
condition|)
name|tg_out
operator|=
name|tgoto
argument_list|(
name|set_column
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tg_out
operator|==
literal|'O'
operator|&&
name|set_pos
condition|)
name|tg_out
operator|=
name|tgoto
argument_list|(
name|set_pos
argument_list|,
name|c
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tg_out
operator|!=
literal|'O'
condition|)
name|tputs
argument_list|(
name|tg_out
argument_list|,
literal|1
argument_list|,
name|prc
argument_list|)
expr_stmt|;
else|else
block|{
name|prs
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
block|}
comment|/* set the tab */
name|tputs
argument_list|(
name|set_tab
argument_list|,
literal|0
argument_list|,
name|prc
argument_list|)
expr_stmt|;
block|}
name|prc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output startup string. */
end_comment

begin_function
name|void
name|output_initializations
parameter_list|()
block|{
name|char
name|buf
index|[
name|CAPBUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
name|int
name|settle
init|=
name|NO
decl_stmt|;
comment|/* Get pad character. */
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
name|PC
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|TAB3
if|if
condition|(
name|oldmode
operator|.
name|c_oflag
operator|&
operator|(
name|TAB3
operator||
name|ONLCR
operator||
name|OCRNL
operator||
name|ONLRET
operator|)
condition|)
block|{
name|oldmode
operator|.
name|c_oflag
operator|&=
operator|(
name|TAB3
operator||
name|ONLCR
operator||
name|OCRNL
operator||
name|ONLRET
operator|)
expr_stmt|;
name|set_mode
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|settabs
argument_list|()
condition|)
block|{
name|settle
operator|=
name|YES
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|IsReset
operator|&&
name|tgetstr
argument_list|(
literal|"rs"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
operator|||
name|tgetstr
argument_list|(
literal|"is"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tputs
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|prc
argument_list|)
expr_stmt|;
name|settle
operator|=
name|YES
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|IsReset
operator|&&
name|tgetstr
argument_list|(
literal|"rf"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
operator|||
name|tgetstr
argument_list|(
literal|"if"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cat
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|settle
operator|=
name|YES
expr_stmt|;
block|}
if|if
condition|(
name|settle
condition|)
block|{
name|prc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Let the terminal settle down. */
block|}
block|}
end_function

begin_comment
comment|/* Set the terminal processing according to 'mode' or 'oldmode'.    If called as the result of a signal, flag is> 0.    If called from terminal init, flag == -1 means reset 'oldmode'.    If called at end of normal mode processing, flag == 0. */
end_comment

begin_function
name|void
name|set_mode
parameter_list|(
name|flag
parameter_list|)
name|int
name|flag
decl_stmt|;
block|{
if|if
condition|(
name|flag
operator|<
literal|0
condition|)
name|tcsetattr
argument_list|(
name|FILEDES
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|oldmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mode
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oldmode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
condition|)
name|tcsetattr
argument_list|(
name|FILEDES
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|>
literal|0
condition|)
comment|/* trapped signal */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the user the value that a control key is set to,    if it has been changed from the default value.    'new', 'old', and 'def' are the current, previous, and default    ASCII values for the control key called 'name' in English. */
end_comment

begin_function
name|void
name|reportek
parameter_list|(
name|name
parameter_list|,
name|new
parameter_list|,
name|old
parameter_list|,
name|def
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|char
name|new
decl_stmt|;
name|unsigned
name|char
name|old
decl_stmt|;
name|unsigned
name|char
name|def
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
name|o
decl_stmt|;
specifier|register
name|unsigned
name|char
name|n
decl_stmt|;
name|char
name|buf
index|[
name|CAPBUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
name|o
operator|=
name|old
expr_stmt|;
name|n
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|n
operator|&&
name|n
operator|==
name|def
condition|)
return|return;
name|prs
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|n
condition|)
name|prs
argument_list|(
literal|" is "
argument_list|)
expr_stmt|;
else|else
name|prs
argument_list|(
literal|" set to "
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"kb"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|&&
name|n
operator|==
name|buf
index|[
literal|0
index|]
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|prs
argument_list|(
literal|"Backspace\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
literal|0177
condition|)
name|prs
argument_list|(
literal|"Delete\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|n
operator|<
literal|040
condition|)
block|{
name|prs
argument_list|(
literal|"Ctrl-"
argument_list|)
expr_stmt|;
name|n
operator|^=
literal|0100
expr_stmt|;
block|}
name|prc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|prc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print string 's' to stderr, buffered. */
end_comment

begin_function
name|void
name|prs
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|prc
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
name|OutBuf
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|OutPtr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print character 'c' to stderr, buffered. */
end_comment

begin_function
name|int
name|prc
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
name|OutBuf
index|[
name|OutPtr
operator|++
index|]
operator|=
name|c
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|OutPtr
operator|>=
sizeof|sizeof
name|OutBuf
condition|)
name|flush
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Write out and empty the buffer used by prs and prc. */
end_comment

begin_function
name|void
name|flush
parameter_list|()
block|{
if|if
condition|(
name|OutPtr
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
name|OutBuf
argument_list|,
name|OutPtr
argument_list|)
expr_stmt|;
name|OutPtr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print file 'file' to STDERR. */
end_comment

begin_function
name|void
name|cat
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|prs
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|": cannot open "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put each of the alternative names for the terminal    described by the termcap entry 'buf' into an element of 'Alias'.    Make the final element a NULL. */
end_comment

begin_function
name|void
name|makealias
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Index into 'Alias'. */
specifier|register
name|char
modifier|*
name|a
decl_stmt|;
comment|/* Pointer into 'Aliasbuf'. */
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
comment|/* Pointer into 'buf'. */
name|Alias
index|[
literal|0
index|]
operator|=
name|a
operator|=
name|Aliasbuf
expr_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|b
operator|&&
operator|*
name|b
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|b
operator|==
literal|'|'
condition|)
block|{
operator|*
name|a
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|Alias
index|[
name|i
operator|++
index|]
operator|=
name|a
expr_stmt|;
name|b
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|a
operator|++
operator|=
operator|*
name|b
operator|++
expr_stmt|;
block|}
operator|*
name|a
operator|=
literal|'\0'
expr_stmt|;
name|Alias
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return YES if 'ident' is the same as one of the aliases,    NO if not. */
end_comment

begin_function
name|int
name|isalias
parameter_list|(
name|ident
parameter_list|)
name|char
modifier|*
name|ident
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|Alias
init|;
operator|*
name|a
condition|;
operator|++
name|a
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ident
argument_list|,
operator|*
name|a
argument_list|)
condition|)
return|return
name|YES
return|;
return|return
name|NO
return|;
block|}
end_function

begin_comment
comment|/* Return the default type of terminal for line 'ttyid'. */
end_comment

begin_function
name|char
modifier|*
name|stypeof
parameter_list|(
name|ttyid
parameter_list|)
name|char
modifier|*
name|ttyid
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|PortType
decl_stmt|;
specifier|register
name|char
modifier|*
name|TtyId
decl_stmt|;
name|struct
name|ttyent
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|ttyid
operator|==
name|NULL
condition|)
return|return
operator|(
name|DEFTYPE
operator|)
return|;
comment|/* Set TtyId to the basename of ttyid. */
name|TtyId
operator|=
name|ttyid
expr_stmt|;
while|while
condition|(
operator|*
name|ttyid
condition|)
if|if
condition|(
operator|*
name|ttyid
operator|++
operator|==
literal|'/'
condition|)
name|TtyId
operator|=
name|ttyid
expr_stmt|;
name|t
operator|=
name|getttynam
argument_list|(
name|TtyId
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEFTYPE
return|;
name|PortType
operator|=
name|t
operator|->
name|ty_type
expr_stmt|;
comment|/* get aliases from termcap entry */
if|if
condition|(
name|Mapped
operator|&&
name|tgetent
argument_list|(
name|Capbuf
argument_list|,
name|PortType
argument_list|)
operator|>
literal|0
condition|)
block|{
name|makealias
argument_list|(
name|Capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Alias
index|[
literal|0
index|]
argument_list|,
name|PortType
argument_list|)
operator|&&
name|Alias
index|[
literal|1
index|]
condition|)
name|PortType
operator|=
name|Alias
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
operator|(
name|PortType
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|WHITE
parameter_list|(
name|c
parameter_list|)
value|(c == ' ' || c == '\t')
end_define

begin_comment
comment|/* Output termcap entry 'bp' to stdout, quoting characters that    would give the shell problems and omitting empty fields. */
end_comment

begin_function
name|void
name|wrtermcap
parameter_list|(
name|bp
parameter_list|)
name|char
modifier|*
name|bp
decl_stmt|;
block|{
name|char
name|buf
index|[
name|CAPBUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
name|int
name|space
decl_stmt|,
name|empty
decl_stmt|;
comment|/* Copy the terminal names in 'bp' into 'buf', 	   discarding (verbose) names that contain blanks. */
while|while
condition|(
operator|*
name|bp
operator|&&
operator|*
name|bp
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'|'
condition|)
block|{
name|tp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|space
operator|=
name|NO
expr_stmt|;
while|while
condition|(
operator|*
name|tp
operator|&&
operator|*
name|tp
operator|!=
literal|'|'
operator|&&
operator|*
name|tp
operator|!=
literal|':'
condition|)
block|{
name|space
operator|=
operator|(
name|space
operator|||
name|WHITE
argument_list|(
operator|*
name|tp
argument_list|)
operator|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|space
condition|)
block|{
name|bp
operator|=
name|tp
expr_stmt|;
continue|continue;
block|}
block|}
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|bp
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
condition|)
block|{
case|case
literal|':'
case|:
comment|/* discard empty, cancelled  or dupl fields */
name|tp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|empty
operator|=
name|YES
expr_stmt|;
while|while
condition|(
operator|*
name|tp
operator|&&
operator|*
name|tp
operator|!=
literal|':'
condition|)
block|{
name|empty
operator|=
operator|(
name|empty
operator|&&
name|WHITE
argument_list|(
operator|*
name|tp
argument_list|)
operator|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|empty
operator|||
name|cancelled
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
condition|)
block|{
name|bp
operator|=
name|tp
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|' '
case|:
comment|/* no spaces in output */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\040"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'!'
case|:
comment|/* the shell thinks this is history */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\041"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|','
case|:
comment|/* the shell thinks this is history */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\054"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'"'
case|:
comment|/* no quotes in output */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\042"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\''
case|:
comment|/* no quotes in output */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\047"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'`'
case|:
comment|/* no back quotes in output */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\140"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
case|case
literal|'^'
case|:
comment|/* anything following is OK */
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
comment|/* we skipped the last : with the : lookahead hack */
operator|(
name|void
operator|)
name|write
argument_list|(
name|STDOUT
argument_list|,
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Array of termcap entries processed so far by 'cancelled',    for omitting duplicates from the output. */
end_comment

begin_decl_stmt
name|char
name|delcap
index|[
literal|128
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of valid entries in 'delcap'. */
end_comment

begin_decl_stmt
name|int
name|ncap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return YES if 'cap' is a commented-out or duplicate capability,    NO if not. */
end_comment

begin_function
name|int
name|cancelled
parameter_list|(
name|cap
parameter_list|)
name|char
modifier|*
name|cap
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncap
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cap
index|[
literal|0
index|]
operator|==
name|delcap
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&&
name|cap
index|[
literal|1
index|]
operator|==
name|delcap
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|YES
operator|)
return|;
block|}
comment|/* delete a second occurrance of the same capability */
name|delcap
index|[
name|ncap
index|]
index|[
literal|0
index|]
operator|=
name|cap
index|[
literal|0
index|]
expr_stmt|;
name|delcap
index|[
name|ncap
index|]
index|[
literal|1
index|]
operator|=
name|cap
index|[
literal|1
index|]
expr_stmt|;
name|ncap
operator|++
expr_stmt|;
return|return
operator|(
name|cap
index|[
literal|2
index|]
operator|==
literal|'@'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Append a printable representation of 'str' to 'ptr' and    return a pointer to the next available character after 'ptr'. */
end_comment

begin_function
name|char
modifier|*
name|putbuf
parameter_list|(
name|ptr
parameter_list|,
name|str
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'\033'
case|:
name|ptr
operator|=
name|putbuf
argument_list|(
name|ptr
argument_list|,
literal|"\\E"
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|*
name|str
operator|<=
literal|' '
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\\%03o"
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|putbuf
argument_list|(
name|ptr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|ptr
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the internal form of ASCII baud rate 'p',    or -1 if 'p' does not represent a valid baud rate. */
end_comment

begin_function
name|int
name|baudrate
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
literal|7
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|)
condition|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|speeds
index|[
name|i
index|]
operator|.
name|string
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|speeds
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|buf
argument_list|)
condition|)
return|return
operator|(
name|speeds
index|[
name|i
index|]
operator|.
name|speed
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the type of terminal to use for a port of type 'type',    as specified by the first applicable mapping in 'map'.    If no mappings apply, return 'type'. */
end_comment

begin_function
name|char
modifier|*
name|mapped
parameter_list|(
name|type
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
block|{
name|int
name|match
decl_stmt|;
name|Map
operator|=
name|map
expr_stmt|;
while|while
condition|(
name|Map
operator|->
name|Ident
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|Map
operator|->
name|Ident
operator|)
operator|==
literal|'\0'
operator|||
operator|!
name|strcmp
argument_list|(
name|Map
operator|->
name|Ident
argument_list|,
name|type
argument_list|)
operator|||
name|isalias
argument_list|(
name|Map
operator|->
name|Ident
argument_list|)
condition|)
block|{
name|match
operator|=
name|NO
expr_stmt|;
switch|switch
condition|(
name|Map
operator|->
name|Test
condition|)
block|{
case|case
name|ANY
case|:
comment|/* no test specified */
case|case
name|ALL
case|:
name|match
operator|=
name|YES
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|match
operator|=
operator|(
name|ospeed
operator|>
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|match
operator|=
operator|(
name|ospeed
operator|>=
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|match
operator|=
operator|(
name|ospeed
operator|==
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|match
operator|=
operator|(
name|ospeed
operator|<=
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|match
operator|=
operator|(
name|ospeed
operator|<
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|match
operator|=
operator|(
name|ospeed
operator|!=
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|match
condition|)
return|return
operator|(
name|Map
operator|->
name|Type
operator|)
return|;
block|}
name|Map
operator|++
expr_stmt|;
block|}
comment|/* no match found; return given type */
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-] [-hnrsIQS] [-eC] [-iC] [-kC] [-EC]\n\        [-m [port-type][test baudrate]:terminal-type] [terminal-type]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

