begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)tset.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/* **  TSET -- set terminal modes ** **	This program does sophisticated terminal initialization. **	I recommend that you include it in your .start_up or .login **	file to initialize whatever terminal you are on. ** **	There are several features: ** **	A special file or sequence (as controlled by the ttycap file) **	is sent to the terminal. ** **	Mode bits are set on a per-terminal_type basis (much better **	than UNIX itself).  This allows special delays, automatic **	tabs, etc. ** **	Erase and Kill characters can be set to whatever you want. **	Default is to change erase to control-H on a terminal which **	can overstrike, and leave it alone on anything else.  Kill **	is always left alone unless specifically requested.  These **	characters can be represented as "^X" meaning control-X; **	X is any character. ** **	Terminals which are dialups or plugboard types can be aliased **	to whatever type you may have in your home or office.  Thus, **	if you know that when you dial up you will always be on a **	TI 733, you can specify that fact to tset.  You can represent **	a type as "?type".  This will ask you what type you want it **	to be -- if you reply with just a newline, it will default **	to the type given. ** **	The htmp file, used by ex, etc., can be updated. ** **	The current terminal type can be queried. ** **	Usage: **		tset [-] [-EC] [-eC] [-kC] [-s] [-h] [-u] [-r] **			[-m [ident] [test baudrate] :type] **			[-Q] [-I] [-S] [type] ** **		In systems with environments, use: **			eval `tset -s ...` **		Actually, this doesn't work in old csh's. **		Instead, use: **			tset -s ...> tset.tmp **			source tset.tmp **			rm tset.tmp **		or: **			set noglob **			set term=(`tset -S ....`) **			setenv TERM $term[1] **			setenv TERMCAP "$term[2]" **			unset term **			unset noglob ** **	Positional Parameters: **		type -- the terminal type to force.  If this is **			specified, initialization is for this **			terminal type. ** **	Flags: **		- -- report terminal type.  Whatever type is **			decided on is reported.  If no other flags **			are stated, the only affect is to write **			the terminal type on the standard output. **		-r -- report to user in addition to other flags. **		-EC -- set the erase character to C on all terminals **			except those which cannot backspace (e.g., **			a TTY 33).  C defaults to control-H. **		-eC -- set the erase character to C on all terminals. **			C defaults to control-H.  If neither -E or -e **			are specified, the erase character is set to **			control-H if the terminal can both backspace **			and not overstrike (e.g., a CRT).  If the erase **			character is NULL (zero byte), it will be reset **			to '#' if nothing else is specified. **		-kC -- set the kill character to C on all terminals. **			Default for C is control-X.  If not specified, **			the kill character is untouched; however, if **			not specified and the kill character is NULL **			(zero byte), the kill character is set to '@'. **		-iC -- reserved for setable interrupt character. **		-qC -- reserved for setable quit character. **		-m -- map the system identified type to some user **			specified type. The mapping can be baud rate **			dependent. This replaces the old -d, -p flags. **			(-d type  ->  -m dialup:type) **			(-p type  ->  -m plug:type) **			Syntax:	-m identifier [test baudrate] :type **			where: ``identifier'' is terminal type found in **			/etc/ttys for this port, (abscence of an identifier **			matches any identifier); ``test'' may be any combination **			of>  =<  !  @; ``baudrate'' is as with stty(1); **			``type'' is the actual terminal type to use if the **			mapping condition is met. Multiple maps are scanned **			in order and the first match prevails. **		-n -- If the new tty driver from UCB is available, this flag **			will activate the new options for erase and kill **			processing. This will be different for printers **			and crt's. For crts, if the baud rate is< 1200 then **			erase and kill don't remove characters from the screen. **		-h -- don't read htmp file.  Normally the terminal type **			is determined by reading the htmp file or the **			environment (unless some mapping is specified). **			This forces a read of the ttytype file -- useful **			when htmp is somehow wrong. (V6 only) **		-u -- don't update htmp.  It seemed like this should **			be put in.  Note that htmp is never actually **			written if there are no changes, so don't bother **			bother using this for efficiency reasons alone. **		-s -- output setenv commands for TERM.  This can be **			used with **				`tset -s ...` **			and is to be prefered to: **				setenv TERM `tset - ...` **			because -s sets the TERMCAP variable also. **		-S -- Similar to -s but outputs 2 strings suitable for **			use in csh .login files as follows: **				set noglob **				set term=(`tset -S .....`) **				setenv TERM $term[1] **				setenv TERMCAP "$term[2]" **				unset term **				unset noglob **		-Q -- be quiet.  don't output 'Erase set to' etc. **		-I -- don't do terminal initialization (is& if **			strings). **		-v -- On virtual terminal systems, don't set up a **			virtual terminal.  Otherwise tset will tell **			the operating system what kind of terminal you **			are on (if it is a known terminal) and fix up **			the output of -s to use virtual terminal sequences. ** **	Files: **		/etc/ttys **			contains a terminal id -> terminal type **			mapping; used when any user mapping is specified, **			or the environment doesn't have TERM set. **		/etc/termcap **			a terminal_type -> terminal_capabilities **			mapping. ** **	Return Codes: **		-1 -- couldn't open ttycap. **		1 -- bad terminal type, or standard output not tty. **		0 -- ok. ** **	Defined Constants: **		DIALUP -- the type code for a dialup port. **		PLUGBOARD -- the type code for a plugboard port. **		ARPANET -- the type code for an arpanet port. **		BACKSPACE -- control-H, the default for -e. **		CTRL('X') -- control-X, the default for -k. **		OLDERASE -- the system default erase character. **		OLDKILL -- the system default kill character. **		FILEDES -- the file descriptor to do the operation **			on, nominally 1 or 2. **		STDOUT -- the standard output file descriptor. **		UIDMASK -- the bit pattern to mask with the getuid() **			call to get just the user id. **		GTTYN -- defines file containing generalized ttynames **			and compiles code to look there. ** **	Requires: **		Routines to handle htmp, ttys, and ttycap. ** **	Compilation Flags: **		OLDFLAGS -- must be defined to compile code for any of **			the -d, -p, or -a flags. **		OLDDIALUP -- accept the -d flag. **		OLDPLUGBOARD -- accept the -p flag. **		OLDARPANET -- accept the -a flag. **		V6 -- if clear, use environments, not htmp. **			also use TIOCSETN rather than stty to avoid flushing **		GTTYN -- if set, compiles code to look at /etc/ttys. **		UCB_NTTY -- set to handle new tty driver modes. ** **	Trace Flags: **		none ** **	Diagnostics: **		Bad flag **			An incorrect option was specified. **		Too few args **			more command line arguments are required. **		Unexpected arg **			wrong type of argument was encountered. **		Cannot open ... **			The specified file could not be openned. **		Type ... unknown **			An unknown terminal type was specified. **		Cannot update htmp **			Cannot update htmp file when the standard **			output is not a terminal. **		Erase set to ... **			Telling that the erase character has been **			set to the specified character. **		Kill set to ... **			Ditto for kill **		Erase is ...    Kill is ... **			Tells that the erase/kill characters were **			wierd before, but they are being left as-is. **		Not a terminal **			Set if FILEDES is not a terminal. ** **	Compilation Instructions: **		cc -n -O tset.c -ltermlib **		mv a.out tset **		chown bin tset **		chmod 4755 tset ** **		where 'bin' should be whoever owns the 'htmp' file. **		If 'htmp' is 666, then tset need not be setuid. ** **		For version 6 the compile command should be: **		cc -n -O -I/usr/include/retrofit tset.c -ltermlib -lretro -lS ** **	Author: **		Eric Allman **		Electronics Research Labs **		U.C. Berkeley ** **	History: **		1/81 -- Added alias checking for mapping identifiers. **		9/80 -- Added UCB_NTTY mods to setup the new tty driver. **			Added the 'reset ...' invocation. **		7/80 -- '-S' added. '-m' mapping added. TERMCAP string **			cleaned up. **		3/80 -- Changed to use tputs.  Prc& flush added. **		10/79 -- '-s' option extended to handle TERMCAP **			variable, set noglob, quote the entry, **			and know about the Bourne shell.  Terminal **			initialization moved to before any information **			output so screen clears would not screw you. **			'-Q' option added. **		8/79 -- '-' option alone changed to only output **			type.  '-s' option added.  'VERSION7' **			changed to 'V6' for compatibility. **		12/78 -- modified for eventual migration to VAX/UNIX, **			so the '-' option is changed to output only **			the terminal type to STDOUT instead of **			FILEDES. **		9/78 -- '-' and '-p' options added (now fully **			compatible with ttytype!), and spaces are **			permitted between the -d and the type. **		8/78 -- The sense of -h and -u were reversed, and the **			-f flag is dropped -- same effect is available **			by just stating the terminal type. **		10/77 -- Written. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_define
define|#
directive|define
name|rindex
value|strrchr
end_define

begin_define
define|#
directive|define
name|curerase
value|mode.c_cc[VERASE]
end_define

begin_define
define|#
directive|define
name|curkill
value|mode.c_cc[VKILL]
end_define

begin_define
define|#
directive|define
name|olderase
value|oldmode.c_cc[VERASE]
end_define

begin_define
define|#
directive|define
name|oldkill
value|oldmode.c_cc[VKILL]
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|curerase
value|mode.sg_erase
end_define

begin_define
define|#
directive|define
name|curkill
value|mode.sg_kill
end_define

begin_define
define|#
directive|define
name|olderase
value|oldmode.sg_erase
end_define

begin_define
define|#
directive|define
name|oldkill
value|oldmode.sg_kill
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|V6
end_ifndef

begin_define
define|#
directive|define
name|GTTYN
end_define

begin_include
include|#
directive|include
file|<ttyent.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_include
include|#
directive|include
file|<retrofit.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_undef
undef|#
directive|undef
name|CTRL
end_undef

begin_define
define|#
directive|define
name|CTRL
parameter_list|(
name|x
parameter_list|)
value|(x ^ 0100)
end_define

begin_define
define|#
directive|define
name|BACKSPACE
value|(CTRL('H'))
end_define

begin_define
define|#
directive|define
name|CHK
parameter_list|(
name|val
parameter_list|,
name|dft
parameter_list|)
value|(val<=0 ? dft : val)
end_define

begin_define
define|#
directive|define
name|isdigit
parameter_list|(
name|c
parameter_list|)
value|(c>= '0'&& c<= '9')
end_define

begin_define
define|#
directive|define
name|isalnum
parameter_list|(
name|c
parameter_list|)
value|(c> ' '&& !(index("<@=>!:|\177", c)) )
end_define

begin_define
define|#
directive|define
name|OLDERASE
value|'#'
end_define

begin_define
define|#
directive|define
name|OLDKILL
value|'@'
end_define

begin_define
define|#
directive|define
name|FILEDES
value|2
end_define

begin_comment
comment|/* do gtty/stty on this descriptor */
end_comment

begin_define
define|#
directive|define
name|STDOUT
value|1
end_define

begin_comment
comment|/* output of -s/-S to this descriptor */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_define
define|#
directive|define
name|UIDMASK
value|0377
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UIDMASK
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UCB_NTTY
end_ifdef

begin_define
define|#
directive|define
name|USAGE
value|"usage: tset [-] [-nrsIQS] [-eC] [-kC] [-m [ident][test speed]:type] [type]\n"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USAGE
value|"usage: tset [-] [-rsIQS] [-eC] [-kC] [-m [ident][test speed]:type] [type]\n"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OLDFLAGS
end_define

begin_define
define|#
directive|define
name|DIALUP
value|"dialup"
end_define

begin_define
define|#
directive|define
name|OLDDIALUP
value|"sd"
end_define

begin_define
define|#
directive|define
name|PLUGBOARD
value|"plugboard"
end_define

begin_define
define|#
directive|define
name|OLDPLUGBOARD
value|"sp"
end_define

begin_comment
comment|/*** # define	ARPANET		"arpanet" # define	OLDARPANET	"sa" /***/
end_comment

begin_define
define|#
directive|define
name|DEFTYPE
value|"unknown"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|GTTYN
end_ifdef

begin_define
define|#
directive|define
name|NOTTY
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NOTTY
value|'x'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Baud Rate Conditionals  */
end_comment

begin_define
define|#
directive|define
name|ANY
value|0
end_define

begin_define
define|#
directive|define
name|GT
value|1
end_define

begin_define
define|#
directive|define
name|EQ
value|2
end_define

begin_define
define|#
directive|define
name|LT
value|4
end_define

begin_define
define|#
directive|define
name|GE
value|(GT|EQ)
end_define

begin_define
define|#
directive|define
name|LE
value|(LT|EQ)
end_define

begin_define
define|#
directive|define
name|NE
value|(GT|LT)
end_define

begin_define
define|#
directive|define
name|ALL
value|(GT|EQ|LT)
end_define

begin_define
define|#
directive|define
name|NMAP
value|10
end_define

begin_struct
struct|struct
name|map
block|{
name|char
modifier|*
name|Ident
decl_stmt|;
name|char
name|Test
decl_stmt|;
name|char
name|Speed
decl_stmt|;
name|char
modifier|*
name|Type
decl_stmt|;
block|}
name|map
index|[
name|NMAP
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|map
modifier|*
name|Map
init|=
name|map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This should be available in an include file */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|speed
decl_stmt|;
name|int
name|baudrate
decl_stmt|;
block|}
name|speeds
index|[]
init|=
block|{
literal|"0"
block|,
name|B0
block|,
literal|0
block|,
literal|"50"
block|,
name|B50
block|,
literal|50
block|,
literal|"75"
block|,
name|B75
block|,
literal|75
block|,
literal|"110"
block|,
name|B110
block|,
literal|110
block|,
literal|"134"
block|,
name|B134
block|,
literal|134
block|,
literal|"134.5"
block|,
name|B134
block|,
literal|134
block|,
literal|"150"
block|,
name|B150
block|,
literal|150
block|,
literal|"200"
block|,
name|B200
block|,
literal|200
block|,
literal|"300"
block|,
name|B300
block|,
literal|300
block|,
literal|"600"
block|,
name|B600
block|,
literal|600
block|,
literal|"1200"
block|,
name|B1200
block|,
literal|1200
block|,
literal|"1800"
block|,
name|B1800
block|,
literal|1800
block|,
literal|"2400"
block|,
name|B2400
block|,
literal|2400
block|,
literal|"4800"
block|,
name|B4800
block|,
literal|4800
block|,
literal|"9600"
block|,
name|B9600
block|,
literal|9600
block|,
literal|"exta"
block|,
name|EXTA
block|,
literal|19200
block|,
literal|"extb"
block|,
name|EXTB
block|,
literal|38400
block|,
literal|0
block|, }
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|CBVIRTTERM
end_ifdef

begin_struct
struct|struct
name|vterm
block|{
name|char
name|cap
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
name|vtab
index|[]
init|=
block|{
literal|"al"
block|,
literal|"\033\120"
block|,
literal|"cd"
block|,
literal|"\033\114"
block|,
literal|"ce"
block|,
literal|"\033\113"
block|,
literal|"cm"
block|,
literal|"\033\107%r%.%."
block|,
literal|"cl"
block|,
literal|"\033\112"
block|,
literal|"dc"
block|,
literal|"\033\115"
block|,
literal|"dl"
block|,
literal|"\033\116"
block|,
literal|"ic"
block|,
literal|"\033\117"
block|,
literal|"kl"
block|,
literal|"\033\104"
block|,
literal|"kr"
block|,
literal|"\033\103"
block|,
literal|"ku"
block|,
literal|"\033\101"
block|,
literal|"kd"
block|,
literal|"\033\102"
block|,
literal|"kh"
block|,
literal|"\033\105"
block|,
literal|"nd"
block|,
literal|"\033\103"
block|,
literal|"se"
block|,
literal|"\033\142\004"
block|,
literal|"so"
block|,
literal|"\033\141\004"
block|,
literal|"ue"
block|,
literal|"\033\142\001"
block|,
literal|"up"
block|,
literal|"\033\101"
block|,
literal|"us"
block|,
literal|"\033\141\001"
block|,
literal|"\0\0"
block|,
name|NULL
block|, }
struct|;
end_struct

begin_decl_stmt
name|int
name|VirTermNo
init|=
operator|-
literal|2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|CBVIRTTERM
end_endif

begin_decl_stmt
name|char
name|Erase_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new erase character */
end_comment

begin_decl_stmt
name|char
name|Kill_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new kill character */
end_comment

begin_decl_stmt
name|char
name|Specialerase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set => Erase_char only on terminals with backspace */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GTTYN
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|Ttyid
init|=
name|NOTTY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal identifier */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|Ttyid
init|=
name|NOTTY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal identifier */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|TtyType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of terminal */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DefType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default type if none other computed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|NewType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mapping identifier based on old flags */
end_comment

begin_decl_stmt
name|int
name|Mapped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mapping has been specified */
end_comment

begin_decl_stmt
name|int
name|Dash_u
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't update htmp */
end_comment

begin_decl_stmt
name|int
name|Dash_h
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't read htmp */
end_comment

begin_decl_stmt
name|int
name|DoSetenv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output setenv commands */
end_comment

begin_decl_stmt
name|int
name|BeQuiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* be quiet */
end_comment

begin_decl_stmt
name|int
name|NoInit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't output initialization string */
end_comment

begin_decl_stmt
name|int
name|IsReset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* invoked as reset */
end_comment

begin_decl_stmt
name|int
name|Report
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report current type */
end_comment

begin_decl_stmt
name|int
name|Ureport
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report to user */
end_comment

begin_decl_stmt
name|int
name|RepOnly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report only */
end_comment

begin_decl_stmt
name|int
name|CmndLine
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output full command lines (-s option) */
end_comment

begin_decl_stmt
name|int
name|Ask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ask user for termtype */
end_comment

begin_decl_stmt
name|int
name|DoVirtTerm
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up a virtual terminal */
end_comment

begin_decl_stmt
name|int
name|New
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use new tty discipline */
end_comment

begin_decl_stmt
name|int
name|HasAM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if terminal has automatic margins */
end_comment

begin_decl_stmt
name|int
name|PadBaud
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Min rate of padding needed */
end_comment

begin_decl_stmt
name|int
name|lines
decl_stmt|,
name|columns
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CAPBUFSIZ
value|1024
end_define

begin_decl_stmt
name|char
name|Capbuf
index|[
name|CAPBUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line from /etc/termcap for this TtyType */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Ttycap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* termcap line from termcap or environ */
end_comment

begin_decl_stmt
name|char
name|Aliasbuf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Alias
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|delay
block|{
name|int
name|d_delay
decl_stmt|;
name|int
name|d_bits
decl_stmt|;
block|}
struct|;
end_struct

begin_include
include|#
directive|include
file|"tset.delays.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_decl_stmt
name|struct
name|sgttyb
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sgttyb
name|oldmode
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|termio
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|termio
name|oldmode
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CBVIRTTERM
end_ifdef

begin_decl_stmt
name|struct
name|termcb
name|block
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|20
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|CBVIRTTERM
end_endif

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
name|buf
index|[
name|CAPBUFSIZ
index|]
decl_stmt|;
name|char
name|termbuf
index|[
literal|32
index|]
decl_stmt|;
specifier|auto
name|char
modifier|*
name|bufp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|Break
decl_stmt|;
name|int
name|Not
decl_stmt|;
name|char
modifier|*
name|nextarg
parameter_list|()
function_decl|;
name|char
modifier|*
name|mapped
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
name|struct
name|winsize
name|win
decl_stmt|;
ifdef|#
directive|ifdef
name|V6
specifier|extern
name|char
modifier|*
name|hsgettype
parameter_list|()
function_decl|;
else|#
directive|else
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GTTYN
name|char
modifier|*
name|stypeof
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
endif|#
directive|endif
name|char
name|bs_char
decl_stmt|;
name|int
name|csh
decl_stmt|;
name|int
name|settle
decl_stmt|;
name|int
name|setmode
parameter_list|()
function_decl|;
extern|extern		prc(
block|)
function|;
end_function

begin_decl_stmt
specifier|extern
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|ospeed
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UCB_NTTY
end_ifdef

begin_decl_stmt
name|int
name|lmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ldisc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|lmode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCGETD
argument_list|,
operator|&
name|ldisc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_if
if|if
condition|(
name|gtty
argument_list|(
name|FILEDES
argument_list|,
operator|&
name|mode
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|mode
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|prs
argument_list|(
literal|"Not a terminal\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|bmove
argument_list|(
operator|&
name|mode
argument_list|,
operator|&
name|oldmode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_expr_stmt
name|ospeed
operator|=
name|mode
operator|.
name|sg_ospeed
operator|&
literal|017
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|ospeed
operator|=
name|mode
operator|.
name|c_cflag
operator|&
name|CBAUD
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|setmode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|setmode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|setmode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|command
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
name|command
operator|++
expr_stmt|;
else|else
name|command
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|sequal
argument_list|(
name|command
argument_list|,
literal|"reset"
argument_list|)
condition|)
block|{
comment|/* 	 * reset the teletype mode bits to a sensible state. 	 * Copied from the program by Kurt Shoens& Mark Horton. 	 * Very useful after crapping out in raw. 	 */
ifndef|#
directive|ifndef
name|V6
ifdef|#
directive|ifdef
name|TIOCGETC
name|struct
name|tchars
name|tbuf
decl_stmt|;
endif|#
directive|endif
endif|TIOCGETC
ifdef|#
directive|ifdef
name|UCB_NTTY
name|struct
name|ltchars
name|ltc
decl_stmt|;
if|if
condition|(
name|ldisc
operator|==
name|NTTYDISC
condition|)
block|{
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|ltc
argument_list|)
expr_stmt|;
name|ltc
operator|.
name|t_suspc
operator|=
name|CHK
argument_list|(
name|ltc
operator|.
name|t_suspc
argument_list|,
name|CTRL
argument_list|(
literal|'Z'
argument_list|)
argument_list|)
expr_stmt|;
name|ltc
operator|.
name|t_dsuspc
operator|=
name|CHK
argument_list|(
name|ltc
operator|.
name|t_dsuspc
argument_list|,
name|CTRL
argument_list|(
literal|'Y'
argument_list|)
argument_list|)
expr_stmt|;
name|ltc
operator|.
name|t_rprntc
operator|=
name|CHK
argument_list|(
name|ltc
operator|.
name|t_rprntc
argument_list|,
name|CTRL
argument_list|(
literal|'R'
argument_list|)
argument_list|)
expr_stmt|;
name|ltc
operator|.
name|t_flushc
operator|=
name|CHK
argument_list|(
name|ltc
operator|.
name|t_flushc
argument_list|,
name|CTRL
argument_list|(
literal|'O'
argument_list|)
argument_list|)
expr_stmt|;
name|ltc
operator|.
name|t_werasc
operator|=
name|CHK
argument_list|(
name|ltc
operator|.
name|t_werasc
argument_list|,
name|CTRL
argument_list|(
literal|'W'
argument_list|)
argument_list|)
expr_stmt|;
name|ltc
operator|.
name|t_lnextc
operator|=
name|CHK
argument_list|(
name|ltc
operator|.
name|t_lnextc
argument_list|,
name|CTRL
argument_list|(
literal|'V'
argument_list|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|UCB_NTTY
ifndef|#
directive|ifndef
name|USG
ifdef|#
directive|ifdef
name|TIOCGETC
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|tbuf
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|t_intrc
operator|=
name|CHK
argument_list|(
name|tbuf
operator|.
name|t_intrc
argument_list|,
name|CTRL
argument_list|(
literal|'?'
argument_list|)
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|t_quitc
operator|=
name|CHK
argument_list|(
name|tbuf
operator|.
name|t_quitc
argument_list|,
name|CTRL
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|t_startc
operator|=
name|CHK
argument_list|(
name|tbuf
operator|.
name|t_startc
argument_list|,
name|CTRL
argument_list|(
literal|'Q'
argument_list|)
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|t_stopc
operator|=
name|CHK
argument_list|(
name|tbuf
operator|.
name|t_stopc
argument_list|,
name|CTRL
argument_list|(
literal|'S'
argument_list|)
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|t_eofc
operator|=
name|CHK
argument_list|(
name|tbuf
operator|.
name|t_eofc
argument_list|,
name|CTRL
argument_list|(
literal|'D'
argument_list|)
argument_list|)
expr_stmt|;
comment|/* brkc is left alone */
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TIOCGETC
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|RAW
ifdef|#
directive|ifdef
name|CBREAK
operator||
name|CBREAK
endif|#
directive|endif
endif|CBREAK
operator||
name|VTDELAY
operator||
name|ALLDELAY
operator|)
expr_stmt|;
name|mode
operator|.
name|sg_flags
operator||=
name|XTABS
operator||
name|ECHO
operator||
name|CRMOD
operator||
name|ANYP
expr_stmt|;
name|curerase
operator|=
name|CHK
argument_list|(
name|curerase
argument_list|,
name|OLDERASE
argument_list|)
expr_stmt|;
name|curkill
operator|=
name|CHK
argument_list|(
name|curkill
argument_list|,
name|OLDKILL
argument_list|)
expr_stmt|;
else|#
directive|else
else|USG
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
name|curerase
operator|=
name|CHK
argument_list|(
name|curerase
argument_list|,
name|OLDERASE
argument_list|)
expr_stmt|;
name|curkill
operator|=
name|CHK
argument_list|(
name|curkill
argument_list|,
name|OLDKILL
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VINTR
index|]
argument_list|,
name|CTRL
argument_list|(
literal|'?'
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VQUIT
index|]
argument_list|,
name|CTRL
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_cc
index|[
name|VEOF
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VEOF
index|]
argument_list|,
name|CTRL
argument_list|(
literal|'D'
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_iflag
operator||=
operator|(
name|BRKINT
operator||
name|ISTRIP
operator||
name|ICRNL
operator||
name|IXON
operator|)
expr_stmt|;
name|mode
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IGNBRK
operator||
name|PARMRK
operator||
name|INPCK
operator||
name|INLCR
operator||
name|IGNCR
operator||
name|IUCLC
operator||
name|IXOFF
operator|)
expr_stmt|;
name|mode
operator|.
name|c_oflag
operator||=
operator|(
name|OPOST
operator||
name|ONLCR
operator|)
expr_stmt|;
name|mode
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|OLCUC
operator||
name|OCRNL
operator||
name|ONOCR
operator||
name|ONLRET
operator||
name|OFILL
operator||
name|OFDEL
operator||
name|NLDLY
operator||
name|CRDLY
operator||
name|TABDLY
operator||
name|BSDLY
operator||
name|VTDLY
operator||
name|FFDLY
operator|)
expr_stmt|;
name|mode
operator|.
name|c_cflag
operator||=
operator|(
name|CS7
operator||
name|CREAD
operator|)
expr_stmt|;
name|mode
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARODD
operator||
name|CLOCAL
operator|)
expr_stmt|;
name|mode
operator|.
name|c_lflag
operator||=
operator|(
name|ISIG
operator||
name|ICANON
operator||
name|ECHO
operator||
name|ECHOK
operator|)
expr_stmt|;
name|mode
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|XCASE
operator||
name|ECHONL
operator||
name|NOFLSH
operator|)
expr_stmt|;
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|USG
endif|#
directive|endif
endif|V6
name|Dash_u
operator|=
name|YES
expr_stmt|;
name|BeQuiet
operator|=
name|YES
expr_stmt|;
name|IsReset
operator|=
name|YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
name|sequal
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|RepOnly
operator|=
name|YES
expr_stmt|;
name|Dash_u
operator|=
name|YES
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|argc
operator|--
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* scan argument list and collect flags */
end_comment

begin_while
while|while
condition|(
operator|--
name|argc
operator|>=
literal|0
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|p
operator|==
name|NULL
condition|)
name|Report
operator|=
name|YES
expr_stmt|;
comment|/* report current terminal type */
else|else
while|while
condition|(
operator|*
name|p
condition|)
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
ifdef|#
directive|ifdef
name|UCB_NTTY
case|case
literal|'n'
case|:
name|ldisc
operator|=
name|NTTYDISC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"ioctl "
argument_list|,
literal|"new"
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
case|case
literal|'r'
case|:
comment|/* report to user */
name|Ureport
operator|=
name|YES
expr_stmt|;
continue|continue;
case|case
literal|'E'
case|:
comment|/* special erase: operate on all but TTY33 */
name|Specialerase
operator|=
name|YES
expr_stmt|;
comment|/* explicit fall-through to -e case */
case|case
literal|'e'
case|:
comment|/* erase character */
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
name|Erase_char
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|Erase_char
operator|=
name|CTRL
argument_list|(
operator|*
operator|++
name|p
argument_list|)
expr_stmt|;
else|else
name|Erase_char
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
continue|continue;
case|case
literal|'k'
case|:
comment|/* kill character */
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
name|Kill_char
operator|=
name|CTRL
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|Kill_char
operator|=
name|CTRL
argument_list|(
operator|*
operator|++
name|p
argument_list|)
expr_stmt|;
else|else
name|Kill_char
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
continue|continue;
ifdef|#
directive|ifdef
name|OLDFLAGS
ifdef|#
directive|ifdef
name|OLDDIALUP
case|case
literal|'d'
case|:
comment|/* dialup type */
name|NewType
operator|=
name|DIALUP
expr_stmt|;
goto|goto
name|mapold
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OLDPLUGBOARD
case|case
literal|'p'
case|:
comment|/* plugboard type */
name|NewType
operator|=
name|PLUGBOARD
expr_stmt|;
goto|goto
name|mapold
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OLDARPANET
case|case
literal|'a'
case|:
comment|/* arpanet type */
name|Newtype
operator|=
name|ARPANET
expr_stmt|;
goto|goto
name|mapold
goto|;
endif|#
directive|endif
name|mapold
label|:
name|Map
operator|->
name|Ident
operator|=
name|NewType
expr_stmt|;
name|Map
operator|->
name|Test
operator|=
name|ALL
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|nextarg
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
operator|++
argument_list|)
expr_stmt|;
block|}
name|Map
operator|->
name|Type
operator|=
name|p
expr_stmt|;
name|Map
operator|++
expr_stmt|;
name|Mapped
operator|=
name|YES
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
continue|continue;
endif|#
directive|endif
case|case
literal|'m'
case|:
comment|/* map identifier to type */
comment|/* This code is very loose. Almost no 				** syntax checking is done!! However, 				** illegal syntax will only produce 				** weird results. 				*/
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|nextarg
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|Map
operator|->
name|Ident
operator|=
name|p
expr_stmt|;
comment|/* identifier */
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
else|else
name|Map
operator|->
name|Ident
operator|=
literal|""
expr_stmt|;
name|Break
operator|=
name|NO
expr_stmt|;
name|Not
operator|=
name|NO
expr_stmt|;
while|while
condition|(
operator|!
name|Break
condition|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|NULL
case|:
name|p
operator|=
name|nextarg
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
operator|++
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|':'
case|:
comment|/* mapped type */
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
name|Break
operator|=
name|YES
expr_stmt|;
continue|continue;
case|case
literal|'>'
case|:
comment|/* conditional */
name|Map
operator|->
name|Test
operator||=
name|GT
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
literal|'<'
case|:
comment|/* conditional */
name|Map
operator|->
name|Test
operator||=
name|LT
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
literal|'='
case|:
comment|/* conditional */
case|case
literal|'@'
case|:
name|Map
operator|->
name|Test
operator||=
name|EQ
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
literal|'!'
case|:
comment|/* invert conditions */
name|Not
operator|=
operator|~
name|Not
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
literal|'B'
case|:
comment|/* Baud rate */
name|p
operator|++
expr_stmt|;
comment|/* intentional fallthru */
default|default:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'e'
condition|)
block|{
name|Map
operator|->
name|Speed
operator|=
name|baudrate
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'.'
condition|)
name|p
operator|++
expr_stmt|;
block|}
else|else
name|Break
operator|=
name|YES
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|Not
condition|)
comment|/* invert sense of test */
block|{
name|Map
operator|->
name|Test
operator|=
operator|(
operator|~
operator|(
name|Map
operator|->
name|Test
operator|)
operator|)
operator|&
name|ALL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|nextarg
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
operator|++
argument_list|)
expr_stmt|;
block|}
name|Map
operator|->
name|Type
operator|=
name|p
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
name|Map
operator|++
expr_stmt|;
name|Mapped
operator|=
name|YES
expr_stmt|;
continue|continue;
case|case
literal|'h'
case|:
comment|/* don't get type from htmp or env */
name|Dash_h
operator|=
name|YES
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
comment|/* don't update htmp */
name|Dash_u
operator|=
name|YES
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
comment|/* output setenv commands */
name|DoSetenv
operator|=
name|YES
expr_stmt|;
name|CmndLine
operator|=
name|YES
expr_stmt|;
continue|continue;
case|case
literal|'S'
case|:
comment|/* output setenv strings */
name|DoSetenv
operator|=
name|YES
expr_stmt|;
name|CmndLine
operator|=
name|NO
expr_stmt|;
continue|continue;
case|case
literal|'Q'
case|:
comment|/* be quiet */
name|BeQuiet
operator|=
name|YES
expr_stmt|;
continue|continue;
case|case
literal|'I'
case|:
comment|/* no initialization */
name|NoInit
operator|=
name|YES
expr_stmt|;
continue|continue;
case|case
literal|'A'
case|:
comment|/* Ask user */
name|Ask
operator|=
name|YES
expr_stmt|;
continue|continue;
case|case
literal|'v'
case|:
comment|/* no virtual terminal */
name|DoVirtTerm
operator|=
name|NO
expr_stmt|;
continue|continue;
default|default:
operator|*
name|p
operator|--
operator|=
name|NULL
expr_stmt|;
name|fatal
argument_list|(
literal|"Bad flag -"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* terminal type */
name|DefType
operator|=
name|p
expr_stmt|;
block|}
block|}
end_while

begin_if
if|if
condition|(
name|DefType
condition|)
block|{
if|if
condition|(
name|Mapped
condition|)
block|{
name|Map
operator|->
name|Ident
operator|=
literal|""
expr_stmt|;
comment|/* means "map any type" */
name|Map
operator|->
name|Test
operator|=
name|ALL
expr_stmt|;
comment|/* at all baud rates */
name|Map
operator|->
name|Type
operator|=
name|DefType
expr_stmt|;
comment|/* to the default type */
block|}
else|else
name|TtyType
operator|=
name|DefType
expr_stmt|;
block|}
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|V6
end_ifndef

begin_comment
comment|/* 	 * Get rid of $TERMCAP, if it's there, so we get a real 	 * entry from /etc/termcap.  This prevents us from being 	 * fooled by out of date stuff in the environment, and 	 * makes tabs work right on CB/Unix. 	 */
end_comment

begin_expr_stmt
name|bufp
operator|=
name|getenv
argument_list|(
literal|"TERMCAP"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bufp
operator|&&
operator|*
name|bufp
operator|!=
literal|'/'
condition|)
name|strcpy
argument_list|(
name|bufp
operator|-
literal|8
argument_list|,
literal|"NOTHING"
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* overwrite only "TERMCAP" */
end_comment

begin_comment
comment|/* get current idea of terminal type from environment */
end_comment

begin_if
if|if
condition|(
operator|!
name|Dash_h
operator|&&
name|TtyType
operator|==
literal|0
condition|)
name|TtyType
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* determine terminal id if needed */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_if
if|if
condition|(
name|Ttyid
operator|==
name|NOTTY
operator|&&
operator|(
name|TtyType
operator|==
literal|0
operator|||
operator|!
name|Dash_h
operator|||
operator|!
name|Dash_u
operator|)
condition|)
name|Ttyid
operator|=
name|ttyn
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
end_if

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
operator|!
name|RepOnly
operator|&&
name|Ttyid
operator|==
name|NOTTY
operator|&&
operator|(
name|TtyType
operator|==
literal|0
operator|||
operator|!
name|Dash_h
operator|)
condition|)
name|Ttyid
operator|=
name|ttyname
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_comment
comment|/* get htmp if ever used */
end_comment

begin_if
if|if
condition|(
operator|!
name|Dash_u
operator|||
operator|(
name|TtyType
operator|==
literal|0
operator|&&
operator|!
name|Dash_h
operator|)
condition|)
block|{
comment|/* get htmp entry -- if error or wrong user use ttytype */
if|if
condition|(
name|Ttyid
operator|==
name|NOTTY
operator|||
name|hget
argument_list|(
name|Ttyid
argument_list|)
operator|<
literal|0
operator|||
name|hgettype
argument_list|()
operator|==
literal|0
operator|||
name|hgetuid
argument_list|()
operator|!=
operator|(
name|getuid
argument_list|()
operator|&
name|UIDMASK
operator|)
condition|)
name|Dash_h
operator|++
expr_stmt|;
block|}
end_if

begin_comment
comment|/* find terminal type (if not already known) */
end_comment

begin_if
if|if
condition|(
name|TtyType
operator|==
literal|0
operator|&&
operator|!
name|Dash_h
condition|)
block|{
comment|/* get type from /etc/htmp */
name|TtyType
operator|=
name|hsgettype
argument_list|()
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GTTYN
end_ifdef

begin_comment
comment|/* If still undefined, look at /etc/ttytype */
end_comment

begin_if
if|if
condition|(
name|TtyType
operator|==
literal|0
condition|)
block|{
name|TtyType
operator|=
name|stypeof
argument_list|(
name|Ttyid
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If still undefined, use DEFTYPE */
end_comment

begin_if
if|if
condition|(
name|TtyType
operator|==
literal|0
condition|)
block|{
name|TtyType
operator|=
name|DEFTYPE
expr_stmt|;
block|}
end_if

begin_comment
comment|/* check for dialup or other mapping */
end_comment

begin_if
if|if
condition|(
name|Mapped
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|Alias
index|[
literal|0
index|]
operator|&&
name|isalias
argument_list|(
name|TtyType
argument_list|)
operator|)
condition|)
if|if
condition|(
name|tgetent
argument_list|(
name|Capbuf
argument_list|,
name|TtyType
argument_list|)
operator|>
literal|0
condition|)
name|makealias
argument_list|(
name|Capbuf
argument_list|)
expr_stmt|;
name|TtyType
operator|=
name|mapped
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* TtyType now contains a pointer to the type of the terminal */
end_comment

begin_comment
comment|/* If the first character is '?', ask the user */
end_comment

begin_if
if|if
condition|(
name|TtyType
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
name|Ask
operator|=
name|YES
expr_stmt|;
name|TtyType
operator|++
expr_stmt|;
if|if
condition|(
name|TtyType
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|TtyType
operator|=
name|DEFTYPE
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|Ask
condition|)
block|{
name|ask
label|:
name|prs
argument_list|(
literal|"TERM = ("
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
comment|/* read the terminal.  If not empty, set type */
name|i
operator|=
name|read
argument_list|(
literal|2
argument_list|,
name|termbuf
argument_list|,
sizeof|sizeof
name|termbuf
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|termbuf
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|i
operator|--
expr_stmt|;
name|termbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|termbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|TtyType
operator|=
name|termbuf
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* get terminal capabilities */
end_comment

begin_if
if|if
condition|(
operator|!
operator|(
name|Alias
index|[
literal|0
index|]
operator|&&
name|isalias
argument_list|(
name|TtyType
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|tgetent
argument_list|(
name|Capbuf
argument_list|,
name|TtyType
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|prs
argument_list|(
literal|"Cannot find termcap\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|prs
argument_list|(
literal|"Type "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|" unknown\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|DoSetenv
condition|)
block|{
name|TtyType
operator|=
name|DEFTYPE
expr_stmt|;
name|Alias
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|ask
goto|;
block|}
else|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|Ttycap
operator|=
name|Capbuf
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|RepOnly
condition|)
block|{
comment|/* determine erase and kill characters */
if|if
condition|(
name|Specialerase
operator|&&
operator|!
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
name|Erase_char
operator|=
literal|0
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
name|p
operator|=
name|tgetstr
argument_list|(
literal|"kb"
argument_list|,
operator|&
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|p
operator|=
name|tgetstr
argument_list|(
literal|"bc"
argument_list|,
operator|&
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|bs_char
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
name|bs_char
operator|=
name|BACKSPACE
expr_stmt|;
else|else
name|bs_char
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Erase_char
operator|==
literal|0
operator|&&
operator|!
name|tgetflag
argument_list|(
literal|"os"
argument_list|)
operator|&&
name|curerase
operator|==
name|OLDERASE
condition|)
block|{
if|if
condition|(
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
operator|||
name|bs_char
operator|!=
literal|0
condition|)
name|Erase_char
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|Erase_char
operator|<
literal|0
condition|)
name|Erase_char
operator|=
operator|(
name|bs_char
operator|!=
literal|0
operator|)
condition|?
name|bs_char
else|:
name|BACKSPACE
expr_stmt|;
if|if
condition|(
name|curerase
operator|==
literal|0
condition|)
name|curerase
operator|=
name|OLDERASE
expr_stmt|;
if|if
condition|(
name|Erase_char
operator|!=
literal|0
condition|)
name|curerase
operator|=
name|Erase_char
expr_stmt|;
if|if
condition|(
name|curkill
operator|==
literal|0
condition|)
name|curkill
operator|=
name|OLDKILL
expr_stmt|;
if|if
condition|(
name|Kill_char
operator|!=
literal|0
condition|)
name|curkill
operator|=
name|Kill_char
expr_stmt|;
comment|/* set modes */
name|PadBaud
operator|=
name|tgetnum
argument_list|(
literal|"pb"
argument_list|)
expr_stmt|;
comment|/* OK if fails */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|speeds
index|[
name|i
index|]
operator|.
name|string
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|speeds
index|[
name|i
index|]
operator|.
name|baudrate
operator|==
name|PadBaud
condition|)
block|{
name|PadBaud
operator|=
name|speeds
index|[
name|i
index|]
operator|.
name|speed
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|USG
name|setdelay
argument_list|(
literal|"dC"
argument_list|,
name|CRdelay
argument_list|,
name|CRbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dN"
argument_list|,
name|NLdelay
argument_list|,
name|NLbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dB"
argument_list|,
name|BSdelay
argument_list|,
name|BSbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dF"
argument_list|,
name|FFdelay
argument_list|,
name|FFbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dT"
argument_list|,
name|TBdelay
argument_list|,
name|TBbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"UC"
argument_list|)
operator|||
operator|(
name|command
index|[
literal|0
index|]
operator|&
literal|0140
operator|)
operator|==
literal|0100
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|LCASE
expr_stmt|;
elseif|else
if|if
condition|(
name|tgetflag
argument_list|(
literal|"LC"
argument_list|)
condition|)
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|LCASE
expr_stmt|;
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|EVENP
operator||
name|ODDP
operator||
name|RAW
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CBREAK
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|CBREAK
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tgetflag
argument_list|(
literal|"EP"
argument_list|)
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|EVENP
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"OP"
argument_list|)
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|ODDP
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|.
name|sg_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
literal|0
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|EVENP
operator||
name|ODDP
expr_stmt|;
name|mode
operator|.
name|sg_flags
operator||=
name|CRMOD
operator||
name|ECHO
operator||
name|XTABS
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"NL"
argument_list|)
condition|)
comment|/* new line, not line feed */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|CRMOD
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"HD"
argument_list|)
condition|)
comment|/* half duplex */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"pt"
argument_list|)
condition|)
comment|/* print tabs */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|XTABS
expr_stmt|;
else|#
directive|else
name|setdelay
argument_list|(
literal|"dC"
argument_list|,
name|CRdelay
argument_list|,
name|CRbits
argument_list|,
operator|&
name|mode
operator|.
name|c_oflag
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dN"
argument_list|,
name|NLdelay
argument_list|,
name|NLbits
argument_list|,
operator|&
name|mode
operator|.
name|c_oflag
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dB"
argument_list|,
name|BSdelay
argument_list|,
name|BSbits
argument_list|,
operator|&
name|mode
operator|.
name|c_oflag
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dF"
argument_list|,
name|FFdelay
argument_list|,
name|FFbits
argument_list|,
operator|&
name|mode
operator|.
name|c_oflag
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dT"
argument_list|,
name|TBdelay
argument_list|,
name|TBbits
argument_list|,
operator|&
name|mode
operator|.
name|c_oflag
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dV"
argument_list|,
name|VTdelay
argument_list|,
name|VTbits
argument_list|,
operator|&
name|mode
operator|.
name|c_oflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"UC"
argument_list|)
operator|||
operator|(
name|command
index|[
literal|0
index|]
operator|&
literal|0140
operator|)
operator|==
literal|0100
condition|)
block|{
name|mode
operator|.
name|c_iflag
operator||=
name|IUCLC
expr_stmt|;
name|mode
operator|.
name|c_oflag
operator||=
name|OLCUC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tgetflag
argument_list|(
literal|"LC"
argument_list|)
condition|)
block|{
name|mode
operator|.
name|c_iflag
operator|&=
operator|~
name|IUCLC
expr_stmt|;
name|mode
operator|.
name|c_oflag
operator|&=
operator|~
name|OLCUC
expr_stmt|;
block|}
name|mode
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|PARMRK
operator||
name|INPCK
operator|)
expr_stmt|;
name|mode
operator|.
name|c_lflag
operator||=
name|ICANON
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"EP"
argument_list|)
condition|)
block|{
name|mode
operator|.
name|c_cflag
operator||=
name|PARENB
expr_stmt|;
name|mode
operator|.
name|c_cflag
operator|&=
operator|~
name|PARODD
expr_stmt|;
block|}
if|if
condition|(
name|tgetflag
argument_list|(
literal|"OP"
argument_list|)
condition|)
block|{
name|mode
operator|.
name|c_cflag
operator||=
name|PARENB
expr_stmt|;
name|mode
operator|.
name|c_cflag
operator||=
name|PARODD
expr_stmt|;
block|}
name|mode
operator|.
name|c_oflag
operator||=
name|ONLCR
expr_stmt|;
name|mode
operator|.
name|c_iflag
operator||=
name|ICRNL
expr_stmt|;
name|mode
operator|.
name|c_lflag
operator||=
name|ECHO
expr_stmt|;
name|mode
operator|.
name|c_oflag
operator||=
name|TAB3
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"NL"
argument_list|)
condition|)
block|{
comment|/* new line, not line feed */
name|mode
operator|.
name|c_oflag
operator|&=
operator|~
name|ONLCR
expr_stmt|;
name|mode
operator|.
name|c_iflag
operator|&=
operator|~
name|ICRNL
expr_stmt|;
block|}
if|if
condition|(
name|tgetflag
argument_list|(
literal|"HD"
argument_list|)
condition|)
comment|/* half duplex */
name|mode
operator|.
name|c_lflag
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"pt"
argument_list|)
condition|)
comment|/* print tabs */
name|mode
operator|.
name|c_oflag
operator|&=
operator|~
name|TAB3
expr_stmt|;
name|mode
operator|.
name|c_lflag
operator||=
operator|(
name|ECHOE
operator||
name|ECHOK
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CBVIRTTERM
name|HasAM
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|CBVIRTTERM
ifdef|#
directive|ifdef
name|UCB_NTTY
if|if
condition|(
name|ldisc
operator|==
name|NTTYDISC
condition|)
block|{
name|lmode
operator||=
name|LCTLECH
expr_stmt|;
comment|/* display ctrl chars */
if|if
condition|(
name|tgetflag
argument_list|(
literal|"hc"
argument_list|)
condition|)
block|{
comment|/** set printer modes **/
name|lmode
operator|&=
operator|~
operator|(
name|LCRTBS
operator||
name|LCRTERA
operator||
name|LCRTKIL
operator|)
expr_stmt|;
name|lmode
operator||=
name|LPRTERA
expr_stmt|;
block|}
else|else
block|{
comment|/** set crt modes **/
if|if
condition|(
operator|!
name|tgetflag
argument_list|(
literal|"os"
argument_list|)
condition|)
block|{
name|lmode
operator|&=
operator|~
name|LPRTERA
expr_stmt|;
name|lmode
operator||=
name|LCRTBS
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|sg_ospeed
operator|>=
name|B1200
condition|)
name|lmode
operator||=
name|LCRTERA
operator||
name|LCRTKIL
expr_stmt|;
block|}
block|}
block|}
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|lmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* get pad character */
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
name|PC
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|columns
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
name|lines
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
comment|/* Set window size */
if|if
condition|(
name|DoSetenv
condition|)
block|{
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|.
name|ws_row
operator|==
literal|0
operator|&&
name|win
operator|.
name|ws_col
operator|==
literal|0
condition|)
block|{
name|win
operator|.
name|ws_row
operator|=
name|lines
expr_stmt|;
name|win
operator|.
name|ws_col
operator|=
name|columns
expr_stmt|;
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|&
name|win
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* output startup string */
if|if
condition|(
operator|!
name|NoInit
condition|)
block|{
ifndef|#
directive|ifndef
name|USG
if|if
condition|(
name|oldmode
operator|.
name|sg_flags
operator|&
operator|(
name|XTABS
operator||
name|CRMOD
operator|)
condition|)
block|{
name|oldmode
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|XTABS
operator||
name|CRMOD
operator|)
expr_stmt|;
name|setmode
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|oldmode
operator|.
name|c_oflag
operator|&
operator|(
name|TAB3
operator||
name|ONLCR
operator||
name|OCRNL
operator||
name|ONLRET
operator|)
condition|)
block|{
name|oldmode
operator|.
name|c_oflag
operator|&=
operator|(
name|TAB3
operator||
name|ONLCR
operator||
name|OCRNL
operator||
name|ONLRET
operator|)
expr_stmt|;
name|setmode
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CBVIRTTERM
name|block
operator|.
name|st_termt
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|LDSETT
argument_list|,
operator|&
name|block
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|CBVIRTTERM
if|if
condition|(
name|settabs
argument_list|()
condition|)
block|{
name|settle
operator|=
name|YES
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
name|IsReset
condition|?
literal|"rs"
else|:
literal|"is"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tputs
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|prc
argument_list|)
expr_stmt|;
name|settle
operator|=
name|YES
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
name|IsReset
condition|?
literal|"rf"
else|:
literal|"if"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cat
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|settle
operator|=
name|YES
expr_stmt|;
block|}
if|if
condition|(
name|settle
condition|)
block|{
name|prc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* let terminal settle down */
block|}
block|}
ifdef|#
directive|ifdef
name|CBVIRTTERM
if|if
condition|(
name|DoVirtTerm
condition|)
block|{
name|j
operator|=
name|tgetnum
argument_list|(
literal|"vt"
argument_list|)
expr_stmt|;
name|VirTermNo
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vt_map
index|[
name|i
index|]
operator|.
name|stdnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vt_map
index|[
name|i
index|]
operator|.
name|stdnum
operator|==
name|j
condition|)
name|VirTermNo
operator|=
name|vt_map
index|[
name|i
index|]
operator|.
name|localnum
expr_stmt|;
block|}
else|else
name|VirTermNo
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
endif|CBVIRTTERM
name|setmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* set new modes, if they've changed */
comment|/* set up environment for the shell we are using */
comment|/* (this code is rather heuristic, checking for $SHELL */
comment|/* ending in the 3 characters "csh") */
name|csh
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|DoSetenv
condition|)
block|{
ifndef|#
directive|ifndef
name|V6
name|char
modifier|*
name|sh
decl_stmt|;
if|if
condition|(
operator|(
name|sh
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|sh
argument_list|)
operator|)
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|csh
operator|=
name|sequal
argument_list|(
operator|&
name|sh
index|[
name|i
operator|-
literal|3
index|]
argument_list|,
literal|"csh"
argument_list|)
operator|)
operator|&&
name|CmndLine
condition|)
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"set noglob;\n"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|csh
condition|)
endif|#
directive|endif
comment|/* running Bourne shell */
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"export TERMCAP TERM;\n"
argument_list|,
literal|21
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* report type if appropriate */
end_comment

begin_if
if|if
condition|(
name|DoSetenv
operator|||
name|Report
operator|||
name|Ureport
condition|)
block|{
comment|/* if type is the short name, find first alias (if any) */
name|makealias
argument_list|(
name|Ttycap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequal
argument_list|(
name|TtyType
argument_list|,
name|Alias
index|[
literal|0
index|]
argument_list|)
operator|&&
name|Alias
index|[
literal|1
index|]
condition|)
block|{
name|TtyType
operator|=
name|Alias
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|DoSetenv
condition|)
block|{
if|if
condition|(
name|csh
condition|)
block|{
if|if
condition|(
name|CmndLine
condition|)
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"setenv TERM "
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
name|TtyType
argument_list|,
name|strlen
argument_list|(
name|TtyType
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CmndLine
condition|)
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|";\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"TERM="
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
name|TtyType
argument_list|,
name|strlen
argument_list|(
name|TtyType
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|";\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Report
condition|)
block|{
name|write
argument_list|(
name|STDOUT
argument_list|,
name|TtyType
argument_list|,
name|strlen
argument_list|(
name|TtyType
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ureport
condition|)
block|{
name|prs
argument_list|(
literal|"Terminal type is "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|DoSetenv
condition|)
block|{
if|if
condition|(
name|csh
condition|)
block|{
if|if
condition|(
name|CmndLine
condition|)
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"setenv TERMCAP '"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"TERMCAP='"
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|wrtermcap
argument_list|(
name|Ttycap
argument_list|)
expr_stmt|;
if|if
condition|(
name|csh
condition|)
block|{
if|if
condition|(
name|CmndLine
condition|)
block|{
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"';\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"unset noglob;\n"
argument_list|,
literal|14
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"';\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|RepOnly
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* tell about changing erase and kill characters */
end_comment

begin_expr_stmt
name|reportek
argument_list|(
literal|"Erase"
argument_list|,
name|curerase
argument_list|,
name|olderase
argument_list|,
name|OLDERASE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|reportek
argument_list|(
literal|"Kill"
argument_list|,
name|curkill
argument_list|,
name|oldkill
argument_list|,
name|OLDKILL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_comment
comment|/* update htmp */
end_comment

begin_if
if|if
condition|(
operator|!
name|Dash_u
condition|)
block|{
if|if
condition|(
name|Ttyid
operator|==
literal|0
condition|)
name|Ttyid
operator|=
name|ttyn
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ttyid
operator|==
literal|'x'
condition|)
block|{
name|prs
argument_list|(
literal|"Cannot update htmp\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* update htmp file only if changed */
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|Capbuf
argument_list|,
name|hsgettype
argument_list|()
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|hsettype
argument_list|(
name|Capbuf
index|[
literal|0
index|]
operator||
operator|(
name|Capbuf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|hput
argument_list|(
name|Ttyid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * Set the hardware tabs on the terminal, using the ct (clear all tabs),  * st (set one tab) and ch (horizontal cursor addressing) capabilities.  * This is done before if and is, so they can patch in case we blow this.  */
end_comment

begin_expr_stmt
unit|settabs
operator|(
operator|)
block|{
name|char
name|caps
index|[
literal|100
index|]
block|;
name|char
operator|*
name|capsp
operator|=
name|caps
block|;
name|char
operator|*
name|clear_tabs
block|,
operator|*
name|set_tab
block|,
operator|*
name|set_column
block|,
operator|*
name|set_pos
block|;
name|char
operator|*
name|tg_out
block|,
operator|*
name|tgoto
argument_list|()
block|;
name|int
name|c
block|;
name|clear_tabs
operator|=
name|tgetstr
argument_list|(
literal|"ct"
argument_list|,
operator|&
name|capsp
argument_list|)
block|;
name|set_tab
operator|=
name|tgetstr
argument_list|(
literal|"st"
argument_list|,
operator|&
name|capsp
argument_list|)
block|;
name|set_column
operator|=
name|tgetstr
argument_list|(
literal|"ch"
argument_list|,
operator|&
name|capsp
argument_list|)
block|;
if|if
condition|(
name|set_column
operator|==
literal|0
condition|)
name|set_pos
operator|=
name|tgetstr
argument_list|(
literal|"cm"
argument_list|,
operator|&
name|capsp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|clear_tabs
operator|&&
name|set_tab
condition|)
block|{
name|prc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
comment|/* force to be at left margin */
name|tputs
argument_list|(
name|clear_tabs
argument_list|,
literal|0
argument_list|,
name|prc
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|set_tab
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|8
init|;
name|c
operator|<
name|columns
condition|;
name|c
operator|+=
literal|8
control|)
block|{
comment|/* get to that column. */
name|tg_out
operator|=
literal|"OOPS"
expr_stmt|;
comment|/* also returned by tgoto */
if|if
condition|(
name|set_column
condition|)
name|tg_out
operator|=
name|tgoto
argument_list|(
name|set_column
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tg_out
operator|==
literal|'O'
operator|&&
name|set_pos
condition|)
name|tg_out
operator|=
name|tgoto
argument_list|(
name|set_pos
argument_list|,
name|c
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tg_out
operator|!=
literal|'O'
condition|)
name|tputs
argument_list|(
name|tg_out
argument_list|,
literal|1
argument_list|,
name|prc
argument_list|)
expr_stmt|;
else|else
block|{
name|prc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|prc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|prc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|prc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|prc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|prc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|prc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|prc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* set the tab */
name|tputs
argument_list|(
name|set_tab
argument_list|,
literal|0
argument_list|,
name|prc
argument_list|)
expr_stmt|;
block|}
name|prc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_if

begin_return
return|return
literal|0
return|;
end_return

begin_expr_stmt
unit|}  setmode
operator|(
name|flag
operator|)
name|int
name|flag
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* flag serves several purposes:  *	if called as the result of a signal, flag will be> 0.  *	if called from terminal init, flag == -1 means reset "oldmode".  *	called with flag == 0 at end of normal mode processing.  */
end_comment

begin_block
block|{
ifndef|#
directive|ifndef
name|USG
name|struct
name|sgttyb
modifier|*
name|ttymode
decl_stmt|;
else|#
directive|else
name|struct
name|termio
modifier|*
name|ttymode
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag
operator|<
literal|0
condition|)
comment|/* unconditionally reset oldmode (called from init) */
name|ttymode
operator|=
operator|&
name|oldmode
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bequal
argument_list|(
operator|&
name|mode
argument_list|,
operator|&
name|oldmode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
condition|)
name|ttymode
operator|=
operator|&
name|mode
expr_stmt|;
else|else
comment|/* don't need it */
ifndef|#
directive|ifndef
name|USG
name|ttymode
operator|=
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
literal|0
expr_stmt|;
else|#
directive|else
name|ttymode
operator|=
operator|(
expr|struct
name|termio
operator|*
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ttymode
condition|)
block|{
ifdef|#
directive|ifdef
name|USG
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TCSETAW
argument_list|,
name|ttymode
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|V6
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCSETN
argument_list|,
name|ttymode
argument_list|)
expr_stmt|;
comment|/* don't flush */
else|#
directive|else
name|stty
argument_list|(
name|FILEDES
argument_list|,
name|ttymode
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|CBVIRTTERM
if|if
condition|(
name|VirTermNo
operator|!=
operator|-
literal|2
condition|)
block|{
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|r1
operator|=
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|LDGETT
argument_list|,
operator|&
name|block
argument_list|)
expr_stmt|;
name|block
operator|.
name|st_flgs
operator||=
name|TM_SET
expr_stmt|;
name|block
operator|.
name|st_termt
operator|=
name|VirTermNo
expr_stmt|;
if|if
condition|(
name|block
operator|.
name|st_termt
operator|<
literal|0
condition|)
name|block
operator|.
name|st_termt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|HasAM
condition|)
name|block
operator|.
name|st_flgs
operator||=
name|TM_ANL
expr_stmt|;
else|else
name|block
operator|.
name|st_flgs
operator|&=
operator|~
name|TM_ANL
expr_stmt|;
name|r2
operator|=
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|LDSETT
argument_list|,
operator|&
name|block
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|flag
operator|>
literal|0
condition|)
comment|/* trapped signal */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|reportek
argument_list|(
argument|name
argument_list|,
argument|new
argument_list|,
argument|old
argument_list|,
argument|def
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|old
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|new
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|def
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|o
decl_stmt|;
specifier|register
name|char
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
if|if
condition|(
name|BeQuiet
condition|)
return|return;
name|o
operator|=
name|old
expr_stmt|;
name|n
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|n
operator|&&
name|n
operator|==
name|def
condition|)
return|return;
name|prs
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|n
condition|)
name|prs
argument_list|(
literal|" is "
argument_list|)
expr_stmt|;
else|else
name|prs
argument_list|(
literal|" set to "
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"kb"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|>
literal|0
operator|&&
name|n
operator|==
name|buf
index|[
literal|0
index|]
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|prs
argument_list|(
literal|"Backspace\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
literal|0177
condition|)
name|prs
argument_list|(
literal|"Delete\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|n
operator|<
literal|040
condition|)
block|{
name|prs
argument_list|(
literal|"Ctrl-"
argument_list|)
expr_stmt|;
name|n
operator|^=
literal|0100
expr_stmt|;
block|}
name|p
operator|=
literal|"x\n"
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|prs
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|setdelay
argument_list|(
argument|cap
argument_list|,
argument|dtab
argument_list|,
argument|bits
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delay
name|dtab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|delay
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|V6
specifier|extern
name|int
name|ospeed
decl_stmt|;
else|#
directive|else
specifier|extern
name|short
name|ospeed
decl_stmt|;
endif|#
directive|endif
comment|/* see if this capability exists at all */
name|i
operator|=
name|tgetnum
argument_list|(
name|cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* No padding at speeds below PadBaud */
if|if
condition|(
name|PadBaud
operator|>
name|ospeed
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* clear out the bits, replace with new ones */
operator|*
name|flags
operator|&=
operator|~
name|bits
expr_stmt|;
comment|/* scan dtab for first entry with adequate delay */
for|for
control|(
name|p
operator|=
name|dtab
init|;
name|p
operator|->
name|d_delay
operator|>=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|d_delay
operator|>=
name|i
condition|)
block|{
name|p
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* use last entry if none will do */
operator|*
name|flags
operator||=
operator|(
operator|--
name|p
operator|)
operator|->
name|d_bits
expr_stmt|;
block|}
end_block

begin_macro
name|prs
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|prc
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
name|OutBuf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|OutPtr
decl_stmt|;
end_decl_stmt

begin_macro
name|prc
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|OutBuf
index|[
name|OutPtr
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|OutPtr
operator|>=
sizeof|sizeof
name|OutBuf
condition|)
name|flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|flush
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|OutPtr
operator|>
literal|0
condition|)
name|write
argument_list|(
literal|2
argument_list|,
name|OutBuf
argument_list|,
name|OutPtr
argument_list|)
expr_stmt|;
name|OutPtr
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|cat
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|prs
argument_list|(
literal|"Cannot open "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|FILEDES
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bmove
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|length
expr_stmt|;
name|p
operator|=
name|from
expr_stmt|;
name|q
operator|=
name|to
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|bequal
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|len
argument_list|)
end_macro

begin_comment
comment|/* must be same thru len chars */
end_comment

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|a
expr_stmt|;
name|q
operator|=
name|b
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|==
operator|*
name|q
operator|)
operator|&&
operator|--
name|i
operator|>
literal|0
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|*
name|p
operator|==
operator|*
name|q
operator|)
operator|&&
name|i
operator|>=
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|sequal
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_comment
comment|/* must be same thru NULL */
end_comment

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|a
decl_stmt|,
modifier|*
name|q
init|=
name|b
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|q
operator|&&
operator|(
operator|*
name|p
operator|==
operator|*
name|q
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|p
operator|==
operator|*
name|q
operator|)
return|;
block|}
end_block

begin_macro
name|makealias
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|;
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
name|Alias
index|[
literal|0
index|]
operator|=
name|a
operator|=
name|Aliasbuf
expr_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|b
operator|&&
operator|*
name|b
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|b
operator|==
literal|'|'
condition|)
block|{
operator|*
name|a
operator|++
operator|=
name|NULL
expr_stmt|;
name|Alias
index|[
name|i
operator|++
index|]
operator|=
name|a
expr_stmt|;
name|b
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|a
operator|++
operator|=
operator|*
name|b
operator|++
expr_stmt|;
block|}
operator|*
name|a
operator|=
name|NULL
expr_stmt|;
name|Alias
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEB
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Alias
index|[
name|i
index|]
condition|;
name|printf
argument_list|(
literal|"A:%s\n"
argument_list|,
name|Alias
index|[
name|i
operator|++
index|]
argument_list|)
control|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|isalias
argument_list|(
argument|ident
argument_list|)
end_macro

begin_comment
comment|/* is ident same as one of the aliases? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ident
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
name|a
init|=
name|Alias
decl_stmt|;
if|if
condition|(
operator|*
name|a
condition|)
while|while
condition|(
operator|*
name|a
condition|)
if|if
condition|(
name|sequal
argument_list|(
name|ident
argument_list|,
operator|*
name|a
argument_list|)
condition|)
return|return
operator|(
name|YES
operator|)
return|;
else|else
name|a
operator|++
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|GTTYN
end_ifdef

begin_function
name|char
modifier|*
name|stypeof
parameter_list|(
name|ttyid
parameter_list|)
name|char
modifier|*
name|ttyid
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|PortType
decl_stmt|;
specifier|register
name|char
modifier|*
name|PortName
decl_stmt|;
specifier|register
name|char
modifier|*
name|TtyId
decl_stmt|;
name|struct
name|ttyent
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|ttyid
operator|==
name|NOTTY
condition|)
return|return
operator|(
name|DEFTYPE
operator|)
return|;
comment|/* split off end of name */
name|TtyId
operator|=
name|ttyid
expr_stmt|;
while|while
condition|(
operator|*
name|ttyid
condition|)
if|if
condition|(
operator|*
name|ttyid
operator|++
operator|==
literal|'/'
condition|)
name|TtyId
operator|=
name|ttyid
expr_stmt|;
comment|/* scan the file */
if|if
condition|(
operator|(
name|t
operator|=
name|getttynam
argument_list|(
name|TtyId
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PortType
operator|=
name|t
operator|->
name|ty_type
expr_stmt|;
comment|/* get aliases from termcap entry */
if|if
condition|(
name|Mapped
operator|&&
name|tgetent
argument_list|(
name|Capbuf
argument_list|,
name|PortType
argument_list|)
operator|>
literal|0
condition|)
block|{
name|makealias
argument_list|(
name|Capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequal
argument_list|(
name|Alias
index|[
literal|0
index|]
argument_list|,
name|PortType
argument_list|)
operator|&&
name|Alias
index|[
literal|1
index|]
condition|)
name|PortType
operator|=
name|Alias
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
operator|(
name|PortType
operator|)
return|;
block|}
return|return
operator|(
name|DEFTYPE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * routine to output the string for the environment TERMCAP variable  */
end_comment

begin_define
define|#
directive|define
name|WHITE
parameter_list|(
name|c
parameter_list|)
value|(c == ' ' || c == '\t')
end_define

begin_decl_stmt
name|char
name|delcap
index|[
literal|128
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ncap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|wrtermcap
argument_list|(
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|CAPBUFSIZ
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|putbuf
parameter_list|()
function_decl|;
name|int
name|space
decl_stmt|,
name|empty
decl_stmt|;
comment|/* discard names with blanks */
comment|/** May not be desireable ? **/
while|while
condition|(
operator|*
name|bp
operator|&&
operator|*
name|bp
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'|'
condition|)
block|{
name|tp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|space
operator|=
name|NO
expr_stmt|;
while|while
condition|(
operator|*
name|tp
operator|&&
operator|*
name|tp
operator|!=
literal|'|'
operator|&&
operator|*
name|tp
operator|!=
literal|':'
condition|)
block|{
name|space
operator|=
operator|(
name|space
operator|||
name|WHITE
argument_list|(
operator|*
name|tp
argument_list|)
operator|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|space
condition|)
block|{
name|bp
operator|=
name|tp
expr_stmt|;
continue|continue;
block|}
block|}
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
block|}
comment|/**/
ifdef|#
directive|ifdef
name|CBVIRTTERM
if|if
condition|(
name|VirTermNo
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|":am"
argument_list|)
expr_stmt|;
comment|/* All virt terms have auto margins */
name|cancelled
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|*
name|bp
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
condition|)
block|{
case|case
literal|':'
case|:
comment|/* discard empty, cancelled  or dupl fields */
name|tp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|empty
operator|=
name|YES
expr_stmt|;
while|while
condition|(
operator|*
name|tp
operator|&&
operator|*
name|tp
operator|!=
literal|':'
condition|)
block|{
name|empty
operator|=
operator|(
name|empty
operator|&&
name|WHITE
argument_list|(
operator|*
name|tp
argument_list|)
operator|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CBVIRTTERM
comment|/* 			 * Virtual terminals use ic, not im or ei.  Turn 			 * any of them into ic - duplicates will be cancelled 			 * below.  I assume that terminals needing im+ic+ei 			 * are handled by the kernel. 			 */
if|if
condition|(
name|VirTermNo
operator|>
literal|0
operator|&&
operator|!
name|HasAM
operator|&&
operator|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'m'
operator|||
name|bp
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'i'
operator|)
condition|)
block|{
name|bp
index|[
literal|1
index|]
operator|=
literal|'i'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'c'
expr_stmt|;
block|}
if|if
condition|(
name|VirTermNo
operator|>
literal|0
operator|&&
operator|!
name|HasAM
operator|&&
operator|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'c'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'s'
operator|)
condition|)
block|{
name|bp
index|[
literal|1
index|]
operator|=
literal|'d'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'l'
expr_stmt|;
comment|/* Also need al, so kludge: */
if|if
condition|(
operator|!
name|cancelled
argument_list|(
literal|"al"
argument_list|)
condition|)
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|":al=\033\120"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|CBVIRTTERM
if|if
condition|(
name|empty
operator|||
name|cancelled
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
condition|)
block|{
name|bp
operator|=
name|tp
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|CBVIRTTERM
if|if
condition|(
name|VirTermNo
operator|>
literal|0
operator|&&
operator|!
name|HasAM
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vtab
index|[
name|i
index|]
operator|.
name|value
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vtab
index|[
name|i
index|]
operator|.
name|cap
index|[
literal|0
index|]
operator|==
name|bp
index|[
literal|1
index|]
operator|&&
name|vtab
index|[
name|i
index|]
operator|.
name|cap
index|[
literal|1
index|]
operator|==
name|bp
index|[
literal|2
index|]
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
comment|/* colon */
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
comment|/* first char */
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
comment|/* second "   */
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
comment|/* = sign */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
name|vtab
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|bp
operator|=
name|tp
expr_stmt|;
goto|goto
name|contin
goto|;
block|}
block|}
endif|#
directive|endif
endif|CBVIRTTERM
break|break;
case|case
literal|' '
case|:
comment|/* no spaces in output */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\040"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'!'
case|:
comment|/* the shell thinks this is history */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\041"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|','
case|:
comment|/* the shell thinks this is history */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\054"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'"'
case|:
comment|/* no quotes in output */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\042"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\''
case|:
comment|/* no quotes in output */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\047"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'`'
case|:
comment|/* no back quotes in output */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\140"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
case|case
literal|'^'
case|:
comment|/* anything following is OK */
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CBVIRTTERM
if|if
condition|(
operator|*
name|bp
operator|==
literal|'E'
operator|&&
name|VirTermNo
operator|>
literal|0
operator|&&
operator|(
name|bp
index|[
operator|-
literal|3
index|]
operator|!=
literal|'\\'
operator|||
name|bp
index|[
operator|-
literal|2
index|]
operator|!=
literal|'E'
operator|)
operator|&&
operator|(
name|bp
index|[
literal|1
index|]
operator|!=
literal|'\\'
operator|||
name|bp
index|[
literal|2
index|]
operator|!=
literal|'E'
operator|)
condition|)
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"E\\"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|CBVIRTTERM
block|}
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|contin
label|:
empty_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
comment|/* we skipped the last : with the : lookahead hack */
name|write
argument_list|(
name|STDOUT
argument_list|,
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cancelled
argument_list|(
argument|cap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncap
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cap
index|[
literal|0
index|]
operator|==
name|delcap
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&&
name|cap
index|[
literal|1
index|]
operator|==
name|delcap
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|YES
operator|)
return|;
block|}
comment|/* delete a second occurrance of the same capability */
name|delcap
index|[
name|ncap
index|]
index|[
literal|0
index|]
operator|=
name|cap
index|[
literal|0
index|]
expr_stmt|;
name|delcap
index|[
name|ncap
index|]
index|[
literal|1
index|]
operator|=
name|cap
index|[
literal|1
index|]
expr_stmt|;
name|ncap
operator|++
expr_stmt|;
return|return
operator|(
name|cap
index|[
literal|2
index|]
operator|==
literal|'@'
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|putbuf
parameter_list|(
name|ptr
parameter_list|,
name|str
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'\033'
case|:
name|ptr
operator|=
name|putbuf
argument_list|(
name|ptr
argument_list|,
literal|"\\E"
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|*
name|str
operator|<=
literal|' '
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\\%03o"
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|putbuf
argument_list|(
name|ptr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|ptr
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_macro
name|baudrate
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
literal|7
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|)
condition|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|speeds
index|[
name|i
index|]
operator|.
name|string
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sequal
argument_list|(
name|speeds
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|buf
argument_list|)
condition|)
return|return
operator|(
name|speeds
index|[
name|i
index|]
operator|.
name|speed
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|mapped
parameter_list|(
name|type
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|V6
specifier|extern
name|int
name|ospeed
decl_stmt|;
else|#
directive|else
specifier|extern
name|short
name|ospeed
decl_stmt|;
endif|#
directive|endif
name|int
name|match
decl_stmt|;
ifdef|#
directive|ifdef
name|DEB
name|printf
argument_list|(
literal|"spd:%d\n"
argument_list|,
name|ospeed
argument_list|)
expr_stmt|;
name|prmap
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|Map
operator|=
name|map
expr_stmt|;
while|while
condition|(
name|Map
operator|->
name|Ident
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|Map
operator|->
name|Ident
operator|)
operator|==
name|NULL
operator|||
name|sequal
argument_list|(
name|Map
operator|->
name|Ident
argument_list|,
name|type
argument_list|)
operator|||
name|isalias
argument_list|(
name|Map
operator|->
name|Ident
argument_list|)
condition|)
block|{
name|match
operator|=
name|NO
expr_stmt|;
switch|switch
condition|(
name|Map
operator|->
name|Test
condition|)
block|{
case|case
name|ANY
case|:
comment|/* no test specified */
case|case
name|ALL
case|:
name|match
operator|=
name|YES
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|match
operator|=
operator|(
name|ospeed
operator|>
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|match
operator|=
operator|(
name|ospeed
operator|>=
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|match
operator|=
operator|(
name|ospeed
operator|==
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|match
operator|=
operator|(
name|ospeed
operator|<=
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|match
operator|=
operator|(
name|ospeed
operator|<
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|match
operator|=
operator|(
name|ospeed
operator|!=
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|match
condition|)
return|return
operator|(
name|Map
operator|->
name|Type
operator|)
return|;
block|}
name|Map
operator|++
expr_stmt|;
block|}
comment|/* no match found; return given type */
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEB
end_ifdef

begin_macro
name|prmap
argument_list|()
end_macro

begin_block
block|{
name|Map
operator|=
name|map
expr_stmt|;
while|while
condition|(
name|Map
operator|->
name|Ident
condition|)
block|{
name|printf
argument_list|(
literal|"%s t:%d s:%d %s\n"
argument_list|,
name|Map
operator|->
name|Ident
argument_list|,
name|Map
operator|->
name|Test
argument_list|,
name|Map
operator|->
name|Speed
argument_list|,
name|Map
operator|->
name|Type
argument_list|)
expr_stmt|;
name|Map
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|nextarg
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Too few args: "
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|*
operator|++
name|argv
operator|)
operator|==
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"Unexpected arg: "
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|argv
operator|)
return|;
block|}
end_function

begin_macro
name|fatal
argument_list|(
argument|mesg
argument_list|,
argument|obj
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mesg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|obj
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|prs
argument_list|(
name|mesg
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|prc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

