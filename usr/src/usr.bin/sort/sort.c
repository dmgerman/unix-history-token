begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)sort.c	4.16 (Berkeley) 8/30/89"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_define
define|#
directive|define
name|L
value|4096
end_define

begin_define
define|#
directive|define
name|N
value|7
end_define

begin_define
define|#
directive|define
name|C
value|20
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|pdp11
end_ifndef

begin_define
define|#
directive|define
name|MEM
value|(128*2048)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MEM
value|(16*2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NF
value|10
end_define

begin_define
define|#
directive|define
name|rline
parameter_list|(
name|mp
parameter_list|)
value|(fgets((mp)->l, L, (mp)->b) == NULL)
end_define

begin_decl_stmt
name|FILE
modifier|*
name|is
decl_stmt|,
modifier|*
name|os
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dirtry
index|[]
init|=
block|{
name|_PATH_TMP1
block|,
name|_PATH_TMP2
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|dirs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|file1
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|file
init|=
name|file1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|nlines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|ntext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|lspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmp
argument_list|()
decl_stmt|,
name|cmpa
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|()
init|=
name|cmpa
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|eol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|term
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|mflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|outfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unsafeout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*kludge to assure -m -o works*/
end_comment

begin_decl_stmt
name|char
name|tabchar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|eargc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|eargv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|zero
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|fold
index|[
literal|256
index|]
init|=
block|{
literal|0200
block|,
literal|0201
block|,
literal|0202
block|,
literal|0203
block|,
literal|0204
block|,
literal|0205
block|,
literal|0206
block|,
literal|0207
block|,
literal|0210
block|,
literal|0211
block|,
literal|0212
block|,
literal|0213
block|,
literal|0214
block|,
literal|0215
block|,
literal|0216
block|,
literal|0217
block|,
literal|0220
block|,
literal|0221
block|,
literal|0222
block|,
literal|0223
block|,
literal|0224
block|,
literal|0225
block|,
literal|0226
block|,
literal|0227
block|,
literal|0230
block|,
literal|0231
block|,
literal|0232
block|,
literal|0233
block|,
literal|0234
block|,
literal|0235
block|,
literal|0236
block|,
literal|0237
block|,
literal|0240
block|,
literal|0241
block|,
literal|0242
block|,
literal|0243
block|,
literal|0244
block|,
literal|0245
block|,
literal|0246
block|,
literal|0247
block|,
literal|0250
block|,
literal|0251
block|,
literal|0252
block|,
literal|0253
block|,
literal|0254
block|,
literal|0255
block|,
literal|0256
block|,
literal|0257
block|,
literal|0260
block|,
literal|0261
block|,
literal|0262
block|,
literal|0263
block|,
literal|0264
block|,
literal|0265
block|,
literal|0266
block|,
literal|0267
block|,
literal|0270
block|,
literal|0271
block|,
literal|0272
block|,
literal|0273
block|,
literal|0274
block|,
literal|0275
block|,
literal|0276
block|,
literal|0277
block|,
literal|0300
block|,
literal|0301
block|,
literal|0302
block|,
literal|0303
block|,
literal|0304
block|,
literal|0305
block|,
literal|0306
block|,
literal|0307
block|,
literal|0310
block|,
literal|0311
block|,
literal|0312
block|,
literal|0313
block|,
literal|0314
block|,
literal|0315
block|,
literal|0316
block|,
literal|0317
block|,
literal|0320
block|,
literal|0321
block|,
literal|0322
block|,
literal|0323
block|,
literal|0324
block|,
literal|0325
block|,
literal|0326
block|,
literal|0327
block|,
literal|0330
block|,
literal|0331
block|,
literal|0332
block|,
literal|0333
block|,
literal|0334
block|,
literal|0335
block|,
literal|0336
block|,
literal|0337
block|,
literal|0340
block|,
literal|0341
block|,
literal|0342
block|,
literal|0343
block|,
literal|0344
block|,
literal|0345
block|,
literal|0346
block|,
literal|0347
block|,
literal|0350
block|,
literal|0351
block|,
literal|0352
block|,
literal|0353
block|,
literal|0354
block|,
literal|0355
block|,
literal|0356
block|,
literal|0357
block|,
literal|0360
block|,
literal|0361
block|,
literal|0362
block|,
literal|0363
block|,
literal|0364
block|,
literal|0365
block|,
literal|0366
block|,
literal|0367
block|,
literal|0370
block|,
literal|0371
block|,
literal|0372
block|,
literal|0373
block|,
literal|0374
block|,
literal|0375
block|,
literal|0376
block|,
literal|0377
block|,
literal|0000
block|,
literal|0001
block|,
literal|0002
block|,
literal|0003
block|,
literal|0004
block|,
literal|0005
block|,
literal|0006
block|,
literal|0007
block|,
literal|0010
block|,
literal|0011
block|,
literal|0012
block|,
literal|0013
block|,
literal|0014
block|,
literal|0015
block|,
literal|0016
block|,
literal|0017
block|,
literal|0020
block|,
literal|0021
block|,
literal|0022
block|,
literal|0023
block|,
literal|0024
block|,
literal|0025
block|,
literal|0026
block|,
literal|0027
block|,
literal|0030
block|,
literal|0031
block|,
literal|0032
block|,
literal|0033
block|,
literal|0034
block|,
literal|0035
block|,
literal|0036
block|,
literal|0037
block|,
literal|0040
block|,
literal|0041
block|,
literal|0042
block|,
literal|0043
block|,
literal|0044
block|,
literal|0045
block|,
literal|0046
block|,
literal|0047
block|,
literal|0050
block|,
literal|0051
block|,
literal|0052
block|,
literal|0053
block|,
literal|0054
block|,
literal|0055
block|,
literal|0056
block|,
literal|0057
block|,
literal|0060
block|,
literal|0061
block|,
literal|0062
block|,
literal|0063
block|,
literal|0064
block|,
literal|0065
block|,
literal|0066
block|,
literal|0067
block|,
literal|0070
block|,
literal|0071
block|,
literal|0072
block|,
literal|0073
block|,
literal|0074
block|,
literal|0075
block|,
literal|0076
block|,
literal|0077
block|,
literal|0100
block|,
literal|0101
block|,
literal|0102
block|,
literal|0103
block|,
literal|0104
block|,
literal|0105
block|,
literal|0106
block|,
literal|0107
block|,
literal|0110
block|,
literal|0111
block|,
literal|0112
block|,
literal|0113
block|,
literal|0114
block|,
literal|0115
block|,
literal|0116
block|,
literal|0117
block|,
literal|0120
block|,
literal|0121
block|,
literal|0122
block|,
literal|0123
block|,
literal|0124
block|,
literal|0125
block|,
literal|0126
block|,
literal|0127
block|,
literal|0130
block|,
literal|0131
block|,
literal|0132
block|,
literal|0133
block|,
literal|0134
block|,
literal|0135
block|,
literal|0136
block|,
literal|0137
block|,
literal|0140
block|,
literal|0101
block|,
literal|0102
block|,
literal|0103
block|,
literal|0104
block|,
literal|0105
block|,
literal|0106
block|,
literal|0107
block|,
literal|0110
block|,
literal|0111
block|,
literal|0112
block|,
literal|0113
block|,
literal|0114
block|,
literal|0115
block|,
literal|0116
block|,
literal|0117
block|,
literal|0120
block|,
literal|0121
block|,
literal|0122
block|,
literal|0123
block|,
literal|0124
block|,
literal|0125
block|,
literal|0126
block|,
literal|0127
block|,
literal|0130
block|,
literal|0131
block|,
literal|0132
block|,
literal|0173
block|,
literal|0174
block|,
literal|0175
block|,
literal|0176
block|,
literal|0177
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|nofold
index|[
literal|256
index|]
init|=
block|{
literal|0200
block|,
literal|0201
block|,
literal|0202
block|,
literal|0203
block|,
literal|0204
block|,
literal|0205
block|,
literal|0206
block|,
literal|0207
block|,
literal|0210
block|,
literal|0211
block|,
literal|0212
block|,
literal|0213
block|,
literal|0214
block|,
literal|0215
block|,
literal|0216
block|,
literal|0217
block|,
literal|0220
block|,
literal|0221
block|,
literal|0222
block|,
literal|0223
block|,
literal|0224
block|,
literal|0225
block|,
literal|0226
block|,
literal|0227
block|,
literal|0230
block|,
literal|0231
block|,
literal|0232
block|,
literal|0233
block|,
literal|0234
block|,
literal|0235
block|,
literal|0236
block|,
literal|0237
block|,
literal|0240
block|,
literal|0241
block|,
literal|0242
block|,
literal|0243
block|,
literal|0244
block|,
literal|0245
block|,
literal|0246
block|,
literal|0247
block|,
literal|0250
block|,
literal|0251
block|,
literal|0252
block|,
literal|0253
block|,
literal|0254
block|,
literal|0255
block|,
literal|0256
block|,
literal|0257
block|,
literal|0260
block|,
literal|0261
block|,
literal|0262
block|,
literal|0263
block|,
literal|0264
block|,
literal|0265
block|,
literal|0266
block|,
literal|0267
block|,
literal|0270
block|,
literal|0271
block|,
literal|0272
block|,
literal|0273
block|,
literal|0274
block|,
literal|0275
block|,
literal|0276
block|,
literal|0277
block|,
literal|0300
block|,
literal|0301
block|,
literal|0302
block|,
literal|0303
block|,
literal|0304
block|,
literal|0305
block|,
literal|0306
block|,
literal|0307
block|,
literal|0310
block|,
literal|0311
block|,
literal|0312
block|,
literal|0313
block|,
literal|0314
block|,
literal|0315
block|,
literal|0316
block|,
literal|0317
block|,
literal|0320
block|,
literal|0321
block|,
literal|0322
block|,
literal|0323
block|,
literal|0324
block|,
literal|0325
block|,
literal|0326
block|,
literal|0327
block|,
literal|0330
block|,
literal|0331
block|,
literal|0332
block|,
literal|0333
block|,
literal|0334
block|,
literal|0335
block|,
literal|0336
block|,
literal|0337
block|,
literal|0340
block|,
literal|0341
block|,
literal|0342
block|,
literal|0343
block|,
literal|0344
block|,
literal|0345
block|,
literal|0346
block|,
literal|0347
block|,
literal|0350
block|,
literal|0351
block|,
literal|0352
block|,
literal|0353
block|,
literal|0354
block|,
literal|0355
block|,
literal|0356
block|,
literal|0357
block|,
literal|0360
block|,
literal|0361
block|,
literal|0362
block|,
literal|0363
block|,
literal|0364
block|,
literal|0365
block|,
literal|0366
block|,
literal|0367
block|,
literal|0370
block|,
literal|0371
block|,
literal|0372
block|,
literal|0373
block|,
literal|0374
block|,
literal|0375
block|,
literal|0376
block|,
literal|0377
block|,
literal|0000
block|,
literal|0001
block|,
literal|0002
block|,
literal|0003
block|,
literal|0004
block|,
literal|0005
block|,
literal|0006
block|,
literal|0007
block|,
literal|0010
block|,
literal|0011
block|,
literal|0012
block|,
literal|0013
block|,
literal|0014
block|,
literal|0015
block|,
literal|0016
block|,
literal|0017
block|,
literal|0020
block|,
literal|0021
block|,
literal|0022
block|,
literal|0023
block|,
literal|0024
block|,
literal|0025
block|,
literal|0026
block|,
literal|0027
block|,
literal|0030
block|,
literal|0031
block|,
literal|0032
block|,
literal|0033
block|,
literal|0034
block|,
literal|0035
block|,
literal|0036
block|,
literal|0037
block|,
literal|0040
block|,
literal|0041
block|,
literal|0042
block|,
literal|0043
block|,
literal|0044
block|,
literal|0045
block|,
literal|0046
block|,
literal|0047
block|,
literal|0050
block|,
literal|0051
block|,
literal|0052
block|,
literal|0053
block|,
literal|0054
block|,
literal|0055
block|,
literal|0056
block|,
literal|0057
block|,
literal|0060
block|,
literal|0061
block|,
literal|0062
block|,
literal|0063
block|,
literal|0064
block|,
literal|0065
block|,
literal|0066
block|,
literal|0067
block|,
literal|0070
block|,
literal|0071
block|,
literal|0072
block|,
literal|0073
block|,
literal|0074
block|,
literal|0075
block|,
literal|0076
block|,
literal|0077
block|,
literal|0100
block|,
literal|0101
block|,
literal|0102
block|,
literal|0103
block|,
literal|0104
block|,
literal|0105
block|,
literal|0106
block|,
literal|0107
block|,
literal|0110
block|,
literal|0111
block|,
literal|0112
block|,
literal|0113
block|,
literal|0114
block|,
literal|0115
block|,
literal|0116
block|,
literal|0117
block|,
literal|0120
block|,
literal|0121
block|,
literal|0122
block|,
literal|0123
block|,
literal|0124
block|,
literal|0125
block|,
literal|0126
block|,
literal|0127
block|,
literal|0130
block|,
literal|0131
block|,
literal|0132
block|,
literal|0133
block|,
literal|0134
block|,
literal|0135
block|,
literal|0136
block|,
literal|0137
block|,
literal|0140
block|,
literal|0141
block|,
literal|0142
block|,
literal|0143
block|,
literal|0144
block|,
literal|0145
block|,
literal|0146
block|,
literal|0147
block|,
literal|0150
block|,
literal|0151
block|,
literal|0152
block|,
literal|0153
block|,
literal|0154
block|,
literal|0155
block|,
literal|0156
block|,
literal|0157
block|,
literal|0160
block|,
literal|0161
block|,
literal|0162
block|,
literal|0163
block|,
literal|0164
block|,
literal|0165
block|,
literal|0166
block|,
literal|0167
block|,
literal|0170
block|,
literal|0171
block|,
literal|0172
block|,
literal|0173
block|,
literal|0174
block|,
literal|0175
block|,
literal|0176
block|,
literal|0177
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|nonprint
index|[
literal|256
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dict
index|[
literal|256
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|field
block|{
name|char
modifier|*
name|code
decl_stmt|;
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|nflg
decl_stmt|;
name|int
name|rflg
decl_stmt|;
name|int
name|bflg
index|[
literal|2
index|]
decl_stmt|;
name|int
name|m
index|[
literal|2
index|]
decl_stmt|;
name|int
name|n
index|[
literal|2
index|]
decl_stmt|;
block|}
name|fields
index|[
name|NF
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|field
name|proto
init|=
block|{
name|nofold
operator|+
literal|128
block|,
name|zero
operator|+
literal|128
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfields
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|error
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|setfil
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|brk
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|blank
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|a
expr_stmt|;
specifier|extern
name|char
name|end
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|struct
name|field
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|copyproto
argument_list|()
expr_stmt|;
name|eargv
operator|=
name|argv
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
for|for
control|(
name|arg
operator|=
operator|*
name|argv
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|arg
condition|)
block|{
case|case
literal|'\0'
case|:
if|if
condition|(
name|arg
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
condition|)
name|eargv
index|[
name|eargc
operator|++
index|]
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
name|outfil
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
if|if
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
name|dirtry
index|[
literal|0
index|]
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
continue|continue;
default|default:
name|field
argument_list|(
operator|++
operator|*
name|argv
argument_list|,
name|nfields
operator|>
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
operator|++
name|nfields
operator|>=
name|NF
condition|)
block|{
name|diag
argument_list|(
literal|"too many keys"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|copyproto
argument_list|()
expr_stmt|;
name|field
argument_list|(
operator|++
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|eargv
index|[
name|eargc
operator|++
index|]
operator|=
operator|*
name|argv
expr_stmt|;
block|}
name|q
operator|=
operator|&
name|fields
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|a
operator|=
literal|1
init|;
name|a
operator|<=
name|nfields
condition|;
name|a
operator|++
control|)
block|{
name|p
operator|=
operator|&
name|fields
index|[
name|a
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|code
operator|!=
name|proto
operator|.
name|code
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|ignore
operator|!=
name|proto
operator|.
name|ignore
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|nflg
operator|!=
name|proto
operator|.
name|nflg
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|rflg
operator|!=
name|proto
operator|.
name|rflg
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|bflg
index|[
literal|0
index|]
operator|!=
name|proto
operator|.
name|bflg
index|[
literal|0
index|]
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|bflg
index|[
literal|1
index|]
operator|!=
name|proto
operator|.
name|bflg
index|[
literal|1
index|]
condition|)
continue|continue;
name|p
operator|->
name|code
operator|=
name|q
operator|->
name|code
expr_stmt|;
name|p
operator|->
name|ignore
operator|=
name|q
operator|->
name|ignore
expr_stmt|;
name|p
operator|->
name|nflg
operator|=
name|q
operator|->
name|nflg
expr_stmt|;
name|p
operator|->
name|rflg
operator|=
name|q
operator|->
name|rflg
expr_stmt|;
name|p
operator|->
name|bflg
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|bflg
index|[
literal|1
index|]
operator|=
name|q
operator|->
name|bflg
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|eargc
operator|==
literal|0
condition|)
name|eargv
index|[
name|eargc
operator|++
index|]
operator|=
literal|"-"
expr_stmt|;
if|if
condition|(
name|cflg
operator|&&
name|eargc
operator|>
literal|1
condition|)
block|{
name|diag
argument_list|(
literal|"can check only 1 file"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|safeoutfil
argument_list|()
expr_stmt|;
name|ep
operator|=
name|end
operator|+
name|MEM
expr_stmt|;
name|lspace
operator|=
operator|(
name|int
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|int
operator|)
name|brk
argument_list|(
name|ep
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ep
operator|-=
literal|512
expr_stmt|;
ifndef|#
directive|ifndef
name|vax
name|brk
argument_list|(
name|ep
operator|-=
literal|512
argument_list|)
expr_stmt|;
comment|/* for recursion */
endif|#
directive|endif
name|a
operator|=
name|ep
operator|-
operator|(
name|char
operator|*
operator|)
name|lspace
expr_stmt|;
name|nlines
operator|=
operator|(
name|a
operator|-
name|L
operator|)
expr_stmt|;
name|nlines
operator|/=
operator|(
literal|5
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|)
expr_stmt|;
name|ntext
operator|=
name|nlines
operator|*
literal|4
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|tspace
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lspace
operator|+
name|nlines
operator|)
expr_stmt|;
name|a
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|dirs
operator|=
name|dirtry
init|;
operator|*
name|dirs
condition|;
name|dirs
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|filep
operator|=
name|file1
argument_list|,
literal|"%s/stm%05uaa"
argument_list|,
operator|*
name|dirs
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|filep
condition|)
name|filep
operator|++
expr_stmt|;
name|filep
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0600
argument_list|)
operator|)
operator|>=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|a
operator|<
literal|0
condition|)
block|{
name|diag
argument_list|(
literal|"can't locate temp"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|nfiles
operator|=
name|eargc
expr_stmt|;
if|if
condition|(
operator|!
name|mflg
operator|&&
operator|!
name|cflg
condition|)
block|{
name|sort
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|a
operator|=
name|mflg
operator||
name|cflg
condition|?
literal|0
else|:
name|eargc
init|;
name|a
operator|+
name|N
operator|<
name|nfiles
operator|||
name|unsafeout
operator|&&
name|a
operator|<
name|eargc
condition|;
name|a
operator|=
name|i
control|)
block|{
name|i
operator|=
name|a
operator|+
name|N
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|nfiles
condition|)
name|i
operator|=
name|nfiles
expr_stmt|;
name|newfile
argument_list|()
expr_stmt|;
name|merge
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|!=
name|nfiles
condition|)
block|{
name|oldfile
argument_list|()
expr_stmt|;
name|merge
argument_list|(
name|a
argument_list|,
name|nfiles
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|term
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|sort
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|lp
decl_stmt|;
specifier|register
name|lines
operator|,
name|text
operator|,
name|len
expr_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|setfil
argument_list|(
name|i
operator|++
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|is
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|is
operator|=
name|fopen
argument_list|(
name|f
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|cant
argument_list|(
name|f
argument_list|)
expr_stmt|;
do|do
block|{
name|cp
operator|=
name|tspace
expr_stmt|;
name|lp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|lspace
expr_stmt|;
name|lines
operator|=
name|nlines
expr_stmt|;
name|text
operator|=
name|ntext
expr_stmt|;
while|while
condition|(
name|lines
operator|>
literal|0
operator|&&
name|text
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|cp
argument_list|,
name|L
argument_list|,
name|is
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|eargc
condition|)
block|{
operator|++
name|done
expr_stmt|;
break|break;
block|}
name|fclose
argument_list|(
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|setfil
argument_list|(
name|i
operator|++
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|is
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|is
operator|=
name|fopen
argument_list|(
name|f
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|cant
argument_list|(
name|f
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|lp
operator|++
operator|=
name|cp
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* null terminate */
if|if
condition|(
name|cp
index|[
name|len
operator|-
literal|2
index|]
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|len
operator|==
name|L
condition|)
block|{
name|diag
argument_list|(
literal|"line too long (skipped): "
argument_list|,
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|is
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
comment|/* throw it away */
empty_stmt|;
operator|--
name|lp
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|diag
argument_list|(
literal|"missing newline before EOF in "
argument_list|,
name|f
condition|?
name|f
else|:
literal|"standard input"
argument_list|)
expr_stmt|;
comment|/* be friendly, append a newline */
operator|++
name|len
expr_stmt|;
name|cp
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|cp
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
operator|--
name|lines
expr_stmt|;
name|text
operator|-=
name|len
expr_stmt|;
block|}
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|lspace
argument_list|,
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
operator|==
literal|0
operator|||
name|nfiles
operator|!=
name|eargc
condition|)
name|newfile
argument_list|()
expr_stmt|;
else|else
name|oldfile
argument_list|()
expr_stmt|;
name|clearerr
argument_list|(
name|os
argument_list|)
expr_stmt|;
while|while
condition|(
name|lp
operator|>
operator|(
name|char
operator|*
operator|*
operator|)
name|lspace
condition|)
block|{
name|cp
operator|=
operator|*
operator|--
name|lp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
name|fputs
argument_list|(
name|cp
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|os
argument_list|)
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|term
argument_list|()
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|done
operator|==
literal|0
condition|)
do|;
block|}
end_block

begin_struct
struct|struct
name|merg
block|{
name|char
name|l
index|[
name|L
index|]
decl_stmt|;
name|FILE
modifier|*
name|b
decl_stmt|;
block|}
modifier|*
name|ibuf
index|[
literal|256
index|]
struct|;
end_struct

begin_macro
name|merge
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_block
block|{
name|struct
name|merg
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|struct
name|merg
modifier|*
modifier|*
name|ip
decl_stmt|,
modifier|*
name|jp
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|,
name|l
decl_stmt|;
name|int
name|muflg
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|merg
operator|*
operator|)
name|lspace
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|a
init|;
name|i
operator|<
name|b
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|setfil
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
name|p
operator|->
name|b
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|->
name|b
operator|=
name|fopen
argument_list|(
name|f
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|cant
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|j
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|rline
argument_list|(
name|p
argument_list|)
condition|)
name|j
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
do|do
block|{
name|i
operator|=
name|j
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|ibuf
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|ibuf
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|cp
operator|=
name|ibuf
index|[
name|i
index|]
operator|->
name|l
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|l
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rline
argument_list|(
name|ibuf
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|k
operator|=
name|i
expr_stmt|;
while|while
condition|(
operator|++
name|k
operator|<
name|j
condition|)
name|ibuf
index|[
name|k
operator|-
literal|1
index|]
operator|=
name|ibuf
index|[
name|k
index|]
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|l
condition|)
do|;
name|clearerr
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|muflg
operator|=
name|mflg
operator|&
name|uflg
operator||
name|cflg
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|cp
operator|=
name|ibuf
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|l
expr_stmt|;
if|if
condition|(
operator|!
name|cflg
operator|&&
operator|(
name|uflg
operator|==
literal|0
operator|||
name|muflg
operator|||
name|i
operator|==
literal|1
operator|||
call|(
modifier|*
name|compare
call|)
argument_list|(
name|ibuf
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|l
argument_list|,
name|ibuf
index|[
name|i
operator|-
literal|2
index|]
operator|->
name|l
argument_list|)
operator|)
condition|)
block|{
name|fputs
argument_list|(
name|cp
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|os
argument_list|)
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|term
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|muflg
condition|)
block|{
name|cp
operator|=
name|ibuf
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|l
expr_stmt|;
name|dp
operator|=
name|p
operator|->
name|l
expr_stmt|;
do|do
block|{ 			}
do|while
condition|(
operator|(
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
do|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|rline
argument_list|(
name|ibuf
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|muflg
operator|=
name|uflg
expr_stmt|;
block|}
name|ip
operator|=
operator|&
name|ibuf
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|ip
operator|>
name|ibuf
operator|&&
call|(
modifier|*
name|compare
call|)
argument_list|(
name|ip
index|[
literal|0
index|]
operator|->
name|l
argument_list|,
name|ip
index|[
operator|-
literal|1
index|]
operator|->
name|l
argument_list|)
operator|<
literal|0
condition|)
block|{
name|jp
operator|=
operator|*
name|ip
expr_stmt|;
operator|*
name|ip
operator|=
operator|*
operator|(
name|ip
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|ip
operator|-
literal|1
operator|)
operator|=
name|jp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|muflg
condition|)
break|break;
name|j
operator|=
call|(
modifier|*
name|compare
call|)
argument_list|(
name|ibuf
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|l
argument_list|,
name|p
operator|->
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflg
condition|)
block|{
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|disorder
argument_list|(
literal|"disorder:"
argument_list|,
name|ibuf
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|l
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uflg
operator|&&
name|j
operator|==
literal|0
condition|)
name|disorder
argument_list|(
literal|"nonunique:"
argument_list|,
name|ibuf
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|0
condition|)
continue|continue;
break|break;
block|}
block|}
name|p
operator|=
operator|(
expr|struct
name|merg
operator|*
operator|)
name|lspace
expr_stmt|;
for|for
control|(
name|i
operator|=
name|a
init|;
name|i
operator|<
name|b
condition|;
name|i
operator|++
control|)
block|{
name|fclose
argument_list|(
name|p
operator|->
name|b
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|eargc
condition|)
name|unlink
argument_list|(
name|setfil
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|disorder
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|t
init|;
operator|*
name|u
operator|!=
literal|'\n'
condition|;
name|u
operator|++
control|)
empty_stmt|;
operator|*
name|u
operator|=
literal|0
expr_stmt|;
name|diag
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|term
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|newfile
argument_list|()
end_macro

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|setfil
argument_list|(
name|nfiles
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|f
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|!
operator|(
name|os
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|diag
argument_list|(
literal|"can't create "
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|term
argument_list|()
expr_stmt|;
block|}
operator|++
name|nfiles
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|setfil
parameter_list|(
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
name|eargc
condition|)
if|if
condition|(
name|eargv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|eargv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|eargv
index|[
name|i
index|]
operator|)
return|;
name|i
operator|-=
name|eargc
expr_stmt|;
name|filep
index|[
literal|0
index|]
operator|=
name|i
operator|/
literal|26
operator|+
literal|'a'
expr_stmt|;
name|filep
index|[
literal|1
index|]
operator|=
name|i
operator|%
literal|26
operator|+
literal|'a'
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_macro
name|oldfile
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|outfil
condition|)
block|{
if|if
condition|(
operator|(
name|os
operator|=
name|fopen
argument_list|(
name|outfil
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|diag
argument_list|(
literal|"can't create "
argument_list|,
name|outfil
argument_list|)
expr_stmt|;
name|term
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|os
operator|=
name|stdout
expr_stmt|;
block|}
end_block

begin_macro
name|safeoutfil
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|stat
name|obuf
decl_stmt|,
name|ibuf
decl_stmt|;
if|if
condition|(
operator|!
name|mflg
operator|||
name|outfil
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|stat
argument_list|(
name|outfil
argument_list|,
operator|&
name|obuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|eargc
operator|-
name|N
init|;
name|i
operator|<
name|eargc
condition|;
name|i
operator|++
control|)
block|{
comment|/*-N is suff., not nec.*/
if|if
condition|(
name|stat
argument_list|(
name|eargv
index|[
name|i
index|]
argument_list|,
operator|&
name|ibuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|obuf
operator|.
name|st_dev
operator|==
name|ibuf
operator|.
name|st_dev
operator|&&
name|obuf
operator|.
name|st_ino
operator|==
name|ibuf
operator|.
name|st_ino
condition|)
name|unsafeout
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|cant
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|perror
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|term
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|diag
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fputs
argument_list|(
literal|"sort: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|s
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|t
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|term
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfiles
operator|==
name|eargc
condition|)
name|nfiles
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|eargc
init|;
name|i
operator|<=
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
comment|/*<= in case of interrupt*/
name|unlink
argument_list|(
name|setfil
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/*with nfiles not updated*/
block|}
name|_exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cmp
argument_list|(
argument|i
argument_list|,
argument|j
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|pa
decl_stmt|,
modifier|*
name|pb
decl_stmt|;
name|char
modifier|*
name|skip
parameter_list|()
function_decl|;
name|char
modifier|*
name|code
decl_stmt|,
modifier|*
name|ignore
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
name|int
name|k
decl_stmt|;
name|char
modifier|*
name|la
decl_stmt|,
modifier|*
name|lb
decl_stmt|;
specifier|register
name|int
name|sa
decl_stmt|;
name|int
name|sb
decl_stmt|;
name|char
modifier|*
name|ipa
decl_stmt|,
modifier|*
name|ipb
decl_stmt|,
modifier|*
name|jpa
decl_stmt|,
modifier|*
name|jpb
decl_stmt|;
name|struct
name|field
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|k
operator|=
name|nfields
operator|>
literal|0
init|;
name|k
operator|<=
name|nfields
condition|;
name|k
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|fields
index|[
name|k
index|]
expr_stmt|;
name|pa
operator|=
name|i
expr_stmt|;
name|pb
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|k
condition|)
block|{
name|la
operator|=
name|skip
argument_list|(
name|pa
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pa
operator|=
name|skip
argument_list|(
name|pa
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lb
operator|=
name|skip
argument_list|(
name|pb
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pb
operator|=
name|skip
argument_list|(
name|pb
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|la
operator|=
name|eol
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|lb
operator|=
name|eol
argument_list|(
name|pb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|nflg
condition|)
block|{
if|if
condition|(
name|tabchar
condition|)
block|{
if|if
condition|(
name|pa
operator|<
name|la
operator|&&
operator|*
name|pa
operator|==
name|tabchar
condition|)
name|pa
operator|++
expr_stmt|;
if|if
condition|(
name|pb
operator|<
name|lb
operator|&&
operator|*
name|pb
operator|==
name|tabchar
condition|)
name|pb
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|blank
argument_list|(
operator|*
name|pa
argument_list|)
condition|)
name|pa
operator|++
expr_stmt|;
while|while
condition|(
name|blank
argument_list|(
operator|*
name|pb
argument_list|)
condition|)
name|pb
operator|++
expr_stmt|;
name|sa
operator|=
name|sb
operator|=
name|fp
operator|->
name|rflg
expr_stmt|;
if|if
condition|(
operator|*
name|pa
operator|==
literal|'-'
condition|)
block|{
name|pa
operator|++
expr_stmt|;
name|sa
operator|=
operator|-
name|sa
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pb
operator|==
literal|'-'
condition|)
block|{
name|pb
operator|++
expr_stmt|;
name|sb
operator|=
operator|-
name|sb
expr_stmt|;
block|}
for|for
control|(
name|ipa
operator|=
name|pa
init|;
name|ipa
operator|<
name|la
operator|&&
name|isdigit
argument_list|(
operator|*
name|ipa
argument_list|)
condition|;
name|ipa
operator|++
control|)
empty_stmt|;
for|for
control|(
name|ipb
operator|=
name|pb
init|;
name|ipb
operator|<
name|lb
operator|&&
name|isdigit
argument_list|(
operator|*
name|ipb
argument_list|)
condition|;
name|ipb
operator|++
control|)
empty_stmt|;
name|jpa
operator|=
name|ipa
expr_stmt|;
name|jpb
operator|=
name|ipb
expr_stmt|;
name|a
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sa
operator|==
name|sb
condition|)
while|while
condition|(
name|ipa
operator|>
name|pa
operator|&&
name|ipb
operator|>
name|pb
condition|)
if|if
condition|(
name|b
operator|=
operator|*
operator|--
name|ipb
operator|-
operator|*
operator|--
name|ipa
condition|)
name|a
operator|=
name|b
expr_stmt|;
while|while
condition|(
name|ipa
operator|>
name|pa
condition|)
if|if
condition|(
operator|*
operator|--
name|ipa
operator|!=
literal|'0'
condition|)
return|return
operator|(
operator|-
name|sa
operator|)
return|;
while|while
condition|(
name|ipb
operator|>
name|pb
condition|)
if|if
condition|(
operator|*
operator|--
name|ipb
operator|!=
literal|'0'
condition|)
return|return
operator|(
name|sb
operator|)
return|;
if|if
condition|(
name|a
condition|)
return|return
operator|(
name|a
operator|*
name|sa
operator|)
return|;
if|if
condition|(
operator|*
operator|(
name|pa
operator|=
name|jpa
operator|)
operator|==
literal|'.'
condition|)
name|pa
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|pb
operator|=
name|jpb
operator|)
operator|==
literal|'.'
condition|)
name|pb
operator|++
expr_stmt|;
if|if
condition|(
name|sa
operator|==
name|sb
condition|)
while|while
condition|(
name|pa
operator|<
name|la
operator|&&
name|isdigit
argument_list|(
operator|*
name|pa
argument_list|)
operator|&&
name|pb
operator|<
name|lb
operator|&&
name|isdigit
argument_list|(
operator|*
name|pb
argument_list|)
condition|)
if|if
condition|(
name|a
operator|=
operator|*
name|pb
operator|++
operator|-
operator|*
name|pa
operator|++
condition|)
return|return
operator|(
name|a
operator|*
name|sa
operator|)
return|;
while|while
condition|(
name|pa
operator|<
name|la
operator|&&
name|isdigit
argument_list|(
operator|*
name|pa
argument_list|)
condition|)
if|if
condition|(
operator|*
name|pa
operator|++
operator|!=
literal|'0'
condition|)
return|return
operator|(
operator|-
name|sa
operator|)
return|;
while|while
condition|(
name|pb
operator|<
name|lb
operator|&&
name|isdigit
argument_list|(
operator|*
name|pb
argument_list|)
condition|)
if|if
condition|(
operator|*
name|pb
operator|++
operator|!=
literal|'0'
condition|)
return|return
operator|(
name|sb
operator|)
return|;
continue|continue;
block|}
name|code
operator|=
name|fp
operator|->
name|code
expr_stmt|;
name|ignore
operator|=
name|fp
operator|->
name|ignore
expr_stmt|;
name|loop
label|:
while|while
condition|(
name|ignore
index|[
operator|*
name|pa
index|]
condition|)
name|pa
operator|++
expr_stmt|;
while|while
condition|(
name|ignore
index|[
operator|*
name|pb
index|]
condition|)
name|pb
operator|++
expr_stmt|;
if|if
condition|(
name|pa
operator|>=
name|la
operator|||
operator|*
name|pa
operator|==
literal|'\n'
condition|)
if|if
condition|(
name|pb
operator|<
name|lb
operator|&&
operator|*
name|pb
operator|!=
literal|'\n'
condition|)
return|return
operator|(
name|fp
operator|->
name|rflg
operator|)
return|;
else|else
continue|continue;
if|if
condition|(
name|pb
operator|>=
name|lb
operator|||
operator|*
name|pb
operator|==
literal|'\n'
condition|)
return|return
operator|(
operator|-
name|fp
operator|->
name|rflg
operator|)
return|;
if|if
condition|(
operator|(
name|sa
operator|=
name|code
index|[
operator|*
name|pb
operator|++
index|]
operator|-
name|code
index|[
operator|*
name|pa
operator|++
index|]
operator|)
operator|==
literal|0
condition|)
goto|goto
name|loop
goto|;
return|return
operator|(
name|sa
operator|*
name|fp
operator|->
name|rflg
operator|)
return|;
block|}
if|if
condition|(
name|uflg
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|cmpa
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|cmpa
argument_list|(
name|pa
argument_list|,
name|pb
argument_list|)
specifier|register
name|char
operator|*
name|pa
operator|,
operator|*
name|pb
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|pa
operator|==
operator|*
name|pb
condition|)
block|{
if|if
condition|(
operator|*
name|pa
operator|++
operator|==
literal|'\n'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pb
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|pa
operator|==
literal|'\n'
condition|?
name|fields
index|[
literal|0
index|]
operator|.
name|rflg
else|:
operator|*
name|pb
operator|==
literal|'\n'
condition|?
operator|-
name|fields
index|[
literal|0
index|]
operator|.
name|rflg
else|:
operator|*
name|pb
operator|>
operator|*
name|pa
condition|?
name|fields
index|[
literal|0
index|]
operator|.
name|rflg
else|:
operator|-
name|fields
index|[
literal|0
index|]
operator|.
name|rflg
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|skip
parameter_list|(
name|pp
parameter_list|,
name|fp
parameter_list|,
name|j
parameter_list|)
name|struct
name|field
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|pp
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pp
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|fp
operator|->
name|m
index|[
name|j
index|]
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|eol
argument_list|(
name|p
argument_list|)
operator|)
return|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tabchar
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
name|tabchar
condition|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
else|else
goto|goto
name|ret
goto|;
if|if
condition|(
name|i
operator|>
literal|0
operator|||
name|j
operator|==
literal|0
condition|)
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|blank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|blank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
else|else
goto|goto
name|ret
goto|;
block|}
block|}
if|if
condition|(
name|tabchar
operator|==
literal|0
operator|||
name|fp
operator|->
name|bflg
index|[
name|j
index|]
condition|)
while|while
condition|(
name|blank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|i
operator|=
name|fp
operator|->
name|n
index|[
name|j
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
else|else
goto|goto
name|ret
goto|;
block|}
name|ret
label|:
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|eol
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|copyproto
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|proto
expr_stmt|;
name|q
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|fields
index|[
name|nfields
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|proto
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|field
argument_list|(
argument|s
argument_list|,
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|field
modifier|*
name|p
decl_stmt|;
specifier|register
name|d
expr_stmt|;
name|p
operator|=
operator|&
name|fields
index|[
name|nfields
index|]
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|0
condition|;
name|s
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
return|return;
case|case
literal|'b'
case|:
name|p
operator|->
name|bflg
index|[
name|k
index|]
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|p
operator|->
name|ignore
operator|=
name|dict
operator|+
literal|128
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|p
operator|->
name|code
operator|=
name|fold
operator|+
literal|128
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|p
operator|->
name|ignore
operator|=
name|nonprint
operator|+
literal|128
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cflg
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'m'
case|:
name|mflg
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|p
operator|->
name|nflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tabchar
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|tabchar
operator|==
literal|0
condition|)
name|s
operator|--
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|p
operator|->
name|rflg
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
name|uflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
name|p
operator|->
name|m
index|[
name|k
index|]
operator|==
operator|-
literal|1
condition|)
comment|/* -m.n with m missing */
name|p
operator|->
name|m
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
name|d
operator|=
operator|&
name|fields
index|[
literal|0
index|]
operator|.
name|n
index|[
literal|0
index|]
operator|-
operator|&
name|fields
index|[
literal|0
index|]
operator|.
name|m
index|[
literal|0
index|]
expr_stmt|;
default|default:
name|p
operator|->
name|m
index|[
name|k
operator|+
name|d
index|]
operator|=
name|number
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
name|compare
operator|=
name|cmp
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|number
argument_list|(
argument|ppa
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ppa
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|pa
decl_stmt|;
name|pa
operator|=
operator|*
name|ppa
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|pa
argument_list|)
condition|)
block|{
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|*
name|pa
operator|-
literal|'0'
expr_stmt|;
operator|*
name|ppa
operator|=
name|pa
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|qsexc
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
value|t= *p;*p= *q;*q=t
end_define

begin_define
define|#
directive|define
name|qstexc
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|,
name|r
parameter_list|)
value|t= *p;*p= *r;*r= *q;*q=t
end_define

begin_macro
name|qsort
argument_list|(
argument|a
argument_list|,
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|i
decl_stmt|,
modifier|*
modifier|*
name|j
decl_stmt|;
name|char
modifier|*
modifier|*
name|k
decl_stmt|;
name|char
modifier|*
modifier|*
name|lp
decl_stmt|,
modifier|*
modifier|*
name|hp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|start
label|:
if|if
condition|(
operator|(
name|n
operator|=
name|l
operator|-
name|a
operator|)
operator|<=
literal|1
condition|)
return|return;
name|n
operator|/=
literal|2
expr_stmt|;
name|hp
operator|=
name|lp
operator|=
name|a
operator|+
name|n
expr_stmt|;
name|i
operator|=
name|a
expr_stmt|;
name|j
operator|=
name|l
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|<
name|lp
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
call|(
modifier|*
name|compare
call|)
argument_list|(
operator|*
name|i
argument_list|,
operator|*
name|lp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|--
name|lp
expr_stmt|;
name|qsexc
argument_list|(
name|i
argument_list|,
name|lp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
block|}
name|loop
label|:
if|if
condition|(
name|j
operator|>
name|hp
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
call|(
modifier|*
name|compare
call|)
argument_list|(
operator|*
name|hp
argument_list|,
operator|*
name|j
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|hp
expr_stmt|;
name|qsexc
argument_list|(
name|hp
argument_list|,
name|j
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|lp
condition|)
block|{
operator|++
name|hp
expr_stmt|;
name|qstexc
argument_list|(
name|i
argument_list|,
name|hp
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|i
operator|=
operator|++
name|lp
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|qsexc
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
operator|--
name|j
expr_stmt|;
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
operator|--
name|j
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|i
operator|==
name|lp
condition|)
block|{
if|if
condition|(
name|uflg
condition|)
for|for
control|(
name|k
operator|=
name|lp
operator|+
literal|1
init|;
name|k
operator|<=
name|hp
condition|;
control|)
operator|*
operator|*
name|k
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lp
operator|-
name|a
operator|>=
name|l
operator|-
name|hp
condition|)
block|{
name|qsort
argument_list|(
name|hp
operator|+
literal|1
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|lp
expr_stmt|;
block|}
else|else
block|{
name|qsort
argument_list|(
name|a
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|a
operator|=
name|hp
operator|+
literal|1
expr_stmt|;
block|}
goto|goto
name|start
goto|;
block|}
operator|--
name|lp
expr_stmt|;
name|qstexc
argument_list|(
name|j
argument_list|,
name|lp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
operator|--
name|hp
expr_stmt|;
block|}
block|}
end_block

end_unit

