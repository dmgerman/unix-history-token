begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)sigretro.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"sigretro.h"
end_include

begin_comment
comment|/*  * Retrofit new signal interface to old signal primitives.  * Supported routines:  *	sigsys(sig, func)  *	sigset(sig, func)  *	sighold(sig)  *	sigrelse(sig)  *	sigignore(sig)  *	sigpause(sig)  * Also,  *	sigchild()  *		to set all held signals to ignored signals in the  *		child process after fork(2)  */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|sigtype
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_decl_stmt
name|sigtype
name|sigdisp
argument_list|()
decl_stmt|,
name|sighold
argument_list|()
decl_stmt|,
name|sigignore
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following helps us keep the extended signal semantics together.  * We remember for each signal the address of the function we're  * supposed to call.  s_func is SIG_DFL / SIG_IGN if appropriate.  */
end_comment

begin_struct
struct|struct
name|sigtable
block|{
name|sigtype
name|s_func
decl_stmt|;
comment|/* What to call */
name|int
name|s_flag
decl_stmt|;
comment|/* Signal flags; see below */
block|}
name|sigtable
index|[
name|NSIG
operator|+
literal|1
index|]
struct|;
end_struct

begin_comment
comment|/*  * Signal flag values.  */
end_comment

begin_define
define|#
directive|define
name|SHELD
value|1
end_define

begin_comment
comment|/* Signal is being held */
end_comment

begin_define
define|#
directive|define
name|SDEFER
value|2
end_define

begin_comment
comment|/* Signal occured while held */
end_comment

begin_define
define|#
directive|define
name|SSET
value|4
end_define

begin_comment
comment|/* s_func is believable */
end_comment

begin_define
define|#
directive|define
name|SPAUSE
value|8
end_define

begin_comment
comment|/* are pausing, waiting for sig */
end_comment

begin_decl_stmt
name|jmp_buf
name|_pause
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For doing sigpause() */
end_comment

begin_comment
comment|/*  * Approximate sigsys() system call  * This is almost useless since one only calls sigsys()  * in the child of a vfork().  If you have vfork(), you have new signals  * anyway.  The real sigsys() does all the stuff needed to support  * the real sigset() library.  We don't bother here, assuming that  * you are either ignoring or defaulting a signal in the child.  */
end_comment

begin_function
name|sigtype
name|sigsys
parameter_list|(
name|sig
parameter_list|,
name|func
parameter_list|)
name|sigtype
name|func
decl_stmt|;
block|{
name|sigtype
name|old
decl_stmt|;
name|old
operator|=
name|sigdisp
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the (permanent) disposition of a signal.  * If the signal is subsequently (or even now) held,  * the action you set here can be enabled using sigrelse().  */
end_comment

begin_function
name|sigtype
name|sigset
parameter_list|(
name|sig
parameter_list|,
name|func
parameter_list|)
name|sigtype
name|func
decl_stmt|;
block|{
name|sigtype
name|old
decl_stmt|;
name|int
name|_sigtramp
parameter_list|()
function_decl|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|sig
operator|<
literal|1
operator|||
name|sig
operator|>
name|NSIG
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|BADSIG
operator|)
return|;
block|}
name|old
operator|=
name|sigdisp
argument_list|(
name|sig
argument_list|)
expr_stmt|;
comment|/* 	 * Does anyone actually call sigset with SIG_HOLD!? 	 */
if|if
condition|(
name|func
operator|==
name|SIG_HOLD
condition|)
block|{
name|sighold
argument_list|(
name|sig
argument_list|)
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator||=
name|SSET
expr_stmt|;
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_func
operator|=
name|func
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|SIG_DFL
condition|)
block|{
comment|/* 		 * If signal has been held, must retain 		 * the catch so that we can note occurrance 		 * of signal. 		 */
if|if
condition|(
operator|(
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&
name|SHELD
operator|)
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
else|else
name|signal
argument_list|(
name|sig
argument_list|,
name|_sigtramp
argument_list|)
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
if|if
condition|(
name|func
operator|==
name|SIG_IGN
condition|)
block|{
comment|/* 		 * Clear pending signal 		 */
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&=
operator|~
name|SDEFER
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
name|signal
argument_list|(
name|sig
argument_list|,
name|_sigtramp
argument_list|)
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hold a signal.  * This CAN be tricky if the signal's disposition is SIG_DFL.  * In that case, we still catch the signal so we can note it  * happened and do something crazy later.  */
end_comment

begin_function
name|sigtype
name|sighold
parameter_list|(
name|sig
parameter_list|)
block|{
name|sigtype
name|old
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|sig
operator|<
literal|1
operator|||
name|sig
operator|>
name|NSIG
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|BADSIG
operator|)
return|;
block|}
name|old
operator|=
name|sigdisp
argument_list|(
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&
name|SHELD
condition|)
return|return
operator|(
name|old
operator|)
return|;
comment|/* 	 * When the default action is required, we have to 	 * set up to catch the signal to note signal's occurrance. 	 */
if|if
condition|(
name|old
operator|==
name|SIG_DFL
condition|)
block|{
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator||=
name|SSET
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|_sigtramp
argument_list|)
expr_stmt|;
block|}
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator||=
name|SHELD
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a signal  * If the signal occurred while we had it held, cause the signal.  */
end_comment

begin_function
name|sigtype
name|sigrelse
parameter_list|(
name|sig
parameter_list|)
block|{
name|sigtype
name|old
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|int
name|_sigtramp
parameter_list|()
function_decl|;
if|if
condition|(
name|sig
operator|<
literal|1
operator|||
name|sig
operator|>
name|NSIG
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|BADSIG
operator|)
return|;
block|}
name|old
operator|=
name|sigdisp
argument_list|(
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&
name|SHELD
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|old
operator|)
return|;
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&=
operator|~
name|SHELD
expr_stmt|;
if|if
condition|(
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&
name|SDEFER
condition|)
name|_sigtramp
argument_list|(
name|sig
argument_list|)
expr_stmt|;
comment|/* 	 * If disposition was the default, then we can unset the 	 * catch to _sigtramp() and let the system do the work. 	 */
if|if
condition|(
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_func
operator|==
name|SIG_DFL
condition|)
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ignore a signal.  */
end_comment

begin_function
name|sigtype
name|sigignore
parameter_list|(
name|sig
parameter_list|)
block|{
return|return
operator|(
name|sigset
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pause, waiting for sig to occur.  * We assume LUSER called us with the signal held.  * When we got the signal, mark the signal as having  * occurred.  It will actually cause something when  * the signal is released.  *  * This is probably useless without job control anyway.  */
end_comment

begin_macro
name|sigpause
argument_list|(
argument|sig
argument_list|)
end_macro

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|sig
operator|<
literal|1
operator|||
name|sig
operator|>
name|NSIG
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator||=
name|SHELD
operator||
name|SPAUSE
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|_pause
argument_list|)
operator|==
literal|0
condition|)
name|pause
argument_list|()
expr_stmt|;
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&=
operator|~
name|SPAUSE
expr_stmt|;
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator||=
name|SDEFER
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * In the child process after fork(2), set the disposition of all held  * signals to SIG_IGN.  This is a new procedure not in the real sigset()  * package, provided for retrofitting purposes.  */
end_comment

begin_macro
name|sigchild
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NSIG
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sigtable
index|[
name|i
index|]
operator|.
name|s_flag
operator|&
name|SHELD
condition|)
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return the current disposition of a signal  * If we have not set this signal before, we have to  * ask the system  */
end_comment

begin_function
name|sigtype
name|sigdisp
parameter_list|(
name|sig
parameter_list|)
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|sigtype
name|old
decl_stmt|;
if|if
condition|(
name|sig
operator|<
literal|1
operator|||
name|sig
operator|>
name|NSIG
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|BADSIG
operator|)
return|;
block|}
comment|/* 	 * If we have no knowledge of this signal, 	 * ask the system, then save the result for later. 	 */
if|if
condition|(
operator|(
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&
name|SSET
operator|)
operator|==
literal|0
condition|)
block|{
name|old
operator|=
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_func
operator|=
name|old
expr_stmt|;
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator||=
name|SSET
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|old
argument_list|)
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
comment|/* 	 * If we have set this signal before, then sigset() 	 * will have been careful to leave something meaningful 	 * in s_func. 	 */
return|return
operator|(
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_func
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The following routine gets called for any signal  * that is to be trapped to a user function.  */
end_comment

begin_macro
name|_sigtramp
argument_list|(
argument|sig
argument_list|)
end_macro

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|sigtype
name|old
decl_stmt|;
if|if
condition|(
name|sig
operator|<
literal|1
operator|||
name|sig
operator|>
name|NSIG
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|top
label|:
name|old
operator|=
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* 	 * If signal being paused on, wakeup sigpause() 	 */
if|if
condition|(
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&
name|SPAUSE
condition|)
name|longjmp
argument_list|(
name|_pause
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If signal being held, mark its table entry 	 * so we can trigger it when signal released. 	 * Then just return. 	 */
if|if
condition|(
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&
name|SHELD
condition|)
block|{
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator||=
name|SDEFER
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|_sigtramp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the signal is being ignored, just return. 	 * This would make SIGCONT more normal, but of course 	 * any system with SIGCONT also has the new signal pkg, so... 	 */
if|if
condition|(
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_func
operator|==
name|SIG_IGN
condition|)
return|return;
comment|/* 	 * If the signal is SIG_DFL, then we probably got here 	 * by holding the signal, having it happen, then releasing 	 * the signal.  I wonder if a process is allowed to send 	 * a signal to itself? 	 */
if|if
condition|(
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_func
operator|==
name|SIG_DFL
condition|)
block|{
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|sig
argument_list|)
expr_stmt|;
comment|/* Will we get back here? */
return|return;
block|}
comment|/* 	 * Looks like we should just cause the signal... 	 * We hold the signal for the duration of the user's 	 * code with the signal re-enabled.  If the signal 	 * happens again while in user code, we will recursively 	 * trap here and mark that we had another occurance 	 * and return to the user's trap code.  When we return 	 * from there, we can cause the signal again. 	 */
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&=
operator|~
name|SDEFER
expr_stmt|;
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator||=
name|SHELD
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|_sigtramp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_func
operator|)
operator|(
name|sig
operator|)
expr_stmt|;
comment|/* 	 * If the signal re-occurred while in the user's routine, 	 * just go try it again... 	 */
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&=
operator|~
name|SHELD
expr_stmt|;
if|if
condition|(
name|sigtable
index|[
name|sig
index|]
operator|.
name|s_flag
operator|&
name|SDEFER
condition|)
goto|goto
name|top
goto|;
block|}
end_block

end_unit

