begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)optim.c	5.8 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * Mail -- a program for sending and receiving mail.  *  * Network name modification routines.  */
end_comment

begin_include
include|#
directive|include
file|"rcv.h"
end_include

begin_include
include|#
directive|include
file|"configdefs.h"
end_include

begin_comment
comment|/*  * Map a name into the correct network "view" of the  * name.  This is done by prepending the name with the  * network address of the sender, then optimizing away  * nonsense.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|netmap
argument_list|(
name|name
argument_list|,
name|from
argument_list|)
name|char
name|name
index|[]
decl_stmt|,
name|from
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|nbuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|ret
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|from
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|name
operator|)
return|;
if|if
condition|(
name|any
argument_list|(
literal|'@'
argument_list|,
name|name
argument_list|)
operator|||
name|any
argument_list|(
literal|'%'
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|savestr
argument_list|(
name|arpafix
argument_list|(
name|name
argument_list|,
name|from
argument_list|)
argument_list|)
operator|)
return|;
name|cp
operator|=
name|revarpa
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NOSTR
condition|)
return|return
operator|(
name|name
operator|)
return|;
name|strcpy
argument_list|(
name|nbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|nbuf
index|[
name|strlen
argument_list|(
name|nbuf
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|!
name|any
argument_list|(
operator|*
name|cp
argument_list|,
name|metanet
argument_list|)
operator|&&
name|cp
operator|>
name|nbuf
condition|)
name|cp
operator|--
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|nbuf
condition|)
return|return
operator|(
name|name
operator|)
return|;
operator|*
operator|++
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|revarpa
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NOSTR
condition|)
name|strcat
argument_list|(
name|nbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|optim
argument_list|(
name|nbuf
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|cp
operator|=
name|revarpa
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
operator|!
name|icequal
argument_list|(
name|name
argument_list|,
name|cp
argument_list|)
condition|)
return|return
operator|(
name|savestr
argument_list|(
name|cp
argument_list|)
operator|)
return|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Turn a network machine name into a unique character  */
end_comment

begin_macro
name|netlook
argument_list|(
argument|machine
argument_list|,
argument|attnet
argument_list|)
end_macro

begin_decl_stmt
name|char
name|machine
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|netmach
modifier|*
name|np
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|char
name|nbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* 	 * Make into lower case. 	 */
for|for
control|(
name|cp
operator|=
name|machine
operator|,
name|cp2
operator|=
name|nbuf
init|;
operator|*
name|cp
condition|;
operator|*
name|cp2
operator|++
operator|=
name|little
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
control|)
if|if
condition|(
name|cp2
operator|>=
operator|&
name|nbuf
index|[
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
operator|-
literal|1
index|]
condition|)
break|break;
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If a single letter machine, look through those first. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|nbuf
argument_list|)
operator|==
literal|1
condition|)
for|for
control|(
name|np
operator|=
name|netmach
init|;
name|np
operator|->
name|nt_mid
operator|!=
literal|0
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|nt_mid
operator|==
name|nbuf
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|nbuf
index|[
literal|0
index|]
operator|)
return|;
comment|/* 	 * Look for usual name 	 */
for|for
control|(
name|np
operator|=
name|netmach
init|;
name|np
operator|->
name|nt_mid
operator|!=
literal|0
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|np
operator|->
name|nt_machine
argument_list|,
name|nbuf
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|np
operator|->
name|nt_mid
operator|)
return|;
comment|/* 	 * Look in side hash table. 	 */
return|return
operator|(
name|mstash
argument_list|(
name|nbuf
argument_list|,
name|attnet
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Make a little character.  */
end_comment

begin_expr_stmt
name|little
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
name|c
operator|+=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Turn a network unique character identifier into a network name.  */
end_comment

begin_function
name|char
modifier|*
name|netname
parameter_list|(
name|mid
parameter_list|)
block|{
specifier|register
name|struct
name|netmach
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|mlook
parameter_list|()
function_decl|;
if|if
condition|(
name|mid
operator|&
literal|0200
condition|)
return|return
operator|(
name|mlook
argument_list|(
name|mid
argument_list|)
operator|)
return|;
for|for
control|(
name|np
operator|=
name|netmach
init|;
name|np
operator|->
name|nt_mid
operator|!=
literal|0
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|nt_mid
operator|==
name|mid
condition|)
return|return
operator|(
name|np
operator|->
name|nt_machine
operator|)
return|;
return|return
operator|(
name|NOSTR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deal with arpa net addresses.  The way this is done is strange.  * In particular, if the destination arpa net host is not Berkeley,  * then the address is correct as stands.  Otherwise, we strip off  * the trailing @Berkeley, then cook up a phony person for it to  * be from and optimize the result.  */
end_comment

begin_function
name|char
modifier|*
name|arpafix
parameter_list|(
name|name
parameter_list|,
name|from
parameter_list|)
name|char
name|name
index|[]
decl_stmt|;
name|char
name|from
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|arpamach
decl_stmt|;
name|char
name|newname
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|fake
index|[
literal|5
index|]
decl_stmt|;
name|char
name|fakepath
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arpafix(%s, %s)\n"
argument_list|,
name|name
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NOSTR
condition|)
name|cp
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NOSTR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Somethings amiss -- no @ or %% in arpafix\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
name|cp
operator|++
expr_stmt|;
name|arpamach
operator|=
name|netlook
argument_list|(
name|cp
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|arpamach
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"machine %s unknown, uses: %s\n"
argument_list|,
name|cp
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|nettype
argument_list|(
name|arpamach
argument_list|)
operator|&
name|nettype
argument_list|(
name|LOCAL
argument_list|)
operator|)
operator|&
operator|~
name|AN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"machine %s known but remote, uses: %s\n"
argument_list|,
name|cp
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|newname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NOSTR
condition|)
name|cp
operator|=
name|rindex
argument_list|(
name|newname
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|fake
index|[
literal|0
index|]
operator|=
name|arpamach
expr_stmt|;
name|fake
index|[
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
name|fake
index|[
literal|2
index|]
operator|=
name|LOCAL
expr_stmt|;
name|fake
index|[
literal|3
index|]
operator|=
literal|':'
expr_stmt|;
name|fake
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|prefer
argument_list|(
name|fake
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fakepath
argument_list|,
name|netname
argument_list|(
name|fake
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|stradd
argument_list|(
name|fakepath
argument_list|,
name|fake
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fakepath
argument_list|,
literal|"daemon"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"machine local, call netmap(%s, %s)\n"
argument_list|,
name|newname
argument_list|,
name|fakepath
argument_list|)
expr_stmt|;
return|return
operator|(
name|netmap
argument_list|(
name|newname
argument_list|,
name|fakepath
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take a network machine descriptor and find the types of connected  * nets and return it.  */
end_comment

begin_macro
name|nettype
argument_list|(
argument|mid
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|netmach
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|mid
operator|&
literal|0200
condition|)
return|return
operator|(
name|mtype
argument_list|(
name|mid
argument_list|)
operator|)
return|;
for|for
control|(
name|np
operator|=
name|netmach
init|;
name|np
operator|->
name|nt_mid
operator|!=
literal|0
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|nt_mid
operator|==
name|mid
condition|)
return|return
operator|(
name|np
operator|->
name|nt_type
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Hashing routines to salt away machines seen scanning  * networks paths that we don't know about.  */
end_comment

begin_define
define|#
directive|define
name|XHSIZE
value|19
end_define

begin_comment
comment|/* Size of extra hash table */
end_comment

begin_define
define|#
directive|define
name|NXMID
value|(XHSIZE*3/4)
end_define

begin_comment
comment|/* Max extra machines */
end_comment

begin_struct
struct|struct
name|xtrahash
block|{
name|char
modifier|*
name|xh_name
decl_stmt|;
comment|/* Name of machine */
name|short
name|xh_mid
decl_stmt|;
comment|/* Machine ID */
name|short
name|xh_attnet
decl_stmt|;
comment|/* Attached networks */
block|}
name|xtrahash
index|[
name|XHSIZE
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|xtrahash
modifier|*
name|xtab
index|[
name|XHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* F: mid-->machine name */
end_comment

begin_decl_stmt
name|short
name|midfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next free machine id */
end_comment

begin_comment
comment|/*  * Initialize the extra host hash table.  * Called by sreset.  */
end_comment

begin_macro
name|minit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|xtrahash
modifier|*
name|xp
decl_stmt|,
modifier|*
modifier|*
name|tp
decl_stmt|;
name|midfree
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
operator|&
name|xtab
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|xp
operator|=
operator|&
name|xtrahash
index|[
literal|0
index|]
init|;
name|xp
operator|<
operator|&
name|xtrahash
index|[
name|XHSIZE
index|]
condition|;
name|xp
operator|++
control|)
block|{
name|xp
operator|->
name|xh_name
operator|=
name|NOSTR
expr_stmt|;
name|xp
operator|->
name|xh_mid
operator|=
literal|0
expr_stmt|;
name|xp
operator|->
name|xh_attnet
operator|=
literal|0
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
operator|(
expr|struct
name|xtrahash
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Stash a net name in the extra host hash table.  * If a new entry is put in the hash table, deduce what  * net the machine is attached to from the net character.  *  * If the machine is already known, add the given attached  * net to those already known.  */
end_comment

begin_macro
name|mstash
argument_list|(
argument|name
argument_list|,
argument|attnet
argument_list|)
end_macro

begin_decl_stmt
name|char
name|name
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|xtrahash
modifier|*
name|xp
decl_stmt|;
name|struct
name|xtrahash
modifier|*
name|xlocate
parameter_list|()
function_decl|;
name|int
name|x
decl_stmt|;
name|xp
operator|=
name|xlocate
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|==
operator|(
expr|struct
name|xtrahash
operator|*
operator|)
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Ran out of machine id spots\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|xp
operator|->
name|xh_name
operator|==
name|NOSTR
condition|)
block|{
if|if
condition|(
name|midfree
operator|>=
name|XHSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"Out of machine ids\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|xtab
index|[
name|midfree
index|]
operator|=
name|xp
expr_stmt|;
name|xp
operator|->
name|xh_name
operator|=
name|savestr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|xp
operator|->
name|xh_mid
operator|=
literal|0200
operator|+
name|midfree
operator|++
expr_stmt|;
block|}
name|x
operator|=
name|ntype
argument_list|(
name|attnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|xp
operator|->
name|xh_attnet
operator||=
name|SN
expr_stmt|;
else|else
name|xp
operator|->
name|xh_attnet
operator||=
name|x
expr_stmt|;
return|return
operator|(
name|xp
operator|->
name|xh_mid
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Search for the given name in the hash table  * and return the pointer to it if found, or to the first  * empty slot if not found.  *  * If no free slots can be found, return 0.  */
end_comment

begin_function
name|struct
name|xtrahash
modifier|*
name|xlocate
parameter_list|(
name|name
parameter_list|)
name|char
name|name
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|h
decl_stmt|,
name|q
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|xtrahash
modifier|*
name|xp
decl_stmt|;
for|for
control|(
name|h
operator|=
literal|0
operator|,
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|h
operator|=
operator|(
name|h
operator|<<
literal|2
operator|)
operator|+
operator|*
name|cp
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|h
operator|<
literal|0
operator|&&
operator|(
name|h
operator|=
operator|-
name|h
operator|)
operator|<
literal|0
condition|)
name|h
operator|=
literal|0
expr_stmt|;
name|h
operator|=
name|h
operator|%
name|XHSIZE
expr_stmt|;
name|cp
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|XHSIZE
condition|;
name|i
operator|++
operator|,
name|q
operator|=
name|i
operator|*
name|i
control|)
block|{
name|xp
operator|=
operator|&
name|xtrahash
index|[
operator|(
name|h
operator|+
name|q
operator|)
operator|%
name|XHSIZE
index|]
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|xh_name
operator|==
name|NOSTR
condition|)
return|return
operator|(
name|xp
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|xp
operator|->
name|xh_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|xp
operator|)
return|;
if|if
condition|(
name|h
operator|-
name|q
operator|<
literal|0
condition|)
name|h
operator|+=
name|XHSIZE
expr_stmt|;
name|xp
operator|=
operator|&
name|xtrahash
index|[
operator|(
name|h
operator|-
name|q
operator|)
operator|%
name|XHSIZE
index|]
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|xh_name
operator|==
name|NOSTR
condition|)
return|return
operator|(
name|xp
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|xp
operator|->
name|xh_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|xp
operator|)
return|;
block|}
return|return
operator|(
operator|(
expr|struct
name|xtrahash
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the name from the extra host hash table corresponding  * to the passed machine id.  */
end_comment

begin_function
name|char
modifier|*
name|mlook
parameter_list|(
name|mid
parameter_list|)
block|{
specifier|register
name|int
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|mid
operator|&
literal|0200
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NOSTR
operator|)
return|;
name|m
operator|=
name|mid
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|m
operator|>=
name|midfree
condition|)
block|{
name|printf
argument_list|(
literal|"Use made of undefined machine id\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOSTR
operator|)
return|;
block|}
return|return
operator|(
name|xtab
index|[
name|m
index|]
operator|->
name|xh_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the bit mask of net's that the given extra host machine  * id has so far.  */
end_comment

begin_macro
name|mtype
argument_list|(
argument|mid
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|mid
operator|&
literal|0200
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|=
name|mid
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|m
operator|>=
name|midfree
condition|)
block|{
name|printf
argument_list|(
literal|"Use made of undefined machine id\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|xtab
index|[
name|m
index|]
operator|->
name|xh_attnet
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Take a network name and optimize it.  This gloriously messy  * operation takes place as follows:  the name with machine names  * in it is tokenized by mapping each machine name into a single  * character machine id (netlook).  The separator characters (network  * metacharacters) are left intact.  The last component of the network  * name is stripped off and assumed to be the destination user name --  * it does not participate in the optimization.  As an example, the  * name "research!vax135!research!ucbvax!bill" becomes, tokenized,  * "r!x!r!v!" and "bill"  A low level routine, optim1, fixes up the  * network part (eg, "r!x!r!v!"), then we convert back to network  * machine names and tack the user name on the end.  *  * The result of this is copied into the parameter "name"  */
end_comment

begin_macro
name|optim
argument_list|(
argument|net
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
name|net
index|[]
decl_stmt|,
name|name
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|netcomp
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|netstr
index|[
literal|40
index|]
decl_stmt|,
name|xfstr
index|[
literal|40
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|strcpy
argument_list|(
name|netstr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|cp
operator|=
name|net
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Rip off next path component into netcomp 		 */
name|cp2
operator|=
name|netcomp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|any
argument_list|(
operator|*
name|cp
argument_list|,
name|metanet
argument_list|)
condition|)
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If we hit null byte, then we just scanned 		 * the destination user name.  Go off and optimize 		 * if its so. 		 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|c
operator|=
name|netlook
argument_list|(
name|netcomp
argument_list|,
operator|*
name|cp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No host named \"%s\"\n"
argument_list|,
name|netcomp
argument_list|)
expr_stmt|;
name|err
label|:
name|strcpy
argument_list|(
name|name
argument_list|,
name|net
argument_list|)
expr_stmt|;
return|return;
block|}
name|stradd
argument_list|(
name|netstr
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|stradd
argument_list|(
name|netstr
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/* 		 * If multiple network separators given, 		 * throw away the extras. 		 */
while|while
condition|(
name|any
argument_list|(
operator|*
name|cp
argument_list|,
name|metanet
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|netcomp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"net name syntax\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|optim1
argument_list|(
name|netstr
argument_list|,
name|xfstr
argument_list|)
expr_stmt|;
comment|/* 	 * Convert back to machine names. 	 */
name|cp
operator|=
name|xfstr
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|cp2
operator|=
name|netname
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
operator|)
operator|==
name|NOSTR
condition|)
block|{
name|printf
argument_list|(
literal|"Made up bad net name\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Machine code %c (0%o)\n"
argument_list|,
name|cp
index|[
operator|-
literal|1
index|]
argument_list|,
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sorry -- dumping now.  Alert K. Shoens\n"
argument_list|)
expr_stmt|;
name|core
argument_list|()
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|strcat
argument_list|(
name|name
argument_list|,
name|cp2
argument_list|)
expr_stmt|;
name|stradd
argument_list|(
name|name
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|name
argument_list|,
name|netcomp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Take a string of network machine id's and separators and  * optimize them.  We process these by pulling off maximal  * leading strings of the same type, passing these to the appropriate  * optimizer and concatenating the results.  */
end_comment

begin_macro
name|optim1
argument_list|(
argument|netstr
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
name|netstr
index|[]
decl_stmt|,
name|name
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|path
index|[
literal|40
index|]
decl_stmt|,
name|rpath
index|[
literal|40
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|int
name|tp
decl_stmt|,
name|nc
decl_stmt|;
name|cp
operator|=
name|netstr
expr_stmt|;
name|prefer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * If the address ultimately points back to us, 	 * just return a null network path. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|>
literal|1
operator|&&
name|cp
index|[
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|2
index|]
operator|==
name|LOCAL
condition|)
return|return;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|tp
operator|=
name|ntype
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|nc
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
name|tp
operator|==
name|ntype
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|stradd
argument_list|(
name|path
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|netkind
argument_list|(
name|tp
argument_list|)
condition|)
block|{
default|default:
name|strcpy
argument_list|(
name|rpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMPLICIT
case|:
name|optimimp
argument_list|(
name|path
argument_list|,
name|rpath
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPLICIT
case|:
name|optimex
argument_list|(
name|path
argument_list|,
name|rpath
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|cp2
operator|=
name|rpath
init|;
operator|*
name|cp2
operator|!=
literal|0
condition|;
name|cp2
operator|++
control|)
block|{
name|stradd
argument_list|(
name|name
argument_list|,
operator|*
name|cp2
argument_list|)
expr_stmt|;
name|stradd
argument_list|(
name|name
argument_list|,
name|nc
argument_list|)
expr_stmt|;
block|}
block|}
name|optiboth
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|prefer
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return the network of the separator --  *	AN for arpa net  *	BN for Bell labs net  *	SN for Schmidt (berkeley net)  *	0 if we don't know.  */
end_comment

begin_expr_stmt
name|ntype
argument_list|(
name|nc
argument_list|)
specifier|register
name|int
name|nc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ntypetab
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|np
operator|=
name|ntypetab
init|;
name|np
operator|->
name|nt_char
operator|!=
literal|0
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|nt_char
operator|==
name|nc
condition|)
return|return
operator|(
name|np
operator|->
name|nt_bcode
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the kind of routing used for the particular net  * EXPLICIT means explicitly routed  * IMPLICIT means implicitly routed  * 0 means don't know  */
end_comment

begin_expr_stmt
name|netkind
argument_list|(
name|nt
argument_list|)
specifier|register
name|int
name|nt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|nkindtab
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|np
operator|=
name|nkindtab
init|;
name|np
operator|->
name|nk_type
operator|!=
literal|0
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|nk_type
operator|==
name|nt
condition|)
return|return
operator|(
name|np
operator|->
name|nk_kind
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Do name optimization for an explicitly routed network (eg BTL network).  */
end_comment

begin_macro
name|optimex
argument_list|(
argument|net
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
name|net
index|[]
decl_stmt|,
name|name
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|cp
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|cp
index|[
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
index|]
operator|==
name|LOCAL
condition|)
block|{
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|m
operator|=
operator|*
name|cp
expr_stmt|;
name|rp
operator|=
name|rindex
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|NOSTR
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Do name optimization for implicitly routed network (eg, arpanet,  * Berkeley network)  */
end_comment

begin_macro
name|optimimp
argument_list|(
argument|net
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
name|net
index|[]
decl_stmt|,
name|name
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
name|cp
operator|=
name|net
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|m
operator|=
name|cp
index|[
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|LOCAL
condition|)
block|{
name|strcpy
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|name
index|[
literal|0
index|]
operator|=
name|m
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Perform global optimization on the given network path.  * The trick here is to look ahead to see if there are any loops  * in the path and remove them.  The interpretation of loops is  * more strict here than in optimex since both the machine and net  * type must match.  */
end_comment

begin_macro
name|optiboth
argument_list|(
argument|net
argument_list|)
end_macro

begin_decl_stmt
name|char
name|net
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|char
modifier|*
name|rpair
parameter_list|()
function_decl|;
name|cp
operator|=
name|net
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Strange arg to optiboth\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|*
name|cp
condition|)
block|{
name|cp2
operator|=
name|rpair
argument_list|(
name|cp
operator|+
literal|2
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp2
operator|!=
name|NOSTR
condition|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|cp2
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Find the rightmost instance of the given (machine, type) pair.  */
end_comment

begin_function
name|char
modifier|*
name|rpair
parameter_list|(
name|str
parameter_list|,
name|mach
parameter_list|)
name|char
name|str
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|cp
operator|=
name|str
expr_stmt|;
name|last
operator|=
name|NOSTR
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
name|mach
condition|)
name|last
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|last
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Change the network separators in the given network path  * to the preferred network transmission means.  */
end_comment

begin_macro
name|prefer
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
name|name
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|,
name|n
decl_stmt|;
name|state
operator|=
name|LOCAL
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|+=
literal|2
control|)
block|{
name|n
operator|=
name|best
argument_list|(
name|state
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|cp
index|[
literal|1
index|]
operator|=
name|n
expr_stmt|;
name|state
operator|=
operator|*
name|cp
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Return the best network separator for the given machine pair.  */
end_comment

begin_macro
name|best
argument_list|(
argument|src
argument_list|,
argument|dest
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|dtype
decl_stmt|,
name|stype
decl_stmt|;
specifier|register
name|struct
name|netorder
modifier|*
name|np
decl_stmt|;
name|stype
operator|=
name|nettype
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|nettype
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|stype
operator|==
literal|0
operator|||
name|dtype
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR:  unknown internal machine id\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stype
operator|&
name|dtype
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|np
operator|=
operator|&
name|netorder
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|np
operator|->
name|no_stat
operator|&
name|stype
operator|&
name|dtype
operator|)
operator|==
literal|0
condition|)
name|np
operator|++
expr_stmt|;
return|return
operator|(
name|np
operator|->
name|no_char
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|GETHOST
end_ifdef

begin_comment
comment|/*  * Initialize the network name of the current host.  */
end_comment

begin_macro
name|inithost
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|netmach
modifier|*
name|np
decl_stmt|;
specifier|static
name|char
name|host
index|[
literal|64
index|]
decl_stmt|;
name|gethostname
argument_list|(
name|host
argument_list|,
sizeof|sizeof
name|host
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|netmach
init|;
name|np
operator|->
name|nt_machine
operator|!=
literal|0
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|np
operator|->
name|nt_machine
argument_list|,
name|EMPTY
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|np
operator|->
name|nt_machine
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot find empty slot for dynamic host entry\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|nt_machine
operator|=
name|host
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|GETHOST
end_endif

begin_comment
comment|/*  * Code to twist around arpa net names.  */
end_comment

begin_define
define|#
directive|define
name|WORD
value|257
end_define

begin_comment
comment|/* Token for a string */
end_comment

begin_decl_stmt
specifier|static
name|char
name|netbuf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reverse all of the arpa net addresses in the given name to  * be of the form "host @ user" instead of "user @ host"  * This function is its own inverse.  */
end_comment

begin_function
name|char
modifier|*
name|revarpa
parameter_list|(
name|str
parameter_list|)
name|char
name|str
index|[]
decl_stmt|;
block|{
if|if
condition|(
name|yyinit
argument_list|(
name|str
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NOSTR
operator|)
return|;
if|if
condition|(
name|name
argument_list|()
condition|)
return|return
operator|(
name|NOSTR
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|netbuf
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|str
operator|)
return|;
return|return
operator|(
name|savestr
argument_list|(
name|netbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse (by recursive descent) network names, using the following grammar:  *	name:  *		term {':' term}  *		term {'^' term}  *		term {'!' term}  *		term '@' name  *		term '%' name  *  *	term:  *		string of characters.  */
end_comment

begin_macro
name|name
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|t
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|WORD
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|yylval
expr_stmt|;
name|t
operator|=
name|yylex
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
literal|0
case|:
name|strcat
argument_list|(
name|netbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'@'
case|:
case|case
literal|'%'
case|:
if|if
condition|(
name|name
argument_list|()
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|stradd
argument_list|(
name|netbuf
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|netbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|WORD
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
name|strcat
argument_list|(
name|netbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|stradd
argument_list|(
name|netbuf
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Scanner for network names.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|charp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current input pointer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nexttok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Salted away next token */
end_comment

begin_comment
comment|/*  * Initialize the network name scanner.  */
end_comment

begin_macro
name|yyinit
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
name|str
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|lexbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|netbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|>=
sizeof|sizeof
name|lexbuf
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nexttok
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|lexbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|charp
operator|=
name|lexbuf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Scan and return a single token.  * yylval is set to point to a scanned string.  */
end_comment

begin_macro
name|yylex
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dot
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
if|if
condition|(
name|nexttok
condition|)
block|{
name|s
operator|=
name|nexttok
expr_stmt|;
name|nexttok
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
name|cp
operator|=
name|charp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|any
argument_list|(
operator|*
name|cp
argument_list|,
name|metanet
argument_list|)
condition|)
block|{
name|charp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
return|return
operator|(
operator|*
name|cp
operator|)
return|;
block|}
name|dot
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|any
argument_list|(
operator|*
name|cp
argument_list|,
name|metanet
argument_list|)
operator|&&
operator|!
name|any
argument_list|(
operator|*
name|cp
argument_list|,
literal|" \t"
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|any
argument_list|(
operator|*
name|cp
argument_list|,
name|metanet
argument_list|)
condition|)
name|nexttok
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
name|charp
operator|=
name|cp
expr_stmt|;
else|else
name|charp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|yylval
operator|=
name|dot
expr_stmt|;
return|return
operator|(
name|WORD
operator|)
return|;
block|}
end_block

end_unit

