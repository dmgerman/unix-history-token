begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* kwset.c - search for any of a set of keywords.    Copyright 1989 Free Software Foundation 		  Written August 1989 by Mike Haertel.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author may be reached (Email) at the address mike@ai.mit.edu,    or (US mail) as Mike Haertel c/o Free Software Foundation. */
end_comment

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_comment
comment|/* The algorithm implemented by these routines bears a startling resemblence    to one discovered by Beate Commentz-Walter, although it is not identical.    See "A String Matching Algorithm Fast on the Average," Technical Report,    IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900    Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, "Efficient    String Matching:  An Aid to Bibliographic Search," CACM June 1975,    Vol. 18, No. 6, which describes the failure function used below. */
end_comment

begin_include
include|#
directive|include
file|"kwset.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|NCHAR
value|(UCHAR_MAX + 1)
end_define

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|malloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Balanced tree of edges and labels leaving a given trie node. */
end_comment

begin_struct
struct|struct
name|tree
block|{
name|struct
name|tree
modifier|*
name|llink
decl_stmt|;
comment|/* Left link; MUST be first field. */
name|struct
name|tree
modifier|*
name|rlink
decl_stmt|;
comment|/* Right link (to larger labels). */
name|struct
name|trie
modifier|*
name|trie
decl_stmt|;
comment|/* Trie node pointed to by this edge. */
name|unsigned
name|char
name|label
decl_stmt|;
comment|/* Label on this edge. */
name|char
name|balance
decl_stmt|;
comment|/* Difference in depths of subtrees. */
block|}
struct|;
end_struct

begin_comment
comment|/* Node of a trie representing a set of reversed keywords. */
end_comment

begin_struct
struct|struct
name|trie
block|{
name|unsigned
name|int
name|accepting
decl_stmt|;
comment|/* Word index of accepted word, or zero. */
name|struct
name|tree
modifier|*
name|links
decl_stmt|;
comment|/* Tree of edges leaving this node. */
name|struct
name|trie
modifier|*
name|parent
decl_stmt|;
comment|/* Parent of this node. */
name|struct
name|trie
modifier|*
name|next
decl_stmt|;
comment|/* List of all trie nodes in level order. */
name|struct
name|trie
modifier|*
name|fail
decl_stmt|;
comment|/* Aho-Corasick failure function. */
name|int
name|depth
decl_stmt|;
comment|/* Depth of this node from the root. */
name|int
name|shift
decl_stmt|;
comment|/* Shift function for search failures. */
name|int
name|maxshift
decl_stmt|;
comment|/* Max shift of self and descendents. */
block|}
struct|;
end_struct

begin_comment
comment|/* Structure returned opaquely to the caller, containing everything. */
end_comment

begin_struct
struct|struct
name|kwset
block|{
name|struct
name|obstack
name|obstack
decl_stmt|;
comment|/* Obstack for node allocation. */
name|int
name|words
decl_stmt|;
comment|/* Number of words in the trie. */
name|struct
name|trie
modifier|*
name|trie
decl_stmt|;
comment|/* The trie itself. */
name|int
name|mind
decl_stmt|;
comment|/* Minimum depth of an accepting node. */
name|int
name|maxd
decl_stmt|;
comment|/* Maximum depth of any node. */
name|int
name|delta
index|[
name|NCHAR
index|]
decl_stmt|;
comment|/* Delta table for rapid search. */
name|struct
name|trie
modifier|*
name|next
index|[
name|NCHAR
index|]
decl_stmt|;
comment|/* Table of children of the root. */
specifier|const
name|char
modifier|*
name|trans
decl_stmt|;
comment|/* Character translation table. */
block|}
struct|;
end_struct

begin_comment
comment|/* Allocate and initialize a keyword set object, returning an opaque    pointer to it.  Return NULL if memory is not available. */
end_comment

begin_decl_stmt
name|kwset_t
name|DEFUN
argument_list|(
name|kwsalloc
argument_list|,
operator|(
name|trans
operator|)
argument_list|,
specifier|const
name|char
operator|*
name|trans
argument_list|)
block|{
name|struct
name|kwset
modifier|*
name|kwset
decl_stmt|;
name|kwset
operator|=
operator|(
expr|struct
name|kwset
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|kwset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kwset
condition|)
return|return
name|NULL
return|;
name|obstack_init
argument_list|(
operator|&
name|kwset
operator|->
name|obstack
argument_list|)
expr_stmt|;
name|kwset
operator|->
name|words
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|trie
operator|=
operator|(
expr|struct
name|trie
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|kwset
operator|->
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kwset
operator|->
name|trie
condition|)
block|{
name|kwsfree
argument_list|(
operator|(
name|kwset_t
operator|)
name|kwset
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|kwset
operator|->
name|trie
operator|->
name|accepting
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|trie
operator|->
name|links
operator|=
name|NULL
expr_stmt|;
name|kwset
operator|->
name|trie
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|kwset
operator|->
name|trie
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|kwset
operator|->
name|trie
operator|->
name|fail
operator|=
name|NULL
expr_stmt|;
name|kwset
operator|->
name|trie
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|trie
operator|->
name|shift
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|mind
operator|=
name|INT_MAX
expr_stmt|;
name|kwset
operator|->
name|maxd
operator|=
operator|-
literal|1
expr_stmt|;
name|kwset
operator|->
name|trans
operator|=
name|trans
expr_stmt|;
return|return
operator|(
name|kwset_t
operator|)
name|kwset
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Add the given string to the contents of the keyword set.  Return NULL    for success, an error message otherwise. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|DEFUN
argument_list|(
name|kwsincr
argument_list|,
operator|(
name|kws
operator|,
name|text
operator|,
name|len
operator|)
argument_list|,
name|kwset_t
name|kws
name|AND
specifier|const
name|char
operator|*
name|text
name|AND
name|size_t
name|len
argument_list|)
block|{
name|struct
name|kwset
modifier|*
name|kwset
decl_stmt|;
specifier|register
name|struct
name|trie
modifier|*
name|trie
decl_stmt|;
specifier|register
name|unsigned
name|char
name|label
decl_stmt|;
specifier|register
name|struct
name|tree
modifier|*
name|link
decl_stmt|;
specifier|register
name|int
name|depth
decl_stmt|;
name|struct
name|tree
modifier|*
name|links
index|[
literal|12
index|]
decl_stmt|;
enum|enum
block|{
name|L
block|,
name|R
block|}
name|dirs
index|[
literal|12
index|]
enum|;
name|struct
name|tree
modifier|*
name|t
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|rl
decl_stmt|,
modifier|*
name|lr
decl_stmt|;
name|kwset
operator|=
operator|(
expr|struct
name|kwset
operator|*
operator|)
name|kws
expr_stmt|;
name|trie
operator|=
name|kwset
operator|->
name|trie
expr_stmt|;
name|text
operator|+=
name|len
expr_stmt|;
comment|/* Descend the trie (built of reversed keywords) character-by-character,      installing new nodes when necessary. */
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|label
operator|=
name|kwset
operator|->
name|trans
condition|?
name|kwset
operator|->
name|trans
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|--
name|text
index|]
else|:
operator|*
operator|--
name|text
expr_stmt|;
comment|/* Descend the tree of outgoing links for this trie node, 	 looking for the current character and keeping track 	 of the path followed. */
name|link
operator|=
name|trie
operator|->
name|links
expr_stmt|;
name|links
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
operator|&
name|trie
operator|->
name|links
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|L
expr_stmt|;
name|depth
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|link
operator|&&
name|label
operator|!=
name|link
operator|->
name|label
condition|)
block|{
name|links
index|[
name|depth
index|]
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|label
operator|<
name|link
operator|->
name|label
condition|)
name|dirs
index|[
name|depth
operator|++
index|]
operator|=
name|L
operator|,
name|link
operator|=
name|link
operator|->
name|llink
expr_stmt|;
else|else
name|dirs
index|[
name|depth
operator|++
index|]
operator|=
name|R
operator|,
name|link
operator|=
name|link
operator|->
name|rlink
expr_stmt|;
block|}
comment|/* The current character doesn't have an outgoing link at 	 this trie node, so build a new trie node and install 	 a link in the current trie node's tree. */
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|link
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|kwset
operator|->
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link
condition|)
return|return
literal|"memory exhausted"
return|;
name|link
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|link
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|link
operator|->
name|trie
operator|=
operator|(
expr|struct
name|trie
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|kwset
operator|->
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link
operator|->
name|trie
condition|)
return|return
literal|"memory exhausted"
return|;
name|link
operator|->
name|trie
operator|->
name|accepting
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|trie
operator|->
name|links
operator|=
name|NULL
expr_stmt|;
name|link
operator|->
name|trie
operator|->
name|parent
operator|=
name|trie
expr_stmt|;
name|link
operator|->
name|trie
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|link
operator|->
name|trie
operator|->
name|fail
operator|=
name|NULL
expr_stmt|;
name|link
operator|->
name|trie
operator|->
name|depth
operator|=
name|trie
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
name|link
operator|->
name|trie
operator|->
name|shift
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|label
operator|=
name|label
expr_stmt|;
name|link
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
comment|/* Install the new tree node in its parent. */
if|if
condition|(
name|dirs
index|[
operator|--
name|depth
index|]
operator|==
name|L
condition|)
name|links
index|[
name|depth
index|]
operator|->
name|llink
operator|=
name|link
expr_stmt|;
else|else
name|links
index|[
name|depth
index|]
operator|->
name|rlink
operator|=
name|link
expr_stmt|;
comment|/* Back up the tree fixing the balance flags. */
while|while
condition|(
name|depth
operator|&&
operator|!
name|links
index|[
name|depth
index|]
operator|->
name|balance
condition|)
block|{
if|if
condition|(
name|dirs
index|[
name|depth
index|]
operator|==
name|L
condition|)
operator|--
name|links
index|[
name|depth
index|]
operator|->
name|balance
expr_stmt|;
else|else
operator|++
name|links
index|[
name|depth
index|]
operator|->
name|balance
expr_stmt|;
operator|--
name|depth
expr_stmt|;
block|}
comment|/* Rebalance the tree by pointer rotations if necessary. */
if|if
condition|(
name|depth
operator|&&
operator|(
name|dirs
index|[
name|depth
index|]
operator|==
name|L
operator|&&
operator|--
name|links
index|[
name|depth
index|]
operator|->
name|balance
operator|||
name|dirs
index|[
name|depth
index|]
operator|==
name|R
operator|&&
operator|++
name|links
index|[
name|depth
index|]
operator|->
name|balance
operator|)
condition|)
block|{
switch|switch
condition|(
name|links
index|[
name|depth
index|]
operator|->
name|balance
condition|)
block|{
case|case
operator|(
name|char
operator|)
operator|-
literal|2
case|:
switch|switch
condition|(
name|dirs
index|[
name|depth
operator|+
literal|1
index|]
condition|)
block|{
case|case
name|L
case|:
name|r
operator|=
name|links
index|[
name|depth
index|]
operator|,
name|t
operator|=
name|r
operator|->
name|llink
operator|,
name|rl
operator|=
name|t
operator|->
name|rlink
expr_stmt|;
name|t
operator|->
name|rlink
operator|=
name|r
operator|,
name|r
operator|->
name|llink
operator|=
name|rl
expr_stmt|;
name|t
operator|->
name|balance
operator|=
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R
case|:
name|r
operator|=
name|links
index|[
name|depth
index|]
operator|,
name|l
operator|=
name|r
operator|->
name|llink
operator|,
name|t
operator|=
name|l
operator|->
name|rlink
expr_stmt|;
name|rl
operator|=
name|t
operator|->
name|rlink
operator|,
name|lr
operator|=
name|t
operator|->
name|llink
expr_stmt|;
name|t
operator|->
name|llink
operator|=
name|l
operator|,
name|l
operator|->
name|rlink
operator|=
name|lr
operator|,
name|t
operator|->
name|rlink
operator|=
name|r
operator|,
name|r
operator|->
name|llink
operator|=
name|rl
expr_stmt|;
name|l
operator|->
name|balance
operator|=
name|t
operator|->
name|balance
operator|!=
literal|1
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|r
operator|->
name|balance
operator|=
name|t
operator|->
name|balance
operator|!=
operator|(
name|char
operator|)
operator|-
literal|1
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|2
case|:
switch|switch
condition|(
name|dirs
index|[
name|depth
operator|+
literal|1
index|]
condition|)
block|{
case|case
name|R
case|:
name|l
operator|=
name|links
index|[
name|depth
index|]
operator|,
name|t
operator|=
name|l
operator|->
name|rlink
operator|,
name|lr
operator|=
name|t
operator|->
name|llink
expr_stmt|;
name|t
operator|->
name|llink
operator|=
name|l
operator|,
name|l
operator|->
name|rlink
operator|=
name|lr
expr_stmt|;
name|t
operator|->
name|balance
operator|=
name|l
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|L
case|:
name|l
operator|=
name|links
index|[
name|depth
index|]
operator|,
name|r
operator|=
name|l
operator|->
name|rlink
operator|,
name|t
operator|=
name|r
operator|->
name|llink
expr_stmt|;
name|lr
operator|=
name|t
operator|->
name|llink
operator|,
name|rl
operator|=
name|t
operator|->
name|rlink
expr_stmt|;
name|t
operator|->
name|llink
operator|=
name|l
operator|,
name|l
operator|->
name|rlink
operator|=
name|lr
operator|,
name|t
operator|->
name|rlink
operator|=
name|r
operator|,
name|r
operator|->
name|llink
operator|=
name|rl
expr_stmt|;
name|l
operator|->
name|balance
operator|=
name|t
operator|->
name|balance
operator|!=
literal|1
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|r
operator|->
name|balance
operator|=
name|t
operator|->
name|balance
operator|!=
operator|(
name|char
operator|)
operator|-
literal|1
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|dirs
index|[
name|depth
operator|-
literal|1
index|]
operator|==
name|L
condition|)
name|links
index|[
name|depth
operator|-
literal|1
index|]
operator|->
name|llink
operator|=
name|t
expr_stmt|;
else|else
name|links
index|[
name|depth
operator|-
literal|1
index|]
operator|->
name|rlink
operator|=
name|t
expr_stmt|;
block|}
block|}
name|trie
operator|=
name|link
operator|->
name|trie
expr_stmt|;
block|}
comment|/* Mark the node we finally reached as accepting, encoding the      index number of this word in the keyword set so far. */
if|if
condition|(
operator|!
name|trie
operator|->
name|accepting
condition|)
name|trie
operator|->
name|accepting
operator|=
literal|1
operator|+
literal|2
operator|*
name|kwset
operator|->
name|words
expr_stmt|;
operator|++
name|kwset
operator|->
name|words
expr_stmt|;
comment|/* Keep track of the longest and shortest string of the keyword set. */
if|if
condition|(
name|trie
operator|->
name|depth
operator|<
name|kwset
operator|->
name|mind
condition|)
name|kwset
operator|->
name|mind
operator|=
name|trie
operator|->
name|depth
expr_stmt|;
if|if
condition|(
name|trie
operator|->
name|depth
operator|>
name|kwset
operator|->
name|maxd
condition|)
name|kwset
operator|->
name|maxd
operator|=
name|trie
operator|->
name|depth
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Enqueue the trie nodes referenced from the given tree in the    given queue. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|enqueue
argument_list|,
operator|(
name|tree
operator|,
name|last
operator|)
argument_list|,
expr|struct
name|tree
operator|*
name|tree
name|AND
expr|struct
name|trie
operator|*
operator|*
name|last
argument_list|)
block|{
if|if
condition|(
operator|!
name|tree
condition|)
return|return;
name|enqueue
argument_list|(
name|tree
operator|->
name|llink
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
name|tree
operator|->
name|rlink
argument_list|,
name|last
argument_list|)
expr_stmt|;
operator|(
operator|*
name|last
operator|)
operator|=
operator|(
operator|*
name|last
operator|)
operator|->
name|next
operator|=
name|tree
operator|->
name|trie
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Compute the Aho-Corasick failure function for the trie nodes referenced    from the given tree, given the failure function for their parent as    well as a last resort failure node. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|treefails
argument_list|,
operator|(
name|tree
operator|,
name|fail
operator|,
name|recourse
operator|)
argument_list|,
specifier|register
expr|struct
name|tree
operator|*
name|tree
name|AND
expr|struct
name|trie
operator|*
name|fail
name|AND
expr|struct
name|trie
operator|*
name|recourse
argument_list|)
block|{
specifier|register
name|struct
name|tree
modifier|*
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|tree
condition|)
return|return;
name|treefails
argument_list|(
name|tree
operator|->
name|llink
argument_list|,
name|fail
argument_list|,
name|recourse
argument_list|)
expr_stmt|;
name|treefails
argument_list|(
name|tree
operator|->
name|rlink
argument_list|,
name|fail
argument_list|,
name|recourse
argument_list|)
expr_stmt|;
comment|/* Find, in the chain of fails going back to the root, the first      node that has a descendent on the current label. */
while|while
condition|(
name|fail
condition|)
block|{
name|link
operator|=
name|fail
operator|->
name|links
expr_stmt|;
while|while
condition|(
name|link
operator|&&
name|tree
operator|->
name|label
operator|!=
name|link
operator|->
name|label
condition|)
if|if
condition|(
name|tree
operator|->
name|label
operator|<
name|link
operator|->
name|label
condition|)
name|link
operator|=
name|link
operator|->
name|llink
expr_stmt|;
else|else
name|link
operator|=
name|link
operator|->
name|rlink
expr_stmt|;
if|if
condition|(
name|link
condition|)
block|{
name|tree
operator|->
name|trie
operator|->
name|fail
operator|=
name|link
operator|->
name|trie
expr_stmt|;
return|return;
block|}
name|fail
operator|=
name|fail
operator|->
name|fail
expr_stmt|;
block|}
name|tree
operator|->
name|trie
operator|->
name|fail
operator|=
name|recourse
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Set delta entries for the links of the given tree such that    the preexisting delta value is larger than the current depth. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|treedelta
argument_list|,
operator|(
name|tree
operator|,
name|depth
operator|,
name|delta
operator|)
argument_list|,
specifier|register
expr|struct
name|tree
operator|*
name|tree
name|AND
specifier|register
name|int
name|depth
name|AND
name|int
name|delta
index|[]
argument_list|)
block|{
if|if
condition|(
operator|!
name|tree
condition|)
return|return;
name|treedelta
argument_list|(
name|tree
operator|->
name|llink
argument_list|,
name|depth
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|treedelta
argument_list|(
name|tree
operator|->
name|rlink
argument_list|,
name|depth
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|<
name|delta
index|[
name|tree
operator|->
name|label
index|]
condition|)
name|delta
index|[
name|tree
operator|->
name|label
index|]
operator|=
name|depth
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Return true if A has every label in B. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|hasevery
argument_list|,
operator|(
name|a
operator|,
name|b
operator|)
argument_list|,
specifier|register
expr|struct
name|tree
operator|*
name|a
name|AND
specifier|register
expr|struct
name|tree
operator|*
name|b
argument_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|hasevery
argument_list|(
name|a
argument_list|,
name|b
operator|->
name|llink
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|hasevery
argument_list|(
name|a
argument_list|,
name|b
operator|->
name|rlink
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|a
operator|&&
name|b
operator|->
name|label
operator|!=
name|a
operator|->
name|label
condition|)
if|if
condition|(
name|b
operator|->
name|label
operator|<
name|a
operator|->
name|label
condition|)
name|a
operator|=
name|a
operator|->
name|llink
expr_stmt|;
else|else
name|a
operator|=
name|a
operator|->
name|rlink
expr_stmt|;
return|return
operator|!
operator|!
name|a
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Compute a vector, indexed by character code, of the trie nodes    referenced from the given tree. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|treenext
argument_list|,
operator|(
name|tree
operator|,
name|next
operator|)
argument_list|,
expr|struct
name|tree
operator|*
name|tree
name|AND
expr|struct
name|trie
operator|*
name|next
index|[]
argument_list|)
block|{
if|if
condition|(
operator|!
name|tree
condition|)
return|return;
name|treenext
argument_list|(
name|tree
operator|->
name|llink
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|treenext
argument_list|(
name|tree
operator|->
name|rlink
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|next
index|[
name|tree
operator|->
name|label
index|]
operator|=
name|tree
operator|->
name|trie
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Compute the shift for each trie node, as well as the delta    table and next cache for the given keyword set. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|DEFUN
argument_list|(
name|kwsprep
argument_list|,
operator|(
name|kws
operator|)
argument_list|,
name|kwset_t
name|kws
argument_list|)
block|{
specifier|register
name|struct
name|kwset
modifier|*
name|kwset
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|trie
modifier|*
name|curr
decl_stmt|,
modifier|*
name|fail
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|trans
decl_stmt|;
name|int
name|delta
index|[
name|NCHAR
index|]
decl_stmt|;
name|struct
name|trie
modifier|*
name|last
decl_stmt|,
modifier|*
name|next
index|[
name|NCHAR
index|]
decl_stmt|;
name|kwset
operator|=
operator|(
expr|struct
name|kwset
operator|*
operator|)
name|kws
expr_stmt|;
comment|/* Initial values for the delta table; will be changed later.  The      delta entry for a given character is the smallest depth of any      node at which an outgoing edge is labeled by that character. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
name|delta
index|[
name|i
index|]
operator|=
name|kwset
operator|->
name|mind
expr_stmt|;
comment|/* Traverse the nodes of the trie in level order, simultaneously      computing the delta table, failure function, and shift function. */
for|for
control|(
name|curr
operator|=
name|last
operator|=
name|kwset
operator|->
name|trie
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
comment|/* Enqueue the immediate descendents in the level order queue. */
name|enqueue
argument_list|(
name|curr
operator|->
name|links
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|curr
operator|->
name|shift
operator|=
name|kwset
operator|->
name|mind
expr_stmt|;
name|curr
operator|->
name|maxshift
operator|=
name|kwset
operator|->
name|mind
expr_stmt|;
comment|/* Update the delta table for the descendents of this node. */
name|treedelta
argument_list|(
name|curr
operator|->
name|links
argument_list|,
name|curr
operator|->
name|depth
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* Compute the failure function for the decendents of this node. */
name|treefails
argument_list|(
name|curr
operator|->
name|links
argument_list|,
name|curr
operator|->
name|fail
argument_list|,
name|kwset
operator|->
name|trie
argument_list|)
expr_stmt|;
comment|/* Update the shifts at each node in the current node's chain 	 of fails back to the root. */
for|for
control|(
name|fail
operator|=
name|curr
operator|->
name|fail
init|;
name|fail
condition|;
name|fail
operator|=
name|fail
operator|->
name|fail
control|)
block|{
comment|/* If the current node has some outgoing edge that the fail 	     doesn't, then the shift at the fail should be no larger 	     than the difference of their depths. */
if|if
condition|(
operator|!
name|hasevery
argument_list|(
name|fail
operator|->
name|links
argument_list|,
name|curr
operator|->
name|links
argument_list|)
condition|)
if|if
condition|(
name|curr
operator|->
name|depth
operator|-
name|fail
operator|->
name|depth
operator|<
name|fail
operator|->
name|shift
condition|)
name|fail
operator|->
name|shift
operator|=
name|curr
operator|->
name|depth
operator|-
name|fail
operator|->
name|depth
expr_stmt|;
comment|/* If the current node is accepting then the shift at the 	     fail and its descendents should be no larger than the 	     difference of their depths. */
if|if
condition|(
name|curr
operator|->
name|accepting
operator|&&
name|fail
operator|->
name|maxshift
operator|>
name|curr
operator|->
name|depth
operator|-
name|fail
operator|->
name|depth
condition|)
name|fail
operator|->
name|maxshift
operator|=
name|curr
operator|->
name|depth
operator|-
name|fail
operator|->
name|depth
expr_stmt|;
block|}
block|}
comment|/* Traverse the trie in level order again, fixing up all nodes whose      shift exceeds their inherited maxshift. */
for|for
control|(
name|curr
operator|=
name|kwset
operator|->
name|trie
operator|->
name|next
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|curr
operator|->
name|maxshift
operator|>
name|curr
operator|->
name|parent
operator|->
name|maxshift
condition|)
name|curr
operator|->
name|maxshift
operator|=
name|curr
operator|->
name|parent
operator|->
name|maxshift
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|shift
operator|>
name|curr
operator|->
name|maxshift
condition|)
name|curr
operator|->
name|shift
operator|=
name|curr
operator|->
name|maxshift
expr_stmt|;
block|}
comment|/* Create a vector, indexed by character code, of the outgoing links      from the root node. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
name|next
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|treenext
argument_list|(
name|kwset
operator|->
name|trie
operator|->
name|links
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* Fix things up for any translation table. */
if|if
condition|(
name|trans
operator|=
name|kwset
operator|->
name|trans
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
block|{
name|kwset
operator|->
name|delta
index|[
name|i
index|]
operator|=
name|delta
index|[
operator|(
name|unsigned
name|char
operator|)
name|trans
index|[
name|i
index|]
index|]
expr_stmt|;
name|kwset
operator|->
name|next
index|[
name|i
index|]
operator|=
name|next
index|[
operator|(
name|unsigned
name|char
operator|)
name|trans
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
block|{
name|kwset
operator|->
name|delta
index|[
name|i
index|]
operator|=
name|delta
index|[
name|i
index|]
expr_stmt|;
name|kwset
operator|->
name|next
index|[
name|i
index|]
operator|=
name|next
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Search through the given text for a match of any member of the    given keyword set.  Return a pointer to the first character of    the matching substring, or NULL if no match is found.  If FOUNDLEN    is non-NULL store in the referenced location the length of the    matching substring.  Similarly, if FOUNDIDX is non-NULL, store    in the referenced location the index number of the particular    keyword matched. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DEFUN
argument_list|(
name|kwsexec
argument_list|,
operator|(
name|kws
operator|,
name|text
operator|,
name|len
operator|,
name|kwsmatch
operator|)
argument_list|,
name|kwset_t
name|kws
name|AND
name|char
operator|*
name|text
name|AND
name|size_t
name|len
name|AND
expr|struct
name|kwsmatch
operator|*
name|kwsmatch
argument_list|)
block|{
name|struct
name|kwset
modifier|*
name|kwset
decl_stmt|;
name|struct
name|trie
modifier|*
modifier|*
name|next
decl_stmt|,
modifier|*
name|trie
decl_stmt|,
modifier|*
name|accept
decl_stmt|;
name|char
modifier|*
name|beg
decl_stmt|,
modifier|*
name|lim
decl_stmt|,
modifier|*
name|mch
decl_stmt|,
modifier|*
name|lmch
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
specifier|register
name|int
modifier|*
name|delta
decl_stmt|,
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|,
modifier|*
name|qlim
decl_stmt|;
specifier|register
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|trans
decl_stmt|;
comment|/* Initialize register copies and look for easy ways out. */
name|kwset
operator|=
operator|(
expr|struct
name|kwset
operator|*
operator|)
name|kws
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|kwset
operator|->
name|mind
condition|)
return|return
name|NULL
return|;
name|next
operator|=
name|kwset
operator|->
name|next
expr_stmt|;
name|delta
operator|=
name|kwset
operator|->
name|delta
expr_stmt|;
name|trans
operator|=
name|kwset
operator|->
name|trans
expr_stmt|;
name|lim
operator|=
name|text
operator|+
name|len
expr_stmt|;
name|end
operator|=
name|text
expr_stmt|;
if|if
condition|(
name|d
operator|=
name|kwset
operator|->
name|mind
condition|)
name|mch
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|mch
operator|=
name|text
operator|,
name|accept
operator|=
name|kwset
operator|->
name|trie
expr_stmt|;
goto|goto
name|match
goto|;
block|}
if|if
condition|(
name|len
operator|>=
literal|4
operator|*
name|kwset
operator|->
name|mind
condition|)
name|qlim
operator|=
name|lim
operator|-
literal|4
operator|*
name|kwset
operator|->
name|mind
expr_stmt|;
else|else
name|qlim
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|lim
operator|-
name|end
operator|>=
name|d
condition|)
block|{
if|if
condition|(
name|qlim
operator|&&
name|end
operator|<=
name|qlim
condition|)
block|{
name|end
operator|+=
name|d
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|delta
index|[
name|c
operator|=
operator|*
name|end
index|]
operator|)
operator|&&
name|end
operator|<
name|qlim
condition|)
block|{
name|end
operator|+=
name|d
expr_stmt|;
name|end
operator|+=
name|delta
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|end
index|]
expr_stmt|;
name|end
operator|+=
name|delta
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|end
index|]
expr_stmt|;
block|}
operator|++
name|end
expr_stmt|;
block|}
else|else
name|d
operator|=
name|delta
index|[
name|c
operator|=
operator|(
name|end
operator|+=
name|d
operator|)
index|[
operator|-
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
name|d
condition|)
continue|continue;
name|beg
operator|=
name|end
operator|-
literal|1
expr_stmt|;
name|trie
operator|=
name|next
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|trie
operator|->
name|accepting
condition|)
block|{
name|mch
operator|=
name|beg
expr_stmt|;
name|accept
operator|=
name|trie
expr_stmt|;
block|}
name|d
operator|=
name|trie
operator|->
name|shift
expr_stmt|;
while|while
condition|(
name|beg
operator|>
name|text
condition|)
block|{
name|c
operator|=
name|trans
condition|?
name|trans
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|--
name|beg
index|]
else|:
operator|*
operator|--
name|beg
expr_stmt|;
name|tree
operator|=
name|trie
operator|->
name|links
expr_stmt|;
while|while
condition|(
name|tree
operator|&&
name|c
operator|!=
name|tree
operator|->
name|label
condition|)
if|if
condition|(
name|c
operator|<
name|tree
operator|->
name|label
condition|)
name|tree
operator|=
name|tree
operator|->
name|llink
expr_stmt|;
else|else
name|tree
operator|=
name|tree
operator|->
name|rlink
expr_stmt|;
if|if
condition|(
name|tree
condition|)
block|{
name|trie
operator|=
name|tree
operator|->
name|trie
expr_stmt|;
if|if
condition|(
name|trie
operator|->
name|accepting
condition|)
block|{
name|mch
operator|=
name|beg
expr_stmt|;
name|accept
operator|=
name|trie
expr_stmt|;
block|}
block|}
else|else
break|break;
name|d
operator|=
name|trie
operator|->
name|shift
expr_stmt|;
block|}
if|if
condition|(
name|mch
condition|)
goto|goto
name|match
goto|;
block|}
return|return
name|NULL
return|;
name|match
label|:
comment|/* Given a known match, find the longest possible match anchored      at or before its starting point.  This is nearly a verbatim      copy of the preceding main search loops. */
if|if
condition|(
name|lim
operator|-
name|mch
operator|>
name|kwset
operator|->
name|maxd
condition|)
name|lim
operator|=
name|mch
operator|+
name|kwset
operator|->
name|maxd
expr_stmt|;
name|lmch
operator|=
name|NULL
expr_stmt|;
name|d
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|lim
operator|-
name|end
operator|>=
name|d
condition|)
block|{
if|if
condition|(
name|d
operator|=
name|delta
index|[
name|c
operator|=
operator|(
name|end
operator|+=
name|d
operator|)
index|[
operator|-
literal|1
index|]
index|]
condition|)
continue|continue;
name|beg
operator|=
name|end
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|trie
operator|=
name|next
index|[
name|c
index|]
operator|)
condition|)
block|{
name|d
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|trie
operator|->
name|accepting
operator|&&
name|beg
operator|<=
name|mch
condition|)
block|{
name|lmch
operator|=
name|beg
expr_stmt|;
name|accept
operator|=
name|trie
expr_stmt|;
block|}
name|d
operator|=
name|trie
operator|->
name|shift
expr_stmt|;
while|while
condition|(
name|beg
operator|>
name|text
condition|)
block|{
name|c
operator|=
name|trans
condition|?
name|trans
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|--
name|beg
index|]
else|:
operator|*
operator|--
name|beg
expr_stmt|;
name|tree
operator|=
name|trie
operator|->
name|links
expr_stmt|;
while|while
condition|(
name|tree
operator|&&
name|c
operator|!=
name|tree
operator|->
name|label
condition|)
if|if
condition|(
name|c
operator|<
name|tree
operator|->
name|label
condition|)
name|tree
operator|=
name|tree
operator|->
name|llink
expr_stmt|;
else|else
name|tree
operator|=
name|tree
operator|->
name|rlink
expr_stmt|;
if|if
condition|(
name|tree
condition|)
block|{
name|trie
operator|=
name|tree
operator|->
name|trie
expr_stmt|;
if|if
condition|(
name|trie
operator|->
name|accepting
operator|&&
name|beg
operator|<=
name|mch
condition|)
block|{
name|lmch
operator|=
name|beg
expr_stmt|;
name|accept
operator|=
name|trie
expr_stmt|;
block|}
block|}
else|else
break|break;
name|d
operator|=
name|trie
operator|->
name|shift
expr_stmt|;
block|}
if|if
condition|(
name|lmch
condition|)
block|{
name|mch
operator|=
name|lmch
expr_stmt|;
goto|goto
name|match
goto|;
block|}
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|kwsmatch
condition|)
block|{
name|kwsmatch
operator|->
name|index
operator|=
name|accept
operator|->
name|accepting
operator|/
literal|2
expr_stmt|;
name|kwsmatch
operator|->
name|beg
index|[
literal|0
index|]
operator|=
name|mch
expr_stmt|;
name|kwsmatch
operator|->
name|size
index|[
literal|0
index|]
operator|=
name|accept
operator|->
name|depth
expr_stmt|;
block|}
return|return
name|mch
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Free the components of the given keyword set. */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|kwsfree
argument_list|,
operator|(
name|kws
operator|)
argument_list|,
name|kwset_t
name|kws
argument_list|)
block|{
name|struct
name|kwset
modifier|*
name|kwset
decl_stmt|;
name|kwset
operator|=
operator|(
expr|struct
name|kwset
operator|*
operator|)
name|kws
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|kwset
operator|->
name|obstack
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|kws
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

end_unit

