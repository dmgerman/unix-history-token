begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Create a tar archive.    Copyright (C) 1988 Free Software Foundation  This file is part of GNU Tar.  GNU Tar is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Tar is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Tar; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * Create a tar archive.  *  * Written 25 Aug 1985 by John Gilmore, ihnp4!hoptoad!gnu.  *  * @(#)create.c 1.36 11/6/87 - gnu  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|V7
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__MSDOS__
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* for MAXPATHLEN */
end_comment

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_include
include|#
directive|include
file|"msd_dir.h"
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NDIR
end_ifdef

begin_include
include|#
directive|include
file|<ndir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DIRECT
end_ifndef

begin_define
define|#
directive|define
name|direct
value|dirent
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DP_NAMELEN
parameter_list|(
name|x
parameter_list|)
value|strlen((x)->d_name)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * FIXME: On other systems there is no standard place for the header file  * for the portable directory access routines.  Change the #include line  * below to bring it in from wherever it is.  */
end_comment

begin_include
include|#
directive|include
file|"ndir.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DP_NAMELEN
end_ifndef

begin_define
define|#
directive|define
name|DP_NAMELEN
parameter_list|(
name|x
parameter_list|)
value|(x)->d_namlen
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_comment
comment|/* major() and minor() defined here */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * V7 doesn't have a #define for this.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Most people don't have a #define for this.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAXPATHLEN
end_ifndef

begin_define
define|#
directive|define
name|MAXPATHLEN
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tar.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|stat
name|hstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stat struct corresponding */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__MSDOS__
end_ifndef

begin_decl_stmt
specifier|extern
name|dev_t
name|ar_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ino_t
name|ar_ino
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JF */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|name
modifier|*
name|gnu_list_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If there are no symbolic links, there is no lstat().  Use stat().  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|S_IFLNK
end_ifndef

begin_define
define|#
directive|define
name|lstat
value|stat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strncpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bzero
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bcopy
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|print_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|union
name|record
modifier|*
name|start_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|finish_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|finduname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|findgname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|name_next
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|to_oct
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_file
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* This code moved from tar.h since create.c is the only file that cares    about 'struct link's.  This means that other files might not have to    include sys/types.h any more.  */
end_comment

begin_struct
struct|struct
name|link
block|{
name|struct
name|link
modifier|*
name|next
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|short
name|linkcount
decl_stmt|;
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|link
modifier|*
name|linklist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to first link in list */
end_comment

begin_expr_stmt
specifier|static
name|nolinks
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Gets set if we run out of RAM */
end_comment

begin_comment
comment|/*  * "Scratch" space to store the information about a sparse file before  * writing the info into the header or extended header  */
end_comment

begin_comment
comment|/* struct sp_array	 *sparsearray;*/
end_comment

begin_comment
comment|/* number of elts storable in the sparsearray */
end_comment

begin_comment
comment|/*int 	sparse_array_size = 10;*/
end_comment

begin_function
name|void
name|create_archive
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name_from_list
parameter_list|()
function_decl|;
name|open_archive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Open for writing */
if|if
condition|(
name|f_gnudump
condition|)
block|{
name|char
name|buf
index|[
name|MAXNAMLEN
index|]
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|bufp
decl_stmt|;
name|collect_and_sort_names
argument_list|()
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|name_from_list
argument_list|()
condition|)
name|dump_file
argument_list|(
name|p
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* if(!f_dironly) { */
name|blank_name_list
argument_list|()
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|name_from_list
argument_list|()
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|gnu_list_name
operator|->
name|dir_contents
init|;
name|q
operator|&&
operator|*
name|q
condition|;
name|q
operator|+=
name|strlen
argument_list|(
name|q
argument_list|)
operator|+
literal|1
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'Y'
condition|)
block|{
name|strcpy
argument_list|(
name|bufp
argument_list|,
name|q
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dump_file
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* } */
block|}
else|else
block|{
name|p
operator|=
name|name_next
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|dump_file
argument_list|(
literal|"."
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
do|do
name|dump_file
argument_list|(
name|p
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
name|p
operator|=
name|name_next
argument_list|(
literal|1
argument_list|)
condition|)
do|;
block|}
block|}
name|write_mangled
argument_list|()
expr_stmt|;
name|write_eot
argument_list|()
expr_stmt|;
name|close_archive
argument_list|()
expr_stmt|;
if|if
condition|(
name|f_gnudump
condition|)
name|write_dir_file
argument_list|()
expr_stmt|;
name|name_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump a single file.  If it's a directory, recurse.  * Result is 1 for success, 0 for failure.  * Sets global "hstat" to stat() output for this file.  */
end_comment

begin_function
name|void
name|dump_file
parameter_list|(
name|p
parameter_list|,
name|curdev
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
comment|/* File name to dump */
name|int
name|curdev
decl_stmt|;
comment|/* Device our parent dir was on */
block|{
name|union
name|record
modifier|*
name|header
decl_stmt|;
name|char
name|type
decl_stmt|;
specifier|extern
name|char
modifier|*
name|save_name
decl_stmt|;
comment|/* JF for multi-volume support */
specifier|extern
name|long
name|save_totsize
decl_stmt|;
specifier|extern
name|long
name|save_sizeleft
decl_stmt|;
name|union
name|record
modifier|*
name|exhdr
decl_stmt|;
name|char
name|save_linkflag
decl_stmt|;
specifier|extern
name|time_t
name|new_time
decl_stmt|;
name|int
name|sparse_ind
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|f_confirm
operator|&&
operator|!
name|confirm
argument_list|(
literal|"add"
argument_list|,
name|p
argument_list|)
condition|)
return|return;
comment|/* 	 * Use stat if following (rather than dumping) 4.2BSD's 	 * symbolic links.  Otherwise, use lstat (which, on non-4.2 	 * systems, is #define'd to stat anyway. 	 */
ifdef|#
directive|ifdef
name|AIX
if|if
condition|(
literal|0
operator|!=
name|f_follow_links
condition|?
name|statx
argument_list|(
name|p
argument_list|,
operator|&
name|hstat
argument_list|,
name|STATSIZE
argument_list|,
name|STX_HIDDEN
argument_list|)
else|:
name|statx
argument_list|(
name|p
argument_list|,
operator|&
name|hstat
argument_list|,
name|STATSIZE
argument_list|,
name|STX_HIDDEN
operator||
name|STX_LINK
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
literal|0
operator|!=
name|f_follow_links
condition|?
name|stat
argument_list|(
name|p
argument_list|,
operator|&
name|hstat
argument_list|)
else|:
name|lstat
argument_list|(
name|p
argument_list|,
operator|&
name|hstat
argument_list|)
condition|)
endif|#
directive|endif
comment|/* AIX */
block|{
name|badperror
label|:
name|msg_perror
argument_list|(
literal|"can't add file %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|badfile
label|:
name|errors
operator|++
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|AIX
if|if
condition|(
name|S_ISHIDDEN
argument_list|(
name|hstat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|allocate
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|strcpy
argument_list|(
name|new
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
name|p
operator|=
name|new
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* AIX */
comment|/* See if we only want new files, and check if this one is too old to 	   put in the archive. */
if|if
condition|(
name|f_new_files
operator|&&
operator|!
name|f_gnudump
operator|&&
name|new_time
operator|>
name|hstat
operator|.
name|st_mtime
operator|&&
operator|(
name|hstat
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
operator|&&
operator|(
name|f_new_files
operator|>
literal|1
operator|||
name|new_time
operator|>
name|hstat
operator|.
name|st_ctime
operator|)
condition|)
block|{
if|if
condition|(
name|curdev
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"%s: is unchanged; not dumped"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
ifndef|#
directive|ifndef
name|__MSDOS__
comment|/* See if we are trying to dump the archive */
if|if
condition|(
name|ar_dev
operator|&&
name|hstat
operator|.
name|st_dev
operator|==
name|ar_dev
operator|&&
name|hstat
operator|.
name|st_ino
operator|==
name|ar_ino
condition|)
block|{
name|msg
argument_list|(
literal|"%s is the archive; not dumped"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Check for multiple links. 	 * 	 * We maintain a list of all such files that we've written so 	 * far.  Any time we see another, we check the list and 	 * avoid dumping the data again if we've done it once already. 	 */
if|if
condition|(
name|hstat
operator|.
name|st_nlink
operator|>
literal|1
condition|)
switch|switch
condition|(
name|hstat
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
specifier|register
name|struct
name|link
modifier|*
name|lp
decl_stmt|;
case|case
name|S_IFREG
case|:
comment|/* Regular file */
ifdef|#
directive|ifdef
name|S_IFCTG
case|case
name|S_IFCTG
case|:
comment|/* Contigous file */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFCHR
case|case
name|S_IFCHR
case|:
comment|/* Character special file */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFBLK
case|case
name|S_IFBLK
case|:
comment|/* Block     special file */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFIFO
case|case
name|S_IFIFO
case|:
comment|/* Fifo      special file */
endif|#
directive|endif
comment|/* First quick and dirty.  Hashing, etc later FIXME */
for|for
control|(
name|lp
operator|=
name|linklist
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|ino
operator|==
name|hstat
operator|.
name|st_ino
operator|&&
name|lp
operator|->
name|dev
operator|==
name|hstat
operator|.
name|st_dev
condition|)
block|{
name|char
modifier|*
name|link_name
init|=
name|lp
operator|->
name|name
decl_stmt|;
comment|/* We found a link. */
name|hstat
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|header
operator|=
name|start_header
argument_list|(
name|p
argument_list|,
operator|&
name|hstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
goto|goto
name|badfile
goto|;
while|while
condition|(
operator|!
name|f_absolute_paths
operator|&&
operator|*
name|link_name
operator|==
literal|'/'
condition|)
block|{
specifier|static
name|int
name|link_warn
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|link_warn
condition|)
block|{
name|msg
argument_list|(
literal|"Removing leading / from absolute links"
argument_list|)
expr_stmt|;
name|link_warn
operator|++
expr_stmt|;
block|}
name|link_name
operator|++
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|header
operator|->
name|header
operator|.
name|linkname
argument_list|,
name|link_name
argument_list|,
name|NAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|header
operator|.
name|linkname
index|[
name|NAMSIZ
operator|-
literal|1
index|]
condition|)
block|{
name|char
modifier|*
name|mangled
decl_stmt|;
specifier|extern
name|char
modifier|*
name|find_mangled
parameter_list|()
function_decl|;
name|mangled
operator|=
name|find_mangled
argument_list|(
name|link_name
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|"%s: link name too long: mangled to %s"
argument_list|,
name|link_name
argument_list|,
name|mangled
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|header
operator|->
name|header
operator|.
name|linkname
argument_list|,
name|mangled
argument_list|,
name|NAMSIZ
argument_list|)
expr_stmt|;
block|}
name|header
operator|->
name|header
operator|.
name|linkflag
operator|=
name|LF_LINK
expr_stmt|;
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* FIXME: Maybe remove from list after all links found? */
return|return;
comment|/* We dumped it */
block|}
block|}
comment|/* Not found.  Add it to the list of possible links. */
name|lp
operator|=
operator|(
expr|struct
name|link
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|link
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
block|{
if|if
condition|(
operator|!
name|nolinks
condition|)
block|{
name|msg
argument_list|(
literal|"no memory for links, they will be dumped as separate files"
argument_list|)
expr_stmt|;
name|nolinks
operator|++
expr_stmt|;
block|}
block|}
name|lp
operator|->
name|ino
operator|=
name|hstat
operator|.
name|st_ino
expr_stmt|;
name|lp
operator|->
name|dev
operator|=
name|hstat
operator|.
name|st_dev
expr_stmt|;
name|strcpy
argument_list|(
name|lp
operator|->
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|lp
operator|->
name|next
operator|=
name|linklist
expr_stmt|;
name|linklist
operator|=
name|lp
expr_stmt|;
block|}
comment|/* 	 * This is not a link to a previously dumped file, so dump it. 	 */
switch|switch
condition|(
name|hstat
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
comment|/* Regular file */
ifdef|#
directive|ifdef
name|S_IFCTG
case|case
name|S_IFCTG
case|:
comment|/* Contiguous file */
endif|#
directive|endif
block|{
name|int
name|f
decl_stmt|;
comment|/* File descriptor */
name|long
name|bufsize
decl_stmt|,
name|count
decl_stmt|;
name|long
name|sizeleft
decl_stmt|;
specifier|register
name|union
name|record
modifier|*
name|start
decl_stmt|;
name|int
name|header_moved
decl_stmt|;
name|char
name|isextended
init|=
literal|0
decl_stmt|;
name|int
name|upperbound
decl_stmt|;
name|int
name|end_nulls
init|=
literal|0
decl_stmt|;
name|header_moved
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD42
if|if
condition|(
name|f_sparse_files
condition|)
block|{
comment|/* 	 	 * JK - This is the test for sparseness: whether the 		 * "size" of the file matches the number of blocks 		 * allocated for it.  If there is a smaller number 		 * of blocks that would be necessary to accommodate 		 * a file of this size, we have a sparse file, i.e., 		 * at least one of those records in the file is just 		 * a useless hole. 		 */
ifdef|#
directive|ifdef
name|hpux
comment|/* Nice of HPUX to gratuitiously change it, huh?  - mib */
if|if
condition|(
name|hstat
operator|.
name|st_size
operator|-
operator|(
name|hstat
operator|.
name|st_blocks
operator|*
literal|1024
operator|)
operator|>
literal|1024
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|hstat
operator|.
name|st_size
operator|-
operator|(
name|hstat
operator|.
name|st_blocks
operator|*
name|RECORDSIZE
operator|)
operator|>
name|RECORDSIZE
condition|)
block|{
endif|#
directive|endif
name|int
name|filesize
init|=
name|hstat
operator|.
name|st_size
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|header
operator|=
name|start_header
argument_list|(
name|p
argument_list|,
operator|&
name|hstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
goto|goto
name|badfile
goto|;
name|header
operator|->
name|header
operator|.
name|linkflag
operator|=
name|LF_SPARSE
expr_stmt|;
name|header_moved
operator|++
expr_stmt|;
comment|/* 			 * Call the routine that figures out the 			 * layout of the sparse file in question. 			 * UPPERBOUND is the index of the last 			 * element of the "sparsearray," i.e., 			 * the number of elements it needed to 			 * describe the file. 			 */
name|upperbound
operator|=
name|deal_with_sparse
argument_list|(
name|p
argument_list|,
name|header
argument_list|)
expr_stmt|;
comment|/*  			 * See if we'll need an extended header 			 * later 			 */
if|if
condition|(
name|upperbound
operator|>
name|SPARSE_IN_HDR
operator|-
literal|1
condition|)
name|header
operator|->
name|header
operator|.
name|isextended
operator|++
expr_stmt|;
comment|/* 			 * We store the "real" file size so 			 * we can show that in case someone wants 			 * to list the archive, i.e., tar tvf<file>. 			 * It might be kind of disconcerting if the 			 * shrunken file size was the one that showed 			 * up. 			 */
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|realsize
argument_list|)
expr_stmt|;
comment|/* 			 * This will be the new "size" of the 			 * file, i.e., the size of the file 			 * minus the records of holes that we're 			 * skipping over.  			 */
name|find_new_file_size
argument_list|(
operator|&
name|filesize
argument_list|,
name|upperbound
argument_list|)
expr_stmt|;
name|hstat
operator|.
name|st_size
operator|=
name|filesize
expr_stmt|;
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|filesize
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/*				to_oct((long) end_nulls, 1+12,  						header->header.ending_blanks);*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPARSE_IN_HDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sparsearray
index|[
name|i
index|]
operator|.
name|numbytes
condition|)
break|break;
name|to_oct
argument_list|(
name|sparsearray
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|sp
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
name|sparsearray
index|[
name|i
index|]
operator|.
name|numbytes
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|sp
index|[
name|i
index|]
operator|.
name|numbytes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
name|upperbound
operator|=
name|SPARSE_IN_HDR
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|sizeleft
operator|=
name|hstat
operator|.
name|st_size
expr_stmt|;
comment|/* Don't bother opening empty, world readable files. */
if|if
condition|(
name|sizeleft
operator|>
literal|0
operator|||
literal|0444
operator|!=
operator|(
literal|0444
operator|&
name|hstat
operator|.
name|st_mode
operator|)
condition|)
block|{
name|f
operator|=
name|open
argument_list|(
name|p
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
goto|goto
name|badperror
goto|;
block|}
else|else
block|{
name|f
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* If the file is sparse, we've already taken care of this */
if|if
condition|(
operator|!
name|header_moved
condition|)
block|{
name|header
operator|=
name|start_header
argument_list|(
name|p
argument_list|,
operator|&
name|hstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|badfile
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|S_IFCTG
comment|/* Mark contiguous files, if we support them */
if|if
condition|(
name|f_standard
operator|&&
operator|(
name|hstat
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCTG
condition|)
block|{
name|header
operator|->
name|header
operator|.
name|linkflag
operator|=
name|LF_CONTIG
expr_stmt|;
block|}
endif|#
directive|endif
name|isextended
operator|=
name|header
operator|->
name|header
operator|.
name|isextended
expr_stmt|;
name|save_linkflag
operator|=
name|header
operator|->
name|header
operator|.
name|linkflag
expr_stmt|;
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|isextended
condition|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/*			register union record *exhdr;*/
name|int
name|arraybound
init|=
name|SPARSE_EXT_HDR
decl_stmt|;
comment|/* static */
name|int
name|index_offset
init|=
name|SPARSE_IN_HDR
decl_stmt|;
name|extend
label|:
name|exhdr
operator|=
name|findrec
argument_list|()
expr_stmt|;
if|if
condition|(
name|exhdr
operator|==
name|NULL
condition|)
goto|goto
name|badfile
goto|;
name|bzero
argument_list|(
name|exhdr
operator|->
name|charptr
argument_list|,
name|RECORDSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPARSE_EXT_HDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|+
name|index_offset
operator|>
name|upperbound
condition|)
break|break;
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|sparsearray
index|[
name|i
operator|+
name|index_offset
index|]
operator|.
name|numbytes
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|exhdr
operator|->
name|ext_hdr
operator|.
name|sp
index|[
name|i
index|]
operator|.
name|numbytes
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|sparsearray
index|[
name|i
operator|+
name|index_offset
index|]
operator|.
name|offset
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|exhdr
operator|->
name|ext_hdr
operator|.
name|sp
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
name|userec
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
comment|/*			sum += i; 			if (sum< upperbound) 				goto extend;*/
if|if
condition|(
name|index_offset
operator|+
name|i
operator|<
name|upperbound
condition|)
block|{
name|index_offset
operator|+=
name|i
expr_stmt|;
name|exhdr
operator|->
name|ext_hdr
operator|.
name|isextended
operator|++
expr_stmt|;
goto|goto
name|extend
goto|;
block|}
block|}
if|if
condition|(
name|save_linkflag
operator|==
name|LF_SPARSE
condition|)
block|{
if|if
condition|(
name|finish_sparse_file
argument_list|(
name|f
argument_list|,
operator|&
name|sizeleft
argument_list|,
name|hstat
operator|.
name|st_size
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|padit
goto|;
block|}
else|else
while|while
condition|(
name|sizeleft
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|f_multivol
condition|)
block|{
name|save_name
operator|=
name|p
expr_stmt|;
name|save_sizeleft
operator|=
name|sizeleft
expr_stmt|;
name|save_totsize
operator|=
name|hstat
operator|.
name|st_size
expr_stmt|;
block|}
name|start
operator|=
name|findrec
argument_list|()
expr_stmt|;
name|bufsize
operator|=
name|endofrecs
argument_list|()
operator|->
name|charptr
operator|-
name|start
operator|->
name|charptr
expr_stmt|;
if|if
condition|(
name|sizeleft
operator|<
name|bufsize
condition|)
block|{
comment|/* Last read -- zero out area beyond */
name|bufsize
operator|=
operator|(
name|int
operator|)
name|sizeleft
expr_stmt|;
name|count
operator|=
name|bufsize
operator|%
name|RECORDSIZE
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|bzero
argument_list|(
name|start
operator|->
name|charptr
operator|+
name|sizeleft
argument_list|,
call|(
name|int
call|)
argument_list|(
name|RECORDSIZE
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|start
operator|->
name|charptr
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"read error at byte %ld, reading\  %d bytes, in file %s"
argument_list|,
name|hstat
operator|.
name|st_size
operator|-
name|sizeleft
argument_list|,
name|bufsize
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|padit
goto|;
block|}
name|sizeleft
operator|-=
name|count
expr_stmt|;
comment|/* This is nonportable (the type of userec's arg). */
name|userec
argument_list|(
name|start
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|/
name|RECORDSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|bufsize
condition|)
continue|continue;
name|msg
argument_list|(
literal|"file %s shrunk by %d bytes, padding with zeros."
argument_list|,
name|p
argument_list|,
name|sizeleft
argument_list|)
expr_stmt|;
goto|goto
name|padit
goto|;
comment|/* Short read */
block|}
if|if
condition|(
name|f_multivol
condition|)
name|save_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * File shrunk or gave error, pad out tape to match 		 * the size we specified in the header. 		 */
name|padit
label|:
while|while
condition|(
name|sizeleft
operator|>
literal|0
condition|)
block|{
name|save_sizeleft
operator|=
name|sizeleft
expr_stmt|;
name|start
operator|=
name|findrec
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|start
operator|->
name|charptr
argument_list|,
name|RECORDSIZE
argument_list|)
expr_stmt|;
name|userec
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|sizeleft
operator|-=
name|RECORDSIZE
expr_stmt|;
block|}
if|if
condition|(
name|f_multivol
condition|)
name|save_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
break|break;
comment|/*		abort(); */
block|}
ifdef|#
directive|ifdef
name|S_IFLNK
case|case
name|S_IFLNK
case|:
comment|/* Symbolic link */
block|{
name|int
name|size
decl_stmt|;
name|hstat
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
comment|/* Force 0 size on symlink */
name|header
operator|=
name|start_header
argument_list|(
name|p
argument_list|,
operator|&
name|hstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
goto|goto
name|badfile
goto|;
name|size
operator|=
name|readlink
argument_list|(
name|p
argument_list|,
name|header
operator|->
name|header
operator|.
name|linkname
argument_list|,
name|NAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
goto|goto
name|badperror
goto|;
if|if
condition|(
name|size
operator|==
name|NAMSIZ
condition|)
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|readlink
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
comment|/* next_mangle(header->header.linkname); */
name|add_symlink_mangle
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
name|header
operator|->
name|header
operator|.
name|linkname
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|"symbolic link %s too long: mangling to %s"
argument_list|,
name|p
argument_list|,
name|header
operator|->
name|header
operator|.
name|linkname
argument_list|)
expr_stmt|;
comment|/* size=strlen(header->header.linkname); */
block|}
else|else
name|header
operator|->
name|header
operator|.
name|linkname
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|header
operator|->
name|header
operator|.
name|linkflag
operator|=
name|LF_SYMLINK
expr_stmt|;
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* Nothing more to do to it */
block|}
break|break;
endif|#
directive|endif
case|case
name|S_IFDIR
case|:
comment|/* Directory */
block|{
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|namebuf
decl_stmt|;
name|int
name|buflen
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|our_device
init|=
name|hstat
operator|.
name|st_dev
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ck_malloc
argument_list|()
decl_stmt|,
modifier|*
name|ck_realloc
argument_list|()
decl_stmt|;
comment|/* Build new prototype name */
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|len
operator|+
name|NAMSIZ
expr_stmt|;
name|namebuf
operator|=
name|ck_malloc
argument_list|(
name|buflen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|namebuf
argument_list|,
name|p
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>=
literal|1
operator|&&
literal|'/'
operator|==
name|namebuf
index|[
name|len
operator|-
literal|1
index|]
condition|)
name|len
operator|--
expr_stmt|;
comment|/* Delete trailing slashes */
name|namebuf
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
comment|/* Now add exactly one back */
name|namebuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Make sure null-terminated */
comment|/* 		 * Output directory header record with permissions 		 * FIXME, do this AFTER files, to avoid R/O dir problems? 		 * If old archive format, don't write record at all. 		 */
if|if
condition|(
operator|!
name|f_oldarch
condition|)
block|{
name|hstat
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
comment|/* Force 0 size on dir */
comment|/* 			 * If people could really read standard archives, 			 * this should be:		(FIXME) 			header = start_header(f_standard? p: namebuf,&hstat); 			 * but since they'd interpret LF_DIR records as 			 * regular files, we'd better put the / on the name. 			 */
name|header
operator|=
name|start_header
argument_list|(
name|namebuf
argument_list|,
operator|&
name|hstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
goto|goto
name|badfile
goto|;
comment|/* eg name too long */
if|if
condition|(
name|f_gnudump
condition|)
name|header
operator|->
name|header
operator|.
name|linkflag
operator|=
name|LF_DUMPDIR
expr_stmt|;
elseif|else
if|if
condition|(
name|f_standard
condition|)
name|header
operator|->
name|header
operator|.
name|linkflag
operator|=
name|LF_DIR
expr_stmt|;
comment|/* If we're gnudumping, we aren't done yet so don't close it. */
if|if
condition|(
operator|!
name|f_gnudump
condition|)
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* Done with directory header */
block|}
if|if
condition|(
name|f_gnudump
condition|)
block|{
name|int
name|sizeleft
decl_stmt|;
name|int
name|totsize
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|union
name|record
modifier|*
name|start
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p_buf
decl_stmt|;
name|buf
operator|=
name|gnu_list_name
operator|->
name|dir_contents
expr_stmt|;
comment|/* FOO */
name|totsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p_buf
operator|=
name|buf
init|;
name|p_buf
operator|&&
operator|*
name|p_buf
condition|;
control|)
block|{
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|strlen
argument_list|(
name|p_buf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|totsize
operator|+=
name|tmp
expr_stmt|;
name|p_buf
operator|+=
name|tmp
expr_stmt|;
block|}
name|totsize
operator|++
expr_stmt|;
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|totsize
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|size
argument_list|)
expr_stmt|;
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|p_buf
operator|=
name|buf
expr_stmt|;
name|sizeleft
operator|=
name|totsize
expr_stmt|;
while|while
condition|(
name|sizeleft
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|f_multivol
condition|)
block|{
name|save_name
operator|=
name|p
expr_stmt|;
name|save_sizeleft
operator|=
name|sizeleft
expr_stmt|;
name|save_totsize
operator|=
name|totsize
expr_stmt|;
block|}
name|start
operator|=
name|findrec
argument_list|()
expr_stmt|;
name|bufsize
operator|=
name|endofrecs
argument_list|()
operator|->
name|charptr
operator|-
name|start
operator|->
name|charptr
expr_stmt|;
if|if
condition|(
name|sizeleft
operator|<
name|bufsize
condition|)
block|{
name|bufsize
operator|=
name|sizeleft
expr_stmt|;
name|count
operator|=
name|bufsize
operator|%
name|RECORDSIZE
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|bzero
argument_list|(
name|start
operator|->
name|charptr
operator|+
name|sizeleft
argument_list|,
name|RECORDSIZE
operator|-
name|count
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|p_buf
argument_list|,
name|start
operator|->
name|charptr
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|sizeleft
operator|-=
name|bufsize
expr_stmt|;
name|p_buf
operator|+=
name|bufsize
expr_stmt|;
name|userec
argument_list|(
name|start
operator|+
operator|(
name|bufsize
operator|-
literal|1
operator|)
operator|/
name|RECORDSIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_multivol
condition|)
name|save_name
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Now output all the files in the directory */
comment|/* if (f_dironly) 			break;		/* Unless the cmdline said not to */
comment|/* 		 * See if we are crossing from one file system to another, 		 * and avoid doing so if the user only wants to dump one file system. 		 */
if|if
condition|(
name|f_local_filesys
operator|&&
name|curdev
operator|>=
literal|0
operator|&&
name|curdev
operator|!=
name|hstat
operator|.
name|st_dev
condition|)
block|{
if|if
condition|(
name|f_verbose
condition|)
name|msg
argument_list|(
literal|"%s: is on a different filesystem; not dumped"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirp
condition|)
block|{
if|if
condition|(
name|errno
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't open directory %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
argument_list|(
literal|"error opening directory %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Hack to remove "./" from the front of all the file names */
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|namebuf
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|namebuf
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Should speed this up by cd-ing into the dir, FIXME */
while|while
condition|(
name|NULL
operator|!=
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
condition|)
block|{
comment|/* Skip . and .. */
if|if
condition|(
name|is_dot_or_dotdot
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|DP_NAMELEN
argument_list|(
name|d
argument_list|)
operator|+
name|len
operator|>=
name|buflen
condition|)
block|{
name|buflen
operator|=
name|len
operator|+
name|DP_NAMELEN
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|namebuf
operator|=
name|ck_realloc
argument_list|(
name|namebuf
argument_list|,
name|buflen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* namebuf[len]='\0'; 				msg("file name %s%s too long",  					namebuf, d->d_name); 				continue; */
block|}
name|strcpy
argument_list|(
name|namebuf
operator|+
name|len
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_exclude
operator|&&
name|check_exclude
argument_list|(
name|namebuf
argument_list|)
condition|)
continue|continue;
name|dump_file
argument_list|(
name|namebuf
argument_list|,
name|our_device
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|S_IFCHR
case|case
name|S_IFCHR
case|:
comment|/* Character special file */
name|type
operator|=
name|LF_CHR
expr_stmt|;
goto|goto
name|easy
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFBLK
case|case
name|S_IFBLK
case|:
comment|/* Block     special file */
name|type
operator|=
name|LF_BLK
expr_stmt|;
goto|goto
name|easy
goto|;
endif|#
directive|endif
comment|/* Avoid screwy apollo lossage where S_IFIFO == S_IFSOCK */
if|#
directive|if
operator|(
operator|(
name|_ISP__M68K
operator|==
literal|0
operator|)
operator|&&
operator|(
name|_ISP__A88K
operator|==
literal|0
operator|)
operator|)
ifdef|#
directive|ifdef
name|S_IFIFO
case|case
name|S_IFIFO
case|:
comment|/* Fifo      special file */
name|type
operator|=
name|LF_FIFO
expr_stmt|;
goto|goto
name|easy
goto|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFSOCK
case|case
name|S_IFSOCK
case|:
comment|/* Socket	pretend its a fifo? */
name|type
operator|=
name|LF_FIFO
expr_stmt|;
goto|goto
name|easy
goto|;
endif|#
directive|endif
name|easy
label|:
if|if
condition|(
operator|!
name|f_standard
condition|)
goto|goto
name|unknown
goto|;
name|hstat
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
comment|/* Force 0 size */
name|header
operator|=
name|start_header
argument_list|(
name|p
argument_list|,
operator|&
name|hstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
goto|goto
name|badfile
goto|;
comment|/* eg name too long */
name|header
operator|->
name|header
operator|.
name|linkflag
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|LF_FIFO
condition|)
block|{
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|major
argument_list|(
name|hstat
operator|.
name|st_rdev
argument_list|)
argument_list|,
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|devmajor
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|minor
argument_list|(
name|hstat
operator|.
name|st_rdev
argument_list|)
argument_list|,
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|devminor
argument_list|)
expr_stmt|;
block|}
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unknown
label|:
name|msg
argument_list|(
literal|"%s: Unknown file type; file ignored."
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|int
name|finish_sparse_file
parameter_list|(
name|fd
parameter_list|,
name|sizeleft
parameter_list|,
name|fullsize
parameter_list|,
name|name
parameter_list|)
name|int
name|fd
decl_stmt|;
name|long
modifier|*
name|sizeleft
decl_stmt|,
name|fullsize
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|union
name|record
modifier|*
name|start
decl_stmt|;
name|char
name|tempbuf
index|[
name|RECORDSIZE
index|]
decl_stmt|;
name|int
name|bufsize
decl_stmt|,
name|sparse_ind
init|=
literal|0
decl_stmt|,
name|count
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|long
name|nwritten
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|sizeleft
operator|>
literal|0
condition|)
block|{
name|start
operator|=
name|findrec
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|start
operator|->
name|charptr
argument_list|,
name|RECORDSIZE
argument_list|)
expr_stmt|;
name|bufsize
operator|=
name|sparsearray
index|[
name|sparse_ind
index|]
operator|.
name|numbytes
expr_stmt|;
if|if
condition|(
operator|!
name|bufsize
condition|)
block|{
comment|/* we blew it, maybe */
name|msg
argument_list|(
literal|"Wrote %ld of %ld bytes to file %s"
argument_list|,
name|fullsize
operator|-
operator|*
name|sizeleft
argument_list|,
name|fullsize
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|pos
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
name|sparsearray
index|[
name|sparse_ind
operator|++
index|]
operator|.
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  		 * If the number of bytes to be written here exceeds 		 * the size of the temporary buffer, do it in steps. 		 */
while|while
condition|(
name|bufsize
operator|>
name|RECORDSIZE
condition|)
block|{
comment|/*			if (amt_read) { 				count = read(fd, start->charptr+amt_read, RECORDSIZE-amt_read); 				bufsize -= RECORDSIZE - amt_read; 				amt_read = 0; 				userec(start); 				start = findrec(); 				bzero(start->charptr, RECORDSIZE); 			}*/
comment|/* store the data */
name|count
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|start
operator|->
name|charptr
argument_list|,
name|RECORDSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"read error at byte %ld, reading %d bytes, in file %s"
argument_list|,
name|fullsize
operator|-
operator|*
name|sizeleft
argument_list|,
name|bufsize
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bufsize
operator|-=
name|count
expr_stmt|;
operator|*
name|sizeleft
operator|-=
name|count
expr_stmt|;
name|userec
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|nwritten
operator|+=
name|RECORDSIZE
expr_stmt|;
comment|/* XXX */
name|start
operator|=
name|findrec
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|start
operator|->
name|charptr
argument_list|,
name|RECORDSIZE
argument_list|)
expr_stmt|;
block|}
name|clear_buffer
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
name|count
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tempbuf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tempbuf
argument_list|,
name|start
operator|->
name|charptr
argument_list|,
name|RECORDSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"read error at byte %ld, reading %d bytes, in file %s"
argument_list|,
name|fullsize
operator|-
operator|*
name|sizeleft
argument_list|,
name|bufsize
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*		if (amt_read>= RECORDSIZE) { 			amt_read = 0; 			userec(start+(count-1)/RECORDSIZE); 			if (count != bufsize) { 				msg("file %s shrunk by %d bytes, padding with zeros.", name, sizeleft); 				return 1; 			} 			start = findrec(); 		} else  			amt_read += bufsize;*/
name|nwritten
operator|+=
name|count
expr_stmt|;
comment|/* XXX */
operator|*
name|sizeleft
operator|-=
name|count
expr_stmt|;
name|userec
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sparsearray
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Amount actually written is (I hope) %d.\n"
argument_list|,
name|nwritten
argument_list|)
expr_stmt|;
comment|/*	userec(start+(count-1)/RECORDSIZE);*/
return|return
literal|0
return|;
block|}
name|init_sparsearray
argument_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|sp_array_size
operator|=
literal|10
expr_stmt|;
comment|/*  	 * Make room for our scratch space -- initially is 10 elts long 	 */
name|sparsearray
operator|=
operator|(
expr|struct
name|sp_array
operator|*
operator|)
name|malloc
argument_list|(
name|sp_array_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sp_array
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp_array_size
condition|;
name|i
operator|++
control|)
block|{
name|sparsearray
index|[
name|i
index|]
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|sparsearray
index|[
name|i
index|]
operator|.
name|numbytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*  * Okay, we've got a sparse file on our hands -- now, what we need to do is  * make a pass through the file and carefully note where any data is, i.e.,  * we want to find how far into the file each instance of data is, and how  * many bytes are there.  We store this information in the sparsearray,  * which will later be translated into header information.  For now, we use  * the sparsearray as convenient storage.  *  * As a side note, this routine is a mess.  If I could have found a cleaner  * way to do it, I would have.  If anyone wants to find a nicer way to do  * this, feel free.  */
comment|/* There is little point in trimming small amounts of null data at the */
comment|/* head and tail of blocks -- it's ok if we only avoid dumping blocks */
comment|/* of complete null data */
name|int
name|deal_with_sparse
parameter_list|(
name|name
parameter_list|,
name|header
parameter_list|,
name|nulls_at_end
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|union
name|record
modifier|*
name|header
decl_stmt|;
block|{
name|long
name|numbytes
init|=
literal|0
decl_stmt|;
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|long
name|save_offset
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|current_size
init|=
name|hstat
operator|.
name|st_size
decl_stmt|;
name|int
name|sparse_ind
init|=
literal|0
decl_stmt|,
name|cc
decl_stmt|;
name|char
name|buf
index|[
name|RECORDSIZE
index|]
decl_stmt|;
name|int
name|read_last_data
init|=
literal|0
decl_stmt|;
comment|/* did we just read the last record? */
name|int
name|amidst_data
init|=
literal|0
decl_stmt|;
name|header
operator|->
name|header
operator|.
name|isextended
operator|=
literal|0
expr_stmt|;
comment|/*  	 * Can't open the file -- this problem will be caught later on, 	 * so just return. 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|init_sparsearray
argument_list|()
expr_stmt|;
name|clear_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cc
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sparse_ind
operator|>
name|sp_array_size
operator|-
literal|1
condition|)
block|{
comment|/* 		 * realloc the scratch area, since we've run out of room -- 		 */
name|sparsearray
operator|=
operator|(
expr|struct
name|sp_array
operator|*
operator|)
name|realloc
argument_list|(
name|sparsearray
argument_list|,
literal|2
operator|*
name|sp_array_size
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sp_array
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sp_array_size
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|==
sizeof|sizeof
name|buf
condition|)
block|{
if|if
condition|(
name|zero_record
argument_list|(
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|amidst_data
condition|)
block|{
name|sparsearray
index|[
name|sparse_ind
operator|++
index|]
operator|.
name|numbytes
operator|=
name|numbytes
expr_stmt|;
name|amidst_data
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* !zero_record(buf) */
if|if
condition|(
name|amidst_data
condition|)
name|numbytes
operator|+=
name|cc
expr_stmt|;
else|else
block|{
name|amidst_data
operator|=
literal|1
expr_stmt|;
name|numbytes
operator|=
name|cc
expr_stmt|;
name|sparsearray
index|[
name|sparse_ind
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|cc
operator|<
sizeof|sizeof
name|buf
condition|)
block|{
comment|/* This has to be the last bit of the file, so this */
comment|/* is somewhat shorter than the above. */
if|if
condition|(
operator|!
name|zero_record
argument_list|(
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|amidst_data
condition|)
block|{
name|amidst_data
operator|=
literal|1
expr_stmt|;
name|numbytes
operator|=
name|cc
expr_stmt|;
name|sparsearray
index|[
name|sparse_ind
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
else|else
name|numbytes
operator|+=
name|cc
expr_stmt|;
block|}
block|}
name|offset
operator|+=
name|cc
expr_stmt|;
name|clear_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|amidst_data
condition|)
name|sparsearray
index|[
name|sparse_ind
operator|++
index|]
operator|.
name|numbytes
operator|=
name|numbytes
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|sparse_ind
operator|-
literal|1
return|;
block|}
comment|/*   * Just zeroes out the buffer so we don't confuse ourselves with leftover  * data.  */
name|clear_buffer
argument_list|(
argument|buf
argument_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RECORDSIZE
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* I'm leaving this as a monument to Joy Kendall, who wrote it */
comment|/*   * JK -   * This routine takes a character array, and tells where within that array  * the data can be found.  It skips over any zeros, and sets the first  * non-zero point in the array to be the "start", and continues until it  * finds non-data again, which is marked as the "end."  This routine is   * mainly for 1) seeing how far into a file we must lseek to data, given  * that we have a sparse file, and 2) determining the "real size" of the  * file, i.e., the number of bytes in the sparse file that are data, as  * opposed to the zeros we are trying to skip.  */
block|where_is_data(from, to, buffer) 	int	*from, 		*to; 	char	*buffer; { 	register int	i = 0; 	register int	save_to = *to; 	int	amidst_data = 0;  	 	while (!buffer[i]) 		i++; 	*from = i;  	if (*from< 16)
comment|/* don't bother */
block|*from = 0;
comment|/* keep going to make sure there isn't more real 	   data in this record */
block|while (i< RECORDSIZE) { 		if (!buffer[i]) { 			if (amidst_data) { 				save_to = i; 				amidst_data = 0; 			} 			i++; 		} 		else if (buffer[i]) { 			if (!amidst_data) 				amidst_data = 1; 			i++; 		} 	} 	if (i == RECORDSIZE) 		*to = i; 	else 		*to = save_to; 		 }
endif|#
directive|endif
comment|/* Note that this routine is only called if zero_record returned true */
if|#
directive|if
literal|0
comment|/* But we actually don't need it at all. */
block|where_is_data (from, to, buffer)      int *from, *to;      char *buffer; {   char *fp, *tp;    for (fp = buffer; ! *fp; fp++)     ;   for (tp = buffer + RECORDSIZE - 1; ! *tp; tp--)     ;   *from = fp - buffer;   *to = tp - buffer + 1; }
endif|#
directive|endif
comment|/*  * Takes a recordful of data and basically cruises through it to see if  * it's made *entirely* of zeros, returning a 0 the instant it finds  * something that is a non-zero, i.e., useful data.  */
name|zero_record
argument_list|(
argument|buffer
argument_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RECORDSIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|!=
literal|'\000'
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
name|find_new_file_size
argument_list|(
argument|filesize
argument_list|,
argument|highest_index
argument_list|)
name|int
modifier|*
name|filesize
decl_stmt|;
name|int
name|highest_index
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
operator|*
name|filesize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sparsearray
index|[
name|i
index|]
operator|.
name|numbytes
operator|&&
name|i
operator|<=
name|highest_index
condition|;
name|i
operator|++
control|)
operator|*
name|filesize
operator|+=
name|sparsearray
index|[
name|i
index|]
operator|.
name|numbytes
expr_stmt|;
block|}
comment|/*  * Make a header block for the file  name  whose stat info is  st .  * Return header pointer for success, NULL if the name is too long.  */
name|union
name|record
modifier|*
name|start_header
parameter_list|(
name|name
parameter_list|,
name|st
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
block|{
specifier|register
name|union
name|record
modifier|*
name|header
decl_stmt|;
name|header
operator|=
operator|(
expr|union
name|record
operator|*
operator|)
name|findrec
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|header
operator|->
name|charptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX speed up */
comment|/* 	 * Check the file name and put it in the record. 	 */
if|if
condition|(
operator|!
name|f_absolute_paths
condition|)
block|{
specifier|static
name|int
name|warned_once
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|__MSDOS__
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|name
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|warned_once
operator|++
condition|)
name|msg
argument_list|(
literal|"Removing drive spec from names in the archive"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
literal|'/'
operator|==
operator|*
name|name
condition|)
block|{
name|name
operator|++
expr_stmt|;
comment|/* Force relative path */
if|if
condition|(
operator|!
name|warned_once
operator|++
condition|)
name|msg
argument_list|(
literal|"Removing leading / from absolute path names in the archive."
argument_list|)
expr_stmt|;
block|}
block|}
name|strncpy
argument_list|(
name|header
operator|->
name|header
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|NAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|header
operator|.
name|name
index|[
name|NAMSIZ
operator|-
literal|1
index|]
condition|)
block|{
name|char
modifier|*
name|mangled
decl_stmt|;
comment|/* next_mangle(header->header.name); */
name|add_mangle
argument_list|(
name|name
argument_list|,
name|header
operator|->
name|header
operator|.
name|name
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|"%s: is too long: mangling to %s"
argument_list|,
name|name
argument_list|,
name|header
operator|->
name|header
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|to_oct
argument_list|(
call|(
name|long
call|)
argument_list|(
name|st
operator|->
name|st_mode
operator|&
operator|~
name|S_IFMT
argument_list|)
argument_list|,
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|mode
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|st
operator|->
name|st_uid
argument_list|,
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|uid
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|st
operator|->
name|st_gid
argument_list|,
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|gid
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|st
operator|->
name|st_size
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|size
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|st
operator|->
name|st_mtime
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|mtime
argument_list|)
expr_stmt|;
comment|/* header->header.linkflag is left as null */
if|if
condition|(
name|f_gnudump
condition|)
block|{
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|st
operator|->
name|st_atime
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|atime
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|st
operator|->
name|st_ctime
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|ctime
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NONAMES
comment|/* Fill in new Unix Standard fields if desired. */
if|if
condition|(
name|f_standard
condition|)
block|{
name|header
operator|->
name|header
operator|.
name|linkflag
operator|=
name|LF_NORMAL
expr_stmt|;
comment|/* New default */
name|strcpy
argument_list|(
name|header
operator|->
name|header
operator|.
name|magic
argument_list|,
name|TMAGIC
argument_list|)
expr_stmt|;
comment|/* Mark as Unix Std */
name|finduname
argument_list|(
name|header
operator|->
name|header
operator|.
name|uname
argument_list|,
name|st
operator|->
name|st_uid
argument_list|)
expr_stmt|;
name|findgname
argument_list|(
name|header
operator|->
name|header
operator|.
name|gname
argument_list|,
name|st
operator|->
name|st_gid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|header
return|;
block|}
comment|/*   * Finish off a filled-in header block and write it out.  * We also print the file name and/or full info if verbose is on.  */
name|void
name|finish_header
parameter_list|(
name|header
parameter_list|)
specifier|register
name|union
name|record
modifier|*
name|header
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|sum
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|void
name|bcopy
parameter_list|()
function_decl|;
name|bcopy
argument_list|(
name|CHKBLANKS
argument_list|,
name|header
operator|->
name|header
operator|.
name|chksum
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|header
operator|.
name|chksum
argument_list|)
argument_list|)
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|header
operator|->
name|charptr
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
comment|/* 		 * We can't use unsigned char here because of old compilers, 		 * e.g. V7. 		 */
name|sum
operator|+=
literal|0xFF
operator|&
operator|*
name|p
operator|++
expr_stmt|;
block|}
comment|/* 	 * Fill in the checksum field.  It's formatted differently 	 * from the other fields:  it has [6] digits, a null, then a 	 * space -- rather than digits, a space, then a null. 	 * We use to_oct then write the null in over to_oct's space. 	 * The final space is already there, from checksumming, and 	 * to_oct doesn't modify it. 	 * 	 * This is a fast way to do: 	 * (void) sprintf(header->header.chksum, "%6o", sum); 	 */
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|sum
argument_list|,
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|chksum
argument_list|)
expr_stmt|;
name|header
operator|->
name|header
operator|.
name|chksum
index|[
literal|6
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Zap the space */
name|userec
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_verbose
condition|)
block|{
specifier|extern
name|union
name|record
modifier|*
name|head
decl_stmt|;
comment|/* Points to current tape header */
specifier|extern
name|int
name|head_standard
decl_stmt|;
comment|/* Tape header is in ANSI format */
comment|/* These globals are parameters to print_header, sigh */
name|head
operator|=
name|header
expr_stmt|;
comment|/* hstat is already set up */
name|head_standard
operator|=
name|f_standard
expr_stmt|;
name|print_header
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|/*  * Quick and dirty octal conversion.  * Converts long "value" into a "digs"-digit field at "where",  * including a trailing space and room for a null.  "digs"==3 means  * 1 digit, a space, and room for a null.  *  * We assume the trailing null is already there and don't fill it in.  * This fact is used by start_header and finish_header, so don't change it!  *  * This should be equivalent to:  *	(void) sprintf(where, "%*lo ", digs-2, value);  * except that sprintf fills in the trailing null and we don't.  */
name|void
name|to_oct
parameter_list|(
name|value
parameter_list|,
name|digs
parameter_list|,
name|where
parameter_list|)
specifier|register
name|long
name|value
decl_stmt|;
specifier|register
name|int
name|digs
decl_stmt|;
specifier|register
name|char
modifier|*
name|where
decl_stmt|;
block|{
operator|--
name|digs
expr_stmt|;
comment|/* Trailing null slot is left alone */
name|where
index|[
operator|--
name|digs
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Put in the space, though */
comment|/* Produce the digits -- at least one */
do|do
block|{
name|where
index|[
operator|--
name|digs
index|]
operator|=
literal|'0'
operator|+
call|(
name|char
call|)
argument_list|(
name|value
operator|&
literal|7
argument_list|)
expr_stmt|;
comment|/* one octal digit */
name|value
operator|>>=
literal|3
expr_stmt|;
block|}
do|while
condition|(
name|digs
operator|>
literal|0
operator|&&
name|value
operator|!=
literal|0
condition|)
do|;
comment|/* Leading spaces, if necessary */
while|while
condition|(
name|digs
operator|>
literal|0
condition|)
name|where
index|[
operator|--
name|digs
index|]
operator|=
literal|' '
expr_stmt|;
block|}
comment|/*  * Write the EOT record(s).  * We actually zero at least one record, through the end of the block.  * Old tar writes garbage after two zeroed records -- and PDtar used to.  */
name|write_eot
argument_list|()
block|{
name|union
name|record
modifier|*
name|p
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|void
name|bzero
parameter_list|()
function_decl|;
name|p
operator|=
name|findrec
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|bufsize
operator|=
name|endofrecs
argument_list|()
operator|->
name|charptr
operator|-
name|p
operator|->
name|charptr
expr_stmt|;
name|bzero
argument_list|(
name|p
operator|->
name|charptr
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|userec
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

