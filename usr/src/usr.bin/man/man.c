begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1987, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1987, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)man.c	8.7 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<glob.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
name|int
name|f_all
decl_stmt|,
name|f_where
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_page
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cat
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|check_pager
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|how
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|jump
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|manual
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|ENTRY
operator|*
operator|,
name|glob_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|onsig
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|ENTRY
modifier|*
name|defp
decl_stmt|,
modifier|*
name|defnewp
decl_stmt|,
modifier|*
name|intmpp
decl_stmt|;
name|ENTRY
modifier|*
name|section
decl_stmt|,
modifier|*
name|sectp
decl_stmt|,
modifier|*
name|sectnewp
decl_stmt|,
modifier|*
name|subp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|glob_t
name|pg
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|f_cat
decl_stmt|,
name|f_how
decl_stmt|,
name|found
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|machine
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|p_add
decl_stmt|,
modifier|*
name|p_path
decl_stmt|,
modifier|*
name|pager
decl_stmt|,
modifier|*
name|slashp
decl_stmt|;
name|char
modifier|*
name|conffile
decl_stmt|,
name|buf
index|[
name|MAXPATHLEN
operator|*
literal|2
index|]
decl_stmt|;
name|conffile
operator|=
name|NULL
expr_stmt|;
name|f_cat
operator|=
name|f_how
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"-aC:cfhkM:m:P:w"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|f_all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|conffile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
case|case
literal|'-'
case|:
comment|/* Deprecated. */
name|f_cat
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|f_how
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|p_add
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'P'
case|:
comment|/* Backward compatibility. */
name|p_path
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* 		 * The -f and -k options are backward compatible, 		 * undocumented ways of calling whatis(1) and apropos(1). 		 */
case|case
literal|'f'
case|:
name|jump
argument_list|(
name|argv
argument_list|,
literal|"-f"
argument_list|,
literal|"whatis"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'k'
case|:
name|jump
argument_list|(
name|argv
argument_list|,
literal|"-k"
argument_list|,
literal|"apropos"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'w'
case|:
name|f_all
operator|=
name|f_where
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|f_cat
operator|&&
operator|!
name|f_how
condition|)
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
name|f_cat
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|pager
operator|=
name|getenv
argument_list|(
literal|"PAGER"
argument_list|)
condition|)
name|pager
operator|=
name|check_pager
argument_list|(
name|pager
argument_list|)
expr_stmt|;
else|else
name|pager
operator|=
name|_PATH_PAGER
expr_stmt|;
comment|/* Read the configuration file. */
name|config
argument_list|(
name|conffile
argument_list|)
expr_stmt|;
comment|/* If there's no _default list, create an empty one. */
if|if
condition|(
operator|(
name|defp
operator|=
name|getlist
argument_list|(
literal|"_default"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|defp
operator|=
name|addlist
argument_list|(
literal|"_default"
argument_list|)
expr_stmt|;
comment|/* Get the machine type. */
if|if
condition|(
operator|(
name|machine
operator|=
name|getenv
argument_list|(
literal|"MACHINE"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|machine
operator|=
name|MACHINE
expr_stmt|;
comment|/* 	 * 1: If the user specified a MANPATH variable, or set the -M 	 *    option, we replace the _default list with the user's list, 	 *    appending the entries in the _subdir list and the machine. 	 */
if|if
condition|(
name|p_path
operator|==
name|NULL
condition|)
name|p_path
operator|=
name|getenv
argument_list|(
literal|"MANPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_path
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|tp
operator|=
name|defp
operator|->
name|list
operator|.
name|qe_next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tp
operator|->
name|s
argument_list|)
expr_stmt|;
name|queue_remove
argument_list|(
operator|&
name|defp
operator|->
name|list
argument_list|,
name|tp
argument_list|,
name|ENTRY
operator|*
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
name|p_path
argument_list|,
literal|":"
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
control|)
block|{
name|slashp
operator|=
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|?
literal|""
else|:
literal|"/"
expr_stmt|;
name|subp
operator|=
name|getlist
argument_list|(
literal|"_subdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subp
operator|!=
name|NULL
condition|)
name|subp
operator|=
name|subp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
init|;
name|subp
operator|!=
name|NULL
condition|;
name|subp
operator|=
name|subp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s%s{/%s,}"
argument_list|,
name|p
argument_list|,
name|slashp
argument_list|,
name|subp
operator|->
name|s
argument_list|,
name|machine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ENTRY
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tp
operator|->
name|s
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|queue_enter_tail
argument_list|(
operator|&
name|defp
operator|->
name|list
argument_list|,
name|tp
argument_list|,
name|ENTRY
operator|*
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * 2: If the user did not specify MANPATH, -M or a section, rewrite 	 *    the _default list to include the _subdir list and the machine. 	 */
if|if
condition|(
operator|(
name|section
operator|=
name|getlist
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|++
name|argv
expr_stmt|;
if|if
condition|(
name|p_path
operator|==
name|NULL
operator|&&
name|section
operator|==
name|NULL
condition|)
block|{
name|defnewp
operator|=
name|addlist
argument_list|(
literal|"_default_new"
argument_list|)
expr_stmt|;
if|if
condition|(
name|defp
operator|->
name|list
operator|.
name|qe_next
operator|!=
name|NULL
condition|)
name|defp
operator|=
name|defp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
init|;
name|defp
operator|!=
name|NULL
condition|;
name|defp
operator|=
name|defp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
name|slashp
operator|=
name|defp
operator|->
name|s
index|[
name|strlen
argument_list|(
name|defp
operator|->
name|s
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|?
literal|""
else|:
literal|"/"
expr_stmt|;
name|subp
operator|=
name|getlist
argument_list|(
literal|"_subdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subp
operator|!=
name|NULL
condition|)
name|subp
operator|=
name|subp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
init|;
name|subp
operator|!=
name|NULL
condition|;
name|subp
operator|=
name|subp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s%s{/%s,}"
argument_list|,
name|defp
operator|->
name|s
argument_list|,
name|slashp
argument_list|,
name|subp
operator|->
name|s
argument_list|,
name|machine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ENTRY
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tp
operator|->
name|s
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|queue_enter_tail
argument_list|(
operator|&
name|defnewp
operator|->
name|list
argument_list|,
name|tp
argument_list|,
name|ENTRY
operator|*
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
name|defp
operator|=
name|getlist
argument_list|(
literal|"_default"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|tp
operator|=
name|defp
operator|->
name|list
operator|.
name|qe_next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tp
operator|->
name|s
argument_list|)
expr_stmt|;
name|queue_remove
argument_list|(
operator|&
name|defp
operator|->
name|list
argument_list|,
name|tp
argument_list|,
name|ENTRY
operator|*
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|defp
operator|->
name|s
argument_list|)
expr_stmt|;
name|queue_remove
argument_list|(
operator|&
name|defp
operator|->
name|tags
argument_list|,
name|defp
argument_list|,
name|ENTRY
operator|*
argument_list|,
name|tags
argument_list|)
expr_stmt|;
name|defnewp
operator|=
name|getlist
argument_list|(
literal|"_default_new"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|defnewp
operator|->
name|s
argument_list|)
expr_stmt|;
name|defnewp
operator|->
name|s
operator|=
literal|"_default"
expr_stmt|;
name|defp
operator|=
name|defnewp
expr_stmt|;
block|}
comment|/* 	 * 3: If the user set the -m option, insert the user's list before 	 *    whatever list we have, again appending the _subdir list and 	 *    the machine. 	 */
if|if
condition|(
name|p_add
operator|!=
name|NULL
condition|)
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
name|p_add
argument_list|,
literal|":"
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
control|)
block|{
name|slashp
operator|=
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|?
literal|""
else|:
literal|"/"
expr_stmt|;
name|subp
operator|=
name|getlist
argument_list|(
literal|"_subdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subp
operator|!=
name|NULL
condition|)
name|subp
operator|=
name|subp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
init|;
name|subp
operator|!=
name|NULL
condition|;
name|subp
operator|=
name|subp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s%s{/%s,}"
argument_list|,
name|p
argument_list|,
name|slashp
argument_list|,
name|subp
operator|->
name|s
argument_list|,
name|machine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ENTRY
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tp
operator|->
name|s
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|queue_enter_head
argument_list|(
operator|&
name|defp
operator|->
name|list
argument_list|,
name|tp
argument_list|,
name|ENTRY
operator|*
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * 4: If none of MANPATH, -M, or -m were specified, and a section was, 	 *    rewrite the section's paths (if they have a trailing slash) to 	 *    append the _subdir list and the machine.  This then becomes the 	 *    _default list. 	 */
if|if
condition|(
name|p_path
operator|==
name|NULL
operator|&&
name|p_add
operator|==
name|NULL
operator|&&
name|section
operator|!=
name|NULL
condition|)
block|{
name|sectnewp
operator|=
name|addlist
argument_list|(
literal|"_section_new"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sectp
operator|=
name|section
operator|)
operator|->
name|list
operator|.
name|qe_next
operator|!=
name|NULL
condition|)
name|sectp
operator|=
name|sectp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
init|;
name|sectp
operator|!=
name|NULL
condition|;
name|sectp
operator|=
name|sectp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
if|if
condition|(
name|sectp
operator|->
name|s
index|[
name|strlen
argument_list|(
name|sectp
operator|->
name|s
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s{/%s,}"
argument_list|,
name|sectp
operator|->
name|s
argument_list|,
name|machine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ENTRY
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tp
operator|->
name|s
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|queue_enter_tail
argument_list|(
operator|&
name|sectnewp
operator|->
name|list
argument_list|,
name|tp
argument_list|,
name|ENTRY
operator|*
argument_list|,
name|list
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|subp
operator|=
name|getlist
argument_list|(
literal|"_subdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subp
operator|!=
name|NULL
condition|)
name|subp
operator|=
name|subp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
init|;
name|subp
operator|!=
name|NULL
condition|;
name|subp
operator|=
name|subp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s{/%s,}"
argument_list|,
name|sectp
operator|->
name|s
argument_list|,
name|subp
operator|->
name|s
argument_list|,
name|machine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ENTRY
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tp
operator|->
name|s
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|queue_enter_tail
argument_list|(
operator|&
name|sectnewp
operator|->
name|list
argument_list|,
name|tp
argument_list|,
name|ENTRY
operator|*
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
name|sectnewp
operator|->
name|s
operator|=
name|section
operator|->
name|s
expr_stmt|;
name|defp
operator|=
name|sectnewp
expr_stmt|;
name|queue_remove
argument_list|(
operator|&
name|section
operator|->
name|tags
argument_list|,
name|section
argument_list|,
name|ENTRY
operator|*
argument_list|,
name|tags
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 5: Search for the files.  Set up an interrupt handler, so the 	 *    temporary files go away. 	 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|found
operator|=
literal|0
init|;
operator|*
name|argv
condition|;
operator|++
name|argv
control|)
if|if
condition|(
name|manual
argument_list|(
operator|*
name|argv
argument_list|,
name|defp
argument_list|,
operator|&
name|pg
argument_list|)
condition|)
name|found
operator|=
literal|1
expr_stmt|;
comment|/* 	 * 7: If nothing found, we're done. 	 */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 8: If it's simple, display it fast. */
if|if
condition|(
name|f_cat
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|pg
operator|.
name|gl_pathv
init|;
operator|*
name|ap
operator|!=
name|NULL
condition|;
operator|++
name|ap
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|ap
operator|==
literal|'\0'
condition|)
continue|continue;
name|cat
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f_all
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|intmpp
operator|!=
name|NULL
condition|)
name|intmpp
operator|=
name|intmpp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
init|;
name|intmpp
operator|!=
name|NULL
condition|;
name|intmpp
operator|=
name|intmpp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
name|cat
argument_list|(
name|intmpp
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f_all
condition|)
break|break;
block|}
block|}
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_how
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|pg
operator|.
name|gl_pathv
init|;
operator|*
name|ap
operator|!=
name|NULL
condition|;
operator|++
name|ap
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|ap
operator|==
literal|'\0'
condition|)
continue|continue;
name|how
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f_all
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|intmpp
operator|=
name|getlist
argument_list|(
literal|"_intmp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intmpp
operator|!=
name|NULL
condition|)
name|intmpp
operator|=
name|intmpp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
init|;
name|intmpp
operator|!=
name|NULL
condition|;
name|intmpp
operator|=
name|intmpp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
name|how
argument_list|(
name|intmpp
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f_all
condition|)
break|break;
block|}
block|}
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_where
condition|)
block|{
for|for
control|(
name|ap
operator|=
name|pg
operator|.
name|gl_pathv
init|;
operator|*
name|ap
operator|!=
name|NULL
condition|;
operator|++
name|ap
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|ap
operator|==
literal|'\0'
condition|)
continue|continue;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
block|}
name|intmpp
operator|=
name|getlist
argument_list|(
literal|"_intmp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intmpp
operator|!=
name|NULL
condition|)
name|intmpp
operator|=
name|intmpp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
init|;
name|intmpp
operator|!=
name|NULL
condition|;
name|intmpp
operator|=
name|intmpp
operator|->
name|list
operator|.
name|qe_next
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|intmpp
operator|->
name|s
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 9: We display things in a single command; build a list of things 	 *    to display. 	 */
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|pg
operator|.
name|gl_pathv
operator|,
name|len
operator|=
name|strlen
argument_list|(
name|pager
argument_list|)
operator|+
literal|1
init|;
operator|*
name|ap
operator|!=
name|NULL
condition|;
operator|++
name|ap
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|ap
operator|==
literal|'\0'
condition|)
continue|continue;
name|len
operator|+=
name|strlen
argument_list|(
operator|*
name|ap
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|f_all
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|intmpp
operator|=
name|getlist
argument_list|(
literal|"_intmp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intmpp
operator|!=
name|NULL
condition|)
name|intmpp
operator|=
name|intmpp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
init|;
name|intmpp
operator|!=
name|NULL
condition|;
name|intmpp
operator|=
name|intmpp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|intmpp
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f_all
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|cmd
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|cmd
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|pager
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|pager
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|pg
operator|.
name|gl_pathv
init|;
operator|*
name|ap
operator|!=
name|NULL
condition|;
operator|++
name|ap
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|ap
operator|==
literal|'\0'
condition|)
continue|continue;
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
operator|*
name|ap
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
name|f_all
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|intmpp
operator|=
name|getlist
argument_list|(
literal|"_intmp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intmpp
operator|!=
name|NULL
condition|)
name|intmpp
operator|=
name|intmpp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
init|;
name|intmpp
operator|!=
name|NULL
condition|;
name|intmpp
operator|=
name|intmpp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|intmpp
operator|->
name|s
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|intmpp
operator|->
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Use system(3) in case someone's pager is "pager arg1 arg2". */
operator|(
name|void
operator|)
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * manual --  *	Search the manuals for the pages.  */
end_comment

begin_function
specifier|static
name|int
name|manual
parameter_list|(
name|page
parameter_list|,
name|list
parameter_list|,
name|pg
parameter_list|)
name|char
modifier|*
name|page
decl_stmt|;
name|ENTRY
modifier|*
name|list
decl_stmt|;
name|glob_t
modifier|*
name|pg
decl_stmt|;
block|{
name|ENTRY
modifier|*
name|listp
decl_stmt|,
modifier|*
name|missp
decl_stmt|,
modifier|*
name|sufp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|int
name|anyfound
decl_stmt|,
name|cnt
decl_stmt|,
name|found
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|anyfound
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
comment|/* For each element in the list... */
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
name|list
operator|=
name|list
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
name|listp
operator|=
name|list
init|;
name|listp
operator|!=
name|NULL
condition|;
name|listp
operator|=
name|listp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s/%s.*"
argument_list|,
name|listp
operator|->
name|s
argument_list|,
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|glob
argument_list|(
name|buf
argument_list|,
name|GLOB_APPEND
operator||
name|GLOB_BRACE
operator||
name|GLOB_NOSORT
operator||
name|GLOB_QUOTE
argument_list|,
name|NULL
argument_list|,
name|pg
argument_list|)
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"globbing"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pg
operator|->
name|gl_matchc
operator|==
literal|0
condition|)
continue|continue;
comment|/* Find out if it's really a man page. */
for|for
control|(
name|cnt
operator|=
name|pg
operator|->
name|gl_pathc
operator|-
name|pg
operator|->
name|gl_matchc
init|;
name|cnt
operator|<
name|pg
operator|->
name|gl_pathc
condition|;
operator|++
name|cnt
control|)
block|{
comment|/* 			 * Try the _suffix key words first. 			 * 			 * XXX 			 * Older versions of man.conf didn't have the suffix 			 * key words, it was assumed that everything was a .0. 			 * We just test for .0 first, it's fast and probably 			 * going to hit. 			 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"*/%s.0"
argument_list|,
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fnmatch
argument_list|(
name|buf
argument_list|,
name|pg
operator|->
name|gl_pathv
index|[
name|cnt
index|]
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|easy
goto|;
name|sufp
operator|=
name|getlist
argument_list|(
literal|"_suffix"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sufp
operator|!=
name|NULL
condition|)
name|sufp
operator|=
name|sufp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
name|found
operator|=
literal|0
init|;
name|sufp
operator|!=
name|NULL
condition|;
name|sufp
operator|=
name|sufp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"*/%s%s"
argument_list|,
name|page
argument_list|,
name|sufp
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fnmatch
argument_list|(
name|buf
argument_list|,
name|pg
operator|->
name|gl_pathv
index|[
name|cnt
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
name|easy
label|:
name|anyfound
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|f_all
condition|)
break|break;
continue|continue;
block|}
comment|/* Try the _build key words next. */
name|sufp
operator|=
name|getlist
argument_list|(
literal|"_build"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sufp
operator|!=
name|NULL
condition|)
name|sufp
operator|=
name|sufp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
name|found
operator|=
literal|0
init|;
name|sufp
operator|!=
name|NULL
condition|;
name|sufp
operator|=
name|sufp
operator|->
name|list
operator|.
name|qe_next
control|)
block|{
for|for
control|(
name|p
operator|=
name|sufp
operator|->
name|s
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
continue|continue;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"*/%s%s"
argument_list|,
name|page
argument_list|,
name|sufp
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fnmatch
argument_list|(
name|buf
argument_list|,
name|pg
operator|->
name|gl_pathv
index|[
name|cnt
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|f_where
condition|)
block|{
name|build_page
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|pg
operator|->
name|gl_pathv
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|pg
operator|->
name|gl_pathv
index|[
name|cnt
index|]
operator|=
literal|""
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
name|anyfound
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|f_all
condition|)
break|break;
continue|continue;
block|}
comment|/* It's not a man page, forget about it. */
name|pg
operator|->
name|gl_pathv
index|[
name|cnt
index|]
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|anyfound
operator|&&
operator|!
name|f_all
condition|)
break|break;
block|}
comment|/* If not found, enter onto the missing list. */
if|if
condition|(
operator|!
name|anyfound
condition|)
block|{
if|if
condition|(
operator|(
name|missp
operator|=
name|getlist
argument_list|(
literal|"_missing"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|missp
operator|=
name|addlist
argument_list|(
literal|"_missing"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ENTRY
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tp
operator|->
name|s
operator|=
name|strdup
argument_list|(
name|page
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|queue_enter_tail
argument_list|(
operator|&
name|missp
operator|->
name|list
argument_list|,
name|tp
argument_list|,
name|ENTRY
operator|*
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|anyfound
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * build_page --  *	Build a man page for display.  */
end_comment

begin_function
specifier|static
name|void
name|build_page
parameter_list|(
name|fmt
parameter_list|,
name|path
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|,
decl|*
name|path
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|int
name|warned
decl_stmt|;
name|ENTRY
modifier|*
name|intmpp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|cmd
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|tpath
index|[
sizeof|sizeof
argument_list|(
name|_PATH_TMP
argument_list|)
index|]
decl_stmt|;
comment|/* Let the user know this may take awhile. */
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|warned
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"Formatting manual page..."
argument_list|)
expr_stmt|;
block|}
comment|/* Add an "in tmp" list. */
if|if
condition|(
operator|(
name|intmpp
operator|=
name|getlist
argument_list|(
literal|"_intmp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|intmpp
operator|=
name|addlist
argument_list|(
literal|"_intmp"
argument_list|)
expr_stmt|;
comment|/* Move to the printf(3) format string. */
for|for
control|(
init|;
operator|*
name|fmt
operator|&&
name|isspace
argument_list|(
operator|*
name|fmt
argument_list|)
condition|;
operator|++
name|fmt
control|)
empty_stmt|;
comment|/* 	 * Get a temporary file and build a version of the file to display. 	 * Link the built file into the list. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tpath
argument_list|,
name|_PATH_TMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|tpath
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|tpath
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s> %s"
argument_list|,
name|fmt
argument_list|,
name|tpath
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|buf
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ENTRY
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tp
operator|->
name|s
operator|=
name|strdup
argument_list|(
name|tpath
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|queue_enter_tail
argument_list|(
operator|&
name|intmpp
operator|->
name|list
argument_list|,
name|tp
argument_list|,
name|ENTRY
operator|*
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * how --  *	display how information  */
end_comment

begin_function
specifier|static
name|void
name|how
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|lcnt
decl_stmt|,
name|print
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|S1
value|"SYNOPSIS"
define|#
directive|define
name|S2
value|"S\bSY\bYN\bNO\bOP\bPS\bSI\bIS\bS"
define|#
directive|define
name|D1
value|"DESCRIPTION"
define|#
directive|define
name|D2
value|"D\bDE\bES\bSC\bCR\bRI\bIP\bPT\bTI\bIO\bON\bN"
for|for
control|(
name|lcnt
operator|=
name|print
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
name|S1
argument_list|,
sizeof|sizeof
argument_list|(
name|S1
argument_list|)
operator|-
literal|1
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
name|S2
argument_list|,
sizeof|sizeof
argument_list|(
name|S2
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|print
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
name|D1
argument_list|,
sizeof|sizeof
argument_list|(
name|D1
argument_list|)
operator|-
literal|1
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
name|D2
argument_list|,
sizeof|sizeof
argument_list|(
name|D2
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|print
condition|)
continue|continue;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\n'
condition|)
operator|++
name|lcnt
expr_stmt|;
else|else
block|{
for|for
control|(
init|;
name|lcnt
condition|;
operator|--
name|lcnt
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
empty_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|p
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cat --  *	cat out the file  */
end_comment

begin_function
specifier|static
name|void
name|cat
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|,
name|n
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"read"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * check_pager --  *	check the user supplied page information  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|check_pager
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
comment|/* 	 * if the user uses "more", we make it "more -s"; watch out for 	 * PAGER = "mypager /usr/ucb/more" 	 */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
empty_stmt|;
for|for
control|(
init|;
name|p
operator|>
name|name
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|;
operator|--
name|p
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|!=
name|name
condition|)
operator|++
name|p
expr_stmt|;
comment|/* make sure it's "more", not "morex" */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"more"
argument_list|,
literal|4
argument_list|)
operator|&&
operator|(
operator|!
name|p
index|[
literal|4
index|]
operator|||
name|isspace
argument_list|(
name|p
index|[
literal|4
index|]
argument_list|)
operator|)
condition|)
block|{
name|save
operator|=
name|name
expr_stmt|;
comment|/* allocate space to add the "-s" */
if|if
condition|(
operator|!
operator|(
name|name
operator|=
name|malloc
argument_list|(
call|(
name|u_int
call|)
argument_list|(
name|strlen
argument_list|(
name|save
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"-s"
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s %s"
argument_list|,
name|save
argument_list|,
literal|"-s"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * jump --  *	strip out flag argument and jump  */
end_comment

begin_function
specifier|static
name|void
name|jump
parameter_list|(
name|argv
parameter_list|,
name|flag
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
name|flag
decl_stmt|,
modifier|*
name|name
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
modifier|*
name|arg
decl_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|name
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|argv
operator|+
literal|1
init|;
operator|*
name|arg
condition|;
operator|++
name|arg
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|arg
argument_list|,
name|flag
argument_list|)
condition|)
break|break;
for|for
control|(
init|;
operator|*
name|arg
condition|;
operator|++
name|arg
control|)
name|arg
index|[
literal|0
index|]
operator|=
name|arg
index|[
literal|1
index|]
expr_stmt|;
name|execvp
argument_list|(
name|name
argument_list|,
name|argv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Command not found.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * onsig --  *	If signaled, delete the temporary files.  */
end_comment

begin_function
specifier|static
name|void
name|onsig
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|cleanup
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cleanup --  *	Clean up temporary files, show any error messages.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
name|ENTRY
modifier|*
name|intmpp
decl_stmt|,
modifier|*
name|missp
decl_stmt|;
name|int
name|sverrno
decl_stmt|;
name|sverrno
operator|=
name|errno
expr_stmt|;
name|missp
operator|=
name|getlist
argument_list|(
literal|"_missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|missp
operator|!=
name|NULL
condition|)
name|missp
operator|=
name|missp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
if|if
condition|(
name|missp
operator|!=
name|NULL
condition|)
for|for
control|(
init|;
name|missp
operator|!=
name|NULL
condition|;
name|missp
operator|=
name|missp
operator|->
name|list
operator|.
name|qe_next
control|)
name|warnx
argument_list|(
literal|"no entry for %s in the manual."
argument_list|,
name|missp
operator|->
name|s
argument_list|)
expr_stmt|;
name|intmpp
operator|=
name|getlist
argument_list|(
literal|"_intmp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intmpp
operator|!=
name|NULL
condition|)
name|intmpp
operator|=
name|intmpp
operator|->
name|list
operator|.
name|qe_next
expr_stmt|;
for|for
control|(
init|;
name|intmpp
operator|!=
name|NULL
condition|;
name|intmpp
operator|=
name|intmpp
operator|->
name|list
operator|.
name|qe_next
control|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|intmpp
operator|->
name|s
argument_list|)
expr_stmt|;
name|errno
operator|=
name|sverrno
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * usage --  *	print usage message and die  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: man [-ac] [-C file] [-M path] [-m path] [section] title ...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

