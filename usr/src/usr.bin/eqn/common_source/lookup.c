begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)lookup.c	4.2 8/11/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"e.h"
end_include

begin_include
include|#
directive|include
file|"e.def"
end_include

begin_define
define|#
directive|define
name|TBLSIZE
value|100
end_define

begin_decl_stmt
name|tbl
modifier|*
name|keytbl
index|[
name|TBLSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key words */
end_comment

begin_decl_stmt
name|tbl
modifier|*
name|restbl
index|[
name|TBLSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reserved words */
end_comment

begin_decl_stmt
name|tbl
modifier|*
name|deftbl
index|[
name|TBLSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user-defined names */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|keyval
decl_stmt|;
block|}
name|keyword
index|[]
init|=
block|{
literal|"sub"
block|,
name|SUB
block|,
literal|"sup"
block|,
name|SUP
block|,
literal|".EN"
block|,
name|EOF
block|,
literal|"from"
block|,
name|FROM
block|,
literal|"to"
block|,
name|TO
block|,
literal|"sum"
block|,
name|SUM
block|,
literal|"hat"
block|,
name|HAT
block|,
literal|"vec"
block|,
name|VEC
block|,
literal|"dyad"
block|,
name|DYAD
block|,
literal|"dot"
block|,
name|DOT
block|,
literal|"dotdot"
block|,
name|DOTDOT
block|,
literal|"bar"
block|,
name|BAR
block|,
literal|"tilde"
block|,
name|TILDE
block|,
literal|"under"
block|,
name|UNDER
block|,
literal|"prod"
block|,
name|PROD
block|,
literal|"int"
block|,
name|INT
block|,
literal|"integral"
block|,
name|INT
block|,
literal|"union"
block|,
name|UNION
block|,
literal|"inter"
block|,
name|INTER
block|,
literal|"pile"
block|,
name|PILE
block|,
literal|"lpile"
block|,
name|LPILE
block|,
literal|"cpile"
block|,
name|CPILE
block|,
literal|"rpile"
block|,
name|RPILE
block|,
literal|"over"
block|,
name|OVER
block|,
literal|"sqrt"
block|,
name|SQRT
block|,
literal|"above"
block|,
name|ABOVE
block|,
literal|"size"
block|,
name|SIZE
block|,
literal|"font"
block|,
name|FONT
block|,
literal|"fat"
block|,
name|FAT
block|,
literal|"roman"
block|,
name|ROMAN
block|,
literal|"italic"
block|,
name|ITALIC
block|,
literal|"bold"
block|,
name|BOLD
block|,
literal|"left"
block|,
name|LEFT
block|,
literal|"right"
block|,
name|RIGHT
block|,
literal|"delim"
block|,
name|DELIM
block|,
literal|"define"
block|,
name|DEFINE
block|,
ifdef|#
directive|ifdef
name|NEQN
comment|/* make ndefine synonym for define, tdefine a no-op */
literal|"tdefine"
block|,
name|TDEFINE
block|,
literal|"ndefine"
block|,
name|DEFINE
block|,
else|#
directive|else
comment|/* tdefine = define, ndefine = no-op */
literal|"tdefine"
block|,
name|DEFINE
block|,
literal|"ndefine"
block|,
name|NDEFINE
block|,
endif|#
directive|endif
literal|"gsize"
block|,
name|GSIZE
block|,
literal|".gsize"
block|,
name|GSIZE
block|,
literal|"gfont"
block|,
name|GFONT
block|,
literal|"include"
block|,
name|INCLUDE
block|,
literal|"up"
block|,
name|UP
block|,
literal|"down"
block|,
name|DOWN
block|,
literal|"fwd"
block|,
name|FWD
block|,
literal|"back"
block|,
name|BACK
block|,
literal|"mark"
block|,
name|MARK
block|,
literal|"lineup"
block|,
name|LINEUP
block|,
literal|"matrix"
block|,
name|MATRIX
block|,
literal|"col"
block|,
name|COL
block|,
literal|"lcol"
block|,
name|LCOL
block|,
literal|"ccol"
block|,
name|CCOL
block|,
literal|"rcol"
block|,
name|RCOL
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_struct
struct|struct
block|{
name|char
modifier|*
name|res
decl_stmt|;
name|char
modifier|*
name|resval
decl_stmt|;
block|}
name|resword
index|[]
init|=
block|{
literal|">="
block|,
literal|"\\(>="
block|,
literal|"<="
block|,
literal|"\\(<="
block|,
literal|"=="
block|,
literal|"\\(=="
block|,
literal|"!="
block|,
literal|"\\(!="
block|,
literal|"+-"
block|,
literal|"\\(+-"
block|,
literal|"->"
block|,
literal|"\\(->"
block|,
literal|"<-"
block|,
literal|"\\(<-"
block|,
literal|"inf"
block|,
literal|"\\(if"
block|,
literal|"infinity"
block|,
literal|"\\(if"
block|,
literal|"partial"
block|,
literal|"\\(pd"
block|,
literal|"half"
block|,
literal|"\\f1\\(12\\fP"
block|,
literal|"prime"
block|,
literal|"\\f1\\(fm\\fP"
block|,
literal|"dollar"
block|,
literal|"\\f1$\\fP"
block|,
literal|"nothing"
block|,
literal|""
block|,
literal|"times"
block|,
literal|"\\(mu"
block|,
literal|"del"
block|,
literal|"\\(gr"
block|,
literal|"grad"
block|,
literal|"\\(gr"
block|,
ifdef|#
directive|ifdef
name|NEQN
literal|"<<"
block|,
literal|"<<"
block|,
literal|">>"
block|,
literal|">>"
block|,
literal|"approx"
block|,
literal|"~\b\\d~\\u"
block|,
literal|"cdot"
block|,
literal|"\\v'-.5'.\\v'.5'"
block|,
literal|"..."
block|,
literal|"..."
block|,
literal|",...,"
block|,
literal|",...,"
block|,
else|#
directive|else
literal|"<<"
block|,
literal|"<\\h'-.3m'<"
block|,
literal|">>"
block|,
literal|">\\h'-.3m'>"
block|,
literal|"approx"
block|,
literal|"\\v'-.2m'\\z\\(ap\\v'.25m'\\(ap\\v'-.05m'"
block|,
literal|"cdot"
block|,
literal|"\\v'-.3m'.\\v'.3m'"
block|,
literal|"..."
block|,
literal|"\\v'-.3m'\\ .\\ .\\ .\\ \\v'.3m'"
block|,
literal|",...,"
block|,
literal|",\\ .\\ .\\ .\\ ,\\|"
block|,
endif|#
directive|endif
literal|"alpha"
block|,
literal|"\\(*a"
block|,
literal|"beta"
block|,
literal|"\\(*b"
block|,
literal|"gamma"
block|,
literal|"\\(*g"
block|,
literal|"GAMMA"
block|,
literal|"\\(*G"
block|,
literal|"delta"
block|,
literal|"\\(*d"
block|,
literal|"DELTA"
block|,
literal|"\\(*D"
block|,
literal|"epsilon"
block|,
literal|"\\(*e"
block|,
literal|"EPSILON"
block|,
literal|"\\f1E\\fP"
block|,
literal|"omega"
block|,
literal|"\\(*w"
block|,
literal|"OMEGA"
block|,
literal|"\\(*W"
block|,
literal|"lambda"
block|,
literal|"\\(*l"
block|,
literal|"LAMBDA"
block|,
literal|"\\(*L"
block|,
literal|"mu"
block|,
literal|"\\(*m"
block|,
literal|"nu"
block|,
literal|"\\(*n"
block|,
literal|"theta"
block|,
literal|"\\(*h"
block|,
literal|"THETA"
block|,
literal|"\\(*H"
block|,
literal|"phi"
block|,
literal|"\\(*f"
block|,
literal|"PHI"
block|,
literal|"\\(*F"
block|,
literal|"pi"
block|,
literal|"\\(*p"
block|,
literal|"PI"
block|,
literal|"\\(*P"
block|,
literal|"sigma"
block|,
literal|"\\(*s"
block|,
literal|"SIGMA"
block|,
literal|"\\(*S"
block|,
literal|"xi"
block|,
literal|"\\(*c"
block|,
literal|"XI"
block|,
literal|"\\(*C"
block|,
literal|"zeta"
block|,
literal|"\\(*z"
block|,
literal|"iota"
block|,
literal|"\\(*i"
block|,
literal|"eta"
block|,
literal|"\\(*y"
block|,
literal|"kappa"
block|,
literal|"\\(*k"
block|,
literal|"rho"
block|,
literal|"\\(*r"
block|,
literal|"tau"
block|,
literal|"\\(*t"
block|,
literal|"omicron"
block|,
literal|"\\(*o"
block|,
literal|"upsilon"
block|,
literal|"\\(*u"
block|,
literal|"UPSILON"
block|,
literal|"\\(*U"
block|,
literal|"psi"
block|,
literal|"\\(*q"
block|,
literal|"PSI"
block|,
literal|"\\(*Q"
block|,
literal|"chi"
block|,
literal|"\\(*x"
block|,
literal|"and"
block|,
literal|"\\f1and\\fP"
block|,
literal|"for"
block|,
literal|"\\f1for\\fP"
block|,
literal|"if"
block|,
literal|"\\f1if\\fP"
block|,
literal|"Re"
block|,
literal|"\\f1Re\\fP"
block|,
literal|"Im"
block|,
literal|"\\f1Im\\fP"
block|,
literal|"sin"
block|,
literal|"\\f1sin\\fP"
block|,
literal|"cos"
block|,
literal|"\\f1cos\\fP"
block|,
literal|"tan"
block|,
literal|"\\f1tan\\fP"
block|,
literal|"sec"
block|,
literal|"\\f1sec\\fP"
block|,
literal|"csc"
block|,
literal|"\\f1csc\\fP"
block|,
literal|"arc"
block|,
literal|"\\f1arc\\fP"
block|,
literal|"asin"
block|,
literal|"\\f1asin\\fP"
block|,
literal|"acos"
block|,
literal|"\\f1acos\\fP"
block|,
literal|"atan"
block|,
literal|"\\f1atan\\fP"
block|,
literal|"asec"
block|,
literal|"\\f1asec\\fP"
block|,
literal|"acsc"
block|,
literal|"\\f1acsc\\fP"
block|,
literal|"sinh"
block|,
literal|"\\f1sinh\\fP"
block|,
literal|"coth"
block|,
literal|"\\f1coth\\fP"
block|,
literal|"tanh"
block|,
literal|"\\f1tanh\\fP"
block|,
literal|"cosh"
block|,
literal|"\\f1cosh\\fP"
block|,
literal|"lim"
block|,
literal|"\\f1lim\\fP"
block|,
literal|"log"
block|,
literal|"\\f1log\\fP"
block|,
literal|"max"
block|,
literal|"\\f1max\\fP"
block|,
literal|"min"
block|,
literal|"\\f1min\\fP"
block|,
literal|"ln"
block|,
literal|"\\f1ln\\fP"
block|,
literal|"exp"
block|,
literal|"\\f1exp\\fP"
block|,
literal|"det"
block|,
literal|"\\f1det\\fP"
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_function
name|tbl
modifier|*
name|lookup
parameter_list|(
name|tblp
parameter_list|,
name|name
parameter_list|,
name|defn
parameter_list|)
comment|/* find name in tbl. if defn non-null, install */
name|tbl
modifier|*
modifier|*
name|tblp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|defn
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|tbl
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|h
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|name
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
for|for
control|(
name|h
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
control|)
name|h
operator|+=
operator|*
name|s
operator|++
expr_stmt|;
name|h
operator|%=
name|TBLSIZE
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tblp
index|[
name|h
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|defn
operator|!=
name|NULL
condition|)
name|p
operator|->
name|defn
operator|=
name|defn
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* didn't find it */
if|if
condition|(
name|defn
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
operator|(
name|tbl
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"out of space in lookup"
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|defn
operator|=
name|defn
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|tblp
index|[
name|h
index|]
expr_stmt|;
name|tblp
index|[
name|h
index|]
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_macro
name|init_tbl
argument_list|()
end_macro

begin_comment
comment|/* initialize all tables */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keyword
index|[
name|i
index|]
operator|.
name|key
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|lookup
argument_list|(
name|keytbl
argument_list|,
name|keyword
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|keyword
index|[
name|i
index|]
operator|.
name|keyval
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|resword
index|[
name|i
index|]
operator|.
name|res
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|lookup
argument_list|(
name|restbl
argument_list|,
name|resword
index|[
name|i
index|]
operator|.
name|res
argument_list|,
name|resword
index|[
name|i
index|]
operator|.
name|resval
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

