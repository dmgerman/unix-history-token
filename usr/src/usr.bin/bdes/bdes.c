begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Matt Bishop of Dartmouth College.  *  * The United States Government has rights in this work pursuant  * to contract no. NAG 2-680 between the National Aeronautics and  * Space Administration and Dartmouth College.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1991 The Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bdes.c	5.5 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * BDES -- DES encryption package for Berkeley Software Distribution 4.4  * options:  *	-a	key is in ASCII  *	-b	use ECB (electronic code book) mode  *	-d	invert (decrypt) input  *	-f b	use b-bit CFB (cipher feedback) mode  *	-F b	use b-bit CFB (cipher feedback) alternative mode  *	-k key	use key as the cryptographic key  *	-m b	generate a MAC of length b  *	-o b	use b-bit OFB (output feedback) mode  *	-p	don't reset the parity bit  *	-v v	use v as the initialization vector (ignored for ECB)  * note: the last character of the last block is the integer indicating  * how many characters of that block are to be output  *  * Author: Matt Bishop  *	   Department of Mathematics and Computer Science  *	   Dartmouth College  *	   Hanover, NH  03755  * Email:  Matt.Bishop@dartmouth.edu  *	   ...!decvax!dartvax!Matt.Bishop  *  * See Technical Report PCS-TR91-158, Department of Mathematics and Computer  * Science, Dartmouth College, for a detailed description of the implemen-  * tation and differences between it and Sun's.  The DES is described in  * FIPS PUB 46, and the modes in FIPS PUB 81 (see either the manual page  * or the technical report for a complete reference).  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/*  * BSD and System V systems offer special library calls that do  * block moves and fills, so if possible we take advantage of them  */
end_comment

begin_define
define|#
directive|define
name|MEMCPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
value|bcopy((src),(dest),(len))
end_define

begin_define
define|#
directive|define
name|MEMZERO
parameter_list|(
name|dest
parameter_list|,
name|len
parameter_list|)
value|bzero((dest),(len))
end_define

begin_comment
comment|/* Hide the calls to the primitive encryption routines. */
end_comment

begin_define
define|#
directive|define
name|FASTWAY
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|FASTWAY
end_ifdef

begin_define
define|#
directive|define
name|DES_KEY
parameter_list|(
name|buf
parameter_list|)
define|\
value|if (des_setkey(buf)) \ 		err("des_setkey", 0);
end_define

begin_define
define|#
directive|define
name|DES_XFORM
parameter_list|(
name|buf
parameter_list|)
define|\
value|if (des_cipher(buf, buf, 0L, (inverse ? -1 : 1))) \ 		err("des_cipher", 0);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DES_KEY
parameter_list|(
name|buf
parameter_list|)
value|{						\ 				char bits1[64];
comment|/* bits of key */
value|\ 				expand(buf, bits1);			\ 				if (setkey(bits1))			\ 					err("setkey", 0);		\ 			}
end_define

begin_define
define|#
directive|define
name|DES_XFORM
parameter_list|(
name|buf
parameter_list|)
value|{						\ 				char bits1[64];
comment|/* bits of message */
value|\ 				expand(buf, bits1);			\ 				if (encrypt(bits1, inverse))		\ 					err("encrypt", 0);		\ 				compress(bits1, buf);			\ 			}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * this does an error-checking write  */
end_comment

begin_define
define|#
directive|define
name|READ
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|)
value|fread(buf, sizeof(char), n, stdin)
end_define

begin_define
define|#
directive|define
name|WRITE
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|)
define|\
value|if (fwrite(buf, sizeof(char), n, stdout) != n)	\ 			err(bn, NULL);
end_define

begin_comment
comment|/*  * some things to make references easier  */
end_comment

begin_typedef
typedef|typedef
name|char
name|Desbuf
index|[
literal|8
index|]
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CHAR
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|)
value|(x[i])
end_define

begin_define
define|#
directive|define
name|UCHAR
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|)
value|(x[i])
end_define

begin_define
define|#
directive|define
name|BUFFER
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_define
define|#
directive|define
name|UBUFFER
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_comment
comment|/*  * global variables and related macros  */
end_comment

begin_define
define|#
directive|define
name|KEY_DEFAULT
value|0
end_define

begin_comment
comment|/* interpret radix of key from key */
end_comment

begin_define
define|#
directive|define
name|KEY_ASCII
value|1
end_define

begin_comment
comment|/* key is in ASCII characters */
end_comment

begin_decl_stmt
name|int
name|keybase
init|=
name|KEY_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how to interpret the key */
end_comment

begin_enum
enum|enum
block|{
comment|/* encrypt, decrypt, authenticate */
name|MODE_ENCRYPT
block|,
name|MODE_DECRYPT
block|,
name|MODE_AUTHENTICATE
block|}
name|mode
init|=
name|MODE_ENCRYPT
enum|;
end_enum

begin_enum
enum|enum
block|{
comment|/* ecb, cbc, cfb, cfba, ofb? */
name|ALG_ECB
block|,
name|ALG_CBC
block|,
name|ALG_CFB
block|,
name|ALG_OFB
block|,
name|ALG_CFBA
block|}
name|alg
init|=
name|ALG_CBC
enum|;
end_enum

begin_decl_stmt
name|Desbuf
name|ivec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initialization vector */
end_comment

begin_decl_stmt
name|char
name|bits
index|[]
init|=
block|{
comment|/* used to extract bits from a char */
literal|'\200'
block|,
literal|'\100'
block|,
literal|'\040'
block|,
literal|'\020'
block|,
literal|'\010'
block|,
literal|'\004'
block|,
literal|'\002'
block|,
literal|'\001'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inverse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 to encrypt, 1 to decrypt */
end_comment

begin_decl_stmt
name|int
name|macbits
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bits in authentication */
end_comment

begin_decl_stmt
name|int
name|fbbits
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of feedback bits */
end_comment

begin_decl_stmt
name|int
name|pflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 to preserve parity bits */
end_comment

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
comment|/* arg count */
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
comment|/* arg vector */
block|{
specifier|extern
name|int
name|optind
decl_stmt|;
comment|/* option (argument) number */
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
comment|/* argument to option if any */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* counter in a for loop */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* used to obtain the key */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
name|int
name|kflag
decl_stmt|;
comment|/* command-line encryptiooon key */
name|int
name|argc
decl_stmt|;
comment|/* the real arg count */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* the real argument vector */
comment|/* 	 * Hide the arguments from ps(1) by making private copies of them 	 * and clobbering the global (visible to ps(1)) ones. 	 */
name|argc
operator|=
name|ac
expr_stmt|;
name|ac
operator|=
literal|1
expr_stmt|;
name|argv
operator|=
name|malloc
argument_list|(
operator|(
name|argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|argv
index|[
name|i
index|]
operator|=
name|strdup
argument_list|(
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|av
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|av
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* initialize the initialization vctor */
name|MEMZERO
argument_list|(
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* process the argument list */
name|kflag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"abdF:f:k:m:o:pv:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* key is ASCII */
name|keybase
operator|=
name|KEY_ASCII
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* use ECB mode */
name|alg
operator|=
name|ALG_ECB
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* decrypt */
name|mode
operator|=
name|MODE_DECRYPT
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* use alternative CFB mode */
name|alg
operator|=
name|ALG_CFBA
expr_stmt|;
if|if
condition|(
operator|(
name|fbbits
operator|=
name|setbits
argument_list|(
name|optarg
argument_list|,
literal|7
argument_list|)
operator|)
operator|>
literal|56
operator|||
name|fbbits
operator|==
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"-F: number must be 1-56 inclusive"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fbbits
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"-F: number must be a multiple of 7"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* use CFB mode */
name|alg
operator|=
name|ALG_CFB
expr_stmt|;
if|if
condition|(
operator|(
name|fbbits
operator|=
name|setbits
argument_list|(
name|optarg
argument_list|,
literal|8
argument_list|)
operator|)
operator|>
literal|64
operator|||
name|fbbits
operator|==
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"-f: number must be 1-64 inclusive"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fbbits
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"-f: number must be a multiple of 8"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* encryption key */
name|kflag
operator|=
literal|1
expr_stmt|;
name|cvtkey
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* number of bits for MACing */
name|mode
operator|=
name|MODE_AUTHENTICATE
expr_stmt|;
if|if
condition|(
operator|(
name|macbits
operator|=
name|setbits
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|64
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"-m: number must be 0-64 inclusive"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* use OFB mode */
name|alg
operator|=
name|ALG_OFB
expr_stmt|;
if|if
condition|(
operator|(
name|fbbits
operator|=
name|setbits
argument_list|(
name|optarg
argument_list|,
literal|8
argument_list|)
operator|)
operator|>
literal|64
operator|||
name|fbbits
operator|==
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"-o: number must be 1-64 inclusive"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fbbits
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"-o: number must be a multiple of 8"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* preserve parity bits */
name|pflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* set initialization vector */
name|cvtkey
argument_list|(
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* error */
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|kflag
condition|)
block|{
comment|/* 		 * if the key's not ASCII, assume it is 		 */
name|keybase
operator|=
name|KEY_ASCII
expr_stmt|;
comment|/* 		 * get the key 		 */
name|p
operator|=
name|getpass
argument_list|(
literal|"Enter key: "
argument_list|)
expr_stmt|;
comment|/* 		 * copy it, nul-padded, into the key area 		 */
name|cvtkey
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|inverse
operator|=
operator|(
name|alg
operator|==
name|ALG_CBC
operator|||
name|alg
operator|==
name|ALG_ECB
operator|)
operator|&&
name|mode
operator|==
name|MODE_DECRYPT
expr_stmt|;
switch|switch
condition|(
name|alg
condition|)
block|{
case|case
name|ALG_CBC
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using CBC mode */
name|cbcauth
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_DECRYPT
case|:
comment|/* decrypt using CBC mode */
name|cbcdec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_ENCRYPT
case|:
comment|/* encrypt using CBC mode */
name|cbcenc
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ALG_CFB
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using CFB mode */
name|cfbauth
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_DECRYPT
case|:
comment|/* decrypt using CFB mode */
name|cfbdec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_ENCRYPT
case|:
comment|/* encrypt using CFB mode */
name|cfbenc
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ALG_CFBA
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using CFBA mode */
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"can't authenticate with CFBA mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_DECRYPT
case|:
comment|/* decrypt using CFBA mode */
name|cfbadec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_ENCRYPT
case|:
comment|/* encrypt using CFBA mode */
name|cfbaenc
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ALG_ECB
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using ECB mode */
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"can't authenticate with ECB mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_DECRYPT
case|:
comment|/* decrypt using ECB mode */
name|ecbdec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_ENCRYPT
case|:
comment|/* encrypt using ECB mode */
name|ecbenc
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ALG_OFB
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using OFB mode */
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"can't authenticate with OFB mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_DECRYPT
case|:
comment|/* decrypt using OFB mode */
name|ofbdec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_ENCRYPT
case|:
comment|/* encrypt using OFB mode */
name|ofbenc
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print a warning message and, possibly, terminate  */
end_comment

begin_macro
name|err
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offending block number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the message */
end_comment

begin_block
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bdes (block %d): "
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bdes: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|s
condition|?
name|s
else|:
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * map a hex character to an integer  */
end_comment

begin_macro
name|tobinhex
argument_list|(
argument|c
argument_list|,
argument|radix
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* char to be converted */
end_comment

begin_decl_stmt
name|int
name|radix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base (2 to 16) */
end_comment

begin_block
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
return|return
operator|(
literal|0x0
operator|)
return|;
case|case
literal|'1'
case|:
return|return
operator|(
literal|0x1
operator|)
return|;
case|case
literal|'2'
case|:
return|return
operator|(
name|radix
operator|>
literal|2
condition|?
literal|0x2
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'3'
case|:
return|return
operator|(
name|radix
operator|>
literal|3
condition|?
literal|0x3
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'4'
case|:
return|return
operator|(
name|radix
operator|>
literal|4
condition|?
literal|0x4
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'5'
case|:
return|return
operator|(
name|radix
operator|>
literal|5
condition|?
literal|0x5
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'6'
case|:
return|return
operator|(
name|radix
operator|>
literal|6
condition|?
literal|0x6
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'7'
case|:
return|return
operator|(
name|radix
operator|>
literal|7
condition|?
literal|0x7
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'8'
case|:
return|return
operator|(
name|radix
operator|>
literal|8
condition|?
literal|0x8
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'9'
case|:
return|return
operator|(
name|radix
operator|>
literal|9
condition|?
literal|0x9
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
return|return
operator|(
name|radix
operator|>
literal|10
condition|?
literal|0xa
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
return|return
operator|(
name|radix
operator|>
literal|11
condition|?
literal|0xb
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
return|return
operator|(
name|radix
operator|>
literal|12
condition|?
literal|0xc
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
return|return
operator|(
name|radix
operator|>
literal|13
condition|?
literal|0xd
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
return|return
operator|(
name|radix
operator|>
literal|14
condition|?
literal|0xe
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
return|return
operator|(
name|radix
operator|>
literal|15
condition|?
literal|0xf
else|:
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * invalid character 	 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * convert the key to a bit pattern  */
end_comment

begin_macro
name|cvtkey
argument_list|(
argument|obuf
argument_list|,
argument|ibuf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|obuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bit pattern */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ibuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the key itself */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* counter in a for loop */
name|int
name|nbuf
index|[
literal|64
index|]
decl_stmt|;
comment|/* used for hex/key translation */
comment|/* 	 * just switch on the key base 	 */
switch|switch
condition|(
name|keybase
condition|)
block|{
case|case
name|KEY_ASCII
case|:
comment|/* ascii to integer */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|obuf
argument_list|,
name|ibuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return;
case|case
name|KEY_DEFAULT
case|:
comment|/* tell from context */
comment|/* 		 * leading '0x' or '0X' == hex key 		 */
if|if
condition|(
name|ibuf
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|ibuf
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|ibuf
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
name|ibuf
operator|=
operator|&
name|ibuf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 			 * now translate it, bombing on any illegal hex digit 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ibuf
index|[
name|i
index|]
operator|&&
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|nbuf
index|[
name|i
index|]
operator|=
name|tobinhex
argument_list|(
name|ibuf
index|[
name|i
index|]
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"bad hex digit in key"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
name|nbuf
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|obuf
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|nbuf
index|[
literal|2
operator|*
name|i
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|nbuf
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|&
literal|0xf
operator|)
expr_stmt|;
comment|/* preserve parity bits */
name|pflag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 		 * leading '0b' or '0B' == binary key 		 */
if|if
condition|(
name|ibuf
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|ibuf
index|[
literal|1
index|]
operator|==
literal|'b'
operator|||
name|ibuf
index|[
literal|1
index|]
operator|==
literal|'B'
operator|)
condition|)
block|{
name|ibuf
operator|=
operator|&
name|ibuf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 			 * now translate it, bombing on any illegal binary digit 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ibuf
index|[
name|i
index|]
operator|&&
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|nbuf
index|[
name|i
index|]
operator|=
name|tobinhex
argument_list|(
name|ibuf
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"bad binary digit in key"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|64
condition|)
name|nbuf
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|obuf
index|[
name|i
index|]
operator|=
operator|(
name|obuf
index|[
name|i
index|]
operator|<<
literal|1
operator|)
operator||
name|nbuf
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
expr_stmt|;
comment|/* preserve parity bits */
name|pflag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 		 * no special leader -- ASCII 		 */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|obuf
argument_list|,
name|ibuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * convert an ASCII string into a decimal number:  * 1. must be between 0 and 64 inclusive  * 2. must be a valid decimal number  * 3. must be a multiple of mult  */
end_comment

begin_macro
name|setbits
argument_list|(
argument|s
argument_list|,
argument|mult
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the ASCII string */
end_comment

begin_decl_stmt
name|int
name|mult
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what it must be a multiple of */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* pointer in a for loop */
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* the integer collected */
comment|/* 	 * skip white space 	 */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* 	 * get the integer 	 */
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
else|else
block|{
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"bad decimal digit in MAC length"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * be sure it's a multiple of mult 	 */
return|return
operator|(
operator|(
name|n
operator|%
name|mult
operator|!=
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/*****************  * DES FUNCTIONS *  *****************/
end_comment

begin_comment
comment|/*  * This sets the DES key and (if you're using the deszip version)  * the direction of the transformation.  This uses the Sun  * to map the 64-bit key onto the 56 bits that the key schedule  * generation routines use: the old way, which just uses the user-  * supplied 64 bits as is, and the new way, which resets the parity  * bit to be the same as the low-order bit in each character.  The  * new way generates a greater variety of key schedules, since many  * systems set the parity (high) bit of each character to 0, and the  * DES ignores the low order bit of each character.  */
end_comment

begin_macro
name|makekey
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|Desbuf
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key block */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* counter in a for loop */
specifier|register
name|int
name|par
decl_stmt|;
comment|/* parity counter */
comment|/* 	 * if the parity is not preserved, flip it 	 */
if|if
condition|(
operator|!
name|pflag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|par
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|bits
index|[
name|j
index|]
operator|&
name|UCHAR
argument_list|(
name|buf
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|par
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|par
operator|&
literal|01
operator|)
operator|==
literal|01
condition|)
name|UCHAR
argument_list|(
name|buf
argument_list|,
name|i
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|buf
argument_list|,
name|i
argument_list|)
operator|&
literal|0177
expr_stmt|;
else|else
name|UCHAR
argument_list|(
name|buf
argument_list|,
name|i
argument_list|)
operator|=
operator|(
name|UCHAR
argument_list|(
name|buf
argument_list|,
name|i
argument_list|)
operator|&
literal|0177
operator|)
operator||
literal|0200
expr_stmt|;
block|}
block|}
name|DES_KEY
argument_list|(
name|UBUFFER
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This encrypts using the Electronic Code Book mode of DES  */
end_comment

begin_macro
name|ecbenc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
for|for
control|(
name|bn
operator|=
literal|0
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|;
name|bn
operator|++
control|)
block|{
comment|/* 		 * do the transformation 		 */
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either ase, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
argument_list|,
literal|8
operator|-
name|n
argument_list|)
expr_stmt|;
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|7
argument_list|)
operator|=
name|n
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This decrypts using the Electronic Code Book mode of DES  */
end_comment

begin_macro
name|ecbdec
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|;
name|bn
operator|++
control|)
block|{
comment|/* 		 * do the transformation 		 */
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|n
operator|=
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|7
condition|)
name|err
argument_list|(
name|bn
argument_list|,
literal|"decryption failed (block corrupted)"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|err
argument_list|(
name|bn
argument_list|,
literal|"decryption failed (incomplete block)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This encrypts using the Cipher Block Chaining mode of DES  */
end_comment

begin_macro
name|cbcenc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|;
name|bn
operator|++
control|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
operator|^=
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
argument_list|,
literal|8
operator|-
name|n
argument_list|)
expr_stmt|;
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|7
argument_list|)
operator|=
name|n
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
operator|^=
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This decrypts using the Cipher Block Chaining mode of DES  */
end_comment

begin_macro
name|cbcdec
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
name|Desbuf
name|ibuf
decl_stmt|;
comment|/* temp buffer for initialization vector */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
for|for
control|(
name|bn
operator|=
literal|0
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|;
name|bn
operator|++
control|)
block|{
comment|/* 		 * do the transformation 		 */
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|ibuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
condition|;
name|c
operator|++
control|)
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|c
argument_list|)
operator|^=
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ibuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|n
operator|=
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|7
condition|)
name|err
argument_list|(
name|bn
argument_list|,
literal|"decryption failed (block corrupted)"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|err
argument_list|(
name|bn
argument_list|,
literal|"decryption failed (incomplete block)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This authenticates using the Cipher Block Chaining mode of DES  */
end_comment

begin_macro
name|cbcauth
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|j
decl_stmt|;
comment|/* number of bytes actually read */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
name|Desbuf
name|encbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do the transformation 	 * note we DISCARD the encrypted block; 	 * we only care about the last one 	 */
while|while
condition|(
operator|(
name|n
operator|=
name|READ
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|CHAR
argument_list|(
name|encbuf
argument_list|,
name|n
argument_list|)
operator|=
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
operator|^
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|encbuf
argument_list|)
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|encbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * now compute the last one, right padding with '\0' if need be 	 */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|MEMZERO
argument_list|(
operator|&
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
argument_list|,
literal|8
operator|-
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|CHAR
argument_list|(
name|encbuf
argument_list|,
name|n
argument_list|)
operator|=
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
operator|^
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|encbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * drop the bits 	 * we write chars until fewer than 7 bits, 	 * and then pad the last one with 0 bits 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|macbits
operator|>
literal|7
condition|;
name|n
operator|++
operator|,
name|macbits
operator|-=
literal|8
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|CHAR
argument_list|(
name|encbuf
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|macbits
operator|>
literal|0
condition|)
block|{
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|macbits
condition|;
name|j
operator|++
control|)
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
operator||=
operator|(
name|CHAR
argument_list|(
name|encbuf
argument_list|,
name|n
argument_list|)
operator|&
name|bits
index|[
name|j
index|]
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * This encrypts using the Cipher FeedBack mode of DES  */
end_comment

begin_macro
name|cfbenc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|n
argument_list|)
operator|=
name|ibuf
index|[
name|n
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
operator|&
name|CHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|ibuf
index|[
name|n
index|]
argument_list|,
name|nbytes
operator|-
name|n
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
name|n
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|ibuf
index|[
name|n
index|]
operator|^=
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This decrypts using the Cipher Block Chaining mode of DES  */
end_comment

begin_macro
name|cfbdec
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|c
operator|++
control|)
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|c
argument_list|)
operator|=
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|c
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nbytes
condition|;
name|c
operator|++
control|)
block|{
name|CHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|c
argument_list|)
operator|=
name|ibuf
index|[
name|c
index|]
expr_stmt|;
name|obuf
index|[
name|c
index|]
operator|=
name|ibuf
index|[
name|c
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|n
operator|=
name|obuf
index|[
name|nbytes
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nbytes
operator|-
literal|1
condition|)
name|err
argument_list|(
name|bn
argument_list|,
literal|"decryption failed (block corrupted)"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|err
argument_list|(
name|bn
argument_list|,
literal|"decryption failed (incomplete block)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This encrypts using the alternative Cipher FeedBack mode of DES  */
end_comment

begin_macro
name|cfbaenc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|7
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|n
argument_list|)
operator|=
operator|(
name|ibuf
index|[
name|n
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
operator|)
operator||
literal|0200
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|obuf
index|[
name|n
index|]
operator|=
name|CHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|n
argument_list|)
operator|&
literal|0177
expr_stmt|;
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|ibuf
index|[
name|n
index|]
argument_list|,
name|nbytes
operator|-
name|n
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
operator|(
literal|'0'
operator|+
name|n
operator|)
operator||
literal|0200
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|ibuf
index|[
name|n
index|]
operator|^=
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This decrypts using the alternative Cipher Block Chaining mode of DES  */
end_comment

begin_macro
name|cfbadec
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|7
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|c
operator|++
control|)
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|c
argument_list|)
operator|=
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|c
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nbytes
condition|;
name|c
operator|++
control|)
block|{
name|CHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|c
argument_list|)
operator|=
name|ibuf
index|[
name|c
index|]
operator||
literal|0200
expr_stmt|;
name|obuf
index|[
name|c
index|]
operator|=
operator|(
name|ibuf
index|[
name|c
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|c
argument_list|)
operator|)
operator|&
literal|0177
expr_stmt|;
block|}
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
operator|(
name|obuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|)
operator|<
literal|0
operator|||
name|n
operator|>
name|nbytes
operator|-
literal|1
condition|)
name|err
argument_list|(
name|bn
argument_list|,
literal|"decryption failed (block corrupted)"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|err
argument_list|(
name|bn
argument_list|,
literal|"decryption failed (incomplete block)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This encrypts using the Output FeedBack mode of DES  */
end_comment

begin_macro
name|ofbenc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
block|{
name|UCHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|n
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|obuf
index|[
name|n
index|]
operator|=
name|ibuf
index|[
name|n
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|ibuf
index|[
name|n
index|]
argument_list|,
name|nbytes
operator|-
name|n
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
name|n
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nbytes
condition|;
name|c
operator|++
control|)
name|ibuf
index|[
name|c
index|]
operator|^=
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This decrypts using the Output Block Chaining mode of DES  */
end_comment

begin_macro
name|ofbdec
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|c
operator|++
control|)
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|c
argument_list|)
operator|=
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|c
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nbytes
condition|;
name|c
operator|++
control|)
block|{
name|CHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|c
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|obuf
index|[
name|c
index|]
operator|=
name|ibuf
index|[
name|c
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|n
operator|=
name|obuf
index|[
name|nbytes
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nbytes
operator|-
literal|1
condition|)
name|err
argument_list|(
name|bn
argument_list|,
literal|"decryption failed (block corrupted)"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/* 		 * dump it 		 */
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|err
argument_list|(
name|bn
argument_list|,
literal|"decryption failed (incomplete block)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This authenticates using the Cipher FeedBack mode of DES  */
end_comment

begin_macro
name|cfbauth
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|j
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
while|while
condition|(
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|n
argument_list|)
operator|=
name|ibuf
index|[
name|n
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|MEMZERO
argument_list|(
operator|&
name|ibuf
index|[
name|n
index|]
argument_list|,
name|nbytes
operator|-
name|n
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
literal|'0'
operator|+
name|n
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|ibuf
index|[
name|n
index|]
operator|^=
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* 	 * drop the bits 	 * we write chars until fewer than 7 bits, 	 * and then pad the last one with 0 bits 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|macbits
operator|>
literal|7
condition|;
name|n
operator|++
operator|,
name|macbits
operator|-=
literal|8
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|macbits
operator|>
literal|0
condition|)
block|{
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|macbits
condition|;
name|j
operator|++
control|)
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
operator||=
operator|(
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
operator|&
name|bits
index|[
name|j
index|]
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|FASTWAY
end_ifndef

begin_comment
comment|/*  * change from 8 bits/Uchar to 1 bit/Uchar  */
end_comment

begin_macro
name|expand
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|Desbuf
name|from
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8bit/unsigned char string */
end_comment

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1bit/char string */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* counters in for loop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
operator|*
name|to
operator|++
operator|=
operator|(
name|CHAR
argument_list|(
name|from
argument_list|,
name|i
argument_list|)
operator|>>
operator|(
literal|7
operator|-
name|j
operator|)
operator|)
operator|&
literal|01
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * change from 1 bit/char to 8 bits/Uchar  */
end_comment

begin_macro
name|compress
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1bit/char string */
end_comment

begin_decl_stmt
name|Desbuf
name|to
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8bit/unsigned char string */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* counters in for loop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|CHAR
argument_list|(
name|to
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|CHAR
argument_list|(
name|to
argument_list|,
name|i
argument_list|)
operator|=
operator|(
operator|(
operator|*
name|from
operator|++
operator|)
operator|<<
operator|(
literal|7
operator|-
name|j
operator|)
operator|)
operator||
name|CHAR
argument_list|(
name|to
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * message about usage  */
end_comment

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
literal|"usage: bdes [-abdp] [-F bit] [-f bit] [-k key] [-m bit] [-o bit] [-v vector]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

