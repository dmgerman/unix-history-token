begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * BDES -- DES encryption package for Berkeley Software Distribution 4.4  * options:  *	-a	key is in ASCII  *	-c	use CBC (cipher block chaining) mode  *	-e	use ECB (electronic code book) mode  *	-f b	use b-bit CFB (cipher feedback) mode  *	-F b	use b-bit CFB (cipher feedback) alternative mode  *	-i	invert (decrypt) input  *	-m b	generate a MAC of length b  *	-o b	use b-bit OFB (output feedback) mode  *	-p	don't reset the parity bit  *	-v v	use v as the initialization vector (ignored for ECB)  * note: the last character of the last block is the integer indicating  * how many characters of that block are to be output  *  * Author: Matt Bishop  *	   Department of Mathematics and Computer Science  *	   Dartmouth College  *	   Hanover, NH  03755  * Email:  Matt.Bishop@dartmouth.edu  *	   ...!decvax!dartvax!Matt.Bishop  *  * This is derived from a program written as part of work done for grant  * NAG 2-680 from the National Aeronautics and Space Administration to  * Dartmouth College.  It is freely distributable provided:  * (1) the name and address of the author and the credit to NASA and  *     Dartmouth are not altered or removed; and  * (2) any changes made are noted in the leading comments, and the date  *     and changer are also noted; and  * (3) all bugs are promptly reported to the author at the above address.  * Also, as stated in the manual page, "there is no warranty of merchant-  * ability nor any warranty of fitness for a particular puurpose not any  * other warranty, either express or implied, as to the accuracy of the  * enclosed materials or as to their suitability for any particular pur-  * pose.  Accordingly, the user assumes full responsibility for their   * use.  Further, the author assumes no obligation to furnish any assis-  * tance of any kind whatsoever, or to furnish any additional information  * or documentation."  *  * See Technical Report PCS-TR91-158, Department of Mathematics and Computer  * Science, Dartmouth College, for a detailed description of the implemen-  * tation and differences between it and Sun's.  The DES is described in  * FIPS PUB 46, and the modes in FIPS PUB 81 (see either the manual page  * or the technical report for a complete reference).  *  * 4/1/91 -- bug fix by Matt Bishop  *	There was an error in the MAC computation if you asked for a  *	MAC of length not a multiple of 8; you got the first bit from  *	the first char, the second from the second char, and so on.  *	Found by inspection of code; fixed.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|C_NULL
value|((char *) NULL)
end_define

begin_comment
comment|/*  * BSD and System V systems offer special library calls that do  * block moves and fills, so if possible we take advantage of them  */
end_comment

begin_define
define|#
directive|define
name|MEMCPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
value|bcopy((src),(dest),(len))
end_define

begin_define
define|#
directive|define
name|MEMZERO
parameter_list|(
name|dest
parameter_list|,
name|len
parameter_list|)
value|bzero((dest),(len))
end_define

begin_comment
comment|/*  * these "hide" the calls to the primitive encryption routines  */
end_comment

begin_define
define|#
directive|define
name|DES_KEY
parameter_list|(
name|buf
parameter_list|)
value|{						\ 				char bits1[64];
comment|/* bits of key */
value|\ 				expand(buf, bits1);			\ 				setkey(bits1);				\ 			}
end_define

begin_define
define|#
directive|define
name|DES_XFORM
parameter_list|(
name|buf
parameter_list|)
value|{						\ 				char bits1[64];
comment|/* bits of message */
value|\ 				expand(buf, bits1);			\ 				encrypt(bits1, inverse);		\ 				compress(bits1, buf);			\ 			}
end_define

begin_comment
comment|/*  * this does an error-checking write  */
end_comment

begin_define
define|#
directive|define
name|READ
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|)
value|fread(buf, sizeof(char), n, stdin)
end_define

begin_define
define|#
directive|define
name|WRITE
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|)
define|\
value|if (fwrite(buf, sizeof(char), n, stdout) != n)	\ 			err(1, bn, C_NULL);
end_define

begin_comment
comment|/*  * some things to make references easier  */
end_comment

begin_typedef
typedef|typedef
name|char
name|Desbuf
index|[
literal|8
index|]
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CHAR
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|)
value|(x[i])
end_define

begin_define
define|#
directive|define
name|UCHAR
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|)
value|(x[i])
end_define

begin_define
define|#
directive|define
name|BUFFER
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_define
define|#
directive|define
name|UBUFFER
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_comment
comment|/*  * global variables and related macros  */
end_comment

begin_define
define|#
directive|define
name|KEY_DEFAULT
value|0
end_define

begin_comment
comment|/* interpret radix of key from key */
end_comment

begin_define
define|#
directive|define
name|KEY_ASCII
value|1
end_define

begin_comment
comment|/* key is in ASCII characters */
end_comment

begin_decl_stmt
name|int
name|keybase
init|=
name|KEY_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how to interpret the key */
end_comment

begin_define
define|#
directive|define
name|MODE_ENCRYPT
value|0x01
end_define

begin_comment
comment|/* encrypt */
end_comment

begin_define
define|#
directive|define
name|MODE_DECRYPT
value|0x02
end_define

begin_comment
comment|/* decrypt */
end_comment

begin_define
define|#
directive|define
name|MODE_AUTHENTICATE
value|0x04
end_define

begin_comment
comment|/* authenticate */
end_comment

begin_define
define|#
directive|define
name|GET_DIRECTION
value|((mode)&0xf)
end_define

begin_define
define|#
directive|define
name|ISSET_MODE_DIRECTION
value|(GET_DIRECTION != 0)
end_define

begin_define
define|#
directive|define
name|MODE_ECB
value|0x10
end_define

begin_comment
comment|/* ECB mode */
end_comment

begin_define
define|#
directive|define
name|MODE_CBC
value|0x20
end_define

begin_comment
comment|/* CBC mode */
end_comment

begin_define
define|#
directive|define
name|MODE_CFB
value|0x30
end_define

begin_comment
comment|/* cipher feedback mode */
end_comment

begin_define
define|#
directive|define
name|MODE_OFB
value|0x40
end_define

begin_comment
comment|/* output feedback mode */
end_comment

begin_define
define|#
directive|define
name|MODE_CFBA
value|0x50
end_define

begin_comment
comment|/* alternative cipher feedback mode */
end_comment

begin_define
define|#
directive|define
name|GET_ALGORITHM
value|((mode)&0xf0)
end_define

begin_define
define|#
directive|define
name|ISSET_MODE_ALGORITHM
value|(GET_ALGORITHM != 0)
end_define

begin_decl_stmt
name|int
name|mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how to run */
end_comment

begin_decl_stmt
name|char
modifier|*
name|keyrep
init|=
literal|"*********"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* replaces command-line key */
end_comment

begin_decl_stmt
name|Desbuf
name|ivec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initialization vector */
end_comment

begin_decl_stmt
name|char
name|bits
index|[]
init|=
block|{
literal|'\200'
block|,
literal|'\100'
block|,
comment|/* used to extract bits from a char */
literal|'\040'
block|,
literal|'\020'
block|,
literal|'\010'
block|,
literal|'\004'
block|,
literal|'\002'
block|,
literal|'\001'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inverse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 ti encrypt, 1 to decrypt */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
init|=
literal|"des program"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program name */
end_comment

begin_decl_stmt
name|int
name|macbits
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bits in authentication */
end_comment

begin_decl_stmt
name|int
name|fbbits
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of feedback bits */
end_comment

begin_decl_stmt
name|int
name|pflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 to preserve parity bits */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dummyargs
index|[]
init|=
block|{
literal|"*****"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argument list to be printed */
end_comment

begin_comment
comment|/*  * library hooks  */
end_comment

begin_comment
comment|/* see getopt(3) */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* option (argument) number */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argument to option if any */
end_comment

begin_comment
comment|/*  * library functions  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_function_decl
name|char
modifier|*
name|sprintf
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* in core formatted print */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|char
modifier|*
name|getpass
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* get a password from a terminal */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* counter in a for loop */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* used to obtain the key */
name|int
name|n
decl_stmt|;
comment|/* number of command-line errors */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
name|int
name|nargs
decl_stmt|;
comment|/* internal number of arguments */
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
comment|/* internal argument list */
comment|/* 	 * hide the arguments 	 */
name|nargs
operator|=
name|argc
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
name|arglist
operator|=
name|argv
expr_stmt|;
name|argv
operator|=
name|dummyargs
expr_stmt|;
comment|/* 	 * initialize the initialization vctor 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|i
argument_list|)
operator|=
literal|0x00
expr_stmt|;
comment|/* 	 * process the argument list 	 */
name|progname
operator|=
name|arglist
index|[
literal|0
index|]
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|nargs
argument_list|,
name|arglist
argument_list|,
literal|"aceF:f:im:o:pv:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* key is ASCII */
name|keybase
operator|=
name|KEY_ASCII
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* use CBC mode */
if|if
condition|(
name|ISSET_MODE_ALGORITHM
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"two modes of operation specified"
argument_list|)
expr_stmt|;
name|mode
operator||=
name|MODE_CBC
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* use ECB mode */
if|if
condition|(
name|ISSET_MODE_ALGORITHM
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"two modes of operation specified"
argument_list|)
expr_stmt|;
name|mode
operator||=
name|MODE_ECB
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* use alternative CFB mode */
if|if
condition|(
name|ISSET_MODE_ALGORITHM
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"two modes of operation specified"
argument_list|)
expr_stmt|;
name|mode
operator||=
name|MODE_CFBA
expr_stmt|;
if|if
condition|(
operator|(
name|fbbits
operator|=
name|setbits
argument_list|(
name|optarg
argument_list|,
literal|7
argument_list|)
operator|)
operator|>
literal|56
operator|||
name|fbbits
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"-F: number must be 1-56 inclusive"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fbbits
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"-F: number must be a multiple of 7"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* use CFB mode */
if|if
condition|(
name|ISSET_MODE_ALGORITHM
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"two modes of operation specified"
argument_list|)
expr_stmt|;
name|mode
operator||=
name|MODE_CFB
expr_stmt|;
if|if
condition|(
operator|(
name|fbbits
operator|=
name|setbits
argument_list|(
name|optarg
argument_list|,
literal|8
argument_list|)
operator|)
operator|>
literal|64
operator|||
name|fbbits
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"-f: number must be 1-64 inclusive"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fbbits
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"-f: number must be a multiple of 8"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* decrypt */
if|if
condition|(
name|ISSET_MODE_DIRECTION
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"only one of -i and -m allowed"
argument_list|)
expr_stmt|;
name|mode
operator||=
name|MODE_DECRYPT
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* number of bits for MACing */
if|if
condition|(
name|ISSET_MODE_DIRECTION
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"only one of -i and -m allowed"
argument_list|)
expr_stmt|;
name|mode
operator||=
name|MODE_AUTHENTICATE
expr_stmt|;
if|if
condition|(
operator|(
name|macbits
operator|=
name|setbits
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|64
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"-m: number must be 0-64 inclusive"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* use OFB mode */
if|if
condition|(
name|ISSET_MODE_ALGORITHM
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"two modes of operation specified"
argument_list|)
expr_stmt|;
name|mode
operator||=
name|MODE_OFB
expr_stmt|;
if|if
condition|(
operator|(
name|fbbits
operator|=
name|setbits
argument_list|(
name|optarg
argument_list|,
literal|8
argument_list|)
operator|)
operator|>
literal|64
operator|||
name|fbbits
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"-o: number must be 1-64 inclusive"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fbbits
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"-o: number must be a multiple of 8"
argument_list|)
expr_stmt|;
break|break;
break|break;
case|case
literal|'p'
case|:
comment|/* preserve parity bits */
name|pflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* set initialization vector */
name|cvtkey
argument_list|(
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* error */
name|n
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 	 * on error, quit 	 */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * if no direction set, default to encryption 	 */
if|if
condition|(
operator|!
name|ISSET_MODE_DIRECTION
condition|)
name|mode
operator||=
name|MODE_ENCRYPT
expr_stmt|;
if|if
condition|(
operator|!
name|ISSET_MODE_ALGORITHM
condition|)
name|mode
operator||=
name|MODE_CBC
expr_stmt|;
comment|/* 	 * pick up the key 	 * -- if there are no more arguments, prompt for it 	 * -- if there is 1 more argument, use it as the key 	 * -- if there are 2 or more arguments, error 	 */
if|if
condition|(
name|optind
operator|==
name|nargs
condition|)
block|{
comment|/* 		 * if the key's not ASCII, assume it is 		 */
name|keybase
operator|=
name|KEY_ASCII
expr_stmt|;
comment|/* 		 * get the key 		 */
if|if
condition|(
operator|(
name|p
operator|=
name|getpass
argument_list|(
literal|"Enter key: "
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"no key given"
argument_list|)
expr_stmt|;
comment|/* 		 * copy it, nul-padded, into the key area 		 */
name|strncpy
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|p
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optind
operator|+
literal|1
operator|==
name|nargs
condition|)
block|{
comment|/* 		 * obtain the bit form of the key 		 * and hide it from a "ps" 		 */
name|cvtkey
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|arglist
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|arglist
index|[
name|optind
index|]
operator|=
name|keyrep
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * extra arguments -- bomb 		 */
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"extraneous arguments"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * main loop 	 */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_ECB
operator||
name|MODE_ENCRYPT
case|:
comment|/* encrypt using ECB mode */
name|inverse
operator|=
literal|0
expr_stmt|;
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|ecbenc
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_ECB
operator||
name|MODE_DECRYPT
case|:
comment|/* decrypt using ECB mode */
name|inverse
operator|=
literal|1
expr_stmt|;
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|ecbdec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_ECB
operator||
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using ECB */
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"can't authenticate with ECB mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_CBC
operator||
name|MODE_ENCRYPT
case|:
comment|/* encrypt using CBC mode */
name|inverse
operator|=
literal|0
expr_stmt|;
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|cbcenc
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_CBC
operator||
name|MODE_DECRYPT
case|:
comment|/* decrypt using CBC mode */
name|inverse
operator|=
literal|1
expr_stmt|;
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|cbcdec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_CBC
operator||
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using CBC */
name|inverse
operator|=
literal|0
expr_stmt|;
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|cbcauth
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_CFB
operator||
name|MODE_ENCRYPT
case|:
comment|/* encrypt using CFB mode */
name|inverse
operator|=
literal|0
expr_stmt|;
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|cfbenc
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_CFB
operator||
name|MODE_DECRYPT
case|:
comment|/* decrypt using CFB mode */
name|inverse
operator|=
literal|0
expr_stmt|;
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|cfbdec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_CFB
operator||
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using CFB */
name|inverse
operator|=
literal|0
expr_stmt|;
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|cfbauth
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_CFBA
operator||
name|MODE_ENCRYPT
case|:
comment|/* alternative CFB mode */
name|inverse
operator|=
literal|0
expr_stmt|;
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|cfbaenc
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_CFBA
operator||
name|MODE_DECRYPT
case|:
comment|/* alternative CFB mode */
name|inverse
operator|=
literal|0
expr_stmt|;
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|cfbadec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_OFB
operator||
name|MODE_ENCRYPT
case|:
comment|/* encrypt using OFB mode */
name|inverse
operator|=
literal|0
expr_stmt|;
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|ofbenc
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_OFB
operator||
name|MODE_DECRYPT
case|:
comment|/* decrypt using OFB mode */
name|inverse
operator|=
literal|0
expr_stmt|;
name|makekey
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|ofbdec
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* unimplemented */
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"can't handle that yet"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print a warning message and, possibly, terminate  */
end_comment

begin_macro
name|err
argument_list|(
argument|f
argument_list|,
argument|n
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*>0 if fatal (status code), 0 if not */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offending block number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the message */
end_comment

begin_block
block|{
name|char
name|tbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%s (block %d)"
argument_list|,
name|progname
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%s"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|C_NULL
condition|)
name|perror
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|tbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>
literal|0
condition|)
name|exit
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * map a hex character to an integer  */
end_comment

begin_function
name|int
name|tobinhex
parameter_list|(
name|c
parameter_list|,
name|radix
parameter_list|)
name|char
name|c
decl_stmt|;
name|int
name|radix
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
return|return
operator|(
literal|0x0
operator|)
return|;
case|case
literal|'1'
case|:
return|return
operator|(
literal|0x1
operator|)
return|;
case|case
literal|'2'
case|:
return|return
operator|(
name|radix
operator|>
literal|2
condition|?
literal|0x2
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'3'
case|:
return|return
operator|(
name|radix
operator|>
literal|3
condition|?
literal|0x3
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'4'
case|:
return|return
operator|(
name|radix
operator|>
literal|4
condition|?
literal|0x4
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'5'
case|:
return|return
operator|(
name|radix
operator|>
literal|5
condition|?
literal|0x5
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'6'
case|:
return|return
operator|(
name|radix
operator|>
literal|6
condition|?
literal|0x6
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'7'
case|:
return|return
operator|(
name|radix
operator|>
literal|7
condition|?
literal|0x7
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'8'
case|:
return|return
operator|(
name|radix
operator|>
literal|8
condition|?
literal|0x8
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'9'
case|:
return|return
operator|(
name|radix
operator|>
literal|9
condition|?
literal|0x9
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
return|return
operator|(
name|radix
operator|>
literal|10
condition|?
literal|0xa
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
return|return
operator|(
name|radix
operator|>
literal|11
condition|?
literal|0xb
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
return|return
operator|(
name|radix
operator|>
literal|12
condition|?
literal|0xc
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
return|return
operator|(
name|radix
operator|>
literal|13
condition|?
literal|0xd
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
return|return
operator|(
name|radix
operator|>
literal|14
condition|?
literal|0xe
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
return|return
operator|(
name|radix
operator|>
literal|15
condition|?
literal|0xf
else|:
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * invalid character 	 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * convert the key to a bit pattern  */
end_comment

begin_macro
name|cvtkey
argument_list|(
argument|obuf
argument_list|,
argument|ibuf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|obuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ibuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* counter in a for loop */
name|int
name|nbuf
index|[
literal|64
index|]
decl_stmt|;
comment|/* used for hex/key translation */
comment|/* 	 * just switch on the key base 	 */
switch|switch
condition|(
name|keybase
condition|)
block|{
case|case
name|KEY_ASCII
case|:
comment|/* ascii to integer */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|obuf
argument_list|,
name|ibuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return;
case|case
name|KEY_DEFAULT
case|:
comment|/* tell from context */
comment|/* 		 * leading '0x' or '0X' == hex key 		 */
if|if
condition|(
name|ibuf
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|ibuf
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|ibuf
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
name|ibuf
operator|=
operator|&
name|ibuf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 			 * now translate it, bombing on any illegal hex digit 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ibuf
index|[
name|i
index|]
operator|&&
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|nbuf
index|[
name|i
index|]
operator|=
name|tobinhex
argument_list|(
name|ibuf
index|[
name|i
index|]
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"bad hex digit in key"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
name|nbuf
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|obuf
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|nbuf
index|[
literal|2
operator|*
name|i
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|nbuf
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|&
literal|0xf
operator|)
expr_stmt|;
comment|/* preserve parity bits */
name|pflag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 		 * leading '0b' or '0B' == binary key 		 */
if|if
condition|(
name|ibuf
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|ibuf
index|[
literal|1
index|]
operator|==
literal|'b'
operator|||
name|ibuf
index|[
literal|1
index|]
operator|==
literal|'B'
operator|)
condition|)
block|{
name|ibuf
operator|=
operator|&
name|ibuf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 			 * now translate it, bombing on any illegal binary digit 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ibuf
index|[
name|i
index|]
operator|&&
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|nbuf
index|[
name|i
index|]
operator|=
name|tobinhex
argument_list|(
name|ibuf
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"bad binary digit in key"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|64
condition|)
name|nbuf
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|obuf
index|[
name|i
index|]
operator|=
operator|(
name|obuf
index|[
name|i
index|]
operator|<<
literal|1
operator|)
operator||
name|nbuf
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
expr_stmt|;
comment|/* preserve parity bits */
name|pflag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 		 * no special leader -- ASCII 		 */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|obuf
argument_list|,
name|ibuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * convert an ASCII string into a decimal number:  * 1. must be between 0 and 64 inclusive  * 2. must be a valid decimal number  * 3. must be a multiple of mult  */
end_comment

begin_macro
name|setbits
argument_list|(
argument|s
argument_list|,
argument|mult
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mult
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* 	 * skip white space 	 */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* 	 * get the integer 	 */
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
else|else
block|{
name|err
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"bad decimal digit in MAC length"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * be sure it's a multiple of mult 	 */
return|return
operator|(
operator|(
name|n
operator|%
name|mult
operator|!=
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/*****************  * DES FUNCTIONS *  *****************/
end_comment

begin_comment
comment|/*  * This sets the DES key and (if you're using the deszip version)  * the direction of the transformation.  This uses the Sun  * to map the 64-bit key onto the 56 bits that the key schedule  * generation routines use: the old way, which just uses the user-  * supplied 64 bits as is, and the new way, which resets the parity  * bit to be the same as the low-order bit in each character.  The  * new way generates a greater variety of key schedules, since many  * systems set the parity (high) bit of each character to 0, and the  * DES ignores the low order bit of each character.  */
end_comment

begin_macro
name|makekey
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|Desbuf
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key block */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* counter in a for loop */
specifier|register
name|int
name|par
decl_stmt|;
comment|/* parity counter */
comment|/* 	 * if the parity is not preserved, flip it 	 */
if|if
condition|(
operator|!
name|pflag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|par
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|bits
index|[
name|j
index|]
operator|&
name|UCHAR
argument_list|(
name|buf
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|par
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|par
operator|&
literal|01
operator|)
operator|==
literal|01
condition|)
name|UCHAR
argument_list|(
name|buf
argument_list|,
name|i
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|buf
argument_list|,
name|i
argument_list|)
operator|&
literal|0177
expr_stmt|;
else|else
name|UCHAR
argument_list|(
name|buf
argument_list|,
name|i
argument_list|)
operator|=
operator|(
name|UCHAR
argument_list|(
name|buf
argument_list|,
name|i
argument_list|)
operator|&
literal|0177
operator|)
operator||
literal|0200
expr_stmt|;
block|}
block|}
comment|/* 	 * Make the key schedule 	 */
name|DES_KEY
argument_list|(
name|UBUFFER
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This encrypts using the Electronic Code Book mode of DES  */
end_comment

begin_macro
name|ecbenc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
for|for
control|(
name|bn
operator|=
literal|0
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|;
name|bn
operator|++
control|)
block|{
comment|/* 		 * do the transformation 		 */
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either ase, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
argument_list|,
literal|8
operator|-
name|n
argument_list|)
expr_stmt|;
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|7
argument_list|)
operator|=
name|n
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This decrypts using the Electronic Code Book mode of DES  */
end_comment

begin_macro
name|ecbdec
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|;
name|bn
operator|++
control|)
block|{
comment|/* 		 * do the transformation 		 */
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|n
operator|=
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|7
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|bn
argument_list|,
literal|"decryption failed (block corrupted)"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|bn
argument_list|,
literal|"decryption failed (incomplete block)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This encrypts using the Cipher Block Chaining mode of DES  */
end_comment

begin_macro
name|cbcenc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|;
name|bn
operator|++
control|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
operator|^=
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
argument_list|,
literal|8
operator|-
name|n
argument_list|)
expr_stmt|;
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|7
argument_list|)
operator|=
name|n
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
operator|^=
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This decrypts using the Cipher Block Chaining mode of DES  */
end_comment

begin_macro
name|cbcdec
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
name|Desbuf
name|ibuf
decl_stmt|;
comment|/* temp buffer for initialization vector */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
for|for
control|(
name|bn
operator|=
literal|0
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|;
name|bn
operator|++
control|)
block|{
comment|/* 		 * do the transformation 		 */
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|ibuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
condition|;
name|c
operator|++
control|)
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|c
argument_list|)
operator|^=
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ibuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|n
operator|=
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|7
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|bn
argument_list|,
literal|"decryption failed (block corrupted)"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|bn
argument_list|,
literal|"decryption failed (incomplete block)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This authenticates using the Cipher Block Chaining mode of DES  */
end_comment

begin_macro
name|cbcauth
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|j
decl_stmt|;
comment|/* number of bytes actually read */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
name|Desbuf
name|encbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do the transformation 	 * note we DISCARD the encrypted block; 	 * we only care about the last one 	 */
while|while
condition|(
operator|(
name|n
operator|=
name|READ
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|CHAR
argument_list|(
name|encbuf
argument_list|,
name|n
argument_list|)
operator|=
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
operator|^
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|encbuf
argument_list|)
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|encbuf
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * now compute the last one, right padding with '\0' if need be 	 */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|MEMZERO
argument_list|(
operator|&
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
argument_list|,
literal|8
operator|-
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|CHAR
argument_list|(
name|encbuf
argument_list|,
name|n
argument_list|)
operator|=
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
operator|^
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|encbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * drop the bits 	 * we write chars until fewer than 7 bits, 	 * and then pad the last one with 0 bits 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|macbits
operator|>
literal|7
condition|;
name|n
operator|++
operator|,
name|macbits
operator|-=
literal|8
control|)
name|putchar
argument_list|(
name|CHAR
argument_list|(
name|encbuf
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|macbits
operator|>
literal|0
condition|)
block|{
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|macbits
condition|;
name|j
operator|++
control|)
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
operator||=
operator|(
name|CHAR
argument_list|(
name|encbuf
argument_list|,
name|n
argument_list|)
operator|&
name|bits
index|[
name|j
index|]
operator|)
expr_stmt|;
name|putchar
argument_list|(
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * This encrypts using the Cipher FeedBack mode of DES  */
end_comment

begin_macro
name|cfbenc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|n
argument_list|)
operator|=
name|ibuf
index|[
name|n
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
operator|&
name|CHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|ibuf
index|[
name|n
index|]
argument_list|,
name|nbytes
operator|-
name|n
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
name|n
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|ibuf
index|[
name|n
index|]
operator|^=
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This decrypts using the Cipher Block Chaining mode of DES  */
end_comment

begin_macro
name|cfbdec
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|c
operator|++
control|)
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|c
argument_list|)
operator|=
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|c
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nbytes
condition|;
name|c
operator|++
control|)
block|{
name|CHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|c
argument_list|)
operator|=
name|ibuf
index|[
name|c
index|]
expr_stmt|;
name|obuf
index|[
name|c
index|]
operator|=
name|ibuf
index|[
name|c
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|n
operator|=
name|obuf
index|[
name|nbytes
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nbytes
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|bn
argument_list|,
literal|"decryption failed (block corrupted)"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|bn
argument_list|,
literal|"decryption failed (incomplete block)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This encrypts using the alternative Cipher FeedBack mode of DES  */
end_comment

begin_macro
name|cfbaenc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|7
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|n
argument_list|)
operator|=
operator|(
name|ibuf
index|[
name|n
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
operator|)
operator||
literal|0200
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|obuf
index|[
name|n
index|]
operator|=
name|CHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|n
argument_list|)
operator|&
literal|0177
expr_stmt|;
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|ibuf
index|[
name|n
index|]
argument_list|,
name|nbytes
operator|-
name|n
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
operator|(
literal|'0'
operator|+
name|n
operator|)
operator||
literal|0200
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|ibuf
index|[
name|n
index|]
operator|^=
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This decrypts using the alternative Cipher Block Chaining mode of DES  */
end_comment

begin_macro
name|cfbadec
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|7
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|c
operator|++
control|)
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|c
argument_list|)
operator|=
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|c
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nbytes
condition|;
name|c
operator|++
control|)
block|{
name|CHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|c
argument_list|)
operator|=
name|ibuf
index|[
name|c
index|]
operator||
literal|0200
expr_stmt|;
name|obuf
index|[
name|c
index|]
operator|=
operator|(
name|ibuf
index|[
name|c
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|c
argument_list|)
operator|)
operator|&
literal|0177
expr_stmt|;
block|}
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
operator|(
name|obuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|)
operator|<
literal|0
operator|||
name|n
operator|>
name|nbytes
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|bn
argument_list|,
literal|"decryption failed (block corrupted)"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|bn
argument_list|,
literal|"decryption failed (incomplete block)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This encrypts using the Output FeedBack mode of DES  */
end_comment

begin_macro
name|ofbenc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
block|{
name|UCHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|n
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|obuf
index|[
name|n
index|]
operator|=
name|ibuf
index|[
name|n
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|ibuf
index|[
name|n
index|]
argument_list|,
name|nbytes
operator|-
name|n
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
name|n
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nbytes
condition|;
name|c
operator|++
control|)
name|ibuf
index|[
name|c
index|]
operator|^=
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This decrypts using the Output Block Chaining mode of DES  */
end_comment

begin_macro
name|ofbdec
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
specifier|register
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|c
operator|++
control|)
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|c
argument_list|)
operator|=
name|CHAR
argument_list|(
name|ivec
argument_list|,
name|c
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nbytes
condition|;
name|c
operator|++
control|)
block|{
name|CHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|c
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|obuf
index|[
name|c
index|]
operator|=
name|ibuf
index|[
name|c
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|n
operator|=
name|obuf
index|[
name|nbytes
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nbytes
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|bn
argument_list|,
literal|"decryption failed (block corrupted)"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/* 		 * dump it 		 */
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|bn
argument_list|,
literal|"decryption failed (incomplete block)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This authenticates using the Cipher FeedBack mode of DES  */
end_comment

begin_macro
name|cfbauth
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|j
decl_stmt|;
comment|/* number of bytes actually read */
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|Desbuf
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
while|while
condition|(
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|)
block|{
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
argument_list|)
operator|=
name|UCHAR
argument_list|(
name|ivec
argument_list|,
name|n
operator|+
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|UCHAR
argument_list|(
name|ivec
argument_list|,
literal|8
operator|-
name|nbytes
operator|+
name|n
argument_list|)
operator|=
name|ibuf
index|[
name|n
index|]
operator|^
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|MEMZERO
argument_list|(
operator|&
name|ibuf
index|[
name|n
index|]
argument_list|,
name|nbytes
operator|-
name|n
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
literal|'0'
operator|+
name|n
expr_stmt|;
name|MEMCPY
argument_list|(
name|BUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|BUFFER
argument_list|(
name|ivec
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
name|UBUFFER
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|ibuf
index|[
name|n
index|]
operator|^=
name|UCHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* 	 * drop the bits 	 * we write chars until fewer than 7 bits, 	 * and then pad the last one with 0 bits 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|macbits
operator|>
literal|7
condition|;
name|n
operator|++
operator|,
name|macbits
operator|-=
literal|8
control|)
name|putchar
argument_list|(
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|macbits
operator|>
literal|0
condition|)
block|{
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|macbits
condition|;
name|j
operator|++
control|)
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
operator||=
operator|(
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
operator|&
name|bits
index|[
name|j
index|]
operator|)
expr_stmt|;
name|putchar
argument_list|(
name|CHAR
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * change from 8 bits/Uchar to 1 bit/Uchar  */
end_comment

begin_macro
name|expand
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|Desbuf
name|from
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8bit/unsigned char string */
end_comment

begin_decl_stmt
name|char
name|to
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1bit/char string */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* counters in for loop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|to
index|[
name|i
operator|*
literal|8
operator|+
name|j
index|]
operator|=
operator|(
name|CHAR
argument_list|(
name|from
argument_list|,
name|i
argument_list|)
operator|>>
operator|(
literal|7
operator|-
name|j
operator|)
operator|)
operator|&
literal|01
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * change from 1 bit/char to 8 bits/Uchar  */
end_comment

begin_macro
name|compress
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
name|from
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1bit/char string */
end_comment

begin_decl_stmt
name|Desbuf
name|to
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8bit/unsigned char string */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* counters in for loop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|CHAR
argument_list|(
name|to
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|CHAR
argument_list|(
name|to
argument_list|,
name|i
argument_list|)
operator|=
operator|(
name|from
index|[
name|i
operator|*
literal|8
operator|+
name|j
index|]
operator|<<
operator|(
literal|7
operator|-
name|j
operator|)
operator|)
operator||
name|CHAR
argument_list|(
name|to
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

