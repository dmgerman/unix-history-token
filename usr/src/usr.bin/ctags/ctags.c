begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ctags.x	5.1 (Berkeley) 10/22/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_comment
comment|/*  * ctags: create a tags file  */
end_comment

begin_define
define|#
directive|define
name|bool
value|char
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_define
define|#
directive|define
name|EOS
value|'\0'
end_define

begin_define
define|#
directive|define
name|MAXTOKEN
value|250
end_define

begin_comment
comment|/* max size of single token */
end_comment

begin_define
define|#
directive|define
name|SETLINE
value|{++lineno;lineftell = ftell(inf);}
end_define

begin_define
define|#
directive|define
name|iswhite
parameter_list|(
name|arg
parameter_list|)
value|(_wht[arg])
end_define

begin_comment
comment|/* T if char is white */
end_comment

begin_define
define|#
directive|define
name|begtoken
parameter_list|(
name|arg
parameter_list|)
value|(_btk[arg])
end_define

begin_comment
comment|/* T if char can start token */
end_comment

begin_define
define|#
directive|define
name|intoken
parameter_list|(
name|arg
parameter_list|)
value|(_itk[arg])
end_define

begin_comment
comment|/* T if char can be in token */
end_comment

begin_define
define|#
directive|define
name|endtoken
parameter_list|(
name|arg
parameter_list|)
value|(_etk[arg])
end_define

begin_comment
comment|/* T if char ends tokens */
end_comment

begin_define
define|#
directive|define
name|isgood
parameter_list|(
name|arg
parameter_list|)
value|(_gd[arg])
end_define

begin_comment
comment|/* T if char can be after ')' */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|nd_st
block|{
comment|/* sorting structure */
name|struct
name|nd_st
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
comment|/* left and right sons */
name|char
modifier|*
name|entry
decl_stmt|,
comment|/* function or type name */
modifier|*
name|file
decl_stmt|,
comment|/* file name */
modifier|*
name|pat
decl_stmt|;
comment|/* search pattern */
name|int
name|lno
decl_stmt|;
comment|/* for -x option */
name|bool
name|been_warned
decl_stmt|;
comment|/* set if noticed dup */
block|}
name|NODE
typedef|;
end_typedef

begin_decl_stmt
name|NODE
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of the sorted binary tree */
end_comment

begin_comment
comment|/* boolean "func" (see init()) */
end_comment

begin_decl_stmt
name|bool
name|_wht
index|[
literal|0177
index|]
decl_stmt|,
name|_etk
index|[
literal|0177
index|]
decl_stmt|,
name|_itk
index|[
literal|0177
index|]
decl_stmt|,
name|_btk
index|[
literal|0177
index|]
decl_stmt|,
name|_gd
index|[
literal|0177
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|inf
decl_stmt|,
comment|/* ioptr for current input file */
modifier|*
name|outf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ioptr for tags file */
end_comment

begin_decl_stmt
name|long
name|lineftell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ftell after getc( inf ) == '\n' */
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|,
comment|/* line number of current line */
name|aflag
decl_stmt|,
comment|/* -a: append to tags */
name|dflag
decl_stmt|,
comment|/* -d: non-macro defines */
name|tflag
decl_stmt|,
comment|/* -t: create tags for typedefs */
name|uflag
decl_stmt|,
comment|/* -u: update tags */
name|wflag
decl_stmt|,
comment|/* -w: suppress warnings */
name|vflag
decl_stmt|,
comment|/* -v: vgrind style index output */
name|xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -x: cxref style output */
end_comment

begin_decl_stmt
name|char
modifier|*
name|curfile
decl_stmt|,
comment|/* current input file name */
name|searchar
init|=
literal|'/'
decl_stmt|,
comment|/* use /.../ searches by default */
name|line
index|[
literal|4
operator|*
name|BUFSIZ
index|]
decl_stmt|,
comment|/* current input line */
name|lbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
comment|/* getopt arguments */
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|static
name|char
modifier|*
name|outfile
init|=
literal|"tags"
decl_stmt|;
comment|/* output file */
name|int
name|exit_val
decl_stmt|,
comment|/* exit value */
name|step
decl_stmt|,
comment|/* step through args */
name|ch
decl_stmt|;
comment|/* getopts char */
name|char
name|cmd
index|[
literal|100
index|]
decl_stmt|,
comment|/* too ugly to explain */
modifier|*
name|savestr
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"BFadf:tuwvx"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
case|case
literal|'B'
case|:
name|searchar
operator|=
literal|'?'
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|searchar
operator|=
literal|'/'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|aflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|outfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|uflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|vflag
operator|++
expr_stmt|;
case|case
literal|'x'
case|:
name|xflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
goto|goto
name|usage
goto|;
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
operator|!
name|argc
condition|)
block|{
name|usage
label|:
name|puts
argument_list|(
literal|"Usage: ctags [-BFadtuwvx] [-f tagsfile] file ..."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|init
argument_list|()
expr_stmt|;
for|for
control|(
name|exit_val
operator|=
name|step
operator|=
literal|0
init|;
name|step
operator|<
name|argc
condition|;
operator|++
name|step
control|)
block|{
name|curfile
operator|=
name|savestr
argument_list|(
name|argv
index|[
name|step
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inf
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|step
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
name|step
index|]
argument_list|)
expr_stmt|;
name|exit_val
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|find_entries
argument_list|(
name|argv
index|[
name|step
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xflag
condition|)
block|{
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uflag
condition|)
block|{
for|for
control|(
name|step
operator|=
literal|0
init|;
name|step
operator|<
name|argc
condition|;
name|step
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"mv %s OTAGS;fgrep -v '\t%s\t' OTAGS>%s;rm OTAGS"
argument_list|,
name|outfile
argument_list|,
name|argv
index|[
name|step
index|]
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
operator|++
name|aflag
expr_stmt|;
block|}
name|outf
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
name|aflag
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outf
condition|)
block|{
name|perror
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_val
argument_list|)
expr_stmt|;
block|}
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|outf
argument_list|)
expr_stmt|;
if|if
condition|(
name|uflag
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"sort %s -o %s"
argument_list|,
name|outfile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|exit_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * init --  *	this routine sets up the boolean psuedo-functions which work by  *	setting boolean flags dependent upon the corresponding character.  *	Every char which is NOT in that string is false with respect to  *	the pseudo-function.  Therefore, all of the array "_wht" is NO  *	by default and then the elements subscripted by the chars in  *	CWHITE are set to YES.  Thus, "_wht" of a char is YES if it is in  *	the string CWHITE, else NO.  */
end_comment

begin_macro
name|init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0177
condition|;
name|i
operator|++
control|)
block|{
name|_wht
index|[
name|i
index|]
operator|=
name|_etk
index|[
name|i
index|]
operator|=
name|_itk
index|[
name|i
index|]
operator|=
name|_btk
index|[
name|i
index|]
operator|=
name|NO
expr_stmt|;
name|_gd
index|[
name|i
index|]
operator|=
name|YES
expr_stmt|;
block|}
define|#
directive|define
name|CWHITE
value|" \f\t\n"
for|for
control|(
name|sp
operator|=
name|CWHITE
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
comment|/* white space chars */
name|_wht
index|[
operator|*
name|sp
index|]
operator|=
name|YES
expr_stmt|;
define|#
directive|define
name|CTOKEN
value|" \t\n\"'#()[]{}=-+%*/&|^~!<>;,.:?"
for|for
control|(
name|sp
operator|=
name|CTOKEN
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
comment|/* token ending chars */
name|_etk
index|[
operator|*
name|sp
index|]
operator|=
name|YES
expr_stmt|;
define|#
directive|define
name|CINTOK
value|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz0123456789"
for|for
control|(
name|sp
operator|=
name|CINTOK
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
comment|/* valid in-token chars */
name|_itk
index|[
operator|*
name|sp
index|]
operator|=
name|YES
expr_stmt|;
define|#
directive|define
name|CBEGIN
value|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
for|for
control|(
name|sp
operator|=
name|CBEGIN
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
comment|/* token starting chars */
name|_btk
index|[
operator|*
name|sp
index|]
operator|=
name|YES
expr_stmt|;
define|#
directive|define
name|CNOTGD
value|",;"
for|for
control|(
name|sp
operator|=
name|CNOTGD
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
comment|/* invalid after-function chars */
name|_gd
index|[
operator|*
name|sp
index|]
operator|=
name|NO
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * find_entries --  *	this routine opens the specified file and calls the function  *	which searches the file.  */
end_comment

begin_macro
name|find_entries
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
comment|/* should be 1 ?? KB */
if|if
condition|(
name|cp
operator|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
operator|!
name|cp
index|[
literal|2
index|]
condition|)
block|{
comment|/* lisp */
if|if
condition|(
name|index
argument_list|(
literal|";(["
argument_list|,
operator|(
name|char
operator|)
name|first_char
argument_list|()
argument_list|)
condition|)
block|{
name|L_funcs
argument_list|()
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* lex */
else|else
block|{
name|toss_yysec
argument_list|()
expr_stmt|;
name|getline
argument_list|()
expr_stmt|;
name|pfnote
argument_list|(
literal|"yylex"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|toss_yysec
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* yacc */
elseif|else
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'y'
operator|&&
operator|!
name|cp
index|[
literal|2
index|]
condition|)
name|Y_entries
argument_list|()
expr_stmt|;
comment|/* fortran */
elseif|else
if|if
condition|(
operator|(
name|cp
index|[
literal|1
index|]
operator|!=
literal|'c'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'h'
operator|)
operator|&&
operator|!
name|cp
index|[
literal|2
index|]
condition|)
block|{
if|if
condition|(
name|PF_funcs
argument_list|()
condition|)
goto|goto
name|done
goto|;
name|rewind
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
block|}
name|c_entries
argument_list|()
expr_stmt|;
comment|/* default: try C */
name|done
label|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * pfnote --  *	enter a new node in the tree  */
end_comment

begin_macro
name|pfnote
argument_list|(
argument|name
argument_list|,
argument|ln
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ln
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|np
decl_stmt|;
specifier|register
name|char
modifier|*
name|fp
decl_stmt|;
name|char
name|nbuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|savestr
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|np
operator|=
operator|(
name|NODE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"ctags: too many entries to sort\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free_tree
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|np
operator|=
operator|(
name|NODE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"ctags: out of space.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|head
operator|=
name|np
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xflag
operator|&&
operator|!
name|bcmp
argument_list|(
name|name
argument_list|,
literal|"main"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|rindex
argument_list|(
name|curfile
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|fp
operator|=
name|curfile
expr_stmt|;
else|else
operator|++
name|fp
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"M%s"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|rindex
argument_list|(
name|nbuf
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|&&
operator|!
name|fp
index|[
literal|2
index|]
condition|)
operator|*
name|fp
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|nbuf
expr_stmt|;
block|}
name|np
operator|->
name|entry
operator|=
name|savestr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|np
operator|->
name|file
operator|=
name|curfile
expr_stmt|;
name|np
operator|->
name|lno
operator|=
name|ln
expr_stmt|;
name|np
operator|->
name|left
operator|=
name|np
operator|->
name|right
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|xflag
condition|)
block|{
name|lbuf
index|[
literal|50
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|lbuf
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
name|lbuf
index|[
literal|50
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|np
operator|->
name|pat
operator|=
name|savestr
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
name|head
operator|=
name|np
expr_stmt|;
else|else
name|add_node
argument_list|(
name|np
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * c_entries --  *	read .c and .h files and call appropriate routines  */
end_comment

begin_macro
name|c_entries
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
comment|/* current character */
name|level
decl_stmt|;
comment|/* brace level */
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
comment|/* buffer pointer */
name|int
name|token
decl_stmt|,
comment|/* if reading a token */
name|t_def
decl_stmt|,
comment|/* if reading a typedef */
name|t_level
decl_stmt|;
comment|/* typedef's brace level */
name|char
name|tok
index|[
name|MAXTOKEN
index|]
decl_stmt|;
comment|/* token buffer */
name|lineftell
operator|=
name|ftell
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|sp
operator|=
name|tok
expr_stmt|;
name|token
operator|=
name|t_def
operator|=
name|NO
expr_stmt|;
name|t_level
operator|=
operator|-
literal|1
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
operator|(
name|char
operator|)
name|c
condition|)
block|{
comment|/* 		 * Here's where it DOESN'T handle: 		 *	foo(a) 		 *	{ 		 *	#ifdef notdef 		 *		} 		 *	#endif 		 *		if (a) 		 *			puts("hello, world"); 		 *	} 		 */
case|case
literal|'{'
case|:
operator|++
name|level
expr_stmt|;
goto|goto
name|endtok
goto|;
case|case
literal|'}'
case|:
comment|/* 			 * if level goes below zero, try and fix 			 * it, even though we've already messed up 			 */
if|if
condition|(
operator|--
name|level
operator|<
literal|0
condition|)
name|level
operator|=
literal|0
expr_stmt|;
goto|goto
name|endtok
goto|;
case|case
literal|'\n'
case|:
name|SETLINE
expr_stmt|;
comment|/* 			 * the above 3 cases are similar in that they 			 * are special characters that also end tokens. 			 */
name|endtok
label|:
if|if
condition|(
name|sp
operator|>
name|tok
condition|)
block|{
operator|*
name|sp
operator|=
name|EOS
expr_stmt|;
name|token
operator|=
name|YES
expr_stmt|;
name|sp
operator|=
name|tok
expr_stmt|;
block|}
else|else
name|token
operator|=
name|NO
expr_stmt|;
continue|continue;
comment|/* we ignore quoted strings and comments in their entirety */
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|skip_key
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
literal|'*'
condition|)
block|{
name|skip_comment
argument_list|()
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|inf
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'/'
expr_stmt|;
goto|goto
name|storec
goto|;
comment|/* hash marks are interesting if they start #define's. */
case|case
literal|'#'
case|:
if|if
condition|(
name|sp
operator|==
name|tok
condition|)
block|{
name|hash_entry
argument_list|()
expr_stmt|;
break|break;
block|}
goto|goto
name|storec
goto|;
comment|/* 	 	 * if we have a current token, parenthesis on 		 * level zero indicates a function. 		 */
case|case
literal|'('
case|:
if|if
condition|(
operator|!
name|level
operator|&&
name|token
condition|)
block|{
name|int
name|curline
decl_stmt|;
if|if
condition|(
name|sp
operator|!=
name|tok
condition|)
operator|*
name|sp
operator|=
name|EOS
expr_stmt|;
comment|/* 				 * grab the line immediately, we may 				 * already be wrong, for example, 				 *	foo 				 *	(arg1, 				 */
name|getline
argument_list|()
expr_stmt|;
name|curline
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
name|func_entry
argument_list|()
condition|)
block|{
operator|++
name|level
expr_stmt|;
name|pfnote
argument_list|(
name|tok
argument_list|,
name|curline
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
goto|goto
name|storec
goto|;
comment|/* 		 * semi-colons are interesting in that they indicate the end 		 * of a typedef; if we find a typedef we search for the next 		 * semi-colon of the same level as the typedef.  They are 		 * fairly tough, can be: 		 * 		 *	"typedef long time_t;" 		 *	"typedef unsigned int u_int;" 		 *	"typedef unsigned int u_int [10];" 		 * 		 * If looking at a typedef, we save a copy of the last token 		 * found.  Then, when we find the ';' we take the current 		 * token if it starts with a valid token name, else we take 		 * the one we saved.  There's probably some reasonable 		 * alternative to this... 		 */
case|case
literal|';'
case|:
if|if
condition|(
name|t_def
operator|&&
name|level
operator|==
name|t_level
condition|)
block|{
name|t_def
operator|=
name|NO
expr_stmt|;
name|getline
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|tok
condition|)
operator|*
name|sp
operator|=
name|EOS
expr_stmt|;
name|pfnote
argument_list|(
name|tok
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|storec
goto|;
comment|/* 		 * store characters until one that can't be part of a token 		 * comes along; check the current token against certain 		 * reserved words. 		 */
default|default:
name|storec
label|:
if|if
condition|(
operator|!
name|intoken
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|sp
operator|==
name|tok
condition|)
break|break;
operator|*
name|sp
operator|=
name|EOS
expr_stmt|;
if|if
condition|(
name|tflag
condition|)
block|{
comment|/* no typedefs inside typedefs */
if|if
condition|(
operator|!
name|t_def
operator|&&
operator|!
name|bcmp
argument_list|(
name|tok
argument_list|,
literal|"typedef"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|t_def
operator|=
name|YES
expr_stmt|;
name|t_level
operator|=
name|level
expr_stmt|;
break|break;
block|}
comment|/* catch "typedef struct" */
if|if
condition|(
operator|(
operator|!
name|t_def
operator|||
name|t_level
operator|<
name|level
operator|)
operator|&&
operator|(
operator|!
name|bcmp
argument_list|(
name|tok
argument_list|,
literal|"struct"
argument_list|,
literal|7
argument_list|)
operator|||
operator|!
name|bcmp
argument_list|(
name|tok
argument_list|,
literal|"union"
argument_list|,
literal|6
argument_list|)
operator|||
operator|!
name|bcmp
argument_list|(
name|tok
argument_list|,
literal|"enum"
argument_list|,
literal|5
argument_list|)
operator|)
condition|)
block|{
comment|/* 						 * get line immediately; 						 * may change before '{' 						 */
name|getline
argument_list|()
expr_stmt|;
if|if
condition|(
name|str_entry
argument_list|(
name|c
argument_list|)
condition|)
operator|++
name|level
expr_stmt|;
break|break;
block|}
block|}
name|sp
operator|=
name|tok
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|!=
name|tok
operator|||
name|begtoken
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
name|token
operator|=
name|YES
expr_stmt|;
block|}
continue|continue;
block|}
name|sp
operator|=
name|tok
expr_stmt|;
name|token
operator|=
name|NO
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * func_entry --  *	handle a function reference  */
end_comment

begin_macro
name|func_entry
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* current character */
name|skip_key
argument_list|(
operator|(
name|int
operator|)
literal|')'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|iswhite
argument_list|(
name|c
argument_list|)
condition|)
if|if
condition|(
name|c
operator|==
operator|(
name|int
operator|)
literal|'\n'
condition|)
name|SETLINE
expr_stmt|;
if|if
condition|(
operator|!
name|intoken
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|(
name|int
operator|)
literal|'{'
condition|)
return|return
operator|(
name|NO
operator|)
return|;
if|if
condition|(
name|c
operator|!=
operator|(
name|int
operator|)
literal|'{'
condition|)
name|skip_key
argument_list|(
operator|(
name|int
operator|)
literal|'{'
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * hash_entry --  *	handle a line starting with a '#'  */
end_comment

begin_macro
name|hash_entry
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
comment|/* character read */
name|curline
decl_stmt|;
comment|/* line started on */
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
comment|/* buffer pointer */
name|char
name|tok
index|[
name|MAXTOKEN
index|]
decl_stmt|;
comment|/* storage buffer */
name|curline
operator|=
name|lineno
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|tok
init|;
condition|;
control|)
block|{
comment|/* get next token */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return;
if|if
condition|(
name|iswhite
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|sp
operator|=
name|EOS
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|tok
argument_list|,
literal|"define"
argument_list|,
literal|6
argument_list|)
condition|)
comment|/* only interested in #define's */
goto|goto
name|skip
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* this doesn't handle "#define \n" */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return;
if|if
condition|(
operator|!
name|iswhite
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
for|for
control|(
name|sp
operator|=
name|tok
init|;
condition|;
control|)
block|{
comment|/* get next token */
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return;
comment|/* 		 * this is where it DOESN'T handle 		 * "#define \n" 		 */
if|if
condition|(
operator|!
name|intoken
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
operator|*
name|sp
operator|=
name|EOS
expr_stmt|;
if|if
condition|(
name|dflag
operator|||
name|c
operator|==
operator|(
name|int
operator|)
literal|'('
condition|)
block|{
comment|/* only want macros */
name|getline
argument_list|()
expr_stmt|;
name|pfnote
argument_list|(
name|tok
argument_list|,
name|curline
argument_list|)
expr_stmt|;
block|}
name|skip
label|:
if|if
condition|(
name|c
operator|==
operator|(
name|int
operator|)
literal|'\n'
condition|)
block|{
comment|/* get rid of rest of define */
name|SETLINE
if|if
condition|(
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
operator|!=
literal|'\\'
condition|)
return|return;
block|}
name|skip_line
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * str_entry --  *	handle a struct, union or enum entry  */
end_comment

begin_expr_stmt
name|str_entry
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* current character */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
comment|/* buffer pointer */
name|int
name|curline
decl_stmt|;
comment|/* line started on */
name|char
name|tok
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* storage buffer */
name|curline
operator|=
name|lineno
expr_stmt|;
while|while
condition|(
name|iswhite
argument_list|(
name|c
argument_list|)
condition|)
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|NO
operator|)
return|;
if|if
condition|(
name|c
operator|==
operator|(
name|int
operator|)
literal|'{'
condition|)
comment|/* it was "struct {" */
return|return
operator|(
name|YES
operator|)
return|;
for|for
control|(
name|sp
operator|=
name|tok
init|;
condition|;
control|)
block|{
comment|/* get next token */
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|NO
operator|)
return|;
if|if
condition|(
operator|!
name|intoken
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
switch|switch
condition|(
operator|(
name|char
operator|)
name|c
condition|)
block|{
case|case
literal|'{'
case|:
comment|/* it was "struct foo{" */
operator|--
name|sp
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
comment|/* it was "struct foo\n" */
name|SETLINE
expr_stmt|;
comment|/*FALLTHROUGH*/
default|default:
comment|/* probably "struct foo " */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|!
name|iswhite
argument_list|(
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
operator|(
name|int
operator|)
literal|'{'
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
operator|*
name|sp
operator|=
name|EOS
expr_stmt|;
name|pfnote
argument_list|(
name|tok
argument_list|,
name|curline
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * skip_line --  *	skip to next line  */
end_comment

begin_macro
name|skip_line
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|savec
decl_stmt|;
for|for
control|(
name|savec
operator|=
literal|'\0'
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
condition|;
name|savec
operator|=
name|c
control|)
if|if
condition|(
name|c
operator|==
operator|(
name|int
operator|)
literal|'\n'
condition|)
block|{
name|SETLINE
expr_stmt|;
if|if
condition|(
name|savec
operator|!=
operator|(
name|int
operator|)
literal|'\\'
condition|)
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * skip_key --  *	skip to next char "key"  */
end_comment

begin_expr_stmt
name|skip_key
argument_list|(
name|key
argument_list|)
specifier|register
name|int
name|key
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
name|key
condition|)
if|if
condition|(
name|c
operator|==
operator|(
name|int
operator|)
literal|'\n'
condition|)
name|SETLINE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * skip_comment --  *	skip over comment  */
end_comment

begin_macro
name|skip_comment
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|level
decl_stmt|,
name|star
decl_stmt|,
name|slash
decl_stmt|;
for|for
control|(
name|level
operator|=
literal|1
operator|,
name|slash
operator|=
name|star
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
condition|;
control|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|c
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|slash
condition|)
block|{
operator|++
name|level
expr_stmt|;
name|slash
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|++
name|star
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|star
condition|)
block|{
if|if
condition|(
operator|!
operator|--
name|level
condition|)
return|return;
name|star
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|++
name|slash
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|SETLINE
expr_stmt|;
default|default:
name|slash
operator|=
name|star
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Y_entries:  *	Find the yacc tags and put them in.  */
end_comment

begin_macro
name|Y_entries
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|orig_sp
decl_stmt|;
specifier|register
name|int
name|brace
decl_stmt|;
specifier|register
name|bool
name|in_rule
decl_stmt|,
name|toklen
decl_stmt|;
name|char
name|tok
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|toss_comment
argument_list|()
decl_stmt|;
name|toss_yysec
argument_list|()
expr_stmt|;
name|brace
operator|=
literal|0
expr_stmt|;
name|getline
argument_list|()
expr_stmt|;
name|pfnote
argument_list|(
literal|"yyparse"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|inf
argument_list|)
condition|)
for|for
control|(
name|sp
operator|=
name|line
init|;
operator|*
name|sp
condition|;
operator|++
name|sp
control|)
switch|switch
condition|(
operator|*
name|sp
condition|)
block|{
case|case
literal|'\n'
case|:
name|lineno
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
break|break;
case|case
literal|'"'
case|:
do|do
block|{
while|while
condition|(
operator|*
operator|++
name|sp
operator|!=
literal|'"'
condition|)
continue|continue;
block|}
do|while
condition|(
name|sp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
do|;
break|break;
case|case
literal|'\''
case|:
do|do
block|{
while|while
condition|(
operator|*
operator|++
name|sp
operator|!=
literal|'\''
condition|)
continue|continue;
block|}
do|while
condition|(
name|sp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
do|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
operator|++
name|sp
operator|==
literal|'*'
condition|)
name|sp
operator|=
name|toss_comment
argument_list|(
name|sp
argument_list|)
expr_stmt|;
else|else
operator|--
name|sp
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|brace
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|brace
operator|--
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'%'
operator|&&
name|sp
operator|==
name|line
condition|)
return|return;
break|break;
case|case
literal|'|'
case|:
case|case
literal|';'
case|:
name|in_rule
operator|=
name|NO
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|brace
operator|&&
operator|!
name|in_rule
operator|&&
operator|(
name|isalpha
argument_list|(
operator|*
name|sp
argument_list|)
operator|||
operator|*
name|sp
operator|==
literal|'.'
operator|||
operator|*
name|sp
operator|==
literal|'_'
operator|)
condition|)
block|{
name|orig_sp
operator|=
name|sp
expr_stmt|;
operator|++
name|sp
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|sp
argument_list|)
operator|||
operator|*
name|sp
operator|==
literal|'_'
operator|||
operator|*
name|sp
operator|==
literal|'.'
condition|)
name|sp
operator|++
expr_stmt|;
name|toklen
operator|=
name|sp
operator|-
name|orig_sp
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|sp
argument_list|)
condition|)
name|sp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|':'
operator|||
operator|(
operator|*
name|sp
operator|==
literal|'\0'
operator|&&
name|first_char
argument_list|()
operator|==
literal|':'
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|tok
argument_list|,
name|orig_sp
argument_list|,
name|toklen
argument_list|)
expr_stmt|;
name|tok
index|[
name|toklen
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|lbuf
index|[
name|strlen
argument_list|(
name|lbuf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pfnote
argument_list|(
name|tok
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|in_rule
operator|=
name|YES
expr_stmt|;
block|}
else|else
name|sp
operator|--
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|toss_comment
parameter_list|(
name|start
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
comment|/* 	 * first, see if the end-of-comment is on the same line 	 */
do|do
block|{
while|while
condition|(
operator|(
name|sp
operator|=
name|index
argument_list|(
name|start
argument_list|,
literal|'*'
argument_list|)
operator|)
condition|)
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
return|return
operator|(
operator|++
name|sp
operator|)
return|;
else|else
name|start
operator|=
operator|++
name|sp
expr_stmt|;
name|start
operator|=
name|line
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|inf
argument_list|)
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * getline --  *	get the line the token of interest occurred on  */
end_comment

begin_macro
name|getline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|long
name|saveftell
decl_stmt|;
name|saveftell
operator|=
name|ftell
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|inf
argument_list|,
name|lineftell
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|lbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
argument_list|,
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|lbuf
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|fseek
argument_list|(
name|inf
argument_list|,
name|saveftell
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|free_tree
argument_list|(
name|node
argument_list|)
specifier|register
name|NODE
operator|*
name|node
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
name|node
condition|)
block|{
name|free_tree
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|add_node
argument_list|(
name|node
argument_list|,
name|cur_node
argument_list|)
specifier|register
name|NODE
operator|*
name|node
operator|,
operator|*
name|cur_node
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|dif
decl_stmt|;
name|dif
operator|=
name|strcmp
argument_list|(
name|node
operator|->
name|entry
argument_list|,
name|cur_node
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dif
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|file
operator|==
name|cur_node
operator|->
name|file
condition|)
block|{
if|if
condition|(
operator|!
name|wflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate entry in file %s, line %d: %s\nSecond entry ignored\n"
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|lineno
argument_list|,
name|node
operator|->
name|entry
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|cur_node
operator|->
name|been_warned
condition|)
if|if
condition|(
operator|!
name|wflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate entry in files %s and %s: %s (Warning only)\n"
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|cur_node
operator|->
name|file
argument_list|,
name|node
operator|->
name|entry
argument_list|)
expr_stmt|;
name|cur_node
operator|->
name|been_warned
operator|=
name|YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dif
operator|<
literal|0
condition|)
if|if
condition|(
name|cur_node
operator|->
name|left
condition|)
name|add_node
argument_list|(
name|node
argument_list|,
name|cur_node
operator|->
name|left
argument_list|)
expr_stmt|;
else|else
name|cur_node
operator|->
name|left
operator|=
name|node
expr_stmt|;
elseif|else
if|if
condition|(
name|cur_node
operator|->
name|right
condition|)
name|add_node
argument_list|(
name|node
argument_list|,
name|cur_node
operator|->
name|right
argument_list|)
expr_stmt|;
else|else
name|cur_node
operator|->
name|right
operator|=
name|node
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * put_entries --  *	write out the tags  */
end_comment

begin_expr_stmt
name|put_entries
argument_list|(
name|node
argument_list|)
specifier|register
name|NODE
operator|*
name|node
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return;
name|put_entries
argument_list|(
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xflag
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%s\t%s\t%c^"
argument_list|,
name|node
operator|->
name|entry
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|searchar
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|node
operator|->
name|pat
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
condition|)
name|fputs
argument_list|(
literal|"\\\\"
argument_list|,
name|outf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|sp
operator|==
name|searchar
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"\\%c"
argument_list|,
name|searchar
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
operator|*
name|sp
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%c\n"
argument_list|,
name|searchar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vflag
condition|)
name|printf
argument_list|(
literal|"%s %s %d\n"
argument_list|,
name|node
operator|->
name|entry
argument_list|,
name|node
operator|->
name|file
argument_list|,
operator|(
name|node
operator|->
name|lno
operator|+
literal|63
operator|)
operator|/
literal|64
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-16s%4d %-16s %s\n"
argument_list|,
name|node
operator|->
name|entry
argument_list|,
name|node
operator|->
name|lno
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|node
operator|->
name|pat
argument_list|)
expr_stmt|;
name|put_entries
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|dbp
init|=
name|lbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pfcnt
decl_stmt|;
end_decl_stmt

begin_macro
name|PF_funcs
argument_list|()
end_macro

begin_block
block|{
name|pfcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|lbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
argument_list|,
name|inf
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|dbp
operator|=
name|lbuf
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|'%'
condition|)
name|dbp
operator|++
expr_stmt|;
comment|/* Ratfor escape to fortran */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
operator|*
name|dbp
operator||
literal|' '
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"integer"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"real"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"logical"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"complex"
argument_list|)
operator|||
name|tail
argument_list|(
literal|"character"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|tail
argument_list|(
literal|"precision"
argument_list|)
condition|)
break|break;
continue|continue;
block|}
break|break;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
operator|*
name|dbp
operator||
literal|' '
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"function"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"subroutine"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"program"
argument_list|)
condition|)
block|{
name|getit
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tail
argument_list|(
literal|"procedure"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
return|return
operator|(
name|pfcnt
operator|)
return|;
block|}
end_block

begin_macro
name|tail
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|&
operator|~
literal|' '
operator|)
operator|==
operator|(
operator|(
operator|*
operator|(
name|dbp
operator|+
name|len
operator|)
operator|)
operator|&
operator|~
literal|' '
operator|)
condition|)
name|cp
operator|++
operator|,
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|dbp
operator|+=
name|len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|takeprec
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|!=
literal|'*'
condition|)
return|return;
name|dbp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
block|{
operator|--
name|dbp
expr_stmt|;
comment|/* force failure */
return|return;
block|}
do|do
name|dbp
operator|++
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
do|;
block|}
end_block

begin_macro
name|getit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|lbuf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
empty_stmt|;
operator|*
operator|--
name|cp
operator|=
literal|0
expr_stmt|;
comment|/* zap newline */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
operator|||
operator|!
name|isalpha
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
return|return;
for|for
control|(
name|cp
operator|=
name|dbp
operator|+
literal|1
init|;
operator|*
name|cp
operator|&&
operator|(
name|isalpha
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|;
name|cp
operator|++
control|)
continue|continue;
name|c
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|pfcnt
operator|++
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|savestr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|space
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
operator|(
name|space
operator|=
name|malloc
argument_list|(
call|(
name|u_int
call|)
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"ctags: no more space.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|strcpy
argument_list|(
name|space
argument_list|,
name|str
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lisp tag functions  * just look for (def or (DEF  */
end_comment

begin_macro
name|L_funcs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|special
decl_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|lbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
argument_list|,
name|inf
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|dbp
operator|=
name|lbuf
expr_stmt|;
if|if
condition|(
name|dbp
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
operator|(
name|dbp
index|[
literal|1
index|]
operator|==
literal|'D'
operator|||
name|dbp
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|2
index|]
operator|==
literal|'E'
operator|||
name|dbp
index|[
literal|2
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|3
index|]
operator|==
literal|'F'
operator|||
name|dbp
index|[
literal|3
index|]
operator|==
literal|'f'
operator|)
condition|)
block|{
name|dbp
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|striccmp
argument_list|(
name|dbp
argument_list|,
literal|"method"
argument_list|)
operator|==
literal|0
operator|||
name|striccmp
argument_list|(
name|dbp
argument_list|,
literal|"wrapper"
argument_list|)
operator|==
literal|0
operator|||
name|striccmp
argument_list|(
name|dbp
argument_list|,
literal|"whopper"
argument_list|)
operator|==
literal|0
condition|)
name|special
operator|=
name|YES
expr_stmt|;
else|else
name|special
operator|=
name|NO
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
operator|++
name|dbp
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
operator|++
name|dbp
expr_stmt|;
name|L_getit
argument_list|(
name|special
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|L_getit
argument_list|(
argument|special
argument_list|)
end_macro

begin_decl_stmt
name|int
name|special
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
name|c
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|lbuf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
empty_stmt|;
operator|*
operator|--
name|cp
operator|=
literal|0
expr_stmt|;
comment|/* zap newline */
if|if
condition|(
operator|!
operator|*
name|dbp
condition|)
return|return;
if|if
condition|(
name|special
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|index
argument_list|(
name|dbp
argument_list|,
literal|')'
argument_list|)
operator|)
condition|)
return|return;
for|for
control|(
init|;
name|cp
operator|>=
name|dbp
operator|&&
operator|*
name|cp
operator|!=
literal|':'
condition|;
operator|--
name|cp
control|)
empty_stmt|;
if|if
condition|(
name|cp
operator|<
name|dbp
condition|)
return|return;
name|dbp
operator|=
name|cp
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|')'
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|;
operator|++
name|cp
control|)
empty_stmt|;
block|}
else|else
for|for
control|(
name|cp
operator|=
name|dbp
operator|+
literal|1
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'('
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|;
name|cp
operator|++
control|)
empty_stmt|;
name|c
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
operator|++
name|pfcnt
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * striccmp:  *	Compare two strings over the length of the second, ignoring  *	case distinctions.  If they are the same, return 0.  If they  *	are different, return the difference of the first two different  *	characters.  It is assumed that the pattern (second string) is  *	completely lower case.  */
end_comment

begin_expr_stmt
name|striccmp
argument_list|(
name|str
argument_list|,
name|pat
argument_list|)
specifier|register
name|char
operator|*
name|str
operator|,
operator|*
name|pat
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c1
decl_stmt|;
while|while
condition|(
operator|*
name|pat
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|c1
operator|=
name|tolower
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
else|else
name|c1
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
operator|*
name|pat
condition|)
return|return
name|c1
operator|-
operator|*
name|pat
return|;
name|pat
operator|++
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * first_char --  *	return the next non-blank character in the file.  After finding  *	it, rewind the input file to the starting position.  */
end_comment

begin_macro
name|first_char
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|long
name|off
decl_stmt|;
name|off
operator|=
name|ftell
argument_list|(
name|inf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|!
name|iswhite
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|inf
argument_list|,
name|off
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|inf
argument_list|,
name|off
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * toss_yysec --  *	toss away code until the next "%%" line.  */
end_comment

begin_macro
name|toss_yysec
argument_list|()
end_macro

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|lineftell
operator|=
name|ftell
argument_list|(
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|inf
argument_list|)
condition|)
return|return;
operator|++
name|lineno
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"%%"
argument_list|,
literal|2
argument_list|)
condition|)
return|return;
block|}
block|}
end_block

end_unit

