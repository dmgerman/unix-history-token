begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ctags.c	4.2 (Berkeley) 10/3/80"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/*  * ctags  */
end_comment

begin_define
define|#
directive|define
name|reg
value|register
end_define

begin_define
define|#
directive|define
name|logical
value|char
end_define

begin_define
define|#
directive|define
name|TRUE
value|(1)
end_define

begin_define
define|#
directive|define
name|FALSE
value|(0)
end_define

begin_define
define|#
directive|define
name|iswhite
parameter_list|(
name|arg
parameter_list|)
value|(_wht[arg])
end_define

begin_comment
comment|/* T if char is white		*/
end_comment

begin_define
define|#
directive|define
name|begtoken
parameter_list|(
name|arg
parameter_list|)
value|(_btk[arg])
end_define

begin_comment
comment|/* T if char can start token	*/
end_comment

begin_define
define|#
directive|define
name|intoken
parameter_list|(
name|arg
parameter_list|)
value|(_itk[arg])
end_define

begin_comment
comment|/* T if char can be in token	*/
end_comment

begin_define
define|#
directive|define
name|endtoken
parameter_list|(
name|arg
parameter_list|)
value|(_etk[arg])
end_define

begin_comment
comment|/* T if char ends tokens	*/
end_comment

begin_define
define|#
directive|define
name|isgood
parameter_list|(
name|arg
parameter_list|)
value|(_gd[arg])
end_define

begin_comment
comment|/* T if char can be after ')'	*/
end_comment

begin_define
define|#
directive|define
name|max
parameter_list|(
name|I1
parameter_list|,
name|I2
parameter_list|)
value|(I1> I2 ? I1 : I2)
end_define

begin_struct
struct|struct
name|nd_st
block|{
comment|/* sorting structure			*/
name|char
modifier|*
name|func
decl_stmt|;
comment|/* function name		*/
name|char
modifier|*
name|file
decl_stmt|;
comment|/* file name			*/
name|int
name|lno
decl_stmt|;
comment|/* for -x option		*/
name|char
modifier|*
name|pat
decl_stmt|;
comment|/* search pattern		*/
name|logical
name|been_warned
decl_stmt|;
comment|/* set if noticed dup		*/
name|struct
name|nd_st
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
comment|/* left and right sons		*/
block|}
struct|;
end_struct

begin_function_decl
name|long
name|ftell
parameter_list|()
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|struct
name|nd_st
name|NODE
typedef|;
end_typedef

begin_decl_stmt
name|logical
name|number
decl_stmt|,
comment|/* T if on line starting with #	*/
name|term
init|=
name|FALSE
decl_stmt|,
comment|/* T if print on terminal	*/
name|makefile
init|=
name|TRUE
decl_stmt|,
comment|/* T if to creat "tags" file	*/
name|gotone
decl_stmt|,
comment|/* found a func already on line	*/
comment|/* boolean "func" (see init)	*/
name|_wht
index|[
literal|0177
index|]
decl_stmt|,
name|_etk
index|[
literal|0177
index|]
decl_stmt|,
name|_itk
index|[
literal|0177
index|]
decl_stmt|,
name|_btk
index|[
literal|0177
index|]
decl_stmt|,
name|_gd
index|[
literal|0177
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|searchar
init|=
literal|'?'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use ?...? searches 		*/
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number of current line */
end_comment

begin_decl_stmt
name|char
name|line
index|[
literal|4
operator|*
name|BUFSIZ
index|]
decl_stmt|,
comment|/* current input line			*/
modifier|*
name|curfile
decl_stmt|,
comment|/* current input file name		*/
modifier|*
name|outfile
init|=
literal|"tags"
decl_stmt|,
comment|/* output file				*/
modifier|*
name|white
init|=
literal|" \f\t\n"
decl_stmt|,
comment|/* white chars				*/
modifier|*
name|endtk
init|=
literal|" \t\n\"'#()[]{}=-+%*/&|^~!<>;,.:?"
decl_stmt|,
comment|/* token ending chars			*/
modifier|*
name|begtk
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
decl_stmt|,
comment|/* token starting chars			*/
modifier|*
name|intk
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz0123456789"
decl_stmt|,
comment|/* valid in-token chars			*/
modifier|*
name|notgd
init|=
literal|",;"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-valid after-function chars	*/
end_comment

begin_decl_stmt
name|int
name|file_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current file number			*/
end_comment

begin_decl_stmt
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -a: append to tags */
end_comment

begin_decl_stmt
name|int
name|uflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -u: update tags */
end_comment

begin_decl_stmt
name|int
name|wflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -w: suppress warnings */
end_comment

begin_decl_stmt
name|int
name|xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -x: create cxref style output */
end_comment

begin_decl_stmt
name|char
name|lbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|inf
decl_stmt|,
comment|/* ioptr for current input file		*/
modifier|*
name|outf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ioptr for tags file			*/
end_comment

begin_decl_stmt
name|long
name|lineftell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ftell after getc( inf ) == '\n' 	*/
end_comment

begin_decl_stmt
name|NODE
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the head of the sorted binary tree	*/
end_comment

begin_function_decl
name|char
modifier|*
name|savestr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
name|cmd
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|ac
operator|>
literal|1
operator|&&
name|av
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|av
index|[
literal|1
index|]
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|av
index|[
literal|1
index|]
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'a'
case|:
name|aflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|uflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xflag
operator|++
expr_stmt|;
break|break;
default|default:
goto|goto
name|usage
goto|;
block|}
block|}
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ac
operator|<=
literal|1
condition|)
block|{
name|usage
label|:
name|printf
argument_list|(
literal|"Usage: ctags [-au] file ...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|init
argument_list|()
expr_stmt|;
comment|/* set up boolean "functions"		*/
comment|/* 	 * loop through files finding functions 	 */
for|for
control|(
name|file_num
operator|=
literal|1
init|;
name|file_num
operator|<
name|ac
condition|;
name|file_num
operator|++
control|)
name|find_funcs
argument_list|(
name|av
index|[
name|file_num
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|xflag
condition|)
block|{
name|put_funcs
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uflag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"mv %s OTAGS;fgrep -v '\t%s\t' OTAGS>%s;rm OTAGS"
argument_list|,
name|outfile
argument_list|,
name|av
index|[
name|i
index|]
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|aflag
operator|++
expr_stmt|;
block|}
name|outf
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
name|aflag
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outf
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|put_funcs
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|outf
argument_list|)
expr_stmt|;
if|if
condition|(
name|uflag
condition|)
block|{
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"sort %s -o %s"
argument_list|,
name|outfile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine sets up the boolean psuedo-functions which work  * by seting boolean flags dependent upon the corresponding character  * Every char which is NOT in that string is not a white char.  Therefore,  * all of the array "_wht" is set to FALSE, and then the elements  * subscripted by the chars in "white" are set to TRUE.  Thus "_wht"  * of a char is TRUE if it is the string "white", else FALSE.  */
end_comment

begin_macro
name|init
argument_list|()
end_macro

begin_block
block|{
name|reg
name|char
modifier|*
name|sp
decl_stmt|;
name|reg
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0177
condition|;
name|i
operator|++
control|)
block|{
name|_wht
index|[
name|i
index|]
operator|=
name|_etk
index|[
name|i
index|]
operator|=
name|_itk
index|[
name|i
index|]
operator|=
name|_btk
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
name|_gd
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|white
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_wht
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|endtk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_etk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|intk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_itk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|begtk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_btk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|notgd
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_gd
index|[
operator|*
name|sp
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine opens the specified file and calls the function  * which finds the function definitions.  */
end_comment

begin_macro
name|find_funcs
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|inf
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
name|curfile
operator|=
name|savestr
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|!=
literal|'c'
operator|||
name|cp
index|[
literal|1
index|]
operator|!=
literal|'h'
operator|)
operator|&&
name|cp
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|PF_funcs
argument_list|(
name|inf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rewind
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|C_funcs
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|C_funcs
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pfnote
argument_list|(
argument|name
argument_list|,
argument|ln
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|fp
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|np
decl_stmt|;
name|char
name|nbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
operator|(
name|NODE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ctags: too many functions to sort\n"
argument_list|)
expr_stmt|;
name|put_funcs
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free_tree
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|np
operator|=
operator|(
name|NODE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xflag
operator|==
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
name|fp
operator|=
name|rindex
argument_list|(
name|curfile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
name|fp
operator|=
name|curfile
expr_stmt|;
else|else
name|fp
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"M%s"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|rindex
argument_list|(
name|nbuf
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|&&
name|fp
index|[
literal|2
index|]
operator|==
literal|0
condition|)
operator|*
name|fp
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|nbuf
expr_stmt|;
block|}
name|np
operator|->
name|func
operator|=
name|savestr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|np
operator|->
name|file
operator|=
name|curfile
expr_stmt|;
name|np
operator|->
name|lno
operator|=
name|ln
expr_stmt|;
name|np
operator|->
name|left
operator|=
name|np
operator|->
name|right
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xflag
operator|==
literal|0
condition|)
block|{
name|lbuf
index|[
literal|50
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|lbuf
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
name|lbuf
index|[
literal|50
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|np
operator|->
name|pat
operator|=
name|savestr
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|np
expr_stmt|;
else|else
name|add_node
argument_list|(
name|np
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine finds functions in C syntax and adds them  * to the list.  */
end_comment

begin_macro
name|C_funcs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|token
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|int
name|incomm
decl_stmt|,
name|inquote
decl_stmt|,
name|inchar
decl_stmt|,
name|midtoken
decl_stmt|,
name|level
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
name|char
name|tok
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|number
operator|=
name|gotone
operator|=
name|midtoken
operator|=
name|inquote
operator|=
name|inchar
operator|=
name|incomm
operator|=
name|FALSE
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|tp
operator|=
name|token
operator|=
name|line
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|sp
operator|=
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|inf
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|sp
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|=
literal|'\n'
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incomm
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
while|while
condition|(
operator|(
operator|*
operator|++
name|sp
operator|=
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
literal|'*'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|incomm
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inquote
condition|)
block|{
comment|/* 			 * Too dumb to know about \" not being magic, but 			 * they usually occur in pairs anyway. 			 */
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|inquote
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|inchar
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|inchar
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'"'
case|:
name|inquote
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'\''
case|:
name|inchar
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'/'
case|:
if|if
condition|(
operator|(
operator|*
operator|++
name|sp
operator|=
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
literal|'*'
condition|)
name|incomm
operator|=
name|TRUE
expr_stmt|;
else|else
name|ungetc
argument_list|(
operator|*
name|sp
argument_list|,
name|inf
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'#'
case|:
if|if
condition|(
name|sp
operator|==
name|line
condition|)
name|number
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'{'
case|:
name|level
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'}'
case|:
if|if
condition|(
name|sp
operator|==
name|line
condition|)
name|level
operator|=
literal|0
expr_stmt|;
comment|/* reset */
else|else
name|level
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|level
operator|&&
operator|!
name|inquote
operator|&&
operator|!
name|incomm
operator|&&
name|gotone
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|midtoken
condition|)
block|{
if|if
condition|(
name|endtoken
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|pfline
init|=
name|lineno
decl_stmt|;
if|if
condition|(
name|start_func
argument_list|(
operator|&
name|sp
argument_list|,
name|token
argument_list|,
name|tp
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|tok
argument_list|,
name|token
argument_list|,
name|tp
operator|-
name|token
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tok
index|[
name|tp
operator|-
name|token
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|getline
argument_list|()
expr_stmt|;
name|pfnote
argument_list|(
name|tok
argument_list|,
name|pfline
argument_list|)
expr_stmt|;
name|gotone
operator|=
name|TRUE
expr_stmt|;
block|}
name|midtoken
operator|=
name|FALSE
expr_stmt|;
name|token
operator|=
name|sp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intoken
argument_list|(
name|c
argument_list|)
condition|)
name|tp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|begtoken
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|token
operator|=
name|tp
operator|=
name|sp
expr_stmt|;
name|midtoken
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|sp
operator|>
operator|&
name|line
index|[
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
name|BUFSIZ
index|]
condition|)
block|{
name|tp
operator|=
name|token
operator|=
name|sp
operator|=
name|line
expr_stmt|;
name|lineftell
operator|=
name|ftell
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|number
operator|=
name|gotone
operator|=
name|midtoken
operator|=
name|inquote
operator|=
name|inchar
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	This routine  checks to see if the current token is  * at the start of a function.  It updates the input line  * so that the '(' will be in it when it returns.  */
end_comment

begin_macro
name|start_func
argument_list|(
argument|lp
argument_list|,
argument|token
argument_list|,
argument|tp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|lp
decl_stmt|,
modifier|*
name|token
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|char
name|c
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
specifier|static
name|logical
name|found
decl_stmt|;
name|logical
name|firsttok
decl_stmt|;
comment|/* T if have seen first token in ()'s */
name|int
name|bad
decl_stmt|;
name|sp
operator|=
operator|*
name|lp
expr_stmt|;
name|c
operator|=
operator|*
name|sp
expr_stmt|;
name|bad
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|number
condition|)
block|{
comment|/* space is not allowed in macro defs	*/
while|while
condition|(
name|iswhite
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
operator|++
name|sp
operator|=
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|>
operator|&
name|line
index|[
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
name|BUFSIZ
index|]
condition|)
goto|goto
name|ret
goto|;
block|}
block|}
comment|/* the following tries to make it so that a #define a b(c)	*/
comment|/* doesn't count as a define of b.				*/
block|}
else|else
block|{
name|logical
name|define
decl_stmt|;
name|define
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|tsp
operator|=
literal|"define"
init|;
operator|*
name|tsp
operator|&&
name|token
operator|<
name|tp
condition|;
name|tsp
operator|++
control|)
if|if
condition|(
operator|*
name|tsp
operator|!=
operator|*
name|token
operator|++
condition|)
block|{
name|define
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|define
condition|)
name|found
operator|=
literal|0
expr_stmt|;
else|else
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|found
operator|>=
literal|2
condition|)
block|{
name|gotone
operator|=
name|TRUE
expr_stmt|;
name|badone
label|:
name|bad
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
goto|goto
name|badone
goto|;
name|firsttok
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|(
operator|*
operator|++
name|sp
operator|=
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|>
operator|&
name|line
index|[
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
name|BUFSIZ
index|]
condition|)
goto|goto
name|ret
goto|;
block|}
comment|/* 		 * This line used to confuse ctags: 		 *	int	(*oldhup)(); 		 * This fixes it. A nonwhite char before the first 		 * token, other than a / (in case of a comment in there) 		 * makes this not a declaration. 		 */
if|if
condition|(
name|begtoken
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'/'
condition|)
name|firsttok
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|iswhite
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|firsttok
condition|)
goto|goto
name|badone
goto|;
block|}
while|while
condition|(
name|iswhite
argument_list|(
operator|*
operator|++
name|sp
operator|=
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|>
operator|&
name|line
index|[
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
name|BUFSIZ
index|]
condition|)
break|break;
block|}
name|ret
label|:
operator|*
name|lp
operator|=
operator|--
name|sp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|--
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|inf
argument_list|)
expr_stmt|;
return|return
operator|!
name|bad
operator|&&
name|isgood
argument_list|(
name|c
argument_list|)
return|;
block|}
end_block

begin_macro
name|getline
argument_list|()
end_macro

begin_block
block|{
name|long
name|saveftell
init|=
name|ftell
argument_list|(
name|inf
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|fseek
argument_list|(
name|inf
argument_list|,
name|lineftell
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|,
name|inf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|lbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|fseek
argument_list|(
name|inf
argument_list|,
name|saveftell
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|free_tree
argument_list|(
argument|node
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|node
condition|)
block|{
name|free_tree
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|add_node
argument_list|(
argument|node
argument_list|,
argument|cur_node
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|node
decl_stmt|,
modifier|*
name|cur_node
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|dif
decl_stmt|;
name|dif
operator|=
name|strcmp
argument_list|(
name|node
operator|->
name|func
argument_list|,
name|cur_node
operator|->
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|dif
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|file
operator|==
name|cur_node
operator|->
name|file
condition|)
block|{
if|if
condition|(
operator|!
name|wflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate function in file %s, line %d: %s\n"
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|lineno
argument_list|,
name|node
operator|->
name|func
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Second entry ignored\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|cur_node
operator|->
name|been_warned
condition|)
if|if
condition|(
operator|!
name|wflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate function in files %s and %s: %s (Warning only)\n"
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|cur_node
operator|->
name|file
argument_list|,
name|node
operator|->
name|func
argument_list|)
expr_stmt|;
name|cur_node
operator|->
name|been_warned
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dif
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|cur_node
operator|->
name|left
operator|!=
name|NULL
condition|)
name|add_node
argument_list|(
name|node
argument_list|,
name|cur_node
operator|->
name|left
argument_list|)
expr_stmt|;
else|else
name|cur_node
operator|->
name|left
operator|=
name|node
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_node
operator|->
name|right
operator|!=
name|NULL
condition|)
name|add_node
argument_list|(
name|node
argument_list|,
name|cur_node
operator|->
name|right
argument_list|)
expr_stmt|;
else|else
name|cur_node
operator|->
name|right
operator|=
name|node
expr_stmt|;
block|}
end_block

begin_macro
name|put_funcs
argument_list|(
argument|node
argument_list|)
end_macro

begin_decl_stmt
name|reg
name|NODE
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
name|put_funcs
argument_list|(
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|xflag
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%s\t%s\t%c^"
argument_list|,
name|node
operator|->
name|func
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|searchar
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|node
operator|->
name|pat
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
operator|*
name|sp
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%c\n"
argument_list|,
name|searchar
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%-16s%4d %-16s %s\n"
argument_list|,
name|node
operator|->
name|func
argument_list|,
name|node
operator|->
name|lno
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|node
operator|->
name|pat
argument_list|)
expr_stmt|;
name|put_funcs
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|dbp
init|=
name|lbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pfcnt
decl_stmt|;
end_decl_stmt

begin_macro
name|PF_funcs
argument_list|(
argument|fi
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fi
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lineno
operator|=
literal|0
expr_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|lbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
argument_list|,
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|dbp
operator|=
name|lbuf
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|'%'
condition|)
name|dbp
operator|++
expr_stmt|;
comment|/* Ratfor escape to fortran */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
operator|*
name|dbp
operator||
literal|' '
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"integer"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"real"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"logical"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"complex"
argument_list|)
operator|||
name|tail
argument_list|(
literal|"character"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|tail
argument_list|(
literal|"precision"
argument_list|)
condition|)
break|break;
continue|continue;
block|}
break|break;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
operator|*
name|dbp
operator||
literal|' '
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"function"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"subroutine"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"program"
argument_list|)
condition|)
block|{
name|getit
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tail
argument_list|(
literal|"procedure"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
return|return
operator|(
name|pfcnt
operator|)
return|;
block|}
end_block

begin_macro
name|tail
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|&
operator|~
literal|' '
operator|)
operator|==
operator|(
operator|(
operator|*
operator|(
name|dbp
operator|+
name|len
operator|)
operator|)
operator|&
operator|~
literal|' '
operator|)
condition|)
name|cp
operator|++
operator|,
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|dbp
operator|+=
name|len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|takeprec
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|!=
literal|'*'
condition|)
return|return;
name|dbp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
block|{
operator|--
name|dbp
expr_stmt|;
comment|/* force failure */
return|return;
block|}
do|do
name|dbp
operator|++
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
do|;
block|}
end_block

begin_macro
name|getit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|lbuf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
empty_stmt|;
operator|*
operator|--
name|cp
operator|=
literal|0
expr_stmt|;
comment|/* zap newline */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
operator|||
operator|!
name|isalpha
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
return|return;
for|for
control|(
name|cp
operator|=
name|dbp
operator|+
literal|1
init|;
operator|*
name|cp
operator|&&
operator|(
name|isalpha
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|;
name|cp
operator|++
control|)
continue|continue;
name|c
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|pfcnt
operator|++
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|savestr
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the ptr in sp at which the character c last  * appears; NULL if not found  *  * Identical to v7 rindex, included for portability.  */
end_comment

begin_function
name|char
modifier|*
name|rindex
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
name|c
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|NULL
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|c
condition|)
name|r
operator|=
name|sp
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|sp
operator|++
condition|)
do|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

end_unit

