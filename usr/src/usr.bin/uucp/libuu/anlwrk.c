begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1985, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This module is believed to contain source code proprietary to AT&T.  * Use and redistribution is subject to the Berkeley Software License  * Agreement and your Software Agreement with AT&T (Western Electric).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)anlwrk.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"uust.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NDIR
end_ifdef

begin_include
include|#
directive|include
file|"ndir.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|TLIMIT
value|(15*60L)
end_define

begin_define
define|#
directive|define
name|NITEMS
parameter_list|(
name|X
parameter_list|)
value|(sizeof (X) / sizeof ((X)[0]))
end_define

begin_decl_stmt
name|int
name|Nfiles
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Filent
index|[
name|LLEN
index|]
index|[
name|NAMESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|TransferSucceeded
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_comment
comment|/*  *	create a vector of command arguments  *  *	return codes:  *		0  -  no more work in this file  *		positive number  -  number of arguments  */
end_comment

begin_comment
comment|/* LOCAL only */
end_comment

begin_function
name|int
name|anlwrk
parameter_list|(
name|file
parameter_list|,
name|wvec
parameter_list|)
specifier|register
name|char
modifier|*
name|file
decl_stmt|,
decl|*
modifier|*
name|wvec
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
name|str
index|[
name|MAXRQST
index|]
decl_stmt|,
name|nstr
index|[
name|MAXRQST
index|]
decl_stmt|,
name|lastfile
index|[
name|MAXFULLNAME
index|]
init|=
literal|""
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
specifier|static
name|long
name|nextread
decl_stmt|,
name|nextwrite
decl_stmt|;
comment|/* 	 * If called with a null string, force a shutdown 	 * of the current work file. 	 */
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|file
argument_list|,
name|lastfile
argument_list|,
name|MAXFULLNAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"Workfilename repeated: %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|strncpy
argument_list|(
name|lastfile
argument_list|,
name|file
argument_list|,
name|MAXFULLNAME
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|subfile
argument_list|(
name|file
argument_list|)
argument_list|,
literal|"r+w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|bnp
decl_stmt|,
name|rqstr
index|[
name|MAXFULLNAME
index|]
decl_stmt|;
name|bnp
operator|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"%s/%s"
argument_list|,
name|CORRUPT
argument_list|,
name|bnp
condition|?
name|bnp
operator|+
literal|1
else|:
name|file
argument_list|)
expr_stmt|;
name|xmv
argument_list|(
name|file
argument_list|,
name|rqstr
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fopen(%s) failed: %m"
argument_list|,
name|subfile
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|subfile
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|Usrf
operator|=
literal|0
expr_stmt|;
name|nstr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nextread
operator|=
name|nextwrite
operator|=
literal|0L
expr_stmt|;
block|}
if|if
condition|(
name|nstr
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|TransferSucceeded
condition|)
block|{
name|fseek
argument_list|(
name|fp
argument_list|,
name|nextwrite
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|nstr
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp
argument_list|,
name|nextread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|nextwrite
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|str
argument_list|,
name|MAXRQST
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TransferSucceeded
condition|)
name|unlink
argument_list|(
name|subfile
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|USRF
argument_list|(
name|USR_COMP
argument_list|)
expr_stmt|;
name|US_RRS
argument_list|(
name|file
argument_list|,
name|Usrf
argument_list|)
expr_stmt|;
name|Usrf
operator|=
literal|0
expr_stmt|;
name|file
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nstr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
do|while
condition|(
operator|!
name|isupper
argument_list|(
name|str
index|[
literal|0
index|]
argument_list|)
condition|)
do|;
name|nextread
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|nstr
argument_list|,
name|str
argument_list|,
name|MAXRQST
argument_list|)
expr_stmt|;
name|nstr
index|[
literal|0
index|]
operator|=
name|tolower
argument_list|(
name|nstr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|getargs
argument_list|(
name|str
argument_list|,
name|wvec
argument_list|,
literal|20
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  *	build list of work files for given system  *  *	return value - 1 if work was found, else 0  *  */
end_comment

begin_comment
comment|/* LOCAL only */
end_comment

begin_function
name|int
name|bldflst
parameter_list|(
name|reqst
parameter_list|,
name|dir
parameter_list|,
name|pre
parameter_list|)
name|char
modifier|*
name|reqst
decl_stmt|;
specifier|register
name|char
modifier|*
name|dir
decl_stmt|,
decl|*
name|pre
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|DIR
modifier|*
name|dirp
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dentp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|plen
init|=
name|strlen
argument_list|(
name|pre
argument_list|)
decl_stmt|;
specifier|extern
name|char
name|MaxGrade
decl_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|subdir
argument_list|(
name|dir
argument_list|,
name|pre
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
literal|"opendir(%s) FAILS\n"
argument_list|,
name|subdir
argument_list|(
name|dir
argument_list|,
name|pre
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
name|rewinddir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|Nfiles
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dentp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|Nfiles
operator|<
name|LLEN
condition|)
block|{
comment|/* Check for two systems with the same prefix. 		 * Magic number "5" is 1 for "grade" character plus 		 * 4 for sequence number.  The point here is to not 		 * send work for a system which has as a prefix the 		 * name of the system called for. 		 * Special case: prefix "X." does not do this check 		 * so uuxqt can use bldflst. 		 */
if|if
condition|(
operator|!
name|prefix
argument_list|(
name|pre
argument_list|,
name|dentp
operator|->
name|d_name
argument_list|)
operator|||
operator|(
name|plen
operator|!=
literal|2
operator|&&
operator|(
name|dentp
operator|->
name|d_namlen
operator|-
name|plen
operator|)
operator|!=
literal|5
operator|)
condition|)
block|{
name|DEBUG
argument_list|(
literal|99
argument_list|,
literal|"bldflst rejects %s\n"
argument_list|,
name|dentp
operator|->
name|d_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dentp
operator|->
name|d_name
index|[
name|dentp
operator|->
name|d_namlen
operator|-
literal|5
index|]
operator|>
name|MaxGrade
condition|)
block|{
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"bldflst rejects %s, grade too low\n"
argument_list|,
name|dentp
operator|->
name|d_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|reqst
operator|==
literal|'c'
condition|)
return|return
literal|1
return|;
comment|/* locate position for the new file and make room for it */
for|for
control|(
name|i
operator|=
name|Nfiles
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|pcompar
argument_list|(
name|dentp
operator|->
name|d_name
argument_list|,
name|Filent
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|LLEN
condition|)
name|strcpy
argument_list|(
name|Filent
index|[
name|i
index|]
argument_list|,
name|Filent
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* add new file (if there is room), and increase Nfiles if need be */
if|if
condition|(
name|i
operator|<
name|LLEN
condition|)
block|{
name|DEBUG
argument_list|(
literal|99
argument_list|,
literal|"bldflst accepts %s"
argument_list|,
name|dentp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|99
argument_list|,
literal|" as Filent[%d]\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Filent
index|[
name|i
index|]
argument_list|,
name|dentp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nfiles
operator|<
name|LLEN
condition|)
name|Nfiles
operator|++
expr_stmt|;
block|}
else|else
name|DEBUG
argument_list|(
literal|99
argument_list|,
literal|"Filent full, %s rejected by bldflst\n"
argument_list|,
name|dentp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Debug
operator|>
literal|99
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Nfiles
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Filent[%d]=%s\n"
argument_list|,
name|i
argument_list|,
name|Filent
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|Nfiles
operator|>
literal|0
return|;
block|}
end_block

begin_comment
comment|/*   Compare priority of filenames p1 and p2.  Return:  *< 0	if p1 "has lower priority than" p2.  *	= 0	if p1 "has priority equal to" p2.  *> 0	if p1 "has greater priority than" p2.  * Priority:  *	lower grade wins.  *	lower sequence number wins (unless wrap-around is suspected).  *  */
end_comment

begin_comment
comment|/* LOCAL only */
end_comment

begin_expr_stmt
name|pcompar
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
specifier|register
name|char
operator|*
name|p1
operator|,
operator|*
name|p2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|rc
decl_stmt|;
comment|/* strlen(p1) and strlen(p2) are>= 5 */
name|p1
operator|+=
name|strlen
argument_list|(
name|p1
argument_list|)
operator|-
literal|5
expr_stmt|;
name|p2
operator|+=
name|strlen
argument_list|(
name|p2
argument_list|)
operator|-
literal|5
expr_stmt|;
comment|/* check 'grade' */
if|if
condition|(
name|rc
operator|=
operator|*
name|p2
operator|++
operator|-
operator|*
name|p1
operator|++
condition|)
return|return
name|rc
return|;
comment|/* check for  sequence wrap-around */
if|if
condition|(
name|rc
operator|=
operator|*
name|p2
operator|++
operator|-
operator|*
name|p1
operator|++
condition|)
if|if
condition|(
name|rc
operator|<
operator|-
literal|10
operator|||
name|rc
operator|>
literal|10
condition|)
return|return
operator|-
name|rc
return|;
else|else
return|return
name|rc
return|;
comment|/* check remaining digits */
return|return
name|strcmp
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  *	get work vector  *  *	return codes:  *		positive number  -  number of arguments  *		0 -  no arguments - fail  */
end_comment

begin_comment
comment|/* EXTERNALLY CALLED */
end_comment

begin_function
name|int
name|gtwvec
parameter_list|(
name|file
parameter_list|,
name|dir
parameter_list|,
name|wkpre
parameter_list|,
name|wrkvec
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|,
decl|*
name|wkpre
decl_stmt|,
modifier|*
modifier|*
name|wrkvec
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nargs
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|nargs
operator|=
name|anlwrk
argument_list|(
name|file
argument_list|,
name|wrkvec
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|n
operator|>
literal|3
operator|||
operator|!
name|iswrk
argument_list|(
name|file
argument_list|,
literal|"get"
argument_list|,
name|dir
argument_list|,
name|wkpre
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
name|nargs
return|;
block|}
end_block

begin_comment
comment|/*  *	iswrk  -  this routine will check the work list (list).  *	If it is empty or the present work is exhausted, it  *	will call bldflst to generate a new list.  *	The "reqst" field will be the string "chk" or "get" to  *	check for work, or get the next work file respectively.  *  *	return codes:  *		0  -  no more work (or some error)  *		1  -  there is work  *  */
end_comment

begin_comment
comment|/* EXTERNALLY CALLED */
end_comment

begin_function
name|int
name|iswrk
parameter_list|(
name|file
parameter_list|,
name|reqst
parameter_list|,
name|dir
parameter_list|,
name|pre
parameter_list|)
specifier|register
name|char
modifier|*
name|file
decl_stmt|,
decl|*
name|reqst
decl_stmt|,
modifier|*
name|dir
decl_stmt|,
modifier|*
name|pre
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
modifier|*
name|lastpre
init|=
literal|0
decl_stmt|;
specifier|register
name|ret
operator|=
literal|0
expr_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Starting new system; re-init */
if|if
condition|(
name|lastpre
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|lastpre
argument_list|,
name|pre
argument_list|)
operator|!=
name|SAME
condition|)
block|{
comment|/* Force close of work file */
name|anlwrk
argument_list|(
literal|""
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Save last worked-on prefix */
if|if
condition|(
name|lastpre
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|lastpre
argument_list|)
expr_stmt|;
name|lastpre
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|pre
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lastpre
argument_list|,
name|pre
argument_list|)
expr_stmt|;
comment|/* Set the external indexes properly */
name|Nfiles
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If the list is empty or new files have entered 	 * the spool area, call "bldflst" to read 	 * some file names into it.  	 */
if|if
condition|(
name|Nfiles
operator|<=
literal|0
operator|||
name|newspool
argument_list|(
operator|(
name|time_t
operator|)
name|TLIMIT
argument_list|)
condition|)
block|{
name|ret
operator|=
name|bldflst
argument_list|(
name|reqst
argument_list|,
name|dir
argument_list|,
name|pre
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|99
argument_list|,
literal|"bldflst returns %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/* If they only wanted to check, return 	 * boolean list not empty.  NB: the list 	 * will be forcibly emptied as soon as 	 * a new system name is mentioned. 	 */
if|if
condition|(
operator|*
name|reqst
operator|==
literal|'c'
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|Nfiles
operator|--
operator|<=
literal|0
condition|)
block|{
comment|/* Didn't find any files in the spool area */
name|Nfiles
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Found some files, return the first one */
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|Filent
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Nfiles
condition|;
name|i
operator|++
control|)
name|strcpy
argument_list|(
name|Filent
index|[
name|i
index|]
argument_list|,
name|Filent
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Return non-zero if there is new work in the spool  * area since last check.  Assumes that if the sequence  * file has been modified, there is new work. This is  * not absolutely correct, but should be close enough.  * Only checks every<limit> seconds at most.  Called  * from "iswrk()" when a new work file is requested.  */
end_comment

begin_comment
comment|/* LOCAL only */
end_comment

begin_function
name|int
name|newspool
parameter_list|(
name|limit
parameter_list|)
name|time_t
name|limit
decl_stmt|;
block|{
specifier|static
name|time_t
name|lastcheck
init|=
literal|0
decl_stmt|,
name|lastmod
init|=
literal|0
decl_stmt|;
name|time_t
name|check
decl_stmt|;
name|struct
name|stat
name|mod
decl_stmt|;
specifier|register
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* (void) */
name|time
argument_list|(
operator|&
name|check
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|-
name|lastcheck
operator|>
name|limit
operator|||
name|lastcheck
operator|-
name|check
operator|>
name|limit
condition|)
block|{
name|mod
operator|.
name|st_mtime
operator|=
literal|0
expr_stmt|;
comment|/* (void) */
name|stat
argument_list|(
name|SEQFILE
argument_list|,
operator|&
name|mod
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod
operator|.
name|st_mtime
operator|!=
name|lastmod
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|lastmod
operator|=
name|mod
operator|.
name|st_mtime
expr_stmt|;
block|}
name|lastcheck
operator|=
name|check
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

