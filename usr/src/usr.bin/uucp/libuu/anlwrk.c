begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)anlwrk.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NDIR
end_ifdef

begin_include
include|#
directive|include
file|"ndir.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Re-written to be reasonable  * Mon Nov 15 17:19:52 EST 1982  * Alan S. Watt (ittvax!swatt)  *  * Tom Truscott (rti!trt):  * Priority ordering cleaned up.  New 'pcompar' subroutine.  * 'stat' removed (speeds things up).  * Possible infinite loop in gtwvec defended against.  * Feb 23, 1983  *  * Changes:  *  *  1)	The check for work is much faster; the first filename  *	that matches the prefix causes a "yes" return.  *  *  2)	The filename is not "stat" ed , so  *	there is no massive delay while the list of potential  *	names is built.  *  *  3)	Requesting work for a new system is now detected so  *	internal variables are re-initialized properly.  In  *	particular, the stream pointer for the current work  *	file is properly closed so work for a system which  *	hangs up will not be sent to the next system called.  *  * Fri Dec  3 09:31:45 EST 1982  *  *  5)	As new work files are requested, a check is made  *	every TLIMIT seconds (5 minutes at present) to see  *	if new files have entered the spool area.  Since  *	work file names are now cached up to LLEN, this can  *	represent a very long transmission time before new  *	work enters the list to be processed.  If people want  *	to use the "grade" character to specify a higher  *	priority, the list must be re-built and re-sorted for  *	higher priority stuff to have an immediate effect.  */
end_comment

begin_define
define|#
directive|define
name|LLEN
value|20
end_define

begin_define
define|#
directive|define
name|MAXRQST
value|250
end_define

begin_define
define|#
directive|define
name|TLIMIT
value|(5*60L)
end_define

begin_define
define|#
directive|define
name|NITEMS
parameter_list|(
name|X
parameter_list|)
value|(sizeof (X) / sizeof ((X)[0]))
end_define

begin_comment
comment|/* These are all used only locally  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Nfiles
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Filent
index|[
name|LLEN
index|]
index|[
name|NAMESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******  *	anlwrk(file, wvec)	create a vector of command arguments  *	char *file, **wvec;  *  *	return codes:  *		0  -  no more work in this file  *		positive number  -  number of arguments  */
end_comment

begin_comment
comment|/* LOCAL only */
end_comment

begin_function
name|int
name|anlwrk
parameter_list|(
name|file
parameter_list|,
name|wvec
parameter_list|)
specifier|register
name|char
modifier|*
name|file
decl_stmt|,
decl|*
modifier|*
name|wvec
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
name|str
index|[
name|MAXRQST
index|]
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
comment|/* If called with a null string, force a shutdown 	 * of the current work file. 	 * John Levine, ima.247, related change in cntl.c 	 */
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|subfile
argument_list|(
name|file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|unlink
argument_list|(
name|subfile
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to zap the thing. rti!trt */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* This is what deletes the current work file when EOF 	 * is reached.  As this is called from gtwvec, which is 	 * in turn called externally, it is not possible to save 	 * "C." files in case of error, except for line errors, 	 * which shuts down the whole system. 	 */
if|if
condition|(
name|fgets
argument_list|(
name|str
argument_list|,
name|MAXRQST
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|subfile
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|file
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|getargs
argument_list|(
name|str
argument_list|,
name|wvec
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	bldflst - build list of work files for given system  *	 Nfiles, Filent are global  *  *	return value - 1 if work was found, else 0  *  * Jul 26 19:17 1982 (ittvax!swatt). fixed this obnoxious  * routine to NOT read all the way through the damned directory  * "stat"'ing every file in sight just to get 10 names!!!  *  * It still reads through the directory from the beginning until  * the list is filled, but this is only once every LLEN names.  */
end_comment

begin_comment
comment|/* LOCAL only */
end_comment

begin_function
name|int
name|bldflst
parameter_list|(
name|reqst
parameter_list|,
name|dir
parameter_list|,
name|pre
parameter_list|)
name|char
modifier|*
name|reqst
decl_stmt|;
specifier|register
name|char
modifier|*
name|dir
decl_stmt|,
decl|*
name|pre
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|DIR
modifier|*
name|dirp
init|=
name|NULL
decl_stmt|;
specifier|register
name|nfound
expr_stmt|;
name|char
name|filename
index|[
name|NAMESIZE
index|]
decl_stmt|;
comment|/* @@@ NB: this needs new dir stuff */
name|int
name|plen
init|=
name|strlen
argument_list|(
name|pre
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|subdir
argument_list|(
name|dir
argument_list|,
name|pre
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|rewinddir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
for|for
control|(
name|nfound
operator|=
literal|0
operator|,
name|Nfiles
operator|=
literal|0
init|;
name|gnamef
argument_list|(
name|dirp
argument_list|,
name|filename
argument_list|)
condition|;
control|)
block|{
comment|/* Check for two systems with the same prefix. 		 * Magic number "5" is 1 for "grade" character plus 		 * 4 for sequence number.  The point here is to not 		 * send work for a system which has as a prefix the 		 * name of the system called for. 		 * Special case: prefix "X." does not do this check 		 * so uuxqt can use bldflst. 		 */
if|if
condition|(
operator|!
name|prefix
argument_list|(
name|pre
argument_list|,
name|filename
argument_list|)
operator|||
operator|(
name|plen
operator|!=
literal|2
operator|&&
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
name|plen
operator|!=
literal|5
operator|)
condition|)
continue|continue;
name|nfound
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|reqst
operator|==
literal|'c'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|entflst
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nfound
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	entflst - put new name if list is not full  *		  or new name is less than the MAX  *		  now in the list.  *	Nfiles, Filent[] are modified.  *	return value - none  *  */
end_comment

begin_comment
comment|/* LOCAL only */
end_comment

begin_function
name|int
name|entflst
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If there is room in the table, just add it. */
if|if
condition|(
name|Nfiles
operator|<
name|LLEN
condition|)
block|{
name|strcpy
argument_list|(
name|Filent
index|[
name|Nfiles
operator|++
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find lowest priority file in table  */
name|p
operator|=
name|Filent
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|Nfiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pcompar
argument_list|(
name|Filent
index|[
name|i
index|]
argument_list|,
name|p
argument_list|)
operator|<
literal|0
condition|)
name|p
operator|=
name|Filent
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * If new candidate is of higher priority 	 * that the lowest priority file in the table, 	 * replace the table entry. 	 */
if|if
condition|(
name|pcompar
argument_list|(
name|p
argument_list|,
name|file
argument_list|)
operator|<
literal|0
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   Compare priority of filenames p1 and p2.  Return:  *< 0	if p1 "has lower priority than" p2.  *	= 0	if p1 "has priority equal to" p2.  *> 0	if p1 "has greater priority than" p2.  * Priority:  *	lower grade wins.  *	lower sequence number wins (unless wrap-around is suspected).  *  */
end_comment

begin_comment
comment|/* LOCAL only */
end_comment

begin_function
name|int
name|pcompar
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|rc
decl_stmt|;
comment|/* assert: strlen(p1) and strlen(p2) are>= 5 */
name|p1
operator|+=
name|strlen
argument_list|(
name|p1
argument_list|)
operator|-
literal|5
expr_stmt|;
name|p2
operator|+=
name|strlen
argument_list|(
name|p2
argument_list|)
operator|-
literal|5
expr_stmt|;
comment|/* check 'grade' */
if|if
condition|(
name|rc
operator|=
operator|*
name|p2
operator|++
operator|-
operator|*
name|p1
operator|++
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* check for  sequence wrap-around */
if|if
condition|(
name|rc
operator|=
operator|*
name|p2
operator|++
operator|-
operator|*
name|p1
operator|++
condition|)
if|if
condition|(
name|rc
operator|<
operator|-
literal|10
operator|||
name|rc
operator|>
literal|10
condition|)
return|return
operator|(
operator|-
name|rc
operator|)
return|;
else|else
return|return
operator|(
name|rc
operator|)
return|;
comment|/* check remaining digits */
return|return
operator|(
name|strcmp
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	gtwrkf - get next work file  *	 Nfiles, Filent[] are modified.  *  *	return value:  *  *		0  - No file gotten  *		1  - File successfully gotten.  *  */
end_comment

begin_comment
comment|/* LOCAL only */
end_comment

begin_macro
name|gtwrkf
argument_list|(
argument|dir
argument_list|,
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Nfiles
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Find highest priority file in table */
name|p
operator|=
name|Filent
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|Nfiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pcompar
argument_list|(
name|Filent
index|[
name|i
index|]
argument_list|,
name|p
argument_list|)
operator|>
literal|0
condition|)
name|p
operator|=
name|Filent
index|[
name|i
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|Filent
index|[
operator|--
name|Nfiles
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	gtwvec(file, dir, wkpre, wrkvec)	get work vector   *	char *file, *dir, *wkpre, **wrkvec;  *  *	return codes:  *		positive number  -  number of arguments  *		0 -  no arguments - fail  */
end_comment

begin_comment
comment|/* EXTERNALLY CALLED */
end_comment

begin_function
name|int
name|gtwvec
parameter_list|(
name|file
parameter_list|,
name|dir
parameter_list|,
name|wkpre
parameter_list|,
name|wrkvec
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|,
decl|*
name|wkpre
decl_stmt|,
modifier|*
modifier|*
name|wrkvec
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nargs
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
comment|/* Break possible infinite loop.  rti!trt */
while|while
condition|(
operator|(
name|nargs
operator|=
name|anlwrk
argument_list|(
name|file
argument_list|,
name|wrkvec
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|n
operator|>
literal|3
operator|||
operator|!
name|iswrk
argument_list|(
name|file
argument_list|,
literal|"get"
argument_list|,
name|dir
argument_list|,
name|wkpre
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|nargs
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	iswrk(file, reqst, dir, pre)  *	char *file, *reqst, *dir, *pre;  *  *	iswrk  -  this routine will check the work list (list).  *	If it is empty or the present work is exhausted, it  *	will call bldflst to generate a new list.  *	The "reqst" field will be the string "chk" or "get" to  *	check for work, or get the next work file respectively.  *  *	return codes:  *		0  -  no more work (or some error)  *		1  -  there is work  *  */
end_comment

begin_comment
comment|/* EXTERNALLY CALLED */
end_comment

begin_function
name|int
name|iswrk
parameter_list|(
name|file
parameter_list|,
name|reqst
parameter_list|,
name|dir
parameter_list|,
name|pre
parameter_list|)
specifier|register
name|char
modifier|*
name|file
decl_stmt|,
decl|*
name|reqst
decl_stmt|,
modifier|*
name|dir
decl_stmt|,
modifier|*
name|pre
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
modifier|*
name|lastpre
init|=
literal|0
decl_stmt|;
specifier|register
name|ret
expr_stmt|;
comment|/* Starting new system; re-init */
if|if
condition|(
name|lastpre
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|lastpre
argument_list|,
name|pre
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|anlwrk
argument_list|(
literal|""
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Force close of work file */
comment|/* Save last worked-on prefix */
if|if
condition|(
name|lastpre
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|lastpre
argument_list|)
expr_stmt|;
name|lastpre
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|pre
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lastpre
argument_list|,
name|pre
argument_list|)
expr_stmt|;
comment|/* Set the external indexes properly 		 */
name|Nfiles
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If the list is empty or new files have entered 	 * the spool area, call "bldflst" to read 	 * some file names into it.  Because names can 	 * be put in the list that later turn out to 	 * be unusable (from "gtwrkf"), this operation 	 * continues until either "bldflst" can't find 	 * any new files, or "gtwrkf" signals success. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Nfiles
operator|==
literal|0
operator|||
name|newspool
argument_list|(
operator|(
name|time_t
operator|)
name|TLIMIT
argument_list|)
condition|)
name|ret
operator|=
name|bldflst
argument_list|(
name|reqst
argument_list|,
name|dir
argument_list|,
name|pre
argument_list|)
expr_stmt|;
comment|/* If they only wanted to check, return 		 * boolean list not empty.  NB: the list 		 * will be forcibly emptied as soon as 		 * a new system name is mentioned. 		 */
if|if
condition|(
operator|*
name|reqst
operator|==
literal|'c'
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|Nfiles
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|gtwrkf
argument_list|(
name|dir
argument_list|,
name|file
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* Return non-zero if there is new work in the spool  * area since last check.  Assumes that if the sequence  * file has been modified, there is new work. This is  * not absolutely correct, but should be close enough.  * Only checks every<limit> seconds at most.  Called  * from "iswrk()" when a new work file is requested.  */
end_comment

begin_comment
comment|/* LOCAL only */
end_comment

begin_function
name|int
name|newspool
parameter_list|(
name|limit
parameter_list|)
name|time_t
name|limit
decl_stmt|;
block|{
specifier|static
name|time_t
name|lastcheck
init|=
literal|0
decl_stmt|,
name|lastmod
init|=
literal|0
decl_stmt|;
name|time_t
name|check
decl_stmt|;
name|struct
name|stat
name|mod
decl_stmt|;
specifier|register
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* (void) */
name|time
argument_list|(
operator|&
name|check
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|-
name|lastcheck
operator|>
name|limit
operator|||
name|lastcheck
operator|-
name|check
operator|>
name|limit
condition|)
block|{
name|mod
operator|.
name|st_mtime
operator|=
literal|0
expr_stmt|;
comment|/* (void) */
name|stat
argument_list|(
name|SEQFILE
argument_list|,
operator|&
name|mod
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod
operator|.
name|st_mtime
operator|!=
name|lastmod
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|lastmod
operator|=
name|mod
operator|.
name|st_mtime
expr_stmt|;
block|}
name|lastcheck
operator|=
name|check
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

