begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pk1.c	4.2	(Berkeley)	12/31/82"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USER
value|1
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"pk.p"
end_include

begin_include
include|#
directive|include
file|"pk.h"
end_include

begin_define
define|#
directive|define
name|PKTIME
value|10
end_define

begin_decl_stmt
name|int
name|Errorrate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Conbad
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Ntimeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CONBAD
value|5
end_define

begin_define
define|#
directive|define
name|NTIMEOUT
value|50
end_define

begin_comment
comment|/*  * packet driver support routines  *  */
end_comment

begin_decl_stmt
name|struct
name|pack
modifier|*
name|pklines
index|[
name|NPLINES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * start initial synchronization.  */
end_comment

begin_function
name|struct
name|pack
modifier|*
name|pkopen
parameter_list|(
name|ifn
parameter_list|,
name|ofn
parameter_list|)
name|int
name|ifn
decl_stmt|,
name|ofn
decl_stmt|;
block|{
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|++
name|pkactive
operator|>=
name|NPLINES
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|pk
operator|=
operator|(
expr|struct
name|pack
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pack
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|pkzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|pk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pack
argument_list|)
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_ifn
operator|=
name|ifn
expr_stmt|;
name|pk
operator|->
name|p_ofn
operator|=
name|ofn
expr_stmt|;
name|pk
operator|->
name|p_xsize
operator|=
name|pk
operator|->
name|p_rsize
operator|=
name|PACKSIZE
expr_stmt|;
name|pk
operator|->
name|p_rwindow
operator|=
name|pk
operator|->
name|p_swindow
operator|=
name|WINDOWS
expr_stmt|;
comment|/*  allocate input windows */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pk
operator|->
name|p_rwindow
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|GETEPACK
operator|)
operator|==
name|NULL
condition|)
break|break;
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|pk
operator|->
name|p_rwindow
operator|=
name|i
expr_stmt|;
comment|/* start synchronization */
name|pk
operator|->
name|p_msg
operator|=
name|pk
operator|->
name|p_rmsg
operator|=
name|M_INITA
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPLINES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pklines
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|pklines
index|[
name|i
index|]
operator|=
name|pk
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|NPLINES
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|LIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|PKGETPKT
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
name|pkreset
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
operator|(
name|pk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * input framing and block checking.  * frame layout for most devices is:  *	  *	S|K|X|Y|C|Z|  ... data ... |  *  *	where 	S	== initial synch byte  *		K	== encoded frame size (indexes pksizes[])  *		X, Y	== block check bytes  *		C	== control byte  *		Z	== XOR of header (K^X^Y^C)  *		data	== 0 or more data bytes  *  */
end_comment

begin_decl_stmt
name|int
name|pksizes
index|[]
init|=
block|{
literal|1
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|,
literal|256
block|,
literal|512
block|,
literal|1024
block|,
literal|2048
block|,
literal|4096
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GETRIES
value|10
end_define

begin_comment
comment|/*  * Pseudo-dma byte collection.  */
end_comment

begin_macro
name|pkgetpack
argument_list|(
argument|ipk
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pack
modifier|*
name|ipk
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ret
decl_stmt|,
name|k
decl_stmt|,
name|tries
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
name|struct
name|header
modifier|*
name|h
decl_stmt|;
name|unsigned
name|short
name|sum
decl_stmt|;
name|int
name|ifn
decl_stmt|;
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
name|char
name|hdchk
decl_stmt|;
if|if
condition|(
name|Conbad
operator|>
name|CONBAD
comment|/* || Ntimeout> NTIMEOUT */
condition|)
name|pkfail
argument_list|()
expr_stmt|;
name|pk
operator|=
name|PADDR
expr_stmt|;
name|ifn
operator|=
name|pk
operator|->
name|p_ifn
expr_stmt|;
comment|/* find HEADER */
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
name|GETRIES
condition|;
control|)
block|{
name|p
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|pk
operator|->
name|p_ihbuf
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|pkcget
argument_list|(
name|ifn
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* set up retransmit or REJ */
name|tries
operator|++
expr_stmt|;
name|pk
operator|->
name|p_msg
operator||=
name|pk
operator|->
name|p_rmsg
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_msg
operator|==
literal|0
condition|)
name|pk
operator|->
name|p_msg
operator||=
name|M_RR
expr_stmt|;
if|if
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|LIVE
operator|)
operator|==
name|LIVE
condition|)
name|pk
operator|->
name|p_state
operator||=
name|RXMIT
expr_stmt|;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
name|SYN
condition|)
continue|continue;
name|p
operator|++
expr_stmt|;
name|ret
operator|=
name|pkcget
argument_list|(
name|ifn
argument_list|,
name|p
argument_list|,
name|HDRSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|tries
operator|>=
name|GETRIES
condition|)
block|{
name|PKDEBUG
argument_list|(
literal|4
argument_list|,
literal|"tries = %d\n"
argument_list|,
name|tries
argument_list|)
expr_stmt|;
name|pkfail
argument_list|()
expr_stmt|;
block|}
name|h
operator|=
operator|(
expr|struct
name|header
operator|*
operator|)
operator|&
name|pk
operator|->
name|p_ihbuf
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|h
expr_stmt|;
name|hdchk
operator|=
name|p
index|[
literal|1
index|]
operator|^
name|p
index|[
literal|2
index|]
operator|^
name|p
index|[
literal|3
index|]
operator|^
name|p
index|[
literal|4
index|]
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|sum
operator|=
operator|(
name|unsigned
operator|)
operator|*
name|p
operator|++
operator|&
literal|0377
expr_stmt|;
name|sum
operator||=
operator|(
name|unsigned
operator|)
operator|*
name|p
operator|<<
literal|8
expr_stmt|;
name|h
operator|->
name|sum
operator|=
name|sum
expr_stmt|;
name|PKDEBUG
argument_list|(
literal|7
argument_list|,
literal|"rec h->cntl %o\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|h
operator|->
name|cntl
argument_list|)
expr_stmt|;
name|k
operator|=
name|h
operator|->
name|ksize
expr_stmt|;
if|if
condition|(
name|hdchk
operator|!=
name|h
operator|->
name|ccntl
condition|)
block|{
comment|/* bad header */
name|PKDEBUG
argument_list|(
literal|7
argument_list|,
literal|"bad header %o,"
argument_list|,
name|hdchk
argument_list|)
expr_stmt|;
name|PKDEBUG
argument_list|(
literal|7
argument_list|,
literal|"h->ccntl %o\n"
argument_list|,
name|h
operator|->
name|ccntl
argument_list|)
expr_stmt|;
name|Conbad
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|==
literal|9
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|sum
operator|+
name|h
operator|->
name|cntl
operator|==
name|CHECK
condition|)
block|{
name|pkcntl
argument_list|(
name|h
operator|->
name|cntl
argument_list|,
name|pk
argument_list|)
expr_stmt|;
name|Conbad
operator|=
literal|0
expr_stmt|;
name|PKDEBUG
argument_list|(
literal|7
argument_list|,
literal|"state - %o\n"
argument_list|,
name|pk
operator|->
name|p_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  bad header */
name|Conbad
operator|++
expr_stmt|;
name|PKDEBUG
argument_list|(
literal|7
argument_list|,
literal|"bad header %o\n"
argument_list|,
name|h
operator|->
name|cntl
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_state
operator||=
name|BADFRAME
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|k
operator|&&
name|pksizes
index|[
name|k
index|]
operator|==
name|pk
operator|->
name|p_rsize
condition|)
block|{
name|pk
operator|->
name|p_rpr
operator|=
name|h
operator|->
name|cntl
operator|&
name|MOD8
expr_stmt|;
name|pksack
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|Conbad
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|*
name|bp
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|PKDEBUG
argument_list|(
literal|7
argument_list|,
literal|"bp NULL %s\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|Conbad
operator|++
expr_stmt|;
return|return;
block|}
name|ret
operator|=
name|pkcget
argument_list|(
name|pk
operator|->
name|p_ifn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|,
name|pk
operator|->
name|p_rsize
argument_list|)
expr_stmt|;
name|PKASSERT
argument_list|(
name|ret
operator|!=
operator|-
literal|1
argument_list|,
literal|"PKGETPKT CAN't READ %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|pkdata
argument_list|(
name|h
operator|->
name|cntl
argument_list|,
name|h
operator|->
name|sum
argument_list|,
name|pk
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|pkdata
argument_list|(
argument|c
argument_list|,
argument|sum
argument_list|,
argument|pk
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|sum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|x
expr_stmt|;
name|int
name|t
decl_stmt|;
name|char
name|m
decl_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|DRAINO
operator|||
operator|!
operator|(
name|pk
operator|->
name|p_state
operator|&
name|LIVE
operator|)
condition|)
block|{
name|pk
operator|->
name|p_msg
operator||=
name|pk
operator|->
name|p_rmsg
expr_stmt|;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|t
operator|=
name|next
index|[
name|pk
operator|->
name|p_pr
index|]
expr_stmt|;
for|for
control|(
name|x
operator|=
name|pk
operator|->
name|p_pr
init|;
name|x
operator|!=
name|t
condition|;
name|x
operator|=
operator|(
name|x
operator|-
literal|1
operator|)
operator|&
literal|7
control|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|==
literal|0
condition|)
goto|goto
name|slot
goto|;
block|}
name|drop
label|:
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
return|return;
name|slot
label|:
name|m
operator|=
name|mask
index|[
name|x
index|]
expr_stmt|;
name|pk
operator|->
name|p_imap
operator||=
name|m
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
name|c
expr_stmt|;
name|pk
operator|->
name|p_isum
index|[
name|x
index|]
operator|=
name|sum
expr_stmt|;
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|bp
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * setup input transfers  */
end_comment

begin_macro
name|pkrstart
argument_list|(
argument|pk
argument_list|)
end_macro

begin_block
block|{}
end_block

begin_comment
comment|/*  * Start transmission on output device associated with pk.  * For asynch devices (t_line==1) framing is  * imposed.  For devices with framing and crc  * in the driver (t_line==2) the transfer is  * passed on to the driver.  */
end_comment

begin_macro
name|pkxstart
argument_list|(
argument|pk
argument_list|,
argument|cntl
argument_list|,
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|cntl
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|short
name|checkword
decl_stmt|;
name|char
name|hdchk
decl_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|pk
operator|->
name|p_ohbuf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SYN
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|hdchk
operator|=
literal|9
expr_stmt|;
name|checkword
operator|=
name|cntl
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|hdchk
operator|=
name|pk
operator|->
name|p_lpsize
expr_stmt|;
name|checkword
operator|=
name|pk
operator|->
name|p_osum
index|[
name|x
index|]
operator|^
call|(
name|unsigned
call|)
argument_list|(
name|cntl
operator|&
literal|0377
argument_list|)
expr_stmt|;
block|}
name|checkword
operator|=
name|CHECK
operator|-
name|checkword
expr_stmt|;
operator|*
name|p
operator|=
name|checkword
expr_stmt|;
name|hdchk
operator|^=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
name|checkword
operator|>>
literal|8
expr_stmt|;
name|hdchk
operator|^=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
name|cntl
expr_stmt|;
name|hdchk
operator|^=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
name|hdchk
expr_stmt|;
comment|/*  writes  */
name|PKDEBUG
argument_list|(
literal|7
argument_list|,
literal|"send %o\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|cntl
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|pk
operator|->
name|p_ohbuf
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|GENERROR
argument_list|(
name|p
argument_list|,
name|HDRSIZ
argument_list|)
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|pk
operator|->
name|p_ofn
argument_list|,
name|p
argument_list|,
name|HDRSIZ
argument_list|)
expr_stmt|;
name|PKASSERT
argument_list|(
name|ret
operator|==
name|HDRSIZ
argument_list|,
literal|"PKXSTART ret %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
name|PACKSIZE
operator|+
name|HDRSIZ
index|]
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|b
operator|=
name|buf
init|;
name|i
operator|<
name|HDRSIZ
condition|;
name|i
operator|++
control|)
operator|*
name|b
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|pk
operator|->
name|p_ob
index|[
name|x
index|]
init|;
name|i
operator|<
name|pk
operator|->
name|p_rsize
condition|;
name|i
operator|++
control|)
operator|*
name|b
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|GENERROR
argument_list|(
name|buf
argument_list|,
name|pk
operator|->
name|p_rsize
operator|+
name|HDRSIZ
argument_list|)
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|pk
operator|->
name|p_ofn
argument_list|,
name|buf
argument_list|,
name|pk
operator|->
name|p_rsize
operator|+
name|HDRSIZ
argument_list|)
expr_stmt|;
name|PKASSERT
argument_list|(
name|ret
operator|==
name|pk
operator|->
name|p_rsize
operator|+
name|HDRSIZ
argument_list|,
literal|"PKXSTART ret %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pk
operator|->
name|p_msg
condition|)
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|pkmove
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|count
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|B_WRITE
condition|)
block|{
name|s
operator|=
name|p2
expr_stmt|;
name|d
operator|=
name|p1
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|p1
expr_stmt|;
name|d
operator|=
name|p2
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/***  *	pkcget(fn, b, n)	get n characters from input  *	char *b;		- buffer for characters  *	int fn;			- file descriptor  *	int n;			- requested number of characters  *  *	return codes:  *		n - number of characters returned  *		0 - end of file  */
end_comment

begin_decl_stmt
name|jmp_buf
name|Getjbuf
decl_stmt|;
end_decl_stmt

begin_macro
name|cgalarm
argument_list|()
end_macro

begin_block
block|{
name|longjmp
argument_list|(
name|Getjbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pkcget
argument_list|(
argument|fn
argument_list|,
argument|b
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fn
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nchars
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Getjbuf
argument_list|)
condition|)
block|{
name|Ntimeout
operator|++
expr_stmt|;
name|PKDEBUG
argument_list|(
literal|4
argument_list|,
literal|"alarm %d\n"
argument_list|,
name|Ntimeout
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|cgalarm
argument_list|)
expr_stmt|;
for|for
control|(
name|nchars
operator|=
literal|0
init|;
name|nchars
operator|<
name|n
condition|;
name|nchars
operator|+=
name|ret
control|)
block|{
name|alarm
argument_list|(
name|PKTIME
argument_list|)
expr_stmt|;
name|ret
operator|=
name|read
argument_list|(
name|fn
argument_list|,
name|b
argument_list|,
name|n
operator|-
name|nchars
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|PKASSERT
argument_list|(
name|ret
operator|>
literal|0
argument_list|,
literal|"PKCGET READ %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|b
operator|+=
name|ret
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|generror
argument_list|(
argument|p
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|Errorrate
operator|!=
literal|0
operator|&&
operator|(
name|rand
argument_list|()
operator|%
name|Errorrate
operator|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|rand
argument_list|()
operator|%
name|s
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gen err at %o, (%o), "
argument_list|,
name|r
argument_list|,
operator|(
name|unsigned
operator|)
operator|*
operator|(
name|p
operator|+
name|r
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|+
name|r
operator|)
operator|+=
literal|1
expr_stmt|;
block|}
return|return;
block|}
end_block

end_unit

