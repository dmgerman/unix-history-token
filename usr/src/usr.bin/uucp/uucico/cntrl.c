begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)cntrl.c	5.3 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_struct
struct|struct
name|Proto
block|{
name|char
name|P_id
decl_stmt|;
name|int
function_decl|(
modifier|*
name|P_turnon
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|P_rdmsg
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|P_wrmsg
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|P_rddata
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|P_wrdata
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|P_turnoff
function_decl|)
parameter_list|()
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|gturnon
argument_list|()
decl_stmt|,
name|gturnoff
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|grdmsg
argument_list|()
decl_stmt|,
name|grddata
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gwrmsg
argument_list|()
decl_stmt|,
name|gwrdata
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nturnon
argument_list|()
decl_stmt|,
name|nturnoff
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nrdmsg
argument_list|()
decl_stmt|,
name|nrddata
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nwrmsg
argument_list|()
decl_stmt|,
name|nwrdata
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|imsg
argument_list|()
decl_stmt|,
name|omsg
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Proto
name|Ptbl
index|[]
init|=
block|{
literal|'n'
block|,
name|nturnon
block|,
name|nrdmsg
block|,
name|nwrmsg
block|,
name|nrddata
block|,
name|nwrdata
block|,
name|nturnoff
block|,
literal|'g'
block|,
name|gturnon
block|,
name|grdmsg
block|,
name|gwrmsg
block|,
name|grddata
block|,
name|gwrdata
block|,
name|gturnoff
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|Imsg
function_decl|)
parameter_list|()
init|=
name|imsg
operator|,
parameter_list|(
function_decl|*Omsg
end_function_decl

begin_expr_stmt
unit|)
operator|(
operator|)
operator|=
name|omsg
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* avoid SEL compiler limitation */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|Rdmsg
function_decl|)
parameter_list|()
init|=
name|imsg
operator|,
parameter_list|(
function_decl|*Rddata
end_function_decl

begin_expr_stmt
unit|)
operator|(
operator|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|Wrmsg
function_decl|)
parameter_list|()
init|=
name|omsg
operator|,
parameter_list|(
function_decl|*Wrdata
end_function_decl

begin_expr_stmt
unit|)
operator|(
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
argument_list|(
operator|*
name|Turnon
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|Turnoff
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YES
value|"Y"
end_define

begin_define
define|#
directive|define
name|NO
value|"N"
end_define

begin_comment
comment|/*  failure messages  */
end_comment

begin_define
define|#
directive|define
name|EM_MAX
value|6
end_define

begin_define
define|#
directive|define
name|EM_LOCACC
value|"N1"
end_define

begin_comment
comment|/* local access to file denied */
end_comment

begin_define
define|#
directive|define
name|EM_RMTACC
value|"N2"
end_define

begin_comment
comment|/* remote access to file/path denied */
end_comment

begin_define
define|#
directive|define
name|EM_BADUUCP
value|"N3"
end_define

begin_comment
comment|/* a bad uucp command was generated */
end_comment

begin_define
define|#
directive|define
name|EM_NOTMP
value|"N4"
end_define

begin_comment
comment|/* remote error - can't create temp */
end_comment

begin_define
define|#
directive|define
name|EM_RMTCP
value|"N5"
end_define

begin_comment
comment|/* can't copy to remote directory - file in public */
end_comment

begin_define
define|#
directive|define
name|EM_LOCCP
value|"N6"
end_define

begin_comment
comment|/* can't copy on local system */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Em_msg
index|[]
init|=
block|{
literal|"COPY FAILED (reason not given by remote)"
block|,
literal|"local access to file denied"
block|,
literal|"remote access to path/file denied"
block|,
literal|"system error - bad uucp command generated"
block|,
literal|"remote system can't create temp file"
block|,
literal|"can't copy to file/directory - file left in PUBDIR/user/file"
block|,
literal|"can't copy to file/directory - file left in PUBDIR/user/file"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*       */
end_comment

begin_define
define|#
directive|define
name|XUUCP
value|'X'
end_define

begin_comment
comment|/* execute uucp (string) */
end_comment

begin_define
define|#
directive|define
name|SLTPTCL
value|'P'
end_define

begin_comment
comment|/* select protocol  (string)  */
end_comment

begin_define
define|#
directive|define
name|USEPTCL
value|'U'
end_define

begin_comment
comment|/* use protocol (character) */
end_comment

begin_define
define|#
directive|define
name|RCVFILE
value|'R'
end_define

begin_comment
comment|/* receive file (string) */
end_comment

begin_define
define|#
directive|define
name|SNDFILE
value|'S'
end_define

begin_comment
comment|/* send file (string) */
end_comment

begin_define
define|#
directive|define
name|RQSTCMPT
value|'C'
end_define

begin_comment
comment|/* request complete (string - yes | no) */
end_comment

begin_define
define|#
directive|define
name|HUP
value|'H'
end_define

begin_comment
comment|/* ready to hangup (string - yes | no) */
end_comment

begin_define
define|#
directive|define
name|RESET
value|'X'
end_define

begin_comment
comment|/* reset line modes */
end_comment

begin_define
define|#
directive|define
name|W_TYPE
value|wrkvec[0]
end_define

begin_define
define|#
directive|define
name|W_FILE1
value|wrkvec[1]
end_define

begin_define
define|#
directive|define
name|W_FILE2
value|wrkvec[2]
end_define

begin_define
define|#
directive|define
name|W_USER
value|wrkvec[3]
end_define

begin_define
define|#
directive|define
name|W_OPTNS
value|wrkvec[4]
end_define

begin_define
define|#
directive|define
name|W_DFILE
value|wrkvec[5]
end_define

begin_define
define|#
directive|define
name|W_MODE
value|wrkvec[6]
end_define

begin_define
define|#
directive|define
name|W_NUSER
value|wrkvec[7]
end_define

begin_define
define|#
directive|define
name|XFRRATE
value|350000L
end_define

begin_define
define|#
directive|define
name|RMESG
parameter_list|(
name|m
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|if (rmesg(m, s, n) != 0) {(*Turnoff)(); return(FAIL);} else
end_define

begin_define
define|#
directive|define
name|RAMESG
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|if (rmesg('\0', s, n) != 0) {(*Turnoff)(); return(FAIL);} else
end_define

begin_define
define|#
directive|define
name|WMESG
parameter_list|(
name|m
parameter_list|,
name|s
parameter_list|)
value|if(wmesg(m, s) != 0) {(*Turnoff)(); return(FAIL);} else
end_define

begin_decl_stmt
name|char
name|Wfile
index|[
name|MAXFULLNAME
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Dfile
index|[
name|MAXFULLNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To avoid a huge backlog of X. files, start uuxqt every so often.  * To avoid a huge number of uuxqt zombies,   * wait for one occasionally!  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nXfiles
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of X files since last uuxqt start */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nXQTs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of uuxqts started */
end_comment

begin_comment
comment|/*******  *	cntrl(role, wkpre)  *	int role;  *	char *wkpre;  *  *	cntrl  -  this routine will execute the conversation  *	between the two machines after both programs are  *	running.  *  *	return codes  *		SUCCESS - ok  *		FAIL - failed  */
end_comment

begin_macro
name|cntrl
argument_list|(
argument|role
argument_list|,
argument|wkpre
argument_list|)
end_macro

begin_decl_stmt
name|int
name|role
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|wkpre
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|msg
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|rqstr
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|filemode
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|char
name|filename
index|[
name|MAXFULLNAME
index|]
decl_stmt|,
name|wrktype
decl_stmt|,
modifier|*
name|wrkvec
index|[
literal|20
index|]
decl_stmt|;
specifier|extern
type|(
modifier|*
name|Rdmsg
decl_stmt|)(
block|)
end_block

begin_operator
operator|,
end_operator

begin_expr_stmt
call|(
modifier|*
name|Wrmsg
call|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|lastpart
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|status
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|i
decl_stmt|,
name|narg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mailopt
decl_stmt|,
name|ntfyopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ret
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pnum
decl_stmt|,
name|tmpnum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|pnum
operator|=
name|getpid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ima.247, John Levine, IECC, PO Box 349, Cambridge MA 02238; (617) 491-5450  * zap Wfile to prevent reuse of wrong C. file  */
end_comment

begin_expr_stmt
name|Wfile
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
end_expr_stmt

begin_label
name|top
label|:
end_label

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|wrkvec
operator|/
sizeof|sizeof
name|wrkvec
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
name|wrkvec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
end_for

begin_expr_stmt
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"*** TOP ***  -  role=%d, "
argument_list|,
name|role
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setline
argument_list|(
name|RESET
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|role
operator|==
name|MASTER
condition|)
block|{
comment|/* get work */
if|if
condition|(
operator|(
name|narg
operator|=
name|gtwvec
argument_list|(
name|Wfile
argument_list|,
name|Spool
argument_list|,
name|wkpre
argument_list|,
name|wrkvec
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|WMESG
argument_list|(
name|HUP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RMESG
argument_list|(
name|HUP
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
name|wrktype
operator|=
name|W_TYPE
index|[
literal|0
index|]
expr_stmt|;
name|mailopt
operator|=
name|index
argument_list|(
name|W_OPTNS
argument_list|,
literal|'m'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|ntfyopt
operator|=
name|index
argument_list|(
name|W_OPTNS
argument_list|,
literal|'n'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|narg
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|msg
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
name|wrkvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrktype
operator|==
name|XUUCP
condition|)
block|{
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"X %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|rqstr
argument_list|,
literal|"REQUEST"
argument_list|)
expr_stmt|;
goto|goto
name|sendmsg
goto|;
block|}
name|ASSERT
argument_list|(
name|narg
operator|>
literal|4
argument_list|,
literal|"ARG COUNT<5"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|User
argument_list|,
literal|"%.9s"
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"%s %s %s %s"
argument_list|,
name|W_TYPE
argument_list|,
name|W_FILE1
argument_list|,
name|W_FILE2
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|rqstr
argument_list|,
literal|"REQUEST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrktype
operator|==
name|SNDFILE
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
name|W_FILE1
argument_list|)
expr_stmt|;
name|i
operator|=
name|expfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"expfile type - %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|chkpth
argument_list|(
name|User
argument_list|,
literal|""
argument_list|,
name|filename
argument_list|)
condition|)
goto|goto
name|e_access
goto|;
name|strcpy
argument_list|(
name|Dfile
argument_list|,
name|W_DFILE
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|W_OPTNS
argument_list|,
literal|'c'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|subfile
argument_list|(
name|Dfile
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|subfile
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/*  can not read data file  */
name|logent
argument_list|(
literal|"CAN'T READ DATA"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
name|unlinkdf
argument_list|(
name|Dfile
argument_list|)
expr_stmt|;
name|lnotify
argument_list|(
name|User
argument_list|,
name|filename
argument_list|,
literal|"can't access"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* if file exists but is not generally readable... */
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|ANYREAD
operator|)
operator|==
literal|0
condition|)
block|{
name|e_access
label|:
empty_stmt|;
comment|/*  access denied  */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|logent
argument_list|(
literal|"DENIED"
argument_list|,
literal|"ACCESS"
argument_list|)
expr_stmt|;
name|unlinkdf
argument_list|(
name|W_DFILE
argument_list|)
expr_stmt|;
name|lnotify
argument_list|(
name|User
argument_list|,
name|filename
argument_list|,
literal|"access denied"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|setline
argument_list|(
name|SNDFILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrktype
operator|==
name|RCVFILE
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
name|W_FILE2
argument_list|)
expr_stmt|;
name|expfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkpth
argument_list|(
name|User
argument_list|,
literal|""
argument_list|,
name|filename
argument_list|)
operator|||
name|chkperm
argument_list|(
name|filename
argument_list|,
name|index
argument_list|(
name|W_OPTNS
argument_list|,
literal|'d'
argument_list|)
argument_list|)
condition|)
block|{
comment|/*  access denied  */
name|logent
argument_list|(
literal|"DENIED"
argument_list|,
literal|"ACCESS"
argument_list|)
expr_stmt|;
name|lnotify
argument_list|(
name|User
argument_list|,
name|filename
argument_list|,
literal|"access denied"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|sprintf
argument_list|(
name|Dfile
argument_list|,
literal|"%s/TM.%05d.%03d"
argument_list|,
name|Spool
argument_list|,
name|pnum
argument_list|,
name|tmpnum
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|subfile
argument_list|(
name|Dfile
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/*  can not create temp  */
name|logent
argument_list|(
literal|"CAN'T CREATE TM"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
name|unlinkdf
argument_list|(
name|Dfile
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|setline
argument_list|(
name|RCVFILE
argument_list|)
expr_stmt|;
block|}
name|sendmsg
label|:
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wrktype - %c\n "
argument_list|,
name|wrktype
argument_list|)
expr_stmt|;
name|WMESG
argument_list|(
name|wrktype
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|RMESG
argument_list|(
name|wrktype
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
end_if

begin_comment
comment|/* role is slave */
end_comment

begin_expr_stmt
name|RAMESG
argument_list|(
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_goto
goto|goto
name|process
goto|;
end_goto

begin_label
name|process
label|:
end_label

begin_comment
comment|/*	rti!trt: ultouch is now done in gio.c (yes, kludge)  *	ultouch();  */
end_comment

begin_expr_stmt
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|" PROCESS: msg - %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|msg
index|[
literal|0
index|]
condition|)
block|{
case|case
name|RQSTCMPT
case|:
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s\n"
argument_list|,
literal|"RQSTCMPT:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
operator|&
name|msg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|EM_MAX
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* duke!rti: only note failed requests */
name|logent
argument_list|(
name|msg
argument_list|,
literal|"REQUESTED"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|role
operator|==
name|MASTER
condition|)
block|{
name|notify
argument_list|(
name|mailopt
argument_list|,
name|W_USER
argument_list|,
name|W_FILE1
argument_list|,
name|Rmtname
argument_list|,
operator|&
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
goto|goto
name|top
goto|;
case|case
name|HUP
case|:
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s\n"
argument_list|,
literal|"HUP:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'Y'
condition|)
block|{
name|WMESG
argument_list|(
name|HUP
argument_list|,
name|YES
argument_list|)
expr_stmt|;
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
name|Rdmsg
operator|=
name|Imsg
expr_stmt|;
name|Wrmsg
operator|=
name|Omsg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|ASSERT
argument_list|(
name|role
operator|==
name|MASTER
argument_list|,
literal|"WRONG ROLE"
argument_list|,
literal|""
argument_list|,
name|role
argument_list|)
expr_stmt|;
name|role
operator|=
name|SLAVE
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* get work */
if|if
condition|(
operator|!
name|iswrk
argument_list|(
name|Wfile
argument_list|,
literal|"chk"
argument_list|,
name|Spool
argument_list|,
name|wkpre
argument_list|)
condition|)
block|{
name|WMESG
argument_list|(
name|HUP
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|RMESG
argument_list|(
name|HUP
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
name|WMESG
argument_list|(
name|HUP
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|role
operator|=
name|MASTER
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|XUUCP
case|:
if|if
condition|(
name|role
operator|==
name|MASTER
condition|)
block|{
goto|goto
name|top
goto|;
block|}
comment|/*  slave part  */
name|i
operator|=
name|getargs
argument_list|(
name|msg
argument_list|,
name|wrkvec
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|W_FILE1
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|filename
argument_list|,
literal|';'
argument_list|)
operator|!=
name|NULL
operator|||
name|index
argument_list|(
name|W_FILE2
argument_list|,
literal|';'
argument_list|)
operator|!=
name|NULL
operator|||
name|i
operator|<
literal|3
condition|)
block|{
name|WMESG
argument_list|(
name|XUUCP
argument_list|,
name|NO
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|expfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkpth
argument_list|(
literal|""
argument_list|,
name|Rmtname
argument_list|,
name|filename
argument_list|)
condition|)
block|{
name|WMESG
argument_list|(
name|XUUCP
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"XUUCP DENIED"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"%s %s"
argument_list|,
name|filename
argument_list|,
name|W_FILE2
argument_list|)
expr_stmt|;
name|xuucp
argument_list|(
name|rqstr
argument_list|)
expr_stmt|;
name|WMESG
argument_list|(
name|XUUCP
argument_list|,
name|YES
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|SNDFILE
case|:
comment|/*  MASTER section of SNDFILE  */
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s\n"
argument_list|,
literal|"SNDFILE:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
operator|&
name|msg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|EM_MAX
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|logent
argument_list|(
name|Em_msg
index|[
name|i
index|]
argument_list|,
literal|"REQUEST"
argument_list|)
expr_stmt|;
name|notify
argument_list|(
name|mailopt
argument_list|,
name|W_USER
argument_list|,
name|W_FILE1
argument_list|,
name|Rmtname
argument_list|,
operator|&
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|role
operator|==
name|MASTER
argument_list|,
literal|"WRONG ROLE"
argument_list|,
literal|""
argument_list|,
name|role
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|!=
literal|'4'
condition|)
name|unlinkdf
argument_list|(
name|W_DFILE
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'Y'
condition|)
block|{
comment|/* send file */
name|ASSERT
argument_list|(
name|role
operator|==
name|MASTER
argument_list|,
literal|"WRONG ROLE"
argument_list|,
literal|""
argument_list|,
name|role
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ret
operator|!=
operator|-
literal|1
argument_list|,
literal|"STAT FAILED"
argument_list|,
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
operator|+
call|(
name|int
call|)
argument_list|(
name|stbuf
operator|.
name|st_size
operator|/
name|XFRRATE
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|Wrdata
call|)
argument_list|(
name|fp
argument_list|,
name|Ofn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|RMESG
argument_list|(
name|RQSTCMPT
argument_list|,
name|msg
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* put the unlink *after* the RMESG -- fortune!Dave-Yost */
name|unlinkdf
argument_list|(
name|W_DFILE
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
comment|/*  SLAVE section of SNDFILE  */
name|ASSERT
argument_list|(
name|role
operator|==
name|SLAVE
argument_list|,
literal|"WRONG ROLE"
argument_list|,
literal|""
argument_list|,
name|role
argument_list|)
expr_stmt|;
comment|/* request to receive file */
comment|/* check permissions */
name|i
operator|=
name|getargs
argument_list|(
name|msg
argument_list|,
name|wrkvec
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|>
literal|4
argument_list|,
literal|"ARG COUNT<5"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"%s %s %s %s"
argument_list|,
name|W_TYPE
argument_list|,
name|W_FILE1
argument_list|,
name|W_FILE2
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|rqstr
argument_list|,
literal|"REQUESTED"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"msg - %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|W_FILE2
argument_list|)
expr_stmt|;
comment|/* Run uuxqt occasionally */
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
name|XQTPRE
condition|)
block|{
if|if
condition|(
operator|++
name|nXfiles
operator|>
literal|10
condition|)
block|{
name|nXfiles
operator|=
literal|0
expr_stmt|;
comment|/* I sure hope the wait(II) does not hang. 				 * One can never tell about UNIX variants. 				 */
if|if
condition|(
operator|++
name|nXQTs
operator|>
literal|2
condition|)
name|wait
argument_list|(
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|xuuxqt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* rti!trt: expand filename, i is set to 0 if this is 		 * is a vanilla spool file, so no stat(II)s are needed */
name|i
operator|=
name|expfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"expfile type - %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|chkpth
argument_list|(
literal|""
argument_list|,
name|Rmtname
argument_list|,
name|filename
argument_list|)
operator|||
name|chkperm
argument_list|(
name|filename
argument_list|,
name|index
argument_list|(
name|W_OPTNS
argument_list|,
literal|'d'
argument_list|)
argument_list|)
condition|)
block|{
name|WMESG
argument_list|(
name|SNDFILE
argument_list|,
name|EM_RMTACC
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"DENIED"
argument_list|,
literal|"PERMISSION"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|isdir
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|lastpart
argument_list|(
name|W_FILE1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|User
argument_list|,
literal|"%.9s"
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"chkpth ok Rmtname - %s\n"
argument_list|,
name|Rmtname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Dfile
argument_list|,
literal|"%s/TM.%05d.%03d"
argument_list|,
name|Spool
argument_list|,
name|pnum
argument_list|,
name|tmpnum
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|subfile
argument_list|(
name|Dfile
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|WMESG
argument_list|(
name|SNDFILE
argument_list|,
name|EM_NOTMP
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"CAN'T OPEN"
argument_list|,
literal|"DENIED"
argument_list|)
expr_stmt|;
name|unlinkdf
argument_list|(
name|Dfile
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|WMESG
argument_list|(
name|SNDFILE
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|Rddata
call|)
argument_list|(
name|Ifn
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* ittvax!swatt: (try to) make sure IO successful */
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|||
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
name|ret
operator|=
name|FAIL
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
comment|/* copy to user directory */
name|ntfyopt
operator|=
name|index
argument_list|(
name|W_OPTNS
argument_list|,
literal|'n'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|status
operator|=
name|xmv
argument_list|(
name|Dfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|WMESG
argument_list|(
name|RQSTCMPT
argument_list|,
name|status
condition|?
name|EM_RMTCP
else|:
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|sscanf
argument_list|(
name|W_MODE
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|filemode
argument_list|)
expr_stmt|;
if|if
condition|(
name|filemode
operator|<=
literal|0
condition|)
name|filemode
operator|=
name|BASEMODE
expr_stmt|;
name|chmod
argument_list|(
name|subfile
argument_list|(
name|filename
argument_list|)
argument_list|,
name|filemode
operator||
name|BASEMODE
argument_list|)
expr_stmt|;
name|arrived
argument_list|(
name|ntfyopt
argument_list|,
name|filename
argument_list|,
name|W_NUSER
argument_list|,
name|Rmtname
argument_list|,
name|User
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logent
argument_list|(
literal|"FAILED"
argument_list|,
literal|"COPY"
argument_list|)
expr_stmt|;
name|status
operator|=
name|putinpub
argument_list|(
name|filename
argument_list|,
name|Dfile
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"->PUBDIR %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|arrived
argument_list|(
name|ntfyopt
argument_list|,
name|filename
argument_list|,
name|W_NUSER
argument_list|,
name|Rmtname
argument_list|,
name|User
argument_list|)
expr_stmt|;
block|}
goto|goto
name|top
goto|;
case|case
name|RCVFILE
case|:
comment|/*  MASTER section of RCVFILE  */
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s\n"
argument_list|,
literal|"RCVFILE:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
operator|&
name|msg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|EM_MAX
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|logent
argument_list|(
name|Em_msg
index|[
name|i
index|]
argument_list|,
literal|"REQUEST"
argument_list|)
expr_stmt|;
name|notify
argument_list|(
name|mailopt
argument_list|,
name|W_USER
argument_list|,
name|W_FILE1
argument_list|,
name|Rmtname
argument_list|,
operator|&
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|role
operator|==
name|MASTER
argument_list|,
literal|"WRONG ROLE"
argument_list|,
literal|""
argument_list|,
name|role
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unlinkdf
argument_list|(
name|Dfile
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'Y'
condition|)
block|{
comment|/* receive file */
name|ASSERT
argument_list|(
name|role
operator|==
name|MASTER
argument_list|,
literal|"WRONG ROLE"
argument_list|,
literal|""
argument_list|,
name|role
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|Rddata
call|)
argument_list|(
name|Ifn
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* ittvax!swatt: (try to) make sure IO successful */
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|||
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
name|ret
operator|=
name|FAIL
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
comment|/* copy to user directory */
if|if
condition|(
name|isdir
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|lastpart
argument_list|(
name|W_FILE1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|xmv
argument_list|(
name|Dfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|WMESG
argument_list|(
name|RQSTCMPT
argument_list|,
name|status
condition|?
name|EM_RMTCP
else|:
name|YES
argument_list|)
expr_stmt|;
name|notify
argument_list|(
name|mailopt
argument_list|,
name|W_USER
argument_list|,
name|filename
argument_list|,
name|Rmtname
argument_list|,
name|status
condition|?
name|EM_LOCCP
else|:
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|sscanf
argument_list|(
operator|&
name|msg
index|[
literal|2
index|]
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|filemode
argument_list|)
expr_stmt|;
if|if
condition|(
name|filemode
operator|<=
literal|0
condition|)
name|filemode
operator|=
name|BASEMODE
expr_stmt|;
name|chmod
argument_list|(
name|subfile
argument_list|(
name|filename
argument_list|)
argument_list|,
name|filemode
operator||
name|BASEMODE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logent
argument_list|(
literal|"FAILED"
argument_list|,
literal|"COPY"
argument_list|)
expr_stmt|;
name|putinpub
argument_list|(
name|filename
argument_list|,
name|Dfile
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
block|}
goto|goto
name|top
goto|;
block|}
comment|/*  SLAVE section of RCVFILE  */
name|ASSERT
argument_list|(
name|role
operator|==
name|SLAVE
argument_list|,
literal|"WRONG ROLE"
argument_list|,
literal|""
argument_list|,
name|role
argument_list|)
expr_stmt|;
comment|/* request to send file */
name|strcpy
argument_list|(
name|rqstr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|rqstr
argument_list|,
literal|"REQUESTED"
argument_list|)
expr_stmt|;
comment|/* check permissions */
name|i
operator|=
name|getargs
argument_list|(
name|msg
argument_list|,
name|wrkvec
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|>
literal|3
argument_list|,
literal|"ARG COUNT<4"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"msg - %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"W_FILE1 - %s\n"
argument_list|,
name|W_FILE1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|W_FILE1
argument_list|)
expr_stmt|;
name|expfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|lastpart
argument_list|(
name|W_FILE2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|User
argument_list|,
literal|"%.9s"
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkpth
argument_list|(
literal|""
argument_list|,
name|Rmtname
argument_list|,
name|filename
argument_list|)
operator|||
name|anyread
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|WMESG
argument_list|(
name|RCVFILE
argument_list|,
name|EM_RMTACC
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"DENIED"
argument_list|,
literal|"PERMISSION"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"chkpth ok Rmtname - %s\n"
argument_list|,
name|Rmtname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|subfile
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|WMESG
argument_list|(
name|RCVFILE
argument_list|,
name|EM_RMTACC
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"CAN'T OPEN"
argument_list|,
literal|"DENIED"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/*  ok to send file */
name|ret
operator|=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ret
operator|!=
operator|-
literal|1
argument_list|,
literal|"STAT FAILED"
argument_list|,
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
operator|+
call|(
name|int
call|)
argument_list|(
name|stbuf
operator|.
name|st_size
operator|/
name|XFRRATE
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%s %o"
argument_list|,
name|YES
argument_list|,
name|stbuf
operator|.
name|st_mode
operator|&
literal|0777
argument_list|)
expr_stmt|;
name|WMESG
argument_list|(
name|RCVFILE
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|Wrdata
call|)
argument_list|(
name|fp
argument_list|,
name|Ofn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|RMESG
argument_list|(
name|RQSTCMPT
argument_list|,
name|msg
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
end_switch

begin_expr_stmt
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|FAIL
operator|)
return|;
end_return

begin_comment
unit|}
comment|/***  *	rmesg(c, msg, n)	read message 'c'  *				try 'n' times  *	char *msg, c;  *  *	return code:  0  |  FAIL  */
end_comment

begin_expr_stmt
unit|rmesg
operator|(
name|c
operator|,
name|msg
operator|,
name|n
operator|)
specifier|register
name|char
operator|*
name|msg
operator|,
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|str
index|[
literal|50
index|]
decl_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"rmesg - '%c' "
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|str
argument_list|,
literal|"PATIENCE"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
call|(
modifier|*
name|Rdmsg
call|)
argument_list|(
name|msg
argument_list|,
name|Ifn
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
continue|continue;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
literal|"FAIL"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"expected '%c' got FAIL"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|str
argument_list|,
literal|"BAD READ"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|msg
index|[
literal|0
index|]
operator|!=
name|c
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"expected '%c' got %.25s"
argument_list|,
name|c
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|str
argument_list|,
literal|"BAD READ"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %.25s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	wmesg(m, s)	write a message (type m)  *	char *s, m;  *  *	return codes: 0 - ok | FAIL - ng  */
end_comment

begin_expr_stmt
name|wmesg
argument_list|(
name|m
argument_list|,
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
name|m
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wmesg '%c'"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%.25s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
modifier|*
name|Wrmsg
call|)
argument_list|(
name|m
argument_list|,
name|s
argument_list|,
name|Ofn
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	notify		mail results of command  *  *	return codes:  none  */
end_comment

begin_macro
name|notify
argument_list|(
argument|mailopt
argument_list|,
argument|user
argument_list|,
argument|file
argument_list|,
argument|sys
argument_list|,
argument|msgcode
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|sys
decl_stmt|,
modifier|*
name|msgcode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|str
index|[
literal|200
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|!
name|mailopt
operator|&&
operator|*
name|msgcode
operator|==
literal|'Y'
condition|)
return|return;
if|if
condition|(
operator|*
name|msgcode
operator|==
literal|'Y'
condition|)
name|msg
operator|=
literal|"copy succeeded"
expr_stmt|;
else|else
block|{
name|i
operator|=
name|atoi
argument_list|(
name|msgcode
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
operator|||
name|i
operator|>
name|EM_MAX
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|msg
operator|=
name|Em_msg
index|[
name|i
index|]
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"file %s, system %s\n%s\n"
argument_list|,
name|file
argument_list|,
name|sys
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|mailst
argument_list|(
name|user
argument_list|,
name|str
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/***  *	lnotify(user, file, mesg)	- local notify  *  *	return code - none  */
end_comment

begin_macro
name|lnotify
argument_list|(
argument|user
argument_list|,
argument|file
argument_list|,
argument|mesg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|mesg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|mbuf
index|[
literal|200
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|mbuf
argument_list|,
literal|"file %s on %s\n%s\n"
argument_list|,
name|file
argument_list|,
name|Myname
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|mailst
argument_list|(
name|user
argument_list|,
name|mbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/***  *	startup(role)  *	int role;  *  *	startup  -  this routine will converse with the remote  *	machine, agree upon a protocol (if possible) and start the  *	protocol.  *  *	return codes:  *		SUCCESS - successful protocol selection  *		FAIL - can't find common or open failed  */
end_comment

begin_macro
name|startup
argument_list|(
argument|role
argument_list|)
end_macro

begin_decl_stmt
name|int
name|role
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
type|(
modifier|*
name|Rdmsg
decl_stmt|)(
block|)
end_block

begin_operator
operator|,
end_operator

begin_expr_stmt
call|(
modifier|*
name|Wrmsg
call|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|blptcl
argument_list|()
decl_stmt|,
name|fptcl
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|msg
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|str
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Rdmsg
operator|=
name|Imsg
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Wrmsg
operator|=
name|Omsg
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|role
operator|==
name|MASTER
condition|)
block|{
name|RMESG
argument_list|(
name|SLTPTCL
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|str
index|[
literal|0
index|]
operator|=
name|fptcl
argument_list|(
operator|&
name|msg
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no protocol match */
name|WMESG
argument_list|(
name|USEPTCL
argument_list|,
name|NO
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|str
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|WMESG
argument_list|(
name|USEPTCL
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|stptcl
argument_list|(
name|str
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"protocol %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
else|else
block|{
name|WMESG
argument_list|(
name|SLTPTCL
argument_list|,
name|blptcl
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|RMESG
argument_list|(
name|USEPTCL
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
if|if
condition|(
name|stptcl
argument_list|(
operator|&
name|msg
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Protocol %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_if

begin_comment
unit|}
comment|/*******  *	char  *	fptcl(str)  *	char *str;  *  *	fptcl  -  this routine will choose a protocol from  *	the input string (str) and return the found letter.  *  *	return codes:  *		'\0'  -  no acceptable protocol  *		any character  -  the chosen protocol  */
end_comment

begin_expr_stmt
unit|char
name|fptcl
argument_list|(
name|str
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|Proto
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|Ifn
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|'\0'
operator|)
return|;
for|for
control|(
name|p
operator|=
name|Ptbl
init|;
name|p
operator|->
name|P_id
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
comment|/* 		 * Hack to avoid using network protocol if not connected 		 * to network. 		 */
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFSOCK
operator|&&
name|p
operator|->
name|P_id
operator|==
literal|'n'
condition|)
continue|continue;
if|if
condition|(
name|index
argument_list|(
name|str
argument_list|,
name|p
operator|->
name|P_id
argument_list|)
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|p
operator|->
name|P_id
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|'\0'
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	char *  *	blptcl(str)  *	char *str;  *  *	blptcl  -  this will build a string of the  *	letters of the available protocols and return  *	the string (str).  *  *	return:  *		a pointer to string (str)  */
end_comment

begin_function
name|char
modifier|*
name|blptcl
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|struct
name|Proto
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|Ofn
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
name|stbuf
operator|.
name|st_mode
operator|=
name|S_IFCHR
expr_stmt|;
for|for
control|(
name|p
operator|=
name|Ptbl
operator|,
name|s
operator|=
name|str
init|;
name|p
operator|->
name|P_id
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
comment|/* 		 * Hack to avoid using network protocol if not connected 		 * to network. 		 */
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFSOCK
operator|&&
name|p
operator|->
name|P_id
operator|==
literal|'n'
condition|)
continue|continue;
operator|*
name|s
operator|++
operator|=
name|p
operator|->
name|P_id
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/***  *	stptcl(c)  *	char *c;  *  *	stptcl  -  this routine will set up the six routines  *	(Rdmsg, Wrmsg, Rddata, Wrdata, Turnon, Turnoff) for the  *	desired protocol.  *  *	return codes:  *		SUCCESS - ok  *		FAIL - no find or failed to open  *  */
end_comment

begin_expr_stmt
name|stptcl
argument_list|(
name|c
argument_list|)
specifier|register
name|char
operator|*
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|Proto
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|Ptbl
init|;
name|p
operator|->
name|P_id
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|c
operator|==
name|p
operator|->
name|P_id
condition|)
block|{
comment|/* found protocol - set routines */
name|Rdmsg
operator|=
name|p
operator|->
name|P_rdmsg
expr_stmt|;
name|Wrmsg
operator|=
name|p
operator|->
name|P_wrmsg
expr_stmt|;
name|Rddata
operator|=
name|p
operator|->
name|P_rddata
expr_stmt|;
name|Wrdata
operator|=
name|p
operator|->
name|P_wrdata
expr_stmt|;
name|Turnon
operator|=
name|p
operator|->
name|P_turnon
expr_stmt|;
name|Turnoff
operator|=
name|p
operator|->
name|P_turnoff
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|Turnon
call|)
argument_list|()
operator|!=
literal|0
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Proto started %c\n"
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Proto start-fail %c\n"
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	putinpub	put file in public place  *			if successful, filename is modified  *  *	return code  0 | FAIL  */
end_comment

begin_expr_stmt
name|putinpub
argument_list|(
name|file
argument_list|,
name|tmp
argument_list|,
name|user
argument_list|)
specifier|register
name|char
operator|*
name|file
operator|,
operator|*
name|user
operator|,
operator|*
name|tmp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|fullname
index|[
name|MAXFULLNAME
index|]
decl_stmt|;
name|char
modifier|*
name|lastpart
parameter_list|()
function_decl|;
name|int
name|status
decl_stmt|;
name|sprintf
argument_list|(
name|fullname
argument_list|,
literal|"%s/%s/"
argument_list|,
name|PUBDIR
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdirs
argument_list|(
name|fullname
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* can not make directories */
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|strcat
argument_list|(
name|fullname
argument_list|,
name|lastpart
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|xmv
argument_list|(
name|tmp
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|file
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|subfile
argument_list|(
name|fullname
argument_list|)
argument_list|,
name|BASEMODE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	unlinkdf(file)	- unlink D. file  *  *	return code - none  */
end_comment

begin_expr_stmt
name|unlinkdf
argument_list|(
name|file
argument_list|)
specifier|register
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|>
literal|6
condition|)
name|unlink
argument_list|(
name|subfile
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/***  *	arrived - notify receiver of arrived file  *  *	return code - none  */
end_comment

begin_macro
name|arrived
argument_list|(
argument|opt
argument_list|,
argument|file
argument_list|,
argument|nuser
argument_list|,
argument|rmtsys
argument_list|,
argument|rmtuser
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|nuser
decl_stmt|,
modifier|*
name|rmtsys
decl_stmt|,
modifier|*
name|rmtuser
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|mbuf
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|opt
condition|)
return|return;
name|sprintf
argument_list|(
name|mbuf
argument_list|,
literal|"%s from %s!%s arrived\n"
argument_list|,
name|file
argument_list|,
name|rmtsys
argument_list|,
name|rmtuser
argument_list|)
expr_stmt|;
name|mailst
argument_list|(
name|nuser
argument_list|,
name|mbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

end_unit

