begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)condevs.c	5.17 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Here are various dialers to establish the machine-machine connection.  * conn.c/condevs.c was glued together by Mike Mitchell.  * The dialers were supplied by many people, to whom we are grateful.  *  * ---------------------------------------------------------------------  * NOTE:  * There is a bug that occurs at least on PDP11s due to a limitation of  * setjmp/longjmp.   If the routine that does a setjmp is interrupted  * and longjmp-ed to,  it loses its register variables (on a pdp11).  * What works is if the routine that does the setjmp  * calls a routine and it is the *subroutine* that is interrupted.  *  * Anyway, in conclusion, condevs.c is plagued with register variables  * that are used inside  * 	if (setjmp(...)) {  * 		....  * 	}  *  * THE FIX: Don't declare variables to be register  */
end_comment

begin_include
include|#
directive|include
file|"condevs.h"
end_include

begin_decl_stmt
name|struct
name|condev
name|condevs
index|[]
init|=
block|{
block|{
literal|"DIR"
block|,
literal|"direct"
block|,
name|diropn
block|,
name|nulldev
block|,
name|dircls
block|}
block|,
ifdef|#
directive|ifdef
name|DATAKIT
block|{
literal|"DK"
block|,
literal|"datakit"
block|,
name|dkopn
block|,
name|nulldev
block|,
name|nulldev
block|}
block|,
endif|#
directive|endif
endif|DATAKIT
ifdef|#
directive|ifdef
name|PNET
block|{
literal|"PNET"
block|,
literal|"pnet"
block|,
name|pnetopn
block|,
name|nulldev
block|,
name|nulldev
block|}
block|,
endif|#
directive|endif
endif|PNET
ifdef|#
directive|ifdef
name|UNETTCP
block|{
literal|"TCP"
block|,
literal|"TCP"
block|,
name|unetopn
block|,
name|nulldev
block|,
name|unetcls
block|}
block|,
endif|#
directive|endif
endif|UNETTCP
ifdef|#
directive|ifdef
name|BSDTCP
block|{
literal|"TCP"
block|,
literal|"TCP"
block|,
name|bsdtcpopn
block|,
name|nulldev
block|,
name|bsdtcpcls
block|}
block|,
endif|#
directive|endif
endif|BSDTCP
ifdef|#
directive|ifdef
name|MICOM
block|{
literal|"MICOM"
block|,
literal|"micom"
block|,
name|micopn
block|,
name|nulldev
block|,
name|miccls
block|}
block|,
endif|#
directive|endif
endif|MICOM
ifdef|#
directive|ifdef
name|DN11
block|{
literal|"ACU"
block|,
literal|"dn11"
block|,
name|Acuopn
block|,
name|dnopn
block|,
name|dncls
block|}
block|,
endif|#
directive|endif
endif|DN11
ifdef|#
directive|ifdef
name|HAYES
block|{
literal|"ACU"
block|,
literal|"hayes"
block|,
name|Acuopn
block|,
name|hyspopn
block|,
name|hyscls
block|}
block|,
block|{
literal|"ACU"
block|,
literal|"hayespulse"
block|,
name|Acuopn
block|,
name|hyspopn
block|,
name|hyscls
block|}
block|,
block|{
literal|"ACU"
block|,
literal|"hayestone"
block|,
name|Acuopn
block|,
name|hystopn
block|,
name|hyscls
block|}
block|,
block|{
literal|"WATS"
block|,
literal|"hayestone"
block|,
name|Acuopn
block|,
name|hystopn
block|,
name|hyscls
block|}
block|,
endif|#
directive|endif
endif|HAYES
ifdef|#
directive|ifdef
name|HAYES2400
block|{
literal|"ACU"
block|,
literal|"hayes2400"
block|,
name|Acuopn
block|,
name|hyspopn24
block|,
name|hyscls24
block|}
block|,
block|{
literal|"ACU"
block|,
literal|"hayes2400pulse"
block|,
name|Acuopn
block|,
name|hyspopn24
block|,
name|hyscls24
block|}
block|,
block|{
literal|"ACU"
block|,
literal|"hayes2400tone"
block|,
name|Acuopn
block|,
name|hystopn24
block|,
name|hyscls24
block|}
block|,
endif|#
directive|endif
endif|HAYES2400
ifdef|#
directive|ifdef
name|HAYESQ
comment|/* a version of hayes that doesn't use result codes */
block|{
literal|"ACU"
block|,
literal|"hayesq"
block|,
name|Acuopn
block|,
name|hysqpopn
block|,
name|hysqcls
block|}
block|,
block|{
literal|"ACU"
block|,
literal|"hayesqpulse"
block|,
name|Acuopn
block|,
name|hysqpopn
block|,
name|hysqcls
block|}
block|,
block|{
literal|"ACU"
block|,
literal|"hayesqtone"
block|,
name|Acuopn
block|,
name|hysqtopn
block|,
name|hysqcls
block|}
block|,
endif|#
directive|endif
endif|HAYESQ
ifdef|#
directive|ifdef
name|CDS224
block|{
literal|"ACU"
block|,
literal|"cds224"
block|,
name|Acuopn
block|,
name|cdsopn224
block|,
name|cdscls224
block|}
block|,
endif|#
directive|endif
endif|CDS224
ifdef|#
directive|ifdef
name|NOVATION
block|{
literal|"ACU"
block|,
literal|"novation"
block|,
name|Acuopn
block|,
name|novopn
block|,
name|novcls
block|}
block|,
endif|#
directive|endif
endif|NOVATION
ifdef|#
directive|ifdef
name|DF02
block|{
literal|"ACU"
block|,
literal|"DF02"
block|,
name|Acuopn
block|,
name|df2opn
block|,
name|df2cls
block|}
block|,
endif|#
directive|endif
endif|DF02
ifdef|#
directive|ifdef
name|DF112
block|{
literal|"ACU"
block|,
literal|"DF112P"
block|,
name|Acuopn
block|,
name|df12popn
block|,
name|df12cls
block|}
block|,
block|{
literal|"ACU"
block|,
literal|"DF112T"
block|,
name|Acuopn
block|,
name|df12topn
block|,
name|df12cls
block|}
block|,
endif|#
directive|endif
endif|DF112
ifdef|#
directive|ifdef
name|VENTEL
block|{
literal|"ACU"
block|,
literal|"ventel"
block|,
name|Acuopn
block|,
name|ventopn
block|,
name|ventcls
block|}
block|,
endif|#
directive|endif
endif|VENTEL
ifdef|#
directive|ifdef
name|PENRIL
block|{
literal|"ACU"
block|,
literal|"penril"
block|,
name|Acuopn
block|,
name|penopn
block|,
name|pencls
block|}
block|,
endif|#
directive|endif
endif|PENRIL
ifdef|#
directive|ifdef
name|VADIC
block|{
literal|"ACU"
block|,
literal|"vadic"
block|,
name|Acuopn
block|,
name|vadopn
block|,
name|vadcls
block|}
block|,
endif|#
directive|endif
endif|VADIC
ifdef|#
directive|ifdef
name|VA212
block|{
literal|"ACU"
block|,
literal|"va212"
block|,
name|Acuopn
block|,
name|va212opn
block|,
name|va212cls
block|}
block|,
endif|#
directive|endif
endif|VA212
ifdef|#
directive|ifdef
name|VA811S
block|{
literal|"ACU"
block|,
literal|"va811s"
block|,
name|Acuopn
block|,
name|va811opn
block|,
name|va811cls
block|}
block|,
endif|#
directive|endif
endif|VA811S
ifdef|#
directive|ifdef
name|VA820
block|{
literal|"ACU"
block|,
literal|"va820"
block|,
name|Acuopn
block|,
name|va820opn
block|,
name|va820cls
block|}
block|,
block|{
literal|"WATS"
block|,
literal|"va820"
block|,
name|Acuopn
block|,
name|va820opn
block|,
name|va820cls
block|}
block|,
endif|#
directive|endif
endif|VA820
ifdef|#
directive|ifdef
name|RVMACS
block|{
literal|"ACU"
block|,
literal|"rvmacs"
block|,
name|Acuopn
block|,
name|rvmacsopn
block|,
name|rvmacscls
block|}
block|,
endif|#
directive|endif
endif|RVMACS
ifdef|#
directive|ifdef
name|VMACS
block|{
literal|"ACU"
block|,
literal|"vmacs"
block|,
name|Acuopn
block|,
name|vmacsopn
block|,
name|vmacscls
block|}
block|,
endif|#
directive|endif
endif|VMACS
ifdef|#
directive|ifdef
name|SYTEK
block|{
literal|"SYTEK"
block|,
literal|"sytek"
block|,
name|sykopn
block|,
name|nulldev
block|,
name|sykcls
block|}
block|,
endif|#
directive|endif
endif|SYTEK
ifdef|#
directive|ifdef
name|ATT2224
block|{
literal|"ACU"
block|,
literal|"att"
block|,
name|Acuopn
block|,
name|attopn
block|,
name|attcls
block|}
block|,
endif|#
directive|endif
endif|ATT2224
comment|/* Insert new entries before this line */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	nulldev		a null device (returns CF_DIAL)  */
end_comment

begin_macro
name|nulldev
argument_list|()
end_macro

begin_block
block|{
return|return
name|CF_DIAL
return|;
block|}
end_block

begin_comment
comment|/*  *	nodev		a null device (returns CF_NODEV)  */
end_comment

begin_macro
name|nodev
argument_list|()
end_macro

begin_block
block|{
return|return
name|CF_NODEV
return|;
block|}
end_block

begin_comment
comment|/*  * Generic devices look through L-devices and call the CU_open routines for  * appropriate devices.  Some things, like the tcp/ip interface, or direct  * connect, do not use the CU_open entry.  ACUs must search to find the  * right routine to call.  */
end_comment

begin_comment
comment|/*  *	diropn(flds)	connect to hardware line  *  *	return codes:  *> 0  -  file number  -  ok  *		FAIL  -  failed  */
end_comment

begin_expr_stmt
name|diropn
argument_list|(
name|flds
argument_list|)
specifier|register
name|char
operator|*
name|flds
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|dcr
decl_stmt|,
name|status
decl_stmt|;
name|struct
name|Devices
name|dev
decl_stmt|;
name|char
name|dcname
index|[
literal|20
index|]
decl_stmt|;
name|FILE
modifier|*
name|dfp
decl_stmt|;
ifdef|#
directive|ifdef
name|VMSDTR
comment|/* Modem control on vms(works dtr) */
name|int
name|modem_control
decl_stmt|;
name|short
name|iosb
index|[
literal|4
index|]
decl_stmt|;
name|int
name|sys$qiow
parameter_list|()
function_decl|;
comment|/* use this for long reads on vms */
name|int
name|ret
decl_stmt|;
name|long
name|mode
index|[
literal|2
index|]
decl_stmt|;
name|modem_control
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|dfp
operator|=
name|fopen
argument_list|(
name|DEVFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|!=
name|NULL
argument_list|,
literal|"CAN'T OPEN"
argument_list|,
name|DEVFILE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|status
operator|=
name|rddev
argument_list|(
name|dfp
argument_list|,
operator|&
name|dev
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
ifdef|#
directive|ifdef
name|VMSDTR
comment|/* Modem control on vms(works dtr) */
comment|/* If we find MOD in the device type field we go into action */
if|if
condition|(
name|strcmp
argument_list|(
name|dev
operator|.
name|D_type
argument_list|,
literal|"MOD"
argument_list|)
operator|==
name|SAME
condition|)
block|{
name|modem_control
operator|=
literal|1
expr_stmt|;
name|DEBUG
argument_list|(
literal|7
argument_list|,
literal|"Setting Modem control to %d"
argument_list|,
name|modem_control
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|flds
index|[
name|F_CLASS
index|]
argument_list|,
name|dev
operator|.
name|D_class
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
comment|/* 		 * Modem control on vms(works dtr) Take anything in MOD class. 	  	 * It probably should work differently anyway so we can have 		 *  multiple hardwired lines. 		 */
if|if
condition|(
operator|!
name|modem_control
operator|&&
name|strcmp
argument_list|(
name|flds
index|[
name|F_PHONE
index|]
argument_list|,
name|dev
operator|.
name|D_line
argument_list|)
operator|!=
name|SAME
condition|)
else|#
directive|else
else|!VMSDTR
if|if
condition|(
name|strcmp
argument_list|(
name|flds
index|[
name|F_CLASS
index|]
argument_list|,
name|dev
operator|.
name|D_class
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|flds
index|[
name|F_PHONE
index|]
argument_list|,
name|dev
operator|.
name|D_line
argument_list|)
operator|!=
name|SAME
condition|)
endif|#
directive|endif
endif|!VMSDTR
continue|continue;
if|if
condition|(
name|mlock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
operator|!=
name|FAIL
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAIL
condition|)
block|{
name|logent
argument_list|(
literal|"DEVICE"
argument_list|,
literal|"NO"
argument_list|)
expr_stmt|;
return|return
name|CF_NODEV
return|;
block|}
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Open timed out\n"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
return|return
name|CF_DIAL
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
comment|/* For PC Pursuit, it could take a while to call back */
name|alarm
argument_list|(
name|strcmp
argument_list|(
name|flds
index|[
name|F_LINE
index|]
argument_list|,
literal|"PCP"
argument_list|)
condition|?
literal|10
else|:
name|MAXMSGTIME
operator|*
literal|4
argument_list|)
expr_stmt|;
name|getnextfd
argument_list|()
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Opening %s\n"
argument_list|,
name|dcname
argument_list|)
expr_stmt|;
name|dcr
operator|=
name|open
argument_list|(
name|dcname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* read/write */
ifdef|#
directive|ifdef
name|VMSDTR
comment|/* Modem control on vms(works dtr) */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|modem_control
condition|)
block|{
comment|/* Did we have MOD in the device type field ? */
comment|/* Sense the current terminal setup and save it */
if|if
condition|(
operator|(
name|ret
operator|=
name|sys$qiow
argument_list|(
name|_$EFN
argument_list|,
operator|(
name|fd_fab_pointer
index|[
name|dcr
index|]
operator|->
name|fab
operator|)
operator|.
name|fab$l_stv
argument_list|,
name|IO$_SENSEMODE
argument_list|,
name|iosb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|SS$_NORMAL
condition|)
block|{
name|DEBUG
argument_list|(
literal|7
argument_list|,
literal|"ret status on sense failed on Modem sense=%x<"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|CF_DIAL
return|;
block|}
name|mode
index|[
literal|1
index|]
operator||=
name|TT$M_MODEM
expr_stmt|;
comment|/* Or in modem control(DTR) */
comment|/* Now set the new terminal characteristics */
comment|/* This is temporary and will go away when we let go of it */
if|if
condition|(
operator|(
name|ret
operator|=
name|sys$qiow
argument_list|(
name|_$EFN
argument_list|,
operator|(
name|fd_fab_pointer
index|[
name|dcr
index|]
operator|->
name|fab
operator|)
operator|.
name|fab$l_stv
argument_list|,
name|IO$_SETMODE
argument_list|,
name|iosb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|SS$_NORMAL
condition|)
block|{
name|DEBUG
argument_list|(
literal|7
argument_list|,
literal|"ret status on sense failed on Modem setup=%x<"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|CF_DIAL
return|;
block|}
block|}
endif|#
directive|endif
endif|VMSDTR
name|next_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcr
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EACCES
condition|)
name|logent
argument_list|(
name|dev
operator|.
name|D_line
argument_list|,
literal|"CANT OPEN"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"OPEN FAILED: errno %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
return|return
name|CF_DIAL
return|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixline
argument_list|(
name|dcr
argument_list|,
name|dev
operator|.
name|D_speed
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"FIXLINE FAILED\n"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
return|return
name|CF_DIAL
return|;
block|}
name|strcpy
argument_list|(
name|devSel
argument_list|,
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
comment|/* for latter unlock */
name|CU_end
operator|=
name|dircls
expr_stmt|;
return|return
name|dcr
return|;
block|}
end_block

begin_expr_stmt
name|dircls
argument_list|(
name|fd
argument_list|)
specifier|register
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|devSel
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	open an ACU and dial the number.  The condevs table  *	will be searched until a dialing unit is found that is free.  *  *	return codes:>0 - file number - o.k.  *			FAIL - failed  */
end_comment

begin_decl_stmt
name|char
name|devSel
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for later unlock() */
end_comment

begin_expr_stmt
name|Acuopn
argument_list|(
name|flds
argument_list|)
specifier|register
name|char
operator|*
name|flds
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|phone
index|[
name|MAXPH
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|struct
name|condev
modifier|*
name|cd
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|,
name|acustatus
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|dfp
decl_stmt|;
name|struct
name|Devices
name|dev
decl_stmt|;
name|int
name|retval
init|=
name|CF_NODEV
decl_stmt|;
name|char
name|nobrand
index|[
name|MAXPH
index|]
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|exphone
argument_list|(
name|flds
index|[
name|F_PHONE
index|]
argument_list|,
name|phone
argument_list|)
expr_stmt|;
if|if
condition|(
name|snccmp
argument_list|(
name|flds
index|[
name|F_LINE
index|]
argument_list|,
literal|"LOCAL"
argument_list|)
operator|==
name|SAME
condition|)
name|line
operator|=
literal|"ACU"
expr_stmt|;
else|else
name|line
operator|=
name|flds
index|[
name|F_LINE
index|]
expr_stmt|;
name|devSel
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nobrand
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Dialing %s\n"
argument_list|,
name|phone
argument_list|)
expr_stmt|;
name|dfp
operator|=
name|fopen
argument_list|(
name|DEVFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|!=
name|NULL
argument_list|,
literal|"Can't open"
argument_list|,
name|DEVFILE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|acustatus
operator|=
literal|0
expr_stmt|;
comment|/* none found, none locked */
while|while
condition|(
name|rddev
argument_list|(
name|dfp
argument_list|,
operator|&
name|dev
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* 		 * for each ACU L.sys line, try at most twice 		 * (TRYCALLS) to establish carrier.  The old way tried every 		 * available dialer, which on big sites takes forever! 		 * Sites with a single auto-dialer get one try. 		 * Sites with multiple dialers get a try on each of two 		 * different dialers. 		 * To try 'harder' to connect to a remote site, 		 * use multiple L.sys entries. 		 */
if|if
condition|(
name|acustatus
operator|>
name|TRYCALLS
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|flds
index|[
name|F_CLASS
index|]
argument_list|,
name|dev
operator|.
name|D_class
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
if|if
condition|(
name|snccmp
argument_list|(
name|line
argument_list|,
name|dev
operator|.
name|D_type
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
if|if
condition|(
name|dev
operator|.
name|D_brand
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|logent
argument_list|(
literal|"Acuopn"
argument_list|,
literal|"No 'brand' name on ACU"
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|cd
operator|=
name|condevs
init|;
name|cd
operator|->
name|CU_meth
operator|!=
name|NULL
condition|;
name|cd
operator|++
control|)
block|{
if|if
condition|(
name|snccmp
argument_list|(
name|line
argument_list|,
name|cd
operator|->
name|CU_meth
argument_list|)
operator|==
name|SAME
condition|)
block|{
if|if
condition|(
name|snccmp
argument_list|(
name|dev
operator|.
name|D_brand
argument_list|,
name|cd
operator|->
name|CU_brand
argument_list|)
operator|==
name|SAME
condition|)
break|break;
name|strncpy
argument_list|(
name|nobrand
argument_list|,
name|dev
operator|.
name|D_brand
argument_list|,
sizeof|sizeof
name|nobrand
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|acustatus
operator|<
literal|1
condition|)
name|acustatus
operator|=
literal|1
expr_stmt|;
comment|/* has been found */
if|if
condition|(
name|mlock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
operator|==
name|FAIL
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DIALINOUT
ifdef|#
directive|ifdef
name|ALLACUINOUT
if|if
condition|(
literal|1
condition|)
block|{
else|#
directive|else
else|!ALLACUINOUT
if|if
condition|(
name|snccmp
argument_list|(
literal|"inout"
argument_list|,
name|dev
operator|.
name|D_calldev
argument_list|)
operator|==
name|SAME
condition|)
block|{
endif|#
directive|endif
endif|!ALLACUINOUT
if|if
condition|(
name|disable
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|delock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|reenable
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|DIALINOUT
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Using %s\n"
argument_list|,
name|cd
operator|->
name|CU_brand
argument_list|)
expr_stmt|;
name|acustatus
operator|++
expr_stmt|;
name|fd
operator|=
operator|(
operator|*
operator|(
name|cd
operator|->
name|CU_open
operator|)
operator|)
operator|(
name|phone
operator|,
name|flds
operator|,
operator|&
name|dev
operator|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|CU_end
operator|=
name|cd
operator|->
name|CU_clos
expr_stmt|;
comment|/* point CU_end at close func */
name|fclose
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|devSel
argument_list|,
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
comment|/* save for later unlock() */
return|return
name|fd
return|;
block|}
else|else
name|delock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CF_DIAL
expr_stmt|;
block|}
name|fclose
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|acustatus
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nobrand
index|[
literal|0
index|]
condition|)
name|logent
argument_list|(
name|nobrand
argument_list|,
literal|"unsupported ACU type"
argument_list|)
expr_stmt|;
else|else
name|logent
argument_list|(
literal|"L-devices"
argument_list|,
literal|"No appropriate ACU"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acustatus
operator|==
literal|1
condition|)
name|logent
argument_list|(
literal|"DEVICE"
argument_list|,
literal|"NO"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/*  * intervaldelay:  delay execution for numerator/denominator seconds.  */
ifdef|#
directive|ifdef
name|INTERVALTIMER
include|#
directive|include
file|<sys/time.h>
define|#
directive|define
name|uucpdelay
parameter_list|(
name|num
parameter_list|,
name|denom
parameter_list|)
value|intervaldelay(num,denom)
name|intervaldelay
argument_list|(
argument|num
argument_list|,
argument|denom
argument_list|)
name|int
name|num
decl_stmt|,
name|denom
decl_stmt|;
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|num
operator|/
name|denom
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|num
operator|*
literal|1000000L
operator|/
name|denom
operator|)
operator|%
literal|1000000L
expr_stmt|;
operator|(
name|void
operator|)
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|INTERVALTIMER
ifdef|#
directive|ifdef
name|FASTTIMER
define|#
directive|define
name|uucpdelay
parameter_list|(
name|num
parameter_list|,
name|denom
parameter_list|)
value|nap(60*num/denom)
comment|/*	Sleep in increments of 60ths of second.	*/
name|nap
argument_list|(
name|time
argument_list|)
specifier|register
name|int
name|time
expr_stmt|;
block|{
specifier|static
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|fd
operator|==
literal|0
condition|)
name|fd
operator|=
name|open
argument_list|(
name|FASTTIMER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|time
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|FASTTIMER
ifdef|#
directive|ifdef
name|FTIME
define|#
directive|define
name|uucpdelay
parameter_list|(
name|num
parameter_list|,
name|denom
parameter_list|)
value|ftimedelay(1000*num/denom)
name|ftimedelay
argument_list|(
argument|n
argument_list|)
block|{
specifier|static
name|struct
name|timeb
name|loctime
decl_stmt|;
specifier|register
name|i
operator|=
name|loctime
operator|.
name|millitm
expr_stmt|;
name|ftime
argument_list|(
operator|&
name|loctime
argument_list|)
expr_stmt|;
while|while
condition|(
name|abs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|loctime
operator|.
name|millitm
operator|-
name|i
argument_list|)
argument_list|)
operator|<
name|n
condition|)
name|ftime
argument_list|(
operator|&
name|loctime
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|FTIME
ifdef|#
directive|ifdef
name|BUSYLOOP
define|#
directive|define
name|uucpdelay
parameter_list|(
name|num
parameter_list|,
name|denom
parameter_list|)
value|busyloop(CPUSPEED*num/denom)
define|#
directive|define
name|CPUSPEED
value|1000000
comment|/* VAX 780 is 1MIPS */
define|#
directive|define
name|DELAY
parameter_list|(
name|n
parameter_list|)
value|{ register long N = (n); while (--N> 0); }
name|busyloop
argument_list|(
argument|n
argument_list|)
block|{
name|DELAY
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|BUSYLOOP
name|slowrite
argument_list|(
name|fd
argument_list|,
name|str
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
block|{
name|DEBUG
argument_list|(
literal|6
argument_list|,
literal|"slowrite "
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
name|DEBUG
argument_list|(
literal|6
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
name|uucpdelay
argument_list|(
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* delay 1/10 second */
name|write
argument_list|(
name|fd
argument_list|,
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
name|DEBUG
argument_list|(
literal|6
argument_list|,
literal|"\n"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|BSPEED
value|B150
comment|/*  *	send a break  */
name|genbrk
argument_list|(
name|fn
argument_list|,
name|bnulls
argument_list|)
specifier|register
name|int
name|fn
operator|,
name|bnulls
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|USG
if|if
condition|(
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TCSBRK
argument_list|,
name|STBNULL
argument_list|)
operator|<
literal|0
condition|)
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"break TCSBRK %s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
else|!USG
ifdef|#
directive|ifdef
name|TIOCSBRK
if|if
condition|(
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCSBRK
argument_list|,
name|STBNULL
argument_list|)
operator|<
literal|0
condition|)
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"break TIOCSBRK %s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCCBRK
name|uucpdelay
argument_list|(
name|bnulls
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCCBRK
argument_list|,
name|STBNULL
argument_list|)
operator|<
literal|0
condition|)
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"break TIOCCBRK %s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TIOCCBRK
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"ioctl %f second break\n"
argument_list|,
operator|(
name|float
operator|)
name|bnulls
operator|/
literal|10
argument_list|)
expr_stmt|;
else|#
directive|else
else|!TIOCSBRK
name|struct
name|sgttyb
name|ttbuf
decl_stmt|;
specifier|register
name|int
name|sospeed
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
operator|<
literal|0
condition|)
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"break TIOCGETP %s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|sospeed
operator|=
name|ttbuf
operator|.
name|sg_ospeed
expr_stmt|;
name|ttbuf
operator|.
name|sg_ospeed
operator|=
name|BSPEED
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
operator|<
literal|0
condition|)
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"break TIOCSETP %s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fn
argument_list|,
literal|"\0\0\0\0\0\0\0\0\0\0\0\0"
argument_list|,
name|bnulls
argument_list|)
operator|!=
name|bnulls
condition|)
block|{
name|badbreak
label|:
name|logent
argument_list|(
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|"BAD WRITE genbrk"
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|Sjbuf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|ttbuf
operator|.
name|sg_ospeed
operator|=
name|sospeed
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
operator|<
literal|0
condition|)
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"break ioctl %s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fn
argument_list|,
literal|"@"
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|badbreak
goto|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"sent BREAK nulls - %d\n"
argument_list|,
name|bnulls
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|!TIOCSBRK
endif|#
directive|endif
endif|!USG
block|}
ifdef|#
directive|ifdef
name|DIALINOUT
comment|/* DIALIN/OUT CODE (WLS) */
comment|/*  * disable and reenable:  allow a single line to be use for dialin/dialout  *  */
name|char
name|enbdev
index|[
literal|16
index|]
decl_stmt|;
name|disable
argument_list|(
name|dev
argument_list|)
specifier|register
name|char
operator|*
name|dev
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|rdev
decl_stmt|;
comment|/* strip off directory prefixes */
name|rdev
operator|=
name|dev
expr_stmt|;
while|while
condition|(
operator|*
name|rdev
condition|)
name|rdev
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|rdev
operator|>=
name|dev
operator|&&
operator|*
name|rdev
operator|!=
literal|'/'
condition|)
empty_stmt|;
name|rdev
operator|++
expr_stmt|;
if|if
condition|(
name|enbdev
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|enbdev
argument_list|,
name|rdev
argument_list|)
operator|==
name|SAME
condition|)
return|return
name|SUCCESS
return|;
comment|/* already disabled */
name|delock
argument_list|(
name|enbdev
argument_list|)
expr_stmt|;
name|reenable
argument_list|()
expr_stmt|;
comment|/* else, reenable the old one */
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Disable %s\n"
argument_list|,
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|enbcall
argument_list|(
literal|"disable"
argument_list|,
name|rdev
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
name|strcpy
argument_list|(
name|enbdev
argument_list|,
name|rdev
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
name|reenable
argument_list|()
block|{
if|if
condition|(
name|enbdev
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Reenable %s\n"
argument_list|,
name|enbdev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|enbcall
argument_list|(
literal|"enable"
argument_list|,
name|enbdev
argument_list|)
expr_stmt|;
name|enbdev
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|enbcall
argument_list|(
argument|type
argument_list|,
argument|dev
argument_list|)
name|char
modifier|*
name|type
decl_stmt|,
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|fildes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|FILE
modifier|*
name|fil
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|pipe
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|DIALINOUT
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|" %s"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|" %s\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* for chown(uid()) in acu program */
name|execl
argument_list|(
name|DIALINOUT
argument_list|,
literal|"acu"
argument_list|,
name|type
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
return|return
name|FAIL
return|;
name|close
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fil
operator|=
name|fdopen
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fil
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD4_2
name|setlinebuf
argument_list|(
name|fil
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD4_2
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fil
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"ACUCNTRL: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
name|pid
condition|)
empty_stmt|;
name|fclose
argument_list|(
name|fil
argument_list|)
expr_stmt|;
return|return
name|status
condition|?
name|FAIL
else|:
name|SUCCESS
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|DIALINOUT
end_endif

end_unit

