begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pk1.c	5.5 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"pk.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_2
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
endif|BSD4_2
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<eunice/eunice.h>
end_include

begin_include
include|#
directive|include
file|<vms/iodef.h>
end_include

begin_include
include|#
directive|include
file|<vms/ssdef.h>
end_include

begin_decl_stmt
name|int
name|iomask
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|VMS
end_endif

begin_define
define|#
directive|define
name|PKMAXSTMSG
value|40
end_define

begin_define
define|#
directive|define
name|PKTIME
value|25
end_define

begin_define
define|#
directive|define
name|CONNODATA
value|10
end_define

begin_define
define|#
directive|define
name|NTIMEOUT
value|10
end_define

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Retries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|jmp_buf
name|Sjbuf
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|Connodata
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Ntimeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * packet driver support routines  *  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pack
modifier|*
name|pklines
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * start initial synchronization.  */
end_comment

begin_function
name|struct
name|pack
modifier|*
name|pkopen
parameter_list|(
name|ifn
parameter_list|,
name|ofn
parameter_list|)
name|int
name|ifn
decl_stmt|,
name|ofn
decl_stmt|;
block|{
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|++
name|pkactive
operator|>=
name|NPLINES
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|pk
operator|=
operator|(
expr|struct
name|pack
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pack
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|pk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pack
argument_list|)
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_ifn
operator|=
name|ifn
expr_stmt|;
name|pk
operator|->
name|p_ofn
operator|=
name|ofn
expr_stmt|;
name|pk
operator|->
name|p_xsize
operator|=
name|pk
operator|->
name|p_rsize
operator|=
name|PACKSIZE
expr_stmt|;
name|pk
operator|->
name|p_rwindow
operator|=
name|pk
operator|->
name|p_swindow
operator|=
name|WINDOWS
expr_stmt|;
comment|/*  allocate input windows */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pk
operator|->
name|p_rwindow
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|pk
operator|->
name|p_xsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|pk
operator|->
name|p_rwindow
operator|=
name|i
expr_stmt|;
comment|/* start synchronization */
name|pk
operator|->
name|p_msg
operator|=
name|pk
operator|->
name|p_rmsg
operator|=
name|M_INITA
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPLINES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pklines
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|pklines
index|[
name|i
index|]
operator|=
name|pk
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|NPLINES
condition|)
return|return
name|NULL
return|;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PKMAXSTMSG
condition|;
name|i
operator|++
control|)
block|{
name|pkgetpack
argument_list|(
name|pk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|LIVE
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|PKMAXSTMSG
condition|)
return|return
name|NULL
return|;
name|pkreset
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|pk
return|;
block|}
end_function

begin_comment
comment|/*  * input framing and block checking.  * frame layout for most devices is:  *  *	S|K|X|Y|C|Z|  ... data ... |  *  *	where 	S	== initial synch byte  *		K	== encoded frame size (indexes pksizes[])  *		X, Y	== block check bytes  *		C	== control byte  *		Z	== XOR of header (K^X^Y^C)  *		data	== 0 or more data bytes  *  */
end_comment

begin_decl_stmt
name|int
name|pksizes
index|[]
init|=
block|{
literal|1
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|,
literal|256
block|,
literal|512
block|,
literal|1024
block|,
literal|2048
block|,
literal|4096
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GETRIES
value|5
end_define

begin_comment
comment|/*  * Pseudo-dma byte collection.  */
end_comment

begin_macro
name|pkgetpack
argument_list|(
argument|ipk
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pack
modifier|*
name|ipk
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|k
decl_stmt|,
name|tries
decl_stmt|,
name|noise
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
specifier|register
name|struct
name|header
modifier|*
name|h
decl_stmt|;
name|unsigned
name|short
name|sum
decl_stmt|;
name|int
name|ifn
decl_stmt|;
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
name|char
name|hdchk
decl_stmt|;
name|pk
operator|=
name|ipk
expr_stmt|;
if|if
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|DOWN
operator|)
operator|||
name|Connodata
operator|>
name|CONNODATA
operator|||
name|Ntimeout
operator|>
name|NTIMEOUT
condition|)
name|pkfail
argument_list|()
expr_stmt|;
name|ifn
operator|=
name|pk
operator|->
name|p_ifn
expr_stmt|;
comment|/* find HEADER */
for|for
control|(
name|tries
operator|=
literal|0
operator|,
name|noise
operator|=
literal|0
init|;
name|tries
operator|<
name|GETRIES
condition|;
control|)
block|{
name|p
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|pk
operator|->
name|p_ihbuf
expr_stmt|;
if|if
condition|(
name|pkcget
argument_list|(
name|ifn
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|SYN
condition|)
block|{
if|if
condition|(
name|pkcget
argument_list|(
name|ifn
argument_list|,
name|p
argument_list|,
name|HDRSIZ
operator|-
literal|1
argument_list|)
operator|==
name|SUCCESS
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|noise
operator|++
operator|<
operator|(
literal|3
operator|*
name|pk
operator|->
name|p_rsize
operator|)
condition|)
continue|continue;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Noisy line - set up RXMIT"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|noise
operator|=
literal|0
expr_stmt|;
block|}
comment|/* set up retransmit or REJ */
name|tries
operator|++
expr_stmt|;
name|Retries
operator|++
expr_stmt|;
name|pk
operator|->
name|p_msg
operator||=
name|pk
operator|->
name|p_rmsg
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_msg
operator|==
literal|0
condition|)
name|pk
operator|->
name|p_msg
operator||=
name|M_RR
expr_stmt|;
if|if
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|LIVE
operator|)
operator|==
name|LIVE
condition|)
name|pk
operator|->
name|p_state
operator||=
name|RXMIT
expr_stmt|;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
name|SYN
condition|)
continue|continue;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|pkcget
argument_list|(
name|ifn
argument_list|,
name|p
argument_list|,
name|HDRSIZ
operator|-
literal|1
argument_list|)
operator|==
name|SUCCESS
condition|)
break|break;
block|}
if|if
condition|(
name|tries
operator|>=
name|GETRIES
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"tries = %d\n"
argument_list|,
name|tries
argument_list|)
expr_stmt|;
name|pkfail
argument_list|()
expr_stmt|;
block|}
name|Connodata
operator|++
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|header
operator|*
operator|)
operator|&
name|pk
operator|->
name|p_ihbuf
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|h
expr_stmt|;
name|hdchk
operator|=
name|p
index|[
literal|1
index|]
operator|^
name|p
index|[
literal|2
index|]
operator|^
name|p
index|[
literal|3
index|]
operator|^
name|p
index|[
literal|4
index|]
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|sum
operator|=
operator|(
name|unsigned
operator|)
operator|*
name|p
operator|++
operator|&
literal|0377
expr_stmt|;
name|sum
operator||=
operator|(
name|unsigned
operator|)
operator|*
name|p
operator|<<
literal|8
expr_stmt|;
name|h
operator|->
name|sum
operator|=
name|sum
expr_stmt|;
name|DEBUG
argument_list|(
literal|7
argument_list|,
literal|"rec h->cntl 0%o\n"
argument_list|,
name|h
operator|->
name|cntl
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|k
operator|=
name|h
operator|->
name|ksize
expr_stmt|;
if|if
condition|(
name|hdchk
operator|!=
name|h
operator|->
name|ccntl
condition|)
block|{
comment|/* bad header */
name|DEBUG
argument_list|(
literal|7
argument_list|,
literal|"bad header 0%o,"
argument_list|,
name|hdchk
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|7
argument_list|,
literal|"h->ccntl 0%o\n"
argument_list|,
name|h
operator|->
name|ccntl
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|==
literal|9
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|sum
operator|+
name|h
operator|->
name|cntl
operator|)
operator|&
literal|0xffff
operator|)
operator|==
name|CHECK
condition|)
block|{
name|pkcntl
argument_list|(
name|h
operator|->
name|cntl
argument_list|,
name|pk
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|7
argument_list|,
literal|"state - 0%o\n"
argument_list|,
name|pk
operator|->
name|p_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  bad header */
name|pk
operator|->
name|p_state
operator||=
name|BADFRAME
expr_stmt|;
name|DEBUG
argument_list|(
literal|7
argument_list|,
literal|"bad header (k==9) 0%o\n"
argument_list|,
name|h
operator|->
name|cntl
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|k
operator|&&
name|pksizes
index|[
name|k
index|]
operator|==
name|pk
operator|->
name|p_rsize
condition|)
block|{
name|pk
operator|->
name|p_rpr
operator|=
name|h
operator|->
name|cntl
operator|&
name|MOD8
expr_stmt|;
name|pksack
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|Connodata
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|pk
operator|->
name|p_ipool
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
literal|7
argument_list|,
literal|"bp NULL %s\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|pk
operator|->
name|p_ipool
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|*
name|bp
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
if|if
condition|(
name|pkcget
argument_list|(
name|pk
operator|->
name|p_ifn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|,
name|pk
operator|->
name|p_rsize
argument_list|)
operator|==
name|SUCCESS
condition|)
name|pkdata
argument_list|(
name|h
operator|->
name|cntl
argument_list|,
name|h
operator|->
name|sum
argument_list|,
name|pk
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
name|Ntimeout
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|pkdata
argument_list|(
argument|c
argument_list|,
argument|sum
argument_list|,
argument|pk
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|sum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|x
expr_stmt|;
name|int
name|t
decl_stmt|;
name|char
name|m
decl_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|DRAINO
operator|||
operator|!
operator|(
name|pk
operator|->
name|p_state
operator|&
name|LIVE
operator|)
condition|)
block|{
name|pk
operator|->
name|p_msg
operator||=
name|pk
operator|->
name|p_rmsg
expr_stmt|;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|t
operator|=
name|next
index|[
name|pk
operator|->
name|p_pr
index|]
expr_stmt|;
for|for
control|(
name|x
operator|=
name|pk
operator|->
name|p_pr
init|;
name|x
operator|!=
name|t
condition|;
name|x
operator|=
operator|(
name|x
operator|-
literal|1
operator|)
operator|&
literal|7
control|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|==
literal|0
condition|)
goto|goto
name|slot
goto|;
block|}
name|drop
label|:
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
return|return;
name|slot
label|:
name|m
operator|=
name|mask
index|[
name|x
index|]
expr_stmt|;
name|pk
operator|->
name|p_imap
operator||=
name|m
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
name|c
expr_stmt|;
name|pk
operator|->
name|p_isum
index|[
name|x
index|]
operator|=
name|sum
expr_stmt|;
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|bp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * setup input transfers  */
end_comment

begin_define
define|#
directive|define
name|PKMAXBUF
value|128
end_define

begin_comment
comment|/*  * Start transmission on output device associated with pk.  * For asynch devices (t_line==1) framing is  * imposed.  For devices with framing and crc  * in the driver (t_line==2) the transfer is  * passed on to the driver.  */
end_comment

begin_expr_stmt
name|pkxstart
argument_list|(
name|pk
argument_list|,
name|cntl
argument_list|,
name|x
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|cntl
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|short
name|checkword
decl_stmt|;
name|char
name|hdchk
decl_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|pk
operator|->
name|p_ohbuf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SYN
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|hdchk
operator|=
literal|9
expr_stmt|;
name|checkword
operator|=
name|cntl
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|hdchk
operator|=
name|pk
operator|->
name|p_lpsize
expr_stmt|;
name|checkword
operator|=
name|pk
operator|->
name|p_osum
index|[
name|x
index|]
operator|^
call|(
name|unsigned
call|)
argument_list|(
name|cntl
operator|&
literal|0377
argument_list|)
expr_stmt|;
block|}
name|checkword
operator|=
name|CHECK
operator|-
name|checkword
expr_stmt|;
operator|*
name|p
operator|=
name|checkword
expr_stmt|;
name|hdchk
operator|^=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
name|checkword
operator|>>
literal|8
expr_stmt|;
name|hdchk
operator|^=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
name|cntl
expr_stmt|;
name|hdchk
operator|^=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
name|hdchk
expr_stmt|;
comment|/*  writes  */
name|DEBUG
argument_list|(
literal|7
argument_list|,
literal|"send 0%o\n"
argument_list|,
name|cntl
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|pk
operator|->
name|p_ohbuf
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|pk
operator|->
name|p_ofn
argument_list|,
name|p
argument_list|,
name|HDRSIZ
argument_list|)
operator|!=
name|HDRSIZ
condition|)
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"PKXSTART write failed"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|Sjbuf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
name|buf
index|[
name|PKMAXBUF
operator|+
name|HDRSIZ
index|]
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|b
operator|=
name|buf
init|;
name|i
operator|<
name|HDRSIZ
condition|;
name|i
operator|++
control|)
operator|*
name|b
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|pk
operator|->
name|p_ob
index|[
name|x
index|]
init|;
name|i
operator|<
name|pk
operator|->
name|p_xsize
condition|;
name|i
operator|++
control|)
operator|*
name|b
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pk
operator|->
name|p_ofn
argument_list|,
name|buf
argument_list|,
name|pk
operator|->
name|p_xsize
operator|+
name|HDRSIZ
argument_list|)
operator|!=
operator|(
name|HDRSIZ
operator|+
name|pk
operator|->
name|p_xsize
operator|)
condition|)
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"PKXSTART write failed"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|Sjbuf
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
name|Connodata
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pk
operator|->
name|p_msg
condition|)
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pkmove
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|count
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|B_WRITE
condition|)
block|{
name|s
operator|=
name|p2
expr_stmt|;
name|d
operator|=
name|p1
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|p1
expr_stmt|;
name|d
operator|=
name|p2
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/***  *	pkcget(fn, b, n)	get n characters from input  *	char *b;		- buffer for characters  *	int fn;			- file descriptor  *	int n;			- requested number of characters  *  *	return codes:  *		n - number of characters returned  *		0 - end of file  */
end_comment

begin_decl_stmt
name|jmp_buf
name|Getjbuf
decl_stmt|;
end_decl_stmt

begin_macro
name|cgalarm
argument_list|()
end_macro

begin_block
block|{
name|longjmp
argument_list|(
name|Getjbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pkcget
argument_list|(
argument|fn
argument_list|,
argument|b
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|ret
decl_stmt|;
specifier|extern
name|int
name|linebaudrate
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD4_2
name|long
name|r
decl_stmt|,
name|itime
init|=
literal|100000L
decl_stmt|;
comment|/* guess it's been 1/10th second since we 				    last read the line */
name|struct
name|timeval
name|tv
decl_stmt|;
endif|#
directive|endif
endif|BSD4_2
ifdef|#
directive|ifdef
name|VMS
name|short
name|iosb
index|[
literal|4
index|]
decl_stmt|;
name|int
name|SYS$QioW
parameter_list|()
function_decl|;
comment|/* use this for long reads on vms */
endif|#
directive|endif
endif|VMS
if|if
condition|(
name|setjmp
argument_list|(
name|Getjbuf
argument_list|)
condition|)
block|{
name|Ntimeout
operator|++
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"pkcget: alarm %d\n"
argument_list|,
name|Ntimeout
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|cgalarm
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|PKTIME
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD4_2
if|if
condition|(
name|linebaudrate
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|n
operator|*
literal|100000L
expr_stmt|;
name|r
operator|=
name|r
operator|/
name|linebaudrate
expr_stmt|;
name|r
operator|=
operator|(
name|r
operator|*
literal|100
operator|)
operator|-
name|itime
expr_stmt|;
name|itime
operator|=
literal|0
expr_stmt|;
comment|/* we predict that more than 1/50th of a 			   second will go by before the read will 			   give back all that we want. */
if|if
condition|(
name|r
operator|>
literal|20000
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|r
operator|/
literal|1000000L
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|r
operator|%
literal|1000000L
expr_stmt|;
name|DEBUG
argument_list|(
literal|11
argument_list|,
literal|"PKCGET stall for %d"
argument_list|,
name|tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|11
argument_list|,
literal|".%06d sec\n"
argument_list|,
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|BSD4_2
ifndef|#
directive|ifndef
name|VMS
name|ret
operator|=
name|read
argument_list|(
name|fn
argument_list|,
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
else|VMS
name|_$Cancel_IO_On_Signal
operator|=
name|FD_FAB_Pointer
index|[
name|fn
index|]
expr_stmt|;
name|ret
operator|=
name|SYS$QioW
argument_list|(
name|_$EFN
argument_list|,
operator|(
name|FD_FAB_Pointer
index|[
name|fn
index|]
operator|->
name|fab
operator|)
operator|.
name|fab$l_stv
argument_list|,
name|IO$_READVBLK
operator||
name|IO$M_NOFILTR
operator||
name|IO$M_NOECHO
argument_list|,
name|iosb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
name|iomask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_$Cancel_IO_On_Signal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|SS$_NORMAL
condition|)
name|ret
operator|=
name|iosb
index|[
literal|1
index|]
operator|+
name|iosb
index|[
literal|3
index|]
expr_stmt|;
comment|/* get length of transfer */
else|else
name|ret
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|VMS
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|"FAILED pkcget Read"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|Sjbuf
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
name|b
operator|+=
name|ret
expr_stmt|;
name|n
operator|-=
name|ret
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_block

end_unit

