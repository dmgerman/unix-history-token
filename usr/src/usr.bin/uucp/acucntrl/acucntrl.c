begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)acucntrl.c	5.12	(Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  acucntrl - turn around tty line between dialin and dialout  *   * Usage:	acucntrl {enable,disable} /dev/ttydX  *  * History:  *	First written by Allan Wilkes (fisher!allan)  *  *	Modified June 8,1983 by W.Sebok (astrovax!wls) to poke kernel rather  * 	than use kernel hack to turn on/off modem control, using subroutine  *	stolen from program written by Tsutomu Shimomura  *	{astrovax,escher}!tsutomu  *  *	Worked over many times by W.Sebok (i.e. hacked to death)  *  * Operation:  *   disable (i.e. setup for dialing out)  *	(1) check input arguments  *	(2) look in /etc/utmp to check that the line is not in use by another  *	(3) disable modem control on terminal  *	(4) check for carrier on device  *	(5) change owner of device to real id  *	(6) edit /etc/ttys,  changing the first character of the appropriate  *	    line to 0  *	(7) send a hangup to process 1 to poke init to disable getty  *	(8) post uid name in capitals in /etc/utmp to let world know device has  *	    been grabbed  *	(9) make sure that DTR is on  *  *   enable (i.e.) restore for dialin  *	(1) check input arguments  *	(2) look in /etc/utmp to check that the line is not in use by another  *	(3) make sure modem control on terminal is disabled  *	(4) turn off DTR to make sure line is hung up  *	(5) condition line: clear exclusive use and set hangup on close modes  *	(6) turn on modem control  *	(7) edit /etc/ttys,  changing the first character of the appropriate  *	    line to 1  *	(8) send a hangup to process 1 to poke init to enable getty  *	(9) clear uid name for /etc/utmp  */
end_comment

begin_comment
comment|/* #define SENSECARRIER */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DIALINOUT
end_ifdef

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_2
end_ifdef

begin_include
include|#
directive|include
file|<vaxuba/ubavar.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ubavar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* vax */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_define
define|#
directive|define
name|NDZLINE
value|8
end_define

begin_comment
comment|/* lines/dz */
end_comment

begin_define
define|#
directive|define
name|NDHLINE
value|16
end_define

begin_comment
comment|/* lines/dh */
end_comment

begin_define
define|#
directive|define
name|NDMFLINE
value|8
end_define

begin_comment
comment|/* lines/dmf */
end_comment

begin_define
define|#
directive|define
name|DZ11
value|1
end_define

begin_define
define|#
directive|define
name|DH11
value|2
end_define

begin_define
define|#
directive|define
name|DMF
value|3
end_define

begin_define
define|#
directive|define
name|NLVALUE
parameter_list|(
name|val
parameter_list|)
value|(nl[val].n_value)
end_define

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
define|#
directive|define
name|CDEVSW
value|0
block|{
literal|"_cdevsw"
block|}
block|,
define|#
directive|define
name|DZOPEN
value|1
block|{
literal|"_dzopen"
block|}
block|,
define|#
directive|define
name|DZINFO
value|2
block|{
literal|"_dzinfo"
block|}
block|,
define|#
directive|define
name|NDZ11
value|3
block|{
literal|"_dz_cnt"
block|}
block|,
define|#
directive|define
name|DZSCAR
value|4
block|{
literal|"_dzsoftCAR"
block|}
block|,
define|#
directive|define
name|DHOPEN
value|5
block|{
literal|"_dhopen"
block|}
block|,
define|#
directive|define
name|DHINFO
value|6
block|{
literal|"_dhinfo"
block|}
block|,
define|#
directive|define
name|NDH11
value|7
block|{
literal|"_ndh11"
block|}
block|,
define|#
directive|define
name|DHSCAR
value|8
block|{
literal|"_dhsoftCAR"
block|}
block|,
define|#
directive|define
name|DMFOPEN
value|9
block|{
literal|"_dmfopen"
block|}
block|,
define|#
directive|define
name|DMFINFO
value|10
block|{
literal|"_dmfinfo"
block|}
block|,
define|#
directive|define
name|NDMF
value|11
block|{
literal|"_ndmf"
block|}
block|,
define|#
directive|define
name|DMFSCAR
value|12
block|{
literal|"_dmfsoftCAR"
block|}
block|,
block|{
literal|"\0"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ENABLE
value|1
end_define

begin_define
define|#
directive|define
name|DISABLE
value|0
end_define

begin_decl_stmt
name|char
name|Etcutmp
index|[]
init|=
literal|"/etc/utmp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Etcttys
index|[]
init|=
literal|"/etc/ttys"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_3
end_ifdef

begin_decl_stmt
name|FILE
modifier|*
name|ttysfile
decl_stmt|,
modifier|*
name|nttysfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|NEtcttys
index|[]
init|=
literal|"/etc/ttys.new"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|long
name|ftell
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|BSD4_3
end_endif

begin_decl_stmt
name|char
name|Devhome
index|[]
init|=
literal|"/dev"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|usage
index|[]
init|=
literal|"Usage: acucntrl {dis|en}able ttydX\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|utmp
name|utmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|resettty
decl_stmt|,
name|resetmodem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|etcutmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|utmploc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|ttyslnbeg
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NAMSIZ
value|sizeof(utmp.ut_name)
end_define

begin_define
define|#
directive|define
name|LINSIZ
value|sizeof(utmp.ut_line)
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|uname
index|[
name|NAMSIZ
index|]
decl_stmt|,
name|Uname
index|[
name|NAMSIZ
index|]
decl_stmt|;
name|int
name|enable
decl_stmt|;
name|char
modifier|*
name|device
decl_stmt|;
name|int
name|devfile
decl_stmt|;
name|int
name|uid
decl_stmt|,
name|gid
decl_stmt|;
name|off_t
name|lseek
parameter_list|()
function_decl|;
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
comment|/* check input arguments */
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|usage
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* interpret command type */
if|if
condition|(
name|prefix
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"disable"
argument_list|)
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"dialout"
argument_list|)
operator|==
literal|0
condition|)
name|enable
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"enable"
argument_list|)
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"dialin"
argument_list|)
operator|==
literal|0
condition|)
name|enable
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|usage
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|device
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|device
operator|=
operator|(
name|device
operator|==
name|NULL
operator|)
condition|?
name|argv
index|[
literal|2
index|]
else|:
name|device
operator|+
literal|1
expr_stmt|;
comment|/* only recognize devices of the form ttydX */
if|if
condition|(
name|strncmp
argument_list|(
name|device
argument_list|,
literal|"ttyd"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad Device Name %s"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|opnttys
argument_list|(
name|device
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
comment|/* Get nlist info */
name|nlist
argument_list|(
literal|"/vmunix"
argument_list|,
name|nl
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|vax
comment|/* Chdir to /dev */
if|if
condition|(
name|chdir
argument_list|(
name|Devhome
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot chdir to %s: %s\r\n"
argument_list|,
name|Devhome
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Get uid information */
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|p
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|->
name|pw_name
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot get uid name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  to upper case */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|uname
index|[
name|i
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|Uname
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
operator|)
condition|?
operator|(
operator|*
name|p
operator|-
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
operator|)
else|:
operator|*
name|p
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|&&
name|i
operator|<
name|NAMSIZ
condition|)
do|;
comment|/* check to see if line is being used */
if|if
condition|(
operator|(
name|etcutmp
operator|=
name|open
argument_list|(
name|Etcutmp
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On open %s open: %s\n"
argument_list|,
name|Etcutmp
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|etcutmp
argument_list|,
name|utmploc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|etcutmp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|utmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
operator|&&
name|utmp
operator|.
name|ut_line
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|utmp
operator|.
name|ut_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
operator|!
name|upcase
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|,
name|NAMSIZ
argument_list|)
operator|||
operator|(
name|uid
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|,
name|Uname
argument_list|,
name|NAMSIZ
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s in use by %s\n"
argument_list|,
name|device
argument_list|,
name|utmp
operator|.
name|ut_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|sequent
comment|/* Disable modem control */
if|if
condition|(
name|setmodem
argument_list|(
name|device
argument_list|,
name|DISABLE
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to disable modem control\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|!sequent
if|if
condition|(
name|enable
condition|)
block|{
ifdef|#
directive|ifdef
name|sequent
if|if
condition|(
name|setmodem
argument_list|(
name|device
argument_list|,
name|ENABLE
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot Enable modem control\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setmodem
argument_list|(
name|device
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|sequent
ifndef|#
directive|ifndef
name|sequent
if|if
condition|(
operator|(
name|devfile
operator|=
name|open
argument_list|(
name|device
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On open of %s: %s\n"
argument_list|,
name|device
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setmodem
argument_list|(
name|device
argument_list|,
name|resetmodem
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Try one last time to hang up */
if|if
condition|(
name|ioctl
argument_list|(
name|devfile
argument_list|,
operator|(
name|int
operator|)
name|TIOCCDTR
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On TIOCCDTR ioctl: %s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|devfile
argument_list|,
operator|(
name|int
operator|)
name|TIOCNXCL
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot clear Exclusive Use on %s: %s\n"
argument_list|,
name|device
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|devfile
argument_list|,
operator|(
name|int
operator|)
name|TIOCHPCL
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot set hangup on close on %s: %s\n"
argument_list|,
name|device
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|!sequent
name|i
operator|=
name|resetmodem
expr_stmt|;
ifndef|#
directive|ifndef
name|sequent
if|if
condition|(
name|setmodem
argument_list|(
name|device
argument_list|,
name|ENABLE
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot Enable modem control\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setmodem
argument_list|(
name|device
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|sequent
name|resetmodem
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|settys
argument_list|(
name|ENABLE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s already enabled\n"
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pokeinit
argument_list|(
name|device
argument_list|,
name|Uname
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
name|post
argument_list|(
name|device
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|TIOCMGET
argument_list|)
operator|&&
name|defined
argument_list|(
name|SENSECARRIER
argument_list|)
if|if
condition|(
name|uid
operator|!=
literal|0
condition|)
block|{
name|int
name|linestat
init|=
literal|0
decl_stmt|;
comment|/* check for presence of carrier */
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* need time after modem control turnoff */
if|if
condition|(
operator|(
name|devfile
operator|=
name|open
argument_list|(
name|device
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On open of %s: %s\n"
argument_list|,
name|device
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setmodem
argument_list|(
name|device
argument_list|,
name|resetmodem
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|devfile
argument_list|,
name|TIOCMGET
argument_list|,
operator|&
name|linestat
argument_list|)
expr_stmt|;
if|if
condition|(
name|linestat
operator|&
name|TIOCM_CAR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is in use (Carrier On)\n"
argument_list|,
name|device
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setmodem
argument_list|(
name|device
argument_list|,
name|resetmodem
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|devfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|TIOCMGET
comment|/* chown device */
if|if
condition|(
name|chown
argument_list|(
name|device
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot chown %s: %s\n"
argument_list|,
name|device
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
comment|/* poke init */
if|if
condition|(
name|settys
argument_list|(
name|DISABLE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s already disabled\n"
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pokeinit
argument_list|(
name|device
argument_list|,
name|Uname
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
name|post
argument_list|(
name|device
argument_list|,
name|Uname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sequent
comment|/* Disable modem control */
if|if
condition|(
name|setmodem
argument_list|(
name|device
argument_list|,
name|DISABLE
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to disable modem control\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|sequent
if|if
condition|(
operator|(
name|devfile
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On %s open: %s\n"
argument_list|,
name|device
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|devfile
argument_list|,
operator|(
name|int
operator|)
name|TIOCSDTR
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot set DTR on %s: %s\n"
argument_list|,
name|device
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return true if no lower case */
end_comment

begin_expr_stmt
name|upcase
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
operator|*
name|str
operator|,
operator|--
name|len
operator|>=
literal|0
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|*
name|str
operator|>=
literal|'a'
operator|&&
operator|*
name|str
operator|<=
literal|'z'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Post name to public */
end_comment

begin_macro
name|post
argument_list|(
argument|device
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|device
decl_stmt|,
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|utmp
operator|.
name|ut_time
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_line
argument_list|,
name|device
argument_list|,
name|LINSIZ
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|,
name|name
argument_list|,
name|NAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|etcutmp
argument_list|,
name|utmploc
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"on lseek in /etc/utmp: %s"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|etcutmp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|utmp
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"on write in /etc/utmp: %s"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* poke process 1 and wait for it to do its thing */
end_comment

begin_macro
name|pokeinit
argument_list|(
argument|device
argument_list|,
argument|uname
argument_list|,
argument|enable
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|uname
decl_stmt|,
modifier|*
name|device
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enable
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|utmp
name|utmp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|post
argument_list|(
name|device
argument_list|,
name|uname
argument_list|)
expr_stmt|;
comment|/* poke init */
if|if
condition|(
name|kill
argument_list|(
literal|1
argument_list|,
name|SIGHUP
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot send hangup to init process: %s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|settys
argument_list|(
name|resettty
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setmodem
argument_list|(
name|device
argument_list|,
name|resetmodem
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enable
condition|)
return|return;
comment|/* wait till init has responded, clearing the utmp entry */
name|i
operator|=
literal|100
expr_stmt|;
do|do
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|etcutmp
argument_list|,
name|utmploc
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On lseek in /etc/utmp: %s"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|etcutmp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|utmp
argument_list|,
sizeof|sizeof
name|utmp
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On read from /etc/utmp: %s"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|utmp
operator|.
name|ut_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|--
name|i
operator|>
literal|0
condition|)
do|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_3
end_ifdef

begin_comment
comment|/* identify terminal line in ttys */
end_comment

begin_macro
name|opnttys
argument_list|(
argument|device
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|device
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|ndevice
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|char
name|linebuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|ttysfile
operator|=
name|NULL
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ttysfile
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|ttysfile
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|ttysfile
operator|=
name|fopen
argument_list|(
name|Etcttys
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttysfile
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s: %s\n"
argument_list|,
name|Etcttys
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|flock
argument_list|(
name|fileno
argument_list|(
name|ttysfile
argument_list|)
argument_list|,
name|LOCK_NB
operator||
name|LOCK_EX
argument_list|)
operator|<
literal|0
condition|)
do|;
name|nttysfile
operator|=
name|fopen
argument_list|(
name|NEtcttys
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nttysfile
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s: %s\n"
argument_list|,
name|Etcttys
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ndevice
operator|=
name|strlen
argument_list|(
name|device
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BRL4_2
name|utmploc
operator|=
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
expr_stmt|;
else|#
directive|else
else|BRL4_2
name|utmploc
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|BRL4_2
while|while
condition|(
name|fgets
argument_list|(
name|linebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
operator|-
literal|1
argument_list|,
name|ttysfile
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|device
argument_list|,
name|linebuf
argument_list|,
name|ndevice
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|ttyslnbeg
operator|+=
name|strlen
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|!=
literal|'#'
operator|&&
name|linebuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|utmploc
operator|+=
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fputs
argument_list|(
name|linebuf
argument_list|,
name|nttysfile
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On %s write: %s\n"
argument_list|,
name|Etcttys
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s not found in %s\n"
argument_list|,
name|device
argument_list|,
name|Etcttys
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* modify appropriate line in /etc/ttys to turn on/off the device */
end_comment

begin_macro
name|settys
argument_list|(
argument|enable
argument_list|)
end_macro

begin_decl_stmt
name|int
name|enable
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|char
name|lbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ttysfile
argument_list|,
name|ttyslnbeg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|lbuf
argument_list|,
name|BUFSIZ
argument_list|,
name|ttysfile
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On %s read: %s\n"
argument_list|,
name|Etcttys
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* format is now */
comment|/* ttyd0 std.100 dialup on secure # comment */
comment|/* except, 2nd item may have embedded spaces inside quotes, Hubert */
name|cp
operator|=
name|lbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cp
operator|&&
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'"'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'"'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
condition|)
name|cp
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Badly formatted line in /etc/ttys:\n%s"
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|c1
operator|=
operator|*
operator|--
name|cp
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|cp2
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Badly formatted line in /etc/ttys:\n%s"
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|c2
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
name|resettty
operator|=
name|strcmp
argument_list|(
literal|"on"
argument_list|,
name|cp2
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|nttysfile
argument_list|,
literal|"%s%c%s%c%s"
argument_list|,
name|lbuf
argument_list|,
name|c1
argument_list|,
name|enable
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
name|c2
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|nttysfile
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On %s fprintf: %s\n"
argument_list|,
name|NEtcttys
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|lbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
operator|-
literal|1
argument_list|,
name|ttysfile
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fputs
argument_list|(
name|lbuf
argument_list|,
name|nttysfile
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On %s write: %s\n"
argument_list|,
name|NEtcttys
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|enable
operator|^
name|resettty
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|NEtcttys
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|stat
name|statb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|Etcttys
argument_list|,
operator|&
name|statb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fchmod
argument_list|(
name|fileno
argument_list|(
name|nttysfile
argument_list|)
argument_list|,
name|statb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|fchown
argument_list|(
name|fileno
argument_list|(
name|nttysfile
argument_list|)
argument_list|,
name|statb
operator|.
name|st_uid
argument_list|,
name|statb
operator|.
name|st_gid
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|rename
argument_list|(
name|NEtcttys
argument_list|,
name|Etcttys
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|nttysfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ttysfile
argument_list|)
expr_stmt|;
return|return
name|enable
operator|^
name|resettty
return|;
block|}
end_block

begin_else
else|#
directive|else
else|!BSD4_3
end_else

begin_comment
comment|/* identify terminal line in ttys */
end_comment

begin_macro
name|opnttys
argument_list|(
argument|device
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|device
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|ttysfile
decl_stmt|;
specifier|register
name|int
name|ndevice
decl_stmt|,
name|lnsiz
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|char
name|linebuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|ttysfile
operator|=
name|fopen
argument_list|(
name|Etcttys
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttysfile
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s: %s\n"
argument_list|,
name|Etcttys
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ndevice
operator|=
name|strlen
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|ttyslnbeg
operator|=
literal|0
expr_stmt|;
name|utmploc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|linebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
operator|-
literal|1
argument_list|,
name|ttysfile
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|lnsiz
operator|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|linebuf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|device
argument_list|,
operator|&
name|linebuf
index|[
literal|2
index|]
argument_list|,
name|ndevice
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ttysfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sequent
comment|/* Why is the sequent off by one? */
name|utmploc
operator|+=
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|sequent
return|return;
block|}
name|ttyslnbeg
operator|+=
name|lnsiz
expr_stmt|;
name|utmploc
operator|+=
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s not found in %s\n"
argument_list|,
name|device
argument_list|,
name|Etcttys
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* modify appropriate line in /etc/ttys to turn on/off the device */
end_comment

begin_macro
name|settys
argument_list|(
argument|enable
argument_list|)
end_macro

begin_decl_stmt
name|int
name|enable
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ittysfil
decl_stmt|;
name|char
name|out
decl_stmt|,
name|in
decl_stmt|;
name|ittysfil
operator|=
name|open
argument_list|(
name|Etcttys
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ittysfil
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s for output: %s\n"
argument_list|,
name|Etcttys
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|ittysfil
argument_list|,
name|ttyslnbeg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|ittysfil
argument_list|,
operator|&
name|in
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On %s write: %s\n"
argument_list|,
name|Etcttys
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|resettty
operator|=
operator|(
name|in
operator|==
literal|'1'
operator|)
expr_stmt|;
name|out
operator|=
name|enable
condition|?
literal|'1'
else|:
literal|'0'
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|ittysfil
argument_list|,
name|ttyslnbeg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|ittysfil
argument_list|,
operator|&
name|out
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"On %s write: %s\n"
argument_list|,
name|Etcttys
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|ittysfil
argument_list|)
expr_stmt|;
return|return
operator|(
name|in
operator|==
name|out
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|!BSD4_3
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|sequent
end_ifdef

begin_macro
name|setmodem
argument_list|(
argument|ttyline
argument_list|,
argument|enable
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ttyline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enable
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|sysbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|sysbuf
argument_list|,
literal|"/etc/ttyconfig /dev/%s -special %s"
argument_list|,
name|ttyline
argument_list|,
name|enable
condition|?
literal|"-carrier"
else|:
literal|"-nocarrier"
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|sysbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sequent */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_comment
comment|/*  * Excerpted from (June 8, 1983 W.Sebok)  *> ttymodem.c - enable/disable modem control for tty lines.  *>  *> Knows about DZ11s and DH11/DM11s.  *> 23.3.83 - TS  *> modified to know about DMF's  (hasn't been tested) Nov 8, 1984 - WLS  */
end_comment

begin_macro
name|setmodem
argument_list|(
argument|ttyline
argument_list|,
argument|enable
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ttyline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enable
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dev_t
name|dev
decl_stmt|;
name|int
name|kmem
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|line
decl_stmt|,
name|nlines
decl_stmt|,
name|addr
decl_stmt|,
name|tflags
decl_stmt|;
name|int
name|devtype
init|=
literal|0
decl_stmt|;
name|char
name|cflags
decl_stmt|;
name|short
name|sflags
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD4_2
name|int
name|flags
decl_stmt|;
else|#
directive|else
name|short
name|flags
decl_stmt|;
endif|#
directive|endif
name|struct
name|uba_device
modifier|*
name|ubinfo
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|struct
name|cdevsw
name|cdevsw
decl_stmt|;
if|if
condition|(
name|nl
index|[
name|CDEVSW
index|]
operator|.
name|n_type
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No namelist.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|kmem
operator|=
name|open
argument_list|(
literal|"/dev/kmem"
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"/dev/kmem open: %s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|ttyline
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s stat: %s\n"
argument_list|,
name|ttyline
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFCHR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is not a character device.\n"
argument_list|,
name|ttyline
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dev
operator|=
name|statb
operator|.
name|st_rdev
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
operator|&
operator|(
operator|(
operator|(
expr|struct
name|cdevsw
operator|*
operator|)
name|NLVALUE
argument_list|(
name|CDEVSW
argument_list|)
operator|)
index|[
name|major
argument_list|(
name|dev
argument_list|)
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cdevsw
argument_list|,
sizeof|sizeof
name|cdevsw
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|cdevsw
operator|.
name|d_open
argument_list|)
operator|==
name|NLVALUE
argument_list|(
name|DZOPEN
argument_list|)
condition|)
block|{
name|devtype
operator|=
name|DZ11
expr_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|/
name|NDZLINE
expr_stmt|;
name|line
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|%
name|NDZLINE
expr_stmt|;
name|addr
operator|=
operator|(
name|int
operator|)
operator|&
operator|(
operator|(
operator|(
name|int
operator|*
operator|)
name|NLVALUE
argument_list|(
name|DZINFO
argument_list|)
operator|)
index|[
name|unit
index|]
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|NLVALUE
argument_list|(
name|NDZ11
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|cdevsw
operator|.
name|d_open
argument_list|)
operator|==
name|NLVALUE
argument_list|(
name|DHOPEN
argument_list|)
condition|)
block|{
name|devtype
operator|=
name|DH11
expr_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|/
name|NDHLINE
expr_stmt|;
name|line
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|%
name|NDHLINE
expr_stmt|;
name|addr
operator|=
operator|(
name|int
operator|)
operator|&
operator|(
operator|(
operator|(
name|int
operator|*
operator|)
name|NLVALUE
argument_list|(
name|DHINFO
argument_list|)
operator|)
index|[
name|unit
index|]
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|NLVALUE
argument_list|(
name|NDH11
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|cdevsw
operator|.
name|d_open
argument_list|)
operator|==
name|NLVALUE
argument_list|(
name|DMFOPEN
argument_list|)
condition|)
block|{
name|devtype
operator|=
name|DMF
expr_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|/
name|NDMFLINE
expr_stmt|;
name|line
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|%
name|NDMFLINE
expr_stmt|;
name|addr
operator|=
operator|(
name|int
operator|)
operator|&
operator|(
operator|(
operator|(
name|int
operator|*
operator|)
name|NLVALUE
argument_list|(
name|DMFINFO
argument_list|)
operator|)
index|[
name|unit
index|]
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|NLVALUE
argument_list|(
name|NDMF
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Device %s (%d/%d) unknown.\n"
argument_list|,
name|ttyline
argument_list|,
name|major
argument_list|(
name|dev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nlines
argument_list|,
sizeof|sizeof
name|nlines
argument_list|)
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
name|nlines
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sub-device %d does not exist (only %d).\n"
argument_list|,
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ubinfo
argument_list|,
sizeof|sizeof
name|ubinfo
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
operator|&
operator|(
name|ubinfo
operator|->
name|ui_flags
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|flags
argument_list|,
sizeof|sizeof
name|flags
argument_list|)
expr_stmt|;
name|tflags
operator|=
literal|1
operator|<<
name|line
expr_stmt|;
name|resetmodem
operator|=
operator|(
operator|(
name|flags
operator|&
name|tflags
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|flags
operator|=
name|enable
condition|?
operator|(
name|flags
operator|&
operator|~
name|tflags
operator|)
else|:
operator|(
name|flags
operator||
name|tflags
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
operator|&
operator|(
name|ubinfo
operator|->
name|ui_flags
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|flags
argument_list|,
sizeof|sizeof
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|devtype
condition|)
block|{
case|case
name|DZ11
case|:
if|if
condition|(
operator|(
name|addr
operator|=
name|NLVALUE
argument_list|(
name|DZSCAR
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No dzsoftCAR.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cflags
operator|=
name|flags
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|addr
operator|)
index|[
name|unit
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cflags
argument_list|,
sizeof|sizeof
name|cflags
argument_list|)
expr_stmt|;
break|break;
case|case
name|DH11
case|:
if|if
condition|(
operator|(
name|addr
operator|=
name|NLVALUE
argument_list|(
name|DHSCAR
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No dhsoftCAR.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sflags
operator|=
name|flags
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
operator|&
operator|(
operator|(
operator|(
name|short
operator|*
operator|)
name|addr
operator|)
index|[
name|unit
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sflags
argument_list|,
sizeof|sizeof
name|sflags
argument_list|)
expr_stmt|;
break|break;
case|case
name|DMF
case|:
if|if
condition|(
operator|(
name|addr
operator|=
name|NLVALUE
argument_list|(
name|DMFSCAR
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No dmfsoftCAR.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cflags
operator|=
name|flags
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|addr
operator|)
index|[
name|unit
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|flags
argument_list|,
sizeof|sizeof
name|cflags
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown device type\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* vax */
end_comment

begin_expr_stmt
name|prefix
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s1
operator|++
operator|)
operator|==
operator|*
name|s2
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|c
operator|==
literal|'\0'
operator|)
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !DIALINOUT */
end_comment

begin_function
name|main
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"acucntrl is not supported on this system\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DIALINOUT */
end_comment

end_unit

