begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)conn.c	5.3 (Berkeley) 8/13/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSIII
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYSIII
end_ifndef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXC
value|1000
end_define

begin_decl_stmt
specifier|extern
name|jmp_buf
name|Sjbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parity control during login procedure */
end_comment

begin_define
define|#
directive|define
name|P_ZERO
value|0
end_define

begin_define
define|#
directive|define
name|P_ONE
value|1
end_define

begin_define
define|#
directive|define
name|P_EVEN
value|2
end_define

begin_define
define|#
directive|define
name|P_ODD
value|3
end_define

begin_decl_stmt
name|char
name|par_tab
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* must be power of two */
end_comment

begin_decl_stmt
name|int
name|next_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* predicted fd to close interrupted opens */
end_comment

begin_comment
comment|/* rti!trt, courtesy unc!smb */
end_comment

begin_comment
comment|/***  *	alarmtr()  -  catch alarm routine for "expect".  */
end_comment

begin_macro
name|alarmtr
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|next_fd
argument_list|)
condition|)
name|logent
argument_list|(
literal|"FAIL"
argument_list|,
literal|"ACU LINE CLOSE"
argument_list|)
expr_stmt|;
name|next_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|Sjbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*******  *	conn(system)  *	char *system;  *  *	conn - place a telephone call to system and  *	login, etc.  *  *	return codes:  *		CF_SYSTEM: don't know system  *		CF_TIME: wrong time to call  *		CF_DIAL: call failed  *		CF_NODEV: no devices available to place call  *		CF_LOGIN: login/password dialog failed  *  *>0  - file no.  -  connect ok  *  */
end_comment

begin_decl_stmt
name|int
name|Dcf
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_macro
name|conn
argument_list|(
argument|system
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|system
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ret
decl_stmt|,
name|nf
decl_stmt|;
specifier|register
name|int
name|fn
decl_stmt|,
name|fnd
decl_stmt|;
name|char
name|info
index|[
name|MAXC
index|]
decl_stmt|,
modifier|*
name|flds
index|[
name|MAXC
operator|/
literal|10
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fsys
decl_stmt|;
name|int
name|fcode
init|=
literal|0
decl_stmt|;
name|nf
operator|=
literal|0
expr_stmt|;
name|fnd
operator|=
literal|0
expr_stmt|;
name|fsys
operator|=
name|fopen
argument_list|(
name|SYSFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fsys
operator|!=
name|NULL
argument_list|,
literal|"CAN'T OPEN"
argument_list|,
name|SYSFILE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"finds %s\n"
argument_list|,
literal|"called"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nf
operator|=
name|finds
argument_list|(
name|fsys
argument_list|,
name|system
argument_list|,
name|info
argument_list|,
name|flds
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"getto %s\n"
argument_list|,
literal|"called"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fn
operator|=
name|getto
argument_list|(
name|flds
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
name|Dcf
operator|=
name|fn
expr_stmt|;
break|break;
block|}
name|fcode
operator|=
operator|(
name|fn
operator|==
name|FAIL
condition|?
name|CF_DIAL
else|:
name|fn
operator|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|<=
literal|0
condition|)
return|return
operator|(
name|fcode
condition|?
name|fcode
else|:
name|nf
operator|)
return|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"login %s\n"
argument_list|,
literal|"called"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|login
argument_list|(
name|nf
argument_list|,
name|flds
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|clsacu
argument_list|()
expr_stmt|;
return|return
operator|(
name|CF_LOGIN
operator|)
return|;
block|}
comment|/* rti!trt:  avoid passing file to children */
name|fioclex
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|fn
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	getto(flds)		connect to remote machine  *	char *flds[];  *  *	return codes:  *>0  -  file number - ok  *		FAIL  -  failed  */
end_comment

begin_expr_stmt
name|getto
argument_list|(
name|flds
argument_list|)
specifier|register
name|char
operator|*
name|flds
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|condev
modifier|*
name|cd
decl_stmt|;
name|int
name|nulldev
argument_list|()
decl_stmt|,
name|diropn
argument_list|()
decl_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"call: no. %s "
argument_list|,
name|flds
index|[
name|F_PHONE
index|]
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"for sys %s\n"
argument_list|,
name|flds
index|[
name|F_NAME
index|]
argument_list|)
expr_stmt|;
name|CU_end
operator|=
name|nulldev
expr_stmt|;
for|for
control|(
name|cd
operator|=
name|condevs
init|;
name|cd
operator|->
name|CU_meth
operator|!=
name|NULL
condition|;
name|cd
operator|++
control|)
block|{
if|if
condition|(
name|snccmp
argument_list|(
name|cd
operator|->
name|CU_meth
argument_list|,
name|flds
index|[
name|F_LINE
index|]
argument_list|)
operator|==
name|SAME
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Using %s to call\n"
argument_list|,
name|cd
operator|->
name|CU_meth
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
operator|(
name|cd
operator|->
name|CU_gen
operator|)
operator|)
operator|(
name|flds
operator|)
operator|)
return|;
block|}
block|}
name|logent
argument_list|(
name|flds
index|[
name|F_LINE
index|]
argument_list|,
literal|"getto: Can't find, using DIR"
argument_list|)
expr_stmt|;
return|return
operator|(
name|diropn
argument_list|(
name|flds
argument_list|)
operator|)
return|;
comment|/* search failed, so use direct */
block|}
end_block

begin_comment
comment|/***  *	clsacu()	close call unit  *  *	return codes:  none  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|CU_end
function_decl|)
parameter_list|()
init|=
name|nulldev
function_decl|;
end_function_decl

begin_macro
name|clsacu
argument_list|()
end_macro

begin_block
block|{
operator|(
operator|*
operator|(
name|CU_end
operator|)
operator|)
operator|(
name|Dcf
operator|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|Dcf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"fd %d NOT CLOSED by CU_clos\n"
argument_list|,
name|Dcf
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"clsacu"
argument_list|,
literal|"NOT CLOSED by CU_clos"
argument_list|)
expr_stmt|;
block|}
name|Dcf
operator|=
operator|-
literal|1
expr_stmt|;
name|CU_end
operator|=
name|nulldev
expr_stmt|;
block|}
end_block

begin_comment
comment|/***  *	exphone - expand phone number for given prefix and number  *  *	return code - none  */
end_comment

begin_expr_stmt
name|exphone
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
specifier|register
name|char
operator|*
name|in
operator|,
operator|*
name|out
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|FILE
modifier|*
name|fn
decl_stmt|;
name|char
name|pre
index|[
name|MAXPH
index|]
decl_stmt|,
name|npart
index|[
name|MAXPH
index|]
decl_stmt|,
name|tpre
index|[
name|MAXPH
index|]
decl_stmt|,
name|p
index|[
name|MAXPH
index|]
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s1
decl_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|in
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
expr_stmt|;
return|return;
block|}
name|s1
operator|=
name|pre
expr_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
operator|*
name|in
argument_list|)
condition|)
operator|*
name|s1
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
operator|*
name|s1
operator|=
literal|'\0'
expr_stmt|;
name|s1
operator|=
name|npart
expr_stmt|;
while|while
condition|(
operator|*
name|in
operator|!=
literal|'\0'
condition|)
operator|*
name|s1
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
operator|*
name|s1
operator|=
literal|'\0'
expr_stmt|;
name|tpre
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|fn
operator|=
name|fopen
argument_list|(
name|DIALFILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|DEBUG
argument_list|(
literal|2
argument_list|,
literal|"CAN'T OPEN %s\n"
argument_list|,
name|DIALFILE
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|cfgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|fn
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s%s"
argument_list|,
name|p
argument_list|,
name|tpre
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|pre
argument_list|)
operator|==
name|SAME
condition|)
goto|goto
name|found
goto|;
name|tpre
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|DEBUG
argument_list|(
literal|2
argument_list|,
literal|"CAN'T FIND dialcodes prefix '%s'\n"
argument_list|,
name|pre
argument_list|)
expr_stmt|;
name|found
label|:
empty_stmt|;
name|fclose
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|out
argument_list|,
name|tpre
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|out
argument_list|,
name|npart
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/***  *	rddev - read and decode a line from device file  *  *	return code - FAIL at end-of file; 0 otherwise  */
end_comment

begin_expr_stmt
name|rddev
argument_list|(
name|fp
argument_list|,
name|dev
argument_list|)
specifier|register
expr|struct
name|Devices
operator|*
name|dev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|fdig
parameter_list|()
function_decl|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|na
decl_stmt|;
if|if
condition|(
operator|!
name|cfgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|fp
argument_list|)
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
name|na
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s%s%s%s%s"
argument_list|,
name|dev
operator|->
name|D_type
argument_list|,
name|dev
operator|->
name|D_line
argument_list|,
name|dev
operator|->
name|D_calldev
argument_list|,
name|dev
operator|->
name|D_class
argument_list|,
name|dev
operator|->
name|D_brand
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|na
operator|>=
literal|4
argument_list|,
literal|"BAD DEVICE ENTRY"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|!=
literal|5
condition|)
name|dev
operator|->
name|D_brand
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dev
operator|->
name|D_speed
operator|=
name|atoi
argument_list|(
name|fdig
argument_list|(
name|dev
operator|->
name|D_class
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	finds(fsys, sysnam, info, flds)	set system attribute vector  *  *	return codes:  *>0  -  number of arguments in vector - succeeded  *		CF_SYSTEM  -  system name not found  *		CF_TIME  -  wrong time to call  */
end_comment

begin_macro
name|finds
argument_list|(
argument|fsys
argument_list|,
argument|sysnam
argument_list|,
argument|info
argument_list|,
argument|flds
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sysnam
decl_stmt|,
name|info
index|[]
decl_stmt|,
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fsys
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|sysn
index|[
literal|8
index|]
decl_stmt|;
name|int
name|na
decl_stmt|;
name|int
name|fcode
init|=
literal|0
decl_stmt|;
comment|/* format of fields 	 *	0 name; 	 *	1 time 	 *	2 acu/hardwired 	 *	3 speed 	 *	etc 	 */
while|while
condition|(
name|cfgets
argument_list|(
name|info
argument_list|,
name|MAXC
argument_list|,
name|fsys
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|na
operator|=
name|getargs
argument_list|(
name|info
argument_list|,
name|flds
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sysn
argument_list|,
literal|"%.7s"
argument_list|,
name|flds
index|[
name|F_NAME
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sysnam
argument_list|,
name|sysn
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
if|if
condition|(
name|ifdate
argument_list|(
name|flds
index|[
name|F_TIME
index|]
argument_list|)
condition|)
comment|/*  found a good entry  */
return|return
operator|(
name|na
operator|)
return|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Wrong time ('%s') to call\n"
argument_list|,
name|flds
index|[
name|F_TIME
index|]
argument_list|)
expr_stmt|;
name|fcode
operator|=
name|CF_TIME
expr_stmt|;
block|}
return|return
operator|(
name|fcode
condition|?
name|fcode
else|:
name|CF_SYSTEM
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	login(nf, flds, dcr)		do login conversation  *	char *flds[];  *	int nf;  *  *	return codes:  0  |  FAIL  */
end_comment

begin_expr_stmt
name|login
argument_list|(
name|nf
argument_list|,
name|flds
argument_list|,
name|fn
argument_list|)
specifier|register
name|char
operator|*
name|flds
index|[]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|nf
decl_stmt|,
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|want
decl_stmt|,
modifier|*
name|altern
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|int
name|k
decl_stmt|,
name|ok
decl_stmt|;
name|ASSERT
argument_list|(
name|nf
operator|>
literal|4
argument_list|,
literal|"TOO FEW LOG FIELDS"
argument_list|,
literal|""
argument_list|,
name|nf
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|F_LOGIN
init|;
name|k
operator|<
name|nf
condition|;
name|k
operator|+=
literal|2
control|)
block|{
name|want
operator|=
name|flds
index|[
name|k
index|]
expr_stmt|;
name|ok
operator|=
name|FAIL
expr_stmt|;
while|while
condition|(
name|ok
operator|!=
literal|0
condition|)
block|{
name|altern
operator|=
name|index
argument_list|(
name|want
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|altern
operator|!=
name|NULL
condition|)
operator|*
name|altern
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wanted %s "
argument_list|,
name|want
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
name|want
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|ok
condition|?
literal|"?"
else|:
literal|"that"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|altern
operator|==
name|NULL
condition|)
block|{
name|logent
argument_list|(
literal|"LOGIN"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
comment|/* close *not* needed here. rti!trt */
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|want
operator|=
name|index
argument_list|(
name|altern
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|want
operator|!=
name|NULL
condition|)
operator|*
name|want
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sendthem
argument_list|(
name|altern
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|+
literal|1
operator|<
name|nf
condition|)
name|sendthem
argument_list|(
name|flds
index|[
name|k
operator|+
literal|1
index|]
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* rti!trt: conditional table generation to support odd speeds */
end_comment

begin_comment
comment|/* Suggested in n44a.139 by n44!dan (Dan Ts'o) */
end_comment

begin_struct
struct|struct
name|sg_spds
block|{
name|int
name|sp_val
decl_stmt|,
name|sp_name
decl_stmt|;
block|}
name|spds
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|B50
block|{
literal|50
block|,
name|B50
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B75
block|{
literal|75
block|,
name|B75
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B110
block|{
literal|110
block|,
name|B110
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B150
block|{
literal|150
block|,
name|B150
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B200
block|{
literal|200
block|,
name|B200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B300
block|{
literal|300
block|,
name|B300
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B600
block|{
literal|600
block|,
name|B600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B1200
block|{
literal|1200
block|,
name|B1200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B1800
block|{
literal|1800
block|,
name|B1800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B2000
block|{
literal|2000
block|,
name|B2000
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B2400
block|{
literal|2400
block|,
name|B2400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B3600
block|{
literal|3600
block|,
name|B3600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B4800
block|{
literal|4800
block|,
name|B4800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B7200
block|{
literal|7200
block|,
name|B7200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B9600
block|{
literal|9600
block|,
name|B9600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B19200
block|{
literal|19200
block|,
name|B19200
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/***  *	fixline(tty, spwant)	set speed/echo/mode...  *	int tty, spwant;  *  *	return codes:  none  */
end_comment

begin_macro
name|fixline
argument_list|(
argument|tty
argument_list|,
argument|spwant
argument_list|)
end_macro

begin_decl_stmt
name|int
name|tty
decl_stmt|,
name|spwant
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|SYSIII
name|struct
name|termio
name|ttbuf
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SYSIII
name|struct
name|sgttyb
name|ttbuf
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|sg_spds
modifier|*
name|ps
decl_stmt|;
name|int
name|speed
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ret
decl_stmt|;
for|for
control|(
name|ps
operator|=
name|spds
init|;
name|ps
operator|->
name|sp_val
condition|;
name|ps
operator|++
control|)
if|if
condition|(
name|ps
operator|->
name|sp_val
operator|==
name|spwant
condition|)
name|speed
operator|=
name|ps
operator|->
name|sp_name
expr_stmt|;
name|ASSERT
argument_list|(
name|speed
operator|>=
literal|0
argument_list|,
literal|"BAD SPEED"
argument_list|,
literal|""
argument_list|,
name|speed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSIII
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
comment|/* ttbuf.sg_flags = (ANYP|RAW); 	ttbuf.sg_ispeed = ttbuf.sg_ospeed = speed; */
name|ttbuf
operator|.
name|c_iflag
operator|=
operator|(
name|ushort
operator|)
literal|0
expr_stmt|;
name|ttbuf
operator|.
name|c_oflag
operator|=
operator|(
name|ushort
operator|)
literal|0
expr_stmt|;
name|ttbuf
operator|.
name|c_cflag
operator|=
operator|(
name|speed
operator||
name|CS8
operator||
name|HUPCL
operator||
name|CREAD
operator|)
expr_stmt|;
name|ttbuf
operator|.
name|c_lflag
operator|=
operator|(
name|ushort
operator|)
literal|0
expr_stmt|;
name|ttbuf
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|6
expr_stmt|;
name|ttbuf
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SYSIII
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
name|ttbuf
operator|.
name|sg_flags
operator|=
operator|(
name|ANYP
operator||
name|RAW
operator|)
expr_stmt|;
name|ttbuf
operator|.
name|sg_ispeed
operator|=
name|ttbuf
operator|.
name|sg_ospeed
operator|=
name|speed
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|ret
operator|>=
literal|0
argument_list|,
literal|"RETURN FROM STTY"
argument_list|,
literal|""
argument_list|,
name|ret
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYSIII
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCHPCL
argument_list|,
name|STBNULL
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCEXCL
argument_list|,
name|STBNULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_block

begin_comment
comment|/* Bill Shannon recommends MR 2000, but that takes too much space on PDPs */
end_comment

begin_comment
comment|/* Actually, the 'expect' algorithm should be rewritten. */
end_comment

begin_define
define|#
directive|define
name|MR
value|1000
end_define

begin_comment
comment|/***  *	expect(str, fn)	look for expected string  *	char *str;  *  *	return codes:  *		0  -  found  *		FAIL  -  lost line or too many characters read  *		some character  -  timed out  */
end_comment

begin_expr_stmt
name|expect
argument_list|(
name|str
argument_list|,
name|fn
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|rdvec
index|[
name|MR
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|rp
init|=
name|rdvec
decl_stmt|;
name|int
name|kr
decl_stmt|;
name|char
name|nextch
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"\"\""
argument_list|)
operator|==
name|SAME
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|rp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
comment|/* change MAXCHARTIME to MAXMSGTIME, outside while loop -- brl-bmd!dpk */
name|alarm
argument_list|(
name|MAXMSGTIME
argument_list|)
expr_stmt|;
while|while
condition|(
name|notin
argument_list|(
name|str
argument_list|,
name|rdvec
argument_list|)
condition|)
block|{
name|kr
operator|=
name|read
argument_list|(
name|fn
argument_list|,
operator|&
name|nextch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|<=
literal|0
condition|)
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"lost line kr - %d\n, "
argument_list|,
name|kr
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"LOGIN"
argument_list|,
literal|"LOST LINE"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|nextch
operator|&
literal|0177
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|c
operator|>=
literal|040
condition|?
literal|"%c"
else|:
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|rp
operator|=
name|nextch
operator|&
literal|0177
operator|)
operator|!=
literal|'\0'
condition|)
name|rp
operator|++
expr_stmt|;
comment|/* Check rdvec before null termination -- cmcl2!salkind */
if|if
condition|(
name|rp
operator|>=
name|rdvec
operator|+
name|MR
condition|)
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
operator|*
name|rp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Determine next file descriptor that would be allocated.  * This permits later closing of a file whose open was interrupted.  * It is a UNIX kernel problem, but it has to be handled.  * unc!smb (Steve Bellovin) probably first discovered it.  */
end_comment

begin_macro
name|getnextfd
argument_list|()
end_macro

begin_block
block|{
name|close
argument_list|(
name|next_fd
operator|=
name|open
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***  *	sendthem(str, fn)	send line of login sequence  *	char *str;  *  *	return codes:  none  */
end_comment

begin_expr_stmt
name|sendthem
argument_list|(
name|str
argument_list|,
name|fn
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|strptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|cr
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|p_init
init|=
literal|0
decl_stmt|;
comment|/* Note: debugging authorized only for privileged users */
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"send %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_init
condition|)
block|{
name|p_init
operator|++
expr_stmt|;
name|bld_partab
argument_list|(
name|P_EVEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prefix
argument_list|(
literal|"BREAK"
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
operator|&
name|str
index|[
literal|5
index|]
argument_list|,
literal|"%1d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
literal|10
condition|)
name|i
operator|=
literal|3
expr_stmt|;
comment|/* send break */
name|genbrk
argument_list|(
name|fn
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prefix
argument_list|(
literal|"PAUSE"
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
operator|&
name|str
index|[
literal|5
index|]
argument_list|,
literal|"%1d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
literal|10
condition|)
name|i
operator|=
literal|3
expr_stmt|;
comment|/* pause for a while */
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"EOT"
argument_list|)
operator|==
name|SAME
condition|)
block|{
name|p_chwrite
argument_list|(
name|fn
argument_list|,
literal|'\04'
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* LF, CR, and "" courtesy unc!smb */
comment|/* Send a '\n' */
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"LF"
argument_list|)
operator|==
name|SAME
condition|)
name|str
operator|=
literal|"\\n\\c"
expr_stmt|;
comment|/* Send a '\r' */
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"CR"
argument_list|)
operator|==
name|SAME
condition|)
name|str
operator|=
literal|"\\r\\c"
expr_stmt|;
comment|/* Set parity as needed */
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"P_ZERO"
argument_list|)
operator|==
name|SAME
condition|)
block|{
name|bld_partab
argument_list|(
name|P_ZERO
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"P_ONE"
argument_list|)
operator|==
name|SAME
condition|)
block|{
name|bld_partab
argument_list|(
name|P_ONE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"P_EVEN"
argument_list|)
operator|==
name|SAME
condition|)
block|{
name|bld_partab
argument_list|(
name|P_EVEN
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"P_ODD"
argument_list|)
operator|==
name|SAME
condition|)
block|{
name|bld_partab
argument_list|(
name|P_ODD
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If "", just send '\r' */
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"\"\""
argument_list|)
operator|!=
name|SAME
condition|)
for|for
control|(
name|strptr
operator|=
name|str
init|;
operator|*
name|strptr
condition|;
name|strptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|strptr
operator|==
literal|'\\'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|strptr
condition|)
block|{
case|case
literal|'s'
case|:
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"BLANK\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|strptr
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"DELAY\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"RETURN\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|strptr
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
name|strptr
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|i
operator|=
operator|(
operator|*
operator|++
name|strptr
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
literal|10
condition|)
name|i
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|3
expr_stmt|;
comment|/* send break */
name|genbrk
argument_list|(
name|fn
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
if|if
condition|(
operator|*
operator|(
name|strptr
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"NO CR\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|cr
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"NO CR - MIDDLE IGNORED\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|isdigit
argument_list|(
name|strptr
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|strptr
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|++
name|n
operator|<=
literal|3
condition|)
name|i
operator|=
name|i
operator|*
literal|8
operator|+
operator|(
operator|*
operator|++
name|strptr
operator|-
literal|'0'
operator|)
expr_stmt|;
name|p_chwrite
argument_list|(
name|fn
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"BACKSLASH\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|strptr
operator|--
expr_stmt|;
block|}
name|p_chwrite
argument_list|(
name|fn
argument_list|,
operator|*
name|strptr
argument_list|)
expr_stmt|;
block|}
comment|/* '\n' changed to '\r'--a better default. rti!trt */
if|if
condition|(
name|cr
condition|)
name|p_chwrite
argument_list|(
name|fn
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|p_chwrite
argument_list|(
argument|fd
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|t
index|[
literal|2
index|]
decl_stmt|;
name|t
index|[
literal|0
index|]
operator|=
name|par_tab
index|[
name|c
operator|&
literal|0177
index|]
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ASSERT
argument_list|(
name|write
argument_list|(
name|fd
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
argument_list|,
literal|"BAD WRITE"
argument_list|,
literal|""
argument_list|,
name|t
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * generate parity table for use by p_chwrite.  */
end_comment

begin_macro
name|bld_partab
argument_list|(
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|par_tab
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|par_tab
argument_list|)
operator|-
literal|1
operator|)
init|;
name|j
condition|;
name|j
operator|=
operator|(
name|j
operator|-
literal|1
operator|)
operator|&
name|j
control|)
name|n
operator|++
expr_stmt|;
name|par_tab
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|P_ONE
operator|||
operator|(
name|type
operator|==
name|P_EVEN
operator|&&
operator|(
name|n
operator|&
literal|01
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|type
operator|==
name|P_ODD
operator|&&
operator|(
name|n
operator|&
literal|01
operator|)
operator|==
literal|0
operator|)
condition|)
name|par_tab
index|[
name|i
index|]
operator||=
sizeof|sizeof
argument_list|(
name|par_tab
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|BSPEED
value|B150
end_define

begin_comment
comment|/***  *	genbrk		send a break  *  *	return codes;  none  */
end_comment

begin_expr_stmt
name|genbrk
argument_list|(
name|fn
argument_list|,
name|bnulls
argument_list|)
specifier|register
name|int
name|fn
operator|,
name|bnulls
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|SYSIII
name|ret
operator|=
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TCSBRK
argument_list|,
name|STBNULL
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"break ioctl ret %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SYSIII
ifdef|#
directive|ifdef
name|TIOCSBRK
name|ret
operator|=
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCSBRK
argument_list|,
name|STBNULL
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"break ioctl ret %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCCBRK
name|ret
operator|=
name|write
argument_list|(
name|fn
argument_list|,
literal|"\0\0\0\0\0\0\0\0\0\0\0\0"
argument_list|,
name|bnulls
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ret
operator|>
literal|0
argument_list|,
literal|"BAD WRITE genbrk"
argument_list|,
literal|""
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCCBRK
argument_list|,
name|STBNULL
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"break ioctl ret %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"ioctl 1 second break\n"
argument_list|,
name|STBNULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|sgttyb
name|ttbuf
decl_stmt|;
specifier|register
name|int
name|sospeed
decl_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
name|sospeed
operator|=
name|ttbuf
operator|.
name|sg_ospeed
expr_stmt|;
name|ttbuf
operator|.
name|sg_ospeed
operator|=
name|BSPEED
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|fn
argument_list|,
literal|"\0\0\0\0\0\0\0\0\0\0\0\0"
argument_list|,
name|bnulls
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ret
operator|>
literal|0
argument_list|,
literal|"BAD WRITE genbrk"
argument_list|,
literal|""
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ttbuf
operator|.
name|sg_ospeed
operator|=
name|sospeed
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|fn
argument_list|,
literal|"@"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ret
operator|>
literal|0
argument_list|,
literal|"BAD WRITE genbrk"
argument_list|,
literal|""
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"sent BREAK nulls - %d\n"
argument_list|,
name|bnulls
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/***  *	notin(sh, lg)	check for occurrence of substring "sh"  *	char *sh, *lg;  *  *	return codes:  *		0  -  found the string  *		1  -  not in the string  */
end_comment

begin_expr_stmt
name|notin
argument_list|(
name|sh
argument_list|,
name|lg
argument_list|)
specifier|register
name|char
operator|*
name|sh
operator|,
operator|*
name|lg
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|lg
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Dave Martingale: permit wild cards in 'expect' */
if|if
condition|(
name|wprefix
argument_list|(
name|sh
argument_list|,
name|lg
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
name|lg
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******  *	ifdate(s)  *	char *s;  *  *	ittvax!swatt  *	Allow multiple date specifications separated by '|'.  *	Calls ifadate, formerly "ifdate".  *  *	return codes:  *		see ifadate  */
end_comment

begin_macro
name|ifdate
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|ret
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'|'
condition|?
operator|*
operator|++
name|p
else|:
operator|*
name|p
operator|)
condition|;
name|p
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'|'
argument_list|)
control|)
if|if
condition|(
name|ret
operator|=
name|ifadate
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******  *	ifadate(s)  *	char *s;  *  *	ifadate  -  this routine will check a string (s)  *	like "MoTu0800-1730" to see if the present  *	time is within the given limits.  *	SIDE EFFECT - Retrytime is set  *  *	String alternatives:  *		Wk - Mo thru Fr  *		zero or one time means all day  *		Any - any day  *  *	return codes:  *		0  -  not within limits  *		1  -  within limits  */
end_comment

begin_macro
name|ifadate
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|days
index|[]
init|=
block|{
literal|"Su"
block|,
literal|"Mo"
block|,
literal|"Tu"
block|,
literal|"We"
block|,
literal|"Th"
block|,
literal|"Fr"
block|,
literal|"Sa"
block|,
literal|0
block|}
decl_stmt|;
name|time_t
name|clock
decl_stmt|;
name|int
name|rtime
decl_stmt|;
name|int
name|i
decl_stmt|,
name|tl
decl_stmt|,
name|th
decl_stmt|,
name|tn
decl_stmt|,
name|flag
decl_stmt|,
name|dayok
init|=
literal|0
decl_stmt|;
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/*  pick up retry time for failures  */
comment|/*  global variable Retrytime is set here  */
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Retrytime
operator|=
name|RETRYTIME
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|sscanf
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|rtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
operator|||
name|rtime
operator|<
literal|5
condition|)
name|rtime
operator|=
literal|5
expr_stmt|;
name|Retrytime
operator|=
name|rtime
operator|*
literal|60
expr_stmt|;
block|}
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|days
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|prefix
argument_list|(
name|days
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
condition|)
if|if
condition|(
name|tp
operator|->
name|tm_wday
operator|==
name|i
condition|)
name|dayok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|prefix
argument_list|(
literal|"Wk"
argument_list|,
name|s
argument_list|)
condition|)
if|if
condition|(
name|tp
operator|->
name|tm_wday
operator|>=
literal|1
operator|&&
name|tp
operator|->
name|tm_wday
operator|<=
literal|5
condition|)
name|dayok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prefix
argument_list|(
literal|"Any"
argument_list|,
name|s
argument_list|)
condition|)
name|dayok
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dayok
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i
operator|=
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%d-%d"
argument_list|,
operator|&
name|tl
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
name|tn
operator|=
name|tp
operator|->
name|tm_hour
operator|*
literal|100
operator|+
name|tp
operator|->
name|tm_min
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|th
operator|<
name|tl
condition|)
name|flag
operator|=
literal|0
expr_stmt|;
comment|/* set up for crossover 2400 test */
else|else
name|flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|tn
operator|>=
name|tl
operator|&&
name|tn
operator|<=
name|th
operator|)
operator|||
operator|(
name|tn
operator|>=
name|th
operator|&&
name|tn
operator|<=
name|tl
operator|)
condition|)
comment|/* test for crossover 2400 */
return|return
operator|(
name|flag
operator|)
return|;
else|else
return|return
operator|(
operator|!
name|flag
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	char *  *	lastc(s)	return pointer to last character  *	char *s;  *  */
end_comment

begin_function
name|char
modifier|*
name|lastc
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/***  *	char *  *	fdig(cp)	find first digit in string  *  *	return - pointer to first digit in string or end of string  */
end_comment

begin_function
name|char
modifier|*
name|fdig
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|cp
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|*
name|c
operator|>=
literal|'0'
operator|&&
operator|*
name|c
operator|<=
literal|'9'
condition|)
break|break;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare strings:  s1>s2:>0  s1==s2: 0  s1<s2:<0  * Strings are compared as if they contain all capital letters.  */
end_comment

begin_expr_stmt
name|snccmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
name|islower
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
name|c1
operator|=
name|toupper
argument_list|(
operator|*
name|s1
argument_list|)
expr_stmt|;
else|else
name|c1
operator|=
operator|*
name|s1
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
name|c2
operator|=
name|toupper
argument_list|(
operator|*
name|s2
argument_list|)
expr_stmt|;
else|else
name|c2
operator|=
operator|*
name|s2
expr_stmt|;
while|while
condition|(
name|c1
operator|==
name|c2
condition|)
block|{
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s2
operator|++
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
name|c1
operator|=
name|toupper
argument_list|(
operator|*
name|s1
argument_list|)
expr_stmt|;
else|else
name|c1
operator|=
operator|*
name|s1
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
name|c2
operator|=
name|toupper
argument_list|(
operator|*
name|s2
argument_list|)
expr_stmt|;
else|else
name|c2
operator|=
operator|*
name|s2
expr_stmt|;
block|}
return|return
operator|(
name|c1
operator|-
name|c2
operator|)
return|;
block|}
end_block

end_unit

